<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>63.&nbsp;Deploying to the Cloud</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Spring Boot Reference Guide"><link rel="up" href="deployment.html" title="Part&nbsp;VI.&nbsp;Deploying Spring Boot Applications"><link rel="prev" href="deployment.html" title="Part&nbsp;VI.&nbsp;Deploying Spring Boot Applications"><link rel="next" href="deployment-install.html" title="64.&nbsp;Installing Spring Boot Applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">63.&nbsp;Deploying to the Cloud</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="deployment.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;VI.&nbsp;Deploying Spring Boot Applications</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="deployment-install.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="cloud-deployment" href="#cloud-deployment"></a>63.&nbsp;Deploying to the Cloud</h2></div></div></div><p>Spring Boot&#8217;s executable jars are ready-made for most popular cloud PaaS
(Platform-as-a-Service) providers. These providers tend to require that you
&#8220;bring your own container&#8221;. They manage application processes (not Java applications
specifically), so they need an intermediary layer that adapts <span class="emphasis"><em>your</em></span> application to the
<span class="emphasis"><em>cloud&#8217;s</em></span> notion of a running process.</p><p>Two popular cloud providers, Heroku and Cloud Foundry, employ a &#8220;buildpack&#8221; approach.
The buildpack wraps your deployed code in whatever is needed to <span class="emphasis"><em>start</em></span> your application.
It might be a JDK and a call to <code class="literal">java</code>, an embedded web server, or a full-fledged
application server. A buildpack is pluggable, but ideally you should be able to get by
with as few customizations to it as possible. This reduces the footprint of functionality
that is not under your control. It minimizes divergence between development and production
environments.</p><p>Ideally, your application, like a Spring Boot executable jar, has everything that it needs
to run packaged within it.</p><p>In this section, we look at what it takes to get the
<a class="link" href="getting-started-first-application.html" title="11.&nbsp;Developing Your First Spring Boot Application">simple application that we
developed</a> in the &#8220;Getting Started&#8221; section up and running in the Cloud.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-cloud-foundry" href="#cloud-deployment-cloud-foundry"></a>63.1&nbsp;Cloud Foundry</h2></div></div></div><p>Cloud Foundry provides default buildpacks that come into play if no other buildpack is
specified. The Cloud Foundry <a class="link" href="https://github.com/cloudfoundry/java-buildpack" target="_top">Java
buildpack</a> has excellent support for Spring applications, including Spring Boot. You can
deploy stand-alone executable jar applications as well as traditional <code class="literal">.war</code> packaged
applications.</p><p>Once you have built your application (by using, for example, <code class="literal">mvn clean package</code>) and have
<a class="link" href="https://docs.cloudfoundry.org/cf-cli/install-go-cli.html" target="_top">installed the <code class="literal">cf</code>
command line tool</a>, deploy your application by using the <code class="literal">cf push</code> command, substituting
the path to your compiled <code class="literal">.jar</code>. Be sure to have
<a class="link" href="https://docs.cloudfoundry.org/cf-cli/getting-started.html#login" target="_top">logged in with
your <code class="literal">cf</code> command line client</a> before pushing an application. The following line shows
using the <code class="literal">cf push</code> command to deploy an application:</p><pre class="screen">$ cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In the preceding example, we substitute <code class="literal">acloudyspringtime</code> for whatever value you
give <code class="literal">cf</code> as the name of your application.</p></td></tr></table></div><p>See the <a class="link" href="https://docs.cloudfoundry.org/cf-cli/getting-started.html#push" target="_top"><code class="literal">cf push</code>
documentation</a> for more options. If there is a Cloud Foundry
<a class="link" href="https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html" target="_top"><code class="literal">manifest.yml</code></a>
file present in the same directory, it is considered.</p><p>At this point, <code class="literal">cf</code> starts uploading your application, producing output similar to the
following example:</p><pre class="screen">Uploading acloudyspringtime... <span class="strong"><strong>OK</strong></span>
Preparing to start acloudyspringtime... <span class="strong"><strong>OK</strong></span>
-----&gt; Downloaded app package (<span class="strong"><strong>8.9M</strong></span>)
-----&gt; Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e
-----&gt; Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found in cache)
       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)
-----&gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)
       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K
-----&gt; Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache)
       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)
-----&gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)
Checking status of app 'acloudyspringtime'...
  0 of 1 instances running (1 starting)
  ...
  0 of 1 instances running (1 starting)
  ...
  0 of 1 instances running (1 starting)
  ...
  1 of 1 instances running (1 running)

App started</pre><p>Congratulations! The application is now live!</p><p>Once your application is live, you can verify the status of the deployed application by
using the <code class="literal">cf apps</code> command, as shown in the following example:</p><pre class="screen">$ cf apps
Getting applications in ...
OK

name                 requested state   instances   memory   disk   urls
...
acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io
...</pre><p>Once Cloud Foundry acknowledges that your application has been deployed, you should be
able to find the application at the URI given. In the preceding example, you could find
it at <code class="literal">https://acloudyspringtime.cfapps.io/</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cloud-deployment-cloud-foundry-services" href="#cloud-deployment-cloud-foundry-services"></a>63.1.1&nbsp;Binding to Services</h3></div></div></div><p>By default, metadata about the running application as well as service connection
information is exposed to the application as environment variables (for example:
<code class="literal">$VCAP_SERVICES</code>). This architecture decision is due to Cloud Foundry&#8217;s polyglot (any
language and platform can be supported as a buildpack) nature. Process-scoped environment
variables are language agnostic.</p><p>Environment variables do not always make for the easiest API, so Spring Boot automatically
extracts them and flattens the data into properties that can be accessed through Spring&#8217;s
<code class="literal">Environment</code> abstraction, as shown in the following example:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Component</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyBean <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> EnvironmentAware {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String instanceId;

	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Override</xslthl:annotation>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setEnvironment(Environment environment) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.instanceId = environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"vcap.application.instance_id"</span>);
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>

}</pre><p>All Cloud Foundry properties are prefixed with <code class="literal">vcap</code>. You can use <code class="literal">vcap</code> properties to
access application information (such as the public URL of the application) and service
information (such as database credentials). See the
<a class="link" href="https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/api/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html" target="_top">&#8216;CloudFoundryVcapEnvironmentPostProcessor&#8217;</a>
Javadoc for complete details.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The <a class="link" href="https://cloud.spring.io/spring-cloud-connectors/" target="_top">Spring Cloud Connectors</a> project
is a better fit for tasks such as configuring a DataSource. Spring Boot includes
auto-configuration support and a <code class="literal">spring-boot-starter-cloud-connectors</code> starter.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-heroku" href="#cloud-deployment-heroku"></a>63.2&nbsp;Heroku</h2></div></div></div><p>Heroku is another popular PaaS platform. To customize Heroku builds, you provide a
<code class="literal">Procfile</code>, which provides the incantation required to deploy an application. Heroku
assigns a <code class="literal">port</code> for the Java application to use and then ensures that routing to the
external URI works.</p><p>You must configure your application to listen on the correct port. The following example
shows the <code class="literal">Procfile</code> for our starter REST application:</p><pre class="screen">web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</pre><p>Spring Boot makes <code class="literal">-D</code> arguments available as properties accessible from a Spring
<code class="literal">Environment</code> instance. The <code class="literal">server.port</code> configuration property is fed to the embedded
Tomcat, Jetty, or Undertow instance, which then uses the port when it starts up. The <code class="literal">$PORT</code>
environment variable is assigned to us by the Heroku PaaS.</p><p>This should be everything you need. The most common deployment workflow for Heroku
deployments is to <code class="literal">git push</code> the code to production, as shown in the following example:</p><pre class="screen">$ git push heroku master

Initializing repository, <span class="strong"><strong>done</strong></span>.
Counting objects: 95, <span class="strong"><strong>done</strong></span>.
Delta compression using up to 8 threads.
Compressing objects: 100% (78/78), <span class="strong"><strong>done</strong></span>.
Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, <span class="strong"><strong>done</strong></span>.
Total 95 (delta 31), reused 0 (delta 0)

-----&gt; Java app detected
-----&gt; Installing OpenJDK 1.8... <span class="strong"><strong>done</strong></span>
-----&gt; Installing Maven 3.3.1... <span class="strong"><strong>done</strong></span>
-----&gt; Installing settings.xml... <span class="strong"><strong>done</strong></span>
-----&gt; Executing: mvn -B -DskipTests=true clean install

       [INFO] Scanning for projects...
       Downloading: https://repo.spring.io/...
       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)
		....
       Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)
       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...
       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...
       [INFO] ------------------------------------------------------------------------
       [INFO] <span class="strong"><strong>BUILD SUCCESS</strong></span>
       [INFO] ------------------------------------------------------------------------
       [INFO] Total time: 59.358s
       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014
       [INFO] Final Memory: 20M/493M
       [INFO] ------------------------------------------------------------------------

-----&gt; Discovering process types
       Procfile declares types -&gt; <span class="strong"><strong>web</strong></span>

-----&gt; Compressing... <span class="strong"><strong>done</strong></span>, 70.4MB
-----&gt; Launching... <span class="strong"><strong>done</strong></span>, v6
       https://agile-sierra-1405.herokuapp.com/ <span class="strong"><strong>deployed to Heroku</strong></span>

To git@heroku.com:agile-sierra-1405.git
 * [new branch]      master -&gt; master</pre><p>Your application should now be up and running on Heroku.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-openshift" href="#cloud-deployment-openshift"></a>63.3&nbsp;OpenShift</h2></div></div></div><p><a class="link" href="https://www.openshift.com/" target="_top">OpenShift</a> is the Red Hat public (and enterprise) extension of
the Kubernetes container orchestration platform. Similarly to Kubernetes, OpenShift has
many options for installing Spring Boot based applications.</p><p>OpenShift has many resources describing how to deploy Spring Boot applications, including:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/" target="_top">Using the S2I builder</a></li><li class="listitem"><a class="link" href="https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/" target="_top">Architecture guide</a></li><li class="listitem"><a class="link" href="https://blog.openshift.com/using-spring-boot-on-openshift/" target="_top">Running as a traditional web application on Wildfly</a></li><li class="listitem"><a class="link" href="https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/" target="_top">OpenShift Commons Briefing</a></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-aws" href="#cloud-deployment-aws"></a>63.4&nbsp;Amazon Web Services (AWS)</h2></div></div></div><p>Amazon Web Services offers multiple ways to install Spring Boot-based applications, either
as traditional web applications (war) or as executable jar files with an embedded web
server. The options include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">AWS Elastic Beanstalk</li><li class="listitem">AWS Code Deploy</li><li class="listitem">AWS OPS Works</li><li class="listitem">AWS Cloud Formation</li><li class="listitem">AWS Container Registry</li></ul></div><p>Each has different features and pricing models. In this document, we describe only the
simplest option: AWS Elastic Beanstalk.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_aws_elastic_beanstalk" href="#_aws_elastic_beanstalk"></a>63.4.1&nbsp;AWS Elastic Beanstalk</h3></div></div></div><p>As described in the official
<a class="link" href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html" target="_top">Elastic
Beanstalk Java guide</a>, there are two main options to deploy a Java application. You can
either use the &#8220;Tomcat Platform&#8221; or the &#8220;Java SE platform&#8221;.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_using_the_tomcat_platform" href="#_using_the_tomcat_platform"></a>Using the Tomcat Platform</h4></div></div></div><p>This option applies to Spring Boot projects that produce a war file. No
special configuration is required. You need only follow the official guide.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_using_the_java_se_platform" href="#_using_the_java_se_platform"></a>Using the Java SE Platform</h4></div></div></div><p>This option applies to Spring Boot projects that produce a jar file and run an embedded
web container. Elastic Beanstalk environments run an nginx instance on port 80 to proxy
the actual application, running on port 5000. To configure it, add the following line to
your <code class="literal">application.properties</code> file:</p><pre class="screen">server.port=5000</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Upload binaries instead of sources"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Upload binaries instead of sources</th></tr><tr><td align="left" valign="top"><p>By default, Elastic Beanstalk uploads sources and compiles them in AWS. However, it is
best to upload the binaries instead. To do so, add lines similar to the following to your
<code class="literal">.elasticbeanstalk/config.yml</code> file:</p><pre class="programlisting">deploy:
	artifact: target/demo-0.0.1-SNAPSHOT.jar</pre></td></tr></table></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Reduce costs by setting the environment type"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Reduce costs by setting the environment type</th></tr><tr><td align="left" valign="top"><p>By default an Elastic Beanstalk environment is load balanced. The load balancer has a
significant cost. To avoid that cost, set the environment type to &#8220;Single instance&#8221;, as
described in
<a class="link" href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity" target="_top">the
Amazon documentation</a>. You can also create single instance environments by using the CLI
and the following command:</p><pre class="screen">eb create -s</pre></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_summary" href="#_summary"></a>63.4.2&nbsp;Summary</h3></div></div></div><p>This is one of the easiest ways to get to AWS, but there are more things to cover, such as
how to integrate Elastic Beanstalk into any CI / CD tool, use the Elastic Beanstalk Maven
plugin instead of the CLI, and others. There is a
<a class="link" href="https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/" target="_top">blog post</a> covering these topics more in detail.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-boxfuse" href="#cloud-deployment-boxfuse"></a>63.5&nbsp;Boxfuse and Amazon Web Services</h2></div></div></div><p><a class="link" href="https://boxfuse.com/" target="_top">Boxfuse</a> works by turning your Spring Boot executable jar or war
into a minimal VM image that can be deployed unchanged either on VirtualBox or on AWS.
Boxfuse comes with deep integration for Spring Boot and uses the information from your
Spring Boot configuration file to automatically configure ports and health check URLs.
Boxfuse leverages this information both for the images it produces as well as for all the
resources it provisions (instances, security groups, elastic load balancers, and so on).</p><p>Once you have created a <a class="link" href="https://console.boxfuse.com" target="_top">Boxfuse account</a>, connected it to
your AWS account, installed the latest version of the Boxfuse Client, and ensured that
the application has been built by Maven or Gradle (by using, for example, <code class="literal">mvn clean
package</code>), you can deploy your Spring Boot application to AWS with a command similar to
the following:</p><pre class="screen">$ boxfuse run myapp-1.0.jar -env=prod</pre><p>See the <a class="link" href="https://boxfuse.com/docs/commandline/run.html" target="_top"><code class="literal">boxfuse run</code> documentation</a> for
more options. If there is a <a class="link" href="https://boxfuse.com/docs/commandline/#configuration" target="_top"><code class="literal">boxfuse.conf</code></a> file present in the current directory, it is considered.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>By default, Boxfuse activates a Spring profile named <code class="literal">boxfuse</code> on startup. If your
executable jar or war contains an
<a class="link" href="https://boxfuse.com/docs/payloads/springboot.html#configuration" target="_top"><code class="literal">application-boxfuse.properties</code></a> file, Boxfuse bases its configuration on the
properties it contains.</p></td></tr></table></div><p>At this point, <code class="literal">boxfuse</code> creates an image for your application, uploads it, and configures
and starts the necessary resources on AWS, resulting in output similar to the following
example:</p><pre class="screen">Fusing Image for myapp-1.0.jar ...
Image fused in 00:06.838s (53937 K) -&gt; axelfontaine/myapp:1.0
Creating axelfontaine/myapp ...
Pushing axelfontaine/myapp:1.0 ...
Verifying axelfontaine/myapp:1.0 ...
Creating Elastic IP ...
Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...
Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...
AMI created in 00:23.557s -&gt; ami-d23f38cf
Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ...
Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...
Instance launched in 00:30.306s -&gt; i-92ef9f53
Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at https://52.28.235.61/ ...
Payload started in 00:29.266s -&gt; https://52.28.235.61/
Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...
Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...
Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at https://myapp-axelfontaine.boxfuse.io/</pre><p>Your application should now be up and running on AWS.</p><p>See the blog post on <a class="link" href="https://boxfuse.com/blog/spring-boot-ec2.html" target="_top">deploying Spring Boot
apps on EC2</a> as well as the
<a class="link" href="https://boxfuse.com/docs/payloads/springboot.html" target="_top">documentation for the Boxfuse Spring
Boot integration</a> to get started with a Maven build to run the app.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cloud-deployment-gae" href="#cloud-deployment-gae"></a>63.6&nbsp;Google Cloud</h2></div></div></div><p>Google Cloud has several options that can be used to launch Spring Boot applications.
The easiest to get started with is probably App Engine, but you could also find ways to
run Spring Boot in a container with Container Engine or on a virtual machine with
Compute Engine.</p><p>To run in App Engine, you can create a project in the UI first, which sets up a unique
identifier for you and also sets up HTTP routes. Add a Java app to the project and leave
it empty and then use the <a class="link" href="https://cloud.google.com/sdk/downloads" target="_top">Google Cloud SDK</a> to
push your Spring Boot app into that slot from the command line or CI build.</p><p>App Engine Standard requires you to use WAR packaging. Follow
<a class="link" href="https://github.com/GoogleCloudPlatform/getting-started-java/blob/master/appengine-standard-java8/springboot-appengine-standard/README.md" target="_top">these steps</a>
to deploy App Engine Standard application to Google Cloud.</p><p>Alternatively, App Engine Flex requires you to create an <code class="literal">app.yaml</code> file to describe
the resources your app requires. Normally, you put this file in <code class="literal">src/main/appengine</code>,
and it should resemble the following file:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">service</span>: default

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">runtime</span>: java
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">env</span>: flex

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">runtime_config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  jdk</span>: openjdk8

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">handlers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">- url</span>: /.*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  script</span>: this field is required<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> but ignored

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">manual_scaling</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  instances</span>: <xslthl:number xmlns:xslthl="http://xslthl.sourceforge.net/">1</xslthl:number>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">health_check</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  enable_health_check</span>: False

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">env_variables</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ENCRYPT_KEY</span>: your_encryption_key_here</pre><p>You can deploy the app (for example, with a Maven plugin) by adding the project ID to the
build configuration, as shown in the following example:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.google.cloud.tools<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>appengine-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>1.3.0<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;project&gt;</span>myproject<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/project&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>Then deploy with <code class="literal">mvn appengine:deploy</code> (if you need to authenticate first, the build
fails).</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="deployment.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="deployment.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="deployment-install.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;VI.&nbsp;Deploying Spring Boot Applications&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;64.&nbsp;Installing Spring Boot Applications</td></tr></table></div></body></html>