<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>36.&nbsp;Calling REST Services with WebClient</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Spring Boot Reference Guide"><link rel="up" href="boot-features.html" title="Part&nbsp;IV.&nbsp;Spring Boot features"><link rel="prev" href="boot-features-resttemplate.html" title="35.&nbsp;Calling REST Services with RestTemplate"><link rel="next" href="boot-features-validation.html" title="37.&nbsp;Validation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">36.&nbsp;Calling REST Services with <code class="literal">WebClient</code></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="boot-features-resttemplate.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Spring Boot features</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="boot-features-validation.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="boot-features-webclient" href="#boot-features-webclient"></a>36.&nbsp;Calling REST Services with <code class="literal">WebClient</code></h2></div></div></div><p>If you have Spring WebFlux on your classpath, you can also choose to use <code class="literal">WebClient</code> to
call remote REST services. Compared to <code class="literal">RestTemplate</code>, this client has a more functional
feel and is fully reactive. You can learn more about the <code class="literal">WebClient</code> in the dedicated
<a class="link" href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_top">section in the Spring Framework docs</a>.</p><p>Spring Boot creates and pre-configures a <code class="literal">WebClient.Builder</code> for you; it is strongly
advised to inject it in your components and use it to create <code class="literal">WebClient</code> instances.
Spring Boot is configuring that builder to share HTTP resources, reflect codecs
setup in the same fashion as the server ones (see
<a class="link" href="boot-features-developing-web-applications.html#boot-features-webflux-httpcodecs" title="29.2.2&nbsp;HTTP Codecs with HttpMessageReaders and HttpMessageWriters">WebFlux HTTP codecs auto-configuration</a>), and more.</p><p>The following code shows a typical example:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Service</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyService {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> WebClient webClient;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyService(WebClient.Builder webClientBuilder) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.webClient = webClientBuilder.baseUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://example.org"</span>).build();
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;Details&gt; someRestCall(String name) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.webClient.get().uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/{name}/details"</span>, name)
						.retrieve().bodyToMono(Details.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
	}

}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-webclient-runtime" href="#boot-features-webclient-runtime"></a>36.1&nbsp;WebClient Runtime</h2></div></div></div><p>Spring Boot will auto-detect which <code class="literal">ClientHttpConnector</code> to use to drive <code class="literal">WebClient</code>,
depending on the libraries available on the application classpath. For now, Reactor
Netty and Jetty RS client are supported.</p><p>The <code class="literal">spring-boot-starter-webflux</code> starter depends on <code class="literal">io.projectreactor.netty:reactor-netty</code>
by default, which brings both server and client implementations. If you choose to use Jetty
as a reactive server instead, you should add a dependency on the Jetty Reactive HTTP
client library, <code class="literal">org.eclipse.jetty:jetty-reactive-httpclient</code>. Using the same technology
for server and client has it advantages, as it will automatically share HTTP resources
between client and server.</p><p>Developers can override the resource configuration for Jetty and Reactor Netty by providing
a custom <code class="literal">ReactorResourceFactory</code> or <code class="literal">JettyResourceFactory</code> bean - this will be applied to
both clients and servers.</p><p>If you wish to override that choice for the client, you can define your own
<code class="literal">ClientHttpConnector</code> bean and have full control over the client configuration.</p><p>You can learn more about the
<a class="link" href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_top"><code class="literal">WebClient</code> configuration
options in the Spring Framework reference documentation</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-webclient-customization" href="#boot-features-webclient-customization"></a>36.2&nbsp;WebClient Customization</h2></div></div></div><p>There are three main approaches to <code class="literal">WebClient</code> customization, depending on how broadly you
want the customizations to apply.</p><p>To make the scope of any customizations as narrow as possible, inject the auto-configured
<code class="literal">WebClient.Builder</code> and then call its methods as required. <code class="literal">WebClient.Builder</code> instances
are stateful: Any change on the builder is reflected in all clients subsequently created
with it. If you want to create several clients with the same builder, you can also
consider cloning the builder with <code class="literal">WebClient.Builder other = builder.clone();</code>.</p><p>To make an application-wide, additive customization to all <code class="literal">WebClient.Builder</code> instances,
you can declare <code class="literal">WebClientCustomizer</code> beans and change the <code class="literal">WebClient.Builder</code> locally at
the point of injection.</p><p>Finally, you can fall back to the original API and use <code class="literal">WebClient.create()</code>. In that case,
no auto-configuration or <code class="literal">WebClientCustomizer</code> is applied.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="boot-features-resttemplate.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="boot-features.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="boot-features-validation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">35.&nbsp;Calling REST Services with <code class="literal">RestTemplate</code>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;37.&nbsp;Validation</td></tr></table></div></body></html>