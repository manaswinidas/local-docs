<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>49.&nbsp;Creating Your Own Auto-configuration</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Spring Boot Reference Guide"><link rel="up" href="boot-features.html" title="Part&nbsp;IV.&nbsp;Spring Boot features"><link rel="prev" href="boot-features-webservices.html" title="48.&nbsp;Web Services"><link rel="next" href="boot-features-kotlin.html" title="50.&nbsp;Kotlin support"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">49.&nbsp;Creating Your Own Auto-configuration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="boot-features-webservices.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Spring Boot features</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="boot-features-kotlin.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="boot-features-developing-auto-configuration" href="#boot-features-developing-auto-configuration"></a>49.&nbsp;Creating Your Own Auto-configuration</h2></div></div></div><p>If you work in a company that develops shared libraries, or if you work on an open-source
or commercial library, you might want to develop your own auto-configuration.
Auto-configuration classes can be bundled in external jars and still be picked-up by
Spring Boot.</p><p>Auto-configuration can be associated to a &#8220;starter&#8221; that provides the auto-configuration
code as well as the typical libraries that you would use with it. We first cover what
you need to know to build your own auto-configuration and then we move on to the
<a class="link" href="boot-features-developing-auto-configuration.html#boot-features-custom-starter" title="49.5&nbsp;Creating Your Own Starter">typical steps required to create a custom starter</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>A <a class="link" href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration" target="_top">demo
project</a> is available to showcase how you can create a starter step-by-step.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-understanding-auto-configured-beans" href="#boot-features-understanding-auto-configured-beans"></a>49.1&nbsp;Understanding Auto-configured Beans</h2></div></div></div><p>Under the hood, auto-configuration is implemented with standard <code class="literal">@Configuration</code> classes.
Additional <code class="literal">@Conditional</code> annotations are used to constrain when the auto-configuration
should apply. Usually, auto-configuration classes use <code class="literal">@ConditionalOnClass</code> and
<code class="literal">@ConditionalOnMissingBean</code> annotations. This ensures that auto-configuration applies
only when relevant classes are found and when you have not declared your own
<code class="literal">@Configuration</code>.</p><p>You can browse the source code of <a class="link" href="https://github.com/spring-projects/spring-boot/tree/v2.1.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure" target="_top"><code class="literal">spring-boot-autoconfigure</code></a>
to see the <code class="literal">@Configuration</code> classes that Spring provides (see the
<a class="link" href="https://github.com/spring-projects/spring-boot/tree/v2.1.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories" target="_top"><code class="literal">META-INF/spring.factories</code></a>
file).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-locating-auto-configuration-candidates" href="#boot-features-locating-auto-configuration-candidates"></a>49.2&nbsp;Locating Auto-configuration Candidates</h2></div></div></div><p>Spring Boot checks for the presence of a <code class="literal">META-INF/spring.factories</code> file within your
published jar. The file should list your configuration classes under the
<code class="literal">EnableAutoConfiguration</code> key, as shown in the following example:</p><pre class="screen">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Auto-configurations must be loaded that way <span class="emphasis"><em>only</em></span>. Make sure that they are defined in
a specific package space and that they are never the target of component scanning.
Furthermore, auto-configuration classes should not enable component scanning to find
additional components. Specific <code class="literal">@Import</code>s should be used instead.</p></td></tr></table></div><p>You can use the
<a class="link" href="https://github.com/spring-projects/spring-boot/tree/v2.1.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java" target="_top"><code class="literal">@AutoConfigureAfter</code></a> or
<a class="link" href="https://github.com/spring-projects/spring-boot/tree/v2.1.4.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java" target="_top"><code class="literal">@AutoConfigureBefore</code></a>
annotations if your configuration needs to be applied in a specific order. For example,
if you provide web-specific configuration, your class may need to be applied after
<code class="literal">WebMvcAutoConfiguration</code>.</p><p>If you want to order certain auto-configurations that should not have any direct
knowledge of each other, you can also use <code class="literal">@AutoConfigureOrder</code>. That annotation has the
same semantic as the regular <code class="literal">@Order</code> annotation but provides a dedicated order for
auto-configuration classes.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-condition-annotations" href="#boot-features-condition-annotations"></a>49.3&nbsp;Condition Annotations</h2></div></div></div><p>You almost always want to include one or more <code class="literal">@Conditional</code> annotations on your
auto-configuration class. The <code class="literal">@ConditionalOnMissingBean</code> annotation is one common
example that is used to allow developers to override auto-configuration if they are
not happy with your defaults.</p><p>Spring Boot includes a number of <code class="literal">@Conditional</code> annotations that you can reuse in your
own code by annotating <code class="literal">@Configuration</code> classes or individual <code class="literal">@Bean</code> methods. These
annotations include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-class-conditions" title="49.3.1&nbsp;Class Conditions">Section&nbsp;49.3.1, &#8220;Class Conditions&#8221;</a></li><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-bean-conditions" title="49.3.2&nbsp;Bean Conditions">Section&nbsp;49.3.2, &#8220;Bean Conditions&#8221;</a></li><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-property-conditions" title="49.3.3&nbsp;Property Conditions">Section&nbsp;49.3.3, &#8220;Property Conditions&#8221;</a></li><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-resource-conditions" title="49.3.4&nbsp;Resource Conditions">Section&nbsp;49.3.4, &#8220;Resource Conditions&#8221;</a></li><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-web-application-conditions" title="49.3.5&nbsp;Web Application Conditions">Section&nbsp;49.3.5, &#8220;Web Application Conditions&#8221;</a></li><li class="listitem"><a class="xref" href="boot-features-developing-auto-configuration.html#boot-features-spel-conditions" title="49.3.6&nbsp;SpEL Expression Conditions">Section&nbsp;49.3.6, &#8220;SpEL Expression Conditions&#8221;</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-class-conditions" href="#boot-features-class-conditions"></a>49.3.1&nbsp;Class Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnClass</code> and <code class="literal">@ConditionalOnMissingClass</code> annotations let
<code class="literal">@Configuration</code> classes be included based on the presence or absence of specific classes.
Due to the fact that annotation metadata is parsed by using <a class="link" href="https://asm.ow2.org/" target="_top">ASM</a>, you
can use the <code class="literal">value</code> attribute to refer to the real class, even though that class might not
actually appear on the running application classpath. You can also use the <code class="literal">name</code>
attribute if you prefer to specify the class name by using a <code class="literal">String</code> value.</p><p>This mechanism does not apply the same way to <code class="literal">@Bean</code> methods where typically the return
type is the target of the condition: before the condition on the method applies, the JVM
will have loaded the class and potentially processed method references which will fail if
the class is not present.</p><p>To handle this scenario, a separate <code class="literal">@Configuration</code> class can be used to isolate the
condition, as shown in the following example:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Configuration</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Some conditions</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyAutoConfiguration {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Auto-configured beans</span>

	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Configuration</xslthl:annotation>
	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@ConditionalOnClass(EmbeddedAcmeService.class)</xslthl:annotation>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> EmbeddedConfiguration {

		<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Bean</xslthl:annotation>
		<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@ConditionalOnMissingBean</xslthl:annotation>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> EmbeddedAcmeService embeddedAcmeService() { ... }

	}

}</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>If you use <code class="literal">@ConditionalOnClass</code> or <code class="literal">@ConditionalOnMissingClass</code> as a part of a
meta-annotation to compose your own composed annotations, you must use <code class="literal">name</code> as referring
to the class in such a case is not handled.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-bean-conditions" href="#boot-features-bean-conditions"></a>49.3.2&nbsp;Bean Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnBean</code> and <code class="literal">@ConditionalOnMissingBean</code> annotations let a bean be
included based on the presence or absence of specific beans. You can use the <code class="literal">value</code>
attribute to specify beans by type or <code class="literal">name</code> to specify beans by name. The <code class="literal">search</code>
attribute lets you limit the <code class="literal">ApplicationContext</code> hierarchy that should be considered
when searching for beans.</p><p>When placed on a <code class="literal">@Bean</code> method, the target type defaults to the return type of the
method, as shown in the following example:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Configuration</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyAutoConfiguration {

	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Bean</xslthl:annotation>
	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@ConditionalOnMissingBean</xslthl:annotation>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyService myService() { ... }

}</pre><p>In the preceding example, the <code class="literal">myService</code> bean is going to be created if no bean of type
<code class="literal">MyService</code> is already contained in the <code class="literal">ApplicationContext</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>You need to be very careful about the order in which bean definitions are added, as
these conditions are evaluated based on what has been processed so far. For this reason,
we recommend using only <code class="literal">@ConditionalOnBean</code> and <code class="literal">@ConditionalOnMissingBean</code> annotations
on auto-configuration classes (since these are guaranteed to load after any user-defined
bean definitions have been added).</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><code class="literal">@ConditionalOnBean</code> and <code class="literal">@ConditionalOnMissingBean</code> do not prevent <code class="literal">@Configuration</code>
classes from being created. The only difference between using these conditions at the class level
and marking each contained <code class="literal">@Bean</code> method with the annotation is that the former prevents
registration of the <code class="literal">@Configuration</code> class as a bean if the condition does not match.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-property-conditions" href="#boot-features-property-conditions"></a>49.3.3&nbsp;Property Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnProperty</code> annotation lets configuration be included based on a Spring
Environment property. Use the <code class="literal">prefix</code> and <code class="literal">name</code> attributes to specify the property that
should be checked. By default, any property that exists and is not equal to <code class="literal">false</code> is
matched. You can also create more advanced checks by using the <code class="literal">havingValue</code> and
<code class="literal">matchIfMissing</code> attributes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-resource-conditions" href="#boot-features-resource-conditions"></a>49.3.4&nbsp;Resource Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnResource</code> annotation lets configuration be included only when a
specific resource is present. Resources can be specified by using the usual Spring
conventions, as shown in the following example: <code class="literal">file:/home/user/test.dat</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-web-application-conditions" href="#boot-features-web-application-conditions"></a>49.3.5&nbsp;Web Application Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnWebApplication</code> and <code class="literal">@ConditionalOnNotWebApplication</code> annotations let
configuration be included depending on whether the application is a &#8220;web application&#8221;.
A web application is any application that uses a Spring <code class="literal">WebApplicationContext</code>,
defines a <code class="literal">session</code> scope, or has a <code class="literal">StandardServletEnvironment</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-spel-conditions" href="#boot-features-spel-conditions"></a>49.3.6&nbsp;SpEL Expression Conditions</h3></div></div></div><p>The <code class="literal">@ConditionalOnExpression</code> annotation lets configuration be included based on the
result of a <a class="link" href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/core.html#expressions" target="_top">SpEL expression</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-test-autoconfig" href="#boot-features-test-autoconfig"></a>49.4&nbsp;Testing your Auto-configuration</h2></div></div></div><p>An auto-configuration can be affected by many factors: user configuration (<code class="literal">@Bean</code>
definition and <code class="literal">Environment</code> customization), condition evaluation (presence of a
particular library), and others. Concretely, each test should create a well defined
<code class="literal">ApplicationContext</code> that represents a combination of those customizations.
<code class="literal">ApplicationContextRunner</code> provides a great way to achieve that.</p><p><code class="literal">ApplicationContextRunner</code> is usually defined as a field of the test class to gather the
base, common configuration. The following example makes sure that
<code class="literal">UserServiceAutoConfiguration</code> is always invoked:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> ApplicationContextRunner contextRunner = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>));</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>If multiple auto-configurations have to be defined, there is no need to order their
declarations as they are invoked in the exact same order as when running the
application.</p></td></tr></table></div><p>Each test can use the runner to represent a particular use case. For instance, the sample
below invokes a user configuration (<code class="literal">UserConfiguration</code>) and checks that the
auto-configuration backs off properly. Invoking <code class="literal">run</code> provides a callback context that can
be used with <code class="literal">Assert4J</code>.</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Test</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> defaultServiceBacksOff() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
			.run((context) -&gt; {
				assertThat(context).hasSingleBean(UserService.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
				assertThat(context.getBean(UserService.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).isSameAs(
						context.getBean(UserConfiguration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).myUserService());
			});
}

<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Configuration</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> UserConfiguration {

	<xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Bean</xslthl:annotation>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> UserService myUserService() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> UserService(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"mine"</span>);
	}

}</pre><p>It is also possible to easily customize the <code class="literal">Environment</code>, as shown in the following
example:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Test</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> serviceNameCanBeConfigured() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.contextRunner.withPropertyValues(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user.name=test123"</span>).run((context) -&gt; {
		assertThat(context).hasSingleBean(UserService.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
		assertThat(context.getBean(UserService.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).getName()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"test123"</span>);
	});
}</pre><p>The runner can also be used to display the <code class="literal">ConditionEvaluationReport</code>. The report can be printed
at <code class="literal">INFO</code> or <code class="literal">DEBUG</code> level. The following example shows how to use the <code class="literal">ConditionEvaluationReportLoggingListener</code>
to print the report in auto-configuration tests.</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Test</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> autoConfigTest {
	ConditionEvaluationReportLoggingListener initializer = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ConditionEvaluationReportLoggingListener(
			LogLevel.INFO);
	ApplicationContextRunner contextRunner = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ApplicationContextRunner()
			.withInitializer(initializer).run((context) -&gt; {
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Do something...</span>
			});
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_simulating_a_web_context" href="#_simulating_a_web_context"></a>49.4.1&nbsp;Simulating a Web Context</h3></div></div></div><p>If you need to test an auto-configuration that only operates in a Servlet or Reactive web
application context, use the <code class="literal">WebApplicationContextRunner</code> or
<code class="literal">ReactiveWebApplicationContextRunner</code> respectively.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overriding_the_classpath" href="#_overriding_the_classpath"></a>49.4.2&nbsp;Overriding the Classpath</h3></div></div></div><p>It is also possible to test what happens when a particular class and/or package is not
present at runtime. Spring Boot ships with a <code class="literal">FilteredClassLoader</code> that can easily be used
by the runner. In the following example, we assert that if <code class="literal">UserService</code> is not present, the
auto-configuration is properly disabled:</p><pre class="programlisting"><xslthl:annotation xmlns:xslthl="http://xslthl.sourceforge.net/">@Test</xslthl:annotation>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> serviceIsIgnoredIfLibraryIsNotPresent() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.contextRunner.withClassLoader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FilteredClassLoader(UserService.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>))
			.run((context) -&gt; assertThat(context).doesNotHaveBean(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"userService"</span>));
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot-features-custom-starter" href="#boot-features-custom-starter"></a>49.5&nbsp;Creating Your Own Starter</h2></div></div></div><p>A full Spring Boot starter for a library may contain the following components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The <code class="literal">autoconfigure</code> module that contains the auto-configuration code.</li><li class="listitem">The <code class="literal">starter</code> module that provides a dependency to the <code class="literal">autoconfigure</code> module as well
as the library and any additional dependencies that are typically useful. In a nutshell,
adding the starter should provide everything needed to start using that library.</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>You may combine the auto-configuration code and the dependency management in a
single module if you do not need to separate those two concerns.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-custom-starter-naming" href="#boot-features-custom-starter-naming"></a>49.5.1&nbsp;Naming</h3></div></div></div><p>You should make sure to provide a proper namespace for your starter. Do not start your
module names with <code class="literal">spring-boot</code>, even if you use a different Maven <code class="literal">groupId</code>. We may
offer official support for the thing you auto-configure in the future.</p><p>As a rule of thumb, you should name a combined module after the starter. For example,
assume that you are creating a starter for "acme" and that you name the auto-configure
module <code class="literal">acme-spring-boot-autoconfigure</code> and the starter <code class="literal">acme-spring-boot-starter</code>. If
you only have one module that combines the two, name it <code class="literal">acme-spring-boot-starter</code>.</p><p>Also, if your starter provides configuration keys, use a unique namespace for them. In
particular, do not include your keys in the namespaces that Spring Boot uses (such as
<code class="literal">server</code>, <code class="literal">management</code>, <code class="literal">spring</code>, and so on). If you use the same namespace, we may modify
these namespaces in the future in ways that break your modules.</p><p>Make sure to
<a class="link" href="configuration-metadata.html#configuration-metadata-annotation-processor" title="B.3&nbsp;Generating Your Own Metadata by Using the Annotation Processor">trigger
meta-data generation</a> so that IDE assistance is available for your keys as well. You may
want to review the generated meta-data (<code class="literal">META-INF/spring-configuration-metadata.json</code>) to
make sure your keys are properly documented.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-custom-starter-module-autoconfigure" href="#boot-features-custom-starter-module-autoconfigure"></a>49.5.2&nbsp;<code class="literal">autoconfigure</code> Module</h3></div></div></div><p>The <code class="literal">autoconfigure</code> module contains everything that is necessary to get started with the
library. It may also contain configuration key definitions (such as
<code class="literal">@ConfigurationProperties</code>) and any callback interface that can be used to further
customize how the components are initialized.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>You should mark the dependencies to the library as optional so that you can include
the <code class="literal">autoconfigure</code> module in your projects more easily. If you do it that way, the
library is not provided and, by default, Spring Boot backs off.</p></td></tr></table></div><p>Spring Boot uses an annotation processor to collect the conditions on auto-configurations
in a metadata file (<code class="literal">META-INF/spring-autoconfigure-metadata.properties</code>). If that file is
present, it is used to eagerly filter auto-configurations that do not match, which will
improve startup time. It is recommended to add the following dependency in a module that
contains auto-configurations:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-autoconfigure-processor<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;optional&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/optional&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>With Gradle 4.5 and earlier, the dependency should be declared in the <code class="literal">compileOnly</code>
configuration, as shown in the following example:</p><pre class="programlisting">dependencies {
	compileOnly <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span>
}</pre><p>With Gradle 4.6 and later, the dependency should be declared in the <code class="literal">annotationProcessor</code>
configuration, as shown in the following example:</p><pre class="programlisting">dependencies {
	annotationProcessor <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span>
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot-features-custom-starter-module-starter" href="#boot-features-custom-starter-module-starter"></a>49.5.3&nbsp;Starter Module</h3></div></div></div><p>The starter is really an empty jar. Its only purpose is to provide the necessary
dependencies to work with the library. You can think of it as an opinionated view of what
is required to get started.</p><p>Do not make assumptions about the project in which your starter is added. If the library
you are auto-configuring typically requires other starters, mention them as well.
Providing a proper set of <span class="emphasis"><em>default</em></span> dependencies may be hard if the number of optional
dependencies is high, as you should avoid including dependencies that are unnecessary for
a typical usage of the library. In other words, you should not include optional
dependencies.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Either way, your starter must reference the core Spring Boot starter
(<code class="literal">spring-boot-starter</code>) directly or indirectly (i.e. no need to add it if your starter
relies on another starter). If a project is created with only your custom starter, Spring
Boot&#8217;s core features will be honoured by the presence of the core starter.</p></td></tr></table></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="boot-features-webservices.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="boot-features.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="boot-features-kotlin.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">48.&nbsp;Web Services&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;50.&nbsp;Kotlin support</td></tr></table></div></body></html>