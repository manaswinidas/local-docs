<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>6.&nbsp;Microservice Architectural Style</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Cloud Data Flow Server for Apache Mesos"><link rel="up" href="architecture.html" title="Part&nbsp;II.&nbsp;Architecture"><link rel="prev" href="arch-intro.html" title="5.&nbsp;Introduction"><link rel="next" href="arch-streaming-apps.html" title="7.&nbsp;Streaming Applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6.&nbsp;Microservice Architectural Style</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="arch-intro.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Architecture</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="arch-streaming-apps.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="arch-microservice-style" href="#arch-microservice-style"></a>6.&nbsp;Microservice Architectural Style</h2></div></div></div><p>The Data Flow Server deploys applications onto the target runtime that conform to the microservice architectural style.  For example, a stream represents a high level application that consists of multiple small microservice applications each running in their own process.  Each microservice application can be scaled up or down independent of the other and each has their own versioning lifecycle.</p><p>Both Streaming and Task based microservice applications build upon Spring Boot as the foundational library.
This gives all microservice applications functionality such as health checks, security, configurable logging, monitoring and management functionality, as well as executable JAR packaging.</p><p>It is important to emphasise that these microservice applications are &#8216;just apps&#8217; that you can run by yourself using &#8216;java -jar&#8217; and passing in appropriate configuration properties.  We provide many common microservice applications for common operations so you don&#8217;t have to start from scratch when addressing common use-cases which build upon the rich ecosystem of Spring Projects, e.g Spring Integration, Spring Data, Spring Hadoop and Spring Batch.  Creating your own microservice application is similar to creating other Spring Boot applications, you can start using the Spring Initialzr web site or the UI to create the basic scaffolding of either a Stream or Task based microservice.</p><p>In addition to passing in the appropriate configuration to the applications, the Data Flow server is responsible for preparing the target platform&#8217;s infrastructure so that the application can be deployed.  For example, in Cloud Foundry it would be binding specified services to the applications and executing the &#8216;cf push&#8217; command for each application.  For Kubernetes it would be creating the replication controller, service, and load balancer.</p><p>The Data Flow Server helps simplify the deployment of multiple applications onto a target runtime, but one could also opt to deploy each of the microservice applications manually and not use Data Flow at all. This approach might be more appropriate to start out with for small scale deployments, gradually adopting the convenience and consistency of Data Flow as you develop more applications.
Manual deployment of Stream and Task based microservices is also a useful educational exercise that will help you better understand some of the automatic applications configuration and platform targeting steps that the Data Flow Server provides.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch-comparison" href="#arch-comparison"></a>6.1&nbsp;Comparison to other Platform architectures</h2></div></div></div><p>Spring Cloud Data Flow&#8217;s architectural style is different than other Stream and Batch processing platforms.  For example in Apache Spark, Apache Flink, and Google Cloud Dataflow applications run on a dedicated compute engine cluster.  The nature of the compute engine gives these platforms a richer environment for performing complex calculations on the data as compared to Spring Cloud Data Flow, but it introduces complexity of another execution environment that is often not needed when creating data centric applications.  That doesn&#8217;t mean you cannot do real time data computations when using Spring Cloud Data Flow.  Refer to the analytics section which describes the integration of Redis to handle common counting based use-cases as well as the RxJava integration for functional API driven analytics use-cases, such as time-sliding-window and moving-average among others.</p><p>Similarly, Apache Storm, Hortonworks DataFlow and Spring Cloud Data Flow&#8217;s predecessor, Spring XD, use a dedicated application execution cluster, unique to each product, that determines where your code should execute on the cluster and perform health checks to ensure that long lived applications are restarted if they fail.  Often, framework specific interfaces are required to be used in order to correctly &#8220;plug in&#8221; to the cluster&#8217;s execution framework.</p><p>As we discovered during the evolution of Spring XD, the rise of multiple container frameworks in 2015 made creating our own runtime a duplication of efforts.  There is no reason to build your own resource management mechanics, when there&#8217;s multiple runtime platforms that offer this functionality already.  Taking these considerations into account is what made us shift to the current architecture where we delegate the execution to popular runtimes, runtimes that you may already be using for other purposes.  This is an advantage in that it reduces the cognitive distance for creating and managing data centric applications as many of the same skills used for deploying other end-user/web applications are applicable.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="arch-intro.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="architecture.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="arch-streaming-apps.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.&nbsp;Introduction&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;7.&nbsp;Streaming Applications</td></tr></table></div></body></html>