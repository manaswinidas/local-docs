<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>12.&nbsp;Runtime</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Cloud Data Flow Server for Apache Mesos"><link rel="up" href="architecture.html" title="Part&nbsp;II.&nbsp;Architecture"><link rel="prev" href="arch-data-flow-server.html" title="11.&nbsp;Data Flow Server"><link rel="next" href="_getting_started.html" title="Part&nbsp;III.&nbsp;Getting Started"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.&nbsp;Runtime</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="arch-data-flow-server.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Architecture</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="_getting_started.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="arch-runtime" href="#arch-runtime"></a>12.&nbsp;Runtime</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch-runtime-fault-tolerance" href="#arch-runtime-fault-tolerance"></a>12.1&nbsp;Fault Tolerance</h2></div></div></div><p>The target runtimes supported by Data Flow all have the ability to restart a long lived application should it fail.  Spring Cloud Data Flow sets up whatever health probe is required by the runtime environment when deploying the application.</p><p>The collective state of all applications that comprise the stream is used to determine the state of the stream.  If an application fails, the state of the stream will change from &#8216;deployed&#8217; to &#8216;partial&#8217;.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch-runtime-resource-management" href="#arch-runtime-resource-management"></a>12.2&nbsp;Resource Management</h2></div></div></div><p>Each target runtime lets you control the amount of memory, disk and CPU that is allocated to each application.  These are passed as properties in the deployment manifest using key names that are unique to each runtime.  Refer to the each platforms server documentation for more information.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch-runtime-scaling" href="#arch-runtime-scaling"></a>12.3&nbsp;Scaling at runtime</h2></div></div></div><p>When deploying a stream, you can set the instance count for each individual application that comprises the stream.
Once the stream is deployed, each target runtime lets you control the target number of instances for each individual application.
Using the APIs, UIs, or command line tools for each runtime, you can scale up or down the number of instances as required.
Future work will provide a portable command in the Data Flow Server to perform this operation.</p><p>Currently, this is not supported with the Kafka binder (based on the 0.8 simple consumer at the time of the release), as well as partitioned streams, for which the suggested workaround is redeploying the stream with an updated number of instances.
Both cases require a static consumer set up based on information about the total instance count and current instance index, a limitation intended to be addressed in future releases.
For example, Kafka 0.9 and higher provides good infrastructure for scaling applications dynamically and will be available as an alternative to the current Kafka 0.8 based binder in the near future.
One specific concern regarding scaling partitioned streams is the handling of local state, which is typically reshuffled as the number of instances is changed.
This is also intended to be addressed in the future versions, by providing first class support for local state management.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch-application-versioning" href="#arch-application-versioning"></a>12.4&nbsp;Application Versioning</h2></div></div></div><p>Application versioning, that is upgrading or downgrading an application from one version to another, is not directly supported by Spring Cloud Data Flow.  You must rely on specific target runtime features to perform these operational tasks.</p><p>The roadmap for Spring Cloud Data Flow will deploy applications that are compatible with Spinnaker to manage the complete application lifecycle.  This also includes automated canary analysis backed by  application metrics.  Portable commands in the Data Flow server to trigger pipelines in Spinnaker are also planned.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="arch-data-flow-server.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="architecture.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="_getting_started.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.&nbsp;Data Flow Server&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;Getting Started</td></tr></table></div></body></html>