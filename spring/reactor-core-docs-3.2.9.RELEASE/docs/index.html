<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Stephane Maldini, Simon BaslÃ©">
<title>Reactor 3 Reference Guide</title>
<style>
@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/1.6.2/semantic.min.css);


#header .details br+span.author:before {
    content: "\00a0\0026\00a0";
    color: rgba(0,0,0,.85);
}

#header .details br+span.email:before {
    content: "(";
}

#header .details br+span.email:after {
    content: ")";
}

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
@import url(https://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.css);

article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary {
    display: block;
}

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video {
    display: inline-block;
}

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) {
    display: none;
    height: 0;
}

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template {
    display: none;
}

script {
    display: none !important;
}

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html {
    font-family: sans-serif; /* 1 */
    -ms-text-size-adjust: 100%; /* 2 */
    -webkit-text-size-adjust: 100%; /* 2 */
}

/** Remove default margin. */
body {
    margin: 0;
}

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a {
    background: transparent;
}

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus {
    outline: thin dotted;
}

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover {
    outline: 0;
}

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 {
    font-size: 2em;
    margin: 1.2em 0;
}

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] {
    border-bottom: 1px dotted;
}

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong {
    font-weight: bold;
}

/** Address styling not present in Safari 5 and Chrome. */
dfn {
    font-style: italic;
}

/** Address differences between Firefox and other browsers. */
hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/** Address styling not present in IE 8/9. */
mark {
    background: #ff0;
    color: #000;
}

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp {
    font-family: monospace, serif;
    font-size: 1em;
}

/** Improve readability of pre-formatted text in all browsers. */
pre {
    white-space: pre-wrap;
}

/** Set consistent quote types. */
q {
    quotes: "\201C" "\201D" "\2018" "\2019";
}

/** Address inconsistent and variable font size in all browsers. */
small {
    font-size: 80%;
}

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img {
    border: 0;
}

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) {
    overflow: hidden;
}

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure {
    margin: 0;
}

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 2 */
    margin: 0; /* 3 */
}

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input {
    line-height: normal;
}

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select {
    text-transform: none;
}

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
}

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] {
    cursor: default;
}

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

meta.foundation-mq-small {
    font-family: "only screen and (min-width: 768px)";
    width: 768px;
}

meta.foundation-mq-medium {
    font-family: "only screen and (min-width:1280px)";
    width: 1280px;
}

meta.foundation-mq-large {
    font-family: "only screen and (min-width:1440px)";
    width: 1440px;
}

*, *:before, *:after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

html, body {
    font-size: 100%;
}

body {
    background: white;
    color: #34302d;
    padding: 0;
    margin: 0;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    line-height: 1.8em;
    position: relative;
    cursor: auto;
}

#content, #content p {
    line-height: 1.8em;
    margin-top: 1.5em;
}

#content li p {
  margin-top: 0.25em;
}

a:hover {
    cursor: pointer;
}

img, object, embed {
    max-width: 100%;
    height: auto;
}

object, embed {
    height: 100%;
}

img {
    -ms-interpolation-mode: bicubic;
}

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object {
    max-width: none !important;
}

.left {
    float: left !important;
}

.right {
    float: right !important;
}

.text-left {
    text-align: left !important;
}

.text-right {
    text-align: right !important;
}

.text-center {
    text-align: center !important;
}

.text-justify {
    text-align: justify !important;
}

.hide {
    display: none;
}

.antialiased, body {
    -webkit-font-smoothing: antialiased;
}

img {
    display: inline-block;
    vertical-align: middle;
}

textarea {
    height: auto;
    min-height: 50px;
}

select {
    width: 100%;
}

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.21875em;
}

.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption {
    color: #6db33f;
    font-weight: 300;
    margin-top: 0.2em;
    margin-bottom: 0.5em;
}

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0;
    direction: ltr;
}

/* Default Link Styles */
a {
    color: #6db33f;
    line-height: inherit;
    text-decoration: none;
}

a:hover, a:focus {
    color: #6db33f;
    text-decoration: underline;
}

a img {
    border: none;
}

/* Default paragraph styles */
p {
    font-family: inherit;
    font-weight: normal;
    font-size: 1em;
    margin-bottom: 1.25em;
    text-rendering: optimizeLegibility;
}

p aside {
    font-size: 0.875em;
    font-style: italic;
}

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-family: "Montserrat", Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    color: #34302d;
    text-rendering: optimizeLegibility;
    margin-top: 1.6em;
    margin-bottom: 0.6em;
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #6db33f;
    line-height: 0;
}

h1 {
    font-size: 2.125em;
}

h2 {
    font-size: 1.6875em;
}

h3, #toctitle, .sidebarblock > .content > .title {
    font-size: 1.375em;
}

h4 {
    font-size: 1.125em;
}

h5 {
    font-size: 1.125em;
}

h6 {
    font-size: 1em;
}

hr {
    border: solid #dcd2c9;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0;
}

/* Helpful Typography Defaults */
em, i {
    font-style: italic;
    line-height: inherit;
}

strong, b {
    font-weight: bold;
    line-height: inherit;
}

small {
    font-size: 60%;
    line-height: inherit;
}

code {
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    font-weight: bold;
    color: #305CB5;
}

/* Lists */
ul, ol, dl {
    font-size: 1em;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit;
}

ul, ol {
    margin-left: 1.5em;
}

ul.no-bullet, ol.no-bullet {
    margin-left: 1.5em;
}

/* Unordered Lists */
ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em; /* Override nested font-size change */
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit;
}

ul.square {
    list-style-type: square;
}

ul.circle {
    list-style-type: circle;
}

ul.disc {
    list-style-type: disc;
}

ul.no-bullet {
    list-style: none;
}

/* Ordered Lists */
ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
}

/* Definition Lists */
dl dt {
    margin-bottom: 0.3125em;
    font-weight: bold;
}

dl dd {
    margin-bottom: 1.25em;
}

/* Abbreviations */
abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: #34302d;
    border-bottom: 1px dotted #dddddd;
    cursor: help;
}

abbr {
    text-transform: none;
}

/* Blockquotes */
blockquote {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 1px solid #dddddd;
}

blockquote cite {
    display: block;
    font-size: 0.8125em;
    color: #655241;
}

blockquote cite:before {
    content: "\2014 \0020";
}

blockquote cite a, blockquote cite a:visited {
    color: #655241;
}

blockquote, blockquote p {
    color: #34302d;
}

/* Microformats */
.vcard {
    display: inline-block;
    margin: 0 0 1.25em 0;
    border: 1px solid #dddddd;
    padding: 0.625em 0.75em;
}

.vcard li {
    margin: 0;
    display: block;
}

.vcard .fn {
    font-weight: bold;
    font-size: 0.9375em;
}

.vevent .summary {
    font-weight: bold;
}

.vevent abbr {
    cursor: auto;
    text-decoration: none;
    font-weight: bold;
    border: none;
    padding: 0 0.0625em;
}

@media only screen and (min-width: 768px) {
    h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    }

    h1 {
        font-size: 2.75em;
    }

    h2 {
        font-size: 2.3125em;
    }

    h3, #toctitle, .sidebarblock > .content > .title {
        font-size: 1.6875em;
    }

    h4 {
        font-size: 1.4375em;
    }
}

/* Print styles.  Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/ Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)
*/
.print-only {
    display: none !important;
}

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a, a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
        content: "";
    }

    pre, blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr, img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p, h2, h3, #toctitle, .sidebarblock > .content > .title {
        orphans: 3;
        widows: 3;
    }

    h2, h3, #toctitle, .sidebarblock > .content > .title {
        page-break-after: avoid;
    }

    .hide-on-print {
        display: none !important;
    }

    .print-only {
        display: block !important;
    }

    .hide-for-print {
        display: none !important;
    }

    .show-for-print {
        display: inherit !important;
    }
}

/* Tables */
table {
    background: white;
    margin-bottom: 1.25em;
    border: solid 1px #34302d;
}

table thead, table tfoot {
    font-weight: bold;
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: 0.5em 0.625em 0.625em;
    font-size: inherit;
    color: #34302d;
    text-align: left;
}

table thead tr th {
    color: white;
    background: #34302d;
}

table tr th, table tr td {
    padding: 0.5625em 0.625em;
    font-size: inherit;
    color: #34302d;
    border: 0 none;
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: #f2F2F2;
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    display: table-cell;
}

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after {
    content: " ";
    display: table;
}

.clearfix:after, .float-group:after {
    clear: both;
}

*:not(pre) > code {
    font-size: inherit;
    padding: 0;
    white-space: nowrap;
    background-color: inherit;
    border: 0 solid #dddddd;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    text-shadow: none;
}

pre, pre > code {
    color: black;
    font-family: monospace, serif;
    font-weight: normal;
}

.keyseq {
    color: #774417;
}

kbd:not(.keyseq) {
    display: inline-block;
    color: #211306;
    font-size: 0.75em;
    background-color: #F7F7F7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    margin: -0.15em 0.15em 0 0.15em;
    padding: 0.2em 0.6em 0.2em 0.5em;
    vertical-align: middle;
    white-space: nowrap;
}

.keyseq kbd:first-child {
    margin-left: 0;
}

.keyseq kbd:last-child {
    margin-right: 0;
}

.menuseq, .menu {
    color: black;
}

b.button:before, b.button:after {
    position: relative;
    top: -1px;
    font-weight: normal;
}

b.button:before {
    content: "[";
    padding: 0 3px 0 2px;
}

b.button:after {
    content: "]";
    padding: 0 2px 0 3px;
}

p a > code:hover {
    color: #541312;
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: 62.5em;
    *zoom: 1;
    position: relative;
    padding-left: 4em;
    padding-right: 4em;
}

#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after {
    content: " ";
    display: table;
}

#header:after, #content:after, #footnotes:after, #footer:after {
    clear: both;
}

#header {
    margin-bottom: 2.5em;
}

#header > h1 {
    color: #34302d;
    font-weight: 400;
}

#header span {
    color: #34302d;
}

#header #revnumber {
    text-transform: capitalize;
}

#header br {
    display: none;
}

#header br + span {
}

#revdate {
    display: block;
}

#toc {
    border-bottom: 1px solid #e6dfd8;
    padding-bottom: 1.25em;
}

#toc > ul {
    margin-left: 0.25em;
}

#toc ul.sectlevel0 > li > a {
    font-style: italic;
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin-left: 0;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

#toc ul {
    list-style-type: none;
}

#toctitle {
    color: #385dbd;
}

@media only screen and (min-width: 768px) {
    body.toc2 {
        padding-left: 15em;
        padding-right: 0;
    }

    #toc.toc2 {
        position: fixed;
        width: 15em;
        left: 0;
        border-bottom: 0;
        z-index: 1000;
        padding: 1em;
        height: 100%;
        top: 0px;
        background: #F1F1F1;
        overflow: auto;

        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    #reactor-header {
        position: fixed;
        top: -75px;
        left: 0;
        right: 0;
        height: 75px;


        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    body.head-show #toc.toc2 {
        top: 75px;
    }
    body.head-show #reactor-header {
        top: 0;
    }

    #toc.toc2 a {
        color: #34302d;
        font-family: Montserrat;
    }

    #toc.toc2 #toctitle {
        margin-top: 0;
        font-size: 1.2em;
    }

    #toc.toc2 > ul {
        font-size: .90em;
    }

    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 0.4em;
    }

    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em;
    }

    body.toc2.toc-right #toc.toc2 {
        border-right: 0;
        border-left: 1px solid #e6dfd8;
        left: auto;
        right: 0;
    }
}

@media only screen and (min-width: 1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0;
    }

    #toc.toc2 {
        width: 20em;
    }

    #toc.toc2 #toctitle {
        font-size: 1.375em;
    }

    #toc.toc2 > ul {
        font-size: 0.95em;
    }

    #toc.toc2 ul ul {
        padding-left: 1.25em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em;
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #d9d9d9;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f2f2f2;
    border-width: 0;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

#content #toc > :first-child {
    margin-top: 0;
}

#content #toc > :last-child {
    margin-bottom: 0;
}

#content #toc a {
    text-decoration: none;
}

#content #toctitle {
    font-weight: bold;
    font-family: "Montserrat", Arial, sans-serif;
    font-size: 1em;
    padding-left: 0.125em;
}

#footer {
    max-width: 100%;
    background-color: white;
    padding: 1.25em;
    color: #CCC;
    border-top: 3px solid #F1F1F1;
}

#footer-text {
    color: #444;
    line-height: 1.44;
}

.sect1 {
    padding-bottom: 1.25em;
}

.sect1 + .sect1 {
    border-top: 1px solid #e6dfd8;
}

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor {
    position: absolute;
    width: 1em;
    margin-left: -1em;
    display: block;
    text-decoration: none;
    visibility: hidden;
    text-align: center;
    font-weight: normal;
}

#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before {
    content: '\00A7';
    font-size: .85em;
    vertical-align: text-top;
    display: block;
    margin-top: 0.05em;
}

#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover {
    visibility: visible;
}

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    color: #34302d;
    text-decoration: none;
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover {
    color: #34302d;
}

.imageblock, .literalblock, .listingblock, .mathblock, .verseblock, .videoblock {
    margin-bottom: 1.25em;
    margin-top: 1.25em;
}

.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    text-align: left;
    font-weight: bold;
}

.tableblock > caption {
    text-align: left;
    font-weight: bold;
    white-space: nowrap;
    overflow: visible;
    max-width: 0;
}

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: inherit;
}

.admonitionblock > table {
    border: 0;
    background: none;
    width: 100%;
}

.admonitionblock > table td.icon {
    text-align: center;
    width: 80px;
}

.admonitionblock > table td.icon img {
    max-width: none;
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    text-transform: uppercase;
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #dcd2c9;
    color: #34302d;
}

.admonitionblock > table td.content > :last-child > :last-child {
    margin-bottom: 0;
}

.exampleblock > .content {
    border-style: solid;
    border-width: 1px;
    border-color: #f3e0ce;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: white;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

.exampleblock > .content > :first-child {
    margin-top: 0;
}

.exampleblock > .content > :last-child {
    margin-bottom: 0;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p {
    color: #333333;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 {
    margin-bottom: 0.625em;
}

.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader {
}

.exampleblock.result > .content {
    -webkit-box-shadow: 0 1px 8px #d9d9d9;
    box-shadow: 0 1px 8px #d9d9d9;
}

.sidebarblock {
    padding: 1.25em 2em;
    background: #F1F1F1;
    margin: 2em -2em;

}

.sidebarblock > :first-child {
    margin-top: 0;
}

.sidebarblock > :last-child {
    margin-bottom: 0;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p {
    color: #333333;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 {
    margin-bottom: 0.625em;
}

.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader {
}

.sidebarblock > .content > .title {
    color: #6db33f;
    margin-top: 0;
    font-size: 1.2em;
}

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child {
    margin-bottom: 0;
}

/*.literalblock .content pre.highlight, .listingblock .content pre.highlight {*/
    /*background-color: #f1f8ec;*/
/*}*/
/*.literalblock pre:not([class]), .listingblock pre:not([class]) {*/
    /*background-color: #f1f8ec;*/
/*}*/

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
    border-width: 1px;
    border-style: solid;
    border-color: rgba(21, 35, 71, 0.1);
    -webkit-border-radius: 6px;
    border-radius: 6px;
    padding: 0.8em;
    word-wrap: break-word;
}

.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal;
}

.literalblock pre > code, .literalblock pre[class] > code, .listingblock pre > code, .listingblock pre[class] > code {
    display: block;
}

@media only screen {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.72em;
    }
}

@media only screen and (min-width: 768px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.81em;
    }
}

@media only screen and (min-width: 1280px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.9em;
    }
}

.listingblock pre.highlight {
    padding: 0;
    line-height: 1em;
}

.listingblock pre.highlight > code {
    padding: 0.8em;
}

.listingblock > .content {
    position: relative;
}

.listingblock:hover code[class*=" language-"]:before {
    text-transform: uppercase;
    font-size: 0.9em;
    color: #999;
    position: absolute;
    top: 0.375em;
    right: 0.375em;
}

.listingblock:hover code.asciidoc:before {
    content: "asciidoc";
}

.listingblock:hover code.clojure:before {
    content: "clojure";
}

.listingblock:hover code.css:before {
    content: "css";
}

.listingblock:hover code.groovy:before {
    content: "groovy";
}

.listingblock:hover code.html:before {
    content: "html";
}

.listingblock:hover code.java:before {
    content: "java";
}

.listingblock:hover code.javascript:before {
    content: "javascript";
}

.listingblock:hover code.python:before {
    content: "python";
}

.listingblock:hover code.ruby:before {
    content: "ruby";
}

.listingblock:hover code.sass:before {
    content: "sass";
}

.listingblock:hover code.scss:before {
    content: "scss";
}

.listingblock:hover code.xml:before {
    content: "xml";
}

.listingblock:hover code.yaml:before {
    content: "yaml";
}

.listingblock.terminal pre .command:before {
    content: attr(data-prompt);
    padding-right: 0.5em;
    color: #999;
}

.listingblock.terminal pre .command:not([data-prompt]):before {
    content: '$';
}

table.pyhltable {
    border: 0;
    margin-bottom: 0;
}

table.pyhltable td {
    vertical-align: top;
    padding-top: 0;
    padding-bottom: 0;
}

table.pyhltable td.code {
    padding-left: .75em;
    padding-right: 0;
}

.highlight.pygments .lineno, table.pyhltable td:not(.code) {
    color: #999;
    padding-left: 0;
    padding-right: .5em;
    border-right: 1px solid #dcd2c9;
}

.highlight.pygments .lineno {
    display: inline-block;
    margin-right: .25em;
}

table.pyhltable .linenodiv {
    background-color: transparent !important;
    padding-right: 0 !important;
}

.quoteblock {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 3px solid #dddddd;
}

.quoteblock blockquote {
    margin: 0 0 1.25em 0;
    padding: 0 0 0.5625em 0;
    border: 0;
}

.quoteblock blockquote > .paragraph:last-child p {
    margin-bottom: 0;
}

.quoteblock .attribution {
    margin-top: -.25em;
    padding-bottom: 0.5625em;
    font-size: 0.8125em;
}

.quoteblock .attribution br {
    display: none;
}

.quoteblock .attribution cite {
    display: block;
    margin-bottom: 0.625em;
}

table thead th, table tfoot th {
    font-weight: bold;
}

table.tableblock.grid-all {
    border-collapse: separate;
    border-radius: 6px;
    border-top: 1px solid #34302d;
    border-bottom: 1px solid #34302d;
}

table.tableblock.frame-topbot, table.tableblock.frame-none {
    border-left: 0;
    border-right: 0;
}

table.tableblock.frame-sides, table.tableblock.frame-none {
    border-top: 0;
    border-bottom: 0;
}

table.tableblock td .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child {
    margin-bottom: 0;
}

th.tableblock.halign-left, td.tableblock.halign-left {
    text-align: left;
}

th.tableblock.halign-right, td.tableblock.halign-right {
    text-align: right;
}

th.tableblock.halign-center, td.tableblock.halign-center {
    text-align: center;
}

th.tableblock.valign-top, td.tableblock.valign-top {
    vertical-align: top;
}

th.tableblock.valign-bottom, td.tableblock.valign-bottom {
    vertical-align: bottom;
}

th.tableblock.valign-middle, td.tableblock.valign-middle {
    vertical-align: middle;
}

tbody tr th {
    display: table-cell;
    background: rgba(105, 60, 22, 0.25);
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: #211306;
    font-weight: bold;
}

td > div.verse {
    white-space: pre;
}

ol {
    margin-left: 1.75em;
}

ul li ol {
    margin-left: 1.5em;
}

dl dd {
    margin-left: 1.125em;
}

dl dd:last-child, dl dd:last-child > :last-child {
    margin-bottom: 0;
}

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: 0.625em;
}

ul.unstyled, ol.unnumbered, ul.checklist, ul.none {
    list-style-type: none;
}

ul.unstyled, ol.unnumbered, ul.checklist {
    margin-left: 0.625em;
}

ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    margin-right: 0.25em;
}

ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    position: relative;
    top: 1px;
}

ul.inline {
    margin: 0 auto 0.625em auto;
    margin-left: -1.375em;
    margin-right: 0;
    padding: 0;
    list-style: none;
    overflow: hidden;
}

ul.inline > li {
    list-style: none;
    float: left;
    margin-left: 1.375em;
    display: block;
}

ul.inline > li > * {
    display: block;
}

.unstyled dl dt {
    font-weight: normal;
    font-style: normal;
}

ol.arabic {
    list-style-type: decimal;
}

ol.decimal {
    list-style-type: decimal-leading-zero;
}

ol.loweralpha {
    list-style-type: lower-alpha;
}

ol.upperalpha {
    list-style-type: upper-alpha;
}

ol.lowerroman {
    list-style-type: lower-roman;
}

ol.upperroman {
    list-style-type: upper-roman;
}

ol.lowergreek {
    list-style-type: lower-greek;
}

.hdlist > table, .colist > table {
    border: 0;
    background: none;
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
    background: none;
}

td.hdlist1 {
    padding-right: .75em;
    font-weight: bold;
}

td.hdlist1, td.hdlist2 {
    vertical-align: top;
}

.literalblock + .colist, .listingblock + .colist {
    margin-top: -0.5em;
}

.colist > table tr > td:first-of-type {
    padding: 0 .75em;
}

.colist > table tr > td:last-of-type {
    padding: 0.25em 0;
}

.qanda > ol > li > p > em:only-child {
    color: #063f40;
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px white;
    -webkit-box-shadow: 0 0 0 1px #dddddd;
    box-shadow: 0 0 0 1px #dddddd;
}

.imageblock.left, .imageblock[style*="float: left"] {
    margin: 0.25em 0.625em 1.25em 0;
}

.imageblock.right, .imageblock[style*="float: right"] {
    margin: 0.25em 0 1.25em 0.625em;
}

.imageblock > .title {
    margin-bottom: 0;
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px;
}

.imageblock.thumb > .title, .imageblock.th > .title {
    padding: 0 0.125em;
}

.image.left, .image.right {
    margin-top: 0.25em;
    margin-bottom: 0.25em;
    display: inline-block;
    line-height: 0;
}

.image.left {
    margin-right: 0.625em;
}

.image.right {
    margin-left: 0.625em;
}

a.image {
    text-decoration: none;
}

span.footnote, span.footnoteref {
    vertical-align: super;
    font-size: 0.875em;
}

span.footnote a, span.footnoteref a {
    text-decoration: none;
}

#footnotes {
    padding-top: 0.75em;
    padding-bottom: 0.75em;
    margin-bottom: 0.625em;
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em 0;
    border-width: 1px 0 0 0;
}

#footnotes .footnote {
    padding: 0 0.375em;
    font-size: 0.875em;
    margin-left: 1.2em;
    text-indent: -1.2em;
    margin-bottom: .2em;
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none;
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0;
}

#content #footnotes {
    margin-top: -0.625em;
    margin-bottom: 0;
    padding: 0.75em 0;
}

.gist .file-data > table {
    border: none;
    background: #fff;
    width: 100%;
    margin-bottom: 0;
}

.gist .file-data > table td.line-data {
    width: 99%;
}

div.unbreakable {
    page-break-inside: avoid;
}

.big {
    font-size: larger;
}

.small {
    font-size: smaller;
}

.underline {
    text-decoration: underline;
}

.overline {
    text-decoration: overline;
}

.line-through {
    text-decoration: line-through;
}

.aqua {
    color: #00bfbf;
}

.aqua-background {
    background-color: #00fafa;
}

.black {
    color: black;
}

.black-background {
    background-color: black;
}

.blue {
    color: #0000bf;
}

.blue-background {
    background-color: #0000fa;
}

.fuchsia {
    color: #bf00bf;
}

.fuchsia-background {
    background-color: #fa00fa;
}

.gray {
    color: #606060;
}

.gray-background {
    background-color: #7d7d7d;
}

.green {
    color: #006000;
}

.green-background {
    background-color: #007d00;
}

.lime {
    color: #00bf00;
}

.lime-background {
    background-color: #00fa00;
}

.maroon {
    color: #600000;
}

.maroon-background {
    background-color: #7d0000;
}

.navy {
    color: #000060;
}

.navy-background {
    background-color: #00007d;
}

.olive {
    color: #606000;
}

.olive-background {
    background-color: #7d7d00;
}

.purple {
    color: #600060;
}

.purple-background {
    background-color: #7d007d;
}

.red {
    color: #bf0000;
}

.red-background {
    background-color: #fa0000;
}

.silver {
    color: #909090;
}

.silver-background {
    background-color: #bcbcbc;
}

.teal {
    color: #006060;
}

.teal-background {
    background-color: #007d7d;
}

.white {
    color: #bfbfbf;
}

.white-background {
    background-color: #fafafa;
}

.yellow {
    color: #bfbf00;
}

.yellow-background {
    background-color: #fafa00;
}

span.icon > [class^="icon-"], span.icon > [class*=" icon-"] {
    cursor: default;
}

.admonitionblock td.icon [class^="icon-"]:before {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    cursor: default;
}

.admonitionblock td.icon .icon-note:before {
    content: "\f05a";
    color: #095557;
    color: #064042;
}

.admonitionblock td.icon .icon-tip:before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8);
    color: #111;
}

.admonitionblock td.icon .icon-warning:before {
    content: "\f071";
    color: #bf6900;
}

.admonitionblock td.icon .icon-caution:before {
    content: "\f06d";
    color: #bf3400;
}

.admonitionblock td.icon .icon-important:before {
    content: "\f06a";
    color: #bf0000;
}

.conum {
    display: inline-block;
    color: white !important;
    background-color: #6db33f;
    -webkit-border-radius: 100px;
    border-radius: 100px;
    text-align: center;
    width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: bold;
    line-height: 20px;
    font-family: Arial, sans-serif;
    font-style: normal;
    position: relative;
    top: -2px;
    letter-spacing: -1px;
}

.conum * {
    color: white !important;
}

.conum + b {
    display: none;
}

.conum:after {
    content: attr(data-value);
}

.conum:not([data-value]):empty {
    display: none;
}

body {
    padding-top: 60px;
}

#toc.toc2 ul ul {
    padding-left: 1em;
}
#toc.toc2 ul ul.sectlevel2 {
}

#toctitle {
    color: #34302d;
    display: none;
}

#header h1 {
    font-weight: bold;
    position: relative;
    left: -0.0625em;
}

#header h1 span.lo {
    color: #dc9424;
}

#content h2, #content h3, #content #toctitle, #content .sidebarblock > .content > .title, #content h4, #content h5, #content #toctitle {
    font-weight: normal;
    position: relative;
    left: -0.0625em;
}

#content h2 {
    font-weight: bold;
}

.admonitionblock > table td.content {
    border-color: #e6dfd8;
}

table.tableblock.grid-all {
    -webkit-border-radius: 0;
    border-radius: 0;
}

#footer {
    background-color: white;
    color: #34302d;
}

.imageblock .title {
    text-align: center;
}

#content h1.sect0 {
    font-size: 48px;
}

#toc > ul > li > a {
    font-size: large;
}




@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700|Karla:400,700);
body {
}
#reactor-header {
    background: #34302d;
    border-top: 4px solid #6db33f;
    z-index: 2000;
    font-family: 'Montserrat';
    height: 75px;
}

#reactor-header h1#logo {
    margin: 7px 0 0 10px;
    padding: 0;
    float: left;
}

#reactor-header h1#logo a {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
}
#reactor-header h1#logo a:hover strong {
    filter: progid:DXImageTransform.Microsoft.Alpha(enabled=false);
    opacity: 1;
}
#reactor-header h1#logo a strong {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    color: red;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
    -moz-transition-property: opacity;
    -o-transition-property: opacity;
    -webkit-transition-property: opacity;
    transition-property: opacity;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0);
    opacity: 0;
}

#nav, #nav ul {
    display: block;
    margin: 0;
    padding: 0;
}
#nav {
    float: right;
    margin-right: 10px;
}
#nav ul li {
    display: block;
    float: left;
    list-style: none;
    margin: 0;
    padding: 0;
}
#nav ul li a {
    color: white;
    text-decoration: none;
    font-weight: 500;
    display: block;
    text-transform: uppercase;
    font-size: 13.5px;
    line-height: 71px;
    margin: 0;
    padding: 0 12px;
    -moz-transition-property: background-color;
    -o-transition-property: background-color;
    -webkit-transition-property: background-color;
    transition-property: background-color;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
}
#nav ul li a:hover {
    background: #6db33f;
}
#nav ul li a.active {
    background: #6db33f;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Reactor 3 Reference Guide</h1>
<div class="details">
<span id="author" class="author">Stephane Maldini</span><br>
<span id="email" class="email"><a href="https://twitter.com/smaldini">@smaldini</a></span><br>
<span id="author2" class="author">Simon BaslÃ©</span><br>
<span id="email2" class="email"><a href="https://twitter.com/simonbasle">@simonbasle</a></span><br>
<span id="revdate">3.2.9.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-doc">1. About the Documentation</a>
<ul class="sectlevel2">
<li><a href="#_latest_version_copyright_notice">1.1. Latest Version &amp; Copyright Notice</a></li>
<li><a href="#_contributing_to_the_documentation">1.2. Contributing to the Documentation</a></li>
<li><a href="#_getting_help">1.3. Getting Help</a></li>
<li><a href="#_where_to_go_from_here">1.4. Where to Go from Here</a></li>
</ul>
</li>
<li><a href="#getting-started">2. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#getting-started-introducing-reactor">2.1. Introducing Reactor</a></li>
<li><a href="#prerequisites">2.2. Prerequisites</a></li>
<li><a href="#getting-started-understanding-bom">2.3. Understanding the BOM</a></li>
<li><a href="#getting">2.4. Getting Reactor</a></li>
</ul>
</li>
<li><a href="#intro-reactive">3. Introduction to Reactive Programming</a>
<ul class="sectlevel2">
<li><a href="#_blocking_can_be_wasteful">3.1. Blocking Can Be Wasteful</a></li>
<li><a href="#_asynchronicity_to_the_rescue">3.2. Asynchronicity to the Rescue?</a></li>
<li><a href="#_from_imperative_to_reactive_programming">3.3. From Imperative to Reactive Programming</a></li>
</ul>
</li>
<li><a href="#core-features">4. Reactor Core Features</a>
<ul class="sectlevel2">
<li><a href="#flux">4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</a></li>
<li><a href="#mono">4.2. <code>Mono</code>, an Asynchronous 0-1 Result</a></li>
<li><a href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it">4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</a></li>
<li><a href="#producing">4.4. Programmatically creating a sequence</a></li>
<li><a href="#schedulers">4.5. Threading and Schedulers</a></li>
<li><a href="#error.handling">4.6. Handling Errors</a></li>
<li><a href="#processors">4.7. Processors</a></li>
</ul>
</li>
<li><a href="#kotlin">5. Kotlin support</a>
<ul class="sectlevel2">
<li><a href="#kotlin-introduction">5.1. Introduction</a></li>
<li><a href="#kotlin-requirements">5.2. Requirements</a></li>
<li><a href="#kotlin-extensions">5.3. Extensions</a></li>
<li><a href="#kotlin-null-safety">5.4. Null-safety</a></li>
</ul>
</li>
<li><a href="#testing">6. Testing</a>
<ul class="sectlevel2">
<li><a href="#_testing_a_scenario_with_stepverifier">6.1. Testing a Scenario with <code>StepVerifier</code></a></li>
<li><a href="#_manipulating_time">6.2. Manipulating Time</a></li>
<li><a href="#_performing_post_execution_assertions_with_stepverifier">6.3. Performing Post-execution Assertions with <code>StepVerifier</code></a></li>
<li><a href="#_testing_the_context">6.4. Testing the <code>Context</code></a></li>
<li><a href="#_manually_emitting_with_testpublisher">6.5. Manually Emitting with <code>TestPublisher</code></a></li>
<li><a href="#_checking_the_execution_path_with_publisherprobe">6.6. Checking the Execution Path with <code>PublisherProbe</code></a></li>
</ul>
</li>
<li><a href="#debugging">7. Debugging Reactor</a>
<ul class="sectlevel2">
<li><a href="#_the_typical_reactor_stack_trace">7.1. The Typical Reactor Stack Trace</a></li>
<li><a href="#debug-activate">7.2. Activating Debug Mode</a></li>
<li><a href="#_reading_a_stack_trace_in_debug_mode">7.3. Reading a Stack Trace in Debug Mode</a></li>
<li><a href="#_logging_a_sequence">7.4. Logging a sequence</a></li>
</ul>
</li>
<li><a href="#advanced">8. Advanced Features and Concepts</a>
<ul class="sectlevel2">
<li><a href="#advanced-mutualizing-operator-usage">8.1. Mutualizing Operator Usage</a></li>
<li><a href="#reactor.hotCold">8.2. Hot vs Cold</a></li>
<li><a href="#advanced-broadcast-multiple-subscribers-connectableflux">8.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></li>
<li><a href="#advanced-three-sorts-batching">8.4. Three Sorts of Batching</a></li>
<li><a href="#advanced-parallelizing-parralelflux">8.5. Parallelizing Work with <code>ParallelFlux</code></a></li>
<li><a href="#scheduler-factory">8.6. Replacing Default <code>Schedulers</code></a></li>
<li><a href="#hooks">8.7. Using Global Hooks</a></li>
<li><a href="#context">8.8. Adding a Context to a Reactive Sequence</a></li>
<li><a href="#cleanup">8.9. Dealing with Objects that need cleanup</a></li>
<li><a href="#null-safety">8.10. Null-safety</a></li>
</ul>
</li>
<li><a href="#which-operator">Appendix A: Which operator do I need?</a>
<ul class="sectlevel2">
<li><a href="#which.create">A.1. Creating a New Sequence&#8230;&#8203;</a></li>
<li><a href="#which.values">A.2. Transforming an Existing Sequence</a></li>
<li><a href="#which.peeking">A.3. Peeking into a Sequence</a></li>
<li><a href="#which.filtering">A.4. Filtering a Sequence</a></li>
<li><a href="#which.errors">A.5. Handling Errors</a></li>
<li><a href="#which.time">A.6. Working with Time</a></li>
<li><a href="#which.window">A.7. Splitting a <code>Flux</code></a></li>
<li><a href="#which.blocking">A.8. Going Back to the Synchronous World</a></li>
<li><a href="#which.multicasting">A.9. Multicasting a <code>Flux</code> to several <code>Subscribers</code></a></li>
</ul>
</li>
<li><a href="#faq">Appendix B: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>
<ul class="sectlevel2">
<li><a href="#faq.wrap-blocking">B.1. How do I wrap a synchronous, blocking call?</a></li>
<li><a href="#faq.chain">B.2. I used an operator on my <code>Flux</code> but it doesn&#8217;t seem to apply. What gives?</a></li>
<li><a href="#faq.monoThen">B.3. My <code>Mono</code> <code>zipWith</code>/<code>zipWhen</code> is never called</a></li>
<li><a href="#faq.retryWhen">B.4. How to use <code>retryWhen</code> to emulate <code>retry(3)</code>?</a></li>
<li><a href="#faq.exponentialBackoff">B.5. How to use <code>retryWhen</code> for exponential backoff?</a></li>
<li><a href="#_how_do_i_ensure_thread_affinity_using_publishon">B.6. How do I ensure thread affinity using <code>publishOn()</code>?</a></li>
</ul>
</li>
<li><a href="#reactor-extra">Appendix C: Reactor-Extra</a>
<ul class="sectlevel2">
<li><a href="#extra-tuples">C.1. <code>TupleUtils</code> and Functional Interfaces</a></li>
<li><a href="#extra-math">C.2. Math Operators With <code>MathFlux</code></a></li>
<li><a href="#extra-repeat-retry">C.3. Repeat and Retry Utilities</a></li>
<li><a href="#extra-schedulers">C.4. Schedulers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-doc"><a class="anchor" href="#about-doc"></a>1. About the Documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides a brief overview of Reactor reference documentation. You do not
need to read this guide in a linear fashion. Each piece stands on its own, though they
often refer to other pieces.</p>
</div>
<div class="sect2">
<h3 id="_latest_version_copyright_notice"><a class="anchor" href="#_latest_version_copyright_notice"></a>1.1. Latest Version &amp; Copyright Notice</h3>
<div class="paragraph">
<p>The Reactor reference guide is available as HTML documents. The latest copy is available
at <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html" class="bare">https://projectreactor.io/docs/core/release/reference/docs/index.html</a></p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others,
provided that you do not charge any fee for such copies and further provided that each
copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributing_to_the_documentation"><a class="anchor" href="#_contributing_to_the_documentation"></a>1.2. Contributing to the Documentation</h3>
<div class="paragraph">
<p>The reference guide is written in
<a href="https://asciidoctor.org/docs/asciidoc-writers-guide/">Asciidoc</a>
format and sources can be found at
<a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc" class="bare">https://github.com/reactor/reactor-core/tree/master/docs/asciidoc</a>.</p>
</div>
<div class="paragraph">
<p>If you have an improvement, we will be happy to get a pull request from you!</p>
</div>
<div class="paragraph">
<p>We recommend that you check out a local copy of the repository, so that you can
generate the documentation using the <code>asciidoctor</code> gradle task and check the
rendering. Some of the sections rely on included files, so GitHub rendering is
not always complete.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To facilitate documentation edits, most sections have a link at the end that opens
an edit UI directly on GitHub for the main source file for that section. These links are
only present in the HTML5 version of this reference guide. They look like the following
<a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc">Suggest Edit^, role="fa fa-edit"</a> to <a href="#about-doc">About the Documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_help"><a class="anchor" href="#_getting_help"></a>1.3. Getting Help</h3>
<div class="paragraph">
<p>There are several ways to reach out for help with Reactor.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Get in touch with the community on <a href="https://gitter.im/reactor/reactor">Gitter</a>.</p>
</li>
<li>
<p>Ask a question on stackoverflow.com at
<a href="https://stackoverflow.com/tags/project-reactor"><code>project-reactor</code></a>.</p>
</li>
<li>
<p>Report bugs in Github issues. The following repositories are closely monitored:
<a href="https://github.com/reactor/reactor-core/issues">reactor-core</a> (which covers the
essential features) and <a href="https://github.com/reactor/reactor-addons/issues">reactor-addons</a>
(which covers reactor-test and adapters issues).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All of Reactor is open source,
<a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc">including this
documentation</a>. If you find problems with the docs or if you just want to improve them,
please <a href="https://github.com/reactor/reactor-core/blob/master/CONTRIBUTING.md">get involved</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_where_to_go_from_here"><a class="anchor" href="#_where_to_go_from_here"></a>1.4. Where to Go from Here</h3>
<div class="ulist">
<ul>
<li>
<p>Head to <a href="#getting-started">Getting Started</a> if you feel like jumping straight into the code.</p>
</li>
<li>
<p>If you are new to <em>Reactive Programming</em>, though, you should probably start with the
<a href="#intro-reactive">Introduction to Reactive Programming</a>.</p>
</li>
<li>
<p>If you are familiar with Reactor concepts and are just looking for the right tool
for the job but cannot think of a relevant operator, try the <a href="#which-operator">Which operator do I need?</a> Appendix.</p>
</li>
<li>
<p>In order to dig deeper into the core features of Reactor, head to <a href="#core-features">Reactor Core Features</a>, to
learn:</p>
<div class="ulist">
<ul>
<li>
<p>More about Reactor&#8217;s reactive types in the "<a href="#flux"><code>Flux</code>, an Asynchronous Sequence of 0-N Items</a>" and "<a href="#mono"><code>Mono</code>, an Asynchronous 0-1 Result</a>"
sections.</p>
</li>
<li>
<p>How to switch threading contexts using <a href="#schedulers">a Scheduler</a>.</p>
</li>
<li>
<p>How to handle errors in the <a href="#error.handling">Handling Errors</a> section.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Unit testing? Yes it is possible with the <code>reactor-test</code> project! See <a href="#testing">Testing</a>.</p>
</li>
<li>
<p><a href="#producing">Programmatically creating a sequence</a> offers a more advanced way of creating of reactive sources.</p>
</li>
<li>
<p>Other advanced topics are covered in <a href="#advanced">Advanced Features and Concepts</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc">Suggest Edit^, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#about-doc">About the Documentation</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section contains information that should help you get going with Reactor. It
includes the following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-introducing-reactor">Introducing Reactor</a></p>
</li>
<li>
<p><a href="#prerequisites">Prerequisites</a></p>
</li>
<li>
<p><a href="#getting-started-understanding-bom">Understanding the BOM</a></p>
</li>
<li>
<p><a href="#getting">Getting Reactor</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-started-introducing-reactor"><a class="anchor" href="#getting-started-introducing-reactor"></a>2.1. Introducing Reactor</h3>
<div class="paragraph">
<p>Reactor is a fully non-blocking reactive programming foundation for the JVM, with
efficient demand management (in the form of managing "backpressure"). It integrates
directly with the Java 8 functional APIs, notably <code>CompletableFuture</code>, <code>Stream</code>, and
<code>Duration</code>. It offers composable asynchronous sequence APIs <code>Flux</code> (for [N] elements) and
<code>Mono</code> (for [0|1] elements), extensively implementing the [Reactive Streams](<a href="https://www.reactive-streams.org/" class="bare">https://www.reactive-streams.org/</a>)
specification.</p>
</div>
<div class="paragraph">
<p>Reactor also supports non-blocking inter-process communication with the
<code>reactor-netty</code> project. Suited for Microservices Architecture, Reactor Netty offers
backpressure-ready network engines for HTTP (including Websockets), TCP, and UDP.
Reactive Encoding and Decoding are fully supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>2.2. Prerequisites</h3>
<div class="paragraph">
<p>Reactor Core runs on <code>Java 8</code> and above.</p>
</div>
<div class="paragraph">
<p>It has a transitive dependency on <code>org.reactivestreams:reactive-streams:1.0.2</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Android support</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reactor 3 does not officially support or target Android (consider using RxJava 2 if
such support is a strong requirement).</p>
</li>
<li>
<p>However, it should work fine with Android SDK 26 (Android O) and above.</p>
</li>
<li>
<p>We are open to evaluating changes that benefit Android support in a best-effort
fashion. However, we cannot make guarantees. Each decision must be made on a
case-by-case basis.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-understanding-bom"><a class="anchor" href="#getting-started-understanding-bom"></a>2.3. Understanding the BOM</h3>
<div class="paragraph">
<p>Reactor 3 uses a BOM model since <code>reactor-core 3.0.4</code>, with the <code>Aluminium</code> release train.
This curated list groups artifacts that are meant to work well together, providing
the relevant versions despite potentially divergent versioning schemes in these artifacts.</p>
</div>
<div class="paragraph">
<p>The BOM (Bill of Materials) is itself versioned, using a release train scheme
with a codename followed by a qualifier. Here are a few examples:</p>
</div>
<div class="verseblock">
<pre class="content">Aluminium-RELEASE
Californium-BUILD-SNAPSHOT
Aluminium-SR1
Bismuth-RELEASE
Californium-SR32</pre>
</div>
<div class="paragraph">
<p>The codenames represent what would traditionally be the MAJOR.MINOR number. They (mostly)
come from the <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">Periodic Table of
Elements</a>, in increasing alphabetical order.</p>
</div>
<div class="paragraph">
<p>The qualifiers are (in chronological order):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BUILD-SNAPSHOT</code></p>
</li>
<li>
<p><code>M1</code>..<code>N</code>: Milestones or developer previews</p>
</li>
<li>
<p><code>RELEASE</code>: The first GA (General Availability) release in a codename series</p>
</li>
<li>
<p><code>SR1</code>..<code>N</code>: The subsequent GA releases in a codename series (equivalent to PATCH
number, SR stands for "Service Release").</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getting"><a class="anchor" href="#getting"></a>2.4. Getting Reactor</h3>
<div class="paragraph">
<p>As mentioned earlier, the easiest way to use Reactor in your core is to use the BOM and
add the relevant dependencies to your project. Note that, when adding such a dependency,
you must omit the version so that the version gets picked up from the BOM.</p>
</div>
<div class="paragraph">
<p>However, if you want to force the use of a specific artifact&#8217;s version, you can specify
it when adding your dependency, as you usually would. You can also forgo the BOM entirely
and specify dependencies by their artifact versions.</p>
</div>
<div class="sect3">
<h4 id="_maven_installation"><a class="anchor" href="#_maven_installation"></a>2.4.1. Maven Installation</h4>
<div class="paragraph">
<p>The BOM concept is natively supported by Maven. First, you need to import the BOM by
adding the following snippet to your <code>pom.xml</code>. If the top section
(<code>dependencyManagement</code>) already exists in your pom, add only the contents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencyManagement&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;Bismuth-RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice the <code>dependencyManagement</code> tag. This is in addition to the regular
<code>dependencies</code> section.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, add your dependencies to the relevant reactor projects, as usual, except without a
<code>&lt;version&gt;</code>, as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dependency on the core library</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No version tag here</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>reactor-test</code> provides facilities to unit test reactive streams</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_gradle_installation"><a class="anchor" href="#_gradle_installation"></a>2.4.2. Gradle installation</h4>
<div class="paragraph">
<p>Gradle has no core support for Maven BOMs, but you can use Spring&#8217;s
<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle-dependency-management</a>
plugin.</p>
</div>
<div class="paragraph">
<p>First, apply the plugin from the Gradle Plugin Portal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.6.RELEASE" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>as of this writing, 1.0.6.RELEASE is the latest version of the plugin.
Check for updates.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then use it to import the BOM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement {
     imports {
          mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally add a dependency to your project, without a version number:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
     compile 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There is no third <code>:</code> separated section for the version. It is taken from
the BOM.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_milestones_and_snapshots"><a class="anchor" href="#_milestones_and_snapshots"></a>2.4.3. Milestones and Snapshots</h4>
<div class="paragraph">
<p>Milestones and developer previews are distributed through the Spring Milestones
repository rather than Maven Central. To add it to your build configuration
file, use the following snippet:</p>
</div>
<div class="listingblock">
<div class="title">Milestones in Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Gradle, use the following snippet:</p>
</div>
<div class="listingblock">
<div class="title">Milestones in Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, snapshots are also available in a separate dedicated repository:</p>
</div>
<div class="listingblock">
<div class="title">BUILD-SNAPSHOTs in Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">BUILD-SNAPSHOTs in Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/gettingStarted.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#getting-started">Getting Started</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro-reactive"><a class="anchor" href="#intro-reactive"></a>3. Introduction to Reactive Programming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor is an implementation of the Reactive Programming paradigm, which can be summed up
as:</p>
</div>
<div class="quoteblock">
<blockquote>
Reactive programming is an asynchronous programming paradigm concerned with data streams
and the propagation of change. This means that it becomes possible to express static
(e.g. arrays) or dynamic (e.g. event emitters) data streams with ease via the employed
programming language(s).
</blockquote>
<div class="attribution">
&#8212; https://en.wikipedia.org/wiki/Reactive_programming
</div>
</div>
<div class="paragraph">
<p>As a first step in the direction of reactive programming, Microsoft created the Reactive
Extensions (Rx) library in the .NET ecosystem. Then RxJava implemented reactive
programming on the JVM.  As time went on, a standardization for Java emerged through the
<strong>Reactive Streams</strong> effort, a specification that defines a set of interfaces and
interaction rules for reactive libraries on the JVM. Its interfaces have been
integrated into Java 9 under the parent <code>Flow</code> class.</p>
</div>
<div class="paragraph">
<p>The reactive programming paradigm is often presented in object-oriented languages as an
extension of the Observer design pattern. One can also compare the main reactive streams
pattern with the familiar Iterator design pattern, as there is a duality to the
<code>Iterable</code>-<code>Iterator</code> pair in all of these libraries. One major difference is that, while
an Iterator is <strong>pull</strong>-based, reactive streams are <strong>push</strong>-based.</p>
</div>
<div class="paragraph">
<p>Using an iterator is an imperative programming pattern, even though the method of
accessing values is solely the responsibility of the <code>Iterable</code>. Indeed, it is up to the
developer to choose when to access the <code>next()</code> item in the sequence. In reactive
streams, the equivalent of the above pair is <code>Publisher-Subscriber</code>. But it is the
<code>Publisher</code> that notifies the Subscriber of newly available values <em>as they come</em>, and
this push aspect is the key to being reactive. Also, operations applied to pushed values
are expressed declaratively rather than imperatively: the programmer expresses the logic
of the computation rather than describing its exact control flow.</p>
</div>
<div class="paragraph">
<p>In addition to pushing values, the error handling and completion aspects are also covered
in a well defined manner. A <code>Publisher</code> can push new values to its <code>Subscriber</code> (by
calling <code>onNext</code>) but can also signal an error (by calling <code>onError</code>) or completion (by
calling <code>onComplete</code>). Both errors and completion terminate the sequence. This can
be summed up as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>onNext x 0..N [onError | onComplete]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach is very flexible. The pattern supports use cases where there is no value,
one value, or n values (including an infinite sequence of values, such as the continuing
ticks of a clock).</p>
</div>
<div class="paragraph">
<p>But let&#8217;s first consider, why would we need such an asynchronous reactive library in the first place?</p>
</div>
<div class="sect2">
<h3 id="_blocking_can_be_wasteful"><a class="anchor" href="#_blocking_can_be_wasteful"></a>3.1. Blocking Can Be Wasteful</h3>
<div class="paragraph">
<p>Modern applications can reach huge numbers of concurrent users, and, even though the
capabilities of modern hardware have continued to improve, performance of
modern software is still a key concern.</p>
</div>
<div class="paragraph">
<p>There are broadly two ways one can improve a program&#8217;s performance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>parallelize</strong>: use more threads and more hardware resources.</p>
</li>
<li>
<p><strong>seek more efficiency</strong> in how current resources are used.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Usually, Java developers write programs using blocking code. This practice
is fine until there is a performance bottleneck, at which point the time
comes to introduce additional threads, running similar blocking code. But this
scaling in resource utilization can quickly introduce contention and concurrency
problems.</p>
</div>
<div class="paragraph">
<p>Worse still, blocking wastes resources. If you look closely, as soon as a
program involves some latency (notably I/O, such as a database request or a
network call), resources are wasted because a thread (or many threads)
now sits idle, waiting for data.</p>
</div>
<div class="paragraph">
<p>So the parallelization approach is not a silver bullet. It is necessary in
order to access the full power of the hardware, but it is also complex to
reason about and susceptible to resource wasting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronicity_to_the_rescue"><a class="anchor" href="#_asynchronicity_to_the_rescue"></a>3.2. Asynchronicity to the Rescue?</h3>
<div class="paragraph">
<p>The second approach (mentioned earlier), seeking more efficiency, can be a solution
to the resource wasting problem. By writing <em>asynchronous</em>, <em>non-blocking</em> code,
you let the execution switch to another active task <strong>using the same underlying
resources</strong> and later come back to the current process when the asynchronous
processing has finished.</p>
</div>
<div class="paragraph">
<p>But how can you produce asynchronous code on the JVM? Java offers two models of
asynchronous programming:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callbacks</strong>: Asynchronous methods do not have a return value but take an extra
<code>callback</code> parameter (a lambda or anonymous class) that gets called when the result is
available. A well known example is Swing&#8217;s <code>EventListener</code> hierarchy.</p>
</li>
<li>
<p><strong>Futures</strong>: Asynchronous methods return a <code>Future&lt;T&gt;</code> <strong>immediately</strong>. The asynchronous
process computes a <code>T</code> value, but the <code>Future</code> object wraps access to it. The value is
not immediately available, and the object can be polled until the value is available. For
instance, <code>ExecutorService</code> running <code>Callable&lt;T&gt;</code> tasks use <code>Future</code> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Are these techniques good enough? Not for every use case, and both approaches have
limitations.</p>
</div>
<div class="paragraph">
<p>Callbacks are hard to compose together, quickly leading to code that is difficult to read
and maintain (known as "Callback Hell").</p>
</div>
<div class="paragraph">
<p>Consider an example: showing the top five favorites from a user on the UI or suggestions
if she doesn&#8217;t have a favorite. This goes through three services (one gives favorite IDs,
the second fetches favorite details, and the third offers suggestions with details):</p>
</div>
<div class="listingblock">
<div class="title">Example of Callback Hell</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>
  public void onSuccess(List&lt;String&gt; list) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (list.isEmpty()) { <i class="conum" data-value="3"></i><b>(3)</b>
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { <i class="conum" data-value="4"></i><b>(4)</b>
          UiUtils.submitOnUiThread(() -&gt; { <i class="conum" data-value="5"></i><b>(5)</b>
            list.stream()
                .limit(5)
                .forEach(uiList::show); <i class="conum" data-value="6"></i><b>(6)</b>
            });
        }

        public void onError(Throwable error) { <i class="conum" data-value="7"></i><b>(7)</b>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() <i class="conum" data-value="8"></i><b>(8)</b>
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, <i class="conum" data-value="9"></i><b>(9)</b>
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We have callback-based services: a <code>Callback</code> interface with a method invoked when
the async process was successful and one invoked in case of an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first service invokes its callback with the list of favorite IDs.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the list is empty, we must go to the <code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>suggestionService</code> gives a <code>List&lt;Favorite&gt;</code> to a second callback.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Since we deal with a UI, we need to ensure our consuming code will run in the UI
thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We use Java 8 <code>Stream</code> to limit the number of suggestions processed to five, and we
show them in a graphical list in the UI.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>At each level, we deal with errors the same way: show them in a popup.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Back to the favorite ID level. If the service returned a full list, then we need to
go to the <code>favoriteService</code> to get detailed <code>Favorite</code> objects. Since we want only five,
we first stream the list of IDs to limit it to five.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Once again, a callback. This time we get a fully-fledged <code>Favorite</code> object that we
push to the UI inside the UI thread.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That is a lot of code, and it is a bit hard to follow and has repetitive parts.
Consider its equivalent in Reactor:</p>
</div>
<div class="listingblock">
<div class="title">Example of Reactor code equivalent to callback code</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId) <i class="conum" data-value="1"></i><b>(1)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="2"></i><b>(2)</b>
           .switchIfEmpty(suggestionService.getSuggestions()) <i class="conum" data-value="3"></i><b>(3)</b>
           .take(5) <i class="conum" data-value="4"></i><b>(4)</b>
           .publishOn(UiUtils.uiThreadScheduler()) <i class="conum" data-value="5"></i><b>(5)</b>
           .subscribe(uiList::show, UiUtils::errorPopup); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start with a flow of favorite IDs.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <em>asynchronously transform</em> these into detailed <code>Favorite</code> objects
(<code>flatMap</code>). We now have a flow of <code>Favorite</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In case the flow of <code>Favorite</code> is empty, we switch to a fallback through the
<code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We are only interested in, at most, five elements from the resulting flow.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>At the end, we want to process each piece of data in the UI thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We trigger the flow by describing what to do with the final form of the data
(show it in a UI list) and what to do in case of an error (show a popup).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What if you want to ensure the favorite IDs are retrieved in less than 800ms or, if it
takes longer, get them from a cache? In the callback-based code, that is a complicated
task. In Reactor it becomes as easy as adding a <code>timeout</code> operator in the chain:</p>
</div>
<div class="listingblock">
<div class="title">Example of Reactor code with timeout and fallback</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) <i class="conum" data-value="1"></i><b>(1)</b>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) <i class="conum" data-value="2"></i><b>(2)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="3"></i><b>(3)</b>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the part above emits nothing for more than 800ms, propagate an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of an error, fall back to the <code>cacheService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The rest of the chain is similar to the previous example.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Futures are a bit better than callbacks, but they still do not do well at composition,
despite the improvements brought in Java 8 by <code>CompletableFuture</code>. Orchestrating multiple
futures together is doable but not easy. Also, <code>Future</code> has other problems: It is easy to
end up with another blocking situation with <code>Future</code> objects by calling the <code>get()</code>
method, they do not support lazy computation and they lack support for multiple
values and advanced error handling.</p>
</div>
<div class="paragraph">
<p>Consider another example: We get a list of IDs from which we want to fetch a name and a
statistic and combine these pair-wise, all of it asynchronously.</p>
</div>
<div class="listingblock">
<div class="title">Example of <code>CompletableFuture</code> combination</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <i class="conum" data-value="1"></i><b>(1)</b>

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
	Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
			l.stream().map(i -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
				CompletableFuture&lt;String&gt; nameTask = ifhName(i); <i class="conum" data-value="4"></i><b>(4)</b>
				CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <i class="conum" data-value="5"></i><b>(5)</b>

				return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; "Name " + name + " has stats " + stat); <i class="conum" data-value="6"></i><b>(6)</b>
			});
	List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <i class="conum" data-value="7"></i><b>(7)</b>
	CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <i class="conum" data-value="8"></i><b>(8)</b>
	return allDone.thenApply(v -&gt; combinationList.stream()
			.map(CompletableFuture::join) <i class="conum" data-value="9"></i><b>(9)</b>
			.collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <i class="conum" data-value="10"></i><b>(10)</b>
assertThat(results).contains(
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121");</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start off with a future that gives us a list of <code>id</code> values to process.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We want to start some deeper asynchronous processing once we get the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>For each element in the list:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Asynchronously get the associated name.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Asynchronously get the associated task.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Combine both results.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>We now have a list of futures that represent all the combination tasks. In order to
execute these tasks, we need to convert the list to an array.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Pass the array to <code>CompletableFuture.allOf</code>, which outputs a <code>Future</code> that completes
when all tasks have completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The tricky bit is that <code>allOf</code> returns <code>CompletableFuture&lt;Void&gt;</code>, so we
reiterate over the list of futures, collecting their results via <code>join()</code>
(which here doesn&#8217;t block since <code>allOf</code> ensures the futures are all done).</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Once the whole asynchronous pipeline has been triggered, we wait for it to
be processed and return the list of results that we can assert.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since Reactor has more combination operators out of the box, this process can be
simplified:</p>
</div>
<div class="listingblock">
<div class="title">Example of Reactor code equivalent to future code</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; ids = ifhrIds(); <i class="conum" data-value="1"></i><b>(1)</b>

Flux&lt;String&gt; combinations =
		ids.flatMap(id -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
			Mono&lt;String&gt; nameTask = ifhrName(id); <i class="conum" data-value="3"></i><b>(3)</b>
			Mono&lt;Integer&gt; statTask = ifhrStat(id); <i class="conum" data-value="4"></i><b>(4)</b>

			return nameTask.zipWith(statTask, <i class="conum" data-value="5"></i><b>(5)</b>
					(name, stat) -&gt; "Name " + name + " has stats " + stat);
		});

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <i class="conum" data-value="6"></i><b>(6)</b>

List&lt;String&gt; results = result.block(); <i class="conum" data-value="7"></i><b>(7)</b>
assertThat(results).containsExactly( <i class="conum" data-value="8"></i><b>(8)</b>
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This time, we start from an asynchronously provided sequence of <code>ids</code> (a
<code>Flux&lt;String&gt;</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For each element in the sequence, we asynchronously process it (inside the function
that is the body <code>flatMap</code> call) twice.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the associated name.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get the associated statistic.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Asynchronously combine the 2 values.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Aggregate the values into a <code>List</code> as they become available.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>In production, we would continue working with the <code>Flux</code> asynchronously by further
combining it or subscribing to it. Most probably, we would return the <code>result</code> <code>Mono</code>.
Since we are in a test, we block, waiting for the processing to finish instead, and then
directly return the aggregated list of values.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Assert the result.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These perils of Callback and Future are similar and are what reactive programming
addresses with the <code>Publisher-Subscriber</code> pair.</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_imperative_to_reactive_programming"><a class="anchor" href="#_from_imperative_to_reactive_programming"></a>3.3. From Imperative to Reactive Programming</h3>
<div class="paragraph">
<p>Reactive libraries such as Reactor aim to address these drawbacks of "classic"
asynchronous approaches on the JVM while also focusing on a few additional aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Composability</strong> and <strong>readability</strong></p>
</li>
<li>
<p>Data as a <strong>flow</strong> manipulated with a rich vocabulary of <strong>operators</strong></p>
</li>
<li>
<p>Nothing happens until you <strong>subscribe</strong></p>
</li>
<li>
<p><strong>Backpressure</strong> or <em>the ability for the consumer to signal the producer that the rate of
emission is too high</em></p>
</li>
<li>
<p><strong>High level</strong> but <strong>high value</strong> abstraction that is <em>concurrency-agnostic</em></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_composability_and_readability"><a class="anchor" href="#_composability_and_readability"></a>3.3.1. Composability and Readability</h4>
<div class="paragraph">
<p>By composability, we mean the ability to orchestrate multiple asynchronous tasks, using
results from previous tasks to feed input to subsequent ones or executing several tasks
in a fork-join style, as well as reusing asynchronous tasks as discrete components in a
higher-level system.</p>
</div>
<div class="paragraph">
<p>The ability to orchestrate tasks is tightly coupled to the readability and
maintainability of code. As the layers of asynchronous processes increase in both number
and complexity, being able to compose and read code becomes increasingly difficult. As we
saw, the callback model is simple, but one of its main drawbacks is that, for complex
processes, you need to have a callback executed from a callback, itself nested inside
another callback, and so on. That mess is known as <strong>Callback Hell</strong>. As you can guess (or
know from experience), such code is pretty hard to go back to and reason about.</p>
</div>
<div class="paragraph">
<p>Reactor offers rich composition options, wherein code mirrors the organization of the
abstract process, and everything is generally kept at the same level (nesting is
minimized).</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_assembly_line_analogy"><a class="anchor" href="#_the_assembly_line_analogy"></a>3.3.2. The Assembly Line Analogy</h4>
<div class="paragraph">
<p>You can think of data processed by a reactive application as moving through an assembly
line. Reactor is both the conveyor belt and the workstations. The raw material pours from
a source (the original <code>Publisher</code>) and ends up as a finished product ready to be pushed
to the consumer (or <code>Subscriber</code>).</p>
</div>
<div class="paragraph">
<p>The raw material can go through various transformations and other intermediary steps or
be part of a larger assembly line that aggregates intermediate pieces together. If there
is a glitch or clogging at one point (perhaps boxing the products takes a
disproportionately long time), the afflicted workstation can signal upstream to limit the
flow of raw material.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operators"><a class="anchor" href="#_operators"></a>3.3.3. Operators</h4>
<div class="paragraph">
<p>In Reactor, operators are the workstations in our assembly analogy. Each operator adds
behavior to a <code>Publisher</code> and wraps the previous step&#8217;s <code>Publisher</code> into a new instance.
The whole chain is thus linked, such that data originates from the first <code>Publisher</code> and
moves down the chain, transformed by each link. Eventually, a <code>Subscriber</code> finishes the
process. Remember that nothing happens until a <code>Subscriber</code> subscribes to a <code>Publisher</code>,
as we see shortly.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Understanding that operators create new instances can help you avoid a common
mistake that would lead you to believe that an operator you used in your chain is not
being applied. See this <a href="#faq.chain">item</a> in the FAQ.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While the Reactive Streams specification does not specify operators at all, one of the
best added values of reactive libraries such as Reactor is the rich vocabulary of
operators  that they provide. These cover a lot of ground, from simple transformation and
filtering to complex orchestration and error handling.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.subscribe"><a class="anchor" href="#reactive.subscribe"></a>3.3.4. Nothing Happens Until You <code>subscribe()</code></h4>
<div class="paragraph">
<p>In Reactor, when you write a <code>Publisher</code> chain, data does not start pumping into it by
default. Instead, you create an abstract description of your asynchronous process (which
can help with reusability and composition).</p>
</div>
<div class="paragraph">
<p>By the act of <strong>subscribing</strong>, you tie the <code>Publisher</code> to a <code>Subscriber</code>, which triggers
the flow of data in the whole chain. This is achieved internally by a single <code>request</code>
signal from the <code>Subscriber</code> that is propagated upstream, all the way back to the source
<code>Publisher</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.backpressure"><a class="anchor" href="#reactive.backpressure"></a>3.3.5. Backpressure</h4>
<div class="paragraph">
<p>Propagating signals upstream is also used to implement <strong>backpressure</strong>, which we described
in the assembly line analogy as a feedback signal sent up the line when a workstation
processes more slowly than an upstream workstation.</p>
</div>
<div class="paragraph">
<p>The real mechanism defined by the Reactive Streams specification is pretty close to the
analogy: a subscriber can work in <em>unbounded</em> mode and let the source push all the data
at its fastest achievable rate or it can use the <code>request</code> mechanism to signal the source
that it is ready to process at most <code>n</code> elements.</p>
</div>
<div class="paragraph">
<p>Intermediate operators can also change the request in-transit. Imagine a <code>buffer</code>
operator that groups elements in batches of 10. If the subscriber requests 1 buffer, it
is acceptable for the source to produce 10 elements. Some operators also implement
<strong>prefetching</strong> strategies, which avoids <code>request(1)</code> round-trips and is beneficial
if producing the elements before they are requested is not too costly.</p>
</div>
<div class="paragraph">
<p>This transforms the push model into a <strong>push-pull hybrid</strong> where the downstream can pull n
elements from upstream if they are readily available. But if the elements are not ready,
they get pushed by the upstream whenever they are produced.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.hotCold"><a class="anchor" href="#reactive.hotCold"></a>3.3.6. Hot vs Cold</h4>
<div class="paragraph">
<p>In the Rx family of reactive libraries, one can distinguish two broad categories of
reactive sequences: <strong>hot</strong> and <strong>cold</strong>. This distinction mainly has to do with how the
reactive stream reacts to subscribers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>Cold</strong> sequence starts anew for each <code>Subscriber</code>, including at the source of data.
For example if the source wraps an HTTP call, a new HTTP request is made for each subscription.</p>
</li>
<li>
<p>A <strong>Hot</strong> sequence does not start from scratch for each <code>Subscriber</code>. Rather, late
subscribers receive signals emitted <em>after</em> they subscribed. Note, however, that some hot
reactive streams can cache or replay the history of emissions totally or partially. From
a general perspective, a hot sequence can even emit when no subscriber is listening (an
exception to the "nothing happens before you subscribe" rule).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information on hot vs cold in the context of Reactor, see
<a href="#reactor.hotCold">this reactor-specific section</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/reactiveProgramming.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#intro-reactive">Introduction to Reactive Programming</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-features"><a class="anchor" href="#core-features"></a>4. Reactor Core Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Reactor project main artifact is <code>reactor-core</code>, a reactive library that focuses on
the Reactive Streams specification and targets Java 8.</p>
</div>
<div class="paragraph">
<p>Reactor introduces composable reactive types that implement <code>Publisher</code> but also provide
a rich vocabulary of operators: <code>Flux</code> and <code>Mono</code>. A <code>Flux</code> object
represents a reactive sequence of 0..N items, while a <code>Mono</code> object represents a
single-value-or-empty (0..1) result.</p>
</div>
<div class="paragraph">
<p>This distinction carries a bit of semantic information into the type, indicating the
rough cardinality of the asynchronous processing. For instance, an HTTP request produces
only one response, so there is not much sense in doing a <code>count</code> operation. Expressing
the result of such an HTTP call as a <code>Mono&lt;HttpResponse&gt;</code> thus makes more sense than
expressing it as a <code>Flux&lt;HttpResponse&gt;</code>, as it offers only operators that are relevant to
a context of zero items or one item.</p>
</div>
<div class="paragraph">
<p>Operators that change the maximum cardinality of the processing also switch to the
relevant type. For instance, the <code>count</code> operator exists in <code>Flux</code>, but it returns a
<code>Mono&lt;Long&gt;</code>.</p>
</div>
<div class="sect2">
<h3 id="flux"><a class="anchor" href="#flux"></a>4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</h3>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png" alt="Flux">
</div>
</div>
<div class="paragraph">
<p>A <code>Flux&lt;T&gt;</code> is a standard <code>Publisher&lt;T&gt;</code> representing an asynchronous sequence of 0 to N
emitted items, optionally terminated by either a completion signal or an error.
As in the Reactive Streams spec, these 3 types of signal translate to calls to a downstream
Subscriber&#8217;s <code>onNext</code>, <code>onComplete</code> or <code>onError</code> methods.</p>
</div>
<div class="paragraph">
<p>With this large scope of possible signals, <code>Flux</code> is the general-purpose reactive type.
Note that all events, even terminating ones, are optional: no <code>onNext</code> event but an
<code>onComplete</code> event represents an <em>empty</em> finite sequence, but remove the <code>onComplete</code> and
you have an <em>infinite</em> empty sequence (not particularly useful, except for tests around cancellation).
Similarly, infinite sequences are not necessarily empty. For example, <code>Flux.interval(Duration)</code> produces a <code>Flux&lt;Long&gt;</code> that is infinite
and emits regular ticks from a clock.</p>
</div>
</div>
<div class="sect2">
<h3 id="mono"><a class="anchor" href="#mono"></a>4.2. <code>Mono</code>, an Asynchronous 0-1 Result</h3>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/mono.png" alt="Mono">
</div>
</div>
<div class="paragraph">
<p>A <code>Mono&lt;T&gt;</code> is a specialized <code>Publisher&lt;T&gt;</code> that emits at most one item and then
optionally terminates with an <code>onComplete</code> signal or an <code>onError</code> signal.</p>
</div>
<div class="paragraph">
<p>It offers only a subset of the operators that are available for a <code>Flux</code>, and
some operators (notably those that combine the <code>Mono</code> with another <code>Publisher</code>)
switch to a <code>Flux</code>.<br>
For example, <code>Mono#concatWith(Publisher)</code> returns a <code>Flux</code> while <code>Mono#then(Mono)</code>
returns another <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>Note that a <code>Mono</code> can be used to represent no-value asynchronous processes that only
have the concept of completion (similar to a <code>Runnable</code>). To create one, use an empty
<code>Mono&lt;Void&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"><a class="anchor" href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"></a>4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</h3>
<div class="paragraph">
<p>The easiest way to get started with <code>Flux</code> and <code>Mono</code> is to use one of the numerous
factory methods found in their respective classes.</p>
</div>
<div class="paragraph">
<p>For instance, to create a sequence of <code>String</code>, you can either enumerate them or put them
in a collection and create the Flux from it, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; seq1 = Flux.just("foo", "bar", "foobar");

List&lt;String&gt; iterable = Arrays.asList("foo", "bar", "foobar");
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other examples of factory methods include the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; noData = Mono.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

Mono&lt;String&gt; data = Mono.just("foo");

Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice the factory method honors the generic type even though it has no value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first parameter is the start of the range, while the second parameter is the
number of items to produce.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When it comes to subscribing, <code>Flux</code> and <code>Mono</code> make use of Java 8 lambdas. You
have a wide choice of <code>.subscribe()</code> variants that take lambdas for different
combinations of callbacks, as shown in the following method signatures:</p>
</div>
<div id="subscribeMethods" class="listingblock">
<div class="title">Lambda-based subscribe variants for <code>Flux</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">subscribe(); <i class="conum" data-value="1"></i><b>(1)</b>

subscribe(Consumer&lt;? super T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); <i class="conum" data-value="3"></i><b>(3)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); <i class="conum" data-value="4"></i><b>(4)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Subscribe and trigger the sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Do something with each produced value.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Deal with values but also react to an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Deal with values and errors but also execute some code when the sequence successfully
completes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Deal with values and errors and successful completion but also do something with the
<code>Subscription</code> produced by this <code>subscribe</code> call.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These variants return a reference to the subscription that you can use to cancel the
subscription when no more data is needed. Upon cancellation, the source should stop
producing values and clean up any resources it created. This cancel and clean-up behavior
is represented in Reactor by the general-purpose <code>Disposable</code> interface.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_subscribe_method_examples"><a class="anchor" href="#_subscribe_method_examples"></a>4.3.1. <code>subscribe</code> Method Examples</h4>
<div class="paragraph">
<p>This section contains minimal examples of each of the five signatures for the <code>subscribe</code>
method. The following code shows an example of the basic method with no arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a <code>Flux</code> that produces three values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe in the simplest way.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding code produces no visible output, but it does work. The <code>Flux</code> produces
three values. If we provide a lambda, we can make the values visible. The next example
for the <code>subscribe</code> method shows one way to make the values appear:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a <code>Flux</code> that produces three values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe with a subscriber that will print the values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3</pre>
</div>
</div>
<div class="paragraph">
<p>To demonstrate the next signature, we intentionally introduce an error, as
shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4) <i class="conum" data-value="1"></i><b>(1)</b>
      .map(i -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        if (i &lt;= 3) return i; <i class="conum" data-value="3"></i><b>(3)</b>
        throw new RuntimeException("Got to 4"); <i class="conum" data-value="4"></i><b>(4)</b>
      });
ints.subscribe(i -&gt; System.out.println(i), <i class="conum" data-value="5"></i><b>(5)</b>
      error -&gt; System.err.println("Error: " + error));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a Flux that produces four values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need a map so that we can handle some values differently.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>For most values, return the value.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>For one value, force an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Subscribe with a subscriber that includes an error handler.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We now have two lambda expressions: one for the content we expect and one for
errors. The preceding code produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3
Error: java.lang.RuntimeException: Got to 4</pre>
</div>
</div>
<div class="paragraph">
<p>The next signature of the <code>subscribe</code> method includes both an error handler and
a handler for completion events, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done")); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a Flux that produces four values when a Subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe with a Subscriber that includes a handler for completion events.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Error signals and completion signals are both terminal events and are exclusive of one
another (you never get both). To make the completion consumer work, we must take care not
to trigger an error.</p>
</div>
<div class="paragraph">
<p>The completion callback has no input, as represented by an empty pair of
parentheses: it matches the <code>run</code> method in the <code>Runnable</code> interface. The preceding code
produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
2
3
4
Done</pre>
</div>
</div>
<div class="paragraph">
<p>The last signature of the <code>subscribe</code> method includes a <code>Consumer&lt;Subscription&gt;</code>.
That variant requires you to do something with the <code>Subscription</code> (perform a
<code>request(long)</code> on it, or <code>cancel()</code> it), otherwise the <code>Flux</code> will just hang:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done"),
    sub -&gt; sub.request(10)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When we subscribe we receive a <code>Subscription</code>. Signal that we want up to <code>10</code>
elements from the source (which will actually emit 4 elements and complete).</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling_a_subscribe_with_its_disposable"><a class="anchor" href="#_cancelling_a_subscribe_with_its_disposable"></a>4.3.2. Cancelling a <code>subscribe()</code> with its <code>Disposable</code></h4>
<div class="paragraph">
<p>All these lambda-based variants of <code>subscribe()</code> have a <code>Disposable</code> return type.
In this case, the <code>Disposable</code> interface represents the fact that the subscription
can be <em>cancelled</em>, by calling its <code>dispose()</code> method.</p>
</div>
<div class="paragraph">
<p>For a <code>Flux</code> or <code>Mono</code>, cancellation is a signal that the source should stop
producing elements. However, it is NOT guaranteed to be immediate: some sources
might produce elements so fast that they could complete even before receiving the
cancel instruction.</p>
</div>
<div class="paragraph">
<p>Some utilities around <code>Disposable</code> are available in the <code>Disposables</code> class.
Among these, <code>Disposables.swap()</code> creates a <code>Disposable</code> wrapper that allows
you to atomically cancel and replace a concrete <code>Disposable</code>. This can be useful,
for instance, in a UI scenario where you want to cancel a request and replace it
with a new one whenever the user clicks on a button. Disposing the wrapper itself
closes it, disposing the current concrete value and all future attempted replacements.</p>
</div>
<div class="paragraph">
<p>Another interesting utility is <code>Disposables.composite(...)</code>. This composite
allows to collect several <code>Disposable</code>, for instance multiple in-flight request
associated with a service call, and dispose all of them at once later on.
Once the composite&#8217;s <code>dispose()</code> method has been called, any attempt at adding
another <code>Disposable</code> immediately disposes it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_alternative_to_lambdas_basesubscriber"><a class="anchor" href="#_alternative_to_lambdas_basesubscriber"></a>4.3.3. Alternative to lambdas: <code>BaseSubscriber</code></h4>
<div class="paragraph">
<p>There is an additional <code>subscribe</code> method that is more generic and takes a full-blown
<code>Subscriber</code> rather than composing one out of lambdas. In order to help you writing
such a <code>Subscriber</code>, we provide an extendable class called <code>BaseSubscriber</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s implement one of these, we&#8217;ll call it a <code>SampleSubscriber</code>. The following
example shows how it would be attached to a <code>Flux</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; {System.out.println("Done");},
    s -&gt; s.request(10));
ints.subscribe(ss);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s have a look at what <code>SampleSubscriber</code> could look like, as a minimalistic
implementation of a <code>BaseSubscriber</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.projectreactor.samples;

import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println("Subscribed");
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The SampleSubscriber class extends <code>BaseSubscriber</code>, which is the recommended abstract
class for user-defined <code>Subscribers</code> in Reactor. The class offers hooks that can be
overridden to tune the subscriber&#8217;s behavior. By default, it will trigger an unbounded
request and behave exactly like <code>subscribe()</code>. However, extending <code>BaseSubscriber</code> is
much more useful when you want a custom request amount.</p>
</div>
<div class="paragraph">
<p>For custom request amount, the bare minimum is to implement <code>hookOnSubscribe(Subscription subscription)</code>
and <code>hookOnNext(T value)</code> like we did. In our case, the <code>hookOnSubscribe</code> method
prints a statement to standard out and makes the first request. Then the <code>hookOnNext</code>
method prints a statement and performs additional requests, one request
at a time.</p>
</div>
<div class="paragraph">
<p>The <code>SampleSubscriber</code> class produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Subscribed
1
2
3
4</pre>
</div>
</div>
<div class="paragraph">
<p><code>BaseSubscriber</code> also offers a <code>requestUnbounded()</code> method to switch to unbounded mode
(equivalent to <code>request(Long.MAX_VALUE)</code>), as well as a <code>cancel()</code> method.</p>
</div>
<div class="paragraph">
<p>It has additional hooks: <code>hookOnComplete</code>, <code>hookOnError</code>, <code>hookOnCancel</code>, and <code>hookFinally</code>
(which is always called when the sequence terminates, with the type of termination passed
in as a <code>SignalType</code> parameter)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You almost certainly want to implement the <code>hookOnError</code>, <code>hookOnCancel</code>, and
<code>hookOnComplete</code> methods. You may also want to implement the <code>hookFinally</code> method.
<code>SampleSubscribe</code> is the absolute minimum implementation of a <code>Subscriber</code> <em>that performs
bounded requests</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_on_backpressure_and_ways_to_reshape_requests"><a class="anchor" href="#_on_backpressure_and_ways_to_reshape_requests"></a>4.3.4. On Backpressure, and ways to reshape requests</h4>
<div class="paragraph">
<p>When implementing backpressure in Reactor, the way consumer pressure is propagated back to the source is by sending a <code>request</code> to the upstream operator.
The sum of current requests is sometimes referenced to as the current "demand", or "pending request".
Demand is capped at <code>Long.MAX_VALUE</code>, representing an unbounded request ("produce as fast as you can", basically disabling backpressure).</p>
</div>
<div class="paragraph">
<p>The first request comes from the final subscriber, at subscription time, yet the most direct ways of subscribing all immediately trigger an unbounded request of <code>Long.MAX_VALUE</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subscribe()</code> and most of its lambda-based variants (to the exception of the one that has a Consumer&lt;Subscription&gt;)</p>
</li>
<li>
<p><code>block()</code>, <code>blockFirst()</code> and <code>blockLast()</code></p>
</li>
<li>
<p>iterating over a <code>toIterable()</code>/<code>toStream()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The simplest way of customizing the original request is to <code>subscribe</code> with a <code>BaseSubscriber</code> with the <code>hookOnSubscribe</code> method overridden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println("request of " + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This snippets prints out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>request of 1
Cancelling after having received 1</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When manipulating a request, you must be careful to produce enough demand for
the sequence to advance or your Flux will get "stuck". That is why <code>BaseSubscriber</code>
defaults to an unbounded request in <code>hookOnSubscribe</code>. When overriding this hook, you should usually
call <code>request</code> at least once.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_operators_changing_the_demand_from_downstream"><a class="anchor" href="#_operators_changing_the_demand_from_downstream"></a>Operators changing the demand from downstream</h5>
<div class="paragraph">
<p>One thing to keep in mind is that demand expressed at the subscribe level <strong>can</strong> be reshaped by each operator in the chain upstream.
A textbook case is the <code>buffer(N)</code> operator: if it receives a <code>request(2)</code>, it is interpreted as a demand for <strong>two full buffers</strong>.
As a consequence, since buffers need <code>N</code> elements to be considered full, the <code>buffer</code> operator reshapes the request to <code>2 x N</code>.</p>
</div>
<div class="paragraph">
<p>You might also have noticed that some operators have variants that take an <code>int</code> input parameter called <code>prefetch</code>.
This is another category of operators that modify the downstream request.
These are usually operators that deal with inner sequences, deriving a <code>Publisher</code> from each incoming element (like <code>flatMap</code>).</p>
</div>
<div class="paragraph">
<p><strong>Prefetch</strong> is a way to tune the initial request made on these inner sequences.
If unspecified, most of these operators start with a demand of <code>32</code>.</p>
</div>
<div class="paragraph">
<p>These operators usually also implement a <strong>replenishing optimization</strong>: once the operator has seen 25% of the prefetch request fulfilled, it re-requests 25% from upstream.
This is a heuristic optimization made so that these operators proactively anticipate the upcoming requests.</p>
</div>
<div class="paragraph">
<p>Finally, a couple of operators are made to directly let you tune the request: <code>limitRate</code> and <code>limitRequest</code>.</p>
</div>
<div class="paragraph">
<p><code>limitRate(N)</code> splits the downstream requests so that they are propagated upstream in smaller batches.
For instance, a request of <code>100</code> made to <code>limitRate(10)</code> would result in <em>at most</em> <code>10</code> requests of <code>10</code> being propagated to the upstream.
Note that in this form <code>limitRate</code> actually implements the replenishing optimization discussed above.</p>
</div>
<div class="paragraph">
<p>The operator has a variant that also lets you tune the replenishing amount, referred to as the <code>lowTide</code> in the variant: <code>limitRate(highTide, lowTide)</code>.
Choosing a <code>lowTide</code> of <code>0</code> will result in <strong>strict</strong> batches of <code>highTide</code> requests, instead of batches further reworked by the replenishing strategy.</p>
</div>
<div class="paragraph">
<p><code>limitRequest(N)</code> on the other hand <strong>caps</strong> the downstream request to a maximum total demand.
It adds up requests up to <code>N</code>. If a single <code>request</code> doesn&#8217;t make the total demand overflow over <code>N</code>, that particular request is wholly propagated upstream.
After that amount has been emitted by the source, <code>limitRequest</code> will consider the sequence complete and send an <code>onComplete</code> signal downstream and cancel the source.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing"><a class="anchor" href="#producing"></a>4.4. Programmatically creating a sequence</h3>
<div class="paragraph">
<p>In this section, we introduce the creation of a <code>Flux</code> or a <code>Mono</code> by
programmatically defining its associated events (<code>onNext</code>, <code>onError</code>, and
<code>onComplete</code>). All these methods share the fact that they expose an API to
trigger the events that we call a <strong>sink</strong>. There are actually a few sink
variants, which we&#8217;ll get to shortly.</p>
</div>
<div class="sect3">
<h4 id="producing.generate"><a class="anchor" href="#producing.generate"></a>4.4.1. Synchronous <code>generate</code></h4>
<div class="paragraph">
<p>The simplest form of programmatic creation of a <code>Flux</code> is through the <code>generate</code>
method, which takes a generator function.</p>
</div>
<div class="paragraph">
<p>This is for <strong>synchronous</strong> and <strong>one-by-one</strong> emissions, meaning that
the sink is a <code>SynchronousSink</code> and that its <code>next()</code> method can only be called
at most once per callback invocation. You can then additionally call <code>error(Throwable)</code>
or <code>complete()</code>, but this is optional.</p>
</div>
<div class="paragraph">
<p>The most useful variant is probably the one that also lets you keep a state
that you can refer to in your sink usage to decide what to emit next. The generator
function then becomes a <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code>, with <code>&lt;S&gt;</code> the
type of the state object. You have to provide a <code>Supplier&lt;S&gt;</code> for the initial
state, and your generator function now returns a new state on each round.</p>
</div>
<div class="paragraph">
<p>For instance, you could use an <code>int</code> as the state:</p>
</div>
<div class="listingblock">
<div class="title">Example of state-based <code>generate</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      sink.next("3 x " + state + " = " + 3*state); <i class="conum" data-value="2"></i><b>(2)</b>
      if (state == 10) sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
      return state + 1; <i class="conum" data-value="4"></i><b>(4)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We supply the initial state value of 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use the state to choose what to emit (a row in the multiplication table
of 3).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We also use it to choose when to stop.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We return a new state that we use in the next invocation (unless the
sequence terminated in this one).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code above generates the table of 3, as the following sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use a mutable <code>&lt;S&gt;</code>. The example above could for instance be
rewritten using a single <code>AtomicLong</code> as the state, mutating it on each round:</p>
</div>
<div class="listingblock">
<div class="title">Mutable state variant</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This time, we generate a mutable object as the state.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We mutate the state here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We return the <strong>same</strong> instance as the new state.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your state object needs to clean up some resources, use the
<code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> variant to clean up the last
state instance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of using the generate method that includes a <code>Consumer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    }, (state) -&gt; System.out.println("state: " + state)); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again, we generate a mutable object as the state.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We mutate the state here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We return the <strong>same</strong> instance as the new state.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We see the last state value (11) as the output of this <code>Consumer</code> lambda.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of the state containing a database connection or other resource
that needs to be handled at the end of the process, the <code>Consumer</code> lambda could
close the connection or  otherwise handle any tasks that should be done at the
end of the process.</p>
</div>
</div>
<div class="sect3">
<h4 id="producing.create"><a class="anchor" href="#producing.create"></a>4.4.2. Asynchronous &amp; multi-threaded: <code>create</code></h4>
<div class="paragraph">
<p><code>create</code> is a more advanced form of programmatic creation of a <code>Flux</code> which is
suitable for multiple emissions per round, even from multiple threads.</p>
</div>
<div class="paragraph">
<p>It exposes a <code>FluxSink</code>, with its <code>next</code>, <code>error</code>, and <code>complete</code> methods.
Contrary to <code>generate</code>, it doesn&#8217;t have a state-based variant. On the other
hand, it can trigger multi-threaded events in the callback.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>create</code> can be very useful to bridge an existing API with the reactive
world - such as an asynchronous API based on listeners.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>create</code> <strong>doesn&#8217;t parallelize your code nor does it make it asynchronous</strong>, even
though it <em>can</em> be used with asynchronous APIs. If you block within the <code>create</code> lambda,
you expose yourself to deadlocks and similar side effects. Even with the use of <code>subscribeOn</code>,
there&#8217;s the caveat that a long-blocking <code>create</code> lambda (such as an infinite loop calling
<code>sink.next(t)</code>) can lock the pipeline: the requests would never be performed due to the
loop starving the same thread they are supposed to run from. Use the <code>subscribeOn(Scheduler, false)</code>
variant: <code>requestOnSeparateThread = false</code> will use the <code>Scheduler</code> thread for the <code>create</code>
and still let data flow by performing <code>request</code> in the original thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine that you use a listener-based API. It processes data by chunks
and has two events: (1) a chunk of data is ready and (2) the processing is
complete (terminal event), as represented in the <code>MyEventListener</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>create</code> to bridge this into a <code>Flux&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( <i class="conum" data-value="4"></i><b>(4)</b>
      new MyEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bridge to the <code>MyEventListener</code> API</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Each element in a chunk becomes an element in the <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>processComplete</code> event is translated to <code>onComplete</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>All of this is done asynchronously whenever the <code>myEventProcessor</code> executes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Additionally, since <code>create</code> can bridge asynchronous APIs and manages backpressure, you
can refine how to behave backpressure-wise, by indicating an <code>OverflowStrategy</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> to Completely ignore downstream backpressure requests.
This may yield <code>IllegalStateException</code> when queues get full downstream.</p>
</li>
<li>
<p><code>ERROR</code> to signal an <code>IllegalStateException</code> when the downstream can&#8217;t keep
up.</p>
</li>
<li>
<p><code>DROP</code> to drop the incoming signal if the downstream is not ready to receive
it.</p>
</li>
<li>
<p><code>LATEST</code> to let downstream only get the latest signals from upstream.</p>
</li>
<li>
<p><code>BUFFER</code> (the default) to buffer all signals if the downstream can&#8217;t keep up.
(this does unbounded buffering and may lead to <code>OutOfMemoryError</code>).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Mono</code> also has a <code>create</code> generator. The <code>MonoSink</code> of Mono&#8217;s create
doesn&#8217;t allow several emissions. It will drop all signals after the first one.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_but_single_threaded_push"><a class="anchor" href="#_asynchronous_but_single_threaded_push"></a>4.4.3. Asynchronous but single-threaded: <code>push</code></h4>
<div class="paragraph">
<p><code>push</code> is a middle ground between <code>generate</code> and <code>create</code> which is suitable for
processing events from a single producer. It is similar to <code>create</code> in the sense
that it can also be asynchronous and can manage backpressure using any of the
overflow strategies supported by <code>create</code>. However, <strong>only one producing thread</strong>
may invoke <code>next</code>, <code>complete</code> or <code>error</code> at a time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }

        public void processError(Throwable e) {
            sink.error(e); <i class="conum" data-value="4"></i><b>(4)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bridge to the <code>SingleThreadEventListener</code> API.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Events are pushed to the sink using <code>next</code> from a single listener thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>complete</code> event generated from the same listener thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>error</code> event also generated from the same listener thread.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_an_hybrid_pushpull_model"><a class="anchor" href="#_an_hybrid_pushpull_model"></a>An hybrid push/pull model</h5>
<div class="paragraph">
<p>Most Reactor operators, like <code>create</code>, follow an hybrid <strong>push/pull</strong> model.
What we mean by that is that despite most of the processing being asynchronous
(suggesting a <em>push</em> approach), there is a small <em>pull</em> component to it: the
request.</p>
</div>
<div class="paragraph">
<p>The consumer <em>pulls</em> data from the source in the sense that it won&#8217;t emit anything
until first requested. The source <em>pushes</em> data to the consumer whenever it
becomes available, but within the bounds of its requested amount.</p>
</div>
<div class="paragraph">
<p>Note that <code>push()</code> and <code>create()</code> both allow to set up an <code>onRequest</code> consumer
in order to manage the request amount and to ensure that data is pushed through
the sink only when there is pending request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
          for(String s : messages) {
            sink.next(s); <i class="conum" data-value="3"></i><b>(3)</b>
          }
        }
    });
    sink.onRequest(n -&gt; {
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <i class="conum" data-value="1"></i><b>(1)</b>
        for(String s : message) {
           sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Poll for messages when requests are made.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If messages are available immediately, push them to the sink.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The remaining messages that arrive asynchronously later are also delivered.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_cleaning_up_after_push_or_create"><a class="anchor" href="#_cleaning_up_after_push_or_create"></a>Cleaning up after <code>push()</code> or <code>create()</code></h5>
<div class="paragraph">
<p>Two callbacks, <code>onDispose</code> and <code>onCancel</code>, perform any cleanup on cancellation
or termination. <code>onDispose</code> can be used to perform cleanup when the <code>Flux</code>
completes, errors out, or is cancelled. <code>onCancel</code> can be used to perform any
action specific to cancellation prior to cleanup with <code>onDispose</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        .onCancel(() -&gt; channel.cancel()) <i class="conum" data-value="1"></i><b>(1)</b>
        .onDispose(() -&gt; channel.close())  <i class="conum" data-value="2"></i><b>(2)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>onCancel</code> is invoked first, for cancel signal only.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>onDispose</code> is invoked for complete, error, or cancel signals.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handle"><a class="anchor" href="#_handle"></a>4.4.4. Handle</h4>
<div class="paragraph">
<p>The <code>handle</code> method is a bit different: it is an instance method, meaning that
it is chained on an existing source (as are the common operators). It is present
in both <code>Mono</code> and <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>It is close to <code>generate</code>, in the sense that it uses a <code>SynchronousSink</code> and
only allows one-by-one emissions. However, <code>handle</code> can be used to generate an
arbitrary value out of each source element, possibly skipping some elements. In
this way, it can serve as a combination of <code>map</code> and <code>filter</code>. The signature of
handle is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider an example. The reactive streams specification disallows <code>null</code>
values in a sequence. What if you want to perform a <code>map</code> but you want to use
a preexisting method as the map function, and that method sometimes returns null?</p>
</div>
<div class="paragraph">
<p>For instance, the following method can be applied safely to a source of
integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String alphabet(int letterNumber) {
	if (letterNumber &lt; 1 || letterNumber &gt; 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return "" + (char) letterIndexAscii;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then use <code>handle</code> to remove any nulls:</p>
</div>
<div class="listingblock">
<div class="title">Using <code>handle</code> for a "map and eliminate nulls" scenario</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); <i class="conum" data-value="1"></i><b>(1)</b>
        if (letter != null) <i class="conum" data-value="2"></i><b>(2)</b>
            sink.next(letter); <i class="conum" data-value="3"></i><b>(3)</b>
    });

alphabet.subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Map to letters.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the "map function" returns null&#8230;&#8203;.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Filter it out by not calling <code>sink.next</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Which will print out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>M
I
T</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schedulers"><a class="anchor" href="#schedulers"></a>4.5. Threading and Schedulers</h3>
<div class="paragraph">
<p>Reactor, like RxJava, can be considered <strong>concurrency agnostic</strong>. That is, it does not
enforce a concurrency model. Rather it leaves you, the developer, in command. However,
that does not prevent the library from helping you with concurrency.</p>
</div>
<div class="paragraph">
<p>Obtaining a <code>Flux</code> or a <code>Mono</code> doesn&#8217;t necessarily mean it will run in a dedicated
<code>Thread</code>. Instead, most operators continue working in the <code>Thread</code> on which the
previous operator executed. Unless specified, the topmost operator (the source)
itself runs on the <code>Thread</code> in which the <code>subscribe()</code> call was made.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
  final Mono&lt;String&gt; mono = Mono.just("hello "); <i class="conum" data-value="1"></i><b>(1)</b>

  new Thread(() -&gt; mono
      .map(msg -&gt; msg + "thread ")
      .subscribe(v -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
          System.out.println(v + Thread.currentThread().getName()) <i class="conum" data-value="3"></i><b>(3)</b>
      )
  ).join();

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Mono&lt;String&gt;</code> is assembled in thread <code>main</code>&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;but it is subscribed to in thread <code>Thread-0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>As a consequence, both the <code>map</code> and onNext callback actually run in <code>Thread-0</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code above produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hello thread Thread-0</pre>
</div>
</div>
<div class="paragraph">
<p>In Reactor, the execution model and where the execution happens is determined by the
<code>Scheduler</code> that is used. A
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a>
has scheduling responsibilities similar to an <code>ExecutorService</code>, but having a
dedicated abstraction allows to do more, notably acting as a clock and enabling
a wider range of implementations (virtual time for tests, trampolining or
immediate scheduling, etc&#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a>
class has static methods that give access to the following execution contexts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The current thread (<code>Schedulers.immediate()</code>).</p>
</li>
<li>
<p>A single, reusable thread (<code>Schedulers.single()</code>). Note that this method reuses the
same thread for all callers, until the Scheduler is disposed. If you want a per-call
dedicated thread, use <code>Schedulers.newSingle()</code> for each call.</p>
</li>
<li>
<p>An elastic thread pool (<code>Schedulers.elastic()</code>). It creates new worker pools as needed,
and reuse idle ones. Worker pools that stay idle for too long (default is 60s) are
disposed. This is a good choice for I/O blocking work for instance.
<code>Schedulers.elastic()</code> is a handy way to give a blocking process its own thread, so that
it does not tie up other resources. See <a href="#faq.wrap-blocking">How do I wrap a synchronous, blocking call?</a>.</p>
</li>
<li>
<p>a fixed pool of workers that is tuned for parallel work (<code>Schedulers.parallel()</code>). It
creates as many workers as you have CPU cores.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, you can create a <code>Scheduler</code> out of any pre-existing <code>ExecutorService</code> by
using <code>Schedulers.fromExecutorService(ExecutorService)</code>. (You can also create one from an
<code>Executor</code>, although doing so is discouraged.)</p>
</div>
<div class="paragraph">
<p>You can also create new instances of the various scheduler types by using the <code>newXXX</code>
methods. For example, <code>Schedulers.newElastic(yourScheduleName)</code> creates a new elastic
scheduler named <code>yourScheduleName</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
While <code>elastic</code> is made to help with legacy blocking code if it cannot be avoided,
<code>single</code> and <code>parallel</code> are not. As a consequence, the use of Reactor blocking APIs
(<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code>, as well as iterating over <code>toIterable()</code>
or <code>toStream()</code>) inside the default single and parallel Schedulers will result in
an <code>IllegalStateException</code> being thrown.
<br>
<br>
Custom <code>Schedulers</code> can also be marked as "non blocking only" by creating instances of <code>Thread</code>
that implement the <code>NonBlocking</code> marker interface.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some operators use a specific Scheduler from <code>Schedulers</code> by default (and usually give
you the option of providing a different one). For instance, calling the factory method
<code>Flux.interval(Duration.ofMillis(300))</code> produces a <code>Flux&lt;Long&gt;</code> that ticks every 300ms.
By default, this is enabled by <code>Schedulers.parallel()</code>. The following line changes the
Scheduler to a new instance similar to <code>Schedulers.single()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reactor offers two means of switching the execution context (or <code>Scheduler</code>) in a
reactive chain: <code>publishOn</code> and <code>subscribeOn</code>. Both take a <code>Scheduler</code> and let you switch
the execution context to that scheduler. But the placement of <code>publishOn</code> in the chain
matters, while the placement of <code>subscribeOn</code> does not. To understand that difference,
you first have to remember that <a href="#reactive.subscribe">nothing happens until you
subscribe()</a>.</p>
</div>
<div class="paragraph">
<p>In Reactor, when you chain operators, you can wrap as many <code>Flux</code> and <code>Mono</code>
implementations inside one another as you need. Once you subscribe, a chain of
<code>Subscriber</code> objects is created, backward (up the chain) to the first
publisher. This is effectively hidden from you. All you can see is the outer layer of
<code>Flux</code> (or <code>Mono</code>) and <code>Subscription</code>, but these intermediate operator-specific
subscribers are where the real work happens.</p>
</div>
<div class="paragraph">
<p>With that knowledge, we can have a closer look at the <code>publishOn</code> and <code>subscribeOn</code>
operators:</p>
</div>
<div class="sect3">
<h4 id="_publishon"><a class="anchor" href="#_publishon"></a>4.5.1. <code>publishOn</code></h4>
<div class="paragraph">
<p><code>publishOn</code> applies in the same way as any other operator, in the middle of the
subscriber chain. It takes signals from upstream and replays them downstream while
executing the callback on a worker from the associated <code>Scheduler</code>. Consequently, it
<strong>affects where the subsequent operators will execute</strong> (until another <code>publishOn</code> is
chained in):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changes the execution context to one <code>Thread</code> picked by the <code>Scheduler</code></p>
</li>
<li>
<p>as per the specification, <code>onNext</code> happen in sequence, so this uses up a single thread</p>
</li>
<li>
<p>unless they work on a specific <code>Scheduler</code>, operators after <code>publishOn</code> continue execution on that same thread</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .publishOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a new <code>Scheduler</code> backed by 4 <code>Thread</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first <code>map</code> runs on the anonymous thread in &lt;5&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>publishOn</code> switches the whole sequence on a <code>Thread</code> picked from &lt;1&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The second <code>map</code> runs on said <code>Thread</code> from &lt;1&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This anonymous <code>Thread</code> is the one where the <em>subscription</em> happens. The print happens on the latest execution context which is the one from <code>publishOn</code></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_subscribeon"><a class="anchor" href="#_subscribeon"></a>4.5.2. <code>subscribeOn</code></h4>
<div class="paragraph">
<p><code>subscribeOn</code> applies to the subscription process, when that backward chain is
constructed. As a consequence, no matter where you place the <code>subscribeOn</code> in the chain,
<strong>it always affects the context of the source emission</strong>. However, this does not affect the
behavior of subsequent calls to <code>publishOn</code>. They still switch the execution context for
the part of the chain after them.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changes the <code>Thread</code> from which the <strong>whole chain</strong> of operators above subscribes</p>
</li>
<li>
<p>picks one thread from the <code>Scheduler</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only the earliest <code>subscribeOn</code> call in the chain is actually taken into account.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .subscribeOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a new <code>Scheduler</code> backed by 4 <code>Thread</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first <code>map</code> runs on one of these 4 threads&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;because <code>subscribeOn</code> switches the whole sequence right from subscription time (&lt;5&gt;)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The second <code>map</code> also runs on same thread</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This anonymous <code>Thread</code> is the one where the <em>subscription</em> initially happens, but <code>subscribeOn</code> immediately shifts it to one of the 4 scheduler threads&#8230;&#8203;</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error.handling"><a class="anchor" href="#error.handling"></a>4.6. Handling Errors</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For a quick look at the available operators for error handling, see
<a href="#which.errors">the relevant operator decision tree</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Reactive Streams, errors are terminal events. As soon as an error occurs, it stops the
sequence and gets propagated down the chain of operators to the last step, the
<code>Subscriber</code> you defined and its <code>onError</code> method.</p>
</div>
<div class="paragraph">
<p>Such errors should still be dealt with at the application level. For instance, you might
display an error notification in a UI or send a meaningful error payload in a REST
endpoint. For this reason, the subscriber&#8217;s <code>onError</code> method should always be defined.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If not defined, <code>onError</code> throws an <code>UnsupportedOperationException</code>. You can
further detect and triage it with the <code>Exceptions.isErrorCallbackNotImplemented</code> method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor also offers alternative means of dealing with errors in the middle of the chain,
as error-handling operators. Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(1, 2, 0)
    .map(i -&gt; "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Before you learn about error-handling operators, you must keep in mind that
<strong>any error in a reactive sequence is a terminal event</strong>. Even if an error-handling
operator is used, it does not allow the <strong>original</strong> sequence to continue. Rather, it
converts the <code>onError</code> signal into the start of a <strong>new</strong> sequence (the fallback one). In
other words, it replaces the terminated sequence <em>upstream</em> of it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can consider each means of error handling one-by-one. When relevant, we make a
parallel with imperative programming&#8217;s <code>try</code> patterns.</p>
</div>
<div class="sect3">
<h4 id="_error_handling_operators"><a class="anchor" href="#_error_handling_operators"></a>4.6.1. Error Handling Operators</h4>
<div class="paragraph">
<p>You may be familiar with several ways of dealing with exceptions in a try-catch block.
Most notably, these include the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catch and return a static default value.</p>
</li>
<li>
<p>Catch and execute an alternative path with a fallback method.</p>
</li>
<li>
<p>Catch and dynamically compute a fallback value.</p>
</li>
<li>
<p>Catch, wrap to a <code>BusinessException</code>, and re-throw.</p>
</li>
<li>
<p>Catch, log an error-specific message, and re-throw.</p>
</li>
<li>
<p>Use the <code>finally</code> block to clean up resources or a Java 7 "try-with-resource" construct.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All of these have equivalents in Reactor, in the form of error-handling operators.
Before looking into these operators, let&#8217;s first establish a parallel between a reactive
chain and a try-catch block.</p>
</div>
<div class="paragraph">
<p>When subscribing, the <code>onError</code> callback at the end of the chain is akin to a <code>catch</code>
block. There, execution skips to the catch in case an <code>Exception</code> is thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) <i class="conum" data-value="1"></i><b>(1)</b>
    .map(v -&gt; doSecondTransform(v)); <i class="conum" data-value="2"></i><b>(2)</b>
s.subscribe(value -&gt; System.out.println("RECEIVED " + value), <i class="conum" data-value="3"></i><b>(3)</b>
            error -&gt; System.err.println("CAUGHT " + error) <i class="conum" data-value="4"></i><b>(4)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A transformation is performed that can throw an exception.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If everything went well, a second transformation is performed.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Each successfully transformed value is printed out.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In case of an error, the sequence terminates and an error message is displayed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is conceptually similar to the following try/catch block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
    for (int i = 1; i &lt; 11; i++) {
        String v1 = doSomethingDangerous(i); <i class="conum" data-value="1"></i><b>(1)</b>
        String v2 = doSecondTransform(v1); <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If an exception is thrown here&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;the rest of the loop is skipped&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;the execution goes straight to here.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now that we have established a parallel, we&#8217;ll look at the different error handling cases
and their equivalent operators.</p>
</div>
<div class="sect4">
<h5 id="_static_fallback_value"><a class="anchor" href="#_static_fallback_value"></a>Static Fallback Value</h5>
<div class="paragraph">
<p>The equivalent of "<strong><em>Catch and return a static default value</em></strong>" is
<code>onErrorReturn</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>becomes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You also have the option of applying a <code>Predicate</code> on the exception to decided
whether or not to recover:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals("boom10"), "recovered10"); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>only recover if the message of the exception is <code>"boom10"</code></td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_fallback_method"><a class="anchor" href="#_fallback_method"></a>Fallback Method</h5>
<div class="paragraph">
<p>If you want more than a single default value and you have an alternative safer way of
processing your data, you can use <code>onErrorResume</code>. This would be the equivalent of
"<strong><em>Catch and execute an alternative path with a fallback method</em></strong>".</p>
</div>
<div class="paragraph">
<p>For example, if your nominal process is fetching data from an external and unreliable
service, but you also keep a local cache of the same data that <em>can</em> be a bit more out of
date but is more reliable, you could do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>becomes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("key1", "key2")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .onErrorResume(e -&gt; getFromCache(k)) <i class="conum" data-value="2"></i><b>(2)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For each key, we asynchronously call the external service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the external service call fails, we fallback to the cache for that key. Note that
we always apply the same fallback, whatever the source error, <code>e</code>, is.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like <code>onErrorReturn</code>, <code>onErrorResume</code> has variants that let you filter which exceptions
to fallback on, based either on the exception&#8217;s class or a <code>Predicate</code>. The fact that it
takes a <code>Function</code> also allows you to choose a different fallback sequence to switch to,
depending on the error encountered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            if (error instanceof TimeoutException) <i class="conum" data-value="2"></i><b>(2)</b>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  <i class="conum" data-value="3"></i><b>(3)</b>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); <i class="conum" data-value="4"></i><b>(4)</b>
        })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function allows dynamically choosing how to continue.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the source times out, hit the local cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the source says the key is unknown, create a new entry.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In all other cases, "re-throw".</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_fallback_value"><a class="anchor" href="#_dynamic_fallback_value"></a>Dynamic Fallback Value</h5>
<div class="paragraph">
<p>Even if you do not have an alternative safer way of processing your data, you might want
to compute a fallback value out of the exception you received. This would be the
equivalent of "<strong><em>Catch and dynamically compute a fallback value</em></strong>".</p>
</div>
<div class="paragraph">
<p>For instance, if your return type <code>MyWrapper</code> has a variant dedicated to holding an exception (think
<code>Future.complete(T success)</code> vs <code>Future.completeExceptionally(Throwable error)</code>), you
could instantiate the error-holding variant and pass the exception.</p>
</div>
<div class="paragraph">
<p>An imperative example would look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be done reactively in the same way as the fallback method solution,
using <code>onErrorResume</code>, with a tiny bit of boilerplate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">erroringFlux.onErrorResume(error -&gt; Mono.just( <i class="conum" data-value="1"></i><b>(1)</b>
        MyWrapper.fromError(error) <i class="conum" data-value="2"></i><b>(2)</b>
));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since you expect a <code>MyWrapper</code> representation of the error, you&#8217;ll need to get a
<code>Mono&lt;MyWrapper&gt;</code> for <code>onErrorResume</code>. We use <code>Mono.just()</code> for that.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need to compute the value out of the exception. Here we achieved That
by wrapping the exception using a relevant <code>MyWrapper</code> factory method.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_catch_and_rethrow"><a class="anchor" href="#_catch_and_rethrow"></a>Catch and Rethrow</h5>
<div class="paragraph">
<p>"<strong><em>Catch, wrap to a <code>BusinessException</code>, and re-throw</em></strong>" in the imperative world
looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the "fallback method" example, the last line inside the <code>flatMap</code> gives us a hint
at achieving the same reactively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there is a more straightforward way of achieving the same with <code>onErrorMap</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException("oops, SLA exceeded", original));</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_log_or_react_on_the_side"><a class="anchor" href="#_log_or_react_on_the_side"></a>Log or React on the Side</h5>
<div class="paragraph">
<p>For cases where you want the error to continue propagating but you still want to react to
it without modifying the sequence (logging it, for instance) there is the <code>doOnError</code>
operator. This is the equivalent of "<strong><em>Catch, log an error-specific message, and re-throw</em></strong>"
pattern, shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doOnError</code> operator, as well as all operators prefixed with <code>doOn</code> , are sometimes
referred to as a "side-effect". They let you peek inside the sequence&#8217;s events without
modifying them.</p>
</div>
<div class="paragraph">
<p>Like the imperative example above, the following example still propagates the error yet
ensures that we at least log that the external service had a failure.
We can also imagine we have statistic counters to increment as a second error side-effect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just("unknown")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .doOnError(e -&gt; {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); <i class="conum" data-value="2"></i><b>(2)</b>
        })
        <i class="conum" data-value="3"></i><b>(3)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The external service call that can fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;is decorated with a logging and stats side-effect&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;after which point it will still terminate with an error, unless we use an error-recovery operator here</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_using_resources_and_the_finally_block"><a class="anchor" href="#_using_resources_and_the_finally_block"></a>Using Resources and the Finally Block</h5>
<div class="paragraph">
<p>The last parallel to draw with imperative programming is the cleaning up that can be done
either via a "<strong><em>Use of the <code>finally</code> block to clean up resources</em></strong>" or a
"<strong><em>Java 7 try-with-resource construct</em></strong>", both shown below:</p>
</div>
<div class="listingblock">
<div class="title">Imperative use of finally</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Imperative use of try-with-resource</div>
<div class="content">
<pre class="highlightjs highlight"><code>try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both have their Reactor equivalents, <code>doFinally</code> and <code>using</code>.</p>
</div>
<div class="paragraph">
<p><code>doFinally</code> is about side-effects that you want to be executed whenever the
sequence terminates (with <code>onComplete</code> or <code>onError</code>) or is cancelled.
It gives you a hint as to what kind of termination triggered the side-effect:</p>
</div>
<div class="listingblock">
<div class="title">Reactive finally: <code>doFinally()</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
        stats.stopTimerAndRecordTiming();<i class="conum" data-value="2"></i><b>(2)</b>
        if (type == SignalType.CANCEL) <i class="conum" data-value="3"></i><b>(3)</b>
          statsCancel.increment();
    })
    .take(1); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doFinally</code> consumes a <code>SignalType</code> for the type of termination.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Similarly to <code>finally</code> blocks, we always record the timing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we also increment statistics in case of cancellation only.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>take(1)</code> will cancel after 1 item is emitted.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the other hand, <code>using</code> handles the case where a <code>Flux</code> is derived from a
resource, and that resource must be acted upon whenever processing is done.
Let&#8217;s replace the <code>AutoCloseable</code> interface of "try-with-resource" with a
<code>Disposable</code>:</p>
</div>
<div class="listingblock">
<div class="title">The Disposable resource</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can do the reactive equivalent of "try-with-resource" on it, which looks
like the following:</p>
</div>
<div class="listingblock">
<div class="title">Reactive try-with-resource: <code>using()</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.using(
        () -&gt; disposableInstance, <i class="conum" data-value="1"></i><b>(1)</b>
        disposable -&gt; Flux.just(disposable.toString()), <i class="conum" data-value="2"></i><b>(2)</b>
        Disposable::dispose <i class="conum" data-value="3"></i><b>(3)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first lambda generates the resource. Here we return our mock <code>Disposable</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second lambda processes the resource, returning a <code>Flux&lt;T&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The third lambda is called when the <code>Flux</code> from 2) terminates or is cancelled, to
clean up resources.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After subscription and execution of the sequence, the <code>isDisposed</code> atomic boolean
would become <code>true</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_demonstrating_the_terminal_aspect_of_onerror"><a class="anchor" href="#_demonstrating_the_terminal_aspect_of_onerror"></a>Demonstrating the Terminal Aspect of <code>onError</code></h5>
<div class="paragraph">
<p>In order to demonstrate that all these operators cause the upstream original sequence to
terminate when the error happens, we can use a more visual example with a
<code>Flux.interval</code>. The interval operator ticks every x units of time with an increasing
<code>Long</code> value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note that <code>interval</code> executes on a <strong>timer</strong> <code>Scheduler</code> by default. Assuming we want
to run that example in a main class, we add a <code>sleep</code> call here so that the application
does not exit immediately without any value being produced.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This prints out one line every 250ms, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>tick 0
tick 1
tick 2
Uh oh</pre>
</div>
</div>
<div class="paragraph">
<p>Even with one extra second of runtime, no more tick comes in from the <code>interval</code>. The
sequence was indeed terminated by the error.</p>
</div>
</div>
<div class="sect4">
<h5 id="_retrying"><a class="anchor" href="#_retrying"></a>Retrying</h5>
<div class="paragraph">
<p>There is another operator of interest with regards to error handling, and you might be
tempted to use it in the case above. <code>retry</code>, as its name indicates, lets you retry an
error-producing sequence.</p>
</div>
<div class="paragraph">
<p>The thing to keep in mind is that it works by <strong>re-subscribing</strong> to the upstream <code>Flux</code>.
This is really a different sequence, and the original one is still terminated.
To verify that, we can re-use the previous example and append a <code>retry(1)</code> to
retry once instead of using <code>onErrorReturn</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(System.out::println, System.err::println); <i class="conum" data-value="2"></i><b>(2)</b>

Thread.sleep(2100); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>elapsed</code> associates each value with the duration since previous value was emitted.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also want to see when there is an <code>onError</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure we have enough time for our 4x2 ticks.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>259,tick 0
249,tick 1
251,tick 2
506,tick 0 <i class="conum" data-value="1"></i><b>(1)</b>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A new <code>interval</code> started, from tick 0. The additional 250ms duration is
coming from the 4th tick, the one that causes the exception and subsequent
retry.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see above, <code>retry(1)</code> merely re-subscribed to the original <code>interval</code>
once, restarting the tick from 0. The second time around, since the exception
still occurs, it gives up and propagates the error downstream.</p>
</div>
<div class="paragraph">
<p>There is a more advanced version of <code>retry</code> (called <code>retryWhen</code>) that uses a "companion"
<code>Flux</code> to tell whether or not a particular failure should retry. This companion <code>Flux</code> is
created by the operator but decorated by the user, in order to customize the retry
condition.</p>
</div>
<div class="paragraph">
<p>The companion <code>Flux</code> is a <code>Flux&lt;Throwable&gt;</code> that gets passed to a <code>Function</code>, the sole
parameter of <code>retryWhen</code>. As the user, you define that function and make it return a new
<code>Publisher&lt;?&gt;</code>. Retry cycles will go like this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each time an error happens (potential for a retry), the error is emitted into the
companion <code>Flux</code>, which has been decorated by your function. Having a <code>Flux</code> here
gives a bird eye&#8217;s view of all the attempts so far.</p>
</li>
<li>
<p>If the companion <code>Flux</code> emits a value, a retry happens.</p>
</li>
<li>
<p>If the companion <code>Flux</code> completes, the error is swallowed, the retry cycle stops
and the resulting sequence <strong>completes</strong> too.</p>
</li>
<li>
<p>If the companion <code>Flux</code> produces an error <code>e</code>, the retry cycle stops and the
resulting sequence <strong>errors</strong> with <code>e</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The distinction between the previous two cases is important. Simply completing the
companion would effectively swallow an error. Consider the following way of emulating
<code>retry(3)</code> using <code>retryWhen</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) <i class="conum" data-value="1"></i><b>(1)</b>
    .doOnError(System.out::println) <i class="conum" data-value="2"></i><b>(2)</b>
    .retryWhen(companion -&gt; companion.take(3)); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This continuously produces errors, calling for retry attempts.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>doOnError</code> <strong>before</strong> the retry will let us log and see all failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here, we consider the first 3 errors as retry-able (<code>take(3)</code>) and then give up.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In effect, this results in an <strong>empty</strong> <code>Flux</code>, but it completes <strong>successfully</strong>. Since
<code>retry(3)</code> on the same <code>Flux</code> would have terminated with the latest error, this
<code>retryWhen</code> example is not exactly the same as a <code>retry(3)</code>.</p>
</div>
<div class="paragraph">
<p>Getting to the same behavior involves a few additional tricks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalArgumentException())
    .retryWhen(companion -&gt; companion
    .zipWith(Flux.range(1, 4), <i class="conum" data-value="1"></i><b>(1)</b>
          (error, index) -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            if (index &lt; 4) return index; <i class="conum" data-value="3"></i><b>(3)</b>
            else throw Exceptions.propagate(error); <i class="conum" data-value="4"></i><b>(4)</b>
          })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Trick one: use <code>zip</code> and a <code>range</code> of "number of acceptable retries + 1".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>zip</code> function lets you count the retries while keeping track of the original
error.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, indexes before 4 return a value to emit.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Similar code can be used to implement an <em>exponential backoff and retry</em> pattern,
as shown in the <a href="#faq.exponentialBackoff">FAQ</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_in_operators_or_functions"><a class="anchor" href="#_handling_exceptions_in_operators_or_functions"></a>4.6.2. Handling Exceptions in Operators or Functions</h4>
<div class="paragraph">
<p>In general, all operators can themselves contain code that potentially trigger an
exception or calls to a user-defined callback that can similarly fail, so they all
contain some form of error handling.</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, an <strong>Unchecked Exception</strong> is always propagated through <code>onError</code>. For
instance, throwing a <code>RuntimeException</code> inside a <code>map</code> function translates to an
<code>onError</code> event, as shown in the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("foo")
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println("GOT VALUE"),
               e -&gt; System.out.println("ERROR: " + e));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code prints out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: java.lang.IllegalArgumentException: foo</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>Exception</code> can be tuned before it is passed to <code>onError</code>, through the use of a
<a href="#hooks-internal">hook</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor, however, defines a set of exceptions (such as <code>OutOfMemoryError</code>) that are
always deemed <strong>fatal</strong>. See the <code>Exceptions.throwIfFatal</code> method. These errors mean that
Reactor cannot keep operating and are thrown rather than propagated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Internally, there are also cases where an unchecked exception still cannot be
propagated (most notably during the subscribe and request phases), due to concurrency
races that could lead to double <code>onError</code> or <code>onComplete</code> conditions. When these races
happen, the error that cannot be propagated is "dropped". These cases can still be
managed to some extent via customizable hooks, see <a href="#hooks-dropping">Dropping Hooks</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You may ask: "What about <strong>Checked Exceptions</strong>?"</p>
</div>
<div class="paragraph">
<p>If, for example, you need to call some method that declares it <code>throws</code> exceptions, you
still have to deal with those exceptions in a <code>try-catch</code> block. You have several
options, though:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catch the exception and recover from it. The sequence continues normally.</p>
</li>
<li>
<p>Catch the exception and wrap it into an <em>unchecked</em> exception, then throw it
(interrupting the sequence). The <code>Exceptions</code> utility class can help you with that (we
get to that next).</p>
</li>
<li>
<p>If you are expected to return a <code>Flux</code> (for example, you are in a <code>flatMap</code>), wrap the
exception in an error-producing <code>Flux</code>: <code>return Flux.error(checkedException)</code>. (The
sequence also terminates.)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reactor has an <code>Exceptions</code> utility class that you can use to ensure that exceptions are
wrapped only if they are checked exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>Exceptions.propagate</code> method to wrap exceptions, if necessary. It also calls
<code>throwIfFatal</code> first and does not wrap <code>RuntimeException</code>.</p>
</li>
<li>
<p>Use the <code>Exceptions.unwrap</code> method to get the original unwrapped exception (going back
to the root cause of a hierarchy of reactor-specific exceptions).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider an example of a <code>map</code> that uses a conversion method that can throw an
<code>IOException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String convert(int i) throws IOException {
    if (i &gt; 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now imagine that you want to use that method in a <code>map</code>. You must now explicitly catch
the exception, and your map function cannot re-throw it. So you can propagate it to the
map&#8217;s <code>onError</code> method as a <code>RuntimeException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; converted = Flux
    .range(1, 10)
    .map(i -&gt; {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later on, when subscribing to the above <code>Flux</code> and reacting to errors (such as in the
UI), you could revert back to the original exception in case you want to do something
special for IOExceptions, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">converted.subscribe(
    v -&gt; System.out.println("RECEIVED: " + v),
    e -&gt; {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="processors"><a class="anchor" href="#processors"></a>4.7. Processors</h3>
<div class="paragraph">
<p>Processors are a special kind of <code>Publisher</code> that are also a <code>Subscriber</code>. That means
that you can <code>subscribe</code> to a <code>Processor</code> (generally, they implement <code>Flux</code>), but you can
also call methods to manually inject data into the sequence or terminate it.</p>
</div>
<div class="paragraph">
<p>There are several kinds of Processors, each with a few particular semantics, but before
you start looking into these, you need to ask yourself the following question:</p>
</div>
<div class="sect3">
<h4 id="_do_i_need_a_processor"><a class="anchor" href="#_do_i_need_a_processor"></a>4.7.1. Do I Need a Processor?</h4>
<div class="paragraph">
<p>Most of the time, you should try to avoid using a <code>Processor</code>. They are harder to use
correctly and prone to some corner cases.</p>
</div>
<div class="paragraph">
<p>If you think a <code>Processor</code> could be a good match for your use case, ask yourself if you
have tried these two alternatives:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Could an operator or combination of operators fit the bill? (See <a href="#which-operator">Which operator do I need?</a>)</p>
</li>
<li>
<p>Could a <a href="#producing">"generator"</a> operator work instead? (Generally, these operators
are made to bridge APIs that are not reactive, providing a "sink" that is similar in
concept to a <code>Processor</code> in the sense that it lets you manually populate the sequence
with data or terminate it).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If, after exploring the above alternatives, you still think you need a <code>Processor</code>, read
the <a href="#processor-overview">Overview of Available Processors</a> section below to learn about the different implementations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_safely_produce_from_multiple_threads_by_using_the_sink_facade"><a class="anchor" href="#_safely_produce_from_multiple_threads_by_using_the_sink_facade"></a>4.7.2. Safely Produce from Multiple Threads by Using the <code>Sink</code> Facade</h4>
<div class="paragraph">
<p>Rather than directly using Reactor <code>Processors</code>, it is a good practice to obtain a <code>Sink</code>
for the <code>Processor</code> by calling <code>sink()</code> <strong>once</strong>.</p>
</div>
<div class="paragraph">
<p><code>FluxProcessor</code> sinks safely gate multi-threaded producers and can be used by
applications that generate data from multiple threads concurrently. For example, a
thread-safe serialized sink can be created for <code>UnicastProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create();
FluxSink&lt;Integer&gt; sink = processor.sink(overflowStrategy);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple producer threads may concurrently generate data on the following serialized
sink:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">sink.next(n);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Despite the <code>FluxSink</code> being adapted for multi-threaded <strong>manual</strong> feeding
of the <code>Processor</code>, it is not possible to mix the subscriber approach with the
sink approach: <strong>you have to <em>either</em> subscribe your <code>FluxProcessor</code> to a source
<code>Publisher</code> <em>or</em> feed it manually though its <code>FluxSink</code></strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Overflow from <code>next</code> behaves in two possible ways, depending on the <code>Processor</code> and its
configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An unbounded processor handles the overflow itself by dropping or buffering.</p>
</li>
<li>
<p>A bounded processor blocks or "spins" on the <code>IGNORE</code> strategy or applies the
<code>overflowStrategy</code> behavior specified for the <code>sink</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="processor-overview"><a class="anchor" href="#processor-overview"></a>4.7.3. Overview of Available Processors</h4>
<div class="paragraph">
<p>Reactor Core comes with several flavors of <code>Processor</code>. Not all processors have the same
semantics but are roughly split into three categories. The following list briefly
describes the three kinds of processors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>direct</strong> (<code>DirectProcessor</code> and <code>UnicastProcessor</code>): These processors can only push
data through direct user action (calling their <code>Sink</code>'s methods directly).</p>
</li>
<li>
<p><strong>synchronous</strong> (<code>EmitterProcessor</code> and <code>ReplayProcessor</code>): These processors can either push data
through user interaction or by subscribing to an upstream <code>Publisher</code> and synchronously
draining it.</p>
</li>
<li>
<p><strong>asynchronous</strong> (<code>WorkQueueProcessor</code> and <code>TopicProcessor</code>): These processors can either push
data obtained from multiple upstream <code>Publishers</code> or through user interaction.
They are more robust and are  backed by a <code>RingBuffer</code> data structure in order
to deal with their multiple upstreams.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The asynchronous processors are the most complex to instantiate, with a lot of different
options. Consequently, they expose a <code>Builder</code> interface. The simpler processors have
static factory methods instead.</p>
</div>
<div class="sect4">
<h5 id="_direct_processor"><a class="anchor" href="#_direct_processor"></a>Direct Processor</h5>
<div class="paragraph">
<p>A <strong>Direct</strong> <code>Processor</code> is a processor that can dispatch signals to zero to many
<code>Subscribers</code>. It is the simplest one to instantiate, with a single <code>DirectProcessor#create()</code> static
factory method. On the other hand, <strong>it has the limitation of not handling backpressure</strong>.
As a consequence, a <code>DirectProcessor</code> signals an <code>IllegalStateException</code> to its
subscribers if you push N elements through it but at least one of its subscribers has
requested less than N.</p>
</div>
<div class="paragraph">
<p>Once the <code>Processor</code> has terminated (usually through its sink&#8217;s <code>error(Throwable)</code> or
<code>complete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect4">
<h5 id="_unicast_processor"><a class="anchor" href="#_unicast_processor"></a>Unicast Processor</h5>
<div class="paragraph">
<p>A <strong>Unicast</strong> <code>Processor</code> can deal with backpressure using an internal buffer. The trade-off
is that it can have <strong>at most one</strong> <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>A <code>UnicastProcessor</code> has a few more options, reflected by a few <code>create</code> static factory
methods. For instance, by default it is <em>unbounded</em>: if you push any amount of
data through it while its <code>Subscriber</code> has not yet requested data, it will buffer all of
the data.</p>
</div>
<div class="paragraph">
<p>This can be changed by providing a custom <code>Queue</code> implementation for the internal
buffering in the <code>create</code> factory method. If that queue is bounded, the processor could
reject the push of a value when the buffer is full and not enough requests from
downstream have been received.</p>
</div>
<div class="paragraph">
<p>In that <em>bounded</em> case, the processor can also be built with a callback that is invoked
on each rejected element, allowing for cleanup of these rejected elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="_emitter_processor"><a class="anchor" href="#_emitter_processor"></a>Emitter Processor</h5>
<div class="paragraph">
<p>An <strong>Emitter</strong> <code>Processor</code> is capable of emitting to several subscribers, while honoring
backpressure for each of its subscribers. It can also subscribe to a <code>Publisher</code> and
relay its signals synchronously.</p>
</div>
<div class="paragraph">
<p>Initially, when it has no subscriber, it can still accept a few data pushes up to a
configurable <code>bufferSize</code>. After that point, if no <code>Subscriber</code> has come in and consumed
the data, calls to <code>onNext</code> block until the processor is drained (which can only happen
concurrently by then).</p>
</div>
<div class="paragraph">
<p>Thus, the first <code>Subscriber</code> to subscribe receives up to <code>bufferSize</code> elements upon
subscribing. However, after that, the processor stops replaying signals to additional
subscribers. These subsequent subscribers instead only receive the signals pushed through
the processor <strong>after</strong> they have subscribed. The internal buffer is still used for
backpressure purposes.</p>
</div>
<div class="paragraph">
<p>By default, if all of its subscribers are cancelled (which basically means they have all
un-subscribed), it will clear its internal buffer and stop accepting new subscribers.
This can be tuned by the <code>autoCancel</code> parameter in the <code>create</code> static factory methods.</p>
</div>
</div>
<div class="sect4">
<h5 id="_replay_processor"><a class="anchor" href="#_replay_processor"></a>Replay Processor</h5>
<div class="paragraph">
<p>A <strong>Replay</strong> <code>Processor</code> caches elements that are either pushed directly through its <code>sink()</code>
or elements from an upstream <code>Publisher</code> and replays them to late subscribers.</p>
</div>
<div class="paragraph">
<p>It can be created in multiple configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caching a single element (<code>cacheLast</code>).</p>
</li>
<li>
<p>Caching a limited history (<code>create(int)</code>), unbounded history (<code>create()</code>).</p>
</li>
<li>
<p>Caching time-based replay window (<code>createTimeout(Duration)</code>).</p>
</li>
<li>
<p>Caching combination of history size and time window
(<code>createSizeOrTimeout(int, Duration)</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_topic_processor"><a class="anchor" href="#_topic_processor"></a>Topic Processor</h5>
<div class="paragraph">
<p>A <strong>Topic</strong> <code>Processor</code> is an asynchronous processor capable of relaying elements from
multiple upstream <code>Publishers</code> when created in the <code>shared</code> configuration (see the
<code>share(boolean)</code> option of the <code>builder()</code>).</p>
</div>
<div class="paragraph">
<p>Note that the share option is mandatory if you intend to concurrently call
<code>TopicProcessor</code>'s <code>onNext</code>, <code>onComplete</code>, or <code>onError</code> methods directly or from a
concurrent upstream Publisher.</p>
</div>
<div class="paragraph">
<p>Otherwise, such concurrent calls are illegal, as the processor is then fully compliant
with the Reactive Streams specification.</p>
</div>
<div class="paragraph">
<p>A <code>TopicProcessor</code> is capable of fanning out to multiple <code>Subscribers</code>. It does so by
associating a <code>Thread</code> to each <code>Subscriber</code>, which will run until an <code>onError</code> or
<code>onComplete</code> signal is pushed through the processor or until the associated <code>Subscriber</code>
is cancelled. The maximum number of downstream subscribers is driven by the <code>executor</code>
builder option. Provide a bounded <code>ExecutorService</code> to limit it to a specific number.</p>
</div>
<div class="paragraph">
<p>The processor is backed by a <code>RingBuffer</code> data structure that stores pushed signals. Each
<code>Subscriber</code> thread keeps track of its associated demand and the correct indexes in the
<code>RingBuffer</code>.</p>
</div>
<div class="paragraph">
<p>This processor also has an <code>autoCancel</code> builder option: If set to <code>true</code> (the default),
it results in the source <code>Publisher</code>(s) being cancelled when all subscribers are
cancelled.</p>
</div>
</div>
<div class="sect4">
<h5 id="_workqueue_processor"><a class="anchor" href="#_workqueue_processor"></a>WorkQueue Processor</h5>
<div class="paragraph">
<p>A <strong>WorkQueue</strong> <code>Processor</code> is also an asynchronous processor capable of relaying elements
from multiple upstream <code>Publishers</code> when created in the <code>shared</code> configuration (it shares
most of its builder options with <code>TopicProcessor</code>).</p>
</div>
<div class="paragraph">
<p>It relaxes its compliance with the Reactive Streams specification, but it acquires the
benefit of requiring fewer resources than the <code>TopicProcessor</code>. It is still based on a
<code>RingBuffer</code> but avoids the overhead of creating one consumer <code>Thread</code> per <code>Subscriber</code>.
As a result, it scales better than the <code>TopicProcessor</code>.</p>
</div>
<div class="paragraph">
<p>The trade-off is that its distribution pattern is a little bit different: Requests from
each subscriber all add up together, and the processor relays signals to only one
<code>Subscriber</code> at a time, in a kind of round-robin distribution rather than fan-out
pattern.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A fair round-robin distribution is not guaranteed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>WorkQueueProcessor</code> mostly has the same builder options as the <code>TopicProcessor</code>,
such as <code>autoCancel</code>, <code>share</code>, and <code>waitStrategy</code>. The maximum number of downstream
subscribers is also driven by a configurable <code>ExecutorService</code> with the <code>executor</code>
option.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
You should take care not to subscribe too many <code>Subscribers</code> to a
<code>WorkQueueProcessor</code>, as doing so <strong>could lock the processor</strong>. If you need to limit the
number of possible subscribers, prefer doing so by using a <code>ThreadPoolExecutor</code> or a
<code>ForkJoinPool</code>. The processor can detect their capacity and throw an exception if you
subscribe one too many times.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/coreFeatures.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#core-features">Reactor Core Features</a>"</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a>5. Kotlin support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="kotlin-introduction"><a class="anchor" href="#kotlin-introduction"></a>5.1. Introduction</h3>
<div class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a> is a statically-typed language targeting the JVM (and other platforms)
which allows writing concise and elegant code while providing a very good
<a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> with
existing libraries written in Java.</p>
</div>
<div class="paragraph">
<p>Reactor 3.1 introduces first-class support for Kotlin which is described in this section.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a>5.2. Requirements</h3>
<div class="paragraph">
<p>Reactor supports Kotlin 1.1+ and requires
<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib"><code>kotlin-stdlib</code></a>
(or one of its <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre7"><code>kotlin-stdlib-jre7</code></a>
/ <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre8"><code>kotlin-stdlib-jre8</code></a> variants).</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a>5.3. Extensions</h3>
<div class="paragraph">
<p>Thanks to its great <a href="https://kotlinlang.org/docs/reference/java-interop.html">Java interoperability</a>
and to <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin extensions</a>, Reactor
Kotlin APIs leverage regular Java APIs and are additionally enhanced by a few Kotlin specific APIs
available out of the box within Reactor artifacts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Keep in mind that Kotlin extensions need to be imported to be used. This means
for example that the <code>Throwable.toFlux</code> Kotlin extension
will only be available if <code>import reactor.core.publisher.toFlux</code> is imported.
That said, similar to static imports, an IDE should automatically suggest the import in most cases.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin reified type parameters</a>
provide a workaround for JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">generics type erasure</a>,
and Reactor provides some extensions to take advantage of this feature.</p>
</div>
<div class="paragraph">
<p>You can see bellow a quick comparison of Reactor with Java versus Reactor with Kotlin + extensions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kotlin with extensions</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.just("foo")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"foo".toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.fromIterable(list)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>list.toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType(Foo.class)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType&lt;Foo&gt;()</code> or <code>flux.ofType(Foo::class)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StepVerifier.create(flux).verifyComplete()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.test().verifyComplete()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="https://projectreactor.io/docs/core/release/kdoc-api/">Reactor KDoc API</a> lists and documents
all the Kotlin extensions available.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a>5.4. Null-safety</h3>
<div class="paragraph">
<p>One of Kotlin&#8217;s key features is <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>
- which cleanly deals with <code>null</code> values at compile time rather than bumping into the famous
<code>NullPointerException</code> at runtime. This makes applications safer through nullability
declarations and expressing "value or no value" semantics without paying the cost of wrappers like <code>Optional</code>.
(Kotlin allows using functional constructs with nullable values; check out this
<a href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to Kotlin null-safety</a>.)</p>
</div>
<div class="paragraph">
<p>Although Java does not allow one to express null-safety in its type-system, Reactor <a href="#null-safety">now
provides null-safety</a> of the whole Reactor API via tooling-friendly annotations declared
in the <code>reactor.util.annotation</code> package.
By default, types from Java APIs used in Kotlin are recognized as
<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>
for which null-checks are relaxed.
<a href="https://github.com/Kotlin/KEEP/blob/jsr-305/proposals/jsr-305-custom-nullability-qualifiers.md">Kotlin support for JSR 305 annotations</a>
+ Reactor nullability annotations provide null-safety for the whole Reactor API to Kotlin developers,
with the advantage of dealing with <code>null</code> related issues at compile time.</p>
</div>
<div class="paragraph">
<p>The JSR 305 checks can be configured by adding the <code>-Xjsr305</code> compiler flag with the following
options: <code>-Xjsr305={strict|warn|ignore}</code>.</p>
</div>
<div class="paragraph">
<p>For kotlin versions 1.1.50+, the default behavior is the same to <code>-Xjsr305=warn</code>.
The <code>strict</code> value is required to have Reactor API full null-safety taken in account
but should be considered experimental since Reactor API nullability declaration could evolve
even between minor releases and more checks may be added in the future).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generic type arguments, varargs and array elements nullability are not supported yet,
but should be in an upcoming release, see <a href="https://github.com/Kotlin/KEEP/issues/79">this dicussion</a>
for up-to-date information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/kotlin.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#kotlin">Kotlin support</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>6. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whether you have written a simple chain of Reactor operators or your own operator,
automated testing is always a good idea.</p>
</div>
<div class="paragraph">
<p>Reactor comes with a few elements dedicated to testing, gathered into their own
artifact: <code>reactor-test</code>. You can find that project
<a href="https://github.com/reactor/reactor-core/tree/master/reactor-test/src">on Github</a>,
inside of the <em>reactor-core</em> repository.</p>
</div>
<div class="paragraph">
<p>To use it in your tests, add it as a test dependency:</p>
</div>
<div class="listingblock">
<div class="title">reactor-test in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">reactor-test in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
   testCompile 'io.projectreactor:reactor-test'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The three main uses of <code>reactor-test</code> are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Testing that a sequence follows a given scenario, step-by-step, with <code>StepVerifier</code>.</p>
</li>
<li>
<p>Producing data in order to test the behavior of operators (including you own operators)
downstream with <code>TestPublisher</code>.</p>
</li>
<li>
<p>In sequences that can go through several alternative <code>Publisher</code> (eg. a chain that uses
<code>switchIfEmpty</code>, probing such a <code>Publisher</code> to ensure it was used (as in, subscribed to).</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_testing_a_scenario_with_stepverifier"><a class="anchor" href="#_testing_a_scenario_with_stepverifier"></a>6.1. Testing a Scenario with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>The most common case for testing a Reactor sequence is to have a <code>Flux</code> or <code>Mono</code> defined
in your code (for example, it might be returned by a method) and wanting to test how it
behaves when subscribed to.</p>
</div>
<div class="paragraph">
<p>This situation translates well to defining a "test scenario", where you define your
expectations in terms of events, step-by-step: what is the next expected event? Do you
expect the <code>Flux</code> to emit a particular value? Or maybe to do nothing for the next 300ms?
All of that can be expressed through the <code>StepVerifier</code> API.</p>
</div>
<div class="paragraph">
<p>For instance, you could have the following utility method in your codebase that
decorates a <code>Flux</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public &lt;T&gt; Flux&lt;T&gt; appendBoomError(Flux&lt;T&gt; source) {
  return source.concatWith(Mono.error(new IllegalArgumentException("boom")));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to test it, you want to verify the following scenario:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I expect this <code>Flux</code> to first emit <code>foo</code>, then emit <code>bar</code>, and then <strong>produce an
error</strong> with the message, <code>boom</code>. Subscribe and <strong>verify</strong> these expectations.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In the <code>StepVerifier</code> API, this translates to the following test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testAppendBoomError() {
  Flux&lt;String&gt; source = Flux.just("foo", "bar"); <i class="conum" data-value="1"></i><b>(1)</b>

  StepVerifier.create( <i class="conum" data-value="2"></i><b>(2)</b>
    appendBoomError(source)) <i class="conum" data-value="3"></i><b>(3)</b>
    .expectNext("foo") <i class="conum" data-value="4"></i><b>(4)</b>
    .expectNext("bar")
    .expectErrorMessage("boom") <i class="conum" data-value="5"></i><b>(5)</b>
    .verify(); <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since our method needs a source <code>Flux</code>, define a simple one for testing purposes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create a <code>StepVerifier</code> builder that wraps and verifies a <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass the <code>Flux</code> to be tested (the result of calling our utility method).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The first signal we expect to happen upon subscription is an <code>onNext</code>, with a value
of <code>foo</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The last signal we expect to happen is a termination of the sequence with an
<code>onError</code>. The exception should have <code>boom</code> as a message.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>It is important to trigger the test by calling <code>verify()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The API is a builder. You start by creating a <code>StepVerifier</code> and passing the
sequence to be tested. This offers a choice of methods that allow you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Express <em>expectations</em> about the next signals to occur. If any other signal is received
(or the content of the signal does not match the expectation), the whole test fails with
a meaningful <code>AssertionError</code>. For example, you might use <code>expectNext(T...)</code> and
<code>expectNextCount(long)</code>.</p>
</li>
<li>
<p><em>Consume</em> the next signal. This is used when you want to skip part of the sequence or
when you want to apply a custom <code>assertion</code> on the content of the signal (for example, to
check that there is an <code>onNext</code> event and assert that the emitted item is a list of size
5). For example, you might use <code>consumeNextWith(Consumer&lt;T&gt;)</code>.</p>
</li>
<li>
<p>Take <em>miscellaneous actions</em> such as pausing or running arbitrary code. For example, if
you want to manipulate a test-specific state or context. To that effect, you might use
<code>thenAwait(Duration)</code> and <code>then(Runnable)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For terminal events, the corresponding expectation methods (<code>expectComplete()</code> and
<code>expectError()</code> and all their variants) switch to an API where you cannot express
expectations anymore. In that last step, all you can do is perform some additional
configuration on the <code>StepVerifier</code> and then <strong>trigger the verification</strong>, often
with <code>verify()</code> or one of its variants.</p>
</div>
<div class="paragraph">
<p>What happens at this point is that the StepVerifier subscribes to the tested <code>Flux</code> or
<code>Mono</code> and plays the sequence, comparing each new signal with the next step in the
scenario. As long as these match, the test is considered a success. As soon as there is a
discrepancy, an <code>AssertionError</code> is thrown.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Remember the <code>verify()</code> step, which triggers the verification. In order to
help, the API includes a few shortcut methods that combine the terminal expectations with
a call to <code>verify()</code>: <code>verifyComplete()</code>, <code>verifyError()</code>, <code>verifyErrorMessage(String)</code>,
and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that, if one of the lambda-based expectations throws an <code>AssertionError</code>, it is
reported as is, failing the test. This is useful for custom assertions.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
By default, the <code>verify()</code> method and derived shortcut methods (<code>verifyThenAssertThat</code>,
<code>verifyComplete()</code>, etc.) has no timeout. It can block indefinitely. You can use
<code>StepVerifier.setDefaultTimeout(Duration)</code> to globally set a timeout for these methods,
or specify one on a per-call basis with <code>verify(Duration)</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_better_identifying_test_failures"><a class="anchor" href="#_better_identifying_test_failures"></a>6.1.1. Better identifying test failures</h4>
<div class="paragraph">
<p><code>StepVerifier</code> provides two options to better identify exactly which expectation step caused
a test to fail:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as(String)</code>: this method can be used <strong>after</strong> most <code>expect*</code> methods to give a description
to the preceding expectation. If the expectation fails, its error message will contain the
description. Terminal expectations and <code>verify</code> cannot be described that way.</p>
</li>
<li>
<p><code>StepVerifierOptions.create().scenarioName(String)</code>: Using <code>StepVerifierOptions</code> to create
you <code>StepVerifier</code>, you can use the <code>scenarioName</code> method to give the whole scenario a
name, which will also be used in assertion error messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that in both cases, the use of the description/name in messages is only guaranteed for
<code>StepVerifier</code> methods that produce their own <code>AssertionError</code> (eg. throwing an exception
manually or through an assertion library in <code>assertNext</code> won&#8217;t add the description/name to
said error&#8217;s message).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manipulating_time"><a class="anchor" href="#_manipulating_time"></a>6.2. Manipulating Time</h3>
<div class="paragraph">
<p><code>StepVerifier</code> can be used with time-based operators to avoid long run times for
corresponding tests. This is done through the <code>StepVerifier.withVirtualTime</code> builder.</p>
</div>
<div class="paragraph">
<p>It looks like the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
//... continue expectations here</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <strong>virtual time</strong> feature plugs in a custom <code>Scheduler</code> in Reactor&#8217;s <code>Schedulers</code>
factory. Since these timed operators usually use the default <code>Schedulers.parallel()</code>
scheduler, replacing it with a <code>VirtualTimeScheduler</code> does the trick. However, an
important prerequisite is that the operator be instantiated <em>after</em> the virtual time
scheduler has been activated.</p>
</div>
<div class="paragraph">
<p>In order to increase the chances this happens correctly, the <code>StepVerifier</code> does not take
a simple <code>Flux</code> as input. <code>withVirtualTime</code> takes a <code>Supplier</code>, which guides you into lazily
creating the instance of the tested flux <em>after</em> having done the scheduler set up.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Take extra care to ensure the <code>Supplier&lt;Publisher&lt;T&gt;&gt;</code> can be used in a lazy
fashion. Otherwise, virtual time is not guaranteed. Especially avoid instantiating the
<code>Flux</code> earlier in the test code and having the <code>Supplier</code> return that variable. Instead,
always instantiate the <code>Flux</code> inside the lambda.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two expectation methods that deal with time, and they are both valid with or
without virtual time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thenAwait(Duration)</code> pauses the evaluation of steps (allowing a few signals to occur
or delays to run out).</p>
</li>
<li>
<p><code>expectNoEvent(Duration)</code> also lets the sequence play out for a given duration but
fails the test if <strong>any</strong> signal occurs during that time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both methods pause the thread for the given duration in classic mode and advance the
virtual clock instead in virtual mode.</p>
</div>
<div id="tip-expectNoEvent" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expectNoEvent</code> also considers the <code>subscription</code> as an event. If you use it as a
first step, it usually fails because the subscription signal is detected. Use
<code>expectSubscription().expectNoEvent(duration)</code> instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to quickly evaluate the behavior of our <code>Mono.delay</code> above, we can finish
writing our code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
    .expectSubscription() <i class="conum" data-value="1"></i><b>(1)</b>
    .expectNoEvent(Duration.ofDays(1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .expectNext(0L) <i class="conum" data-value="3"></i><b>(3)</b>
    .verifyComplete(); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>See the <a href="#tip-expectNoEvent">tip</a> above.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Expect nothing to happen during a full day.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then expect a delay that emits <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Then expect completion (and trigger the verification).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We could have used <code>thenAwait(Duration.ofDays(1))</code> above, but <code>expectNoEvent</code> has the
benefit of guaranteeing that nothing happened earlier than it should have.</p>
</div>
<div class="paragraph">
<p>Note that <code>verify()</code> returns a <code>Duration</code> value. This is the <strong>real-time</strong> duration of the
entire test.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Virtual time is not a silver bullet. Keep in mind that <em>all</em> <code>Schedulers</code> are
replaced with the same <code>VirtualTimeScheduler</code>. In some cases, you can lock the
verification process because the virtual clock has not moved forward before an
expectation is expressed, resulting in the expectation waiting on data that can only be
produced by advancing time. In most cases, you need to advance the virtual clock for
sequences to emit. Virtual time also gets very limited with infinite sequences, which
might hog the thread on which both the sequence and its verification run.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_performing_post_execution_assertions_with_stepverifier"><a class="anchor" href="#_performing_post_execution_assertions_with_stepverifier"></a>6.3. Performing Post-execution Assertions with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>After having described the final expectation of your scenario, you can switch to a
complementary assertion API instead of triggering <code>verify()</code>. To do so, use
<code>verifyThenAssertThat()</code> instead.</p>
</div>
<div class="paragraph">
<p><code>verifyThenAssertThat()</code> returns a <code>StepVerifier.Assertions</code> object, which you can use to
assert a few elements of state once the whole scenario has played out successfully
(because it <strong>also calls <code>verify()</code></strong>). Typical (albeit advanced) usage is to capture
elements that have been dropped by some operator and assert them (see the section on
<a href="#hooks">Hooks</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_the_context"><a class="anchor" href="#_testing_the_context"></a>6.4. Testing the <code>Context</code></h3>
<div class="paragraph">
<p>For more information about the <code>Context</code>, see <a href="#context">Adding a Context to a Reactive Sequence</a>.</p>
</div>
<div class="paragraph">
<p><code>StepVerifier</code> comes with a couple of expectations around the propagation of a <code>Context</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectAccessibleContext</code>: returns a <code>ContextExpectations</code> object that you can use
to set up expectations on the propagated <code>Context</code>. Be sure to call <code>then()</code> to return
to the set up of sequence expectations.</p>
</li>
<li>
<p><code>expectNoAccessibleContext</code>: set up an expectation that NO <code>Context</code> can be propagated
up the chain of operators under test. This most likely occurs when the <code>Publisher</code> under
test is not a Reactor one, or doesn&#8217;t have any operator that can propagate the <code>Context</code>
(e.g. just a <em>generator</em> source).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, one can associate a test-specific initial <code>Context</code> to a <code>StepVerifier</code> by
using <code>StepVerifierOptions</code> to create the verifier.</p>
</div>
<div class="paragraph">
<p>These features are demonstrated in the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(Mono.just(1).map(i -&gt; i + 10),
				StepVerifierOptions.create().withInitialContext(Context.of("foo", "bar"))) <i class="conum" data-value="1"></i><b>(1)</b>
		            .expectAccessibleContext() <i class="conum" data-value="2"></i><b>(2)</b>
		            .contains("foo", "bar") <i class="conum" data-value="3"></i><b>(3)</b>
		            .then() <i class="conum" data-value="4"></i><b>(4)</b>
		            .expectNext(11)
		            .verifyComplete(); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>StepVerifier</code> using <code>StepVerifierOptions</code> and pass in an initial <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start setting up expectations about <code>Context</code> propagation. This alone ensures that a
<code>Context</code> <strong>was</strong> propagated.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An example of a <code>Context</code>-specific expectation: it must contain value "bar" for key "foo".</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We <code>then()</code> switch back to setting up normal expectations on the data.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Let&#8217;s not forget to <code>verify()</code> the whole set of expectations.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_manually_emitting_with_testpublisher"><a class="anchor" href="#_manually_emitting_with_testpublisher"></a>6.5. Manually Emitting with <code>TestPublisher</code></h3>
<div class="paragraph">
<p>For more advanced test cases, it might be useful to have complete mastery over the source
of data, in order to trigger finely chosen signals that closely match the particular
situation you want to test.</p>
</div>
<div class="paragraph">
<p>Another situation is when you have implemented your own operator and you want to verify
how it behaves with regards to the Reactive Streams specification, especially if its
source is not well behaved.</p>
</div>
<div class="paragraph">
<p>For both cases, <code>reactor-test</code> offers the <code>TestPublisher</code> class. This is a <code>Publisher&lt;T&gt;</code>
that lets you programmatically trigger various signals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next(T)</code> and <code>next(T, T...)</code> triggers 1-n <code>onNext</code> signals.</p>
</li>
<li>
<p><code>emit(T...)</code> does the same and does <code>complete()</code>.</p>
</li>
<li>
<p><code>complete()</code> terminates with an <code>onComplete</code> signal.</p>
</li>
<li>
<p><code>error(Throwable)</code> terminates with an <code>onError</code> signal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well behaved <code>TestPublisher</code> can be obtained through the <code>create</code> factory method. Also,
a misbehaving <code>TestPublisher</code> can be created using the <code>createNonCompliant</code> factory
method. The latter takes a value or multiple values from the <code>TestPublisher.Violation</code>
enum. The values define which parts of the specification the publisher can overlook.
These enum values include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUEST_OVERFLOW</code>: Allows <code>next</code> calls to be made despite an insufficient request,
without triggering an <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>ALLOW_NULL</code>: Allows <code>next</code> calls to be made with a <code>null</code> value without triggering a
<code>NullPointerException</code>.</p>
</li>
<li>
<p><code>CLEANUP_ON_TERMINATE</code>: Allows termination signals to be sent several times in a row.
This includes <code>complete()</code>, <code>error()</code> and <code>emit()</code>.</p>
</li>
<li>
<p><code>DEFER_CANCELLATION</code>: Allow the <code>TestPublisher</code> to ignore cancellation signals and continue
emitting signals as if the cancellation lost race against said signals.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the <code>TestPublisher</code> keeps track of internal state after subscription, which can
be asserted through its various <code>assert*</code> methods.</p>
</div>
<div class="paragraph">
<p>It can be used as a <code>Flux</code> or <code>Mono</code> by using the conversion methods <code>flux()</code> and
<code>mono()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_the_execution_path_with_publisherprobe"><a class="anchor" href="#_checking_the_execution_path_with_publisherprobe"></a>6.6. Checking the Execution Path with <code>PublisherProbe</code></h3>
<div class="paragraph">
<p>When building complex chains of operators, you could come across cases where
there are several possible execution paths, materialized by distinct sub-sequences.</p>
</div>
<div class="paragraph">
<p>Most of the time, these sub-sequences produce a specific-enough <code>onNext</code> signal
that you can assert it was executed by looking at the end result.</p>
</div>
<div class="paragraph">
<p>For instance, consider the following method, which builds a chain of operators from a
source and uses a <code>switchIfEmpty</code> to fallback to a particular alternative if the source
is empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Flux&lt;String&gt; processOrFallback(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback) {
    return source
            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split("\\s+")))
            .switchIfEmpty(fallback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is easy enough to test which logical branch of the switchIfEmpty was used, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testSplitPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.just("just a  phrase with    tabs!"),
            Mono.just("EMPTY_PHRASE")))
                .expectNext("just", "a", "phrase", "with", "tabs!")
                .verifyComplete();
}

@Test
public void testEmptyPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just("EMPTY_PHRASE")))
                .expectNext("EMPTY_PHRASE")
                .verifyComplete();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But think about an example where the method produces a <code>Mono&lt;Void&gt;</code> instead. It waits
for the source to complete, performs an additional task, and completes. If the source
is empty, a fallback Runnable-like task must be performed instead, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Mono&lt;String&gt; executeCommand(String command) {
    return Mono.just(command + " DONE");
}

public Mono&lt;Void&gt; processOrFallback(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty) {
    return commandSource
            .flatMap(command -&gt; executeCommand(command).then()) <i class="conum" data-value="1"></i><b>(1)</b>
            .switchIfEmpty(doWhenEmpty); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>then()</code> forgets about the command result. It cares only that it was completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>How to distinguish between two cases that both are empty sequences?</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to verify that your processOrFallback indeed goes through the <code>doWhenEmpty</code> path,
you need to write a bit of boilerplate. Namely you need a <code>Mono&lt;Void&gt;</code> that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Captures the fact that it has been subscribed to</p>
</li>
<li>
<p>Lets you assert that fact <strong>after</strong> the whole processing has terminated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before version 3.1, you would need to manually maintain one <code>AtomicBoolean</code> per state you
wanted to assert and attach a corresponding <code>doOn*</code> callback to the publisher you wanted
to evaluate. This could be a lot of boilerplate when having to apply this pattern
regularly. Fortunately, since 3.1.0 there&#8217;s an alternative with <code>PublisherProbe</code>, as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testCommandEmptyPathIsUsed() {
    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <i class="conum" data-value="2"></i><b>(2)</b>
                .verifyComplete();

    probe.assertWasSubscribed(); <i class="conum" data-value="3"></i><b>(3)</b>
    probe.assertWasRequested(); <i class="conum" data-value="4"></i><b>(4)</b>
    probe.assertWasNotCancelled(); <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a probe that translates to an empty sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the probe in place of <code>Mono&lt;Void&gt;</code> by calling <code>probe.mono()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After completion of the sequence, the probe lets you assert that it was used. You
can check that is was subscribed to&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;as well as actually requested for data&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;and whether or not it was cancelled.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use the probe in place of a <code>Flux&lt;T&gt;</code> by calling <code>.flux()</code> instead of
<code>.mono()</code>. For cases where you need to probe an execution path but also need the
probe to emit data, you can wrap any <code>Publisher&lt;T&gt;</code> using <code>PublisherProbe.of(Publisher)</code>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/testing.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#testing">Testing</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>7. Debugging Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Switching from an imperative and synchronous programming paradigm to a reactive and
asynchronous one can sometimes be daunting. One of the steepest steps in the learning
curve is how to analyze and debug when something goes wrong.</p>
</div>
<div class="paragraph">
<p>In the imperative world, debugging is usually pretty straightforward: just read the
stacktrace and you see where the problem originated and more: Was it entirely a failure
of your code? Did the failure occur in some library code? If so, what part of your code
called the library, potentially passing in improper parameters that ultimately caused the
failure?</p>
</div>
<div class="sect2">
<h3 id="_the_typical_reactor_stack_trace"><a class="anchor" href="#_the_typical_reactor_stack_trace"></a>7.1. The Typical Reactor Stack Trace</h3>
<div class="paragraph">
<p>When you shift to asynchronous code, things can get much more complicated.</p>
</div>
<div class="paragraph">
<p>Consider the following stack trace:</p>
</div>
<div class="listingblock">
<div class="title">A typically Reactor stack trace</div>
<div class="content">
<pre class="highlightjs highlight"><code>java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:445)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:379)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
	at reactor.core.publisher.FluxRange$RangeSubscription.slowPath(FluxRange.java:154)
	at reactor.core.publisher.FluxRange$RangeSubscription.request(FluxRange.java:109)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:332)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
	at reactor.core.publisher.FluxRange.subscribe(FluxRange.java:68)
	at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)
	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97)
	at reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3096)
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingCommonStacktrace(GuideTests.java:995)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a lot going on there. We get an <code>IndexOutOfBoundsException</code>, which tells us that
a "<strong>source emitted</strong> <em>more than one item</em>".</p>
</div>
<div class="paragraph">
<p>We can probably quickly come to assume that this source is a Flux/Mono, as confirmed by
the line below that mentions <code>MonoSingle</code>. So it appears to be some sort of complaint
from a <code>single</code> operator.</p>
</div>
<div class="paragraph">
<p>Referring to the Javadoc for <code>Mono#single</code> operator, we see that <code>single</code> has a contract:
The source must emit exactly one element. It appears we had a source that emitted more
than one and thus violated that contract.</p>
</div>
<div class="paragraph">
<p>Can we dig deeper and identify that source? The following rows are not very helpful. They
take us on a travel inside the internals of what seems to be a reactive chain, through
multiple calls to <code>subscribe</code> and <code>request</code>.</p>
</div>
<div class="paragraph">
<p>By skimming over these rows, we can at least start to form a picture of the kind of chain
that went wrong: It seems to involve a <code>MonoSingle</code>, a <code>FluxFlatMap</code>, and a <code>FluxRange</code>
(each gets several rows in the trace, but overall these three classes are involved). So a
<code>range().flatMap().single()</code> chain maybe?</p>
</div>
<div class="paragraph">
<p>But what if we use that pattern a lot in our application? This still does not tell us
much, and simply searching for <code>single</code> isn&#8217;t going to find the problem. Then the last
line refers to some of our code. Finally, we are getting close.</p>
</div>
<div class="paragraph">
<p>Hold on, though. When we go to the source file, all we see is that a
pre-existing <code>Flux</code> is subscribed to, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">toDebug.subscribe(System.out::println, Throwable::printStackTrace);</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of this happened at subscription time, but the <code>Flux</code> itself was not
<em>declared</em> there. Worse, when we go to where the variable is declared, we see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Mono&lt;String&gt; toDebug; //please overlook the public class attribute</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable is not <em>instantiated</em> where it is declared. We must assume a worst-case
scenario where we find out that there could be a few different code paths that set it in
the application. We remain unsure of which one caused the issue.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is kind of the Reactor equivalent of a runtime error, as opposed to a
compilation error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What we want to find out more easily is where the operator was added into the chain -
that is,  where the <code>Flux</code> was declared. We usually refer to that as the <strong>assembly</strong> of
the <code>Flux</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="debug-activate"><a class="anchor" href="#debug-activate"></a>7.2. Activating Debug Mode</h3>
<div class="paragraph">
<p>Even though the stacktrace was still able to convey some information for someone with a
bit of experience, we can see that it is not ideal by itself in more advanced cases.</p>
</div>
<div class="paragraph">
<p>Fortunately, Reactor comes with a debugging-oriented capability of
<strong>assembly-time instrumentation</strong>.</p>
</div>
<div class="paragraph">
<p>This is done by customizing the <code>Hooks.onOperator</code> hook <strong>at application start</strong> (or at
least before the incriminated <code>Flux</code> or <code>Mono</code> can be instantiated), as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Hooks.onOperatorDebug();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This starts instrumenting the calls to the <code>Flux</code> (and <code>Mono</code>) operator  methods (where
they are assembled into the chain) by wrapping the construction of the operator and
capturing a stacktrace there. Since this is done when the operator chain is declared, the
hook should be activated <strong>before</strong> that, so the safest way is to activate it right at the
start of your application.</p>
</div>
<div class="paragraph">
<p>Later on, if an exception occurs, the failing operator is able to refer to that capture
and append it to the stack trace.</p>
</div>
<div class="paragraph">
<p>In the next section, we see how the stack trace differs and how to interpret
that new information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_a_stack_trace_in_debug_mode"><a class="anchor" href="#_reading_a_stack_trace_in_debug_mode"></a>7.3. Reading a Stack Trace in Debug Mode</h3>
<div class="paragraph">
<p>When we reuse our initial example but activate the <code>operatorStacktrace</code> debug feature,
the stack trace is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:375) <i class="conum" data-value="1"></i><b>(1)</b>
...
<i class="conum" data-value="2"></i><b>(2)</b>
...
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1000)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <i class="conum" data-value="3"></i><b>(3)</b>
Assembly trace from producer [reactor.core.publisher.MonoSingle] : <i class="conum" data-value="4"></i><b>(4)</b>
	reactor.core.publisher.Flux.single(Flux.java:6676)
	reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949)
	reactor.guide.GuideTests.populateDebug(GuideTests.java:962)
	org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	org.junit.rules.RunRules.evaluate(RunRules.java:20)
Error has been observed by the following operator(s): <i class="conum" data-value="5"></i><b>(5)</b>
	|_	Flux.single â¢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949) <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is new: We see the wrapper operator that captures the stack.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apart from that, the first section of the stack trace is still the same for the most
part, showing a bit of the operator&#8217;s internals (so we removed a bit of the snippet here).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is where the new stuff from debugging mode starts to appear.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>First, we get some details on where the operator was assembled.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We also get a traceback of the error as it propagated through the operator chain,
from first to last (error site to subscribe site).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Each operator that saw the error is mentioned along with the user class and line where it
was used.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, the captured stack trace is appended to the original error as a
suppressed <code>OnAssemblyException</code>. There are two parts to it, but the first section is the
most interesting. It shows the path of construction for the operator that triggered the
exception. Here it shows that the <code>single</code> that caused our issue was created in the
<code>scatterAndGather</code> method, itself called from a <code>populateDebug</code> method that got executed
through JUnit.</p>
</div>
<div class="paragraph">
<p>Now that we are armed with enough information to find the culprit, we can have
a meaningful look at that <code>scatterAndGather</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Mono&lt;String&gt; scatterAndGather(Flux&lt;String&gt; urls) {
    return urls.flatMap(url -&gt; doRequest(url))
           .single(); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sure enough, here is our <code>single</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can see what the root cause of the error was a <code>flatMap</code> that performs
several HTTP calls to a few URLs is chained with <code>single</code>, which is too
restrictive. After a short <code>git blame</code> and a quick discussion with the author of
that line, we find out he meant to use the less restrictive <code>take(1)</code> instead.</p>
</div>
<div class="paragraph">
<p><strong>We have solved our problem.</strong></p>
</div>
<div class="quoteblock">
<blockquote>
Error has been observed by the following operator(s):
</blockquote>
</div>
<div class="paragraph">
<p>That second part of the debug stack trace was not necessarily interesting in
this particular example, because the error was actually happening in the last
operator in the chain (the one closest to <code>subscribe</code>). Considering another
example might make it more clear:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FakeRepository.findAllUserByName(Flux.just("pedro", "simon", "stephane"))
              .transform(FakeUtils1.applyFilters)
              .transform(FakeUtils2.enrichUser)
              .blockLast();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now imagine that, inside <code>findAllUserByName</code>, there is a <code>map</code> that fails. Here
we would see the following final traceback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Error has been observed by the following operator(s):
	|_	Flux.map â¢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
	|_	Flux.map â¢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
	|_	Flux.filter â¢ reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
	|_	Flux.transform â¢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)
	|_	Flux.elapsed â¢ reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
	|_	Flux.transform â¢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This corresponds to the section of the chain of operators that gets notified of the error:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The exception originates in the first <code>map</code>.</p>
</li>
<li>
<p>It is seen by a second <code>map</code> (both in fact correspond to the <code>findAllUserByName</code>
method).</p>
</li>
<li>
<p>It is then seen by a <code>filter</code> and a <code>transform</code>, which indicate that part of the chain
is constructed via a reusable transformation function (here, the <code>applyFilters</code> utility
method).</p>
</li>
<li>
<p>Finally, it is seen by an <code>elapsed</code> and a <code>transform</code>. Once again, <code>elapsed</code> is applied
by the transformation function of that second transform.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We deal with a form of instrumentation here, and creating a stack trace is costly. That
is why this debugging feature should only be activated in a controlled manner, as a last
resort.</p>
</div>
<div class="sect3">
<h4 id="_the_checkpoint_alternative"><a class="anchor" href="#_the_checkpoint_alternative"></a>7.3.1. The <code>checkpoint()</code> Alternative</h4>
<div class="paragraph">
<p>The debug mode is global and affects every single operator assembled into a <code>Flux</code> or
<code>Mono</code> inside the application. This has the benefit of allowing <strong>after-the-fact
debugging</strong>: whatever the error, we will obtain additional info to debug it.</p>
</div>
<div class="paragraph">
<p>As we saw earlier, this global knowledge comes at the cost of an impact on performance
(due to the number of populated stack traces). That cost can be reduced if we have an
idea of likely problematic operators. However, we usually do not know which operators are
likely to be problematic unless we observed an error in the wild, saw we were missing
assembly information, and then modified the code to activate assembly tracking, hoping to
observe the same error again.</p>
</div>
<div class="paragraph">
<p>In that scenario, we have to switch into debugging mode and make preparations in order to
better observe a second occurrence of the error, this time capturing all the additional
information.</p>
</div>
<div class="paragraph">
<p>If you can identify reactive chains that you assemble in your application for which
serviceability is critical, <strong>a mix of both techniques can be achieved with the
<code>checkpoint()</code> operator.</strong></p>
</div>
<div class="paragraph">
<p>You can chain this operator into a method chain. The <code>checkpoint</code> operator works like the
hook version, but only for its link of that particular chain.</p>
</div>
<div class="paragraph">
<p>There is also a <code>checkpoint(String)</code> variant that lets you add a unique String identifier
to the assembly traceback. This way, the stack trace is omitted and you rely on the
description to identify the assembly site. A <code>checkpoint(String)</code> imposes less processing
cost than a regular <code>checkpoint</code>.</p>
</div>
<div class="paragraph">
<p><code>checkpoint(String)</code> includes "light" in its output (which can be handy when
searching), as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>...
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:
Assembly site of producer [reactor.core.publisher.ParallelSource] is identified by light checkpoint [light checkpoint identifier].</pre>
</div>
</div>
<div class="paragraph">
<p>Last but not least, if you want to add a more generic description to the checkpoint but
still rely on the stack trace mechanism to identify the assembly site, you can force that
behavior by using the <code>checkpoint("description", true)</code> version. We are now back to the
initial message for the traceback, augmented with a <code>description</code>, as shown in the
following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] : <i class="conum" data-value="1"></i><b>(1)</b>
	reactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)
	reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)
Error has been observed by the following operator(s):
	|_	ParallelFlux.checkpoint â¢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>descriptionCorrelation1234</code> is the description provided in the <code>checkpoint</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The description could be a static identifier or user-readable description or a wider
<strong>correlation ID</strong> (for instance, coming from a header in the case of an HTTP request).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When both global debugging and local <code>checkpoint()</code> are enabled, checkpointed
snapshot stacks are appended as suppressed error output after the observing operator
graph and following the same declarative order.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logging_a_sequence"><a class="anchor" href="#_logging_a_sequence"></a>7.4. Logging a sequence</h3>
<div class="paragraph">
<p>In addition to stack trace debugging and analysis, another powerful tool to have in your
toolkit is the ability to trace and log events in an asynchronous sequence.</p>
</div>
<div class="paragraph">
<p>The <code>log()</code> operator can do just that. Chained inside a sequence, it will peek at every
event of the <code>Flux</code> or <code>Mono</code> upstream of it (including <code>onNext</code>, <code>onError</code>, and
<code>onComplete</code> and <em>subscriptions</em>, <em>cancellations</em>, and <em>requests</em>).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Side note on logging implementation</div>
<div class="paragraph">
<p>The <code>log</code> operator uses the <code>Loggers</code> utility class, which picks up common logging
frameworks like Log4J and Logback through <strong><code>SLF4J</code></strong> and defaults to logging to the
console in case SLF4J is unavailable.</p>
</div>
<div class="paragraph">
<p>The Console fallback uses <code>System.err</code> for the <code>WARN</code> and <code>ERROR</code> log levels and
<code>System.out</code> for everything else.</p>
</div>
<div class="paragraph">
<p>If you prefer a JDK <code>java.util.logging</code> fallback, as in 3.0.x, you can get it by setting
the <code>reactor.logging.fallback</code> System property to <code>JDK</code>.</p>
</div>
<div class="paragraph">
<p>In all cases, when logging in production <strong>you should take care to configure the
underlying logging framework to use its most asynchronous and non-blocking approach</strong>.
For instance, an <code>AsyncAppender</code> in logback or <code>AsyncLogger</code> in Log4j 2.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For instance, suppose we have <em>logback</em> activated and configured and a chain like
<code>range(1,10).take(3)</code>. By placing a <code>log()</code> just before the <em>take</em>, we can get some
insight into how it works and what kind of events it propagates upstream to the <em>range</em>,
as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; flux = Flux.range(1, 10)
                         .log()
                         .take(3);
flux.subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This prints out (through the logger&#8217;s console appender):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>10:45:20.200 [main] INFO  reactor.Flux.Range.1 - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription) <i class="conum" data-value="1"></i><b>(1)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | request(unbounded) <i class="conum" data-value="2"></i><b>(2)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(1) <i class="conum" data-value="3"></i><b>(3)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(2)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(3)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | cancel() <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="paragraph">
<p>Here, in addition to the logger&#8217;s own formatter (time, thread, level, message), the
<code>log()</code> operator outputs a few things in its own format:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>reactor.Flux.Range.1</code> is an automatic <em>category</em> for the log, in case you use the
operator several times in a chain. It allows you to distinguish which operator&#8217;s events
are logged (in this case, the <code>range</code>). The identifier can be overwritten with your own
custom category by using the <code>log(String)</code> method signature. After a few separating
characters, the actual event gets printed. Here we get an <code>onSubscribe</code> call, an
<code>request</code> call, three <code>onNext</code> calls, and a <code>cancel</code> call. For the first line,
<code>onSubscribe</code>, we get the implementation of the <code>Subscriber</code>, which usually corresponds
to the operator-specific implementation. Between square brackets, we get additional
information, including whether the operator can be automatically optimized via
synchronous or asynchronous fusion.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>On the second line, we can see that an unbounded request was propagated up from
downstream.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then the range sends three values in a row.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>On the last line, we see <code>cancel()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The last line, <strong>(4)</strong>, is the most interesting. We can see the <code>take</code> in action there. It
operates by cutting the sequence short after it has seen enough elements emitted. In
short, <code>take()</code> causes the source to <code>cancel()</code> once it has emitted the user-requested
amount.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/debugging.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#debugging">Debugging Reactor</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced"><a class="anchor" href="#advanced"></a>8. Advanced Features and Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers advanced features and concepts of Reactor, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#advanced-mutualizing-operator-usage">Mutualizing Operator Usage</a></p>
</li>
<li>
<p><a href="#reactor.hotCold">Hot vs Cold</a></p>
</li>
<li>
<p><a href="#advanced-broadcast-multiple-subscribers-connectableflux">Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></p>
</li>
<li>
<p><a href="#advanced-three-sorts-batching">Three Sorts of Batching</a></p>
</li>
<li>
<p><a href="#advanced-parallelizing-parralelflux">Parallelizing Work with <code>ParallelFlux</code></a></p>
</li>
<li>
<p><a href="#scheduler-factory">Replacing Default <code>Schedulers</code></a></p>
</li>
<li>
<p><a href="#hooks">Using Global Hooks</a></p>
</li>
<li>
<p><a href="#context">Adding a Context to a Reactive Sequence</a></p>
</li>
<li>
<p><a href="#null-safety">Null-safety</a></p>
</li>
<li>
<p><a href="#cleanup">Dealing with Objects that need cleanup</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="advanced-mutualizing-operator-usage"><a class="anchor" href="#advanced-mutualizing-operator-usage"></a>8.1. Mutualizing Operator Usage</h3>
<div class="paragraph">
<p>From a clean-code perspective, code reuse is generally a good thing. Reactor offers a few
patterns that can help you reuse and mutualize code, notably for operators or combination
of operators that you might want to apply regularly in your codebase. If you think of a
chain of operators as a recipe, you can create a cookbook of operator recipes.</p>
</div>
<div class="sect3">
<h4 id="_using_the_transform_operator"><a class="anchor" href="#_using_the_transform_operator"></a>8.1.1. Using the <code>transform</code> Operator</h4>
<div class="paragraph">
<p>The <code>transform</code> operator lets you encapsulate a piece of an operator chain into a
function. That function is applied to an original operator chain at assembly time to
augment it with the encapsulated operators. Doing so applies the same operations to all
the subscribers of a sequence and is basically equivalent to chaining the operators
directly. The following code shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap =
f -&gt; f.filter(color -&gt; !color.equals("orange"))
      .map(String::toUpperCase);

Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
	.doOnNext(System.out::println)
	.transform(filterAndMap)
	.subscribe(d -&gt; System.out.println("Subscriber to Transformed MapAndFilter: "+d));</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-transform.png" alt="Transform Operator : encapsulate flows">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber to Transformed MapAndFilter: BLUE
green
Subscriber to Transformed MapAndFilter: GREEN
orange
purple
Subscriber to Transformed MapAndFilter: PURPLE</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_compose_operator"><a class="anchor" href="#_using_the_compose_operator"></a>8.1.2. Using the <code>compose</code> Operator</h4>
<div class="paragraph">
<p>The <code>compose</code> operator is similar to <code>transform</code> and also lets you encapsulate operators
in a function. The major difference is that this function is applied to the original
sequence <strong>on a per-subscriber basis</strong>. It means that the function can actually produce a
different operator chain for each subscription (by maintaining some state). The
following code shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger ai = new AtomicInteger();
Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap = f -&gt; {
	if (ai.incrementAndGet() == 1) {
return f.filter(color -&gt; !color.equals("orange"))
        .map(String::toUpperCase);
	}
	return f.filter(color -&gt; !color.equals("purple"))
	        .map(String::toUpperCase);
};

Flux&lt;String&gt; composedFlux =
Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .compose(filterAndMap);

composedFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
composedFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-compose.png" alt="Compose Operator : Per Subscriber transformation">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber 1 to Composed MapAndFilter :BLUE
green
Subscriber 1 to Composed MapAndFilter :GREEN
orange
purple
Subscriber 1 to Composed MapAndFilter :PURPLE
blue
Subscriber 2 to Composed MapAndFilter: BLUE
green
Subscriber 2 to Composed MapAndFilter: GREEN
orange
Subscriber 2 to Composed MapAndFilter: ORANGE
purple</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor.hotCold"><a class="anchor" href="#reactor.hotCold"></a>8.2. Hot vs Cold</h3>
<div class="paragraph">
<p>So far, we have considered that all <code>Flux</code> (and <code>Mono</code>) are the same: They all represent
an asynchronous sequence of data, and nothing happens before you subscribe.</p>
</div>
<div class="paragraph">
<p>Really, though, there are two broad families of publishers: <strong>hot</strong> and <strong>cold</strong>.</p>
</div>
<div class="paragraph">
<p>The description above applies to the <strong>cold</strong> family of publishers. They generate data anew
for each subscription. If no subscription is created, then data never gets generated.</p>
</div>
<div class="paragraph">
<p>Think of an HTTP request: Each new subscriber will trigger an HTTP call, but no call is
made if no one is interested in the result.</p>
</div>
<div class="paragraph">
<p><strong>Hot</strong> publishers, on the other hand, do not depend on any number of subscribers. They
might start publishing data right away and would continue doing so whenever a new
<code>Subscriber</code> comes in (in which case said subscriber would only see new elements emitted
<em>after</em> it subscribed). For hot publishers, <em>something</em> does indeed happen before you
subscribe.</p>
</div>
<div class="paragraph">
<p>One example of the few hot operators in Reactor is <code>just</code>: It directly captures the value
at assembly time and replays it to anybody subscribing to it later. To re-use the HTTP
call analogy, if the captured data is the result of an HTTP call, then only one network
call is made, when instantiating <em>just</em>.</p>
</div>
<div class="paragraph">
<p>To transform <code>just</code> into a <em>cold</em> publisher, you can use <code>defer</code>. It defers the HTTP
request in our example to subscription time (and would result in a separate network call
for each new subscription).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most other <em>hot</em> publishers in Reactor extend <code>Processor</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider two other examples. The following code shows the first example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
                          .map(String::toUpperCase);

source.subscribe(d -&gt; System.out.println("Subscriber 1: "+d));
source.subscribe(d -&gt; System.out.println("Subscriber 2: "+d));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This first example produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Subscriber 1: BLUE
Subscriber 1: GREEN
Subscriber 1: ORANGE
Subscriber 1: PURPLE
Subscriber 2: BLUE
Subscriber 2: GREEN
Subscriber 2: ORANGE
Subscriber 2: PURPLE</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-cold.png" alt="Replaying behavior">
</div>
</div>
<div class="paragraph">
<p>Both subscribers catch all four colors, because each subscriber causes the
process defined by the operators on the <code>Flux</code> to run.</p>
</div>
<div class="paragraph">
<p>Compare the first example to the second example, shown in the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DirectProcessor&lt;String&gt; hotSource = DirectProcessor.create();

Flux&lt;String&gt; hotFlux = hotSource.map(String::toUpperCase);


hotFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Hot Source: "+d));

hotSource.onNext("blue");
hotSource.onNext("green");

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Hot Source: "+d));

hotSource.onNext("orange");
hotSource.onNext("purple");
hotSource.onComplete();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second example produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Subscriber 1 to Hot Source: BLUE
Subscriber 1 to Hot Source: GREEN
Subscriber 1 to Hot Source: ORANGE
Subscriber 2 to Hot Source: ORANGE
Subscriber 1 to Hot Source: PURPLE
Subscriber 2 to Hot Source: PURPLE</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-hot.png" alt="Broadcasting a subscription">
</div>
</div>
<div class="paragraph">
<p>Subscriber 1 catches all four colors. Subscriber 2, having been created after the first
two colors were produced, catches only the last two colors. This difference accounts for
the doubling of "ORANGE" and "PURPLE" in the output. The process described by the
operators on this Flux runs regardless of when subscriptions have been attached.</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-broadcast-multiple-subscribers-connectableflux"><a class="anchor" href="#advanced-broadcast-multiple-subscribers-connectableflux"></a>8.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></h3>
<div class="paragraph">
<p>Sometimes, you want to not only defer some processing to the subscription time of one
subscriber, but you might actually want for several of them to <em>rendezvous</em> and <strong>then</strong>
trigger the subscription and data generation.</p>
</div>
<div class="paragraph">
<p>This is what <code>ConnectableFlux</code> is made for. Two main patterns are covered in the <code>Flux</code>
API that return a <code>ConnectableFlux</code>: <code>publish</code> and <code>replay</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>publish</code> dynamically tries to respect the demand from its various subscribers, in
terms of backpressure, by forwarding these requests to the source. Most notably, if any
subscriber has a pending demand of <code>0</code>, publish <strong>pauses</strong> its requesting to the source.</p>
</li>
<li>
<p><code>replay</code> buffers data seen through the first subscription, up to configurable limits
(in time and buffer size). It replays the data to subsequent subscribers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>ConnectableFlux</code> offers additional methods to manage subscriptions downstream
versus subscriptions to the original source. These additional methods include the
following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connect()</code> can be called manually once you reach enough subscriptions to the flux. That
triggers the subscription to the upstream source.</p>
</li>
<li>
<p><code>autoConnect(n)</code> can do the same job automatically once <code>n</code> subscriptions have been
made.</p>
</li>
<li>
<p><code>refCount(n)</code> not only automatically tracks incoming subscriptions but also detects
when these subscriptions are cancelled. If not enough subscribers are tracked, the source
is "disconnected", causing a new subscription to the source later if additional
subscribers appear.</p>
</li>
<li>
<p><code>refCount(int, Duration)</code> adds a "grace period": Once the number of tracked subscribers
becomes too low, it waits for the <code>Duration</code> before disconnecting the source, potentially
allowing for enough new subscribers to come in and cross the connection threshold again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

ConnectableFlux&lt;Integer&gt; co = source.publish();

co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});

System.out.println("done subscribing");
Thread.sleep(500);
System.out.println("will now connect");

co.connect();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>done subscribing
will now connect
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
<div class="paragraph">
<p>With <code>autoConnect</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

Flux&lt;Integer&gt; autoCo = source.publish().autoConnect(2);

autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
System.out.println("subscribed first");
Thread.sleep(500);
System.out.println("subscribing second");
autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>subscribed first
subscribing second
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-three-sorts-batching"><a class="anchor" href="#advanced-three-sorts-batching"></a>8.4. Three Sorts of Batching</h3>
<div class="paragraph">
<p>When you have lots of elements and you want to separate them into batches, you have three
broad solutions in Reactor: grouping, windowing, and buffering. These three are
conceptually close, because they redistribute a <code>Flux&lt;T&gt;</code> into an aggregate. Grouping and
windowing create a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>, while buffering aggregates into a <code>Collection&lt;T&gt;</code>.</p>
</div>
<div class="sect3">
<h4 id="_grouping_with_fluxgroupedfluxt"><a class="anchor" href="#_grouping_with_fluxgroupedfluxt"></a>8.4.1. Grouping with <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Grouping is the act of splitting the source <code>Flux&lt;T&gt;</code> into multiple batches by a <strong>key</strong>.</p>
</div>
<div class="paragraph">
<p>The associated operator is <code>groupBy</code>.</p>
</div>
<div class="paragraph">
<p>Each group is represented as a <code>GroupedFlux&lt;T&gt;</code>, which lets you retrieve the key via its
<code>key()</code> method.</p>
</div>
<div class="paragraph">
<p>There is no necessary continuity in the content of the groups. Once a source element
produces a new key, the group for this key is opened and elements that match the key end
up in the group (several groups could be open at the same time).</p>
</div>
<div class="paragraph">
<p>This means that groups:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Are always disjoint (a source element belongs to 1 and only 1 group).</p>
</li>
<li>
<p>Can contain elements from different places in the original sequence.</p>
</li>
<li>
<p>Are never empty.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.groupBy(i -&gt; i % 2 == 0 ? "even" : "odd")
		.concatMap(g -&gt; g.defaultIfEmpty(-1) //if empty groups, show them
				.map(String::valueOf) //map to string
				.startWith(g.key())) //start with the group's key
	)
	.expectNext("odd", "1", "3", "5", "11", "13")
	.expectNext("even", "2", "4", "6", "12")
	.verifyComplete();</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Grouping is best suited for when you have a medium to low number of groups. The
groups must also imperatively be consumed (such as by a <code>flatMap</code>) so that <code>groupBy</code>
continues fetching data from upstream and feeding more groups. Sometimes, these two
constraints multiply and lead to hangs, such as when you have a high cardinality and the
concurrency of the <code>flatMap</code> consuming the groups is too low.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_windowing_with_fluxfluxt"><a class="anchor" href="#_windowing_with_fluxfluxt"></a>8.4.2. Windowing with <code>Flux&lt;Flux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Windowing is the act of splitting the source <code>Flux&lt;T&gt;</code> into <em>windows</em>, by criteria of
size, time, boundary-defining predicates, or boundary-defining <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>The associated operators are <code>window</code>, <code>windowTimeout</code>, <code>windowUntil</code>, <code>windowWhile</code>, and
<code>windowWhen</code>.</p>
</div>
<div class="paragraph">
<p>Contrary to <code>groupBy</code>, which randomly overlaps according to incoming keys,
most of the time windows are opened sequentially.</p>
</div>
<div class="paragraph">
<p>Some variants <strong>can</strong> still overlap, though. For instance in <code>window(int maxSize, int skip)</code>
the <code>maxSize</code> parameter is the number of elements after which a window
closes, and the <code>skip</code> parameter is the number of elements in the source after which a
new window is opened. So if <code>maxSize &gt; skip</code>, a new window opens before the previous one
closes and the two windows overlap.</p>
</div>
<div class="paragraph">
<p>The following example shows overlapping windows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.window(5, 3) //overlapping windows
		.concatMap(g -&gt; g.defaultIfEmpty(-1)) //show empty windows as -1
	)
		.expectNext(1, 2, 3, 4, 5)
		.expectNext(4, 5, 6, 7, 8)
		.expectNext(7, 8, 9, 10)
		.expectNext(10)
		.verifyComplete();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With the reverse configuration (<code>maxSize</code> &lt; <code>skip</code>), some elements from
the source are dropped and are not part of any window.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of predicate-based windowing via <code>windowUntil</code> and <code>windowWhile</code>,
having subsequent source elements that do not match the predicate can also lead
to <em>empty windows</em>, as demonstrated in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.windowWhile(i -&gt; i % 2 == 0)
		.concatMap(g -&gt; g.defaultIfEmpty(-1))
	)
		.expectNext(-1, -1, -1) //respectively triggered by odd 1 3 5
		.expectNext(2, 4, 6) // triggered by 11
		.expectNext(12) // triggered by 13
		// however, no empty completion window is emitted (would contain extra matching elements)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buffering_with_fluxlistt"><a class="anchor" href="#_buffering_with_fluxlistt"></a>8.4.3. Buffering with <code>Flux&lt;List&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Buffering is similar to windowing, with the following twist: instead of emitting
<em>windows</em> (which are each a <code>Flux&lt;T&gt;</code>), it emits <em>buffers</em> (which are <code>Collection&lt;T&gt;</code>
- by default, <code>List&lt;T&gt;</code>).</p>
</div>
<div class="paragraph">
<p>The operators for buffering mirror those for windowing: <code>buffer</code>, <code>bufferTimeout</code>,
<code>bufferUntil</code>, <code>bufferWhile</code>, and <code>bufferWhen</code>.</p>
</div>
<div class="paragraph">
<p>Where the corresponding windowing operator opens a window, a buffering operator creates a
new collection and start adding elements to it. Where a window closes, the buffering
operator emits the collection.</p>
</div>
<div class="paragraph">
<p>Buffering can also lead to dropping source elements or having overlapping buffers, as
shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.buffer(5, 3) //overlapping buffers
	)
		.expectNext(Arrays.asList(1, 2, 3, 4, 5))
		.expectNext(Arrays.asList(4, 5, 6, 7, 8))
		.expectNext(Arrays.asList(7, 8, 9, 10))
		.expectNext(Collections.singletonList(10))
		.verifyComplete();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike in windowing, <code>bufferUntil</code> and <code>bufferWhile</code> do not emit an empty buffer, as
shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.bufferWhile(i -&gt; i % 2 == 0)
	)
	.expectNext(Arrays.asList(2, 4, 6)) // triggered by 11
	.expectNext(Collections.singletonList(12)) // triggered by 13
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-parallelizing-parralelflux"><a class="anchor" href="#advanced-parallelizing-parralelflux"></a>8.5. Parallelizing Work with <code>ParallelFlux</code></h3>
<div class="paragraph">
<p>With multi-core architectures being a commodity nowadays, being able to easily
parallelize work is important. Reactor helps with that by providing a special type,
<code>ParallelFlux</code>, that exposes operators that are optimized for parallelized work.</p>
</div>
<div class="paragraph">
<p>To obtain a <code>ParallelFlux</code>, you can use the <code>parallel()</code> operator on any <code>Flux</code>.
<strong>By itself, this method does not parallelize the work</strong>. Rather, it divides
the workload into "rails" (by default, as many rails as there are CPU cores).</p>
</div>
<div class="paragraph">
<p>In order to tell the resulting ParallelFlux where to execute each rail (and, by
extension, to execute rails in parallel) you have to use <code>runOn(Scheduler)</code>. Note that
there is a recommended dedicated Scheduler for parallel work: <code>Schedulers.parallel()</code>.</p>
</div>
<div class="paragraph">
<p>Compare the next two examples, the first of which is shown in the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .parallel(2) <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We force a number of rails instead of relying on the number of CPU cores.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following code shows the second example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first example produces the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>main -&gt; 1
main -&gt; 2
main -&gt; 3
main -&gt; 4
main -&gt; 5
main -&gt; 6
main -&gt; 7
main -&gt; 8
main -&gt; 9
main -&gt; 10</pre>
</div>
</div>
<div class="paragraph">
<p>The second correctly parallelizes on two threads, as shown in the following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>parallel-1 -&gt; 1
parallel-2 -&gt; 2
parallel-1 -&gt; 3
parallel-2 -&gt; 4
parallel-1 -&gt; 5
parallel-2 -&gt; 6
parallel-1 -&gt; 7
parallel-1 -&gt; 9
parallel-2 -&gt; 8
parallel-2 -&gt; 10</pre>
</div>
</div>
<div class="paragraph">
<p>If, once you process your sequence in parallel, you want to revert back to a "normal"
<code>Flux</code> and apply the rest of the operator chain in a sequential manner, you can use the
<code>sequential()</code> method on <code>ParallelFlux</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>sequential()</code> is implicitly applied if you <code>subscribe</code> to the ParallelFlux
with a <code>Subscriber</code> but not when using the lambda-based variants of <code>subscribe</code>.</p>
</div>
<div class="paragraph">
<p>Note also that <code>subscribe(Subscriber&lt;T&gt;)</code> merges all the rails, while
<code>subscribe(Consumer&lt;T&gt;)</code> runs all the rails. If the <code>subscribe()</code> method has a lambda,
each lambda is executed as many times as there are rails.</p>
</div>
<div class="paragraph">
<p>You can also access individual rails or "groups" as a <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> through the
<code>groups()</code> method and apply additional operators to them through the <code>composeGroup()</code>
method.</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduler-factory"><a class="anchor" href="#scheduler-factory"></a>8.6. Replacing Default <code>Schedulers</code></h3>
<div class="paragraph">
<p>As we have seen in the <a href="#schedulers">Threading and Schedulers</a> section, Reactor Core comes with several
<code>Scheduler</code> implementations. While you can always create new instances through the <code>new*</code>
factory methods, each <code>Scheduler</code> flavor also has a default singleton instance that is
accessible through the direct factory method (such as <code>Schedulers.elastic()</code> versus
<code>Schedulers.newElastic()</code>).</p>
</div>
<div class="paragraph">
<p>These default instances are the ones used by operators that need a <code>Scheduler</code> to work
when you do not explicitly specify one. For example, <code>Flux#delayElements(Duration)</code> uses
the <code>Schedulers.parallel()</code> instance.</p>
</div>
<div class="paragraph">
<p>In some cases, however, you might need to change these default instances with something
else in a cross-cutting way, without having to make sure every single operator you call
has your specific <code>Scheduler</code> as a parameter. An example is measuring the time every
single scheduled task takes by wrapping the real schedulers, for instrumentation
purposes. In other words, you might want to <strong>change the default <code>Schedulers</code></strong>.</p>
</div>
<div class="paragraph">
<p>Changing the default schedulers is possible through the <code>Schedulers.Factory</code> class. By
default, a <code>Factory</code> creates all the standard <code>Scheduler</code> through similarly named
methods. Each of these can be overridden with your custom implementation.</p>
</div>
<div class="paragraph">
<p>Additionally, the <code>Factory</code> exposes one additional customization method:
<code>decorateExecutorService</code>. It is invoked during the creation of every reactor-core
<code>Scheduler</code> that is backed by a <code>ScheduledExecutorService</code> (even non-default instances,
such as those created by calls to <code>Schedulers.newParallel()</code>).</p>
</div>
<div class="paragraph">
<p>This lets you tune the <code>ScheduledExecutorService</code> to be used: The default one is exposed
as a <code>Supplier</code> and, depending on the type of <code>Scheduler</code> being configured, you can choose
to entirely bypass that supplier and return your own instance or you can <code>get()</code> the
default instance and wrap it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Once you create a <code>Factory</code> that fits your needs, you must install it via
<code>Schedulers.setFactory(Factory)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, there is a last customizable hook in <code>Schedulers</code>: <code>onHandleError</code>. This hook is
invoked whenever a <code>Runnable</code> task submitted to a <code>Scheduler</code> throws an <code>Exception</code> (note
that if there is an <code>UncaughtExceptionHandler</code> set for the <code>Thread</code> that ran the task,
both the handler and the hook will be invoked).</p>
</div>
</div>
<div class="sect2">
<h3 id="hooks"><a class="anchor" href="#hooks"></a>8.7. Using Global Hooks</h3>
<div class="paragraph">
<p>Reactor has another category of configurable callbacks that are invoked by Reactor
operators in various situations. They are all set in the <code>Hooks</code> class, and fall into
three categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hooks-dropping">Dropping Hooks</a></p>
</li>
<li>
<p><a href="#hooks-internal">Internal Error Hook</a></p>
</li>
<li>
<p><a href="#hooks-assembly">Assembly Hooks</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hooks-dropping"><a class="anchor" href="#hooks-dropping"></a>8.7.1. Dropping Hooks</h4>
<div class="paragraph">
<p>Dropping hooks are invoked when the source of an operator does not comply with the
Reactive Streams specification. These kind of errors are outside of the normal execution
path (that is, they cannot be propagated through <code>onError</code>).</p>
</div>
<div class="paragraph">
<p>Typically, a <code>Publisher</code> calls <code>onNext</code> on the operator despite having already called
<code>onCompleted</code> on it previously. In that case, the <code>onNext</code> value is <em>dropped</em>. The same
is true for an extraneous <code>onError</code> signal.</p>
</div>
<div class="paragraph">
<p>The corresponding hooks, <code>onNextDropped</code> and <code>onErrorDropped</code>, let you provide a global
<code>Consumer</code> for these drops. For example, you can use it to log the drop and cleanup
resources associated with a value if needed (as it never makes it to the rest of the
reactive chain).</p>
</div>
<div class="paragraph">
<p>Setting the hooks twice in a row is additive: every consumer you provide is invoked. The
hooks can be fully reset to their defaults by using <code>Hooks.resetOn*Dropped()</code> methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-internal"><a class="anchor" href="#hooks-internal"></a>8.7.2. Internal Error Hook</h4>
<div class="paragraph">
<p>One hook, <code>onOperatorError</code>, is invoked by operators when an unexpected <code>Exception</code> is
thrown during the execution of their <code>onNext</code>, <code>onError</code> and <code>onComplete</code> methods.</p>
</div>
<div class="paragraph">
<p>Unlike the previous category, this is still within the normal execution path. A typical
example is the <code>map</code> operator with a map function that throws an <code>Exception</code> (such as
division by zero). It is still possible at this point to go through the usual channel of
<code>onError</code>, and that is what the operator does.</p>
</div>
<div class="paragraph">
<p>First, it passes the <code>Exception</code> through <code>onOperatorError</code>. The hook lets you inspect the
error (and the incriminating value, if relevant) and <em>change</em> the <code>Exception</code>. Of course,
you can also do something on the side, such as log and return the original Exception.</p>
</div>
<div class="paragraph">
<p>Note that the <code>onOperatorError</code> hook can be set multiple times: you can provide a
<code>String</code> identifier for a particular <code>BiFunction</code>, and subsequent calls with different
keys concatenates the functions, which are all executed. On the other hand, reusing the
same key twice lets you replace a function you previously set.</p>
</div>
<div class="paragraph">
<p>As a consequence, the default hook behavior can be both fully reset (using
<code>Hooks.resetOnOperatorError()</code>) or partially reset for a specific <code>key</code> only (by using
<code>Hooks.resetOnOperatorError(String)</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-assembly"><a class="anchor" href="#hooks-assembly"></a>8.7.3. Assembly Hooks</h4>
<div class="paragraph">
<p>These hooks tie in the lifecycle of operators. They are invoked when a chain of operators
is assembled (that is, instantiated). <code>onEachOperator</code> lets you dynamically change each
operator as it is assembled in the chain, by returning a different <code>Publisher</code>.
<code>onLastOperator</code> is similar, except that it is only invoked on the last operator in the
chain before the <code>subscribe</code> call.</p>
</div>
<div class="paragraph">
<p>If you want to decorate all operators with a cross-cutting <code>Subscriber</code> implementation,
you can look into <code>Operators#lift*</code> methods to help you deal with the various
types of Reactor <code>Publishers</code> out there (Flux, Mono, ParallelFlux, GroupedFlux, ConnectableFlux),
as well as their <code>Fuseable</code> version.</p>
</div>
<div class="paragraph">
<p>Like <code>onOperatorError</code>, these hooks are cumulative and can be identified with a key. They
can also be reset partially or totally.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hook_presets"><a class="anchor" href="#_hook_presets"></a>8.7.4. Hook Presets</h4>
<div class="paragraph">
<p>The <code>Hooks</code> utility class provides a couple of preset hooks. These are alternatives to
the default behaviors that you can use by calling their corresponding method, rather than
coming up with the hook yourself:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onNextDroppedFail()</code>: <code>onNextDropped</code> used to throw a <code>Exceptions.failWithCancel()</code>
exception. It now defaults to logging the dropped value at the DEBUG level. To go back to
the old default behavior of throwing, use <code>onNextDroppedFail()</code>.</p>
</li>
<li>
<p><code>onOperatorDebug()</code>: This method activates <a href="#debug-activate">debug mode</a>. It ties into
the <code>onOperatorError</code> hook, so calling <code>resetOnOperatorError()</code> also resets it. It can be
independently reset via <code>resetOnOperatorDebug()</code> as it uses a specific key internally.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>8.8. Adding a Context to a Reactive Sequence</h3>
<div class="paragraph">
<p>One of the big technical challenges encountered when switching from an imperative
programming perspective to a reactive programming mindset lies in how you deal with
threading.</p>
</div>
<div class="paragraph">
<p>Contrary to what you might be used to, in reactive programming, a <code>Thread</code> can be used
to process several asynchronous sequences that run roughly at the same time (actually, in
non-blocking locksteps). The execution can also easily and often jump from one thread to
another.</p>
</div>
<div class="paragraph">
<p>This arrangement is especially hard for developers that use features dependent on the
threading model being more "stable", such as <code>ThreadLocal</code>. As it lets you associate
data with a <strong>thread</strong>, it becomes tricky to use in a reactive context. As a result,
libraries that rely on <code>ThreadLocal</code> at least introduce new challenges when used with
Reactor. At worst, they work badly or even fail. Using the MDC of Logback to store and
log correlation IDs is a prime example of such a situation.</p>
</div>
<div class="paragraph">
<p>The usual workaround for <code>ThreadLocal</code> usage is to move the contextual data, <code>C</code>, along
your business data, <code>T</code>, in the sequence, by using <code>Tuple2&lt;T, C&gt;</code> for instance. This does
not look good and leaks an orthogonal concern (the contextual data) into your method and
<code>Flux</code> signatures.</p>
</div>
<div class="paragraph">
<p>Since version <code>3.1.0</code>, Reactor comes with an advanced feature that is somewhat comparable
to <code>ThreadLocal</code> but applied to a <code>Flux</code> or a <code>Mono</code> instead of a <code>Thread</code>: the <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>As an illustration of how it looks like, here is a very simple example of both writing to
the <code>Context</code> and reading from it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "World"));

StepVerifier.create(r)
            .expectNext("Hello World")
            .verifyComplete();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following sections, we&#8217;ll learn about the <code>Context</code> and how to use it, so that you
will eventually understand the example above.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an advanced feature that is more targeted at library developers. It
requires good understanding of the lifecycle of a <code>Subscription</code> and is intended for
libraries that are responsible for the subscriptions.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_context_api"><a class="anchor" href="#_the_context_api"></a>8.8.1. The <code>Context</code> API</h4>
<div class="paragraph">
<p>A <code>Context</code> is an interface reminiscent of <code>Map</code>: it stores key-value pairs and lets you
fetch a value you stored by its key. More specifically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Both key and values are of type <code>Object</code>, so a <code>Context</code> can contain any number of
highly divergent values from different libraries and sources.</p>
</li>
<li>
<p>A <code>Context</code> is <strong>immutable</strong>.</p>
</li>
<li>
<p>Use <code>put(Object key, Object value)</code> to store a key-value pair, returning a new
<code>Context</code> instance. You can also merge two contexts into a new one by using
<code>putAll(Context)</code>.</p>
</li>
<li>
<p>You can check if the key is present with <code>hasKey(Object key)</code>.</p>
</li>
<li>
<p>Use <code>getOrDefault(Object key, T defaultValue)</code> to retrieve a value (cast to a <code>T</code>) or
fall back to a default one if the Context does not have that key.</p>
</li>
<li>
<p>Use <code>getOrEmpty(Object key)</code> to get an <code>Optional&lt;T&gt;</code> (the context attempts to cast the
stored value to <code>T</code>).</p>
</li>
<li>
<p>Use <code>delete(Object key)</code> to remove the value associated to a key, returning a new
<code>Context</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When <strong>creating a</strong> <code>Context</code>, you can create pre-valued contexts with up to five
key-value pairs by using the static <code>Context.of</code> methods. They take 2, 4, 6, 8 or 10
<code>Object</code> instances, each couple of <code>Object</code> instances being a key-value pair to add to
the <code>Context</code>.<br>
<br>
Alternatively you can also create an empty <code>Context</code> by using <code>Context.empty()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_tying_the_context_to_a_flux_and_writing"><a class="anchor" href="#_tying_the_context_to_a_flux_and_writing"></a>8.8.2. Tying the <code>Context</code> to a <code>Flux</code> and Writing</h4>
<div class="paragraph">
<p>To make the context useful, it must be tied to a specific sequence and be accessible by
each operator in a chain. Note that the operator must be  a Reactor native operator, as
<code>Context</code> is specific to Reactor.</p>
</div>
<div class="paragraph">
<p>Actually, a <code>Context</code> is tied to each <code>Subscriber</code> to a chain. It uses the <code>Subscription</code>
propagation mechanism to make itself available to each operator, starting with the final
<code>subscribe</code> and moving up the chain.</p>
</div>
<div class="paragraph">
<p>In order to populate the <code>Context</code>, which can only be done at subscription time, you need
to use the <code>subscriberContext</code> operator.</p>
</div>
<div class="paragraph">
<p>Use <code>subscriberContext(Context)</code>, which merges the <code>Context</code> you provide and the
<code>Context</code> from downstream (remember, the <code>Context</code> is propagated from the bottom of the
chain towards the top). This is done through a call to <code>putAll</code>, resulting in a new
<code>Context</code> for upstream.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also use the more advanced <code>subscriberContext(Function&lt;Context, Context&gt;)</code>.
It receives the state of the <code>Context</code> from downstream and lets you put or delete values
as you see fit, returning the new <code>Context</code> to use. You can even decide to return a
completely different instance, although it is really not recommended (doing so might
impact 3rd-party libraries that depend on the <code>Context</code>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_reading_the_context"><a class="anchor" href="#_reading_the_context"></a>8.8.3. Reading the Context</h4>
<div class="paragraph">
<p>Populating the <code>Context</code> is one aspect, but retrieving that data from it is equally
important. Most of the time, the responsibility of putting information into the <code>Context</code>
is on the end user&#8217;s side, while exploiting that information is on the 3rd-party library&#8217;s side,
as the such libraries are usually upstream of the client code.</p>
</div>
<div class="paragraph">
<p>The tool for reading data from the context is the static <code>Mono.subscriberContext()</code>
method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_simple_examples"><a class="anchor" href="#_simple_examples"></a>8.8.4. Simple Examples</h4>
<div class="paragraph">
<p>The examples in this section are meant as ways to better understand some of the caveats of
using a <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first look back at our simple example from the introduction in a bit more details:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext() <i class="conum" data-value="2"></i><b>(2)</b>
                                   .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello World") <i class="conum" data-value="4"></i><b>(4)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The chain of operators ends with a call to <code>subscriberContext(Function)</code> that puts
<code>"World"</code> into the <code>Context</code> under the key <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <code>flatMap</code> on the source element, materializing the <code>Context</code> with <code>Mono.subscriberContext()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We then use <code>map</code> to extract the data associated to <code>"message"</code> and concatenate that with
the original word.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> indeed emits <code>"Hello World"</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The numbering above vs the actual line order is not a mistake: it represents
the execution order. Even though <code>subscriberContext</code> is the last piece of the chain, it is
the one that gets executed first (due to its subscription time nature, and the fact that
the subscription signal flows from bottom to top).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that in your chain of operators, the <strong>relative positions</strong> of where you <strong>write</strong> to the
<code>Context</code> and where you <strong>read</strong> from it matters: the <code>Context</code>
is immutable and its content can only be seen by operators above it, as demonstrated in
the following code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")) <i class="conum" data-value="1"></i><b>(1)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.getOrDefault(key, "Stranger")));  <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Stranger") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Context</code> is written to too high in the chain&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As a result, in the <code>flatMap</code>, there&#8217;s no value associated to our key. A default value
is used instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> thus emits <code>"Hello Stranger"</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example also demonstrates the immutable nature of the <code>Context</code>, and how
<code>Mono.subscriberContext()</code> always returns the <code>Context</code> set by <code>subscriberContext</code> calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";

Mono&lt;String&gt; r = Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
	.map( ctx -&gt; ctx.put(key, "Hello")) <i class="conum" data-value="2"></i><b>(2)</b>
	.flatMap( ctx -&gt; Mono.subscriberContext()) <i class="conum" data-value="3"></i><b>(3)</b>
	.map( ctx -&gt; ctx.getOrDefault(key,"Default")); <i class="conum" data-value="4"></i><b>(4)</b>

StepVerifier.create(r)
	.expectNext("Default") <i class="conum" data-value="5"></i><b>(5)</b>
	.verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We materialize the <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In a <code>map</code> we attempt to mutate it</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We re-materialize the <code>Context</code> in a <code>flatMap</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We read the attempted key in the <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The key was never set to <code>"Hello"</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, in case of several attempts to write the same key to the <code>Context</code>, the
<strong>relative order of the writes</strong> matters too: operators reading the <code>Context</code> will see
the value that was set closest to under them, as demonstrated in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A write attempt on key <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Another write attempt on key <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>map</code> only saw the value set closest to it (and below it): <code>"Reactor"</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here what happens is that the <code>Context</code> is populated during subscription with <code>"World"</code>.
Then the subscription signal moves upstream, and another write happens. This produces a
second immutable <code>Context</code> with a value of <code>"Reactor"</code>. After that, data starts flowing.
The <code>flatMap</code> sees the <code>Context</code> closest to it, which is our second <code>Context</code> with the
<code>"Reactor"</code> value.</p>
</div>
<div class="paragraph">
<p>You might wonder if the <code>Context</code> is propagated along with the data signal. If that was
the case, putting another <code>flatMap</code> between these two writes would use the value from
the top <code>Context</code>. But this is not the case, as demonstrated by the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="2"></i><b>(2)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="4"></i><b>(4)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor World") <i class="conum" data-value="5"></i><b>(5)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the first write to happen.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the second write to happen.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>First <code>flatMap</code> sees second write.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Second <code>flatMap</code> concatenates result from first one with the value from <strong>first write</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>Mono</code> emits <code>"Hello Reactor World"</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reason is that the <code>Context</code> is associated to the <code>Subscriber</code> and each operator
accesses the <code>Context</code> by requesting it from its downstream <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>One last interesting propagation case is the one where the <code>Context</code> is also written to
<strong>inside</strong> a <code>flatMap</code>, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r =
        Mono.just("Hello")
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
            )
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
                               .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
            )
            .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello World Reactor")
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>subscriberContext</code> does not impact anything outside of its <code>flatMap</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This <code>subscriberContext</code> impacts the main sequence&#8217;s <code>Context</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the example above, the final emitted value is <code>"Hello World Reactor"</code> and not "Hello
Reactor World", because the <code>subscriberContext</code> that writes "Reactor" does so as part of
the inner sequence of the second <code>flatMap</code>. As a consequence, it is not visible / propagated
through the main sequence and the first <code>flatMap</code> doesn&#8217;t see it. Propagation + immutability
isolate the <code>Context</code> in operators that create intermediate inner sequences like <code>flatMap</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_full_example"><a class="anchor" href="#_full_example"></a>8.8.5. Full Example</h4>
<div class="paragraph">
<p>Let&#8217;s consider a more real life example of a library reading information from the <code>Context</code>:
A reactive HTTP client that takes a <code>Mono&lt;String&gt;</code> as the source of data for a <code>PUT</code> but
also looks for a particular Context key to add a correlation ID to the request&#8217;s headers.</p>
</div>
<div class="paragraph">
<p>From the user perspective, it is called as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">doPut("www.example.com", Mono.just("Walter"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to propagate a correlation ID, it would be called as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">doPut("www.example.com", Mono.just("Walter"))
	.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the snippets above, the user code uses <code>subscriberContext</code> to populate
a <code>Context</code> with an <code>HTTP_CORRELATION_ID</code> key-value pair. The upstream of the operator is
a <code>Mono&lt;Tuple2&lt;Integer, String&gt;&gt;</code> (a simplistic representation of an HTTP response)
returned by the HTTP client library. So it is effectively passing information from the
user code to the library code.</p>
</div>
<div class="paragraph">
<p>The following example shows mock code from the library&#8217;s perspective that reads the
context and "augments the request" if it can find the correlation ID:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static final String HTTP_CORRELATION_ID = "reactive.http.library.correlationId";

Mono&lt;Tuple2&lt;Integer, String&gt;&gt; doPut(String url, Mono&lt;String&gt; data) {
	Mono&lt;Tuple2&lt;String, Optional&lt;Object&gt;&gt;&gt; dataAndContext =
			data.zipWith(Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
			                 .map(c -&gt; c.getOrEmpty(HTTP_CORRELATION_ID))); <i class="conum" data-value="2"></i><b>(2)</b>

	return dataAndContext
			.&lt;String&gt;handle((dac, sink) -&gt; {
				if (dac.getT2().isPresent()) { <i class="conum" data-value="3"></i><b>(3)</b>
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url + " with header X-Correlation-ID = " + dac.getT2().get());
				}
				else {
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url);
				}
				sink.complete();
			})
			.map(msg -&gt; Tuples.of(200, msg));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Materialize the <code>Context</code> through <code>Mono.subscriberContext()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Extract a value for a the correlation ID key, as an <code>Optional</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the key was present in the context, use the correlation ID as a header.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the library snippet, you can see how it zips the data <code>Mono</code> with
<code>Mono.subscriberContext()</code>. This gives the library a <code>Tuple2&lt;String, Context&gt;</code>, and that
context contains the <code>HTTP_CORRELATION_ID</code> entry from downstream (as it is on the direct
path to the subscriber).</p>
</div>
<div class="paragraph">
<p>The library code then uses <code>map</code> to extract an <code>Optional&lt;String&gt;</code> for that key, and, if
the entry is present, it uses the passed correlation ID as a <code>X-Correlation-ID</code> header.
That last part is simulated by the <code>handle</code> above.</p>
</div>
<div class="paragraph">
<p>The whole test that validates the library code used the correlation ID can be written as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void contextForLibraryReactivePut() {
	Mono&lt;String&gt; put = doPut("www.example.com", Mono.just("Walter"))
			.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
			.filter(t -&gt; t.getT1() &lt; 300)
			.map(Tuple2::getT2);

	StepVerifier.create(put)
	            .expectNext("PUT &lt;Walter&gt; sent to www.example.com with header X-Correlation-ID = 2-j3r9afaf92j-afkaf")
	            .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>8.9. Dealing with Objects that need cleanup</h3>
<div class="paragraph">
<p>In very specific cases, your application may deal with types that necessitate some form of cleanup once they&#8217;re not in use anymore.
This is an advanced scenario, for example when you have <em>reference counted</em> objects or when you&#8217;re dealing with <em>off heap</em> objects.
Netty&#8217;s <code>ByteBuf</code> is a prime example of both.</p>
</div>
<div class="paragraph">
<p>In order to ensure proper cleanup of such objects, you need to accommodate for it on a <code>Flux</code>-by-<code>Flux</code> basis, as well as in several of the global hooks (see <a href="#hooks">Using Global Hooks</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>doOnDiscard</code> <code>Flux</code>/<code>Mono</code> operator</p>
</li>
<li>
<p>The <code>onOperatorError</code> hook</p>
</li>
<li>
<p>The <code>onNextDropped</code> hook</p>
</li>
<li>
<p>Operator-specific handlers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is needed because each hook is made with a specific subset of cleanup in mind, and users might want ie. to implement specific error handling logic in addition to cleanup logic within <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>Note that some operators are less adapted to dealing with objects that need cleanup.
For example, <code>bufferWhen</code> can introduce overlapping buffers, and that means that the discard "local hook" above might see a first buffer as being discarded and cleanup an element in it that is in a second buffer <em>which is still valid</em>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the purpose of cleaning up, <strong>all these hooks MUST be IDEMPOTENT</strong>.
They might on some occasions get applied several times to the same object.
Unlike the <code>doOnDiscard</code> operator, which performs a class <code>instanceOf</code> check, the global hooks are also dealing with instances that can be any <code>Object</code> and it is up to the user&#8217;s implementation to distinguish between which instances need cleanup and which don&#8217;t.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_doondiscard_operator_local_hook"><a class="anchor" href="#_the_doondiscard_operator_local_hook"></a>8.9.1. The <code>doOnDiscard</code> operator / local hook</h4>
<div class="paragraph">
<p>This hook has been specifically put in place for cleanup of objects that would otherwise never be exposed to user code.
It is intended as a cleanup hook for flows that operate under normal circumstances (ie. not malformed sources that push too many items, which is covered by <code>onNextDropped</code>).</p>
</div>
<div class="paragraph">
<p>It is local, in the sense that it is activated through an operator and only applies to a given <code>Flux</code> or <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>Obvious cases include operators that filter elements from upstream.
These elements never reach the next operator (or final subscriber), but this is part of the normal path of execution.
As such, they are passed to the <code>doOnDiscard</code> hook.
For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter</code>: items that don&#8217;t match the filter are considered "discarded"</p>
</li>
<li>
<p><code>skip</code>: items skipped are discarded</p>
</li>
<li>
<p><code>buffer(maxSize, skip)</code> with <code>maxSize &lt; skip</code>: "dropping buffer", items in between buffers are discarded</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But <code>doOnDiscard</code> is not limited to filtering operators, and is also used by operators that internally queue data for backpressure purposes.
More specifically, most of the time this is important during cancellation: an operator that prefetches data from its source and later drains to its subscriber upon demand could have un-emitted data when it gets cancelled.
Such operators use the <code>doOnDiscard</code> hook during cancellation to clear up their internal backpressure <code>Queue</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Each call to <code>doOnDiscard(Class, Consumer)</code> is additive with the others, to the extent that it is only visible and used by operators upstream of it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_onoperatorerror_hook"><a class="anchor" href="#_the_onoperatorerror_hook"></a>8.9.2. The <code>onOperatorError</code> hook</h4>
<div class="paragraph">
<p>The <code>onOperatorError</code> hook is intended to modify errors in a transverse manner (similar to an AOP catch-and-rethrow).</p>
</div>
<div class="paragraph">
<p>When the error happens during the processing of an <code>onNext</code> signal, the element that was being emitted is passed to <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>If that type of element needs cleanup you need to implement it in the <code>onOperatorError</code> hook, possibly on top of error-rewriting code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_onnextdropped_hook"><a class="anchor" href="#_the_onnextdropped_hook"></a>8.9.3. The <code>onNextDropped</code> hook</h4>
<div class="paragraph">
<p>With malformed <code>Publishers</code>, there could be cases where an operator receives an element when it expected none (typically, after having received the <code>onError</code> or <code>onComplete</code> signals).
In such cases, the unexpected element is "dropped", passed to the <code>onNextDropped</code> hook.
If you have types that need cleanup, you must detect these in the <code>onNextDropped</code> hook and implement cleanup code there as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operator_specific_handlers"><a class="anchor" href="#_operator_specific_handlers"></a>8.9.4. Operator-specific handlers</h4>
<div class="paragraph">
<p>Some operators that deal with buffers and/or collect values as part of their operations have specific handlers for cases where collected data isn&#8217;t propagated downstream.
If you use such operators with the type(s) that need cleanup, you need to perform cleanup in these handlers.</p>
</div>
<div class="paragraph">
<p>For example, <code>distinct</code> has such a callback that is invoked when the operator terminates (or is cancelled) in order to clear the collection it uses to judge if an element is distinct or not.
By default, the collection is a <code>HashSet</code> and the cleanup callback is simply a <code>Hashet::clear</code>.
But if you deal with reference counted objects, you might want to change that to a more involved handler that would <code>release</code> each element in the set before `clear()`ing it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="null-safety"><a class="anchor" href="#null-safety"></a>8.10. Null-safety</h3>
<div class="paragraph">
<p>Although Java does not allow expressing null-safety with its type system, Reactor
now provides annotations to declare nullability of APIs, similar to those provided by
Spring Framework 5.</p>
</div>
<div class="paragraph">
<p>Reactor leverages these annotations, but they can also be used in any Reactor-based
Java project to declare null-safe APIs. Nullability of types used inside method bodies
is outside of the scope of this feature.</p>
</div>
<div class="paragraph">
<p>These annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant JSR that is supported by tools like IntelliJ IDEA) to provide
useful warnings to Java developers related to null-safety in order to avoid
<code>NullPointerException</code> at runtime. JSR 305 meta-annotations allows tooling vendors to
provide null-safety support in a generic way, without having to hard-code support for Reactor annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is not necessary nor recommended with Kotlin 1.1.5+ to have a dependency on JSR 305 in
your project classpath.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>They are also used by Kotlin which natively supports
<a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>. See
<a href="#kotlin-null-safety">this dedicated section</a> for more details.</p>
</div>
<div class="paragraph">
<p>The following annotations are provided in the <code>reactor.util.annotation</code> package:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNull.html"><code>@NonNull</code></a>
indicates that a specific parameter, return value, or field cannot be <code>null</code>.
(It is not needed on parameters and return value where <code>@NonNullApi</code> applies) .</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/Nullable.html"><code>@Nullable</code></a>
indicates that a parameter, return value, or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNullApi.html"><code>@NonNullApi</code></a>
is a package level annotation that indicates non-null is the default behavior for
parameters and return values.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Nullability for generic type arguments, varargs, and array elements is not supported yet.
See <a href="https://github.com/reactor/reactor-core/issues/878">issue #878</a> for up-to-date
information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/advancedFeatures.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#advanced">Advanced Features and Concepts</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="which-operator"><a class="anchor" href="#which-operator"></a>Appendix A: Which operator do I need?</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In this section, if an operator is specific to <code>Flux</code> or <code>Mono</code> it is
prefixed accordingly. Common operators have no prefix. When a specific use case
is covered by a combination of operators, it is presented as a method call, with
leading dot and parameters in parentheses, like this: <code>.methodCall(parameter)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I want to deal with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#which.create">Creating a New Sequence&#8230;&#8203;</a></p>
</li>
<li>
<p><a href="#which.values">Transforming an Existing Sequence</a></p>
</li>
<li>
<p><a href="#which.filtering">Filtering a Sequence</a></p>
</li>
<li>
<p><a href="#which.peeking">Peeking into a Sequence</a></p>
</li>
<li>
<p><a href="#which.errors">Handling Errors</a></p>
</li>
<li>
<p><a href="#which.time">Working with Time</a></p>
</li>
<li>
<p><a href="#which.window">Splitting a <code>Flux</code></a></p>
</li>
<li>
<p><a href="#which.blocking">Going Back to the Synchronous World</a></p>
</li>
<li>
<p><a href="#which.multicasting">Multicasting a <code>Flux</code> to several <code>Subscribers</code></a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="which.create"><a class="anchor" href="#which.create"></a>A.1. Creating a New Sequence&#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>that emits a <code>T</code>, and I already have: <code>just</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;from an <code>Optional&lt;T&gt;</code>: <code>Mono#justOrEmpty(Optional&lt;T&gt;)</code></p>
</li>
<li>
<p>&#8230;&#8203;from a potentially <code>null</code> T: <code>Mono#justOrEmpty(T)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits a <code>T</code> returned by a method: <code>just</code> as well</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily captured: use <code>Mono#fromSupplier</code> or wrap <code>just</code> inside <code>defer</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits several <code>T</code> I can explicitly enumerate: <code>Flux#just(T...)</code></p>
</li>
<li>
<p>that iterates over:</p>
<div class="ulist">
<ul>
<li>
<p>an array: <code>Flux#fromArray</code></p>
</li>
<li>
<p>a collection or iterable: <code>Flux#fromIterable</code></p>
</li>
<li>
<p>a range of integers: <code>Flux#range</code></p>
</li>
<li>
<p>a <code>Stream</code> supplied for each Subscription: <code>Flux#fromStream(Supplier&lt;Stream&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits from various single-valued sources such as:</p>
<div class="ulist">
<ul>
<li>
<p>a <code>Supplier&lt;T&gt;</code>: <code>Mono#fromSupplier</code></p>
</li>
<li>
<p>a task: <code>Mono#fromCallable</code>, <code>Mono#fromRunnable</code></p>
</li>
<li>
<p>a <code>CompletableFuture&lt;T&gt;</code>: <code>Mono#fromFuture</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that completes: <code>empty</code></p>
</li>
<li>
<p>that errors immediately: <code>error</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily build the <code>Throwable</code>: <code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that never does anything: <code>never</code></p>
</li>
<li>
<p>that is decided at subscription: <code>defer</code></p>
</li>
<li>
<p>that depends on a disposable resource: <code>using</code></p>
</li>
<li>
<p>that generates events programmatically (can use state):</p>
<div class="ulist">
<ul>
<li>
<p>synchronously and one-by-one: <code>Flux#generate</code></p>
</li>
<li>
<p>asynchronously (can also be sync), multiple emissions possible in one pass: <code>Flux#create</code>
(<code>Mono#create</code> as well, without the multiple emission aspect)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.values"><a class="anchor" href="#which.values"></a>A.2. Transforming an Existing Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>I want to transform existing data:</p>
<div class="ulist">
<ul>
<li>
<p>on a 1-to-1 basis (eg. strings to their length): <code>map</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;by just casting it: <code>cast</code></p>
</li>
<li>
<p>&#8230;&#8203;in order to materialize each source value&#8217;s index: <code>Flux#index</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>on a 1-to-n basis (eg. strings to their characters): <code>flatMap</code> + use a factory method</p>
</li>
<li>
<p>on a 1-to-n basis with programmatic behavior for each source element and/or state: <code>handle</code></p>
</li>
<li>
<p>running an asynchronous task for each source item (eg. urls to http request): <code>flatMap</code> + an async <code>Publisher</code>-returning method</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;ignoring some data: conditionally return a <code>Mono.empty()</code> in the flatMap lambda</p>
</li>
<li>
<p>&#8230;&#8203;retaining the original sequence order: <code>Flux#flatMapSequential</code> (this triggers the async processes immediately but reorders the results)</p>
</li>
<li>
<p>&#8230;&#8203;where the async task can return multiple values, from a <code>Mono</code> source: <code>Mono#flatMapMany</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to add pre-set elements to an existing sequence:</p>
<div class="ulist">
<ul>
<li>
<p>at the start: <code>Flux#startWith(T...)</code></p>
</li>
<li>
<p>at the end: <code>Flux#concatWith(T...)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to aggregate a <code>Flux</code>: (the <code>Flux#</code> prefix is assumed below)</p>
<div class="ulist">
<ul>
<li>
<p>into a List: <code>collectList</code>, <code>collectSortedList</code></p>
</li>
<li>
<p>into a Map: <code>collectMap</code>, <code>collectMultiMap</code></p>
</li>
<li>
<p>into an arbitrary container: <code>collect</code></p>
</li>
<li>
<p>into the size of the sequence: <code>count</code></p>
</li>
<li>
<p>by applying a function between each element (eg. running sum): <code>reduce</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but emitting each intermediary value: <code>scan</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>into a boolean value from a predicate:</p>
<div class="ulist">
<ul>
<li>
<p>applied to all values (AND): <code>all</code></p>
</li>
<li>
<p>applied to at least one value (OR): <code>any</code></p>
</li>
<li>
<p>testing the presence of any value: <code>hasElements</code></p>
</li>
<li>
<p>testing the presence of a specific value: <code>hasElement</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to combine publishers&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>in sequential order: <code>Flux#concat</code> or <code>.concatWith(other)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but delaying any error until remaining publishers have been emitted: <code>Flux#concatDelayError</code></p>
</li>
<li>
<p>&#8230;&#8203;but eagerly subscribing to subsequent publishers: <code>Flux#mergeSequential</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>in emission order (combined items emitted as they come): <code>Flux#merge</code> / <code>.mergeWith(other)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with different types (transforming merge): <code>Flux#zip</code> / <code>Flux#zipWith</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by pairing values:</p>
<div class="ulist">
<ul>
<li>
<p>from 2 Monos into a <code>Tuple2</code>: <code>Mono#zipWith</code></p>
</li>
<li>
<p>from n Monos when they all completed: <code>Mono#zip</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by coordinating their termination:</p>
<div class="ulist">
<ul>
<li>
<p>from 1 Mono and any source into a <code>Mono&lt;Void&gt;</code>: <code>Mono#and</code></p>
</li>
<li>
<p>from n sources when they all completed: <code>Mono#when</code></p>
</li>
<li>
<p>into an arbitrary container type:</p>
<div class="ulist">
<ul>
<li>
<p>each time all sides have emitted: <code>Flux#zip</code> (up to the smallest cardinality)</p>
</li>
<li>
<p>each time a new value arrives at either side: <code>Flux#combineLatest</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>only considering the sequence that emits first: <code>Flux#first</code>, <code>Mono#first</code>, <code>mono.or
(otherMono).or(thirdMono)</code>, <code>flux.or(otherFlux).or(thirdFlux)</code></p>
</li>
<li>
<p>triggered by the elements in a source sequence: <code>switchMap</code> (each source element is mapped to a Publisher)</p>
</li>
<li>
<p>triggered by the start of the next publisher in a sequence of publishers: <code>switchOnNext</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to repeat an existing sequence: <code>repeat</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but at time intervals: <code>Flux.interval(duration).flatMap(tick -&gt; myExistingPublisher)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have an empty sequence but&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>I want a value instead: <code>defaultIfEmpty</code></p>
</li>
<li>
<p>I want another sequence instead: <code>switchIfEmpty</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a sequence but I am not interested in values: <code>ignoreElements</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and I want the completion represented as a <code>Mono</code>: <code>then</code></p>
</li>
<li>
<p>&#8230;&#8203;and I want to wait for another task to complete at the end: <code>thenEmpty</code></p>
</li>
<li>
<p>&#8230;&#8203;and I want to switch to another <code>Mono</code> at the end: <code>Mono#then(mono)</code></p>
</li>
<li>
<p>&#8230;&#8203;and I want to emit a single value at the end: <code>Mono#thenReturn(T)</code></p>
</li>
<li>
<p>&#8230;&#8203;and I want to switch to a <code>Flux</code> at the end: <code>thenMany</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a Mono for which I want to defer completion&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;until another publisher, which is derived from this value, has completed: <code>Mono#delayUntil(Function)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to expand elements recursively into a graph of sequences and emit the combination&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;expanding the graph breadth first: <code>expand(Function)</code></p>
</li>
<li>
<p>&#8230;&#8203;expanding the graph depth first: <code>expandDeep(Function)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.peeking"><a class="anchor" href="#which.peeking"></a>A.3. Peeking into a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>Without modifying the final sequence, I want to:</p>
<div class="ulist">
<ul>
<li>
<p>get notified of / execute additional behavior <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> on:</p>
<div class="ulist">
<ul>
<li>
<p>emissions: <code>doOnNext</code></p>
</li>
<li>
<p>completion: <code>Flux#doOnComplete</code>, <code>Mono#doOnSuccess</code> (includes the result if any)</p>
</li>
<li>
<p>error termination: <code>doOnError</code></p>
</li>
<li>
<p>cancellation: <code>doOnCancel</code></p>
</li>
<li>
<p>subscription: <code>doOnSubscribe</code></p>
</li>
<li>
<p>request: <code>doOnRequest</code></p>
</li>
<li>
<p>completion or error: <code>doOnTerminate</code> (Mono version includes the result if any)</p>
<div class="ulist">
<ul>
<li>
<p>but <strong>after</strong> it has been propagated downstream: <code>doAfterTerminate</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>any type of signal, represented as a <code>Signal</code>: <code>Flux#doOnEach</code></p>
</li>
<li>
<p>any terminating condition (complete, error, cancel): <code>doFinally</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>log what happens internally: <code>log</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to know of all events:</p>
<div class="ulist">
<ul>
<li>
<p>each represented as <code>Signal</code> object:</p>
<div class="ulist">
<ul>
<li>
<p>in a callback outside the sequence: <code>doOnEach</code></p>
</li>
<li>
<p>instead of the original onNext emissions: <code>materialize</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and get back to the onNexts: <code>dematerialize</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>as a line in a log: <code>log</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.filtering"><a class="anchor" href="#which.filtering"></a>A.4. Filtering a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>I want to filter a sequence:</p>
<div class="ulist">
<ul>
<li>
<p>based on an arbitrary criteria: <code>filter</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;that is asynchronously computed: <code>filterWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>restricting on the type of the emitted objects: <code>ofType</code></p>
</li>
<li>
<p>by ignoring the values altogether: <code>ignoreElements</code></p>
</li>
<li>
<p>by ignoring duplicates:</p>
<div class="ulist">
<ul>
<li>
<p>in the whole sequence (logical set): <code>Flux#distinct</code></p>
</li>
<li>
<p>between subsequently emitted items (deduplication): <code>Flux#distinctUntilChanged</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to keep only a subset of the sequence:</p>
<div class="ulist">
<ul>
<li>
<p>by taking N elements:</p>
<div class="ulist">
<ul>
<li>
<p>at the beginning of the sequence: <code>Flux#take(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;based on a duration: <code>Flux#take(Duration)</code></p>
</li>
<li>
<p>&#8230;&#8203;only the first element, as a <code>Mono</code>: <code>Flux#next()</code></p>
</li>
<li>
<p>&#8230;&#8203;using <code>request(N)</code> rather than cancellation: <code>Flux#limitRequest(long)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>at the end of the sequence: <code>Flux#takeLast</code></p>
</li>
<li>
<p>until a criteria is met (inclusive): <code>Flux#takeUntil</code> (predicate-based), <code>Flux#takeUntilOther</code> (companion publisher-based)</p>
</li>
<li>
<p>while a criteria is met (exclusive): <code>Flux#takeWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by taking at most 1 element:</p>
<div class="ulist">
<ul>
<li>
<p>at a specific position: <code>Flux#elementAt</code></p>
</li>
<li>
<p>at the end: <code>.takeLast(1)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and emit an error if empty: <code>Flux#last()</code></p>
</li>
<li>
<p>&#8230;&#8203;and emit a default value if empty: <code>Flux#last(T)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>by skipping elements:</p>
<div class="ulist">
<ul>
<li>
<p>at the beginning of the sequence: <code>Flux#skip(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;based on a duration: <code>Flux#skip(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>at the end of the sequence: <code>Flux#skipLast</code></p>
</li>
<li>
<p>until a criteria is met (inclusive): <code>Flux#skipUntil</code> (predicate-based), <code>Flux#skipUntilOther</code> (companion publisher-based)</p>
</li>
<li>
<p>while a criteria is met (exclusive): <code>Flux#skipWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by sampling items:</p>
<div class="ulist">
<ul>
<li>
<p>by duration: <code>Flux#sample(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>but keeping the first element in the sampling window instead of the last: <code>sampleFirst</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a publisher-based window: <code>Flux#sample(Publisher)</code></p>
</li>
<li>
<p>based on a publisher "timing out": <code>Flux#sampleTimeout</code> (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I expect at most 1 element (error if more than one)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>and I want an error if the sequence is empty: <code>Flux#single()</code></p>
</li>
<li>
<p>and I want a default value if the sequence is empty: <code>Flux#single(T)</code></p>
</li>
<li>
<p>and I accept an empty sequence as well: <code>Flux#singleOrEmpty</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.errors"><a class="anchor" href="#which.errors"></a>A.5. Handling Errors</h3>
<div class="ulist">
<ul>
<li>
<p>I want to create an erroring sequence: <code>error</code>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;to replace the completion of a successful <code>Flux</code>: <code>.concat(Flux.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;to replace the <strong>emission</strong> of a successful <code>Mono</code>: <code>.then(Mono.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;if too much time elapses between onNexts: <code>timeout</code></p>
</li>
<li>
<p>&#8230;&#8203;lazily: <code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want the try/catch equivalent of:</p>
<div class="ulist">
<ul>
<li>
<p>throwing: <code>error</code></p>
</li>
<li>
<p>catching an exception:</p>
<div class="ulist">
<ul>
<li>
<p>and falling back to a default value: <code>onErrorReturn</code></p>
</li>
<li>
<p>and falling back to another <code>Flux</code> or <code>Mono</code>: <code>onErrorResume</code></p>
</li>
<li>
<p>and wrapping and re-throwing: <code>.onErrorMap(t -&gt; new RuntimeException(t))</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>the finally block: <code>doFinally</code></p>
</li>
<li>
<p>the using pattern from Java 7: <code>using</code> factory method</p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to recover from errors&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>by falling back:</p>
<div class="ulist">
<ul>
<li>
<p>to a value: <code>onErrorReturn</code></p>
</li>
<li>
<p>to a <code>Publisher</code> or <code>Mono</code>, possibly different ones depending on the error: <code>Flux#onErrorResume</code> and <code>Mono#onErrorResume</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by retrying: <code>retry</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;triggered by a companion control Flux: <code>retryWhen</code></p>
</li>
<li>
<p>&#8230;&#8203; using a standard backoff strategy (exponential backoff with jitter): <code>retryBackoff</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to deal with backpressure "errors"<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>by throwing a special <code>IllegalStateException</code>: <code>Flux#onBackpressureError</code></p>
</li>
<li>
<p>by dropping excess values: <code>Flux#onBackpressureDrop</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;except the last one seen: <code>Flux#onBackpressureLatest</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by buffering excess values (bounded or unbounded): <code>Flux#onBackpressureBuffer</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and applying a strategy when bounded buffer also overflows: <code>Flux#onBackpressureBuffer</code> with a <code>BufferOverflowStrategy</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.time"><a class="anchor" href="#which.time"></a>A.6. Working with Time</h3>
<div class="ulist">
<ul>
<li>
<p>I want to associate emissions with a timing (<code>Tuple2&lt;Long, T&gt;</code>) measured&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>since subscription: <code>elapsed</code></p>
</li>
<li>
<p>since the dawn of time (well, computer time): <code>timestamp</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want my sequence to be interrupted if there is too much delay between emissions: <code>timeout</code></p>
</li>
<li>
<p>I want to get ticks from a clock, regular time intervals: <code>Flux#interval</code></p>
</li>
<li>
<p>I want to emit a single <code>0</code> after an initial delay: static <code>Mono.delay</code>.</p>
</li>
<li>
<p>I want to introduce a delay:</p>
<div class="ulist">
<ul>
<li>
<p>between each onNext signal: <code>Mono#delayElement</code>, <code>Flux#delayElements</code></p>
</li>
<li>
<p>before the subscription happens: <code>delaySubscription</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.window"><a class="anchor" href="#which.window"></a>A.7. Splitting a <code>Flux</code></h3>
<div class="ulist">
<ul>
<li>
<p>I want to split a <code>Flux&lt;T&gt;</code> into a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>, by a boundary criteria:</p>
<div class="ulist">
<ul>
<li>
<p>of size: <code>window(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping windows: <code>window(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>of time <code>window(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping windows: <code>window(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>of size OR time (window closes when count is reached or timeout elapsed): <code>windowTimeout(int, Duration)</code></p>
</li>
<li>
<p>based on a predicate on elements: <code>windowUntil</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;â¦emitting the element that triggered the boundary in the next window (<code>cutBefore</code> variant): <code>.windowUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;keeping the window open while elements match a predicate: <code>windowWhile</code> (non-matching elements are not emitted)</p>
</li>
</ul>
</div>
</li>
<li>
<p>driven by an arbitrary boundary represented by onNexts in a control Publisher: <code>window(Publisher)</code>, <code>windowWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to split a <code>Flux&lt;T&gt;</code> and buffer elements within boundaries together&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>into <code>List</code>:</p>
<div class="ulist">
<ul>
<li>
<p>by a size boundary: <code>buffer(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping buffers: <code>buffer(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a duration boundary: <code>buffer(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping buffers: <code>buffer(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a size OR duration boundary: <code>bufferTimeout(int, Duration)</code></p>
</li>
<li>
<p>by an arbitrary criteria boundary: <code>bufferUntil(Predicate)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;putting the element that triggered the boundary in the next buffer: <code>.bufferUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;buffering while predicate matches and dropping the element that triggered the boundary: <code>bufferWhile(Predicate)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>driven by an arbitrary boundary represented by onNexts in a control Publisher: <code>buffer(Publisher)</code>, <code>bufferWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>into an arbitrary "collection" type <code>C</code>: use variants like <code>buffer(int, Supplier&lt;C&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to split a <code>Flux&lt;T&gt;</code> so that element that share a characteristic end up in the same sub-flux: <code>groupBy(Function&lt;T,K&gt;)</code>
TIP: Note that this returns a <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code>, each inner <code>GroupedFlux</code> shares the same <code>K</code> key accessible through <code>key()</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.blocking"><a class="anchor" href="#which.blocking"></a>A.8. Going Back to the Synchronous World</h3>
<div class="paragraph">
<p>Note: all of these methods except <code>Mono#toFuture</code> will throw an <code>UnsupportedOperatorException</code> if called from
within a <code>Scheduler</code> marked as "non-blocking only" (by default <code>parallel()</code> and <code>single()</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I have a <code>Flux&lt;T&gt;</code> and I want to:</p>
<div class="ulist">
<ul>
<li>
<p>block until I can get the first element: <code>Flux#blockFirst</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <code>Flux#blockFirst(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>block until I can get the last element (or null if empty): <code>Flux#blockLast</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <code>Flux#blockLast(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>synchronously switch to an <code>Iterable&lt;T&gt;</code>: <code>Flux#toIterable</code></p>
</li>
<li>
<p>synchronously switch to a Java 8 <code>Stream&lt;T&gt;</code>: <code>Flux#toStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a <code>Mono&lt;T&gt;</code> and I want:</p>
<div class="ulist">
<ul>
<li>
<p>to block until I can get the value: <code>Mono#block</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <code>Mono#block(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>a <code>CompletableFuture&lt;T&gt;</code>: <code>Mono#toFuture</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.multicasting"><a class="anchor" href="#which.multicasting"></a>A.9. Multicasting a <code>Flux</code> to several <code>Subscribers</code></h3>
<div class="ulist">
<ul>
<li>
<p>I want to connect multiple <code>Subscriber</code> to a <code>Flux</code>:</p>
<div class="ulist">
<ul>
<li>
<p>and decide when to trigger the source with <code>connect()</code>: <code>publish()</code> (returns a <code>ConnectableFlux</code>)</p>
</li>
<li>
<p>and trigger the source immediately (late subscribers see later data): <code>share()</code></p>
</li>
<li>
<p>and permanently connect the source when enough subscribers have registered: <code>.publish().autoConnect(n)</code></p>
</li>
<li>
<p>and automatically connect and cancel the source when subscribers go above/below the threshold: <code>.publish().refCount(n)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but giving a chance for new subscribers to come in before cancelling: <code>.publish().refCountGrace(n, Duration)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to cache data from a <code>Publisher</code> and replay it to later subscribers:</p>
<div class="ulist">
<ul>
<li>
<p>up to <code>n</code> elements: <code>cache(int)</code></p>
</li>
<li>
<p>caching latest elements seen within a <code>Duration</code> (Time-To-Live): <code>cache(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but retain no more than <code>n</code> elements: <code>cache(int, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>but without immediately triggering the source: <code>Flux#replay</code> (returns a <code>ConnectableFlux</code>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-operatorChoice.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#which-operator">Which operator do I need?</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix B: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="faq.wrap-blocking"><a class="anchor" href="#faq.wrap-blocking"></a>B.1. How do I wrap a synchronous, blocking call?</h3>
<div class="paragraph">
<p>It&#8217;s often the case that a source of information is synchronous and blocking.
To deal with such sources in your Reactor applications, apply the following
pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono blockingWrapper = Mono.fromCallable(() -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    return /* make a remote synchronous call */ <i class="conum" data-value="2"></i><b>(2)</b>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.elastic()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>Mono</code> by using <code>fromCallable</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Return the asynchronous, blocking resource.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure each subscription will happen on a dedicated single-threaded worker
from <code>Schedulers.elastic()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You should use a Mono because the source returns one value. You should use
<code>Schedulers.elastic</code> because it creates a dedicated thread to wait for the
blocking resource without tying up some other resource.</p>
</div>
<div class="paragraph">
<p>Note that <code>subscribeOn</code> does not subscribe to the <code>Mono</code>. It specifies what
kind of <code>Scheduler</code> to use when a subscribe call happens.</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.chain"><a class="anchor" href="#faq.chain"></a>B.2. I used an operator on my <code>Flux</code> but it doesn&#8217;t seem to apply. What gives?</h3>
<div class="paragraph">
<p>Make sure that the variable you <code>.subscribe()</code> to has been affected by the
operators you think should have been applied to it.</p>
</div>
<div class="paragraph">
<p>Reactor operators are decorators. They return a different instance that wraps
the source sequence and add behavior. That is why the preferred way of using
operators is to <strong>chain</strong> the calls.</p>
</div>
<div class="paragraph">
<p>Compare the following two examples:</p>
</div>
<div class="listingblock">
<div class="title">without chaining (incorrect)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.just("foo", "chain");
flux.map(secret -&gt; secret.replaceAll(".", "*")); <i class="conum" data-value="1"></i><b>(1)</b>
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The mistake is here. The result isn&#8217;t attached to the <code>flux</code> variable.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">without chaining (correct)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.just("foo", "chain");
flux = flux.map(secret -&gt; secret.replaceAll(".", "*"));
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sample is even better (because it&#8217;s simpler):</p>
</div>
<div class="listingblock">
<div class="title">with chaining (best)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; secrets = Flux
  .just("foo", "chain")
  .map(secret -&gt; secret.replaceAll(".", "*"))
  .subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first version will output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Received: foo
Received: chain</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whereas the two other versions will output the expected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Received: ***
Received: *****</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.monoThen"><a class="anchor" href="#faq.monoThen"></a>B.3. My <code>Mono</code> <code>zipWith</code>/<code>zipWhen</code> is never called</h3>
<div class="listingblock">
<div class="title">example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">myMethod.process("a") // this method returns Mono&lt;Void&gt;
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the source <code>Mono</code> is either <code>empty</code> or a <code>Mono&lt;Void&gt;</code> (a <code>Mono&lt;Void&gt;</code> is
empty for all intents and purposes), some combinations will never be called.</p>
</div>
<div class="paragraph">
<p>This is the typical case for any transformer like the <code>zip</code> static method or
<code>zipWith</code>/<code>zipWhen</code> operators, which by definition need an element from each
source to produce their output.</p>
</div>
<div class="paragraph">
<p>Using data-suppressing operators on sources of <code>zip</code> is thus problematic.
Examples of data-suppressing operators include <code>then()</code>, <code>thenEmpty(Publisher&lt;Void&gt;)</code>,
<code>ignoreElements()</code> and <code>ignoreElement()</code>, <code>when(Publisher...)</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, operators that use a <code>Function&lt;T,?&gt;</code> to tune their behavior, like <code>flatMap</code>,
do need at least one element to be emitted for the <code>Function</code> to have a chance
to apply. Applying these on an empty (or <code>&lt;Void&gt;</code>) sequence will never produce an element.</p>
</div>
<div class="paragraph">
<p>You can use <code>.defaultIfEmpty(T)</code> and <code>.switchIfEmpty(Publisher&lt;T&gt;)</code> to respectively
replace an <strong>empty</strong> sequence of <code>T</code> with a default value or a fallback <code>Publisher&lt;T&gt;</code>,
which could help avoid some of these situations. Note that this doesn&#8217;t apply to
<code>Flux&lt;Void&gt;</code>/<code>Mono&lt;Void&gt;</code> sources, as you can only switch to another <code>Publisher&lt;Void&gt;</code>,
which is still guaranteed to be empty. Here&#8217;s an example of <code>defaultIfEmpty</code>:</p>
</div>
<div class="listingblock">
<div class="title">use <code>defaultIfEmpty</code> before <code>zipWhen</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">myMethod.emptySequenceForKey("a") // this method returns empty Mono&lt;String&gt;
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -&gt; myMethod.process("b")) //this is called with the empty String
        .subscribe();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.retryWhen"><a class="anchor" href="#faq.retryWhen"></a>B.4. How to use <code>retryWhen</code> to emulate <code>retry(3)</code>?</h3>
<div class="paragraph">
<p>The <code>retryWhen</code> operator can be quite complex. Hopefully this snippet of code
can help you understand how it works by attempting to emulate a simpler
<code>retry(3)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalArgumentException())
    .retryWhen(companion -&gt; companion
    .zipWith(Flux.range(1, 4), <i class="conum" data-value="1"></i><b>(1)</b>
          (error, index) -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            if (index &lt; 4) return index; <i class="conum" data-value="3"></i><b>(3)</b>
            else throw Exceptions.propagate(error); <i class="conum" data-value="4"></i><b>(4)</b>
          })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Trick one: use <code>zip</code> and a <code>range</code> of "number of acceptable retries + 1".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>zip</code> function lets you count the retries while keeping track of the original
error.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, indexes before 4 return a value to emit.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="faq.exponentialBackoff"><a class="anchor" href="#faq.exponentialBackoff"></a>B.5. How to use <code>retryWhen</code> for exponential backoff?</h3>
<div class="paragraph">
<p>Exponential backoff produces retry attempts with a growing delay between each
of the attempts, so as not to overload the source systems and risk an all out
crash. The rationale is that if the source produces an error, it is already in
an unstable state and not likely to immediately recover from it. So blindly
retrying immediately is likely to produce yet another error and add to the
instability.</p>
</div>
<div class="paragraph">
<p>Since <code>3.2.0.RELEASE</code>, Reactor comes with such a retry baked in: <code>Flux.retryBackoff</code>.</p>
</div>
<div class="paragraph">
<p>For the curious, here is how to implement an exponential backoff with <code>retryWhen</code>
that delays retries and increase the delay between each attempt (pseudocode:
delay = attempt number * 100 milliseconds):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalArgumentException())
    .retryWhen(companion -&gt; companion
        .doOnNext(s -&gt; System.out.println(s + " at " + LocalTime.now())) <i class="conum" data-value="1"></i><b>(1)</b>
        .zipWith(Flux.range(1, 4), (error, index) -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
          if (index &lt; 4) return index;
          else throw Exceptions.propagate(error);
        })
        .flatMap(index -&gt; Mono.delay(Duration.ofMillis(index * 100))) <i class="conum" data-value="3"></i><b>(3)</b>
        .doOnNext(s -&gt; System.out.println("retried at " + LocalTime.now())) <i class="conum" data-value="4"></i><b>(4)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We log the time of errors.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use the <code>retryWhen</code> + <code>zipWith</code> trick to propagate the error after 3
retries.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Through <code>flatMap</code>, we cause a delay that depends on the attempt&#8217;s index.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We also log the time at which the retry happens.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When subscribed to, this fails and terminates after printing out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException at 18:02:29.338
retried at 18:02:29.459 <i class="conum" data-value="1"></i><b>(1)</b>
java.lang.IllegalArgumentException at 18:02:29.460
retried at 18:02:29.663 <i class="conum" data-value="2"></i><b>(2)</b>
java.lang.IllegalArgumentException at 18:02:29.663
retried at 18:02:29.964 <i class="conum" data-value="3"></i><b>(3)</b>
java.lang.IllegalArgumentException at 18:02:29.964</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>first retry after about 100ms</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>second retry after about 200ms</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>third retry after about 300ms</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_how_do_i_ensure_thread_affinity_using_publishon"><a class="anchor" href="#_how_do_i_ensure_thread_affinity_using_publishon"></a>B.6. How do I ensure thread affinity using <code>publishOn()</code>?</h3>
<div class="paragraph">
<p>As described in <a href="#schedulers">Schedulers</a>, <code>publishOn()</code> can be used to switch
execution contexts. The <code>publishOn</code> operator influences the threading context
where the rest of the operators in the chain below it will execute, up to a new
occurrence of <code>publishOn</code>. So the placement of <code>publishOn</code> is significant.</p>
</div>
<div class="paragraph">
<p>For instance, in the example below, the <code>transform</code> function in <code>map()</code> is
executed on a worker of <code>scheduler1</code> and the <code>processNext</code> method in
<code>doOnNext()</code> is executed on a worker of <code>scheduler2</code>. Each <strong>subscription</strong> gets
its own worker, so all elements pushed to the corresponding subscriber are published
on the same <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>Single threaded schedulers may be used to ensure thread affinity for different stages in the
chain or for different subscribers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EmitterProcessor&lt;Integer&gt; processor = EmitterProcessor.create();
processor.publishOn(scheduler1)
         .map(i -&gt; transform(i))
         .publishOn(scheduler2)
         .doOnNext(i -&gt; processNext(i))
         .subscribe();</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/faq.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#faq">FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-extra"><a class="anchor" href="#reactor-extra"></a>Appendix C: Reactor-Extra</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>reactor-extra</code> artifact contains additional operators and utilities that are for
users of <code>reactor-core</code> with advanced needs.</p>
</div>
<div class="paragraph">
<p>As this is a separate artifact, you need to explicitly add it to your build:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
     compile 'io.projectreactor:reactor-core'
     compile 'io.projectreactor.addons:reactor-extra' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add the reactor extra artifact in addition to core. See <a href="#getting">Getting Reactor</a> for details
about why you don&#8217;t need to specify a version if you use the BOM, usage in Maven, etc&#8230;&#8203;</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="extra-tuples"><a class="anchor" href="#extra-tuples"></a>C.1. <code>TupleUtils</code> and Functional Interfaces</h3>
<div class="paragraph">
<p>The <code>reactor.function</code> package contains functional interfaces that complement the Java 8
<code>Function</code>, <code>Predicate</code> and <code>Consumer</code> interfaces, for 3 to 8 values.</p>
</div>
<div class="paragraph">
<p><code>TupleUtils</code> offers static methods that act as a bridge between lambdas of these functional
interfaces to a similar interface on the corresponding <code>Tuple</code>.</p>
</div>
<div class="paragraph">
<p>This allows to easily work with independent parts of any <code>Tuple</code>, for instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.map(tuple -&gt; {
  String firstName = tuple.getT1();
  String lastName = tuple.getT2();
  String address = tuple.getT3();

  return new Customer(firstName, lastName, address);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Can be instead written as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.map(TupleUtils.function(Customer::new)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(as <code>Customer</code> constructor conforms to <code>Consumer3</code> functional interface signature)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extra-math"><a class="anchor" href="#extra-math"></a>C.2. Math Operators With <code>MathFlux</code></h3>
<div class="paragraph">
<p>The <code>reactor.math</code> package contains a <code>MathFlux</code> specialized version of <code>Flux</code> that offers
mathematical operators, like <code>max</code>, <code>min</code>, <code>sumInt</code>, <code>averageDouble</code>&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-repeat-retry"><a class="anchor" href="#extra-repeat-retry"></a>C.3. Repeat and Retry Utilities</h3>
<div class="paragraph">
<p>The <code>reactor.retry</code> package contains utilities to help in writing <code>Flux#repeatWhen</code> and
<code>Flux#retryWhen</code> functions. The entry points are factory methods in respectively <code>Repeat</code>
and <code>Retry</code> interfaces.</p>
</div>
<div class="paragraph">
<p>Both interfaces can be used as a mutative builder AND are implementing the correct
<code>Function</code> signature to be used in their counterpart operators.</p>
</div>
<div class="paragraph">
<p>Since 3.2.0, one of the most advanced retry strategies offered by these utilities is
also part of the <code>reactor-core</code> main artifact directly: exponential backoff is
available as the <code>Flux#retryBackoff</code> operator.</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-schedulers"><a class="anchor" href="#extra-schedulers"></a>C.4. Schedulers</h3>
<div class="paragraph">
<p>Reactor-extra comes with several specialized schedulers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForkJoinPoolScheduler</code> in package <code>reactor.scheduler.forkjoin</code>: uses the Java <code>ForkJoinPool</code> to execute tasks.</p>
</li>
<li>
<p><code>SwingScheduler</code> in package <code>reactor.swing</code> executes tasks in the Swing UI event loop thread, the <code>EDT</code>.</p>
</li>
<li>
<p><code>SwtScheduler</code> in package <code>reactor.swing</code> executes tasks in the SWT UI event loop thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-reactorExtra.adoc">Suggest Edit, title="Suggest an edit to the above section via github", role="fa fa-edit"</a>
to "<a href="#reactor-extra">Reactor-Extra</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. sometimes referred to as "side-effects"
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. request max from upstream and apply the strategy when downstream does not produce enough request
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-05-06 08:20:00 UTC
</div>
</div>
<link rel="stylesheet" href="./highlight/styles/railscasts.min.css">
<script src="./highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>