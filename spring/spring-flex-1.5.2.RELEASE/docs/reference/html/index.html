<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring BlazeDS Integration Reference Guide</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Spring BlazeDS Integration Reference Guide</h1></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Jeremy</span> <span class="surname">Grelle</span> 
            (SpringSource)
            </span></div></div><div><p class="releaseinfo">Version 1.5.2.RELEASE</p></div><div><div class="legalnotice"><a name="d0e21"></a><p>
                Copies of this document may be made for your own use and for
                distribution to others, provided that you do not charge any
                fee for such copies and further provided that each copy
                contains this Copyright Notice, whether distributed in print
                or electronically.
            </p></div></div><div><p class="pubdate">November 2011</p></div></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#introduction">1. Spring BlazeDS Integration Overview</a></span></dt><dd><dl><dt><span class="sect1"><a href="#intro-background">1.1. Background</a></span></dt><dt><span class="sect1"><a href="#system-requirements">1.2. Minimum major dependency versions Spring BlazeDS Integration 1.5 requires to run</a></span></dt><dt><span class="sect1"><a href="#optional-system-requirements">1.3. Minimum major dependency versions required by optional features</a></span></dt><dt><span class="sect1"><a href="#support">1.4. Where to get support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">2. Configuring and Using the BlazeDS MessageBroker with Spring</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-introduction">2.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#configuration-dispatcherservlet">2.2. Configuring the Spring DispatcherServlet</a></span></dt><dt><span class="sect1"><a href="#configuration-messagebroker">2.3. Configuring the MessageBroker in Spring</a></span></dt><dt><span class="sect1"><a href="#configuration-mapping">2.4. Mapping Requests to the MessageBroker</a></span></dt><dt><span class="sect1"><a href="#flex-and-spring-mvc">2.5. Using Flex clients alongside Spring MVC Controllers</a></span></dt><dt><span class="sect1"><a href="#client-side-remoting">2.6. Using Spring-managed Destinations from the Flex Client</a></span></dt><dt><span class="sect1"><a href="#config-processors">2.7. Advanced MessageBroker Customization</a></span></dt><dt><span class="sect1"><a href="#exception-translators">2.8. Using Custom Exception Translators</a></span></dt><dt><span class="sect1"><a href="#message-interceptors">2.9. Using Custom Message Interceptors</a></span></dt><dd><dl><dt><span class="sect2"><a href="#resource-handling-message-interceptors">2.9.1. Resource Handling with Custom Message Interceptors</a></span></dt><dt><span class="sect2"><a href="#message-interception-order">2.9.2. Customizing the Message Interceptor Chain</a></span></dt></dl></dd><dt><span class="sect1"><a href="#service-adapters">2.10. Providing Custom Service Adapters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#remoting">3. Exporting Spring Beans for Flex Remoting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#remoting-introduction">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#remoting-service-config">3.2. Configuring the Remoting Service</a></span></dt><dt><span class="sect1"><a href="#remoting-destination">3.3. Using the <code class="code">remoting-destination</code> Tag</a></span></dt><dt><span class="sect1"><a href="#remoting-destination-annotation">3.4. Exporting Beans for Remoting with @RemotingDestination</a></span></dt><dd><dl><dt><span class="sect2"><a href="#dynamic-remoting-destination-channels">3.4.1. Supplying Externalized Channel Ids</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#amf-rest">4. Communicating with RESTful Spring MVC Endpoints using AMF</a></span></dt><dd><dl><dt><span class="sect1"><a href="#rest-introduction">4.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#amf-rest-view">4.2. Using AmfView</a></span></dt><dt><span class="sect1"><a href="#amf-rest-converter">4.3. Using AmfHttpMessageConverter</a></span></dt><dt><span class="sect1"><a href="#amf-rest-client">4.4. Interacting with RESTful AMF Endpoints from the Flex Client</a></span></dt></dl></dd><dt><span class="chapter"><a href="#amf">5. Enhanced AMF Support</a></span></dt><dd><dl><dt><span class="sect1"><a href="#amf-introduction">5.1. Customizing AMF Conversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#amf-config-processor">5.1.1. Configuring AMF Type Conversion</a></span></dt><dd><dl><dt><span class="sect3"><a href="#field-mapping">5.1.1.1. Using Direct Field Mapping</a></span></dt><dt><span class="sect3"><a href="#amf-creator-mapping">5.1.1.2. Deserializing Immutable Objects with @AmfCreator</a></span></dt><dt><span class="sect3"><a href="#amf-ignoring-properties">5.1.1.3. Ignoring Properties During AMF Conversion</a></span></dt><dt><span class="sect3"><a href="#amf-custom-converters">5.1.1.4. Providing Custom Converters</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#hibernate-introduction">5.2. Working with Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#hibernate-io-config">5.2.1. Configuring Hibernate Entity Serialization/Deserialization Support</a></span></dt></dl></dd><dt><span class="sect1"><a href="#amf-classpath-scanning">5.3. Using Classpath Scanning for AMF Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#security">6. Securing BlazeDS Destinations with Spring Security</a></span></dt><dd><dl><dt><span class="sect1"><a href="#security-introduction">6.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#spring-security-config">6.1.1. A simple Spring Security 3 configuration</a></span></dt><dt><span class="sect2"><a href="#security-filter-config">6.1.2. Enabling the Spring Security filter chain in web.xml</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuring-security">6.2. Configuring the Spring Security Integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-login-command">6.2.1. Using a Custom LoginCommand</a></span></dt><dt><span class="sect2"><a href="#accessing-user-details">6.2.2. Accessing User Details</a></span></dt><dt><span class="sect2"><a href="#security-exception-translation">6.2.3. Security Exception Translation</a></span></dt><dt><span class="sect2"><a href="#secured-tag-attributes">6.2.4. <code class="code">secured</code> Configuration Attributes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#endpoint-security">6.3. Configuring Endpoint and Destination Security</a></span></dt><dd><dl><dt><span class="sect2"><a href="#secured-channel">6.3.1. Securing Specific BlazeDS Channels</a></span></dt><dt><span class="sect2"><a href="#secured-endpoint-path">6.3.2. Securing BlazeDS Channels by Endpoint URL Path</a></span></dt><dt><span class="sect2"><a href="#securing-destinations">6.3.3. Securing Exported Spring Services</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#messaging">7. Integration with the BlazeDS Message Service</a></span></dt><dd><dl><dt><span class="sect1"><a href="#messaging-introduction">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#message-service-config">7.2. Configuring the Message Service</a></span></dt><dt><span class="sect1"><a href="#actionscript-messaging">7.3. Using AMF Message Destinations</a></span></dt><dt><span class="sect1"><a href="#jms-messaging">7.4. Using JMS Message Destinations</a></span></dt><dt><span class="sect1"><a href="#integration-messaging">7.5. Using Spring Integration Message Destinations</a></span></dt><dt><span class="sect1"><a href="#message-template">7.6. Sending AMF Messages with the MessageTemplate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#samples">8. Building and Running the Spring BlazeDS Integration Samples</a></span></dt><dd><dl><dt><span class="sect1"><a href="#samples-introduction">8.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#building-with-maven">8.1.1. Maven Setup</a></span></dt><dt><span class="sect2"><a href="#samples-build">8.1.2. Building and Running the Test Drive</a></span></dt><dt><span class="sect2"><a href="#blazeds-4-maven">8.1.3. Using BlazeDS 4 with Maven</a></span></dt><dt><span class="sect2"><a href="#pre-built-samples">8.1.4. Download the Pre-packaged Test Drive</a></span></dt><dt><span class="sect2"><a href="#samples-eclipse">8.1.5. Importing and Running the Test Drive in Eclipse</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Spring BlazeDS Integration Overview</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro-background"></a>1.1.&nbsp;Background</h2></div></div></div><p>
            Spring has always aimed to be agnostic to the client technologies being used to access its core services, intentionally leaving options open and letting
            the community drive the demand for any new first-class integration solutions to be added to the Spring project portfolio.  Spring BlazeDS Integration
            is an answer to the commmunity demand for a top-level solution for building Spring-powered Rich Internet Applications using Adobe Flex for the client-side 
            technology.         
        </p><p>
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.adobe.com/wiki/display/blazeds/BlazeDS/" target="_top">BlazeDS</a> is an open source project from Adobe that provides the remoting and 
            messaging foundation for connecting a Flex-based front-end to Java back-end services.  Though it has previously been possible to use BlazeDS to connect to 
            Spring-managed services, it has not been in a way that feels "natural" to a Spring developer, requiring the extra burden of having to maintain a separate 
            BlazeDS xml configuration.  Spring BlazeDS Integration turns the tables by making the BlazeDS MessageBroker a Spring-managed object, opening up the pathways
            to a more extensive integration that follows "the Spring way".   
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="system-requirements"></a>1.2.&nbsp;Minimum major dependency versions Spring BlazeDS Integration 1.5 requires to run</h2></div></div></div><p>
            Java 5
        </p><p>
            Spring 3.0
        </p><p>
            Adobe BlazeDS 4.0
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optional-system-requirements"></a>1.3.&nbsp;Minimum major dependency versions required by optional features</h2></div></div></div><p>
            Spring Security 3.0
        </p><p>
            Spring Integration 2.0
        </p><p>
            Hibernate 3.5
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="support"></a>1.4.&nbsp;Where to get support</h2></div></div></div><p>
            Professional from-the-source support on Spring BlazeDS Integration is available from
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springsource.com" target="_top">SpringSource</a>, the company behind Spring.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;2.&nbsp;Configuring and Using the BlazeDS MessageBroker with Spring</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-introduction"></a>2.1.&nbsp;Introduction</h2></div></div></div><p>
            The central component that must be configured to use Spring BlazeDS Integration is the <code class="code">MessageBroker</code>.  HTTP messages from the Flex client
            will be routed through the Spring <code class="code">DispatcherServlet</code> to the Spring-managed <code class="code">MessageBroker</code>.  There is no need to configure the 
            BlazeDS <code class="code">MessageBrokerServlet</code> when using the Spring-managed <code class="code">MessageBroker</code>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-dispatcherservlet"></a>2.2.&nbsp;Configuring the Spring DispatcherServlet</h2></div></div></div><p>
            The <code class="code">DispatcherServlet</code> must be configured as normal in web.xml to bootstrap a Spring WebApplicationContext. For example:
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- The front controller of this Spring Web application, responsible for handling all application 
requests --</span>&gt;
&lt;<span class="hl-tag">servlet</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;Spring MVC Dispatcher Servlet&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">servlet-class</span>&gt;org.springframework.web.servlet.DispatcherServlet&lt;<span class="hl-tag">/servlet-class</span>&gt;
    &lt;<span class="hl-tag">init-param</span>&gt;
        &lt;<span class="hl-tag">param-name</span>&gt;contextConfigLocation&lt;<span class="hl-tag">/param-name</span>&gt;
        &lt;<span class="hl-tag">param-value</span>&gt;/WEB-INF/config/web-application-config.xml&lt;<span class="hl-tag">/param-value</span>&gt;
    &lt;<span class="hl-tag">/init-param</span>&gt;
    &lt;<span class="hl-tag">load-on-startup</span>&gt;1&lt;<span class="hl-tag">/load-on-startup</span>&gt;
&lt;<span class="hl-tag">/servlet</span>&gt;
        </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-messagebroker"></a>2.3.&nbsp;Configuring the MessageBroker in Spring</h2></div></div></div><p>
            A simplified Spring XML config namespace is provided for configuring the MessageBroker in your WebApplicationContext. To use the 
            namespace support you must add the schema location in your Spring XML config files.  A typical config will look something like
            the following:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:flex</span>=<span class="hl-value">"http://www.springframework.org/schema/flex"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/flex 
           http://www.springframework.org/schema/flex/spring-flex-1.0.xsd"</span>&gt;
...
&lt;<span class="hl-tag">/beans</span>&gt;
         
        </pre><p>
            This makes the Spring BlazeDS Integration configuration tags available under the <code class="code">flex</code> namespace in your configuration files.  The above setup will
            be assumed for the rest of the configuration examples to follow.  For the full detail of every attribute and tag available in the config namespace, be sure
            to refer to the spring-flex-1.0.xsd as every element and attribute is fully documented there.  Using an XSD-aware XML editor such as the one in Eclipse
            should bring up the documentation automatically as you type.
        </p><p>
            At a minimum, the <code class="code">MessageBrokerFactoryBean</code> must be configured as a bean in your Spring WebApplicationContext in order to bootstrap the <code class="code">MessageBroker</code>,
            along with a <code class="code">MessageBrokerHandlerAdapter</code> and an appropriate <code class="code">HandlerMapping</code> (usually a <code class="code">SimpleUrlHandlerMapping</code>) to route incoming
            requests to the Spring-managed <code class="code">MessageBroker</code>.
        </p><p> 
            These beans will be registered automatically by using the provided <code class="code">message-broker</code> tag in your bean
            definition file.  For example, in its simplest form:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>/&gt;       
        </pre><p>
            This will set up the <code class="code">MessageBroker</code> and necessary supporting infrastructure using sensible defaults.  The defaults can be
            overriden using the provided attributes of the <code class="code">message-broker</code> tag and its associated child elements.  For example, the
            default location of the BlazeDS XML configuration file (/WEB-INF/flex/services-config.xml) can be overridden using the 
            <code class="code">services-config-path</code> attribute.  The <code class="code">MessageBrokerFactoryBean</code> uses Spring's <code class="code">ResourceLoader</code> abstraction,
            so that typical Spring resource paths may be used.  For example, to load the configuration from the application's classpath: 
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span> <span class="hl-attribute">services-config-path</span>=<span class="hl-value">"classpath*:services-config.xml"</span>       
        </pre><p>
            The equivalent <code class="code">MessageBrokerFactoryBean</code> definition using vanilla Spring configuration would be:
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Bootstraps and exposes the BlazeDS MessageBroker --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"_messageBroker"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.core.MessageBrokerFactoryBean"</span> &gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"servicesConfigPath"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath*:services-config.xml"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;      
        </pre><p>
            Note especially that with the <code class="code">message-broker</code> tag, it is not necessary to assign a custom id to the MessageBroker, and it
            is in fact discouraged so that you won't have to continually reference it later.  The only reason you would ever need to provide a custom
            id is if you were bootstrapping more than one <code class="code">MessageBroker</code> in the same WebApplicationContext.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-mapping"></a>2.4.&nbsp;Mapping Requests to the MessageBroker</h2></div></div></div><p>To properly route incoming requests to the Spring-managed <code class="code">MessageBroker</code>, request mapping must be configured in three places:</p><div class="orderedlist"><ol type="1"><li><p><code class="code">DispatcherServlet</code> mapping in web.xml</p></li><li><p><code class="code">HandlerMapping</code> in the Spring WebApplicationContext</p></li><li><p>Channel definitions in the BlazeDS services-config.xml</p></li></ol></div><p>
            The simplest request mapping scenario is when the Flex front-end is the only client type for the application.  In this case you can just map /messagebroker as the top-level
            path for requests.  The mapping in web.xml would be:
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Map all /messagbroker requests to the DispatcherServlet for handling --</span>&gt;
&lt;<span class="hl-tag">servlet-mapping</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;Spring MVC Dispatcher Servlet&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">url-pattern</span>&gt;/messagebroker/*&lt;<span class="hl-tag">/url-pattern</span>&gt;
&lt;<span class="hl-tag">/servlet-mapping</span>&gt;    
        </pre><p> 
            When using the <code class="code">message-broker</code> config tag, a <code class="code">SimpleUrlHandlerMapping</code> is installed that by default maps all 
            incoming <code class="code">DispatcherServlet</code> requests to the Spring-managed <code class="code">MessageBroker</code> using a <code class="code">/*</code>path pattern.  
            The default mapping can be overridden by providing one or more <code class="code">mapping</code> child elements.  If you want to provide your own
            <code class="code">HandlerMapping</code> bean configuration, you can disable the default using the <code class="code">disable-default-mapping</code> attribute 
            of the <code class="code">message-broker</code> tag.  The order of the installed <code class="code">SimpleUrlHandlerMapping</code> can be set (for complex 
            scenarios where multiple handler mapping types are installed in the same context) using the <code class="code">mapping-order</code> attribute.
        </p><p>
            The <code class="code">SimpleUrlHandlerMapping</code> in the Spring WebApplicationContext maps all requests to the Spring-managed <code class="code">MessageBroker</code> via 
            the <code class="code">MessageBrokerHandlerAdapter</code>.  The default setup installed by the <code class="code">message-broker</code> config tag is equivalent to the
            following bean definitions:
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Maps request paths at /* to the BlazeDS MessageBroker --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mappings"</span>&gt;
        &lt;<span class="hl-tag">value</span>&gt;
            /*=_messageBroker
        &lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-comment">!-- Dispatches requests mapped to a MessageBroker --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.servlet.MessageBrokerHandlerAdapter"</span>/&gt;    
        </pre><p>
            Channel definitions in the BlazeDS services-config.xml must correspond to the chosen mapping.  For example, to set up a typical AMF channel in 
            BlazeDS that matches the above mapping strategy:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">channel-definition</span> <span class="hl-attribute">id</span>=<span class="hl-value">"my-amf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"mx.messaging.channels.AMFChannel"</span>&gt;
    &lt;<span class="hl-tag">endpoint</span> <span class="hl-attribute">url</span>=<span class="hl-value">"http://{server.name}:{server.port}/{context.root}/messagebroker/amf"</span> 
        <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.endpoints.AMFEndpoint"</span>/&gt;
    &lt;<span class="hl-tag">properties</span>&gt;
        &lt;<span class="hl-tag">polling-enabled</span>&gt;false&lt;<span class="hl-tag">/polling-enabled</span>&gt;
    &lt;<span class="hl-tag">/properties</span>&gt;
&lt;<span class="hl-tag">/channel-definition</span>&gt;        
        </pre><p>
            See the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://livedocs.adobe.com/blazeds/1/blazeds_devguide/" target="_top">BlazeDS documentation</a> for more information on configuring communication 
            channels in services-config.xml.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="flex-and-spring-mvc"></a>2.5.&nbsp;Using Flex clients alongside Spring MVC Controllers</h2></div></div></div><p>
            It could often be the case that your application needs to serve more than just Flex-based clients.  For example, you may be constructing a RESTful architecture
            that is meant to serve multiple client-types.  You could potentially even be consuming RESTful endpoints using the Flex HTTPService component.  Spring MVC's controller 
            model provides a simple, flexible means to create such RESTful endpoints. In these sorts of hybrid web application secenarios, 
            you will need to consider an alternate mapping strategy.  
        </p><p>
            The simplest approach is to use a hierarchical application context with multiple <code class="code">DispatcherServlets</code>.  In this approach, you configure
            your main application layer (services, security, supporting infrastructure, etc) in a parent context loaded via the <code class="code">ContextLoaderListener</code>, and then
            configure all aspects of your Spring MVC controllers in one child <code class="code">DispatcherServlet</code> context, and all aspects specific to your Flex client in a separate 
            child <code class="code">DispatcherServlet</code> context.  This approach could look as follows in web.xml:     
        </p><pre class="programlisting">
&lt;<span class="hl-tag">context-param</span>&gt;
    &lt;<span class="hl-tag">param-name</span>&gt;contextConfigLocation&lt;<span class="hl-tag">/param-name</span>&gt;
    &lt;<span class="hl-tag">param-value</span>&gt;
        /WEB-INF/spring/*-context.xml
    &lt;<span class="hl-tag">/param-value</span>&gt;
&lt;<span class="hl-tag">/context-param</span>&gt;

&lt;<span class="hl-tag">listener</span>&gt;
    &lt;<span class="hl-tag">listener-class</span>&gt;org.springframework.web.context.ContextLoaderListener&lt;<span class="hl-tag">/listener-class</span>&gt;
&lt;<span class="hl-tag">/listener</span>&gt;

&lt;<span class="hl-tag">servlet</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;flex&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">servlet-class</span>&gt;org.springframework.web.servlet.DispatcherServlet&lt;<span class="hl-tag">/servlet-class</span>&gt;
    &lt;<span class="hl-tag">load-on-startup</span>&gt;1&lt;<span class="hl-tag">/load-on-startup</span>&gt;
&lt;<span class="hl-tag">/servlet</span>&gt;

&lt;<span class="hl-tag">servlet-mapping</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;flex&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">url-pattern</span>&gt;/messagebroker/*&lt;<span class="hl-tag">/url-pattern</span>&gt;
&lt;<span class="hl-tag">/servlet-mapping</span>&gt;

&lt;<span class="hl-tag">servlet</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;spring-mvc&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">servlet-class</span>&gt;org.springframework.web.servlet.DispatcherServlet&lt;<span class="hl-tag">/servlet-class</span>&gt;
    &lt;<span class="hl-tag">load-on-startup</span>&gt;1&lt;<span class="hl-tag">/load-on-startup</span>&gt;
&lt;<span class="hl-tag">/servlet</span>&gt;

&lt;<span class="hl-tag">servlet-mapping</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;spring-mvc&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">url-pattern</span>&gt;/spring/*&lt;<span class="hl-tag">/url-pattern</span>&gt;
&lt;<span class="hl-tag">/servlet-mapping</span>&gt;       
        </pre><p>
            Here the parent application context is being assembled from a group of files ending in <code class="code">-context.xml</code> contained in the <code class="code">/WEB-INF/spring/</code> directory.  The child 
            context for the Flex-specific setup would be built (by convention) from <code class="code">/WEB-INF/flex-servlet.xml</code>, and the context for the Spring MVC controllers would be built from <code class="code">/WEB-INF/spring-mvc-servlet.xml</code>.  
            This approach provides a nice separation of concerns and will allow Spring 2.5+ annotated controllers to work using their default configuration.
        </p><p>
            An alternate approach is to keep things consolidated under one <code class="code">DispatcherServlet</code> context.  The down-side to this approach is that it requires some additional manual configuration, and you 
            have to modify your mapping approach accordingly, such as mapping <code class="code">/spring/*</code> to the <code class="code">DispatcherServlet</code>, mapping <code class="code">/messagebroker/*</code>
            to the Spring-managed <code class="code">MessageBroker</code> via the <code class="code">mapping</code> XML namespace config tag, and modifying any BlazeDS channel definitions accordingly.  You would override the default mapping strategy
            of the <code class="code">message-broker</code> tag as follows:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:mapping</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/messagebroker/*"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;       
        </pre><p>
            and you would have to account for the /spring/* mapping in your BlazeDS channel definitions.  For example:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">channel-definition</span> <span class="hl-attribute">id</span>=<span class="hl-value">"my-amf"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"mx.messaging.channels.AMFChannel"</span>&gt;
    &lt;<span class="hl-tag">endpoint</span> <span class="hl-attribute">url</span>=<span class="hl-value">"http://{server.name}:{server.port}/{context.root}/spring/messagebroker/amf"</span> 
        <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.endpoints.AMFEndpoint"</span>/&gt;
    &lt;<span class="hl-tag">properties</span>&gt;
        &lt;<span class="hl-tag">polling-enabled</span>&gt;false&lt;<span class="hl-tag">/polling-enabled</span>&gt;
    &lt;<span class="hl-tag">/properties</span>&gt;
&lt;<span class="hl-tag">/channel-definition</span>&gt;        
        </pre><p>
            In addition to setting up the consolidated mapping strategy, you will also have to manually enable the correct <code class="code">HandlerMapping</code> and <code class="code">HandlerAdapter</code> for your Spring MVC controllers 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/mvc.html#mvc-ann-setup" target="_top">as described in the Spring MVC documentation</a>, due to the fact that alternate <code class="code">HandlerMapping</code> and 
            <code class="code">HandlerAdapter</code> beans are configured automatically when using the <code class="code">message-broker</code> tag.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="client-side-remoting"></a>2.6.&nbsp;Using Spring-managed Destinations from the Flex Client</h2></div></div></div><p>
            Explicit channel definition is a requirement when using dynamic destinations (meaning any destination that is added programmatically and not defined in the BlazeDS 
            services-config.xml, i.e. the destinations created by the <code class="code">remoting-destination</code> tag and the various <code class="code">*-message-destination</code> tags).  See 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://livedocs.adobe.com/blazeds/1/blazeds_devguide/runtimeconfig_5.html#194376" target="_top">Adobe's documentation</a> for more detail.
        </p><p>
            The only way you don't have to explicitly define the ChannelSet on the client is if
        </p><div class="orderedlist"><ol type="1"><li><p>you are using explicitly defined destinations in services-config.xml (i.e, not dynamic destinations) AND you compile your flex client against that file</p></li><li><p>your destination is using the application-wide default channel AND you compile your flex client against that file</p></li></ol></div><p>
            Even if you weren't using dynamically created destinations it is debatable whether it is a good idea to ever compile your client against services-config.xml, 
            thus coupling your client to your server configuration. It is often desirable to keep your flex client and your server side code as two distinct modules, 
            but compiling against services-config.xml blurs the lines between those modules.
        </p><p>
            Our recommendation is that it is generally cleaner to keep the client-side configuration of ChannelSets explicitly contained within the client module. 
            An excellent way to do this without having to hard-code the URLs in your client code is to use an ActionScript DI framework such as Spring 
            ActionScript (a Spring Extensions project, formerly known as Prana).
        </p><p>
            If you choose to go the route of compiling your client against services-config.xml, note that you can at least keep the URL information out of the 
            client code by using ServerConfig.getChannel as described in the referenced BlazeDS documentation.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config-processors"></a>2.7.&nbsp;Advanced MessageBroker Customization</h2></div></div></div><p>
            The initialization of the <code class="code">MessageBroker</code> by the <code class="code">MessageBrokerFactoryBean</code> logically consists of two phases:
        </p><div class="orderedlist"><ol type="1"><li><p>Parsing the BlazeDS XML configuration files and applying their settings to a newly created MessageBroker</p></li><li><p>Starting the MessageBroker and its services</p></li></ol></div><p>
            A special <code class="code">MessageBrokerConfigProcessor</code> callback interface is provided that allows custom processing to be done on the
            newly created MessageBroker after each phase, before it is made available for request processing.  This interface is used internally
            by Spring BlazeDS Integration, but is also available for general use in advanced programmatic introspection and customization of the 
            <code class="code">MessageBroker</code>.  A custom <code class="code">MessageBrokerConfigProcessor</code> can be configured as a Spring bean and then registered with the 
            <code class="code">MessageBrokerFactoryBean</code> via the <code class="code">config-processor</code> tag.  For example, given a trivial implementation
            to log some additional info about the MessageBroker:        
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> com.example;

<span class="hl-keyword">import</span> org.springframework.flex.config.MessageBrokerConfigProcessor;

<span class="hl-keyword">import</span> flex.messaging.MessageBroker;
<span class="hl-keyword">import</span> flex.messaging.services.RemotingService;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDestinationCountingConfigProcessor <span class="hl-keyword">implements</span> MessageBrokerConfigProcessor {

    <span class="hl-keyword">public</span> MessageBroker processAfterStartup(MessageBroker broker) {
        RemotingService remotingService = 
            (RemotingService) broker.getServiceByType(RemotingService.<span class="hl-keyword">class</span>.getName());
        <span class="hl-keyword">if</span> (remotingService.isStarted()) {
            System.out.println(<span class="hl-string">"The Remoting Service has been started with "</span>
                    +remotingService.getDestinations().size()+<span class="hl-string">" Destinations."</span>);
        }
        <span class="hl-keyword">return</span> broker;
    }

    <span class="hl-keyword">public</span> MessageBroker processBeforeStartup(MessageBroker broker) {
        <span class="hl-keyword">return</span> broker;
    }
}        
        </pre><p>
            This class could be configured and registered with the <code class="code">MessageBroker</code> as follows:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:config-processor</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myConfigProcessor"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myConfigProcessor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.MyDestinationCountingConfigProcessor"</span> /&gt;
        </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exception-translators"></a>2.8.&nbsp;Using Custom Exception Translators</h2></div></div></div><p>
            In order to propagate useful information back to the Flex client when an exception occurs on the server, 
            the original exception must be translated into an instance of <code class="code">flex.messaging.MessageException</code>.
            If special translation logic is not applied, a generic "Server.Processing" error will propagate to the client that
            doesn't give the client the chance to reason on the real cause of the error to take appropriate action.  Special 
            exception translators are configured by default for transforming Spring Security exceptions into an appropriate 
            <code class="code">MessageException</code>, but it could also be useful to provide custom translation for your own application-level exceptions.    
        </p><p>
            Custom exception translation logic can be provided through implementations of the <code class="code">org.springframework.flex.core.ExceptionTranslator</code>
            interface.  These implementations must be configured as Spring beans and then registered through the XML configuration namespace as follows:  
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Custom exception translator configured as a Spring bean --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myExceptionTranslator"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.foo.app.MyBusinessExceptionTranslator"</span>/&gt;

&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:exception-translator</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myExceptionTranslator"</span>/&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;           
        </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-interceptors"></a>2.9.&nbsp;Using Custom Message Interceptors</h2></div></div></div><p>
            Custom message interceptors may be used to apply special processing logic to incoming and outgoing AMF messages in 
            their de-serialized Java form.  For example, an interceptor can be used to inspect the contents of the incoming message,
            or to add extra information to the outgoing message.    
        </p><p>
            Custom message processing logic is provided through implementations of the <code class="code">org.springframework.flex.core.MessageInterceptor</code> 
            interface.  These implementations must be configured as Spring beans and then registered through the XML configuration namespace as follows:  
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Custom message interceptor configured as a Spring bean --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myMessageInterceptor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.foo.app.MyMessageInterceptor"</span>/&gt;

&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:message-interceptor</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myMessageInterceptor"</span>/&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;           
        </pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resource-handling-message-interceptors"></a>2.9.1.&nbsp;Resource Handling with Custom Message Interceptors</h3></div></div></div><p>
               For housekeeping purposes, an additional <code class="code">org.springframework.flex.core.ResourceHandlingMessageInterceptor</code> interface
               is available to use.  Interceptors that implement this extended interface receive an additional guaranteed callback after message processing is completed,
               whether processing was successful or failed due to an exception being thrown by the Endpoint.  This allows the interceptor to clean up any resources that 
               it may have been using.  This interface extends the basic <code class="code">MessageInterceptor</code> interface, thus it is configured the same way using the 
               <code class="code">message-interceptor</code> tag.
           </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="message-interception-order"></a>2.9.2.&nbsp;Customizing the Message Interceptor Chain</h3></div></div></div><p>
                The framework installs a number of predefined <code class="code">MessageInterceptors</code> that are automatically configured through the use of the configuration 
                namespace.  These interceptors are configured in a specific order, and any custom interceptors are by default added to the beginning of the chain, in the 
                order that their <code class="code">message-interceptor</code> elements appear.  It is possible to specify an explicit order via the <code class="code">position</code>, <code class="code">before</code>, 
                and <code class="code">after</code> attributes.  The <code class="code">position</code> attribute allows the user to *override* the framework-supplied interceptor at that position, or to 
                simply specify that the interceptor should be at the beginning or end of the chain by using the <code class="code">FIRST</code> and <code class="code">LAST</code> values respectively. The 
                <code class="code">before</code> and <code class="code">after</code> attributes allow specifying position *relative to* the framework-supplied filters.
            </p><p>
                The ordering and implementation of the framework-supplied filters is shown in the table below.
                </p><div class="table"><a name="interceptor-stack"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Standard Interceptor Aliases and Ordering</b></p><div class="table-contents"><table summary="Standard Interceptor Aliases and Ordering" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="center">Alias</th><th align="center">MessageInterceptor Class</th><th align="center">Namespace Element or Attribute</th></tr></thead><tbody><tr><td align="left"> PER_CLIENT_AUTH_INTERCEPTOR</td><td align="left">
                                    <code class="literal">PerClientAuthenticationInterceptor</code>
                                </td><td align="left">
                                    <code class="literal">message-broker / secured @ per-client-authentication</code>
                                </td></tr><tr><td align="left"> LOGIN_MESSAGE_INTERCEPTOR</td><td align="left">
                                    <code class="literal">LoginMessageInterceptor</code>
                                </td><td align="left">
                                    <code class="literal">message-broker / secured</code>
                                </td></tr><tr><td align="left"> ENDPOINT_INTERCEPTOR</td><td align="left">
                                    <code class="literal">EndpointInterceptor</code>
                                </td><td align="left">
                                    <code class="literal">message-broker / secured / secured-endpoint-path or message-broker / secured / secured-channel</code>
                                </td></tr></tbody></table></div></div><p><br class="table-break">
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-adapters"></a>2.10.&nbsp;Providing Custom Service Adapters</h2></div></div></div><p>
            Using the XML config namespace automatically installs the needed implementations of <code class="code">flex.messaging.services.ServiceAdapter</code>
            for use with the Remoting and Message services.  Third-party adapters (such as those provided by the dpHibernate or Gilead projects) can
            be configured using the <code class="code">org.springframework.flex.core.ManageableComponentFactoryBean</code>.  This factory bean implementation is
            able to process arbitrarily complex configuration metadata supplied in JSON format (instead of arbitrarily complex XML as in the native
            BlazeDS configuration) and honors the lifecycle semantics (such as proper invocation of the <code class="code">initialize</code> method) of the 
            ManageableComponent.  These custom adapters may be used by Spring-managed Remoting and Message destinations by either setting its id as the 
            default for the Remoting or Message service, or by setting the <code class="code">service-adapter</code> attribute for a specific destination (see the 
            Remoting and Messaging chapters for further detail).
        </p><p>
            For example, to use the special adapter provided by dpHibernate as the default adapter with the Remoting service, the configuration 
            would be similar to the following:      
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"hibernate-object"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.core.ManageableComponentFactoryBean"</span>&gt;
&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"net.digitalprimates.persistence.hibernate.HibernateAdapter"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"properties"</span>&gt;
        &lt;<span class="hl-tag">value</span>&gt;
            {"hibernate" :
                {"sessionFactory" :
                    { "class" : "net.digitalprimates.persistence.hibernate.utils.HibernateUtil",
                      "getCurrentSessionMethod" : "getCurrentSession"
                    }
                }
            }
        &lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt; 

&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:remoting-service</span> <span class="hl-attribute">default-adapter-id</span>=<span class="hl-value">"hibernate-object"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;           
        </pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="remoting"></a>Chapter&nbsp;3.&nbsp;Exporting Spring Beans for Flex Remoting</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-introduction"></a>3.1.&nbsp;Introduction</h2></div></div></div><p>
            Using a Spring-managed <code class="code">MessageBroker</code> enables Spring beans to be easily exported for direct remoting calls from a Flex client.  This approach
            is quite similar to that taken with other remoting technologies in the core Spring Framework.  Remoting is applied to existing Spring-managed beans
            as an external configuration concern.  The <code class="code">MessageBroker</code> transparently handles the process of serialization and deserialization between
            the Flex AMF data format and Java. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-service-config"></a>3.2.&nbsp;Configuring the Remoting Service</h2></div></div></div><p>
            The BlazeDS <code class="code">RemotingService</code> has traditionally been configured by the inclusion of a remoting-config.xml file in the BlazeDS XML configuration.  When
            using only Spring-managed remoting destinations, this config file can be left out completely as the inclusion of the <code class="code">message-broker</code> tag
            in your Spring configuration will cause the <code class="code">RemotingService</code> to be configured with sensible defaults if none already exists at startup
            time.  The end result is essentially equivalent to including the following minimal remoting-config.xml in your BlazeDS configuration:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">service</span> <span class="hl-attribute">id</span>=<span class="hl-value">"remoting-service"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.services.RemotingService"</span>&gt;

    &lt;<span class="hl-tag">adapters</span>&gt;
        &lt;<span class="hl-tag">adapter-definition</span> <span class="hl-attribute">id</span>=<span class="hl-value">"java-object"</span> 
            <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.services.remoting.adapters.JavaAdapter"</span> 
            <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span>/&gt;
    &lt;<span class="hl-tag">/adapters</span>&gt;

    &lt;<span class="hl-tag">default-channels</span>&gt;
        &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"my-amf"</span>/&gt;
    &lt;<span class="hl-tag">/default-channels</span>&gt;
    
&lt;<span class="hl-tag">/service</span>&gt;       
        </pre><p>
            Note that this assumes that there is already an equivalent application-wide <code class="code">default-channels</code> configuration.  It is recommended that
            you set the desired service-specific channels (see example below) if not relying on an application-wide default setup.  If no application-wide
            defaults exist, a best guess will be made by configuring the first available channel from the <code class="code">MessageBroker</code> that uses an 
            <code class="code">AMFEndpoint</code> as the default for the <code class="code">RemotingService</code>.  
        </p><p>
            If you wish to have more explicit control over the defaults that will be set on the <code class="code">RemotingService</code>, you can customize them
            via the <code class="code">remoting-service</code> child element of the <code class="code">message-broker</code> tag.  For example:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:remoting-service</span> <span class="hl-attribute">default-adapter-id</span>=<span class="hl-value">"my-default-remoting-adapter"</span> 
        <span class="hl-attribute">default-channels</span>=<span class="hl-value">"my-amf, my-secure-amf"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;
        </pre><p>
            If you have an existing remoting-config.xml for a legacy BlazeDS application, the <code class="code">RemotingDestinationExporter</code> will be able to work transparently with it,
            allowing you to gradually migrate to all Spring-managed remoting destinations.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-destination"></a>3.3.&nbsp;Using the <code class="code">remoting-destination</code> Tag</h2></div></div></div><p>
            The <code class="code">remoting-destination</code> configuration tag can be used to export existing Spring-managed services for direct remoting from a Flex client.
            Given the following Spring bean definition for a <code class="code">productService</code> bean:
        </p><pre class="programlisting">    
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"flex.samples.product.ProductServiceImpl"</span> /&gt;
        </pre><p>
            and assuming the existance of a Spring-managed <code class="code">MessageBroker</code> configured via the <code class="code">message-broker</code> tag, the following 
            top-level <code class="code">remoting-destination</code> tag will expose the service for remoting to the Flex client as a remote service destination named <code class="code">productService</code>: 
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Expose the productService bean for BlazeDS remoting --</span>&gt;
&lt;<span class="hl-tag">flex:remoting-destination</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"productService"</span> /&gt;
        </pre><p>
            By default, the remote service destination exposed to the Flex client will use bean name of the bean being exported as the service id of the 
            destination, but this may be overridden using the <code class="code">destination-id</code> attribute on the <code class="code">remoting-destination</code> tag.
        </p><p>
            An alternate way of using the <code class="code">remoting-destination</code> tag is as a child element of an top-level bean definition.  This is even more concise 
            and works well if you don't have a need to keep your domain-layer bean definitions separate from infrastructure concerns such as Flex remoting.  
            (Keep in mind that keeping them separate can lead to easier testability of the core domain layer.)  The following achieves the equivalent result
            to the previous example:  
        </p><pre class="programlisting">    
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"flex.samples.product.ProductServiceImpl"</span> &gt;
    &lt;<span class="hl-tag">flex:remoting-destination</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
        </pre><p>
            The methods that are exposed to be called by the Flex client can be more tightly controlled through use of the <code class="code">include-methods</code> and <code class="code">exclude-methods</code>
            attributes of the <code class="code">remoting-destination</code> tag.  The BlazeDS channels over which the destination is exposed can also be controlled using the <code class="code">channels</code> 
            attribute.  (These attributes are available whether using the top-level or the nested version.)  A more extensively customized example would look something like:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:remoting-destination</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"productService"</span> 
    <span class="hl-attribute">include-methods</span>=<span class="hl-value">"read, update"</span> 
    <span class="hl-attribute">exclude-methods</span>=<span class="hl-value">"create, delete"</span> 
    <span class="hl-attribute">channels</span>=<span class="hl-value">"my-amf, my-secure-amf"</span> /&gt;
        </pre><p>
            The <code class="code">remoting-destination</code> tag is transparently configuring a <code class="code">RemotingDestinationExporter</code> bean instance for each bean being exported.  
            The equivalent full bean syntax without the namespace support would be:
        </p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Expose the productService bean for BlazeDS remoting --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.remoting.RemotingDestinationExporter"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageBroker"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"_messageBroker"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"service"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"productService"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"destinationId"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"productService"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"includeMethods"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"read, update"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"excludeMethods"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"create, delete"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channels"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"my-amf, my-secure-amf"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
        </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-destination-annotation"></a>3.4.&nbsp;Exporting Beans for Remoting with @RemotingDestination</h2></div></div></div><p>
            The <code class="code">@RemotingDestination</code> annotation may be used as an alternative to the XML remoting-destination tag when using annotation-based 
            Spring configuration.  <code class="code">@RemotingDestination</code> is used at the type level to indicate the class being exported.  <code class="code">@RemotingInclude</code> and 
            <code class="code">@RemotingExclude</code> are used at the method level to mark the methods that should be included and excluded for remoting.  
        </p><p>
            The following example illustrates the productService bean configured exclusively through annotations:
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> flex.samples.product;

<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingDestination;
<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingExclude;
<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingInclude;
<span class="hl-keyword">import</span> org.springframework.stereotype.Service;

@Service(<span class="hl-string">"productService"</span>)
@RemotingDestination(channels={<span class="hl-string">"my-amf"</span>,<span class="hl-string">"my-secure-amf"</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    @RemotingInclude
    <span class="hl-keyword">public</span> Product read(String id) {
        ...
    }
    
    @RemotingExclude
    <span class="hl-keyword">public</span> Product create(Product product){
        ...
    }
    
    @RemotingInclude
    <span class="hl-keyword">public</span> Product update(Product product){
        ...
    }
    
    @RemotingExclude
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(Product product) {
        ...
    }
}
        </pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-remoting-destination-channels"></a>3.4.1.&nbsp;Supplying Externalized Channel Ids</h3></div></div></div><p>
                One potential drawback of the <code class="code">@RemotingDestination</code> approach is the potential need to hard-code AMF channel ids in multiple 
                classes throughout your codebase.  The specification of the <code class="code">channels</code> property is optional (if not specified, the defaults for 
                the RemotingService will be used), but in cases where they do need to be specified, one shouldn't need to edit all instances of 
                <code class="code">@RemotingDestination</code> any time the channel identifiers change.  To support this need, the <code class="code">channels</code> attribute is 
                able to resolve values supplied in the <code class="code">ApplicationContext</code> through a <code class="code">PropertyPlaceholderConfigurer</code>.  For example, the 
                previous hardcoded example could be replaced with:
            </p><pre class="programlisting">
<span class="hl-keyword">package</span> flex.samples.product;

<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingDestination;
<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingExclude;
<span class="hl-keyword">import</span> org.springframework.flex.remoting.RemotingInclude;
<span class="hl-keyword">import</span> org.springframework.stereotype.Service;

@Service(<span class="hl-string">"productService"</span>)
@RemotingDestination(channels={<span class="hl-string">"${channel1}"</span>,<span class="hl-string">"${channel2}"</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {
    ...
}
            </pre><p>
                assuming you have a <code class="code">PropertyPlaceholderConfigurer</code> provided along the lines of:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"properties"</span>&gt;
        &lt;<span class="hl-tag">props</span>&gt;
            &lt;<span class="hl-tag">prop</span> <span class="hl-attribute">key</span>=<span class="hl-value">"channel1"</span>&gt;my-amf&lt;<span class="hl-tag">/prop</span>&gt;
            &lt;<span class="hl-tag">prop</span> <span class="hl-attribute">key</span>=<span class="hl-value">"channel2"</span>&gt;my-secure-amf, my-amf&lt;<span class="hl-tag">/prop</span>&gt;
        &lt;<span class="hl-tag">/props</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;      
            </pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="amf-rest"></a>Chapter&nbsp;4.&nbsp;Communicating with RESTful Spring MVC Endpoints using AMF</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-introduction"></a>4.1.&nbsp;Introduction</h2></div></div></div><p>
            Spring MVC 3 introduced support for building RESTful services using the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-controller" target="_top">@Controller</a> programming
            model. This allows for serving multiple representations of the same content based on what the client has requested. For example, a single RESTful
            endpoint could be configured to serve HTML, XML, or JSON all from a single request handling Java method on the @Controller class. This approach
            allows a single service implementation to support a variety of different client types, automatically providing the representation that a particular
            client desires. In order to better support Flex as one of those client types, Spring BlazeDS Integration adds the necessary support to be able to
            support an AMF representation of a given RESTful resource.
        </p><p>
            <code class="code">AmfView</code> and <code class="code">AmfHttpMessageConverter</code> provide the foundation necessary to use AMF with Spring MVC @Controllers. The
            implementations are quite similar to <code class="code">MappingJacksonJsonView</code> and <code class="code">MappingJacksonHttpMessageConverter</code> which provide Spring's
            out-of-the-box JSON support.  The basics of configuring these classes are shown throughout the rest of this chapter.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amf-rest-view"></a>4.2.&nbsp;Using AmfView</h2></div></div></div><p>
            <code class="code">AmfView</code> is a Spring MVC <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-viewresolver" target="_top">View</a> implementation that is
            intended to be used in conjunction with Spring MVC's <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-multiple-representations" target="_top">ContentNegotiatingViewResolver</a>.
            In particular, it is expected that it will be configured as a "default" singleton view implementation that can render any MVC model as AMF, rather
            than needing to have a unique instance per logical view name.
        </p><p>
            The following example shows a simple configuration of <code class="code">ContentNegotiatingViewResolver</code> to support both JSON and AMF representations:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.servlet.view.ContentNegotiatingViewResolver"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mediaTypes"</span>&gt;
    &lt;<span class="hl-tag">map</span>&gt;
      &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"json"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"application/json"</span>/&gt;
      &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"amf"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"application/x-amf"</span>/&gt;
    &lt;<span class="hl-tag">/map</span>&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"defaultViews"</span>&gt;
    &lt;<span class="hl-tag">list</span>&gt;
      &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.servlet.view.json.MappingJacksonJsonView"</span> /&gt;
      &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.http.AmfView"</span> /&gt;
    &lt;<span class="hl-tag">/list</span>&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;        
        
        </pre><p>
            The above example includes setting the <code class="code">mediaTypes</code> property to map file extensions to media types.  This is helpful for clients 
            (such as Flex) that aren't always able to set an appropriate <code class="code">Accept</code> header.  So given the above configuration, and a simple controller 
            such as the following:
        </p><pre class="programlisting">
        
@Controller
@RequestMapping(<span class="hl-string">"/contacts"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContactsController {

    @Autowired
    <span class="hl-keyword">private</span> IContactDAO contactDAO;

    @RequestMapping(method=RequestMethod.GET)
    <span class="hl-keyword">public</span> List&lt;Contact&gt; find() {
        <span class="hl-keyword">return</span> contactDAO.findAll();
    }
}
        
        </pre><p>
            an HTTP <code class="code">GET</code> request issued to either <code class="code">http://localhost/myapp/contacts.amf</code> <span class="emphasis"><em>without</em></span> an appropriate
            <code class="code">Accept</code> header or to<code class="code">http://localhost/myapp/contacts</code> <span class="emphasis"><em>with</em></span> an accept header of
            <code class="code">application/x-amf</code> will return the list of contacts as an AMF message that may then be deserialized to an <code class="code">ArrayCollection</code> 
            of ActionScript objects on the Flex client.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amf-rest-converter"></a>4.3.&nbsp;Using AmfHttpMessageConverter</h2></div></div></div><p>
            <code class="code">AmfHttpMessageConverter</code> is a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/remoting.html#rest-message-conversion" target="_top">HttpMessageConverter</a> implementation that can convert to and from AMF. In order to be able to convert HTTP <code class="code">POST</code> and
            <code class="code">PUT</code> request message bodies from AMF to Java objects to be passed as a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-requestbody" target="_top">@RequestBody</a> arguments
            to <code class="code">@Controller</code> methods, it must be added to the converters used by Spring MVC's <code class="code">AnnotationMethodHandlerAdapter</code>. In order
            to add AMF support while also leaving the framework's default <code class="code">HttpMessageConverters</code> in place, a simple <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-extension-bpp" target="_top">BeanPostProcessor</a> such as the following example can be used:
        </p><pre class="programlisting">
        
<span class="hl-keyword">package</span> org.springframework.flex.samples.rest;

<span class="hl-keyword">import</span> org.springframework.beans.BeansException;
<span class="hl-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;
<span class="hl-keyword">import</span> org.springframework.flex.http.AmfHttpMessageConverter;
<span class="hl-keyword">import</span> org.springframework.http.converter.HttpMessageConverter;
<span class="hl-keyword">import</span> org.springframework.util.ObjectUtils;
<span class="hl-keyword">import</span> org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HandlerAdapterPostProcessor <span class="hl-keyword">implements</span> BeanPostProcessor {

    <span class="hl-keyword">public</span> Object postProcessBeforeInitialization(Object bean, String beanName)
            <span class="hl-keyword">throws</span> BeansException {
        <span class="hl-keyword">return</span> bean;
    }

    <span class="hl-keyword">public</span> Object postProcessAfterInitialization(Object bean, String beanName)
            <span class="hl-keyword">throws</span> BeansException {
        <span class="hl-keyword">if</span> (bean <span class="hl-keyword">instanceof</span> AnnotationMethodHandlerAdapter) {
            AnnotationMethodHandlerAdapter adapter = (AnnotationMethodHandlerAdapter) bean;
            HttpMessageConverter&lt;?&gt;[] converters = adapter.getMessageConverters();
            adapter.setMessageConverters(
                (HttpMessageConverter&lt;?&gt;[]) ObjectUtils.
                addObjectToArray(converters, <span class="hl-keyword">new</span> AmfHttpMessageConverter()));
        }
        <span class="hl-keyword">return</span> bean;
    }

}
        
        </pre><p>
            With this configuration in place, and a controller such as the following:
        </p><pre class="programlisting">
        
@Controller
@RequestMapping(<span class="hl-string">"/contacts"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContactsController {

    @Autowired
    <span class="hl-keyword">private</span> IContactDAO contactDAO;

    @RequestMapping(method=RequestMethod.POST)
    <span class="hl-keyword">public</span> Contact create(@RequestBody Contact contact) {
        <span class="hl-keyword">return</span> contactDAO.create(contact);
    }
}
        
        </pre></div><p>
        the Flex client can send an HTTP <code class="code">POST</code> request with an ActionScript <code class="code">Contact</code> serialized to AMF in the message body to
        <code class="code">http://localhost/myapp/contacts</code> in order to persist that contact to the database.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amf-rest-client"></a>4.4.&nbsp;Interacting with RESTful AMF Endpoints from the Flex Client</h2></div></div></div><p>
            Effectively interacting with a RESTful service from the Flex client using AMF is generally a matter of dropping down to some lower-level Flash APIs
            such as <code class="code">flash.net.URLRequest</code> and <code class="code">flash.net.URLStream</code>.  There are some limitations to how a Flash/Flex application can
            interact with a REST service from within the browser. These limitations are generally imposed by the host browser, and are similar to the
            limitations imposed on HTML pages. Fortunately, Spring MVC already accounts for such browser limitations and provides useable workarounds.
        </p><p>
            The first major limitation is that the Flash player is typically not able to set the <code class="code">Accept</code> header for the request to
            <code class="code">application/x-amf</code> when using <code class="code">URLRequest</code>. Spring supports mapping file extensions to media types as an alternative (see the
            example <a href="#amf-rest-view" title="4.2.&nbsp;Using AmfView">Section&nbsp;4.2, &#8220;Using AmfView&#8221;</a> configuration for how this is achieved).  
        </p><p>
            The second major limitation is the inability to properly send HTTP <code class="code">PUT</code> and <code class="code">DELETE</code> requests. Spring provides the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/index.html?org/springframework/web/filter/HiddenHttpMethodFilter.html" target="_top">HiddenHttpMethodFilter</a> to help cope with this. With the filter configured, a <code class="code">DELETE</code> request (for example) could be simulated
            by sending a <code class="code">POST</code> request to a URL such as <code class="code">http://localhost/myapp/contacts/1.amf?_method=DELETE</code>.
        </p><p>    
            A complete <code class="code">insync-rest</code> example of interacting with a Spring MVC @Controller is now provided in the <a href="#samples" title="Chapter&nbsp;8.&nbsp;Building and Running the Spring BlazeDS Integration Samples">Test
            Drive</a>. This sample duplicates the full functionality of the complete inSync application that was originally built using BlazeDS Remoting. It
            shows in detail how to work around Flash player's limitations to use AMF to interact with a RESTful service that supports it.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="amf"></a>Chapter&nbsp;5.&nbsp;Enhanced AMF Support</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amf-introduction"></a>5.1.&nbsp;Customizing AMF Conversion</h2></div></div></div><p>
            While BlazeDS provides excellent support for serialization/deserialization between Java beans and AMF, there are certain limitations in the 
            types of objects that can be handled out-of-the-box.  For example, objects to be converted to/from AMF must have getter and setter methods and must 
            have a public no-arg constructor.  In order to allow for a more flexible approach, we have provided an extension mechanism for easily customizing 
            the AMF type conversion process through Spring configuration.  
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="amf-config-processor"></a>5.1.1.&nbsp;Configuring AMF Type Conversion</h3></div></div></div><p> 
                A special Spring-aware <code class="code">PropertyProxy</code> (a BlazeDS-specific interface for customizing serialization) is provided that uses Spring's
                <code class="code">PropertyAccessor</code> interface for type introspection and delegates to the Spring 3+ <code class="code">ConversionService</code> to allow for
                additional property conversion logic to be plugged in during the serialization/deserialization process. This enhanced <code class="code">PropertyProxy</code> 
                optionally supports:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Direct field access for properties (instead of requiring getters and setters)</p></li><li><p>Use of an alternate constructor annotated with <code class="code">@AmfCreator</code> for deserialization (instead of a public no-arg constructor)</p></li><li><p>Ignoring certain properties during serialization and/or deserialization when marked with <code class="code">@AmfIgnore</code> or <code class="code">@AmfIgnoreField</code></p></li></ul></div><p>
                To take advantage of the enhanced AMF support, an instance of <code class="code">SpringPropertyProxy</code> must be registered for each individual type that
                could potentially be converted to/from AMF. A specialized set of <code class="code">MessageBrokerConfigProcessors</code> are provided that take varied
                approaches to locating the types to be registered:
            </p><p>
                </p><div class="table"><a name="amf-configprocessors"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;AMF Handling MessageBrokerConfigProcessors</b></p><div class="table-contents"><table summary="AMF Handling MessageBrokerConfigProcessors" border="1"><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th align="center">Class</th><th align="center">Implementation</th></tr></thead><tbody><tr><td align="left">org.springframework.flex.core.io.
                                    HibernateConfigProcessor</td><td align="left">Uses the Hibernate metadata API to locate mapped Hibernate types to register for AMF conversion and configures specialized Hibernate <code class="code">Converters</code>. See <a href="#hibernate-introduction" title="5.2.&nbsp;Working with Hibernate">Section&nbsp;5.2, &#8220;Working with Hibernate&#8221;</a></td></tr><tr><td align="left">org.springframework.flex.core.io.
                                    JpaHibernateConfigProcessor</td><td align="left">Uses the Hibernate metadata API to locate mapped Hibernate JPA types to register for AMF conversion and configures specialized Hibernate <code class="code">Converters</code>. See <a href="#hibernate-introduction" title="5.2.&nbsp;Working with Hibernate">Section&nbsp;5.2, &#8220;Working with Hibernate&#8221;</a></td></tr><tr><td align="left">org.springframework.flex.core.io.
                                    ClassPathScanningAmfConversionService
                                    ConfigProcessor</td><td align="left">Uses classpath scanning to locate types to register for AMF conversion. See <a href="#amf-classpath-scanning" title="5.3.&nbsp;Using Classpath Scanning for AMF Configuration">Section&nbsp;5.3, &#8220;Using Classpath Scanning for AMF Configuration&#8221;</a></td></tr></tbody></table></div></div><p><br class="table-break"> 
            </p><p>
                Explicit configuration of one of these classes is done just as with any other <code class="code">MessageBrokerConfigProcessor</code>, by defining the desired
                implementation as a bean and wiring it into the <code class="code">MessageBroker</code> using the <code class="code">config-processor</code> namespace tag.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="field-mapping"></a>5.1.1.1.&nbsp;Using Direct Field Mapping</h4></div></div></div><p>
                    By default, the <code class="code">SpringPropertyProxy</code> will read and write property values during AMF conversion using JavaBean standard get and
                    set methods, just as the default BlazeDS <code class="code">BeanProxy</code> does. Alternatively, you many configure it to access fields directly. This
                    is useful in such cases as when you have a class that does not expose public getter or setter methods, such as the following:
                </p><pre class="programlisting">
                
@Entity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PackagePrivatePerson {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    Integer id;

    @Version
    @Column(name = <span class="hl-string">"version"</span>)
    Integer version;

    String name;
}
                
                </pre><p>
                    In order to be able to convert such a class to/from AMF, you must configure the <code class="code">useDirectFieldAccess</code> property of one of the
                    supplied AMF configuration processors.  For example:
                </p><pre class="programlisting">
                
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:config-processor</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myJpaConfigProcessor"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myJpaConfigProcessor"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.core.io.JpaConfigProcessor"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"useDirectFieldAccess"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;                
                
                </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="amf-creator-mapping"></a>5.1.1.2.&nbsp;Deserializing Immutable Objects with @AmfCreator</h4></div></div></div><p>
                    By default, the <code class="code">SpringPropertyProxy</code> will try to instantiate types using a public no-arg constructor during the AMF 
                    deserialization process.  Types that do not have a no-arg constructor must provide an alternate constructor annotated with 
                    <code class="code">org.springframework.flex.core.io.AmfCreator</code>, whose properties are in turn annotated with 
                    <code class="code">org.springframework.flex.core.io.AmfProperty</code>, in order to be eligible for AMF conversion.  For example:  
                </p><pre class="programlisting">
                
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ImmutableValueObject {

    <span class="hl-keyword">final</span> String foo;

    <span class="hl-keyword">final</span> Integer zoo;

    @AmfCreator
    <span class="hl-keyword">public</span> ImmutableValueObject(@AmfProperty(<span class="hl-string">"foo"</span>) String foo, @AmfProperty(<span class="hl-string">"zoo"</span>) Integer zoo) {
        <span class="hl-keyword">this</span>.foo = foo;
        <span class="hl-keyword">this</span>.zoo = zoo;
    }

    <span class="hl-keyword">public</span> String getFoo() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.foo;
    }

    <span class="hl-keyword">public</span> Integer getZoo() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.zoo;
    }
}
                
                </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="amf-ignoring-properties"></a>5.1.1.3.&nbsp;Ignoring Properties During AMF Conversion</h4></div></div></div><p>
                    Sometimes it is desirable to ignore certain properties during serialization and/or deserialization. For example, there may be a property in
                    your Java object that you do not wish to ever send to the Flex client. <code class="code">SpringPropertyProxy</code> provides a means of achieving this
                    by adding some additional annotations to your Java objects. 
                </p><p>
                    The annotation <code class="code">org.springframework.flex.core.io.AmfIgnore</code> may be used on getter and setter methods.  Annotating a getter method
                    with <code class="code">@AmfIgnore</code> will cause the property to be ignored during serialization to AMF, and annotating a setter method with 
                    <code class="code">@AmfIgnore</code> will cause the property to be ignored during deserialization from AMF.  For example:
                </p><pre class="programlisting">
                
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> IgnorablePropsObject {

    <span class="hl-comment">//Will be ignored on both serialization and deserialization</span>
    <span class="hl-keyword">private</span> String foo;

    <span class="hl-comment">//Will be ignored only on serialization</span>
    <span class="hl-keyword">private</span> String bar;

    <span class="hl-comment">//Will be ignored only on deserialization</span>
    <span class="hl-keyword">private</span> String baz;

    @AmfIgnore
    <span class="hl-keyword">public</span> String getFoo() {
        <span class="hl-keyword">return</span> foo;
    }

    @AmfIgnore
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFoo(String foo) {
        <span class="hl-keyword">this</span>.foo = foo;
    }

    @AmfIgnore
    <span class="hl-keyword">public</span> String getBar() {
        <span class="hl-keyword">return</span> bar;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBar(String bar) {
        <span class="hl-keyword">this</span>.bar = bar;
    }

    <span class="hl-keyword">public</span> String getBaz() {
        <span class="hl-keyword">return</span> baz;
    }

    @AmfIgnore
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBaz(String baz) {
        <span class="hl-keyword">this</span>.baz = baz;
    }
}                
                
                </pre><p>
                    When using direct field mapping, the annotation <code class="code">org.springframework.flex.core.io.AmfIgnoreField</code> may be used on fields to 
                    achieve equivalent functionality.  For example:
                </p><pre class="programlisting">
                
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> IgnorableFieldsObject {

    <span class="hl-comment">//Will be ignored on both serialization and deserialization</span>
    @AmfIgnoreField
    <span class="hl-keyword">private</span> String foo; 

    <span class="hl-comment">//Will be ignored only on serialization</span>
    @AmfIgnoreField(onDeserialization=false)
    <span class="hl-keyword">private</span> String bar;

    <span class="hl-comment">//Will be ignored only on deserialization</span>
    @AmfIgnoreField(onSerialization=false)
    <span class="hl-keyword">private</span> String baz;

}
                
                </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="amf-custom-converters"></a>5.1.1.4.&nbsp;Providing Custom Converters</h4></div></div></div><p>
                    Customizing the way Java objects are converted to/from AMF is a matter of providing Spring 3 type <code class="code">Converters</code> and registering
                    them with the <code class="code">ConversionService</code>. The provided AMF config processors all extend from
                    <code class="code">org.springframework.flex.core.io.AbstractAmfConversionServiceConfigProcessor</code>, which provides a template method for registering 
                    additional converters.  One such use for this would be if you wanted to use classpath scanning to locate AMF-eligible types, but still wanted 
                    to register the specialized Hibernate converters.  The following example illustrates this:
                </p><p>
                    First, we configure the <code class="code">ClassPathScanningAmfConversionServiceConfigProcessor</code> using the Spring 3 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-java" target="_top">@Configuration style</a>:
                </p><pre class="programlisting">
                
<span class="hl-keyword">package</span> com.foo.config;

<span class="hl-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hl-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hl-keyword">import</span> org.springframework.core.convert.converter.ConverterRegistry;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.ClassPathScanningAmfConversionServiceConfigProcessor;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.HibernateProxyConverter;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.PersistentCollectionConverterFactory;

@Configuration
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomConverterConfiguration {

    @Bean
    <span class="hl-keyword">public</span> ClassPathScanningAmfConversionServiceConfigProcessor myConfigProcessor() {

        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ClassPathScanningAmfConversionServiceConfigProcessor(<span class="hl-string">"com.foo.domain"</span>) {

            @Override
            <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configureConverters(ConverterRegistry registry) {
                registry.addConverter(<span class="hl-keyword">new</span> HibernateProxyConverter());
                registry.addConverterFactory(<span class="hl-keyword">new</span> PersistentCollectionConverterFactory());
            }

        };
    }
}
                
                </pre><p>
                    Then we simply reference that config processor as usual in our <code class="code">MessageBroker</code> configuration:
                </p><pre class="programlisting">
                
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:config-processor</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myConfigProcessor"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;                
                
                </pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hibernate-introduction"></a>5.2.&nbsp;Working with Hibernate</h2></div></div></div><p>
            Using Hibernate to handle persistence concerns is quite common in Spring applications.  A common problem arises, though, when attempting to 
            directly use Hibernate-loaded entities in AMF messages with BlazeDS.  In essence, the default BlazeDS serialization mechanism tries to walk 
            the entire object graph, forcing initialization of any lazily loaded associations that might be encountered.  This generally leads either to 
            LazyInitialization errors, or (if using a solution such as Spring's <code class="code">OpenSessionInViewFilter</code>) the undesirable n+1 selects 
            scenario.  The other problem that arises is when associations are eagerly loaded, but still wrapped in a Hibernate-specific collection or proxy, 
            which can cause unexpected results in the way the association gets serialized.   
        </p><p>
            Spring BlazeDS Integration provides a simple solution that will allow the direct use of Hibernate entities in AMF messages. A few special
            Hibernate-aware <code class="code">Converters</code> are automatically installed that understand how to properly convert Hibernate-specific types when they are
            encountered.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="hibernate-io-config"></a>5.2.1.&nbsp;Configuring Hibernate Entity Serialization/Deserialization Support</h3></div></div></div><p>
                The Hibernate serialization/deserialization support will be automatically configured with a default <code class="code">ConversionService</code> upon
                application startup if Hibernate is detected on the classpath. This support is provided in the form of two different
                <code class="code">MessageBrokerConfigProcessors</code> - one for "native" Hibernate and one for using Hibernate as a JPA provider. The proper one will be
                configured based on the presence of the JPA api on the classpath.
            </p><p>
                The default behavior of the <code class="code">SpringPropertyProxy</code> (in the case of both "native" Hibernate and JPA), when this support is configured 
                is as follows:
            </p><div class="orderedlist"><ol type="1"><li><p>Check each bean property to see whether it is contains a Hibernate-specific Proxy or Collection</p></li><li><p>If the Proxy/Collection is initialized, unwrap the underlying value for serialization</p></li><li><p>If the Proxy/Collection is uninitialized, return <code class="code">null</code> for the value to be serialized</p></li></ol></div><p>
                At startup time, Hibernate's Metadata API is used to determine which types to register with BlazeDS to use the specialized 
                <code class="code">SpringPropetyProxy</code>.
            </p><p>
                The default behavior may be extended/overridden by manually deploying either the <code class="code">HibernateConfigProcessor</code>, 
                <code class="code">JpaHibernateConfigProcessor</code>, or some other custom extension of <code class="code">AbstractAmfConversionServiceConfigProcessor</code>  as a Spring bean and wiring it into the <code class="code">MessageBroker</code> via the <code class="code">config-processor</code> XML
                namespace tag as shown in <a href="#amf-config-processor" title="5.1.1.&nbsp;Configuring AMF Type Conversion">Section&nbsp;5.1.1, &#8220;Configuring AMF Type Conversion&#8221;</a>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amf-classpath-scanning"></a>5.3.&nbsp;Using Classpath Scanning for AMF Configuration</h2></div></div></div><p>
            As an alternative to using the Hibernate Metadata API to find types to which the <code class="code">SpringPropertyProxy</code> should be applied, a more general
            config processor implementation, <code class="code">org.springframework.flex.core.io.ClassPathScanningAmfConversionServiceConfigProcessor</code>, is supplied as
            an alternative that will instead find types using Spring's internal classpath scanning support. The implementation scans recursively starting from a
            given base package, and all classes found in the scan will be registered to have the <code class="code">SpringPropertyProxy</code> applied to them for AMF
            conversion. The scanning process may be customized further by configuring <code class="code">org.springframework.core.type.filter.TypeFilter</code>
            implementations to either include or exclude matching types. For example, Spring provides out-of-the-box RegEx-based and Annotation-based
            <code class="code">TypeFilter</code> implementations. The easiest way to configure this implementation is by using the Java config support provided in Spring 3+, 
            as in the following example: 
        </p></div><pre class="programlisting">
    
<span class="hl-keyword">package</span> com.foo.config;

<span class="hl-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hl-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hl-keyword">import</span> org.springframework.core.convert.converter.Converter;
<span class="hl-keyword">import</span> org.springframework.core.convert.converter.ConverterRegistry;
<span class="hl-keyword">import</span> org.springframework.core.type.filter.AnnotationTypeFilter;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.ClassPathScanningAmfConversionServiceConfigProcessor;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.HibernateProxyConverter;
<span class="hl-keyword">import</span> org.springframework.flex.core.io.PersistentCollectionConverterFactory;

@Configuration
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ApplicationConfig {

    @Bean
    <span class="hl-keyword">public</span> ClassPathScanningAmfConversionServiceConfigProcessor amfConfigProcessor() {
        ClassPathScanningAmfConversionServiceConfigProcessor configProcessor = 
            <span class="hl-keyword">new</span> ClassPathScanningAmfConversionServiceConfigProcessor(<span class="hl-string">"com.foo.domain"</span>) {

                @Override
                <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> configureConverters(ConverterRegistry registry) {
                    registry.addConverter(<span class="hl-keyword">new</span> HibernateProxyConverter());
                    registry.addConverterFactory(<span class="hl-keyword">new</span> PersistentCollectionConverterFactory());
                    registry.addConverter(<span class="hl-keyword">new</span> MyCustomConverter());
                }

            };

        configProcessor.addIncludeFilter(<span class="hl-keyword">new</span> AnnotationTypeFilter(MyCustomAmfAnnotation.<span class="hl-keyword">class</span>));    

        <span class="hl-keyword">return</span> configProcessor;
    } 

}
    
    </pre><pre class="programlisting">
    
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:config-processor</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"amfConfigProcessor"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;                
    
    </pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;6.&nbsp;Securing BlazeDS Destinations with Spring Security</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-introduction"></a>6.1.&nbsp;Introduction</h2></div></div></div><p>
            Spring Security provides an extremely flexible alternative to the container-based security support provided out-of-the-box with 
            BlazeDS.  Spring BlazeDS Integration provides explicit integration support for incorporating Spring Security smoothly into your 
            Flex/BlazeDS application.  Spring Security provides a wealth of different configuration options, but rather than go into the many
            different combinations here, we'll leave most of that to the Spring Security documentation.  
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spring-security-config"></a>6.1.1.&nbsp;A simple Spring Security 3 configuration</h3></div></div></div><p>
                Here is a simple Spring Security starting configuration for use in conjunction with the explicit integration features 
                provided by Spring BlazeDS Integration that should be a solid starting point for securing a typical Flex application:   
            </p><pre class="programlisting">
&lt;<span class="hl-tag">beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/security"</span>
    <span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> 
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                        http://www.springframework.org/schema/security 
                        http://www.springframework.org/schema/security/spring-security-3.0.xsd"</span>&gt;

    &lt;<span class="hl-tag">http</span> <span class="hl-attribute">entry-point-ref</span>=<span class="hl-value">"entryPoint"</span>&gt;
        &lt;<span class="hl-tag">anonymous</span> <span class="hl-attribute">enabled</span>=<span class="hl-value">"false"</span>/&gt;
    &lt;<span class="hl-tag">/http</span>&gt;
    
    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"entryPoint"</span> 
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.security3.FlexAuthenticationEntryPoint"</span>/&gt;
    
    &lt;<span class="hl-tag">authentication-manager</span>&gt;
       &lt;<span class="hl-tag">authentication-provider</span>&gt;
           &lt;<span class="hl-tag">user-service</span>&gt;
            &lt;<span class="hl-tag">user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"john"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"john"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER"</span> /&gt;
            &lt;<span class="hl-tag">user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"admin"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"admin"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_USER, ROLE_ADMIN"</span> /&gt;
            &lt;<span class="hl-tag">user</span> <span class="hl-attribute">name</span>=<span class="hl-value">"guest"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"guest"</span> <span class="hl-attribute">authorities</span>=<span class="hl-value">"ROLE_GUEST"</span> /&gt;
           &lt;<span class="hl-tag">/user-service</span>&gt;
       &lt;<span class="hl-tag">/authentication-provider</span>&gt;
    &lt;<span class="hl-tag">/authentication-manager</span>&gt;

&lt;<span class="hl-tag">/beans:beans</span>&gt;
        </pre><p>
                With a typical Flex application, this approach is preferred to using Spring Security's auto-config setup.  Auto-config sets up a number of 
                features that typically are not needed with a Flex application.  For instance, auto-config sets up a default <code class="code">intercept-url</code> entry that
                requires authentication for all URL paths within the application.  The <code class="code">FlexAuthenticationEntryPoint</code> will return a proper AMF error 
                response when such URL's are hit via normal Flex communication processing, but it's invocation should generally be considered a last resort.  Most of 
                the time, authentication and authorization processing should happen deeper within the BlazeDS request handling process, where there are opportunities to 
                provide more useful information to the client. (See <a href="#secured-endpoint-path" title="6.3.2.&nbsp;Securing BlazeDS Channels by Endpoint URL Path">
                Securing BlazeDS Channels by Endpoint URL Path</a> for an alternative to <code class="code">intercept-url</code> that generates proper AMF responses for the Flex client.) 
                It is recommended to start simple as in this example, and add the additional features as needed.  
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="security-filter-config"></a>6.1.2.&nbsp;Enabling the Spring Security filter chain in web.xml</h3></div></div></div><p>
                For a typical setup with Spring Security, it is critical to remember to enable 
                the Spring Security filter chain by adding the appropriate entry to web.xml:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">filter</span>&gt; 
    &lt;<span class="hl-tag">filter-name</span>&gt;springSecurityFilterChain&lt;<span class="hl-tag">/filter-name</span>&gt; 
    &lt;<span class="hl-tag">filter-class</span>&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;<span class="hl-tag">/filter-class</span>&gt; 
&lt;<span class="hl-tag">/filter</span>&gt; 

&lt;<span class="hl-tag">filter-mapping</span>&gt; 
    &lt;<span class="hl-tag">filter-name</span>&gt;springSecurityFilterChain&lt;<span class="hl-tag">/filter-name</span>&gt; 
    &lt;<span class="hl-tag">url-pattern</span>&gt;/*&lt;<span class="hl-tag">/url-pattern</span>&gt; 
&lt;<span class="hl-tag">/filter-mapping</span>&gt;           

            </pre></div><p>
            We will assume the above configuration is in place for the remainder of the examples in this chapter.  For additional details on the many options available in 
            configuring and using Spring Security, please refer to that project's <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring-security/site/reference.html" target="_top">documentation</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring-security"></a>6.2.&nbsp;Configuring the Spring Security Integration</h2></div></div></div><p>
            Spring Security integration is enabled through the <code class="code">secured</code> child element of the <code class="code">message-broker</code> tag.  The
            simplest possible configuration would be:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:secured</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;
        </pre><p>
            This enables the basic security features.  A special BlazeDS <code class="code">LoginCommand</code> implementation is automatically installed that
            enables ChannelSet.login and ChannelSet.logout requests to integrate with Spring Security's Authorization mechanisms.  Additionally, 
            the special <code class="code">LoginCommand</code> enables Spring Security granted authorities to be referenced in BlazeDS XML security constraints.
            For example, if we were using a traditional BlazeDS remoting destination defined in remoting-config.xml, we could have something like 
            the following:  
        </p><pre class="programlisting">
&lt;<span class="hl-tag">destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"productService"</span>&gt;
    ...
    &lt;<span class="hl-tag">security</span>&gt;
        &lt;<span class="hl-tag">security-constraint</span>&gt;
            &lt;<span class="hl-tag">auth-method</span>&gt;Custom&lt;<span class="hl-tag">/auth-method</span>&gt;
            &lt;<span class="hl-tag">roles</span>&gt;
                &lt;<span class="hl-tag">role</span>&gt;ROLE_USER&lt;<span class="hl-tag">/role</span>&gt;
            &lt;<span class="hl-tag">/roles</span>&gt;
        &lt;<span class="hl-tag">/security-constraint</span>&gt;
    &lt;<span class="hl-tag">/security</span>&gt;
&lt;<span class="hl-tag">/destination</span>&gt;       
        </pre><p>
            As you can see, we are referencing the "ROLE_USER" authority from our simple Spring Security setup.  The invocation of this remote
            destination would cause the provided <code class="code">LoginCommand</code> to be invoked to both verify that the user is logged in and to check
            that they have the appropriate role.  Violation of either will result in an exception being thrown by Spring Security.    
        </p><p>
            The provided <code class="code">LoginCommand</code> mimics as much as possible the functionality of Spring Security's 
            <code class="code">AbstractAuthenticationProcessingFilter</code> including taking the necessary actions to coordinate Spring Security's additional 
            features such as, <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/springsecurity-single.html#remember-me" target="_top">Remember Me</a>, 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/springsecurity-single.html#ns-session-fixation" target="_top">Session Fixation Protection</a>, 
            and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/springsecurity-single.html#concurrent-sessions" target="_top">Concurrent Session Management</a> 
            upon commencement of the authentication process.  Additionally, it will invoke any configured <code class="code">LogoutHandlers</code> as part of the logout 
            process, including both those auto-configured by Spring Security, and any that might be supplied by the application developer. 
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-login-command"></a>6.2.1.&nbsp;Using a Custom LoginCommand</h3></div></div></div><p>
                While the supplied <code class="code">LoginCommand</code> covers many of the most common security configuration scenarios, sometimes it can be useful 
                to provide your own implementation that either extends <code class="code">SpringSecurityLoginCommand</code>, while using the Spring container to wire in 
                any necessary dependencies.  A custom <code class="code">LoginCommand</code> can be supplied via the <code class="code">login-command</code> attribute of the <code class="code">secured</code> 
                tag as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:secured</span> <span class="hl-attribute">login-command</span>=<span class="hl-value">"myLoginCommand"</span>/&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myLoginCommand"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.foo.app.security.CustomLoginCommand"</span>/&gt;
            </pre><p>
                If your custom <code class="code">LoginCommand</code> extends <code class="code">SpringSecurityLoginCommand</code>, the following properties will be autowired by the container if possible:
                </p><div class="itemizedlist"><ul type="disc"><li><p>rememberMeServices</p></li><li><p>sessionAuthenticationStrategy</p></li><li><p>logoutHandlers</p></li></ul></div><p>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="accessing-user-details"></a>6.2.2.&nbsp;Accessing User Details</h3></div></div></div><p>
                When using the ChannelSet.login API call from the Flex client with Spring Security integration enabled, the resulting ResponseEvent 
                fired client-side upon successful completion will contain additional information that can be inspected about the current user.  The 
                name and authorities will be extracted from the Authentication object and added to the body of the response message.  This information, 
                for example, can then be used to conditionally display different portions of the UI based on the user's identity and granted roles:
            </p><pre class="programlisting">
var token:AsyncToken = myChannelSet.login(<span class="hl-string">"jeremy"</span>,<span class="hl-string">"atlanta"</span>);
token.addResponder(
    <span class="hl-keyword">new</span> AsyncResponder(
        function(event:ResultEvent, token:Object = null):<span class="hl-keyword">void</span> {
            <span class="hl-keyword">if</span> (event.result.authorities.indexOf(<span class="hl-string">"ROLE_ADMIN"</span>) &gt;= 0) {
                displayAdminPanel(event.result.name);
            } <span class="hl-keyword">else</span> {
                displayUserPanel(event.result.name);
            }
        },
        function(event:FaultEvent, token:Object = null):<span class="hl-keyword">void</span> {
            displayErrorMessage(<span class="hl-string">"Login Failed: "</span>+event.fault.faultString);
        }
    )
);       
            </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="security-exception-translation"></a>6.2.3.&nbsp;Security Exception Translation</h3></div></div></div><p>
                Another feature that is automatically installed when the <code class="code">secured</code> tag is used is automatic exception translation from
                any thrown SpringSecurityException to the proper BlazeDS SecurityException.  The exceptions are caught and translated at the proper 
                point in the execution chain such that it will result in the proper AMF error message being serialized and sent back to the client.
            </p><p>  
                This is alternative to the normal Spring Security behavior where a filter in the chain catches the exception and sends back a
                corresponding HTTP status code.  The problem with sending back HTTP status codes other than 200 is that this causes the Flex client
                to throw a generic and rather unhelpful exception, and often the status code can't be determined from the Flex client.  Sending back 
                specific AMF error messages instead causes a <code class="code">FaultEvent</code> to be thrown client-side that contains the proper 
                security fault code that can then be reasoned on and appropriate action can be taken.  This behavior is equivalent to that of the
                out-of-the-box container-based security mechanisms provided with BlazeDS, so the programming model client-side remains the same.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secured-tag-attributes"></a>6.2.4.&nbsp;<code class="code">secured</code> Configuration Attributes</h3></div></div></div><p>
                The <code class="code">secured</code> tag has several additional attributes that allow further customization.
            </p><p>  
                If you are not using Spring Security's
                default bean ids for the <code class="code">AuthenticationManager</code> or <code class="code">AccessDecisionManager</code>, you can specify your custom bean references
                using the corresponding <code class="code">authentication-manager</code> and <code class="code">access-decision-manager</code> attributes respectively on the <code class="code">secured</code>
                tag.   
            </p><p>
                The configuration of the provided <code class="code">LoginCommand</code> can be further controlled via the <code class="code">secured</code> tag.  The <code class="code">invalidate-flex-session</code>
                attribute controls whether the current Flex session is invalidated when the <code class="code">logout()</code> method is called on the <code class="code">LoginCommand</code>, and 
                defaults to "true" if not specified.  The <code class="code">per-client-authentication</code> attribute turns BlazeDS's per-client authentication mode on when true, and
                defaults to "false" if not specified.  Enabling per-client authentication will cause the Security context to no longer be stored in the session between
                requests and thus will prevent the use of any Spring Security filters that rely on the Security Context being available in the session, but the authentication 
                and authorization integration will otherwise work as expected.  (See the BlazeDS docs for further information on the difference between per-session and per-client 
                authentication.)                
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-security"></a>6.3.&nbsp;Configuring Endpoint and Destination Security</h2></div></div></div><p>
            The Spring Security integration allows flexible control over how you secure your application.  You can secure BlazeDS endpoints in
            a manner similar to Spring Security's traditional URL security, and you can secure your Spring services using the many existing
            object security mechanisms of Spring Security just as if you were writing a traditional web application.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secured-channel"></a>6.3.1.&nbsp;Securing Specific BlazeDS Channels</h3></div></div></div><p>
                You can set security constraints on specific BlazeDS channels using the <code class="code">secured-channel</code> child element of the <code class="code">secured</code> 
                tag.  For example:  
            </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:secured</span>&gt;
        &lt;<span class="hl-tag">flex:secured-channel</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"my-amf"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span> /&gt;
    &lt;<span class="hl-tag">/flex:secured</span>&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;
            </pre><p>
                This results in any request being routed to the "my-amf" channel to require the user to be logged in and to have the "ROLE_USER" 
                authority.  If either of those is violated, a <code class="code">FaultEvent</code> will be signaled on the client. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secured-endpoint-path"></a>6.3.2.&nbsp;Securing BlazeDS Channels by Endpoint URL Path</h3></div></div></div><p>
                You can set security constraints on multiple BlazeDS channels at once using the <code class="code">secured-endpoint-path</code> child element 
                of the <code class="code">secured</code> tag.  In this case you specify a URL pattern to be secured instead of a specific channel id.  For 
                example:  
            </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:secured</span>&gt;
        &lt;<span class="hl-tag">flex:secured-endpoint-path</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"**/messagebroker/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span> /&gt;
    &lt;<span class="hl-tag">/flex:secured</span>&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;
            </pre><p>
                This results in any request being routed to any channel whose endpoint URL contains "/messagebroker/" in the path to require the 
                user to be logged in and to have the "ROLE_USER" authority.  If either of those is violated, a <code class="code">FaultEvent</code> will be 
                signaled on the client. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="securing-destinations"></a>6.3.3.&nbsp;Securing Exported Spring Services</h3></div></div></div><p>
                Earlier in this chapter you saw an example of using the BlazeDS XML configuration to secure a BlazeDS-managed destination.  Since
                most of the time you will instead be defining destinations by exporting Spring beans using the <code class="code">remoting-destination</code>tag, an
                alternate approach to securing destinations is needed.  This is where Spring Security comes in, as all of its existing authorization
                mechanisms should "just work" when security integration is enabled using the <code class="code">secured</code> tag.   
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                    When securing destinations as in the examples shown below, it is important to keep in mind that this feature of Spring Security is
                    using Spring AOP.  By default, Spring AOP uses JDK dynamic proxies.  As such, if you have need to secure methods on a class that are 
                    not part of an interface that the class implements, then you will need either factor those methods out into an interface, or configure 
                    Spring to use CGLIB-based proxies instead.  See the following Spring documentation references for futher guidance:
                    </p><div class="orderedlist"><ol type="1"><li><p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/aop.html#aop-introduction-proxies" target="_top">AOP Proxies</a></p></li><li><p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/aop.html#aop-proxying" target="_top">Proxying Mechanisms</a></p></li></ol></div><p>
                </p></td></tr></table></div><p>
                One of the major strengths of Spring Security is the multiple levels of granularity it provides you when securing your Spring services.  You can
                go from securing your entire service layer in one concise statement:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">global-method-security</span>&gt;
    &lt;<span class="hl-tag">protect-pointcut</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"execution(* com.mycompany.*Service.*(..))"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span>/&gt;
&lt;<span class="hl-tag">/global-method-security</span>&gt;
            </pre><p>
                to controlling access in a more fine-grained manner at the method layer using XML:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.mycompany.myapp.MyService"</span>&gt;
    &lt;<span class="hl-tag">flex:remoting-destination</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-methods</span>&gt;
        &lt;<span class="hl-tag">security:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"set*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_ADMIN"</span> /&gt;
        &lt;<span class="hl-tag">security:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"get*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_ADMIN,ROLE_USER"</span> /&gt;
        &lt;<span class="hl-tag">security:protect</span> <span class="hl-attribute">method</span>=<span class="hl-value">"doSomething"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span> /&gt;
    &lt;<span class="hl-tag">/security:intercept-methods</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
            </pre><p>
                to using a combination of XML and annotations:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">security:global-method-security</span> <span class="hl-attribute">secured-annotations</span>=<span class="hl-value">"enabled"</span> <span class="hl-attribute">jsr250-annotations</span>=<span class="hl-value">"enabled"</span>/&gt;
...
&lt;<span class="hl-tag">flex:remoting-destination</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myBankServiceImpl"</span> /&gt;
  

            </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> BankService {
  
    @Secured(<span class="hl-string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>)
    <span class="hl-keyword">public</span> Account readAccount(Long id);
  
    @Secured(<span class="hl-string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>)
    <span class="hl-keyword">public</span> Account[] findAccounts();
  
    @Secured(<span class="hl-string">"ROLE_TELLER"</span>)
    <span class="hl-keyword">public</span> Account post(Account account, <span class="hl-keyword">double</span> amount);
}

            </pre><p>
                to even more fine-grained ACL-based domain object permissions.  For more details on the options available, see the Spring Security
                documentation.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="messaging"></a>Chapter&nbsp;7.&nbsp;Integration with the BlazeDS Message Service</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="messaging-introduction"></a>7.1.&nbsp;Introduction</h2></div></div></div><p>
            The BlazeDS <code class="code">MessageService</code> provides a common abstraction for asynchronous messaging style communication
            that is ultimately agnostic to the messaging protocol being used on the server side.  Messages can be passed 
            exclusively between Flex clients, from Java POJOs to subscribed Flex clients, from Flex clients to POJO message
            handlers, or between just about any combination thereof. Using the Spring-managed <code class="code">MessageBroker</code> enables support for using 
            BlazeDS-native AMF messaging, JMS messaging based on Spring's proven and simple JMS abstractions, 
            or messaging using Spring Integration's <code class="code">MessageChannel</code> abstraction, all from a common programming model.    
        </p><p>
            The same <code class="code">Consumer</code> and <code class="code">Producer</code> APIs are used to interact with message destinations from the Flex client, regardless 
            of which underlying messaging protocol is being used on the server.  As such, this chapter will focus mainly on setting up and using the various
            message destination types on the server side.  For more details on how to use the <code class="code">Consumer</code> and <code class="code">Producer</code> APIs in the client,
            see the BlazeDS documentation.    
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-service-config"></a>7.2.&nbsp;Configuring the Message Service</h2></div></div></div><p>
            The BlazeDS <code class="code">MessageService</code> has traditionally been configured by the inclusion of a messaging-config.xml file in the BlazeDS XML configuration.  
            When using only Spring-managed message destinations, this config file can be left out completely as the inclusion of the <code class="code">message-broker</code> tag
            in your Spring configuration will cause the <code class="code">MessageService</code> to be configured with sensible defaults if none already exists at startup
            time.  The end result is essentially equivalent to including the following minimal messaging-config.xml in your BlazeDS configuration:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">service</span> <span class="hl-attribute">id</span>=<span class="hl-value">"message-service"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.services.MessageService"</span>&gt;

    &lt;<span class="hl-tag">adapters</span>&gt;
        &lt;<span class="hl-tag">adapter-definition</span> <span class="hl-attribute">id</span>=<span class="hl-value">"actionscript"</span> 
            <span class="hl-attribute">class</span>=<span class="hl-value">"flex.messaging.services.messaging.adapters.ActionScriptAdapter"</span> 
            <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span>/&gt;
    &lt;<span class="hl-tag">/adapters</span>&gt;

    &lt;<span class="hl-tag">default-channels</span>&gt;
        &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"my-polling-amf"</span>/&gt;
    &lt;<span class="hl-tag">/default-channels</span>&gt;
    
&lt;<span class="hl-tag">/service</span>&gt;       
        </pre><p>
            Note that this assumes that there is already an equivalent application-wide <code class="code">default-channels</code> configuration.  It is recommended that
            you set the desired service-specific channels (see example below) if not relying on an application-wide default setup.  If no application-wide
            defaults exist, a best guess will be made by configuring the first available channel from the <code class="code">MessageBroker</code> that uses an 
            <code class="code">AMFEndpoint</code> with polling enabled as the default for the <code class="code">MessageService</code>.  
        </p><p>
            If you wish to have more explicit control over the defaults that will be set on the <code class="code">MessageService</code>, you can customize them
            via the <code class="code">message-service</code> child element of the <code class="code">message-broker</code> tag.  For example:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span>&gt;
    &lt;<span class="hl-tag">flex:message-service</span> <span class="hl-attribute">default-adapter-id</span>=<span class="hl-value">"my-default-messaging-adapter"</span> 
        <span class="hl-attribute">default-channels</span>=<span class="hl-value">"my-polling-amf"</span> /&gt;
&lt;<span class="hl-tag">/flex:message-broker</span>&gt;
        </pre><p>
            If you have an existing messaging-config.xml for a legacy BlazeDS application, the <code class="code">MessageDestinationFactory</code> will be able to work transparently 
            with it, allowing you to gradually migrate to all Spring-managed messaging destinations.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="actionscript-messaging"></a>7.3.&nbsp;Using AMF Message Destinations</h2></div></div></div><p>
            For simple messaging needs where there are no requirements for message durability, transaction support, or advanced routing logic, the BlazeDS-native 
            AMF-based message destination is the ideal choice.  These destinations can be fully configured in a Spring application context using the 
            <code class="code">message-destination</code> XML namespace tag.  For example, assuming a Spring-managed <code class="code">MessageBroker</code> has been configured, all that is
            needed to set up a basic destination named "event-bus" with default settings is the following:  
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"event-bus"</span> /&gt;      
        </pre><p>
            This sets up a destination to use the BlazeDS <code class="code">ActionScriptAdapter</code> to handle incoming messages.  The settings of the destination can be
            further customized through the various attributes of the <code class="code">message-destination</code> tag.  Here is an example of the "event-bus" destination configured 
            with most of the available attributes:    
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"event-bus"</span> 
    <span class="hl-attribute">message-broker</span>=<span class="hl-value">"messageServiceBroker"</span>
    <span class="hl-attribute">channels</span>=<span class="hl-value">"my-polling-amf, my-secure-amf"</span> 
    <span class="hl-attribute">allow-subtopics</span>=<span class="hl-value">"true"</span> 
    <span class="hl-attribute">cluster-message-routing</span>=<span class="hl-value">"broadcast"</span> 
    <span class="hl-attribute">message-time-to-live</span>=<span class="hl-value">"1"</span> 
    <span class="hl-attribute">send-security-constraint</span>=<span class="hl-value">"fooConstraint"</span> 
    <span class="hl-attribute">subscribe-security-constraint</span>=<span class="hl-value">"barConstraint"</span> 
    <span class="hl-attribute">subscription-timeout-minutes</span>=<span class="hl-value">"1"</span> 
    <span class="hl-attribute">subtopic-separator</span>=<span class="hl-value">"/"</span> 
    <span class="hl-attribute">throttle-inbound-max-frequency</span>=<span class="hl-value">"500"</span>
    <span class="hl-attribute">throttle-inbound-policy</span>=<span class="hl-value">"ERROR"</span> 
    <span class="hl-attribute">throttle-outbound-max-frequency</span>=<span class="hl-value">"500"</span> 
    <span class="hl-attribute">throttle-outbound-policy</span>=<span class="hl-value">"IGNORE"</span> /&gt;     
        </pre><p>
            The <code class="code">message-broker</code> attribute is a reference to the id of a Spring-managed <code class="code">MessageBroker</code>.  The <code class="code">channels</code> attribute allows
            you to specify a comma-delimited list of the BlazeDS channels to be used (in order of preference) for this destination.  The remaining attributes correspond
            to the options available via the <code class="code">network</code> and <code class="code">server</code> settings when configuring a message destination in the BlazeDS-specific XML.  
            Each of these additional attributes is documented in the XSD to provide live code-completion assistance.  For additional details on their usage, see
            the BlazeDS documentation.  The <code class="code">message-destination</code> tag serves as a base for the <code class="code">jms-message-destination</code> and 
            <code class="code">integration-message-destination</code> tags so that the same configuration options are available no matter the type of the underlying 
            <code class="code">MessagingAdapter</code>.
        </p><p> 
            The only attribute available on the <code class="code">message-destination</code> tag that is not available in the JMS and Spring Integration implementations is the 
            <code class="code">service-adapter</code> attribute, which can be used to provide a custom <code class="code">ServiceAdapter</code> via a reference to a 
            <code class="code">ManageableComponentFactoryBean</code>.  This can be used to provide integration with additional messaging protocols not directly supported by
            Spring BlazeDS Integration.  See <a href="#service-adapters" title="2.10.&nbsp;Providing Custom Service Adapters">Providing Custom Service Adapters</a> for additional information on using the
            <code class="code">ManageableComponentFactoryBean</code>.  
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-messaging"></a>7.4.&nbsp;Using JMS Message Destinations</h2></div></div></div><p>
            For integration with JMS, a special <code class="code">JmsAdapter</code> is provided that internally makes use of Spring's <code class="code">JmsTemplate</code>, <code class="code">DestinationResolver</code>, 
            <code class="code">DefaultMessageListenerContainer</code> and other such JMS abstractions for simplified interaction with JMS resources.  The <code class="code">jms-message-destination</code> XML namespace 
            tag is used to expose JMS destinations as BlazeDS message destinations.  The minimal attributes that must be specified are the destination <code class="code">id</code> 
            and exactly one of <code class="code">jms-destination</code>, <code class="code">queue-name</code>, or <code class="code">topic-name</code>.  A JMS <code class="code">ConnectionFactory</code> reference is also
            required, but does not have to be explicitly specified if there is already one configured in the current application context with an id of "connectionFactory".  
            For example, to configure a BlazeDS message destination named "chatIn" that uses a Spring-managed ActiveMQ JMS queue with a local ActiveMQ installation:   
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"brokerURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tcp://localhost:61616"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
    
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"chatInQueue"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"queue.flex.chat.in"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">flex:jms-message-destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"chatIn"</span> <span class="hl-attribute">jms-destination</span>=<span class="hl-value">"chatInQueue"</span> /&gt;       
        </pre><p>
            Using <code class="code">queue-name</code> or <code class="code">topic-name</code> will cause the destination to be resolved using a Spring <code class="code">DestinationResolver</code>.  
            The <code class="code">destination-resolver</code>, <code class="code">message-converter</code>, and <code class="code">transaction-manager</code> attributes may be used to set custom references 
            to a Spring-managed <code class="code">DestinationResolver</code>, <code class="code">MessageConverter</code>, or <code class="code">TransactionManager</code> respectively.    
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-messaging"></a>7.5.&nbsp;Using Spring Integration Message Destinations</h2></div></div></div><p>
            For routing messages with Spring Integration, a special <code class="code">IntegrationAdapter</code> is provided that is able to send/receive messages via a 
            <code class="code">MessageChannel</code>.  This is especially useful when you have more complex routing needs for your messages, such as connecting to email or FTP 
            endpoints.  The <code class="code">integration-message-destination</code> XML namespace tag is used to expose a Spring Integration <code class="code">MessageChannel</code> as a 
            BlazeDS message destination. For example, to configure a BlazeDS message destination named "chatOut" that uses a Spring Integration 
            <code class="code">PublishSubscribeChannel</code>:  
        </p><pre class="programlisting">
&lt;<span class="hl-tag">integration:publish-subscribe-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"chatOutPubSubChannel"</span> /&gt;

&lt;<span class="hl-tag">flex:integration-message-destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"chatOut"</span> <span class="hl-attribute">message-channel</span>=<span class="hl-value">"chatOutPubSubChannel"</span> /&gt;
        </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-template"></a>7.6.&nbsp;Sending AMF Messages with the MessageTemplate</h2></div></div></div><p>
            A convenient <code class="code">MessageTemplate</code> helper class is provided that allows you to push messages to any BlazeDS <code class="code">MessageDestination</code> from a simple
            POJO.  This provides a nice abstraction over push style messaging that hides away the details of the underlying messaging protocol.  Whether using a simple 
            AMF based destination or full-blown JMS, etc., the use of the <code class="code">MessageTemplate</code> stays the same.  The only thing the <code class="code">MessageTemplate</code> requires 
            is a reference to a Spring-managed <code class="code">MessageBroker</code>.  If the <code class="code">MessageTemplate</code> is configured as a Spring bean, it will try and auto-detect 
            the <code class="code">MessageBroker</code> from its application context.  
        </p><p>
            As an example of how the <code class="code">MessageTemplate</code> could be used, suppose we have a RESTful travel application that has a Flex-based admin console but also 
            exposes an API over HTTP.  To give the admin console a "live" view of the data, we want to push updates to it anytime a new hotel booking is created.  Given the 
            following setup in our application context:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">flex:message-broker</span> /&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultMessageTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.flex.messaging.MessageTemplate"</span> /&gt;

&lt;<span class="hl-tag">flex:message-destination</span> <span class="hl-attribute">id</span>=<span class="hl-value">"bookingUpdates"</span> /&gt;
        </pre><p>
            and assuming the Flex client is subscribed to the "bookingUpdates" destination, this could be achieved with the following controller code:
        </p><pre class="programlisting">
@Controller
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BookingController {
    
    <span class="hl-keyword">private</span> MessageTemplate template;
    
    <span class="hl-keyword">private</span> BookingService bookingService;
    
    @RequestMapping(value=<span class="hl-string">"/bookings"</span>, method=RequestMethod.POST)
    <span class="hl-keyword">public</span> String createBooking(Booking booking){
        booking = bookingService.saveBooking(booking);
        template.send(<span class="hl-string">"bookingUpdates"</span>, booking);
        <span class="hl-keyword">return</span> <span class="hl-string">"redirect:/bookings/"</span>+booking.getId();
    }
    
    @Autowired
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTemplate(MessageTemplate template) {
        <span class="hl-keyword">this</span>.template = template;
    }
    
    @Autowired
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBookingService(BookingService bookingService) {
        <span class="hl-keyword">this</span>.bookingService = bookingService;
    }
}
        </pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="samples"></a>Chapter&nbsp;8.&nbsp;Building and Running the Spring BlazeDS Integration Samples</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples-introduction"></a>8.1.&nbsp;Introduction</h2></div></div></div><p>
            Included in the project distribution is a collection of samples called the Spring BlazeDS Integration Test Drive.  This samples project is set up 
            to be built with Maven and either run via an embedded Tomcat instance using the Maven Tomcat plugin, or else imported into Eclipse for running via WTP.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="building-with-maven"></a>8.1.1.&nbsp;Maven Setup</h3></div></div></div><p>
                The sample build requires Maven 2.2.0 or greater.  Because the build compiles several seperate Flex and AIR projects, it can require setting the MAVEN_OPTS 
                variable for your environment to allocate more memory than the default.  The setting we find works well is:
            </p><pre class="programlisting">
MAVEN_OPTS="-Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m"

            </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="samples-build"></a>8.1.2.&nbsp;Building and Running the Test Drive</h3></div></div></div><p>
                Once your Maven environment is set up correctly, cd to {project distribution root}/samples/spring-flex-testdrive and execute:
            </p><pre class="programlisting">
mvn clean install

            </pre><p>
                This will first build all of the individual Flex projects and then finally assemble the 'testdrive' WAR project.  After building successfully, if you'd like to 
                run the application from the command line with an embedded Tomcat instance, execute:
            </p><pre class="programlisting">
mvn tomcat:run

            </pre><p>
                Once the application has started successfully, you can access the samples walk-through at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://localhost:8080/testdrive/index.html" target="_top">http://localhost:8080/testdrive/index.html</a>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="blazeds-4-maven"></a>8.1.3.&nbsp;Using BlazeDS 4 with Maven</h3></div></div></div><p>
                Spring BlazeDS Integration 1.5 requires BlazeDS 4, but as of this writing the BlazeDS 4 artifacts have not yet been published to Maven central.  
                The artifacts have been published to the Spring External maven repository (as required for the Spring BlazeDS Integration automated builds).  Declaring a 
                dependency on the spring-flex-core-1.5.0.RELEASE jar *should* cause the BlazeDS 4 artifacts to be pulled down transitively from the Spring External repository, 
                but if you encounter any problems, add the following repository entry (either to settings.xml or to your project's pom.xml):
            </p><pre class="programlisting">
&lt;<span class="hl-tag">repository</span>&gt;
    &lt;<span class="hl-tag">id</span>&gt;spring-external&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">name</span>&gt;Spring External Repository&lt;<span class="hl-tag">/name</span>&gt;
    &lt;<span class="hl-tag">url</span>&gt;http://maven.springframework.org/external&lt;<span class="hl-tag">/url</span>&gt;
    &lt;<span class="hl-tag">releases</span>&gt;
        &lt;<span class="hl-tag">enabled</span>&gt;true&lt;<span class="hl-tag">/enabled</span>&gt;
    &lt;<span class="hl-tag">/releases</span>&gt;
    &lt;<span class="hl-tag">snapshots</span>&gt;
        &lt;<span class="hl-tag">enabled</span>&gt;false&lt;<span class="hl-tag">/enabled</span>&gt;
    &lt;<span class="hl-tag">/snapshots</span>&gt;
&lt;<span class="hl-tag">/repository</span>&gt;

            </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pre-built-samples"></a>8.1.4.&nbsp;Download the Pre-packaged Test Drive</h3></div></div></div><p>
                As a convenience for anyone who is adverse to using Maven and just wants to get the Test Drive up and running quickly in Eclipse, pre-packaged builds 
                of the Test Drive can be downloaded directly via the following links:
            </p><div class="itemizedlist"><ul type="disc"><li><p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring-flex/docs/1.5.x/samples/spring-flex-testdrive-spring3.zip" target="_top">Spring BlazeDS Integration Test Drive with Spring 3.0</a></p></li></ul></div><p>
               Unzip the download and then follow the directions below for importing into Eclipse, substituting the unzipped directory in place of the 
               {project distribution root}/spring-flex-samples/spring-flex-testdrive path.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="samples-eclipse"></a>8.1.5.&nbsp;Importing and Running the Test Drive in Eclipse</h3></div></div></div><p>
                The individual Test Drive projects are pre-configured to be imported in Eclipse and run with WTP.  (There are a number of individual projects, so you may want to consider creating a fresh
                workspace or at least create a new working set to manage the projects.)  We recommend using the free <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springsource.com/products/sts" target="_top">SpringSource Tool Suite</a> to work with the samples so that you can take full 
                advantage of its extensive Spring support, but any version of Eclipse 3.5+ with WTP should work.  
            </p><p>  
                To import the samples, select File-&gt;Import...-&gt;General-&gt;Existing Projects into Workspace and navigate to the
                {project distribution root}/spring-flex-samples/spring-flex-testdrive directory and import all of the projects found.
            </p><p>
                There is an individual project for each Flex sample, and one WTP project for the 'testdrive' WAR.  Once the projects have been imported, you can start the web application by selecting the 
                'testdrive' project, right-clicking and selecting Run As-&gt;Run on Server.  The samples have been most thoroughly tested in Tomcat 6.0, but should run in any Servlet 2.4 container that WTP supports.  Once 
                the application has started successfully, you can access the samples walk-through at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://localhost:8080/testdrive/index.html" target="_top">http://localhost:8080/testdrive/index.html</a> (If running on a server other than 
                Tomcat, change the port number as needed.)
            </p></div></div></div></div></body></html>