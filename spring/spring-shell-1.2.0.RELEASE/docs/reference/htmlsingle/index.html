<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Shell Documentation</title><link rel="stylesheet" href="css/manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Spring Shell Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="spring-shell-reference"></a>Spring Shell Documentation</h1></div><div><div class="authorgroup">
            <div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Pollack</span></h3><div class="affiliation">SpringSource</div></div>
            <div class="author"><h3 class="author"><span class="firstname">Costin</span> <span class="surname">Leau</span></h3><div class="affiliation">SpringSource</div></div>
            <div class="author"><h3 class="author"><span class="firstname">Jarred</span> <span class="surname">Li</span></h3><div class="affiliation">VMware</div></div>
        </div></div><div><p class="releaseinfo">1.2.0.RELEASE</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d4e20"></a>
            <p>
                Copies of this document may be made for your own use and for distribution
                to others, provided that you do not charge any fee for such copies and
                further provided that each copy contains this Copyright Notice, whether
                distributed in print or electronically.
            </p>
        </div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#introduction">I. Introduction</a></span></dt><dd><dl><dt><span class="chapter"><a href="#requirements">1. Requirements</a></span></dt></dl></dd><dt><span class="part"><a href="#reference">II. Reference Documentation</a></span></dt><dd><dl><dt><span class="chapter"><a href="#shell">2. Spring Shell</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e58">2.1. Plugin Model</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e73">2.1.1. Commands</a></span></dt><dt><span class="section"><a href="#d4e85">2.1.2. Converters</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e94">2.2. Built in commands</a></span></dt><dt><span class="section"><a href="#d4e140">2.3. Customizing the shell</a></span></dt><dt><span class="section"><a href="#d4e162">2.4. Communicating between plugins</a></span></dt><dt><span class="section"><a href="#d4e166">2.5. Command method interception</a></span></dt><dt><span class="section"><a href="#d4e173">2.6. Command line options</a></span></dt><dt><span class="section"><a href="#d4e191">2.7. Scripts and comments</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#dev">III. Developing Spring Shell Applications</a></span></dt><dd><dl><dt><span class="chapter"><a href="#dev-shell">3. Developing Spring Shell Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e207">3.1. Marker Interface</a></span></dt><dt><span class="section"><a href="#d4e215">3.2. Logging</a></span></dt><dt><span class="section"><a href="#d4e220">3.3. CLI Annotations</a></span></dt><dt><span class="section"><a href="#d4e253">3.4. Testing shell commands</a></span></dt><dt><span class="section"><a href="#d4e260">3.5. Building and running the shell</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#samples">IV. Spring Shell Sample application</a></span></dt><dd><dl><dt><span class="chapter"><a href="#simple-application">4. Simple sample application using the Spring Shell</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e274">4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e288">4.2. HelloWorldCommands</a></span></dt></dl></dd></dl></dd></dl></div>

    

    
    
    <div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div>
  

  <p>The Spring Shell provides an interactive shell that allows you to
  plugin your own custom commands using a Spring based programming
  model.</p>

  <p>The shell has been extracted from the <a class="ulink" href="http://www.springsource.org/spring-roo/" target="_top">Spring Roo
  project</a>, giving it a strong foundation and rich feature set. One
  significant change from Spring Roo is that the plugin model is no longer
  based on OSGi but instead uses the Spring IoC container to discover commands
  through classpath scanning. There is currently no classloader isolation
  between plugins, however that maybe added in future versions.</p>

  <p>Spring Shell's features include</p>

  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
      <p>A simple, annotation driven, programming model to contribute
      custom commands</p>
    </li><li class="listitem">
      <p>Use of Spring's classpath scanning functionality as the basis for
      a command plugin strategy and command development</p>
    </li><li class="listitem">
      <p>Inheritance of the <a class="ulink" href="http://static.springsource.org/spring-roo/reference/html-single/index.html#usage-shell" target="_top">Roo
      Shell features</a>, most notably tab completion, colorization, and
      script execution.</p>
    </li><li class="listitem">
      <p>Customization of command prompt, banner, shell history file
      name.</p>
    </li></ul></div>

  <p>This document assumes that the reader already has a basic familiarity
  with the Spring Framework.</p>

  <p>While every effort has been made to ensure that this documentation is
  comprehensive and there are no errors, nevertheless some topics might
  require more explanation and some typos might have crept in. If you do spot
  any mistakes or even more serious errors and you can spare a few cycles
  during lunch, please do bring the error to the attention of the Spring Shell
  team by <a class="ulink" href="https://jira.springsource.org/browse/SHL" target="_top">raising an
  issue</a>.</p>
</div>

    <div class="part" title="Part&nbsp;I.&nbsp;Introduction"><div class="titlepage"><div><div><h1 class="title"><a name="introduction"></a>Part&nbsp;I.&nbsp;Introduction</h1></div></div></div>
             
      <div class="partintro" title="Introduction"><div></div>
  <p>The Spring Shell provides an interactive shell that lets you
  contribute commands using a simple Spring based programming model.</p>

  <p>This document is the reference guide for the Spring Shell and covers
  the key classes that are part of the Shell infrastructure, the plugin model,
  how to create commands for the shell as well as discussion of the sample
  application.</p>
</div>
      <div class="chapter" title="1.&nbsp;Requirements"><div class="titlepage"><div><div><h2 class="title"><a name="requirements"></a>1.&nbsp;Requirements</h2></div></div></div>
  

  <p>The Spring Shell requires JDK level 6.0 and above as well as the
  <a class="ulink" href="http://www.springsource.org/about" target="_top">Spring Framework</a> 3.0
  (3.1 recommended) and above.</p>
</div>
    </div>

    <div class="part" title="Part&nbsp;II.&nbsp;Reference Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="reference"></a>Part&nbsp;II.&nbsp;Reference Documentation</h1></div></div></div>
             
      <div class="partintro" title="Reference Documentation"><div></div><p>This part of the reference documentation explains the core components
  of the Spring Shell.</p></div>
      <div class="chapter" title="2.&nbsp;Spring Shell"><div class="titlepage"><div><div><h2 class="title"><a name="shell"></a>2.&nbsp;Spring Shell</h2></div></div></div>
  

  <p>The core components of the shell are its plugin model, built-in
  commands, and converters.</p>

  <div class="section" title="2.1&nbsp;Plugin Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e58"></a>2.1&nbsp;Plugin Model</h2></div></div></div>
    

    <p>The plugin model is based on Spring. Each plugin jar is required to
    contain the file
    <code class="literal">META-INF/spring/spring-shell-plugin.xml</code>. These files
    will be loaded to bootstrap a Spring
    <code class="interfacename">ApplicationContext</code> when the shell is
    started. The essential boostrapping code that looks for your contributions
    looks like this: </p><pre class="programlisting">new ClassPathXmlApplicationContext("classpath*:/META-INF/spring/spring-shell-plugin.xml");</pre>

    <p>In the <code class="literal">spring-shell-plugin.xml</code> file you should
    define the command classes and any other collaborating objects that
    support the command's actions. The plugin model is depicted in the
    following diagram</p>

    <div class="mediaobject"><img src="images/shell-arch-overview.png"></div>

    <p>Note that the current plugin model loads all plugins under the same
    class loader. An open <a class="ulink" href="https://jira.springsource.org/browse/SHL-37" target="_top">JIRA issue</a>
    suggests providing a classloader per plugin to provide isolation.</p>

    <div class="section" title="2.1.1&nbsp;Commands"><div class="titlepage"><div><div><h3 class="title"><a name="d4e73"></a>2.1.1&nbsp;Commands</h3></div></div></div>
      

      <p>An easy way to declare the commands is to use Spring's component
      scanning functionality. Here is an example
      <code class="literal">spring-shell-plugin.xml </code> from the sample
      application:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context 
       http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;context:component-scan</span> 
           <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.springframework.shell.samples.helloworld.commands"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <p>The commands are Spring components, demarcated as such using the
      <code class="literal">@Component</code> annotation. For example, the shell of the
      <code class="classname">HelloWorldCommands</code> class from the sample
      application looks like this</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {

  <span class="hl-comment">// use any Spring annotations for Dependency Injection or other Spring </span>
  <span class="hl-comment">// interfaces as required.</span>

  <span class="hl-comment">// methods with @Cli annotations go here</span>

}</pre>

      <p>Once the commands are registered and instantiated by the Spring
      container, they are registered with the core shell parser so that the
      <code class="literal">@Cli</code> annotations can be processed. The way the
      commands are identified is through the use of the
      <code class="interfacename">CommandMarker</code> interface.</p>
    </div>

    <div class="section" title="2.1.2&nbsp;Converters"><div class="titlepage"><div><div><h3 class="title"><a name="d4e85"></a>2.1.2&nbsp;Converters</h3></div></div></div>
      

      <p>The
      <code class="interfacename">org.springframework.shell.core.Converter</code>
      interface provides the contract to convert the strings that are entered
      on the command line to rich Java types passed into the arguments of
      <code class="classname">@Cli</code>-annotated methods.</p>

      <p>By default converters for common types are registered. These cover
      primitive types (boolean, int, float...) as well as Date, Character, and
      File.</p>

      <p>If you need to register any additional
      <code class="interfacename">Converter</code> instances, register them with
      the Spring container in the
      <code class="classname">spring-shell-plugin.xml</code> file and they will be
      picked up automatically.</p>
    </div>
  </div>

  <div class="section" title="2.2&nbsp;Built in commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e94"></a>2.2&nbsp;Built in commands</h2></div></div></div>
    

    <p>There are a few built in commands. Here is a listing of their class
    name and functionality</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="classname">ConsoleCommands</code> -
        <code class="literal">clr</code> and <code class="literal">clear</code> - to clear the console.</p>
      </li><li class="listitem">
        <p><code class="classname">DateCommands</code> -
        <code class="literal">date</code> - show the current date and time.</p>
      </li><li class="listitem">
        <p><code class="classname">ExitCommands</code> -
        <code class="literal">exit</code> and <code class="literal">quit</code> - to exit the
        shell.</p>
      </li><li class="listitem">
        <p><code class="classname">HelpCommands</code> - <code class="literal">help</code> -
        list all commands and their usage</p>
      </li><li class="listitem">
        <p><code class="classname">InlineCommentCommands</code> - <code class="literal">//</code> and <code class="literal">;</code> shows the valid characters to use for inline comments</p>
      </li><li class="listitem">
        <p><code class="classname">OsCommands</code> - the keyword for this command
        is the exclamation point, <code class="literal">!</code>. After the exclamation
        point you can pass in a unix/windows command string to be
        executed.</p>
      </li><li class="listitem">
        <p><code class="classname">SystemPropertyCommands</code> - <code class="literal">system properties</code>- shows the shell's system properties</p>
      </li><li class="listitem">
        <p><code class="classname">VersionCommands</code> - <code class="literal">version</code>- shows the shell's version</p>
      </li></ul></div>

    <p>There are two commands in provided by the
    <code class="classname">AbstractShell</code> class related to useage of block comments</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="literal">/*</code> and <code class="literal">*/</code>- The begin and end characters for block comments</p>
      </li></ul></div>
  </div>

  <div class="section" title="2.3&nbsp;Customizing the shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e140"></a>2.3&nbsp;Customizing the shell</h2></div></div></div>
    

    <p>There are a few extension points that allow you to customize the
    shell. The extension points are the interfaces</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="interfacename">BannerProvider</code> - Specifies the
        banner text, welcome message, and version number that will be
        displayed when the shell is started</p>
      </li><li class="listitem">
        <p><code class="interfacename">PromptProvider</code> - Specifies the
        command prompt text, eg. "<code class="literal">shell&gt;</code>" or
        "<code class="literal">#</code>" or "<code class="literal">$</code>". This will be called
        after every command execution so it does not need to be a static
        string.</p>
      </li><li class="listitem">
        <p><code class="interfacename">HistoryFileNameProvider</code> -
        Specifies the name of the command history file</p>
      </li></ul></div>

    <p>There is a default implementation for these interfaces but you
    should create your own implementations for your own shell application.
    All of these interfaces extend from 
    <code class="interfacename">NamedProvider</code>.  Use
    Spring's <code class="literal">@Order</code> annotation to set the priority of the
    provider. This allows your provider implementations to take precedence
    over any other implementations that maybe present on the classpath from
    other plugins.</p>

    <p>To make cool "<a class="ulink" href="http://en.wikipedia.org/wiki/ASCII_art" target="_top">ASCII art</a>"
    banners the website <a class="ulink" href="http://patorjk.com/software/taag" target="_top">http://patorjk.com/software/taag</a>
    is quite neat!</p>
  </div>

  <div class="section" title="2.4&nbsp;Communicating between plugins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e162"></a>2.4&nbsp;Communicating between plugins</h2></div></div></div>
    

    <p>As this is a standard Spring application you can use Spring's
    <code class="classname">ApplicationContext</code> event infrastructure to
    communicate across plugins.</p>
  </div>

  <div class="section" title="2.5&nbsp;Command method interception"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e166"></a>2.5&nbsp;Command method interception</h2></div></div></div>
    

    <p>It has shown to be useful to provide a simple form of interception
    around the invocation of a command method. This enables the command class
    to check for updates to state, such as configuration information modified
    by other plugins, before the command method is executed. The interface
    <code class="interfacename">ExecutionProcessor</code> should be implemented
    instead of <code class="interfacename">CommandMarker</code> to access this
    functionality. The <code class="interfacename">ExecutionProcessor</code>
    interface is shown below</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ExecutionProcessor <span class="hl-keyword">extends</span> CommandMarker {

 <b class="hl-tag" style="color: blue">/**
  * Method called before invoking the target command (described by {@link ParseResult}).
  * Additionally, for advanced cases, the parse result itself effectively changing the 
  * invocation calling site.
  * 
  * @param invocationContext target command context
  * @return the invocation target 
  */</b>
 ParseResult beforeInvocation(ParseResult invocationContext);

 <b class="hl-tag" style="color: blue">/**
  * Method called after successfully invoking the target command (described by 
  * {@link ParseResult}).
  * 
  * @param invocationContext target command context
  * @param result the invocation result
  */</b>
 <span class="hl-keyword">void</span> afterReturningInvocation(ParseResult invocationContext, Object result);

 <b class="hl-tag" style="color: blue">/**
  * Method called after invoking the target command (described by {@link ParseResult}) 
  * had thrown an exception .
  * 
  * @param invocationContext target command context
  * @param thrown the thrown object
  */</b>
 <span class="hl-keyword">void</span> afterThrowingInvocation(ParseResult invocationContext, Throwable thrown);

}</pre>
  </div>

  <div class="section" title="2.6&nbsp;Command line options"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e173"></a>2.6&nbsp;Command line options</h2></div></div></div>
    

    <p>There are a few command line options that can be specified when
    starting the shell. They are</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="literal">--profiles</code> - Specifies values for the system
        property spring.profiles.active so that Spring 3.1 and greater <a class="ulink" href="http://blog.springsource.com/2011/02/11/spring-framework-3-1-m1-released/" target="_top">profile
        support </a>is enabled.</p>
      </li><li class="listitem">
        <p><code class="literal">--cmdfile</code> - Specifies a file to read that
        contains shell commands</p>
      </li><li class="listitem">
        <p><code class="literal">--histsize</code> - Specifies the maximum number of
        lines to store in the command history file. Default value is
        3000.</p>
      </li><li class="listitem">
        <p><code class="literal">--disableInternalCommands</code> - Flag that disables all commands that would
	be pre-registered with the shell.  There is no argument to this option.  You can selectively add
	back any internal commands by referencing them in your shell plugin file.  Look at the
	Spring Shell javadocs for specific commands located in the 
	<code class="literal">org.springframework.shell.commands</code> package as well as the section in this documentation
	of Built in commands.</p>
      </li></ul></div>
  </div>

  <div class="section" title="2.7&nbsp;Scripts and comments"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e191"></a>2.7&nbsp;Scripts and comments</h2></div></div></div>
    

    <p>Scripts can be executed either by passing in the
    <code class="literal">--cmdfile</code> argument at startup or by executing the
    <code class="literal">script</code> command inside the shell. When using scripts it
    helps to add comments and this can be done using block comments that start
    and end with <code class="literal">/*</code> and <code class="literal">*/</code> or an inline
    one line comment using the <code class="literal">//</code> or <code class="literal">;</code>
    characters.</p>
  </div>
</div>
    </div>

    <div class="part" title="Part&nbsp;III.&nbsp;Developing Spring Shell Applications"><div class="titlepage"><div><div><h1 class="title"><a name="dev"></a>Part&nbsp;III.&nbsp;Developing Spring Shell Applications</h1></div></div></div>
      
      <div class="partintro" title="Developing Spring Shell Applications"><div></div><p>This section provides some guidance on how one can create commands for
  the Spring Shell.</p></div>
      <div class="chapter" title="3.&nbsp;Developing Spring Shell Applications"><div class="titlepage"><div><div><h2 class="title"><a name="dev-shell"></a>3.&nbsp;Developing Spring Shell Applications</h2></div></div></div>
  

  <p>Contributing commands to the shell is very easy. There are only a few
  annotations you need to learn. The implementation style of the command is
  the same as developing classes for an application that uses dependency
  injection. You can leverage all the features of the Spring container to
  implement your command classes.</p>

  <div class="section" title="3.1&nbsp;Marker Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e207"></a>3.1&nbsp;Marker Interface</h2></div></div></div>
    

    <p>The first step to creating a command is to implement the marker
    interface <code class="interfacename">CommandMarker</code> and to annotate
    your class with Spring's <code class="classname">@Component </code>annotation.
    (Note there is an open JIRA issue to provide a
    <code class="classname">@CliCommand</code> meta-annotation to avoid having to use
    a marker interface). Using the code from the helloworld sample
    application, the code of a <code class="classname">HelloWorldCommands</code> class
    is shown below:</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {
 
  <span class="hl-comment">// use any Spring annotations for Dependency Injection or other Spring interfaces </span>
  <span class="hl-comment">// as required.</span>

  <span class="hl-comment">// methods with @Cli annotations go here  </span>

}</pre>
  </div>

  <div class="section" title="3.2&nbsp;Logging"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e215"></a>3.2&nbsp;Logging</h2></div></div></div>
    

    <p>Logging is currently done using JDK logging. Due to the intricacies
    of console, JLine and Ansi handling, it is generally advised to display
    messages as return values to the method commands. However, when logging is
    required, the typical JDK logger declaration should suffice.</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {
 
  <span class="hl-keyword">protected</span> <span class="hl-keyword">final</span> Logger LOG = Logger.getLogger(getClass().getName());

  <span class="hl-comment">// methods with @Cli annotations go here  </span>

}</pre>

    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/admon/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
       Note: it is the responsibility of the packager/developer to handle logging for third-party libraries. Typically one wants to reduce the logging level so the console/shell does not get affected by logging messages. 
    </td></tr></table></div>
  </div>

  <div class="section" title="3.3&nbsp;CLI Annotations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e220"></a>3.3&nbsp;CLI Annotations</h2></div></div></div>
    

    <p>There are three annotations used on methods and method arguments
    that define the main contract for interacting with the shell. These
    are:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="classname">CliAvailabilityIndicator</code> - Placed on a
        method that returns a boolean value and indicates if a particular
        command can be presented in the shell. This decision is usually based
        on the history of commands that have been executed previously. It
        prevents extraneous commands being presented until some preconditions
        are met, for example the execution of a 'configuration'
        command.</p>
      </li><li class="listitem">
        <p><code class="classname">CliCommand</code> - Placed on a method that
        provides a command to the shell. Its value provides one or more
        strings that serve as the start of a particular command name. These
        must be unique within the entire application, across all
        plugins.</p>
      </li><li class="listitem">
        <p><code class="classname">CliOption</code> - Placed on the arguments of a
        command method, allowing it to declare the argument value as mandatory
        or optional with a default value.</p>
      </li></ul></div>

    <p>Here is a simple use of these annotations in a command class</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {

  <i><span class="hl-annotation" style="color: gray">@CliAvailabilityIndicator({"hw simple"})</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isCommandAvailable() {
    <span class="hl-keyword">return</span> true;
  }

  <i><span class="hl-annotation" style="color: gray">@CliCommand(value = "hw simple", help = "Print a simple hello world message")</span></i>
  <span class="hl-keyword">public</span> String simple(
    <i><span class="hl-annotation" style="color: gray">@CliOption(key = { "message" }, mandatory = true, help = "The hello world message")</span></i> 
    <span class="hl-keyword">final</span> String message,
    
    <i><span class="hl-annotation" style="color: gray">@CliOption(key = { "location" }, mandatory = false, 
               help = "Where you are saying hello", specifiedDefaultValue="At work")</span></i> 
    <span class="hl-keyword">final</span> String location) {

    <span class="hl-keyword">return</span> <span class="hl-string">"Message = ["</span> + message + <span class="hl-string">"] Location = ["</span> + location + <span class="hl-string">"]"</span>;

  }
}</pre>

    <p>The method annotated with <code class="classname">@CliAvailabilityIndicator
    </code>is returning true so that the one and only command in this
    class is exposed to the shell to be invoked. If there were more commands
    in the class, you would list them as comma separated value.</p>

    <p>The <code class="classname">@CliCommand</code> annotation is creating the
    command '<code class="literal">hw simple</code>' in the shell. The help message is
    what will be printed if you use the build in <code class="literal">help</code>
    command. The method name is '<code class="methodname">simple</code>' but it could
    just have been any other name.</p>

    <p>The <code class="classname">@CliOption</code> annotation on each of the
    command arguments is where you will spend most of your time authoring
    commands. You need to decide which arguments are required, which are
    optional, and if they are optional is there a default value. In this case
    there are two arguments or options to the command: message and location.
    The message option is required and a help message is provided to give
    guidance to the user when tabbing to get completion for the
    command.</p>

    <p>The implementation of the '<code class="methodname">simple</code>' method
    is trivial, just a log statement, but this is where you would typically
    call other collaborating objects that were injected into the class via
    Spring.</p>

    <p>The method argument types in this example are
    <code class="classname">String</code>, which doesn't present any issue with type
    conversion. You can specify methods with any rich object type as well as
    basic primitive types such as int, float etc. For all types other than
    those handled by the shell by default (basic types,
    <code class="classname">Date</code>, <code class="classname">File</code>) you will need to
    register your own implementation of the
    <code class="interfacename">org.springframework.shell.core.Converter</code>
    interface with the container in your plugin.</p>

    <p>Note that the method return argument can be non-void - in our
    example, it is the actual message we want to display. Whenever an object
    is returned, the shell will display its <code class="literal">toString()</code>
    representation.</p>
  </div>
  
  <div class="section" title="3.4&nbsp;Testing shell commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e253"></a>3.4&nbsp;Testing shell commands</h2></div></div></div>
    

    <p>To perform a test of the shell commands you can instantiate the shell inside a test case,
    execute the command and then perform assertions on the return value CommandResult.
    A simple base class to set this up is shown below.</p>
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractShellIntegrationTest {

	<span class="hl-keyword">private</span> <span class="hl-keyword">static</span> JLineShellComponent shell;
	
	<i><span class="hl-annotation" style="color: gray">@BeforeClass</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> startUp() <span class="hl-keyword">throws</span> InterruptedException {
		Bootstrap bootstrap = <span class="hl-keyword">new</span> Bootstrap();		
		shell = bootstrap.getJLineShellComponent();
	}
	
	<i><span class="hl-annotation" style="color: gray">@AfterClass</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> shutdown() {
		shell.stop();
	}

	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> JLineShellComponent getShell() {
		<span class="hl-keyword">return</span> shell;
	}

}</pre>
    <p>Here is an example testing the Date command</p>
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BuiltInCommandTests <span class="hl-keyword">extends</span> AbstractShellIntegrationTest {
	
	<i><span class="hl-annotation" style="color: gray">@Test</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> dateTest() <span class="hl-keyword">throws</span> ParseException {
		
		<span class="hl-comment">//Execute command</span>
		CommandResult cr = getShell().executeCommand(<span class="hl-string">"date"</span>);
		
		<span class="hl-comment">//Get result   </span>
		DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL,Locale.US);
		Date result = df.parse(cr.getResult().toString());
		
		<span class="hl-comment">//Make assertions - DateMaters is an external dependency not shown here.</span>
		Date now = <span class="hl-keyword">new</span> Date();
		MatcherAssert.assertThat(now, DateMatchers.within(<span class="hl-number">5</span>, TimeUnit.SECONDS, result));		
	}
}</pre>
    <p>The java.lang.Class of CommandResult's getResult method will match that of the return value of
    the method annotated with @CliCommand.  You should cast to the appropriate type to help perform your assertions.
    </p>
  </div>
  <div class="section" title="3.5&nbsp;Building and running the shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e260"></a>3.5&nbsp;Building and running the shell</h2></div></div></div>
    

    <p>In our opinion, the easiest way to build and execute the shell is to
    cut-n-paste the gradle script in the example application. This uses the
    application plugin from gradle to create a bin directory with a startup
    script for windows and Unix and places all dependent jars in a lib
    directory. Maven has a similar plugin - the <a class="ulink" href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/" target="_top">AppAssembler</a>
    plugin.</p>

    <p>The main class of the shell is
    <code class="classname">org.springframework.shell.Bootstrap</code>. As long as you
    place other plugins, perhaps developed independently, on the classpath,
    the Bootstrap class will incorporate them into the shell.</p>
  </div>
</div>
    </div>

    <div class="part" title="Part&nbsp;IV.&nbsp;Spring Shell Sample application"><div class="titlepage"><div><div><h1 class="title"><a name="samples"></a>Part&nbsp;IV.&nbsp;Spring Shell Sample application</h1></div></div></div>
      
      <div class="partintro" title="Spring Shell Sample application"><div></div><p>This part of the reference documentation covers the sample
  applications included with Spring Shell that demonstrate the features in a
  code centric manner.</p><p><a class="xref" href="#simple-application" title="4.&nbsp;Simple sample application using the Spring Shell">Chapter&nbsp;4, <i>Simple sample application using the Spring Shell</i></a>Describes a simple Spring Shell
  application that echo's the command parameters to the console.</p></div>
      <div class="chapter" title="4.&nbsp;Simple sample application using the Spring Shell"><div class="titlepage"><div><div><h2 class="title"><a name="simple-application"></a>4.&nbsp;Simple sample application using the Spring Shell</h2></div></div></div>
  

  <div class="section" title="4.1&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e274"></a>4.1&nbsp;Introduction</h2></div></div></div>
    

    <p>The sample application named 'helloworld' contains three
    '<code class="literal">hw</code>' commands, they are '<code class="literal">hw simple</code>',
    '<code class="literal">hw complex</code>' and '<code class="literal">hw enum</code>' and
    demonstrate simple to intermediate level usage of the
    <code class="literal">@Cli</code> annotation classes for creating commands.</p>

    <p>The example code is located in the distribution directory
    <code class="literal">&lt;spring-shell-install-dir&gt;/samples/helloworld</code>.</p>

    <p>To build the example cd to the helloworld directory and execute
    <code class="literal">gradlew installApp</code> (you first need to add the <code class="literal">gradlew</code>
    gradle wrapper to your path). To run the application cd to
    <code class="literal">build\install\helloworld\bin</code> and execute the helloworld
    script.</p>
  </div>

  <div class="section" title="4.2&nbsp;HelloWorldCommands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e288"></a>4.2&nbsp;HelloWorldCommands</h2></div></div></div>
    

    <p>The <code class="classname">HelloWorldCommands</code> class is show
    below</p>

    <pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.shell.samples.helloworld.commands;

<span class="hl-keyword">import</span> org.springframework.shell.core.CommandMarker;
<span class="hl-keyword">import</span> org.springframework.shell.core.annotation.CliAvailabilityIndicator;
<span class="hl-keyword">import</span> org.springframework.shell.core.annotation.CliCommand;
<span class="hl-keyword">import</span> org.springframework.shell.core.annotation.CliOption;
<span class="hl-keyword">import</span> org.springframework.stereotype.Component;

<i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {
	
	<span class="hl-keyword">private</span> <span class="hl-keyword">boolean</span> simpleCommandExecuted = false;
	
	<i><span class="hl-annotation" style="color: gray">@CliAvailabilityIndicator({"hw simple"})</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isSimpleAvailable() {
		<span class="hl-comment">//always available</span>
		<span class="hl-keyword">return</span> true;
	}
	
	<i><span class="hl-annotation" style="color: gray">@CliAvailabilityIndicator({"hw complex", "hw enum"})</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isComplexAvailable() {
		<span class="hl-keyword">if</span> (simpleCommandExecuted) {
			<span class="hl-keyword">return</span> true;
		} <span class="hl-keyword">else</span> {
			<span class="hl-keyword">return</span> false;
		}
	}
		
	<i><span class="hl-annotation" style="color: gray">@CliCommand(value = "hw simple", help = "Print a simple hello world message")</span></i>
	<span class="hl-keyword">public</span> String simple(
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "message" }, mandatory = true, help = "The hello world message")</span></i> <span class="hl-keyword">final</span> String message,
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "location" }, mandatory = false, help = "Where you are saying hello", specifiedDefaultValue="At work")</span></i> <span class="hl-keyword">final</span> String location) {		
		simpleCommandExecuted = true;
		<span class="hl-keyword">return</span> <span class="hl-string">"Message = ["</span> + message + <span class="hl-string">"] Location = ["</span> + location + <span class="hl-string">"]"</span>;
	}
	
	<i><span class="hl-annotation" style="color: gray">@CliCommand(value = "hw complex", help = "Print a complex hello world message")</span></i>
	<span class="hl-keyword">public</span> String hello(
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "message" }, mandatory = true, help = "The hello world message")</span></i> <span class="hl-keyword">final</span> String message,
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "name1"}, mandatory = true, help = "Say hello to the first name")</span></i> <span class="hl-keyword">final</span> String name1,
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "name2" }, mandatory = true, help = "Say hello to a second name")</span></i> <span class="hl-keyword">final</span> String name2,
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "time" }, mandatory = false, specifiedDefaultValue="now", help = "When you are saying hello")</span></i> <span class="hl-keyword">final</span> String time,
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "location" }, mandatory = false, help = "Where you are saying hello")</span></i> <span class="hl-keyword">final</span> String location) {		
		<span class="hl-keyword">return</span> <span class="hl-string">"Hello "</span> + name1 + <span class="hl-string">" and "</span> + name2 + <span class="hl-string">". Your special message is "</span>  + message + <span class="hl-string">". time=["</span> + time + <span class="hl-string">"] location=["</span> + location + <span class="hl-string">"]"</span>;
	}
	
	<i><span class="hl-annotation" style="color: gray">@CliCommand(value = "hw enum", help = "Print a simple hello world message from an enumerated value")</span></i>
	<span class="hl-keyword">public</span> String eenum(
		<i><span class="hl-annotation" style="color: gray">@CliOption(key = { "message" }, mandatory = true, help = "The hello world message")</span></i> <span class="hl-keyword">final</span> MessageType message){		
		<span class="hl-keyword">return</span> <span class="hl-string">"Hello.  Your special enumerated message is "</span> + message;
	}
	
	enum MessageType {		
		Type1(<span class="hl-string">"type1"</span>),
		Type2(<span class="hl-string">"type2"</span>),
		Type3(<span class="hl-string">"type3"</span>);
		
		<span class="hl-keyword">private</span> String type;
		
		<span class="hl-keyword">private</span> MessageType(String type){
			<span class="hl-keyword">this</span>.type = type;
		}
		
		<span class="hl-keyword">public</span> String getType(){
			<span class="hl-keyword">return</span> type;
		}
	}
}
</pre>

    <p>The use of the <code class="classname">@CliAvailabilityIndicator</code>
    annotation on two methods, <code class="methodname">isSimpleAvailable</code> and
    <code class="methodname">isComplexAvailable</code> shows how you can enable the
    presence of the '<code class="literal">hw complex</code>' and '<code class="literal">hw
    enum</code>' commands only if the '<code class="literal">hw simple</code>'
    command was executed.</p>

    <p>Here is an example session showing the behavior.</p>

    <div class="mediaobject"><img src="images/shell-example.jpg"></div>

    <p>The '<code class="literal">hw enum</code>' command shows how the shell
    supports the use of an enumeration as command method arguments.</p>

    <div class="mediaobject"><img src="images/shell-example-enum.jpg"></div>
  </div>
</div>
    </div>

</div></body></html>