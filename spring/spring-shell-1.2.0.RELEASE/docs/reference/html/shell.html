<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Spring Shell</title><link rel="stylesheet" href="css/manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Shell Documentation"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="prev" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="next" href="dev.html" title="Part&nbsp;III.&nbsp;Developing Spring Shell Applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Spring Shell</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Reference Documentation</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="dev.html">Next</a></td></tr></table><hr></div><div class="chapter" title="2.&nbsp;Spring Shell"><div class="titlepage"><div><div><h2 class="title"><a name="shell"></a>2.&nbsp;Spring Shell</h2></div></div></div>
  

  <p>The core components of the shell are its plugin model, built-in
  commands, and converters.</p>

  <div class="section" title="2.1&nbsp;Plugin Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e58"></a>2.1&nbsp;Plugin Model</h2></div></div></div>
    

    <p>The plugin model is based on Spring. Each plugin jar is required to
    contain the file
    <code class="literal">META-INF/spring/spring-shell-plugin.xml</code>. These files
    will be loaded to bootstrap a Spring
    <code class="interfacename">ApplicationContext</code> when the shell is
    started. The essential boostrapping code that looks for your contributions
    looks like this: </p><pre class="programlisting">new ClassPathXmlApplicationContext("classpath*:/META-INF/spring/spring-shell-plugin.xml");</pre>

    <p>In the <code class="literal">spring-shell-plugin.xml</code> file you should
    define the command classes and any other collaborating objects that
    support the command's actions. The plugin model is depicted in the
    following diagram</p>

    <div class="mediaobject"><img src="images/shell-arch-overview.png"></div>

    <p>Note that the current plugin model loads all plugins under the same
    class loader. An open <a class="ulink" href="https://jira.springsource.org/browse/SHL-37" target="_top">JIRA issue</a>
    suggests providing a classloader per plugin to provide isolation.</p>

    <div class="section" title="2.1.1&nbsp;Commands"><div class="titlepage"><div><div><h3 class="title"><a name="d4e73"></a>2.1.1&nbsp;Commands</h3></div></div></div>
      

      <p>An easy way to declare the commands is to use Spring's component
      scanning functionality. Here is an example
      <code class="literal">spring-shell-plugin.xml </code> from the sample
      application:</p>

      <pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context 
       http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;context:component-scan</span> 
           <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.springframework.shell.samples.helloworld.commands"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>

      <p>The commands are Spring components, demarcated as such using the
      <code class="literal">@Component</code> annotation. For example, the shell of the
      <code class="classname">HelloWorldCommands</code> class from the sample
      application looks like this</p>

      <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {

  <span class="hl-comment">// use any Spring annotations for Dependency Injection or other Spring </span>
  <span class="hl-comment">// interfaces as required.</span>

  <span class="hl-comment">// methods with @Cli annotations go here</span>

}</pre>

      <p>Once the commands are registered and instantiated by the Spring
      container, they are registered with the core shell parser so that the
      <code class="literal">@Cli</code> annotations can be processed. The way the
      commands are identified is through the use of the
      <code class="interfacename">CommandMarker</code> interface.</p>
    </div>

    <div class="section" title="2.1.2&nbsp;Converters"><div class="titlepage"><div><div><h3 class="title"><a name="d4e85"></a>2.1.2&nbsp;Converters</h3></div></div></div>
      

      <p>The
      <code class="interfacename">org.springframework.shell.core.Converter</code>
      interface provides the contract to convert the strings that are entered
      on the command line to rich Java types passed into the arguments of
      <code class="classname">@Cli</code>-annotated methods.</p>

      <p>By default converters for common types are registered. These cover
      primitive types (boolean, int, float...) as well as Date, Character, and
      File.</p>

      <p>If you need to register any additional
      <code class="interfacename">Converter</code> instances, register them with
      the Spring container in the
      <code class="classname">spring-shell-plugin.xml</code> file and they will be
      picked up automatically.</p>
    </div>
  </div>

  <div class="section" title="2.2&nbsp;Built in commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e94"></a>2.2&nbsp;Built in commands</h2></div></div></div>
    

    <p>There are a few built in commands. Here is a listing of their class
    name and functionality</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="classname">ConsoleCommands</code> -
        <code class="literal">clr</code> and <code class="literal">clear</code> - to clear the console.</p>
      </li><li class="listitem">
        <p><code class="classname">DateCommands</code> -
        <code class="literal">date</code> - show the current date and time.</p>
      </li><li class="listitem">
        <p><code class="classname">ExitCommands</code> -
        <code class="literal">exit</code> and <code class="literal">quit</code> - to exit the
        shell.</p>
      </li><li class="listitem">
        <p><code class="classname">HelpCommands</code> - <code class="literal">help</code> -
        list all commands and their usage</p>
      </li><li class="listitem">
        <p><code class="classname">InlineCommentCommands</code> - <code class="literal">//</code> and <code class="literal">;</code> shows the valid characters to use for inline comments</p>
      </li><li class="listitem">
        <p><code class="classname">OsCommands</code> - the keyword for this command
        is the exclamation point, <code class="literal">!</code>. After the exclamation
        point you can pass in a unix/windows command string to be
        executed.</p>
      </li><li class="listitem">
        <p><code class="classname">SystemPropertyCommands</code> - <code class="literal">system properties</code>- shows the shell's system properties</p>
      </li><li class="listitem">
        <p><code class="classname">VersionCommands</code> - <code class="literal">version</code>- shows the shell's version</p>
      </li></ul></div>

    <p>There are two commands in provided by the
    <code class="classname">AbstractShell</code> class related to useage of block comments</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="literal">/*</code> and <code class="literal">*/</code>- The begin and end characters for block comments</p>
      </li></ul></div>
  </div>

  <div class="section" title="2.3&nbsp;Customizing the shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e140"></a>2.3&nbsp;Customizing the shell</h2></div></div></div>
    

    <p>There are a few extension points that allow you to customize the
    shell. The extension points are the interfaces</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="interfacename">BannerProvider</code> - Specifies the
        banner text, welcome message, and version number that will be
        displayed when the shell is started</p>
      </li><li class="listitem">
        <p><code class="interfacename">PromptProvider</code> - Specifies the
        command prompt text, eg. "<code class="literal">shell&gt;</code>" or
        "<code class="literal">#</code>" or "<code class="literal">$</code>". This will be called
        after every command execution so it does not need to be a static
        string.</p>
      </li><li class="listitem">
        <p><code class="interfacename">HistoryFileNameProvider</code> -
        Specifies the name of the command history file</p>
      </li></ul></div>

    <p>There is a default implementation for these interfaces but you
    should create your own implementations for your own shell application.
    All of these interfaces extend from 
    <code class="interfacename">NamedProvider</code>.  Use
    Spring's <code class="literal">@Order</code> annotation to set the priority of the
    provider. This allows your provider implementations to take precedence
    over any other implementations that maybe present on the classpath from
    other plugins.</p>

    <p>To make cool "<a class="ulink" href="http://en.wikipedia.org/wiki/ASCII_art" target="_top">ASCII art</a>"
    banners the website <a class="ulink" href="http://patorjk.com/software/taag" target="_top">http://patorjk.com/software/taag</a>
    is quite neat!</p>
  </div>

  <div class="section" title="2.4&nbsp;Communicating between plugins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e162"></a>2.4&nbsp;Communicating between plugins</h2></div></div></div>
    

    <p>As this is a standard Spring application you can use Spring's
    <code class="classname">ApplicationContext</code> event infrastructure to
    communicate across plugins.</p>
  </div>

  <div class="section" title="2.5&nbsp;Command method interception"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e166"></a>2.5&nbsp;Command method interception</h2></div></div></div>
    

    <p>It has shown to be useful to provide a simple form of interception
    around the invocation of a command method. This enables the command class
    to check for updates to state, such as configuration information modified
    by other plugins, before the command method is executed. The interface
    <code class="interfacename">ExecutionProcessor</code> should be implemented
    instead of <code class="interfacename">CommandMarker</code> to access this
    functionality. The <code class="interfacename">ExecutionProcessor</code>
    interface is shown below</p>

    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ExecutionProcessor <span class="hl-keyword">extends</span> CommandMarker {

 <b class="hl-tag" style="color: blue">/**
  * Method called before invoking the target command (described by {@link ParseResult}).
  * Additionally, for advanced cases, the parse result itself effectively changing the 
  * invocation calling site.
  * 
  * @param invocationContext target command context
  * @return the invocation target 
  */</b>
 ParseResult beforeInvocation(ParseResult invocationContext);

 <b class="hl-tag" style="color: blue">/**
  * Method called after successfully invoking the target command (described by 
  * {@link ParseResult}).
  * 
  * @param invocationContext target command context
  * @param result the invocation result
  */</b>
 <span class="hl-keyword">void</span> afterReturningInvocation(ParseResult invocationContext, Object result);

 <b class="hl-tag" style="color: blue">/**
  * Method called after invoking the target command (described by {@link ParseResult}) 
  * had thrown an exception .
  * 
  * @param invocationContext target command context
  * @param thrown the thrown object
  */</b>
 <span class="hl-keyword">void</span> afterThrowingInvocation(ParseResult invocationContext, Throwable thrown);

}</pre>
  </div>

  <div class="section" title="2.6&nbsp;Command line options"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e173"></a>2.6&nbsp;Command line options</h2></div></div></div>
    

    <p>There are a few command line options that can be specified when
    starting the shell. They are</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="literal">--profiles</code> - Specifies values for the system
        property spring.profiles.active so that Spring 3.1 and greater <a class="ulink" href="http://blog.springsource.com/2011/02/11/spring-framework-3-1-m1-released/" target="_top">profile
        support </a>is enabled.</p>
      </li><li class="listitem">
        <p><code class="literal">--cmdfile</code> - Specifies a file to read that
        contains shell commands</p>
      </li><li class="listitem">
        <p><code class="literal">--histsize</code> - Specifies the maximum number of
        lines to store in the command history file. Default value is
        3000.</p>
      </li><li class="listitem">
        <p><code class="literal">--disableInternalCommands</code> - Flag that disables all commands that would
	be pre-registered with the shell.  There is no argument to this option.  You can selectively add
	back any internal commands by referencing them in your shell plugin file.  Look at the
	Spring Shell javadocs for specific commands located in the 
	<code class="literal">org.springframework.shell.commands</code> package as well as the section in this documentation
	of Built in commands.</p>
      </li></ul></div>
  </div>

  <div class="section" title="2.7&nbsp;Scripts and comments"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e191"></a>2.7&nbsp;Scripts and comments</h2></div></div></div>
    

    <p>Scripts can be executed either by passing in the
    <code class="literal">--cmdfile</code> argument at startup or by executing the
    <code class="literal">script</code> command inside the shell. When using scripts it
    helps to add comments and this can be done using block comments that start
    and end with <code class="literal">/*</code> and <code class="literal">*/</code> or an inline
    one line comment using the <code class="literal">//</code> or <code class="literal">;</code>
    characters.</p>
  </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="reference.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="dev.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;II.&nbsp;Reference Documentation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;Developing Spring Shell Applications</td></tr></table></div></body></html>