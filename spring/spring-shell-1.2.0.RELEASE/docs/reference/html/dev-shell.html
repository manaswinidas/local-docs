<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Developing Spring Shell Applications</title><link rel="stylesheet" href="css/manual.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Shell Documentation"><link rel="up" href="dev.html" title="Part&nbsp;III.&nbsp;Developing Spring Shell Applications"><link rel="prev" href="dev.html" title="Part&nbsp;III.&nbsp;Developing Spring Shell Applications"><link rel="next" href="samples.html" title="Part&nbsp;IV.&nbsp;Spring Shell Sample application"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Developing Spring Shell Applications</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="dev.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;III.&nbsp;Developing Spring Shell Applications</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="samples.html">Next</a></td></tr></table><hr></div><div class="chapter" title="3.&nbsp;Developing Spring Shell Applications"><div class="titlepage"><div><div><h2 class="title"><a name="dev-shell"></a>3.&nbsp;Developing Spring Shell Applications</h2></div></div></div>
  

  <p>Contributing commands to the shell is very easy. There are only a few
  annotations you need to learn. The implementation style of the command is
  the same as developing classes for an application that uses dependency
  injection. You can leverage all the features of the Spring container to
  implement your command classes.</p>

  <div class="section" title="3.1&nbsp;Marker Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e207"></a>3.1&nbsp;Marker Interface</h2></div></div></div>
    

    <p>The first step to creating a command is to implement the marker
    interface <code class="interfacename">CommandMarker</code> and to annotate
    your class with Spring's <code class="classname">@Component </code>annotation.
    (Note there is an open JIRA issue to provide a
    <code class="classname">@CliCommand</code> meta-annotation to avoid having to use
    a marker interface). Using the code from the helloworld sample
    application, the code of a <code class="classname">HelloWorldCommands</code> class
    is shown below:</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {
 
  <span class="hl-comment">// use any Spring annotations for Dependency Injection or other Spring interfaces </span>
  <span class="hl-comment">// as required.</span>

  <span class="hl-comment">// methods with @Cli annotations go here  </span>

}</pre>
  </div>

  <div class="section" title="3.2&nbsp;Logging"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e215"></a>3.2&nbsp;Logging</h2></div></div></div>
    

    <p>Logging is currently done using JDK logging. Due to the intricacies
    of console, JLine and Ansi handling, it is generally advised to display
    messages as return values to the method commands. However, when logging is
    required, the typical JDK logger declaration should suffice.</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {
 
  <span class="hl-keyword">protected</span> <span class="hl-keyword">final</span> Logger LOG = Logger.getLogger(getClass().getName());

  <span class="hl-comment">// methods with @Cli annotations go here  </span>

}</pre>

    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/admon/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
       Note: it is the responsibility of the packager/developer to handle logging for third-party libraries. Typically one wants to reduce the logging level so the console/shell does not get affected by logging messages. 
    </td></tr></table></div>
  </div>

  <div class="section" title="3.3&nbsp;CLI Annotations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e220"></a>3.3&nbsp;CLI Annotations</h2></div></div></div>
    

    <p>There are three annotations used on methods and method arguments
    that define the main contract for interacting with the shell. These
    are:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        <p><code class="classname">CliAvailabilityIndicator</code> - Placed on a
        method that returns a boolean value and indicates if a particular
        command can be presented in the shell. This decision is usually based
        on the history of commands that have been executed previously. It
        prevents extraneous commands being presented until some preconditions
        are met, for example the execution of a 'configuration'
        command.</p>
      </li><li class="listitem">
        <p><code class="classname">CliCommand</code> - Placed on a method that
        provides a command to the shell. Its value provides one or more
        strings that serve as the start of a particular command name. These
        must be unique within the entire application, across all
        plugins.</p>
      </li><li class="listitem">
        <p><code class="classname">CliOption</code> - Placed on the arguments of a
        command method, allowing it to declare the argument value as mandatory
        or optional with a default value.</p>
      </li></ul></div>

    <p>Here is a simple use of these annotations in a command class</p>

    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Component</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldCommands <span class="hl-keyword">implements</span> CommandMarker {

  <i><span class="hl-annotation" style="color: gray">@CliAvailabilityIndicator({"hw simple"})</span></i>
  <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isCommandAvailable() {
    <span class="hl-keyword">return</span> true;
  }

  <i><span class="hl-annotation" style="color: gray">@CliCommand(value = "hw simple", help = "Print a simple hello world message")</span></i>
  <span class="hl-keyword">public</span> String simple(
    <i><span class="hl-annotation" style="color: gray">@CliOption(key = { "message" }, mandatory = true, help = "The hello world message")</span></i> 
    <span class="hl-keyword">final</span> String message,
    
    <i><span class="hl-annotation" style="color: gray">@CliOption(key = { "location" }, mandatory = false, 
               help = "Where you are saying hello", specifiedDefaultValue="At work")</span></i> 
    <span class="hl-keyword">final</span> String location) {

    <span class="hl-keyword">return</span> <span class="hl-string">"Message = ["</span> + message + <span class="hl-string">"] Location = ["</span> + location + <span class="hl-string">"]"</span>;

  }
}</pre>

    <p>The method annotated with <code class="classname">@CliAvailabilityIndicator
    </code>is returning true so that the one and only command in this
    class is exposed to the shell to be invoked. If there were more commands
    in the class, you would list them as comma separated value.</p>

    <p>The <code class="classname">@CliCommand</code> annotation is creating the
    command '<code class="literal">hw simple</code>' in the shell. The help message is
    what will be printed if you use the build in <code class="literal">help</code>
    command. The method name is '<code class="methodname">simple</code>' but it could
    just have been any other name.</p>

    <p>The <code class="classname">@CliOption</code> annotation on each of the
    command arguments is where you will spend most of your time authoring
    commands. You need to decide which arguments are required, which are
    optional, and if they are optional is there a default value. In this case
    there are two arguments or options to the command: message and location.
    The message option is required and a help message is provided to give
    guidance to the user when tabbing to get completion for the
    command.</p>

    <p>The implementation of the '<code class="methodname">simple</code>' method
    is trivial, just a log statement, but this is where you would typically
    call other collaborating objects that were injected into the class via
    Spring.</p>

    <p>The method argument types in this example are
    <code class="classname">String</code>, which doesn't present any issue with type
    conversion. You can specify methods with any rich object type as well as
    basic primitive types such as int, float etc. For all types other than
    those handled by the shell by default (basic types,
    <code class="classname">Date</code>, <code class="classname">File</code>) you will need to
    register your own implementation of the
    <code class="interfacename">org.springframework.shell.core.Converter</code>
    interface with the container in your plugin.</p>

    <p>Note that the method return argument can be non-void - in our
    example, it is the actual message we want to display. Whenever an object
    is returned, the shell will display its <code class="literal">toString()</code>
    representation.</p>
  </div>
  
  <div class="section" title="3.4&nbsp;Testing shell commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e253"></a>3.4&nbsp;Testing shell commands</h2></div></div></div>
    

    <p>To perform a test of the shell commands you can instantiate the shell inside a test case,
    execute the command and then perform assertions on the return value CommandResult.
    A simple base class to set this up is shown below.</p>
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractShellIntegrationTest {

	<span class="hl-keyword">private</span> <span class="hl-keyword">static</span> JLineShellComponent shell;
	
	<i><span class="hl-annotation" style="color: gray">@BeforeClass</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> startUp() <span class="hl-keyword">throws</span> InterruptedException {
		Bootstrap bootstrap = <span class="hl-keyword">new</span> Bootstrap();		
		shell = bootstrap.getJLineShellComponent();
	}
	
	<i><span class="hl-annotation" style="color: gray">@AfterClass</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> shutdown() {
		shell.stop();
	}

	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> JLineShellComponent getShell() {
		<span class="hl-keyword">return</span> shell;
	}

}</pre>
    <p>Here is an example testing the Date command</p>
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BuiltInCommandTests <span class="hl-keyword">extends</span> AbstractShellIntegrationTest {
	
	<i><span class="hl-annotation" style="color: gray">@Test</span></i>
	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> dateTest() <span class="hl-keyword">throws</span> ParseException {
		
		<span class="hl-comment">//Execute command</span>
		CommandResult cr = getShell().executeCommand(<span class="hl-string">"date"</span>);
		
		<span class="hl-comment">//Get result   </span>
		DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL,Locale.US);
		Date result = df.parse(cr.getResult().toString());
		
		<span class="hl-comment">//Make assertions - DateMaters is an external dependency not shown here.</span>
		Date now = <span class="hl-keyword">new</span> Date();
		MatcherAssert.assertThat(now, DateMatchers.within(<span class="hl-number">5</span>, TimeUnit.SECONDS, result));		
	}
}</pre>
    <p>The java.lang.Class of CommandResult's getResult method will match that of the return value of
    the method annotated with @CliCommand.  You should cast to the appropriate type to help perform your assertions.
    </p>
  </div>
  <div class="section" title="3.5&nbsp;Building and running the shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e260"></a>3.5&nbsp;Building and running the shell</h2></div></div></div>
    

    <p>In our opinion, the easiest way to build and execute the shell is to
    cut-n-paste the gradle script in the example application. This uses the
    application plugin from gradle to create a bin directory with a startup
    script for windows and Unix and places all dependent jars in a lib
    directory. Maven has a similar plugin - the <a class="ulink" href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/" target="_top">AppAssembler</a>
    plugin.</p>

    <p>The main class of the shell is
    <code class="classname">org.springframework.shell.Bootstrap</code>. As long as you
    place other plugins, perhaps developed independently, on the classpath,
    the Bootstrap class will incorporate them into the shell.</p>
  </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="dev.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="dev.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="samples.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;III.&nbsp;Developing Spring Shell Applications&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;IV.&nbsp;Spring Shell Sample application</td></tr></table></div></body></html>