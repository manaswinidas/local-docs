<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>25.&nbsp;Creating a Stream</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Cloud Data Flow for Apache YARN"><link rel="up" href="streams.html" title="Part&nbsp;V.&nbsp;Streams"><link rel="prev" href="custom-applications.html" title="24.&nbsp;Creating custom applications"><link rel="next" href="spring-cloud-dataflow-destroy-stream.html" title="26.&nbsp;Destroying a Stream"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">25.&nbsp;Creating a Stream</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="custom-applications.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;V.&nbsp;Streams</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="spring-cloud-dataflow-destroy-stream.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-dataflow-create-stream" href="#spring-cloud-dataflow-create-stream"></a>25.&nbsp;Creating a Stream</h2></div></div></div><p>The Spring Cloud Data Flow Server exposes a full RESTful API for managing the lifecycle of stream definitions, but the easiest way to use is it is via the Spring Cloud Data Flow shell. Start the shell as described in the <a class="link" href="">Getting Started</a> section.</p><p>New streams are created by with the help of stream definitions. The definitions are built from a simple DSL. For example, let&#8217;s walk through what happens if we execute the following shell command:</p><pre class="screen">dataflow:&gt; stream create --definition "time | log" --name ticktock</pre><p>This defines a stream named <code class="literal">ticktock</code> based off the DSL expression <code class="literal">time | log</code>.  The DSL uses the "pipe" symbol <code class="literal">|</code>, to connect a source to a sink.</p><p>Then to deploy the stream execute the following shell command (or alternatively add the <code class="literal">--deploy</code> flag when creating the stream so that this step is not needed):</p><pre class="screen">dataflow:&gt; stream deploy --name ticktock</pre><p>The Data Flow Server resolves <code class="literal">time</code> and <code class="literal">log</code> to maven coordinates and uses those to launch the <code class="literal">time</code> and <code class="literal">log</code> applications of the stream.</p><pre class="screen">2016-06-01 09:41:21.728  INFO 79016 --- [nio-9393-exec-6] o.s.c.d.spi.local.LocalAppDeployer       : deploying app ticktock.log instance 0
   Logs will be in /var/folders/wn/8jxm_tbd1vj28c8vj37n900m0000gn/T/spring-cloud-dataflow-912434582726479179/ticktock-1464788481708/ticktock.log
2016-06-01 09:41:21.914  INFO 79016 --- [nio-9393-exec-6] o.s.c.d.spi.local.LocalAppDeployer       : deploying app ticktock.time instance 0
   Logs will be in /var/folders/wn/8jxm_tbd1vj28c8vj37n900m0000gn/T/spring-cloud-dataflow-912434582726479179/ticktock-1464788481910/ticktock.time</pre><p>In this example, the time source simply sends the current time as a message each second, and the log sink outputs it using the logging framework.
You can tail the <code class="literal">stdout</code> log (which has an "_&lt;instance&gt;" suffix). The log files are located within the directory displayed in the Data Flow Server&#8217;s log output, as shown above.</p><pre class="screen">$ tail -f /var/folders/wn/8jxm_tbd1vj28c8vj37n900m0000gn/T/spring-cloud-dataflow-912434582726479179/ticktock-1464788481708/ticktock.log/stdout_0.log
2016-06-01 09:45:11.250  INFO 79194 --- [  kafka-binder-] log.sink    : 06/01/16 09:45:11
2016-06-01 09:45:12.250  INFO 79194 --- [  kafka-binder-] log.sink    : 06/01/16 09:45:12
2016-06-01 09:45:13.251  INFO 79194 --- [  kafka-binder-] log.sink    : 06/01/16 09:45:13</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_application_properties" href="#_application_properties"></a>25.1&nbsp;Application properties</h2></div></div></div><p>Application properties are the properties associated with each application in the stream. When the application is deployed, the application properties are applied to the application via
command line arguments or environment variables based on the underlying deployment implementation.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_application_properties_when_creating_a_stream" href="#_passing_application_properties_when_creating_a_stream"></a>25.1.1&nbsp;Passing application properties when creating a stream</h3></div></div></div><p>The following stream</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time | log"</span> --name ticktock</pre><p>can have application properties defined at the time of stream creation.</p><p>The shell command <code class="literal">app info &lt;appType&gt;:&lt;appName&gt;</code> displays the white-listed application properties for the application.
For more info on the property white listing refer to <a class="xref" href="spring-cloud-dataflow-register-apps.html#spring-cloud-dataflow-stream-app-whitelisting" title="23.1&nbsp;Whitelisting application properties">Section&nbsp;23.1, &#8220;Whitelisting application properties&#8221;</a></p><p>Below are the white listed properties for the app <code class="literal">time</code>:</p><pre class="programlisting">dataflow:&gt; app info source:time
&#9556;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9559;
&#9553;         Option Name          &#9474;         Description          &#9474;           Default            &#9474;             Type             &#9553;
&#9568;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9571;
&#9553;trigger.time-unit             &#9474;The TimeUnit to apply to delay&#9474;&lt;none&gt;                        &#9474;java.util.concurrent.TimeUnit &#9553;
&#9553;                              &#9474;values.                       &#9474;                              &#9474;                              &#9553;
&#9553;trigger.fixed-delay           &#9474;Fixed delay <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> periodic      &#9474;<span class="hl-number">1</span>                             &#9474;java.lang.Integer             &#9553;
&#9553;                              &#9474;triggers.                     &#9474;                              &#9474;                              &#9553;
&#9553;trigger.cron                  &#9474;Cron expression value <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> the &#9474;&lt;none&gt;                        &#9474;java.lang.String              &#9553;
&#9553;                              &#9474;Cron Trigger.                 &#9474;                              &#9474;                              &#9553;
&#9553;trigger.initial-delay         &#9474;Initial delay <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> periodic    &#9474;<span class="hl-number">0</span>                             &#9474;java.lang.Integer             &#9553;
&#9553;                              &#9474;triggers.                     &#9474;                              &#9474;                              &#9553;
&#9553;trigger.max-messages          &#9474;Maximum messages per poll, -<span class="hl-number">1</span> &#9474;<span class="hl-number">1</span>                             &#9474;java.lang.Long                &#9553;
&#9553;                              &#9474;means infinity.               &#9474;                              &#9474;                              &#9553;
&#9553;trigger.date-format           &#9474;Format <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> the date value.    &#9474;&lt;none&gt;                        &#9474;java.lang.String              &#9553;
&#9562;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9565;</pre><p>Below are the white listed properties for the app <code class="literal">log</code>:</p><pre class="programlisting">dataflow:&gt; app info sink:log
&#9556;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9572;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9559;
&#9553;         Option Name          &#9474;         Description          &#9474;           Default            &#9474;             Type             &#9553;
&#9568;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9578;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9571;
&#9553;log.name                      &#9474;The name of the logger to use.&#9474;&lt;none&gt;                        &#9474;java.lang.String              &#9553;
&#9553;log.level                     &#9474;The level at which to log     &#9474;&lt;none&gt;                        &#9474;org.springframework.integratio&#9553;
&#9553;                              &#9474;messages.                     &#9474;                              &#9474;n.handler.LoggingHandler$Level&#9553;
&#9553;log.expression                &#9474;A SpEL expression (against the&#9474;payload                       &#9474;java.lang.String              &#9553;
&#9553;                              &#9474;incoming message) to evaluate &#9474;                              &#9474;                              &#9553;
&#9553;                              &#9474;as the logged message.        &#9474;                              &#9474;                              &#9553;
&#9562;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9575;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9565;</pre><p>The application properties for the <code class="literal">time</code> and <code class="literal">log</code> apps can be specified at the time of <code class="literal">stream</code> creation as follows:</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time --fixed-delay=5 | log --level=WARN"</span> --name ticktock</pre><p>Note that the properties <code class="literal">fixed-delay</code> and <code class="literal">level</code> defined above for the apps <code class="literal">time</code> and <code class="literal">log</code> are the 'short-form' property names provided by the shell completion.
These 'short-form' property names are applicable only for the white-listed properties and in all other cases, only <span class="emphasis"><em>fully qualified</em></span> property names should be used.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_deployment_properties" href="#_deployment_properties"></a>25.2&nbsp;Deployment properties</h2></div></div></div><p>When deploying the stream, properties that control the deployment of the apps into the target platform are known as <code class="literal">deployment</code> properties.
For instance, one can specify how many instances need to be deployed for the specific application defined in the stream using the deployment property called <code class="literal">count</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_application_properties_versus_deployer_properties" href="#_application_properties_versus_deployer_properties"></a>25.2.1&nbsp;Application properties versus Deployer properties</h3></div></div></div><p>Starting with version 1.2, the distinction between properties that are meant for the <span class="emphasis"><em>deployed app</em></span> and properties that
govern <span class="emphasis"><em>how</em></span> this app is deployed (thanks to some implementation of a
<a class="link" href="https://github.com/spring-cloud/spring-cloud-deployer/" target="_top">spring cloud deployer</a>) is more explicit. The former should be
passed using the syntax <code class="literal">app.&lt;app-name&gt;.&lt;property-name&gt;=&lt;value&gt;</code> while the latter use the
<code class="literal">deployer.&lt;app-name&gt;.&lt;short-property-name&gt;=&lt;value&gt;</code></p><p>The following table recaps the difference in behavior between the two.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Application Properties</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Deployer Properties</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><span class="strong"><strong>Example Syntax</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">app.filter.expression=foo</code></p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">deployer.filter.count=3</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><span class="strong"><strong>What the application "sees"</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">expression=foo</code> or <code class="literal">&lt;some-prefix&gt;.expression=foo</code> if <code class="literal">expression</code> is one of the whitelisted properties</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Nothing</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><span class="strong"><strong>What the deployer "sees"</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Nothing</p></td><td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">spring.cloud.deployer.count=3</code> The <code class="literal">spring.cloud.deployer</code> prefix is automatically and always prepended to the property name</p></td></tr><tr><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><span class="strong"><strong>Typical usage</strong></span></p></td><td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>Passing/Overriding application properties, passing Spring Cloud Stream binder or partitionning properties</p></td><td style="" align="left" valign="top"><p>Setting the number of instances, memory, disk, etc.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_instance_count_as_deployment_property" href="#_passing_instance_count_as_deployment_property"></a>25.2.2&nbsp;Passing instance count as deployment property</h3></div></div></div><p>If you would like to have multiple instances of an application in the stream, you
can include a deployer property with the deploy command:</p><pre class="programlisting">dataflow:&gt; stream deploy --name ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"deployer.time.count=3"</span></pre><p>Note that <code class="literal">count</code> is the <span class="strong"><strong>reserved</strong></span> property name used by the underlying deployer. Hence, if the application also has a custom property named <code class="literal">count</code>, it is <span class="strong"><strong>not</strong></span> supported
 when specified in 'short-form' form during stream <span class="emphasis"><em>deployment</em></span> as it could conflict with the <span class="emphasis"><em>instance</em></span> count deployer property. Instead, the <code class="literal">count</code> as a custom application property can be
 specified in its <span class="emphasis"><em>fully qualified</em></span> form (example: <code class="literal">app.foo.bar.count</code>) during stream <span class="emphasis"><em>deployment</em></span> or it can be specified using 'short-form' or <span class="emphasis"><em>fully qualified</em></span> form during the stream <span class="emphasis"><em>creation</em></span>
 where it will be considered as an app property.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>See <a class="xref" href="spring-cloud-dataflow-stream-app-labels.html" title="32.&nbsp;Using Labels in a Stream">Chapter&nbsp;32, <i>Using Labels in a Stream</i></a>.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inline_vs_file_reference_properties" href="#_inline_vs_file_reference_properties"></a>25.2.3&nbsp;Inline vs file reference properties</h3></div></div></div><p>When using the Spring Cloud Data Flow Shell, there are two ways to provide deployment
properties: either <span class="strong"><strong>inline</strong></span> or via a <span class="strong"><strong>file reference</strong></span>. Those two ways are exclusive
and documented below:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>Inline properties</strong></span></span></dt><dd>use the <code class="literal">--properties</code> shell option and list properties as a comma separated
list of key=value pairs, like so:</dd></dl></div><pre class="programlisting">stream deploy foo
    --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"deployer.transform.count=2,app.transform.producer.partitionKeyExpression=payload"</span></pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>Using a file reference</strong></span></span></dt><dd>use the <code class="literal">--propertiesFile</code> option and point it to a local <code class="literal">.properties</code>, <code class="literal">.yaml</code> or <code class="literal">.yml</code> file
(i.e. that lives in the filesystem of the machine running the shell). Being read
as a <code class="literal">.properties</code> file, normal rules apply (ISO 8859-1 encoding, <code class="literal">=</code>, <code class="literal">&lt;space&gt;</code> or
<code class="literal">:</code> delimiter, etc.) although we recommend using <code class="literal">=</code> as a key-value pair delimiter
for consistency:</dd></dl></div><pre class="programlisting">stream deploy foo --propertiesFile myprops.properties</pre><p>where <code class="literal">myprops.properties</code> contains:</p><pre class="screen">deployer.transform.count=2
app.transform.producer.partitionKeyExpression=payload</pre><p>Both the above properties will be passed as deployment properties for the stream <code class="literal">foo</code> above.</p><p>In case of using YAML as the format for the deployment properties, use the <code class="literal">.yaml</code> or <code class="literal">.yml</code> file extention when deploying the stream,</p><pre class="programlisting">stream deploy foo --propertiesFile myprops.yaml</pre><p>where <code class="literal">myprops.yaml</code> contains:</p><pre class="screen">deployer:
  transform:
    count: 2
app:
  transform:
    producer:
      partitionKeyExpression: payload</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_application_properties_when_deploying_a_stream" href="#_passing_application_properties_when_deploying_a_stream"></a>25.2.4&nbsp;Passing application properties when deploying a stream</h3></div></div></div><p>The application properties can also be specified when deploying a stream. When specified during deployment, these application properties can either be specified as
 'short-form' property names (applicable for white-listed properties) or <span class="emphasis"><em>fully qualified</em></span> property names. The application properties should have the prefix "app.&lt;appName/label&gt;".</p><p>For example, the stream</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time | log"</span> --name ticktock</pre><p>can be deployed with application properties using the 'short-form' property names:</p><pre class="programlisting">dataflow:&gt;stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.time.fixed-delay=5,app.log.level=ERROR"</span></pre><p>When using the app label,</p><pre class="programlisting">stream create ticktock --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"a: time | b: log"</span></pre><p>the application properties can be defined as:</p><pre class="programlisting">stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.a.fixed-delay=4,app.b.level=ERROR"</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="passing_producer_consumer_properties" href="#passing_producer_consumer_properties"></a>25.2.5&nbsp;Passing Spring Cloud Stream properties for the application</h3></div></div></div><p>Spring Cloud Data Flow sets the <code class="literal">required</code> Spring Cloud Stream properties for the applications inside the stream. Most importantly, the <code class="literal">spring.cloud.stream.bindings.&lt;input/output&gt;.destination</code> is set internally for the apps to bind.</p><p>If someone wants to override any of the Spring Cloud Stream properties, they can be set via deployment properties.</p><p>For example, for the below stream</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http | transform --expression=payload.getValue('hello').toUpperCase() | log"</span> --name ticktock</pre><p>if there are multiple binders available in the classpath for each of the applications and the binder is chosen for each deployment then the stream can be deployed with the specific Spring Cloud Stream properties as:</p><pre class="programlisting">dataflow:&gt;stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.time.spring.cloud.stream.bindings.output.binder=kafka,app.transform.spring.cloud.stream.bindings.input.binder=kafka,app.transform.spring.cloud.stream.bindings.output.binder=rabbit,app.log.spring.cloud.stream.bindings.input.binder=rabbit"</span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Overriding the destination names is not recommended as Spring Cloud Data Flow takes care of setting this internally.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_per_binding_producer_consumer_properties" href="#_passing_per_binding_producer_consumer_properties"></a>25.2.6&nbsp;Passing per-binding producer consumer properties</h3></div></div></div><p>A Spring Cloud Stream application can have producer and consumer properties set <code class="literal">per-binding</code> basis.
While Spring Cloud Data Flow supports specifying short-hand notation for per binding producer properties such as <code class="literal">partitionKeyExpression</code>, <code class="literal">partitionKeyExtractorClass</code> as described in <a class="xref" href="spring-cloud-dataflow-create-stream.html#passing_stream_partition_properties" title="25.2.7&nbsp;Passing stream partition properties during stream deployment">Section&nbsp;25.2.7, &#8220;Passing stream partition properties during stream deployment&#8221;</a>, all the supported Spring Cloud Stream producer/consumer properties can be set as Spring Cloud Stream properties for the app directly as well.</p><p>The consumer properties can be set for the <code class="literal">inbound</code> channel name with the prefix <code class="literal">app.[app/label name].spring.cloud.stream.bindings.&lt;channelName&gt;.consumer.</code> and the producer properties can be set for the <code class="literal">outbound</code> channel name with the prefix <code class="literal">app.[app/label name].spring.cloud.stream.bindings.&lt;channelName&gt;.producer.</code>.
For example, the stream</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time | log"</span> --name ticktock</pre><p>can be deployed with producer/consumer properties as:</p><pre class="programlisting">dataflow:&gt;stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.time.spring.cloud.stream.bindings.output.producer.requiredGroups=myGroup,app.time.spring.cloud.stream.bindings.output.producer.headerMode=raw,app.log.spring.cloud.stream.bindings.input.consumer.concurrency=3,app.log.spring.cloud.stream.bindings.input.consumer.maxAttempts=5"</span></pre><p>The <code class="literal">binder</code> specific producer/consumer properties can also be specified in a similar way.</p><p>For instance</p><pre class="programlisting">dataflow:&gt;stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.time.spring.cloud.stream.rabbit.bindings.output.producer.autoBindDlq=true,app.log.spring.cloud.stream.rabbit.bindings.input.consumer.transacted=true"</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="passing_stream_partition_properties" href="#passing_stream_partition_properties"></a>25.2.7&nbsp;Passing stream partition properties during stream deployment</h3></div></div></div><p>A common pattern in stream processing is to partition the data as it is streamed.
This entails deploying multiple instances of a message consuming app and using
content-based routing so that messages with a given key (as determined at runtime)
are always routed to the same app instance. You can pass the partition properties during
stream deployment to declaratively configure a partitioning strategy to route each
message to a specific consumer instance.</p><p>See below for examples of deploying partitioned streams:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>app.[app/label name].producer.partitionKeyExtractorClass</strong></span></span></dt><dd>The class name of a PartitionKeyExtractorStrategy (default <code class="literal">null</code>)</dd><dt><span class="term"><span class="strong"><strong>app.[app/label name].producer.partitionKeyExpression</strong></span></span></dt><dd>A SpEL expression, evaluated against the message, to determine the partition key;
only applies if <code class="literal">partitionKeyExtractorClass</code> is null. If both are null, the app
is not partitioned (default <code class="literal">null</code>)</dd><dt><span class="term"><span class="strong"><strong>app.[app/label name].producer.partitionSelectorClass</strong></span></span></dt><dd>The class name of a PartitionSelectorStrategy (default <code class="literal">null</code>)</dd><dt><span class="term"><span class="strong"><strong>app.[app/label name].producer.partitionSelectorExpression</strong></span></span></dt><dd>A SpEL expression, evaluated against the partition key, to determine the partition
index to which the message will be routed. The final partition index will be the
return value (an integer) modulo <code class="literal">[nextModule].count</code>. If both the class and
expression are null, the underlying binder&#8217;s default PartitionSelectorStrategy
will be applied to the key (default <code class="literal">null</code>)</dd></dl></div><p>In summary, an app is partitioned if its count is &gt; 1 and the previous app has a
<code class="literal">partitionKeyExtractorClass</code> or <code class="literal">partitionKeyExpression</code> (class takes precedence).
When a partition key is extracted, the partitioned app instance is determined by
invoking the <code class="literal">partitionSelectorClass</code>, if present, or the <code class="literal">partitionSelectorExpression % partitionCount</code>,
where <code class="literal">partitionCount</code> is application count in the case of RabbitMQ, and the underlying
partition count of the topic in the case of Kafka.</p><p>If neither a <code class="literal">partitionSelectorClass</code> nor a <code class="literal">partitionSelectorExpression</code> is
present the result is <code class="literal">key.hashCode() % partitionCount</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="passing_content_type_properties" href="#passing_content_type_properties"></a>25.2.8&nbsp;Passing application content type properties</h3></div></div></div><p>In a stream definition you can specify that the input or the output of an application need to be converted to a different type.
You can use the <code class="literal">inputType</code> and <code class="literal">outputType</code> properties to specify the content type for the incoming data and outgoing data, respectively.</p><p>For example, consider the following stream:</p><pre class="screen">dataflow:&gt;stream create tuple --definition "http | filter --inputType=application/x-spring-tuple
 --expression=payload.hasFieldName('hello') | transform --expression=payload.getValue('hello').toUpperCase()
 | log" --deploy</pre><p>The <code class="literal">http</code> app is expected to send the data in JSON and the <code class="literal">filter</code> app receives the JSON data
and processes it as a Spring Tuple.
In order to do so, we use the <code class="literal">inputType</code> property on the filter app to convert the data into the expected Spring Tuple format.
The <code class="literal">transform</code> application processes the Tuple data and sends the processed data to the downstream <code class="literal">log</code> application.</p><p>When sending some data to the <code class="literal">http</code> application:</p><pre class="screen">dataflow:&gt;http post --data {"hello":"world","foo":"bar"} --contentType application/json --target http://localhost:&lt;http-port&gt;</pre><p>At the log application you see the content as follows:</p><pre class="screen">INFO 18745 --- [transform.tuple-1] log.sink                                 : WORLD</pre><p>Depending on how applications are chained, the content type conversion can be specified either as via the <code class="literal">--outputType</code> in the upstream app or as an <code class="literal">--inputType</code> in the downstream app.
For instance, in the above stream, instead of specifying the <code class="literal">--inputType</code> on the 'transform' application to convert, the option <code class="literal">--outputType=application/x-spring-tuple</code> can also be specified on the 'http' application.</p><p>For the complete list of message conversion and message converters, please refer to Spring Cloud Stream 1.2.2.RELEASE#contenttypemanagement[documentation].</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_overriding_application_properties_during_stream_deployment" href="#_overriding_application_properties_during_stream_deployment"></a>25.2.9&nbsp;Overriding application properties during stream deployment</h3></div></div></div><p>Application properties that are defined during deployment override the same properties defined during the stream creation.</p><p>For example, the following stream has application properties defined during stream creation:</p><pre class="programlisting">dataflow:&gt; stream create --definition <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time --fixed-delay=5 | log --level=WARN"</span> --name ticktock</pre><p>To override these application properties, one can specify the new property values during deployment:</p><pre class="programlisting">dataflow:&gt;stream deploy ticktock --properties <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"app.time.fixed-delay=4,app.log.level=ERROR"</span></pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-cloud-dataflow-global-properties" href="#spring-cloud-dataflow-global-properties"></a>25.3&nbsp;Common application properties</h2></div></div></div><p>In addition to configuration via DSL, Spring Cloud Data Flow provides a mechanism for setting common properties to all
the streaming applications that are launched by it.
This can be done by adding properties prefixed with <code class="literal">spring.cloud.dataflow.applicationProperties.stream</code> when starting
the server.
When doing so, the server will pass all the properties, without the prefix, to the instances it launches.</p><p>For example, all the launched applications can be configured to use a specific Kafka broker by launching the
Data Flow server with the following options:</p><pre class="screen">--spring.cloud.dataflow.applicationProperties.stream.spring.cloud.stream.kafka.binder.brokers=192.168.1.100:9092
--spring.cloud.dataflow.applicationProperties.stream.spring.cloud.stream.kafka.binder.zkNodes=192.168.1.100:2181</pre><p>This will cause the properties <code class="literal">spring.cloud.stream.kafka.binder.brokers</code> and <code class="literal">spring.cloud.stream.kafka.binder.zkNodes</code>
to be passed to all the launched applications.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Properties configured using this mechanism have lower precedence than stream deployment properties.
They will be overridden if a property with the same key is specified at stream deployment time (e.g.
<code class="literal">app.http.spring.cloud.stream.kafka.binder.brokers</code> will override the common property).</p></td></tr></table></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-applications.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="streams.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-cloud-dataflow-destroy-stream.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">24.&nbsp;Creating custom applications&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;26.&nbsp;Destroying a Stream</td></tr></table></div></body></html>