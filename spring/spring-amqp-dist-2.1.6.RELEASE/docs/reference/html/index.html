<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Mark Pollack, Mark Fisher, Oleg Zhurakousky, Dave Syer, Gary Russell, Gunnar Hillert, Artem Bilan, Stéphane Nicoll, Arnaud Cogoluègnes, Jay Bryant">
<title>Spring AMQP</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body id="spring-amqp-reference" class="book toc2 toc-left">
<div id="header">
<h1>Spring AMQP</h1>
<div class="details">
<span id="author" class="author">Mark Pollack</span><br>
<span id="author2" class="author">Mark Fisher</span><br>
<span id="author3" class="author">Oleg Zhurakousky</span><br>
<span id="author4" class="author">Dave Syer</span><br>
<span id="author5" class="author">Gary Russell</span><br>
<span id="author6" class="author">Gunnar Hillert</span><br>
<span id="author7" class="author">Artem Bilan</span><br>
<span id="author8" class="author">Stéphane Nicoll</span><br>
<span id="author9" class="author">Arnaud Cogoluègnes</span><br>
<span id="author10" class="author">Jay Bryant</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_preface">1. Preface</a></li>
<li><a href="#_introduction">2. Introduction</a>
<ul class="sectlevel2">
<li><a href="#quick-tour">2.1. Quick Tour for the impatient</a>
<ul class="sectlevel3">
<li><a href="#_introduction_2">2.1.1. Introduction</a>
<ul class="sectlevel4">
<li><a href="#compatibility">Compatibility</a></li>
<li><a href="#_very_very_quick">Very, Very Quick</a></li>
<li><a href="#_with_xml_configuration">With XML Configuration</a></li>
<li><a href="#_with_java_configuration">With Java Configuration</a></li>
<li><a href="#_with_spring_boot_auto_configuration_and_an_async_pojo_listener">With Spring Boot Auto Configuration and an Async POJO Listener</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#whats-new">2.2. What&#8217;s New</a>
<ul class="sectlevel3">
<li><a href="#_changes_in_2_1_since_2_0">2.2.1. Changes in 2.1 Since 2.0</a>
<ul class="sectlevel4">
<li><a href="#_amqp_client_library">AMQP Client library</a></li>
<li><a href="#_package_changes">Package Changes</a></li>
<li><a href="#_publisher_confirms_changes">Publisher Confirms Changes</a></li>
<li><a href="#_listener_container_factory_improvements">Listener Container Factory Improvements</a></li>
<li><a href="#_broker_event_listener">Broker Event Listener</a></li>
<li><a href="#_rabbitadmin_changes">RabbitAdmin Changes</a></li>
<li><a href="#_rabbittemplate_changes">RabbitTemplate Changes</a></li>
<li><a href="#_message_conversion">Message Conversion</a></li>
<li><a href="#_management_rest_api">Management REST API</a></li>
<li><a href="#_rabbitlistener_changes"><code>@RabbitListener</code> Changes</a></li>
<li><a href="#_async_rabbitlistener_return">Async <code>@RabbitListener</code> Return</a></li>
<li><a href="#_connection_factory_bean_changes">Connection Factory Bean Changes</a></li>
<li><a href="#_connection_factory_changes">Connection Factory Changes</a></li>
<li><a href="#_listener_container_changes">Listener Container Changes</a></li>
<li><a href="#_immediate_requeue">Immediate requeue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_reference">3. Reference</a>
<ul class="sectlevel2">
<li><a href="#amqp">3.1. Using Spring AMQP</a>
<ul class="sectlevel3">
<li><a href="#_amqp_abstractions">3.1.1. AMQP Abstractions</a>
<ul class="sectlevel4">
<li><a href="#_message"><code>Message</code></a></li>
<li><a href="#_exchange">Exchange</a></li>
<li><a href="#_queue">Queue</a></li>
<li><a href="#_binding">Binding</a></li>
</ul>
</li>
<li><a href="#connections">3.1.2. Connection and Resource Management</a>
<ul class="sectlevel4">
<li><a href="#_naming_connections">Naming Connections</a></li>
<li><a href="#_blocked_connections_and_resource_constraints">Blocked Connections and Resource Constraints</a></li>
<li><a href="#connection-factory">Configuring the Underlying Client Connection Factory</a></li>
<li><a href="#rabbitconnectionfactorybean-configuring-ssl"><code>RabbitConnectionFactoryBean</code> and Configuring SSL</a></li>
<li><a href="#routing-connection-factory">Routing Connection Factory</a></li>
<li><a href="#queue-affinity">Queue Affinity and the <code>LocalizedQueueConnectionFactory</code></a></li>
<li><a href="#cf-pub-conf-ret">Publisher Confirms and Returns</a></li>
<li><a href="#connection-channel-listeners">Connection and Channel Listeners</a></li>
<li><a href="#channel-close-logging">Logging Channel Close Events</a></li>
<li><a href="#runtime-cache-properties">Runtime Cache Properties</a></li>
<li><a href="#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a></li>
</ul>
</li>
<li><a href="#custom-client-props">3.1.3. Adding Custom Client Connection Properties</a></li>
<li><a href="#amqp-template">3.1.4. <code>AmqpTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#template-retry">Adding Retry Capabilities</a></li>
<li><a href="#publishing-is-async">Publishing is Asynchronous&#8201;&#8212;&#8201;How to Detect Successes and Failures</a></li>
<li><a href="#template-confirms">Publisher Confirms and Returns</a></li>
<li><a href="#scoped-operations">Scoped Operations</a></li>
<li><a href="#template-messaging">Messaging Integration</a></li>
<li><a href="#template-user-id">Validated User Id</a></li>
<li><a href="#separate-connection">Using a Separate Connection</a></li>
</ul>
</li>
<li><a href="#sending-messages">3.1.5. Sending Messages</a>
<ul class="sectlevel4">
<li><a href="#message-builder">Message Builder API</a></li>
<li><a href="#_publisher_returns">Publisher Returns</a></li>
<li><a href="#template-batching">Batching</a></li>
</ul>
</li>
<li><a href="#receiving-messages">3.1.6. Receiving Messages</a>
<ul class="sectlevel4">
<li><a href="#polling-consumer">Polling Consumer</a></li>
<li><a href="#async-consumer">Asynchronous Consumer</a></li>
<li><a href="#de-batching">Batched Messages</a></li>
<li><a href="#consumer-events">Consumer Events</a></li>
<li><a href="#consumerTags">Consumer Tags</a></li>
<li><a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a></li>
<li><a href="#using-container-factories">Using Container Factories</a></li>
<li><a href="#async-returns">Asynchronous <code>@RabbitListener</code> Return Types</a></li>
<li><a href="#threading">Threading and Asynchronous Consumers</a></li>
<li><a href="#choose-container">Choosing a Container</a></li>
<li><a href="#idle-containers">Detecting Idle Asynchronous Consumers</a></li>
</ul>
</li>
<li><a href="#containers-and-broker-named-queues">3.1.7. Containers and Broker-Named queues</a></li>
<li><a href="#message-converters">3.1.8. Message Converters</a>
<ul class="sectlevel4">
<li><a href="#simple-message-converter"><code>SimpleMessageConverter</code></a></li>
<li><a href="#serializer-message-converter"><code>SerializerMessageConverter</code></a></li>
<li><a href="#json-message-converter">Jackson2JsonMessageConverter</a></li>
<li><a href="#_marshallingmessageconverter"><code>MarshallingMessageConverter</code></a></li>
<li><a href="#_jackson2xmlmessageconverter"><code>Jackson2XmlMessageConverter</code></a></li>
<li><a href="#_contenttypedelegatingmessageconverter"><code>ContentTypeDelegatingMessageConverter</code></a></li>
<li><a href="#java-deserialization">Java Deserialization</a></li>
<li><a href="#message-properties-converters">Message Properties Converters</a></li>
</ul>
</li>
<li><a href="#post-processing">3.1.9. Modifying Messages - Compression and More</a></li>
<li><a href="#request-reply">3.1.10. Request/Reply Messaging</a>
<ul class="sectlevel4">
<li><a href="#reply-timeout">Reply Timeout</a></li>
<li><a href="#direct-reply-to">RabbitMQ Direct reply-to</a></li>
<li><a href="#_message_correlation_with_a_reply_queue">Message Correlation With A Reply Queue</a></li>
<li><a href="#reply-listener">Reply Listener Container</a></li>
<li><a href="#async-template"><code>AsyncRabbitTemplate</code></a></li>
<li><a href="#remoting">Spring Remoting with AMQP</a></li>
</ul>
</li>
<li><a href="#broker-configuration">3.1.11. Configuring the Broker</a>
<ul class="sectlevel4">
<li><a href="#headers-exchange">Headers Exchange</a></li>
<li><a href="#builder-api">Builder API for Queues and Exchanges</a></li>
<li><a href="#collection-declaration">Declaring Collections of Exchanges, Queues, and Bindings</a></li>
<li><a href="#conditional-declaration">Conditional Declaration</a></li>
<li><a href="#note-id-name">A Note On the <code>id</code> and <code>name</code> Attributes</a></li>
<li><a href="#anonymous-queue"><code>AnonymousQueue</code></a></li>
</ul>
</li>
<li><a href="#broker-events">3.1.12. Broker Event Listener</a></li>
<li><a href="#delayed-message-exchange">3.1.13. Delayed Message Exchange</a></li>
<li><a href="#management-rest-api">3.1.14. RabbitMQ REST API</a></li>
<li><a href="#exception-handling">3.1.15. Exception Handling</a></li>
<li><a href="#transactions">3.1.16. Transactions</a>
<ul class="sectlevel4">
<li><a href="#conditional-rollback">Conditional Rollback</a></li>
<li><a href="#transaction-rollback">A note on Rollback of Received Messages</a></li>
<li><a href="#_using_rabbittransactionmanager">Using <code>RabbitTransactionManager</code></a></li>
</ul>
</li>
<li><a href="#containerAttributes">3.1.17. Message Listener Container Configuration</a></li>
<li><a href="#listener-concurrency">3.1.18. Listener Concurrency</a>
<ul class="sectlevel4">
<li><a href="#_simplemessagelistenercontainer">SimpleMessageListenerContainer</a></li>
<li><a href="#_using_directmessagelistenercontainer">Using <code>DirectMessageListenerContainer</code></a></li>
</ul>
</li>
<li><a href="#exclusive-consumer">3.1.19. Exclusive Consumer</a></li>
<li><a href="#listener-queues">3.1.20. Listener Container Queues</a></li>
<li><a href="#_resilience_recovering_from_errors_and_broker_failures">3.1.21. Resilience: Recovering from Errors and Broker Failures</a>
<ul class="sectlevel4">
<li><a href="#automatic-declaration">Automatic Declaration of Exchanges, Queues, and Bindings</a></li>
<li><a href="#retry">Failures in Synchronous Operations and Options for Retry</a></li>
<li><a href="#async-listeners">Message Listeners and the Asynchronous Case</a></li>
<li><a href="#_exception_classification_for_spring_retry">Exception Classification for Spring Retry</a></li>
</ul>
</li>
<li><a href="#_debugging">3.1.22. Debugging</a></li>
</ul>
</li>
<li><a href="#logging">3.2. Logging Subsystem AMQP Appenders</a>
<ul class="sectlevel3">
<li><a href="#_common_properties">3.2.1. Common properties</a></li>
<li><a href="#_log4j_2_appender">3.2.2. Log4j 2 Appender</a></li>
<li><a href="#_logback_appender">3.2.3. Logback Appender</a></li>
<li><a href="#_customizing_the_messages">3.2.4. Customizing the Messages</a></li>
<li><a href="#_customizing_the_client_properties">3.2.5. Customizing the Client Properties</a>
<ul class="sectlevel4">
<li><a href="#_simple_string_properties">Simple String Properties</a></li>
<li><a href="#_advanced_technique_for_logback">Advanced Technique for Logback</a></li>
</ul>
</li>
<li><a href="#_providing_a_custom_queue_implementation">3.2.6. Providing a Custom Queue Implementation</a></li>
</ul>
</li>
<li><a href="#sample-apps">3.3. Sample Applications</a>
<ul class="sectlevel3">
<li><a href="#hello-world-sample">3.3.1. The &#8220;Hello World&#8221; Sample</a>
<ul class="sectlevel4">
<li><a href="#hello-world-sync">Synchronous Example</a></li>
<li><a href="#hello-world-async">Asynchronous Example</a></li>
</ul>
</li>
<li><a href="#_stock_trading">3.3.2. Stock Trading</a></li>
<li><a href="#spring-rabbit-json">3.3.3. Receiving JSON from Non-Spring Applications</a></li>
</ul>
</li>
<li><a href="#testing">3.4. Testing Support</a>
<ul class="sectlevel3">
<li><a href="#mockito-answer">3.4.1. Mockito <code>Answer&lt;?&gt;</code> Implementations</a></li>
<li><a href="#test-harness">3.4.2. <code>@RabbitListenerTest</code> and <code>RabbitListenerTestHarness</code></a></li>
<li><a href="#test-template">3.4.3. Using <code>TestRabbitTemplate</code></a></li>
<li><a href="#junit-rules">3.4.4. JUnit4 <code>@Rules</code></a>
<ul class="sectlevel4">
<li><a href="#_using_brokerrunning">Using <code>BrokerRunning</code></a></li>
<li><a href="#_using_longrunningintegrationtest">Using <code>LongRunningIntegrationTest</code></a></li>
</ul>
</li>
<li><a href="#junit5-conditions">3.4.5. JUnit5 Conditions</a>
<ul class="sectlevel4">
<li><a href="#_using_the_rabbitavailable_annotation">Using the <code>@RabbitAvailable</code> Annotation</a></li>
<li><a href="#_using_the_longrunning_annotation">Using the <code>@LongRunning</code> Annotation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_spring_integration_reference">4. Spring Integration - Reference</a>
<ul class="sectlevel2">
<li><a href="#spring-integration-amqp">4.1. Spring Integration AMQP Support</a>
<ul class="sectlevel3">
<li><a href="#spring-integration-amqp-introduction">4.1.1. Introduction</a></li>
<li><a href="#_inbound_channel_adapter">4.1.2. Inbound Channel Adapter</a></li>
<li><a href="#_outbound_channel_adapter">4.1.3. Outbound Channel Adapter</a></li>
<li><a href="#_inbound_gateway">4.1.4. Inbound Gateway</a></li>
<li><a href="#_outbound_gateway">4.1.5. Outbound Gateway</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">5. Other Resources</a>
<ul class="sectlevel2">
<li><a href="#further-reading">5.1. Further Reading</a></li>
</ul>
</li>
<li><a href="#_change_history">Appendix A: Change History</a>
<ul class="sectlevel2">
<li><a href="#_current_release">A.1. Current Release</a></li>
<li><a href="#previous-whats-new">A.2. Previous Releases</a>
<ul class="sectlevel3">
<li><a href="#_changes_in_2_0_since_1_7">A.2.1. Changes in 2.0 Since 1.7</a>
<ul class="sectlevel4">
<li><a href="#_using_cachingconnectionfactory">Using <code>CachingConnectionFactory</code></a></li>
<li><a href="#_amqp_client_library_2">AMQP Client library</a></li>
<li><a href="#_general_changes">General Changes</a></li>
<li><a href="#_deleted_classes">Deleted Classes</a></li>
<li><a href="#_new_listener_container">New Listener Container</a></li>
<li><a href="#_log4j_appender">Log4j Appender</a></li>
<li><a href="#_rabbittemplate_changes_2"><code>RabbitTemplate</code> Changes</a></li>
<li><a href="#_listener_adapter">Listener Adapter</a></li>
<li><a href="#_listener_container_changes_2">Listener Container Changes</a></li>
<li><a href="#_connection_factory_changes_2">Connection Factory Changes</a></li>
<li><a href="#_retry_changes">Retry Changes</a></li>
<li><a href="#_anonymous_queue_naming">Anonymous Queue Naming</a></li>
<li><a href="#_rabbitlistener_changes_2"><code>@RabbitListener</code> Changes</a></li>
<li><a href="#_container_conditional_rollback">Container Conditional Rollback</a></li>
<li><a href="#_remove_jackson_1_x_support">Remove Jackson 1.x support</a></li>
<li><a href="#_json_message_converter">JSON Message Converter</a></li>
<li><a href="#_xml_parsers">XML Parsers</a></li>
<li><a href="#_blocked_connection">Blocked Connection</a></li>
</ul>
</li>
<li><a href="#_changes_in_1_7_since_1_6">A.2.2. Changes in 1.7 Since 1.6</a>
<ul class="sectlevel4">
<li><a href="#_amqp_client_library_3">AMQP Client library</a></li>
<li><a href="#_log4j_2_upgrade">Log4j 2 upgrade</a></li>
<li><a href="#_logback_appender_2">Logback Appender</a></li>
<li><a href="#_spring_retry_upgrade">Spring Retry Upgrade</a></li>
<li><a href="#_fasterxml_jackson_upgrade">FasterXML Jackson upgrade</a></li>
<li><a href="#_junit_rules">JUnit <code>@Rules</code></a></li>
<li><a href="#_container_conditional_rollback_2">Container Conditional Rollback</a></li>
<li><a href="#_connection_naming_strategy">Connection Naming Strategy</a></li>
<li><a href="#_listener_container_changes_3">Listener Container Changes</a></li>
</ul>
</li>
<li><a href="#_earlier_releases">A.2.3. Earlier Releases</a></li>
<li><a href="#_changes_in_1_6_since_1_5">A.2.4. Changes in 1.6 Since 1.5</a>
<ul class="sectlevel4">
<li><a href="#_testing_support">Testing Support</a></li>
<li><a href="#_builder">Builder</a></li>
<li><a href="#_namespace_changes">Namespace Changes</a></li>
<li><a href="#_listener_container_changes_4">Listener Container Changes</a></li>
<li><a href="#_autodeclare_and_rabbitadmin_instances"><code>AutoDeclare</code> and <code>RabbitAdmin</code> Instances</a></li>
<li><a href="#_amqptemplate_receive_with_timeout"><code>AmqpTemplate</code>: Receive with Timeout</a></li>
<li><a href="#_using_asyncrabbittemplate">Using <code>AsyncRabbitTemplate</code></a></li>
<li><a href="#_rabbittemplate_changes_3"><code>RabbitTemplate</code> Changes</a></li>
<li><a href="#_message_properties">Message Properties</a></li>
<li><a href="#_rabbitadmin_changes_2"><code>RabbitAdmin</code> Changes</a></li>
<li><a href="#_rabbitlistener_changes_3"><code>@RabbitListener</code> Changes</a></li>
<li><a href="#_delayed_message_exchange">Delayed Message Exchange</a></li>
<li><a href="#_exchange_internal_flag">Exchange Internal Flag</a></li>
<li><a href="#_cachingconnectionfactory_changes"><code>CachingConnectionFactory</code> Changes</a></li>
<li><a href="#_using_rabbitconnectionfactorybean">Using <code>RabbitConnectionFactoryBean</code></a></li>
<li><a href="#_java_deserialization">Java Deserialization</a></li>
<li><a href="#_json_messageconverter">JSON <code>MessageConverter</code></a></li>
<li><a href="#_logging_appenders">Logging Appenders</a></li>
</ul>
</li>
<li><a href="#_changes_in_1_5_since_1_4">A.2.5. Changes in 1.5 Since 1.4</a>
<ul class="sectlevel4">
<li><a href="#_spring_erlang_is_no_longer_supported"><code>spring-erlang</code> Is No Longer Supported</a></li>
<li><a href="#_cachingconnectionfactory_changes_2"><code>CachingConnectionFactory</code> Changes</a></li>
<li><a href="#_properties_to_control_container_queue_declaration_behavior">Properties to Control Container Queue Declaration Behavior</a></li>
<li><a href="#_class_package_change">Class Package Change</a></li>
<li><a href="#_defaultmessagepropertiesconverter_changes"><code>DefaultMessagePropertiesConverter</code> Changes</a></li>
<li><a href="#_rabbitlistener_improvements"><code>@RabbitListener</code> Improvements</a></li>
<li><a href="#_automatic_exchange_queue_and_binding_declaration">Automatic Exchange, Queue, and Binding Declaration</a></li>
<li><a href="#_rabbittemplate_changes_4"><code>RabbitTemplate</code> Changes</a></li>
<li><a href="#_rabbitmanagementtemplate_added"><code>RabbitManagementTemplate</code> Added</a></li>
<li><a href="#_listener_container_bean_names_xml">Listener Container Bean Names (XML)</a></li>
<li><a href="#_class_level_rabbitlistener">Class-Level <code>@RabbitListener</code></a></li>
<li><a href="#_simplemessagelistenercontainer_backoff_support"><code>SimpleMessageListenerContainer</code>: BackOff Support</a></li>
<li><a href="#_channel_close_logging">Channel Close Logging</a></li>
<li><a href="#_application_events">Application Events</a></li>
<li><a href="#_consumer_tag_configuration">Consumer Tag Configuration</a></li>
<li><a href="#_using_messagelisteneradapter">Using <code>MessageListenerAdapter</code></a></li>
<li><a href="#_localizedqueueconnectionfactory_added"><code>LocalizedQueueConnectionFactory</code> Added</a></li>
<li><a href="#_anonymous_queue_naming_2">Anonymous Queue Naming</a></li>
</ul>
</li>
<li><a href="#_changes_in_1_4_since_1_3">A.2.6. Changes in 1.4 Since 1.3</a>
<ul class="sectlevel4">
<li><a href="#_rabbitlistener_annotation"><code>@RabbitListener</code> Annotation</a></li>
<li><a href="#_rabbitmessagingtemplate_added"><code>RabbitMessagingTemplate</code> Added</a></li>
<li><a href="#_listener_container_missingqueuesfatal_attribute">Listener Container <code>missingQueuesFatal</code> Attribute</a></li>
<li><a href="#_rabbittemplate_confirmcallback_interface">RabbitTemplate <code>ConfirmCallback</code> Interface</a></li>
<li><a href="#_rabbitconnectionfactorybean_added"><code>RabbitConnectionFactoryBean</code> Added</a></li>
<li><a href="#_using_cachingconnectionfactory_2">Using <code>CachingConnectionFactory</code></a></li>
<li><a href="#_log_appender">Log Appender</a></li>
<li><a href="#_listener_queues">Listener Queues</a></li>
<li><a href="#_rabbittemplate_mandatory_and_connectionfactoryselector_expressions"><code>RabbitTemplate</code>: <code>mandatory</code> and <code>connectionFactorySelector</code> Expressions</a></li>
<li><a href="#_listeners_and_the_routing_connection_factory">Listeners and the Routing Connection Factory</a></li>
<li><a href="#_rabbittemplate_recoverycallback_option"><code>RabbitTemplate</code>: <code>RecoveryCallback</code> Option</a></li>
<li><a href="#_messageconversionexception_change"><code>MessageConversionException</code> Change</a></li>
<li><a href="#_rabbitmq_3_4_compatibility">RabbitMQ 3.4 Compatibility</a></li>
<li><a href="#_contenttypedelegatingmessageconverter_added"><code>ContentTypeDelegatingMessageConverter</code> Added</a></li>
</ul>
</li>
<li><a href="#_changes_in_1_3_since_1_2">A.2.7. Changes in 1.3 Since 1.2</a>
<ul class="sectlevel4">
<li><a href="#_listener_concurrency">Listener Concurrency</a></li>
<li><a href="#_listener_queues_2">Listener Queues</a></li>
<li><a href="#_consumer_priority">Consumer Priority</a></li>
<li><a href="#_exclusive_consumer">Exclusive Consumer</a></li>
<li><a href="#_rabbit_admin">Rabbit Admin</a></li>
<li><a href="#_direct_exchange_binding">Direct Exchange Binding</a></li>
<li><a href="#_amqptemplate_changes"><code>AmqpTemplate</code> Changes</a></li>
<li><a href="#_caching_connection_factory">Caching Connection Factory</a></li>
<li><a href="#_binding_arguments">Binding Arguments</a></li>
<li><a href="#_routing_connection_factory">Routing Connection Factory</a></li>
<li><a href="#_messagebuilder_and_messagepropertiesbuilder"><code>MessageBuilder</code> and <code>MessagePropertiesBuilder</code></a></li>
<li><a href="#_retryinterceptorbuilder_change"><code>RetryInterceptorBuilder</code> Change</a></li>
<li><a href="#_republishmessagerecoverer_added"><code>RepublishMessageRecoverer</code> Added</a></li>
<li><a href="#_default_error_handler_since_1_3_2">Default Error Handler (Since 1.3.2)</a></li>
<li><a href="#_listener_container_missingqueuesfatal_property_since_1_3_5">Listener Container 'missingQueuesFatal` Property (Since 1.3.5)</a></li>
</ul>
</li>
<li><a href="#_changes_to_1_2_since_1_1">A.2.8. Changes to 1.2 Since 1.1</a>
<ul class="sectlevel4">
<li><a href="#_rabbitmq_version">RabbitMQ Version</a></li>
<li><a href="#_rabbit_admin_2">Rabbit Admin</a></li>
<li><a href="#_rabbit_template">Rabbit Template</a></li>
<li><a href="#_json_message_converters">JSON Message Converters</a></li>
<li><a href="#_automatic_declaration_of_queues_and_other_items">Automatic Declaration of Queues and Other Items</a></li>
<li><a href="#_amqp_remoting">AMQP Remoting</a></li>
<li><a href="#_requested_heart_beats">Requested Heart Beats</a></li>
</ul>
</li>
<li><a href="#_changes_to_1_1_since_1_0">A.2.9. Changes to 1.1 Since 1.0</a>
<ul class="sectlevel4">
<li><a href="#_general">General</a></li>
<li><a href="#_amqp_log4j_appender">AMQP Log4j Appender</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>2.1.6.RELEASE</strong></p>
</div>
<div class="paragraph">
<p>&#169; 2010 - 2019 by Pivotal Software, Inc.</p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preface">1. Preface</h2>
<div class="sectionbody">
<div id="preface" class="paragraph">
<p>The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.
We provide a &#8220;template&#8221; as a high-level abstraction for sending and receiving messages.
We also provide support for message-driven POJOs.
These libraries facilitate management of AMQP resources while promoting the use of dependency injection and declarative configuration.
In all of these cases, you can see similarities to the JMS support in the Spring Framework.
For other project-related information, visit the Spring AMQP project <a href="https://projects.spring.io/spring-amqp/">homepage</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">2. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This first part of the reference documentation is a high-level overview of Spring AMQP and the underlying concepts.
It includes some code snippets to get you up and running as quickly as possible.</p>
</div>
<div class="sect2">
<h3 id="quick-tour">2.1. Quick Tour for the impatient</h3>
<div class="sect3">
<h4 id="_introduction_2">2.1.1. Introduction</h4>
<div class="paragraph">
<p>This is the five-minute tour to get started with Spring AMQP.</p>
</div>
<div class="paragraph">
<p>Prerequisites: Install and run the RabbitMQ broker (<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>).
Then grab the spring-rabbit JAR and all its dependencies - the easiest way to do so is to declare a dependency in your build tool.
For example, for Maven, you can do something resembling the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
  &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;
  &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For Gradle, you can do something resembling the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile 'org.springframework.amqp:spring-rabbit:2.1.6.RELEASE'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="compatibility">Compatibility</h5>
<div class="paragraph">
<p>The minimum Spring Framework version dependency is 5.1.x.</p>
</div>
<div class="paragraph">
<p>The minimum <code>amqp-client</code> Java client library version is 5.4.0.</p>
</div>
</div>
<div class="sect4">
<h5 id="_very_very_quick">Very, Very Quick</h5>
<div class="paragraph">
<p>This section offers the fastest introduction.</p>
</div>
<div class="paragraph">
<p>First, add the following <code>import</code> statements to make the examples later in this section work:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitAdmin;
import org.springframework.amqp.rabbit.core.RabbitTemplate;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example uses plain, imperative Java to send and receive a message:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ConnectionFactory connectionFactory = new CachingConnectionFactory();
AmqpAdmin admin = new RabbitAdmin(connectionFactory);
admin.declareQueue(new Queue("myqueue"));
AmqpTemplate template = new RabbitTemplate(connectionFactory);
template.convertAndSend("myqueue", "foo");
String foo = (String) template.receiveAndConvert("myqueue");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that there is also a <code>ConnectionFactory</code> in the native Java Rabbit client.
We use the Spring abstraction in the preceding code.
It caches channels (and optionally connections) for reuse.
We rely on the default exchange in the broker (since none is specified in the send), and the default binding of all queues to the default exchange by their name (thus, we can use the queue name as a routing key in the send).
Those behaviors are defined in the AMQP specification.</p>
</div>
</div>
<div class="sect4">
<h5 id="_with_xml_configuration">With XML Configuration</h5>
<div class="paragraph">
<p>The following example is the same as the preceding example but externalizes the resource configuration to XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ApplicationContext context =
    new GenericXmlApplicationContext("classpath:/rabbit-context.xml");
AmqpTemplate template = context.getBean(AmqpTemplate.class);
template.convertAndSend("myqueue", "foo");
String foo = (String) template.receiveAndConvert("myqueue");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:rabbit="http://www.springframework.org/schema/rabbit"
       xsi:schemaLocation="http://www.springframework.org/schema/rabbit
           https://www.springframework.org/schema/rabbit/spring-rabbit.xsd
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;rabbit:connection-factory id="connectionFactory"/&gt;

    &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory"/&gt;

    &lt;rabbit:admin connection-factory="connectionFactory"/&gt;

    &lt;rabbit:queue name="myqueue"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the <code>&lt;rabbit:admin/&gt;</code> declaration automatically looks for beans of type <code>Queue</code>, <code>Exchange</code>, and <code>Binding</code> and declares them to the broker on behalf of the user.
As a result, you need not use that bean explicitly in the simple Java driver.
There are plenty of options to configure the properties of the components in the XML schema.
You can use auto-complete features of your XML editor to explore them and look at their documentation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_with_java_configuration">With Java Configuration</h5>
<div class="paragraph">
<p>The following example repeats the same example as the preceding example but with the external configuration defined in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ApplicationContext context =
    new AnnotationConfigApplicationContext(RabbitConfiguration.class);
AmqpTemplate template = context.getBean(AmqpTemplate.class);
template.convertAndSend("myqueue", "foo");
String foo = (String) template.receiveAndConvert("myqueue");

........

@Configuration
public class RabbitConfiguration {

    @Bean
    public ConnectionFactory connectionFactory() {
        return new CachingConnectionFactory("localhost");
    }

    @Bean
    public AmqpAdmin amqpAdmin() {
        return new RabbitAdmin(connectionFactory());
    }

    @Bean
    public RabbitTemplate rabbitTemplate() {
        return new RabbitTemplate(connectionFactory());
    }

    @Bean
    public Queue myQueue() {
       return new Queue("myqueue");
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_with_spring_boot_auto_configuration_and_an_async_pojo_listener">With Spring Boot Auto Configuration and an Async POJO Listener</h5>
<div class="paragraph">
<p>Spring Boot automatically configures the infrastructure beans, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    public ApplicationRunner runner(AmqpTemplate template) {
        return args -&gt; template.convertAndSend("myqueue", "foo");
    }

    @Bean
    public Queue myQueue() {
        return new Queue("myqueue");
    }

    @RabbitListener(queues = "myqueue")
    public void listen(String in) {
        System.out.println(in);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="whats-new">2.2. What&#8217;s New</h3>
<div class="sect3">
<h4 id="_changes_in_2_1_since_2_0">2.2.1. Changes in 2.1 Since 2.0</h4>
<div class="paragraph">
<p>This section describes the changes between version 2.0 and version 2.1.</p>
</div>
<div class="sect4">
<h5 id="_amqp_client_library">AMQP Client library</h5>
<div class="paragraph">
<p>Spring AMQP now uses the 5.4.x version of the <code>amqp-client</code> library provided by the RabbitMQ team.
This client has auto-recovery configured by default.
See <a href="#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of version 4.0, the client enables automatic recovery by default.
While compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally is not needed.
We recommend disabling <code>amqp-client</code> automatic recovery, to avoid getting <code>AutoRecoverConnectionNotCurrentlyOpenException</code> instances when the broker is available but the connection has not yet recovered.
Starting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the <code>CachingConnectionFactory</code>.
RabbitMQ <code>ConnectionFactory</code> instances created by the <code>RabbitConnectionFactoryBean</code> also have the option disabled by default.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_package_changes">Package Changes</h5>
<div class="paragraph">
<p>Certain classes have moved to different packages.
Most are internal classes and do not affect user applications.
Two exceptions are <code>ChannelAwareMessageListener</code> and <code>RabbitListenerErrorHandler</code>.
These interfaces are now in <code>org.springframework.amqp.rabbit.listener.api</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_publisher_confirms_changes">Publisher Confirms Changes</h5>
<div class="paragraph">
<p>Channels enabled for publisher confirmations are not returned to the cache while there are outstanding confirmations.
See <a href="#template-confirms">Publisher Confirms and Returns</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_factory_improvements">Listener Container Factory Improvements</h5>
<div class="paragraph">
<p>You can now use the listener container factories to create any listener container, not only those for use with <code>@RabbitListener</code> annotations or the <code>@RabbitListenerEndpointRegistry</code>.
See <a href="#using-container-factories">Using Container Factories</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>ChannelAwareMessageListener</code> now inherits from <code>MessageListener</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_broker_event_listener">Broker Event Listener</h5>
<div class="paragraph">
<p>A <code>BrokerEventListener</code> is introduced to publish selected broker events as <code>ApplicationEvent</code> instances.
See <a href="#broker-events">Broker Event Listener</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitadmin_changes">RabbitAdmin Changes</h5>
<div class="paragraph">
<p>The <code>RabbitAdmin</code> discovers beans of type <code>Declarables</code> (which is a container for <code>Declarable</code> - <code>Queue</code>, <code>Exchange</code>, and <code>Binding</code> objects) and declare the contained objects on the broker.
Users are discouraged from using the old mechanism of declaring <code>&lt;Collection&lt;Queue&gt;&gt;</code> (and others) and should use <code>Declarables</code> beans instead.
By default, the old mechanism is disabled.
See <a href="#collection-declaration">Declaring Collections of Exchanges, Queues, and Bindings</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>AnonymousQueue</code> isntances are now declared with <code>x-queue-master-locator</code> set to <code>client-local</code> by default, to ensure the queues are created on the node the application is connected to.
See <a href="#broker-configuration">Configuring the Broker</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_changes">RabbitTemplate Changes</h5>
<div class="paragraph">
<p>You can now configure the <code>RabbitTemplate</code> with the <code>noLocalReplyConsumer</code> option to control a <code>noLocal</code> flag for reply consumers in the <code>sendAndReceive()</code> operations.
See <a href="#request-reply">Request/Reply Messaging</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>CorrelationData</code> for publisher confirmations now has a <code>ListenableFuture</code>, which you can use to get the acknowledgment instead of using a callback.
When returns and confirmations are enabled, the correlation data, if provided, is populated with the returned message.
See <a href="#template-confirms">Publisher Confirms and Returns</a> for more information.</p>
</div>
<div class="paragraph">
<p>A method called <code>replyTimedOut</code> is now provided to notify subclasses that a reply has timed out, allowing for any state cleanup.
See <a href="#reply-timeout">Reply Timeout</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now specify an <code>ErrorHandler</code> to be invoked when using request/reply with a <code>DirectReplyToMessageListenerContainer</code> (the default) when exceptions occur when replies are delivered (for example, late replies).
See <code>setReplyErrorHandler</code> on the <code>RabbitTemplate</code>.
(Also since 2.0.11).</p>
</div>
</div>
<div class="sect4">
<h5 id="_message_conversion">Message Conversion</h5>
<div class="paragraph">
<p>We introduced a new <code>Jackson2XmlMessageConverter</code> to support converting messages from and to XML format.
See <a href="#Jackson2XmlMessageConverter">[Jackson2XmlMessageConverter]</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_management_rest_api">Management REST API</h5>
<div class="paragraph">
<p>The <code>RabbitManagementTemplate</code> is now deprecated in favor of the direct <code>com.rabbitmq.http.client.Client</code> (or <code>com.rabbitmq.http.client.ReactorNettyClient</code>) usage.
See <a href="#management-rest-api">RabbitMQ REST API</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitlistener_changes"><code>@RabbitListener</code> Changes</h5>
<div class="paragraph">
<p>The listener container factory can now be configured with a <code>RetryTemplate</code> and, optionally, a <code>RecoveryCallback</code> used when sending replies.
See <a href="#async-annotation-driven-enable">Enable Listener Endpoint Annotations</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_async_rabbitlistener_return">Async <code>@RabbitListener</code> Return</h5>
<div class="paragraph">
<p><code>@RabbitListener</code> methods can now return <code>ListenableFuture&lt;?&gt;</code> or <code>Mono&lt;?&gt;</code>.
See <a href="#async-return">[async-return]</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_connection_factory_bean_changes">Connection Factory Bean Changes</h5>
<div class="paragraph">
<p>By default, the <code>RabbitConnectionFactoryBean</code> now calls <code>enableHostnameVerification()</code>.
To revert to the previous behavior, set the <code>enableHostnameVerification</code> property to <code>false</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_connection_factory_changes">Connection Factory Changes</h5>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> now unconditionally disables auto-recovery in the underlying RabbitMQ <code>ConnectionFactory</code>, even if a pre-configured instance is provided in a constructor.
While steps have been taken to make Spring AMQP compatible with auto recovery, certain corner cases have arisen where issues remain.
Spring AMQP has had its own recovery mechanism since 1.0.0 and does not need to use the recovery provided by the client.
While it is still possible to enable the feature (using <code>cachingConnectionFactory.getRabbitConnectionFactory()</code> <code>.setAutomaticRecoveryEnabled()</code>) after the <code>CachingConnectionFactory</code> is constructed, <strong>we strongly recommend that you not do so</strong>.
We recommend that you use a separate RabbitMQ <code>ConnectionFactory</code> if you need auto recovery connections when using the client factory directly (rather than using Spring AMQP components).</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_changes">Listener Container Changes</h5>
<div class="paragraph">
<p>The default <code>ConditionalRejectingErrorHandler</code> now completely discards messages that cause fatal errors if an <code>x-death</code> header is present.
See <a href="#exception-handling">Exception Handling</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_immediate_requeue">Immediate requeue</h5>
<div class="paragraph">
<p>A new <code>ImmediateRequeueAmqpException</code> is introduced to notify a listener container that the message has to be re-queued.
To use this feature, a new <code>ImmediateRequeueMessageRecoverer</code> implementation is added.</p>
</div>
<div class="paragraph">
<p>See <a href="#async-listeners">Message Listeners and the Asynchronous Case</a> for more information.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reference">3. Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation details the various components that comprise Spring AMQP.
The <a href="#amqp">main chapter</a> covers the core classes to develop an AMQP application.
This part also includes a chapter about the <a href="#sample-apps">sample applications</a>.</p>
</div>
<div class="sect2">
<h3 id="amqp">3.1. Using Spring AMQP</h3>
<div class="paragraph">
<p>This chapter explores the interfaces and classes that are the essential components for developing applications with Spring AMQP.</p>
</div>
<div class="sect3">
<h4 id="_amqp_abstractions">3.1.1. AMQP Abstractions</h4>
<div class="paragraph">
<p>Spring AMQP consists of two modules (each represented by a JAR in the distribution): <code>spring-amqp</code> and <code>spring-rabbit</code>.
The 'spring-amqp' module contains the <code>org.springframework.amqp.core</code> package.
Within that package, you can find the classes that represent the core AMQP &#8220;model&#8221;.
Our intention is to provide generic abstractions that do not rely on any particular AMQP broker implementation or client library.
End user code can be more portable across vendor implementations as it can be developed against the abstraction layer only.
These abstractions are then implemented by broker-specific modules, such as 'spring-rabbit'.
There is currently only a RabbitMQ implementation.
However, the abstractions have been validated in .NET using Apache Qpid in addition to RabbitMQ.
Since AMQP operates at the protocol level, in principle, you can use the RabbitMQ client with any broker that supports the same protocol version, but we do not test any other brokers at present.</p>
</div>
<div class="paragraph">
<p>This overview assumes that you are already familiar with the basics of the AMQP specification.
If not, have a look at the resources listed in <a href="#resources">Other Resources</a></p>
</div>
<div class="sect4">
<h5 id="_message"><code>Message</code></h5>
<div class="paragraph">
<p>The 0-9-1 AMQP specification does not define a <code>Message</code> class or interface.
Instead, when performing an operation such as <code>basicPublish()</code>, the content is passed as a byte-array argument and additional properties are passed in as separate arguments.
Spring AMQP defines a <code>Message</code> class as part of a more general AMQP domain model representation.
The purpose of the <code>Message</code> class is to encapsulate the body and properties within a single instance so that the API can, in turn, be simpler.
The following example shows the <code>Message</code> class definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Message {

    private final MessageProperties messageProperties;

    private final byte[] body;

    public Message(byte[] body, MessageProperties messageProperties) {
        this.body = body;
        this.messageProperties = messageProperties;
    }

    public byte[] getBody() {
        return this.body;
    }

    public MessageProperties getMessageProperties() {
        return this.messageProperties;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>MessageProperties</code> interface defines several common properties, such as 'messageId', 'timestamp', 'contentType', and several more.
You can also extend those properties with user-defined 'headers' by calling the <code>setHeader(String key, Object value)</code> method.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with versions <code>1.5.7</code>, <code>1.6.11</code>, <code>1.7.4</code>, and <code>2.0.0</code>, if a message body is a serialized <code>Serializable</code> java object, it is no longer deserialized (by default) when performing <code>toString()</code> operations (such as in log messages).
This is to prevent unsafe deserialization.
By default, only <code>java.util</code> and <code>java.lang</code> classes are deserialized.
To revert to the previous behavior, you can add allowable class/package patterns by invoking <code>Message.addWhiteListPatterns(&#8230;&#8203;)</code>.
A simple <code><strong></code> wildcard is supported, for example <code>com.something.</strong>, *.MyClass</code>.
Bodies that cannot be deserialized are represented by <code>byte[&lt;size&gt;]</code> in log messages.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_exchange">Exchange</h5>
<div class="paragraph">
<p>The <code>Exchange</code> interface represents an AMQP Exchange, which is what a Message Producer sends to.
Each Exchange within a virtual host of a broker has a unique name as well as a few other properties.
The following example shows the <code>Exchange</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Exchange {

    String getName();

    String getExchangeType();

    boolean isDurable();

    boolean isAutoDelete();

    Map&lt;String, Object&gt; getArguments();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, an <code>Exchange</code> also has a 'type' represented by constants defined in <code>ExchangeTypes</code>.
The basic types are: <code>direct</code>, <code>topic</code>, fanout`, and <code>headers</code>.
In the core package, you can find implementations of the <code>Exchange</code> interface for each of those types.
The behavior varies across these <code>Exchange</code> types in terms of how they handle bindings to queues.
For example, a <code>Direct</code> exchange lets a queue be bound by a fixed routing key (often the queue&#8217;s name).
A <code>Topic</code> exchange supports bindings with routing patterns that may include the '*' and '#' wildcards for 'exactly-one' and 'zero-or-more', respectively.
The <code>Fanout</code> exchange publishes to all queues that are bound to it without taking any routing key into consideration.
For much more information about these and the other Exchange types, see <a href="#resources">Other Resources</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The AMQP specification also requires that any broker provide a &#8220;default&#8221; direct exchange that has no name.
All queues that are declared are bound to that default <code>Exchange</code> with their names as routing keys.
You can learn more about the default Exchange&#8217;s usage within Spring AMQP in <a href="#amqp-template"><code>AmqpTemplate</code></a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_queue">Queue</h5>
<div class="paragraph">
<p>The <code>Queue</code> class represents the component from which a message consumer receives messages.
Like the various <code>Exchange</code> classes, our implementation is intended to be an abstract representation of this core AMQP type.
The following listing shows the <code>Queue</code> class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Queue  {

    private final String name;

    private volatile boolean durable;

    private volatile boolean exclusive;

    private volatile boolean autoDelete;

    private volatile Map&lt;String, Object&gt; arguments;

    /**
     * The queue is durable, non-exclusive and non auto-delete.
     *
     * @param name the name of the queue.
     */
    public Queue(String name) {
        this(name, true, false, false);
    }

    // Getters and Setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the constructor takes the queue name.
Depending on the implementation, the admin template may provide methods for generating a uniquely named queue.
Such queues can be useful as a &#8220;reply-to&#8221; address or in other <strong>temporary</strong> situations.
For that reason, the 'exclusive' and 'autoDelete' properties of an auto-generated queue would both be set to 'true'.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the section on queues in <a href="#broker-configuration">Configuring the Broker</a> for information about declaring queues by using namespace support, including queue arguments.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_binding">Binding</h5>
<div class="paragraph">
<p>Given that a producer sends to an exchange and a consumer receives from a queue, the bindings that connect queues to exchanges are critical for connecting those producers and consumers via messaging.
In Spring AMQP, we define a <code>Binding</code> class to represent those connections.
This section reviews the basic options for binding queues to exchanges.</p>
</div>
<div class="paragraph">
<p>You can bind a queue to a <code>DirectExchange</code> with a fixed routing key, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new Binding(someQueue, someDirectExchange, "foo.bar");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can bind a queue to a <code>TopicExchange</code> with a routing pattern, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new Binding(someQueue, someTopicExchange, "foo.*");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can bind a queue to a <code>FanoutExchange</code> with no routing key, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new Binding(someQueue, someFanoutExchange);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We also provide a <code>BindingBuilder</code> to facilitate a &#8220;fluent API&#8221; style, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with("foo.*");</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For clarity, the preceding example shows the <code>BindingBuilder</code> class, but this style works well when using a static import for the 'bind()' method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By itself, an instance of the <code>Binding</code> class only holds the data about a connection.
In other words, it is not an &#8220;active&#8221; component.
However, as you will see later in <a href="#broker-configuration">Configuring the Broker</a>, the <code>AmqpAdmin</code> class can use <code>Binding</code> instances to actually trigger the binding actions on the broker.
Also, as you can see in that same section, you can define the <code>Binding</code> instances by using Spring&#8217;s <code>@Bean</code> annotations within <code>@Configuration</code> classes.
There is also a convenient base class that further simplifies that approach for generating AMQP-related bean definitions and recognizes the queues, exchanges, and bindings so that they are all declared on the AMQP broker upon application startup.</p>
</div>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> is also defined within the core package.
As one of the main components involved in actual AMQP messaging, it is discussed in detail in its own section (see <a href="#amqp-template"><code>AmqpTemplate</code></a>).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connections">3.1.2. Connection and Resource Management</h4>
<div class="paragraph">
<p>Whereas the AMQP model we described in the previous section is generic and applicable to all implementations, when we get into the management of resources, the details are specific to the broker implementation.
Therefore, in this section, we focus on code that exists only within our &#8220;spring-rabbit&#8221; module since, at this point, RabbitMQ is the only supported implementation.</p>
</div>
<div class="paragraph">
<p>The central component for managing a connection to the RabbitMQ broker is the <code>ConnectionFactory</code> interface.
The responsibility of a <code>ConnectionFactory</code> implementation is to provide an instance of <code>org.springframework.amqp.rabbit.connection.Connection</code>, which is a wrapper for <code>com.rabbitmq.client.Connection</code>.
The only concrete implementation we provide is <code>CachingConnectionFactory</code>, which, by default, establishes a single connection proxy that can be shared by the application.
Sharing of the connection is possible since the &#8220;unit of work&#8221; for messaging with AMQP is actually a &#8220;channel&#8221; (in some ways, this is similar to the relationship between a connection and a session in JMS).
The connection instance provides a <code>createChannel</code> method.
The <code>CachingConnectionFactory</code> implementation supports caching of those channels, and it maintains separate caches for channels based on whether they are transactional.
When creating an instance of <code>CachingConnectionFactory</code>, you can provide the 'hostname' through the constructor.
You should also provide the 'username' and 'password' properties.
To configure the size of the channel cache (the default is 25), you can call the
<code>setChannelCacheSize()</code> method.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.3, you can configure the <code>CachingConnectionFactory</code> to cache connections as well as only channels.
In this case, each call to <code>createConnection()</code> creates a new connection (or retrieves an idle one from the cache).
Closing a connection returns it to the cache (if the cache size has not been reached).
Channels created on such connections are also cached.
The use of separate connections might be useful in some environments, such as consuming from an HA cluster, in
conjunction with a load balancer, to connect to different cluster members, and others.
To cache connections, set the <code>cacheMode</code> to <code>CacheMode.CONNECTION</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This does not limit the number of connections.
Rather, it specifies how many idle open connections are allowed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 1.5.5, a new property called <code>connectionLimit</code> is provided.
When this property is set, it limits the total number of connections allowed.
When set, if the limit is reached, the <code>channelCheckoutTimeLimit</code> is used to wait for a connection to become idle.
If the time is exceeded, an <code>AmqpTimeoutException</code> is thrown.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the cache mode is <code>CONNECTION</code>, automatic declaration of queues and others
(See <a href="#automatic-declaration">Automatic Declaration of Exchanges, Queues, and Bindings</a>) is NOT supported.</p>
</div>
<div class="paragraph">
<p>Also, at the time of this writing, the <code>amqp-client</code> library by default creates a fixed thread pool for each connection (default size: <code>Runtime.getRuntime().availableProcessors() * 2</code> threads).
When using a large number of connections, you should consider setting a custom <code>executor</code> on the <code>CachingConnectionFactory</code>.
Then, the same executor can be used by all connections and its threads can be shared.
The executor&#8217;s thread pool should be unbounded or set appropriately for the expected use (usually, at least one thread per connection).
If multiple channels are created on each connection, the pool size affects the concurrency, so a variable (or simple cached) thread pool executor would be most suitable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is important to understand that the cache size is (by default) not a limit but is merely the number of channels that can be cached.
With a cache size of, say, 10, any number of channels can actually be in use.
If more than 10 channels are being used and they are all returned to the cache, 10 go in the cache.
The remainder are physically closed.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6, the default channel cache size has been increased from 1 to 25.
In high volume, multi-threaded environments, a small cache means that channels are created and closed at a high rate.
Increasing the default cache size can avoid this overhead.
You should monitor the channels in use through the RabbitMQ Admin UI and consider increasing the cache size further if you
see many channels being created and closed.
The cache grows only on-demand (to suit the concurrency requirements of the application), so this change does not
impact existing low-volume applications.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4.2, the <code>CachingConnectionFactory</code> has a property called <code>channelCheckoutTimeout</code>.
When this property is greater than zero, the <code>channelCacheSize</code> becomes a limit on the number of channels that can be created on a connection.
If the limit is reached, calling threads block until a channel is available or this timeout is reached, in which case a <code>AmqpTimeoutException</code> is thrown.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Channels used within the framework (for example,
<code>RabbitTemplate</code>) are reliably returned to the cache.
If you create channels outside of the framework, (for example,
by accessing the connections directly and invoking <code>createChannel()</code>), you must return them (by closing) reliably, perhaps in a <code>finally</code> block, to avoid running out of channels.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to create a new <code>connection</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingConnectionFactory connectionFactory = new CachingConnectionFactory("somehost");
connectionFactory.setUsername("guest");
connectionFactory.setPassword("guest");

Connection connection = connectionFactory.createConnection();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>When using XML, the configuration might look like the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory"&gt;
    &lt;constructor-arg value="somehost"/&gt;
    &lt;property name="username" value="guest"/&gt;
    &lt;property name="password" value="guest"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is also a <code>SingleConnectionFactory</code> implementation that is available only in the unit test code of the framework.
It is simpler than <code>CachingConnectionFactory</code>, since it does not cache channels, but it is not intended for practical usage outside of simple tests due to its lack of performance and resilience.
If you need to implement your own <code>ConnectionFactory</code> for some reason, the <code>AbstractConnectionFactory</code> base class may provide a nice starting point.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>ConnectionFactory</code> can be created quickly and conveniently by using the rabbit namespace, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory id="connectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In most cases, this approach is preferable, since the framework can choose the best defaults for you.
The created instance is a <code>CachingConnectionFactory</code>.
Keep in mind that the default cache size for channels is 25.
If you want more channels to be cachedm, set a larger value by setting the 'channelCacheSize' property.
In XML it would look like as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory"&gt;
    &lt;constructor-arg value="somehost"/&gt;
    &lt;property name="username" value="guest"/&gt;
    &lt;property name="password" value="guest"/&gt;
    &lt;property name="channelCacheSize" value="50"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also, with the namespace, you can add the 'channel-cache-size' attribute, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory
    id="connectionFactory" channel-cache-size="50"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The default cache mode is <code>CHANNEL</code>, but you can configure it to cache connections instead.
In the following example, we use <code>connection-cache-size</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory
    id="connectionFactory" cache-mode="CONNECTION" connection-cache-size="25"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can provide host and port attributes by using the namespace, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory
    id="connectionFactory" host="somehost" port="5672"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if running in a clustered environment, you can use the addresses attribute, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory
    id="connectionFactory" addresses="host1:5672,host2:5672"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example with a custom thread factory that prefixes thread names with <code>rabbitmq-</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory id="multiHost" virtual-host="/bar" addresses="host1:1234,host2,host3:4567"
    thread-factory="tf"
    channel-cache-size="10" username="user" password="password" /&gt;

&lt;bean id="tf" class="org.springframework.scheduling.concurrent.CustomizableThreadFactory"&gt;
    &lt;constructor-arg value="rabbitmq-" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_naming_connections">Naming Connections</h5>
<div class="paragraph">
<p>Starting with version 1.7, a <code>ConnectionNameStrategy</code> is provided for the injection into the <code>AbstractionConnectionFactory</code>.
The generated name is used for the application-specific identification of the target RabbitMQ connection.
The connection name is displayed in the management UI if the RabbitMQ server supports it.
This value does not have to be unique and cannot be used as a connection identifier&#8201;&#8212;&#8201;for example, in HTTP API requests.
This value is supposed to be human-readable and is a part of <code>ClientProperties</code> under the <code>connection_name</code> key.
You can use a simple Lambda, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">connectionFactory.setConnectionNameStrategy(connectionFactory -&gt; "MY_CONNECTION");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>ConnectionFactory</code> argument can be used to distinguish target connection names by some logic.
By default, the <code>beanName</code> of the <code>AbstractConnectionFactory</code>, a hex string representing the object, and an internal counter are used to generate the <code>connection_name</code>.
The <code>&lt;rabbit:connection-factory&gt;</code> namespace component is also supplied with the <code>connection-name-strategy</code> attribute.</p>
</div>
<div class="paragraph">
<p>An implementation of <code>SimplePropertyValueConnectionNameStrategy</code> sets the connection name to an application property.
You can declare it as a <code>@Bean</code> and inject it into the connection factory, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConnectionNameStrategy cns() {
    return new SimplePropertyValueConnectionNameStrategy("spring.application.name");
}

@Bean
public ConnectionFactory rabbitConnectionFactory(ConnectionNameStrategy cns) {
    CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
    ...
    connectionFactory.setConnectionNameStrategy(cns);
    return connectionFactory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The property must exist in the application context&#8217;s <code>Environment</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using Spring Boot and its autoconfigured connection factory, you need only declare the <code>ConnectionNameStrategy</code> <code>@Bean</code>.
Boot auto-detects the bean and wires it into the factory.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_blocked_connections_and_resource_constraints">Blocked Connections and Resource Constraints</h5>
<div class="paragraph">
<p>The connection might be blocked for interaction from the broker that corresponds to the <a href="https://www.rabbitmq.com/memory.html">Memory Alarm</a>.
Starting with version 2.0, the <code>org.springframework.amqp.rabbit.connection.Connection</code> can be supplied with <code>com.rabbitmq.client.BlockedListener</code> instances to be notified for connection blocked and unblocked events.
In addition, the <code>AbstractConnectionFactory</code> emits a <code>ConnectionBlockedEvent</code> and <code>ConnectionUnblockedEvent</code>, respectively, through its internal <code>BlockedListener</code> implementation.
These let you provide application logic to react appropriately to problems on the broker and (for example) take some corrective actions.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When the application is configured with a single <code>CachingConnectionFactory</code>, as it is by default with Spring Boot auto-configuration, the application stops working when the connection is blocked by the Broker.
And when it is blocked by the Broker, any of its clients stop to work.
If we have producers and consumers in the same application, we may end up with a deadlock when producers are blocking the connection (because there are no resources on the Broker any more) and consumers cannot free them (because the connection is blocked).
To mitigate the problem, we suggest having one more separate <code>CachingConnectionFactory</code> instance with the same options&#8201;&#8212;&#8201;one for producers and one for consumers.
A separate <code>CachingConnectionFactory</code> is not possible for transactional producers that execute on a consumer thread, since they should reuse the <code>Channel</code> associated with the consumer transactions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.0.2, the <code>RabbitTemplate</code> has a configuration option to automatically use a second connection factory, unless transactions are being used.
See <a href="#separate-connection">Using a Separate Connection</a> for more information.
The <code>ConnectionNameStrategy</code> for the publisher connection is the same as the primary strategy with <code>.publisher</code> appended to the result of calling the method.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.7.7, an <code>AmqpResourceNotAvailableException</code> is provided, which is thrown when <code>SimpleConnection.createChannel()</code> cannot create a <code>Channel</code> (for example, because the <code>channelMax</code> limit is reached and there are no available channels in the cache).
You can use this exception in the <code>RetryPolicy</code> to recover the operation after some back-off.</p>
</div>
</div>
<div class="sect4">
<h5 id="connection-factory">Configuring the Underlying Client Connection Factory</h5>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> uses an instance of the Rabbit client <code>ConnectionFactory</code>.
A number of configuration properties are passed through (<code>host, port, userName, password, requestedHeartBeat, and connectionTimeout</code> for example) when setting the equivalent property on the <code>CachingConnectionFactory</code>.
To set other properties (<code>clientProperties</code>, for example), you can define an instance of the Rabbit factory and provide a reference to it by using the appropriate constructor of the <code>CachingConnectionFactory</code>.
When using the namespace (<a href="#connections">as described earlier</a>), you need to provide a reference to the configured factory in the <code>connection-factory</code> attribute.
For convenience, a factory bean is provided to assist in configuring the connection factory in a Spring application context, as discussed in <a href="#rabbitconnectionfactorybean-configuring-ssl">the next section</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory
      id="connectionFactory" connection-factory="rabbitConnectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 4.0.x client enables automatic recovery by default.
While compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally is not needed.
We recommend disabling <code>amqp-client</code> automatic recovery, to avoid getting <code>AutoRecoverConnectionNotCurrentlyOpenException</code> instances when the broker is available but the connection has not yet recovered.
You may notice this exception, for example, when a <code>RetryTemplate</code> is configured in a <code>RabbitTemplate</code>, even when failing over to another broker in a cluster.
Since the auto-recovering connection recovers on a timer, the connection may be recovered more quickly by using Spring AMQP&#8217;s recovery mechanisms.
Starting with version 1.7.1, Spring AMQP disables <code>amqp-client</code> automatic recovery unless you explicitly create your own RabbitMQ connection factory and provide it to the <code>CachingConnectionFactory</code>.
RabbitMQ <code>ConnectionFactory</code> instances created by the <code>RabbitConnectionFactoryBean</code> also have the option disabled by default.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="rabbitconnectionfactorybean-configuring-ssl"><code>RabbitConnectionFactoryBean</code> and Configuring SSL</h5>
<div class="paragraph">
<p>Starting with version 1.4, a convenient <code>RabbitConnectionFactoryBean</code> is provided to enable convenient configuration of SSL properties on the underlying client connection factory by using dependency injection.
Other setters delegate to the underlying factory.
Previously, you had to configure the SSL options programmatically.
The following example shows how to configure a <code>RabbitConnectionFactoryBean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory id="rabbitConnectionFactory"
    connection-factory="clientConnectionFactory"
    host="${host}"
    port="${port}"
    virtual-host="${vhost}"
    username="${username}" password="${password}" /&gt;

&lt;bean id="clientConnectionFactory"
        class="org.springframework.amqp.rabbit.connection.RabbitConnectionFactoryBean"&gt;
    &lt;property name="useSSL" value="true" /&gt;
    &lt;property name="sslPropertiesLocation" value="file:/secrets/rabbitSSL.properties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://www.rabbitmq.com/ssl.html">RabbitMQ Documentation</a> for information about configuring SSL.
Omit the <code>keyStore</code> and <code>trustStore</code> configuration to connect over SSL without certificate validation.
The next example shows how you can provide key and trust store configuration.</p>
</div>
<div class="paragraph">
<p>The <code>sslPropertiesLocation</code> property is a Spring <code>Resource</code> pointing to a properties file containing the following keys:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>keyStore=file:/secret/keycert.p12
trustStore=file:/secret/trustStore
keyStore.passPhrase=secret
trustStore.passPhrase=secret</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>keyStore</code> and <code>truststore</code> are Spring <code>Resources</code> pointing to the stores.
Typically this properties file is secured by the operating system with the application having read access.</p>
</div>
<div class="paragraph">
<p>Starting with Spring AMQP version 1.5,you can set these properties directly on the factory bean.
If both discrete properties and <code>sslPropertiesLocation</code> is provided, properties in the latter override the
discrete values.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 2.0, the server certificate is validated by default because it is more secure.
If you wish to skip this validation for some reason, set the factory bean&#8217;s <code>skipServerCertificateValidation</code> property to <code>true</code>.
Starting with version 2.1, the <code>RabbitConnectionFactoryBean</code> now calls <code>enableHostnameVerification()</code> by default.
To revert to the previous behavior, set the <code>enableHostnameVerification</code> property to <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="routing-connection-factory">Routing Connection Factory</h5>
<div class="paragraph">
<p>Starting with version 1.3, the <code>AbstractRoutingConnectionFactory</code> has been introduced.
This factory provides a mechanism to configure mappings for several <code>ConnectionFactories</code> and determine a target <code>ConnectionFactory</code> by some <code>lookupKey</code> at runtime.
Typically, the implementation checks a thread-bound context.
For convenience, Spring AMQP provides the <code>SimpleRoutingConnectionFactory</code>, which gets the current thread-bound <code>lookupKey</code> from the <code>SimpleResourceHolder</code>.
The following examples shows how to configure a <code>SimpleRoutingConnectionFactory</code> in both XML and Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory"&gt;
	&lt;property name="targetConnectionFactories"&gt;
		&lt;map&gt;
			&lt;entry key="#{connectionFactory1.virtualHost}" ref="connectionFactory1"/&gt;
			&lt;entry key="#{connectionFactory2.virtualHost}" ref="connectionFactory2"/&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;rabbit:template id="template" connection-factory="connectionFactory" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyService {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void service(String vHost, String payload) {
        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);
        rabbitTemplate.convertAndSend(payload);
        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is important to unbind the resource after use.
For more information, see the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/rabbit/connection/AbstractRoutingConnectionFactory.html">JavaDoc</a> for <code>AbstractRoutingConnectionFactory</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4, <code>RabbitTemplate</code> supports the SpEL <code>sendConnectionFactorySelectorExpression</code> and <code>receiveConnectionFactorySelectorExpression</code> properties, which are evaluated on each AMQP protocol interaction operation (<code>send</code>, <code>sendAndReceive</code>, <code>receive</code>, or <code>receiveAndReply</code>), resolving to a <code>lookupKey</code> value for the provided <code>AbstractRoutingConnectionFactory</code>.
You can use bean references, such as <code>@vHostResolver.getVHost(#root)</code> in the expression.
For <code>send</code> operations, the message to be sent is the root evaluation object.
For <code>receive</code> operations, the <code>queueName</code> is the root evaluation object.</p>
</div>
<div class="paragraph">
<p>The routing algorithm is as follows: If the selector expression is <code>null</code> or is evaluated to <code>null</code> or the provided <code>ConnectionFactory</code> is not an instance of <code>AbstractRoutingConnectionFactory</code>, everything works as before, relying on the provided <code>ConnectionFactory</code> implementation.
The same occurs if the evaluation result is not <code>null</code>, but there is no target <code>ConnectionFactory</code> for that <code>lookupKey</code> and the <code>AbstractRoutingConnectionFactory</code> is configured with <code>lenientFallback = true</code>.
In the case of an <code>AbstractRoutingConnectionFactory</code>, it does fallback to its <code>routing</code> implementation based on <code>determineCurrentLookupKey()</code>.
However, if <code>lenientFallback = false</code>, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The namespace support also provides the <code>send-connection-factory-selector-expression</code> and <code>receive-connection-factory-selector-expression</code> attributes on the <code>&lt;rabbit:template&gt;</code> component.</p>
</div>
<div class="paragraph">
<p>Also, starting with version 1.4, you can configure a routing connection factory in a listener container.
In that case, the list of queue names is used as the lookup key.
For example, if you configure the container with <code>setQueueNames("thing1", "thing2")</code>, the lookup key is <code>[thing1,thing]"</code> (note that there is no space in the key).</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6.9, you can add a qualifier to the lookup key by using <code>setLookupKeyQualifier</code> on the listener container.
Doing so enables, for example, listening to queues with the same name but in a different virtual host (where you would have a connection factory for each).</p>
</div>
<div class="paragraph">
<p>For example, with lookup key qualifier <code>thing1</code> and a container listening to queue <code>thing2</code>, the lookup key you could register the target connection factory with could be <code>thing1[thing2]</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="queue-affinity">Queue Affinity and the <code>LocalizedQueueConnectionFactory</code></h5>
<div class="paragraph">
<p>When using HA queues in a cluster, for the best performance, you may want to connect to the physical broker
where the master queue resides.
While the <code>CachingConnectionFactory</code> can be configured with multiple broker addresses.
This is to fail over and the client attempts to connect in order.
The <code>LocalizedQueueConnectionFactory</code> uses the REST API provided by the admin plugin to determine on which node the queue is mastered.
It then creates (or retrieves from a cache) a <code>CachingConnectionFactory</code> that connects to just that node.
If the connection fails, the new master node is determined and the consumer connects to it.
The <code>LocalizedQueueConnectionFactory</code> is configured with a default connection factory, in case the physical location of the queue cannot be determined, in which case it connects as normal to the cluster.</p>
</div>
<div class="paragraph">
<p>The <code>LocalizedQueueConnectionFactory</code> is a <code>RoutingConnectionFactory</code> and the <code>SimpleMessageListenerContainer</code> uses the queue names as the lookup key as discussed in <a href="#routing-connection-factory">Routing Connection Factory</a> above.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For this reason (the use of the queue name for the lookup), the <code>LocalizedQueueConnectionFactory</code> can only be used if the container is configured to listen to a single queue.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The RabbitMQ management plugin must be enabled on each node.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This connection factory is intended for long-lived connections, such as those used by the <code>SimpleMessageListenerContainer</code>.
It is not intended for short connection use, such as with a <code>RabbitTemplate</code> because of the overhead of invoking the REST API before making the connection.
Also, for publish operations, the queue is unknown, and the message is published to all cluster members anyway, so the logic of looking up the node has little value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example configuration shows how to use Spring Boot&#8217;s RabbitProperties to configure the factories:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private RabbitProperties props;

private final String[] adminUris = { "http://host1:15672", "http://host2:15672" };

private final String[] nodes = { "rabbit@host1", "rabbit@host2" };

@Bean
public ConnectionFactory defaultConnectionFactory() {
    CachingConnectionFactory cf = new CachingConnectionFactory();
    cf.setAddresses(this.props.getAddresses());
    cf.setUsername(this.props.getUsername());
    cf.setPassword(this.props.getPassword());
    cf.setVirtualHost(this.props.getVirtualHost());
    return cf;
}

@Bean
public ConnectionFactory queueAffinityCF(
        @Qualifier("defaultConnectionFactory") ConnectionFactory defaultCF) {
    return new LocalizedQueueConnectionFactory(defaultCF,
            StringUtils.commaDelimitedListToStringArray(this.props.getAddresses()),
            this.adminUris, this.nodes,
            this.props.getVirtualHost(), this.props.getUsername(), this.props.getPassword(),
            false, null);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the first three parameters are arrays of <code>addresses</code>, <code>adminUris</code>, and <code>nodes</code>.
These are positional in that, when a container attempts to connect to a queue, it determines on which node the queue is
mastered and connects to the address in the same array position.</p>
</div>
</div>
<div class="sect4">
<h5 id="cf-pub-conf-ret">Publisher Confirms and Returns</h5>
<div class="paragraph">
<p>Confirmed and returned messages are supported by setting the <code>publisherConfirms</code> and <code>publisherReturns</code> properties of the <code>CachingConnectionFactory</code> to 'true'.</p>
</div>
<div class="paragraph">
<p>When these options are set, <code>Channel</code> instances created by the factory are wrapped in an <code>PublisherCallbackChannel</code>, which is used to facilitate the callbacks.
When such a channel is obtained, the client can register a <code>PublisherCallbackChannel.Listener</code> with the <code>Channel</code>.
The <code>PublisherCallbackChannel</code> implementation contains logic to route a confirm or return to the appropriate listener.
These features are explained further in the following sections.</p>
</div>
<div class="paragraph">
<p>See also <code>simplePublisherConfirms</code> in <a href="#scoped-operations">Scoped Operations</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For some more background information, see the blog post by the RabbitMQ team titled <a href="https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/">Introducing Publisher Confirms</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="connection-channel-listeners">Connection and Channel Listeners</h5>
<div class="paragraph">
<p>The connection factory supports registering <code>ConnectionListener</code> and <code>ChannelListener</code> implementations.
This allows you to receive notifications for connection and channel related events.
(A <code>ConnectionListener</code> is used by the <code>RabbitAdmin</code> to perform declarations when the connection is established - see <a href="#automatic-declaration">Automatic Declaration of Exchanges, Queues, and Bindings</a> for more information).
The following listing shows the <code>ConnectionListener</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface ConnectionListener {

    void onCreate(Connection connection);

    default void onClose(Connection connection) {
    }

    default void onShutDown(ShutdownSignalException signal) {
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>org.springframework.amqp.rabbit.connection.Connection</code> object can be supplied with <code>com.rabbitmq.client.BlockedListener</code> instances to be notified for connection blocked and unblocked events.
The following example shows the ChannelListener interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface ChannelListener {

    void onCreate(Channel channel, boolean transactional);

    default void onShutDown(ShutdownSignalException signal) {
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#publishing-is-async">Publishing is Asynchronous&#8201;&#8212;&#8201;How to Detect Successes and Failures</a> for one scenario where you might want to register a <code>ChannelListener</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-close-logging">Logging Channel Close Events</h5>
<div class="paragraph">
<p>Version 1.5 introduced a mechanism to enable users to control logging levels.</p>
</div>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> uses a default strategy to log channel closures as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Normal channel closes (200 OK) are not logged.</p>
</li>
<li>
<p>If a channel is closed due to a failed passive queue declaration, it is logged at debug level.</p>
</li>
<li>
<p>If a channel is closed because the <code>basic.consume</code> is refused due to an exclusive consumer condition, it is logged at
INFO level.</p>
</li>
<li>
<p>All others are logged at ERROR level.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To modify this behavior, you can inject a custom <code>ConditionalExceptionLogger</code> into the
<code>CachingConnectionFactory</code> in its <code>closeExceptionLogger</code> property.</p>
</div>
<div class="paragraph">
<p>See also <a href="#consumer-events">Consumer Events</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="runtime-cache-properties">Runtime Cache Properties</h5>
<div class="paragraph">
<p>Staring with version 1.6, the <code>CachingConnectionFactory</code> now provides cache statistics through the <code>getCacheProperties()</code>
method.
These statistics can be used to tune the cache to optimize it in production.
For example, the high water marks can be used to determine whether the cache size should be increased.
If it equals the cache size, you might want to consider increasing further.
The following table describes the <code>CacheMode.CHANNEL</code> properties:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Cache properties for CacheMode.CHANNEL</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `connectionName`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the connection generated by the <code>ConnectionNameStrategy</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `channelCacheSize`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently configured maximum channels that are allowed to be idle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `localPort`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The local port for the connection (if available).
This can be used to correlate with connections and channels on the RabbitMQ Admin UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsTx`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of transactional channels that are currently idle (cached).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsNotTx`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of non-transactional channels that are currently idle (cached).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsTxHighWater`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of transactional channels that have been concurrently idle (cached).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsNotTxHighWater`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of non-transactional channels have been concurrently idle (cached).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes the <code>CacheMode.CONNECTION</code> properties:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Cache properties for CacheMode.CONNECTION</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `connectionName:&lt;localPort&gt;`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the connection generated by the <code>ConnectionNameStrategy</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `openConnections`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of connection objects representing connections to brokers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `channelCacheSize`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently configured maximum channels that are allowed to be idle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `connectionCacheSize`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently configured maximum connections that are allowed to be idle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleConnections`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of connections that are currently idle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleConnectionsHighWater`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of connections that have been concurrently idle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsTx:&lt;localPort&gt;`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of transactional channels that are currently idle (cached) for this connection.
You can use the <code>localPort</code> part of the property name to correlate with connections and channels on the RabbitMQ Admin UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsNotTx:&lt;localPort&gt;`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of non-transactional channels that are currently idle (cached) for this connection.
The <code>localPort</code> part of the property name can be used to correlate with connections and channels on the RabbitMQ Admin UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsTxHighWater:&lt;localPort&gt;`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of transactional channels that have been concurrently idle (cached).
The localPort part of the property name can be used to correlate with connections and channels on the RabbitMQ Admin UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleChannelsNotTxHighWater:&lt;localPort&gt;`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of non-transactional channels have been concurrently idle (cached).
You can use the <code>localPort</code> part of the property name to correlate with connections and channels on the RabbitMQ Admin UI.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>cacheMode</code> property (<code>CHANNEL</code> or <code>CONNECTION</code>) is also included.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/cacheStats.png" alt="cacheStats">
</div>
<div class="title">Figure 1. JVisualVM Example</div>
</div>
</div>
<div class="sect4">
<h5 id="auto-recovery">RabbitMQ Automatic Connection/Topology recovery</h5>
<div class="paragraph">
<p>Since the first version of Spring AMQP, the framework has provided its own connection and channel recovery in the event of a broker failure.
Also, as discussed in <a href="#broker-configuration">Configuring the Broker</a>, the <code>RabbitAdmin</code> re-declares any infrastructure beans (queues and others) when the connection is re-established.
It therefore does not rely on the <a href="https://www.rabbitmq.com/api-guide.html#recovery">auto-recovery</a> that is now provided by the <code>amqp-client</code> library.
Spring AMQP now uses the <code>4.0.x</code> version of <code>amqp-client</code>, which has auto recovery enabled by default.
Spring AMQP can still use its own recovery mechanisms if you wish, disabling it in the client, (by setting the <code>automaticRecoveryEnabled</code> property on the underlying <code>RabbitMQ connectionFactory</code> to <code>false</code>).
However, the framework is completely compatible with auto-recovery being enabled.
This means any consumers you create within your code (perhaps via <code>RabbitTemplate.execute()</code>) can be recovered automatically.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Only elements (queues, exchanges, bindings) that are defined as beans will be re-declared after a connection failure.
Elements declared by invoking <code>RabbitAdmin.declare*()</code> methods directly from user code are unknown to the framework and therefore cannot be recovered.
If you have a need for a variable number of declarations, consider defining a bean, or beans, of type <code>Declarables</code>, as discussed in <a href="#collection-declaration">Declaring Collections of Exchanges, Queues, and Bindings</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-client-props">3.1.3. Adding Custom Client Connection Properties</h4>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> now lets you access the underlying connection factory to allow, for example,
setting custom client properties.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">connectionFactory.getRabbitConnectionFactory().getClientProperties().put("thing1", "thing2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>These properties appear in the RabbitMQ Admin UI when viewing the connection.</p>
</div>
</div>
<div class="sect3">
<h4 id="amqp-template">3.1.4. <code>AmqpTemplate</code></h4>
<div class="paragraph">
<p>As with many other high-level abstractions provided by the Spring Framework and related projects, Spring AMQP provides a &#8220;template&#8221; that plays a central role.
The interface that defines the main operations is called <code>AmqpTemplate</code>.
Those operations cover the general behavior for sending and receiving messages.
In other words, they are not unique to any implementation&#8201;&#8212;&#8201;hence the &#8220;AMQP&#8221; in the name.
On the other hand, there are implementations of that interface that are tied to implementations of the AMQP protocol.
Unlike JMS, which is an interface-level API itself, AMQP is a wire-level protocol.
The implementations of that protocol provide their own client libraries, so each implementation of the template interface depends on a particular client library.
Currently, there is only a single implementation: <code>RabbitTemplate</code>.
In the examples that follow, we often use an <code>AmqpTemplate</code>.
However, when you look at the configuration examples or any code excerpts where the template is instantiated or setters are invoked, you can see the implementation type (for example, <code>RabbitTemplate</code>).</p>
</div>
<div class="paragraph">
<p>As mentioned earlier, the <code>AmqpTemplate</code> interface defines all of the basic operations for sending and receiving messages.
We will explore message sending and reception, respectively, in <a href="#sending-messages">Sending Messages</a> and <a href="#receiving-messages">Receiving Messages</a>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#async-template"><code>AsyncRabbitTemplate</code></a>.</p>
</div>
<div class="sect4">
<h5 id="template-retry">Adding Retry Capabilities</h5>
<div class="paragraph">
<p>Starting with version 1.3, you can now configure the <code>RabbitTemplate</code> to use a <code>RetryTemplate</code> to help with handling problems with broker connectivity.
See the <a href="https://github.com/spring-projects/spring-retry">spring-retry</a> project for complete information.
The following is only one example that uses an exponential back off policy and the default <code>SimpleRetryPolicy</code>, which makes three tries before throwing the exception to the caller.</p>
</div>
<div class="paragraph">
<p>The following example uses the XML namespace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:template id="template" connection-factory="connectionFactory" retry-template="retryTemplate"/&gt;

&lt;bean id="retryTemplate" class="org.springframework.retry.support.RetryTemplate"&gt;
    &lt;property name="backOffPolicy"&gt;
        &lt;bean class="org.springframework.retry.backoff.ExponentialBackOffPolicy"&gt;
            &lt;property name="initialInterval" value="500" /&gt;
            &lt;property name="multiplier" value="10.0" /&gt;
            &lt;property name="maxInterval" value="10000" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example uses the <code>@Configuration</code> annotation in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AmqpTemplate rabbitTemplate() {
    RabbitTemplate template = new RabbitTemplate(connectionFactory());
    RetryTemplate retryTemplate = new RetryTemplate();
    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
    backOffPolicy.setInitialInterval(500);
    backOffPolicy.setMultiplier(10.0);
    backOffPolicy.setMaxInterval(10000);
    retryTemplate.setBackOffPolicy(backOffPolicy);
    template.setRetryTemplate(retryTemplate);
    return template;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 1.4, in addition to the <code>retryTemplate</code> property, the <code>recoveryCallback</code> option is supported on the <code>RabbitTemplate</code>.
It is used as a second argument for the <code>RetryTemplate.execute(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>RecoveryCallback</code> is somewhat limited, in that the retry context contains only the <code>lastThrowable</code> field.
For more sophisticated use cases, you should use an external <code>RetryTemplate</code> so that you can convey additional information to the <code>RecoveryCallback</code> through the context&#8217;s attributes.
The following example shows how to do so:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">retryTemplate.execute(
    new RetryCallback&lt;Object, Exception&gt;() {

        @Override
        public Object doWithRetry(RetryContext context) throws Exception {
            context.setAttribute("message", message);
            return rabbitTemplate.convertAndSend(exchange, routingKey, message);
        }

    }, new RecoveryCallback&lt;Object&gt;() {

        @Override
        public Object recover(RetryContext context) throws Exception {
            Object message = context.getAttribute("message");
            Throwable t = context.getLastThrowable();
            // Do something with message
            return null;
        }
    });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, you would <strong>not</strong> inject a <code>RetryTemplate</code> into the <code>RabbitTemplate</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="publishing-is-async">Publishing is Asynchronous&#8201;&#8212;&#8201;How to Detect Successes and Failures</h5>
<div class="paragraph">
<p>Publishing messages is an asynchronous mechanism and, by default, messages that cannot be routed are dropped by RabbitMQ.
For successful publishing, you can receive an asynchronous confirm, as described in <a href="#template-confirms">Publisher Confirms and Returns</a>.
Consider two failure scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Publish to an exchange but there is no matching destination queue.</p>
</li>
<li>
<p>Publish to a non-existent exchange.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first case is covered by publisher returns, as described in <a href="#template-confirms">Publisher Confirms and Returns</a>.</p>
</div>
<div class="paragraph">
<p>For the second case, the message is dropped and no return is generated.
The underlying channel is closed with an exception.
By default, this exception is logged, but you can register a <code>ChannelListener</code> with the <code>CachingConnectionFactory</code> to obtain notifications of such events.
The following example shows how to add a <code>ConnectionListener</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.connectionFactory.addConnectionListener(new ConnectionListener() {

    @Override
    public void onCreate(Connection connection) {
    }

    @Override
    public void onShutDown(ShutdownSignalException signal) {
        ...
    }

});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can examine the signal&#8217;s <code>reason</code> property to determine the problem that occurred.</p>
</div>
<div class="paragraph">
<p>To detect the exception on the sending thread, you can <code>setChannelTransacted(true)</code> on the <code>RabbitTemplate</code> and the exception is detected on the <code>txCommit()</code>.
However, <strong>transactions significantly impede performance</strong>, so consider this carefully before enabling transactions for just this one use case.</p>
</div>
</div>
<div class="sect4">
<h5 id="template-confirms">Publisher Confirms and Returns</h5>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> implementation of <code>AmqpTemplate</code> supports publisher confirms and returns.</p>
</div>
<div class="paragraph">
<p>For returned messages, the template&#8217;s <code>mandatory</code> property must be set to <code>true</code> or the <code>mandatory-expression</code>
must evaluate to <code>true</code> for a particular message.
This feature requires a <code>CachingConnectionFactory</code> that has its <code>publisherReturns</code> property set to <code>true</code> (see <a href="#cf-pub-conf-ret">Publisher Confirms and Returns</a>).
Returns are sent to the client by it registering a <code>RabbitTemplate.ReturnCallback</code> by calling <code>setReturnCallback(ReturnCallback callback)</code>.
The callback must implement the following method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void returnedMessage(Message message, int replyCode, String replyText,
          String exchange, String routingKey);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Only one <code>ReturnCallback</code> is supported by each <code>RabbitTemplate</code>.
See also <a href="#reply-timeout">Reply Timeout</a>.</p>
</div>
<div class="paragraph">
<p>For publisher confirms (also known as publisher acknowledgements), the template requires a <code>CachingConnectionFactory</code> that has its <code>publisherConfirms</code> property set to <code>true</code>.
Confirms are sent to the client by it registering a <code>RabbitTemplate.ConfirmCallback</code> by calling <code>setConfirmCallback(ConfirmCallback callback)</code>.
The callback must implement this method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void confirm(CorrelationData correlationData, boolean ack, String cause);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CorrelationData</code> is an object supplied by the client when sending the original message.
The <code>ack</code> is true for an <code>ack</code> and false for a <code>nack</code>.
For <code>nack</code> instances, the cause may contain a reason for the <code>nack</code>, if it is available when the <code>nack</code> is generated.
An example is when sending a message to a non-existent exchange.
In that case, the broker closes the channel.
The reason for the closure is included in the <code>cause</code>.
The <code>cause</code> was added in version 1.4.</p>
</div>
<div class="paragraph">
<p>Only one <code>ConfirmCallback</code> is supported by a <code>RabbitTemplate</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a rabbit template send operation completes, the channel is closed.
This precludes the reception of confirms or returns when the connection factory cache is full (when there is space in the cache, the channel is not physically closed and the returns and confirms proceed normally).
When the cache is full, the framework defers the close for up to five seconds, in order to allow time for the confirms and returns to be received.
When using confirms, the channel is closed when the last confirm is received.
When using only returns, the channel remains open for the full five seconds.
We generally recommend setting the connection factory&#8217;s <code>channelCacheSize</code> to a large enough value so that the channel on which a message is published is returned to the cache instead of being closed.
You can monitor channel usage by using the RabbitMQ management plugin.
If you see channels being opened and closed rapidly, you should consider increasing the cache size to reduce overhead on the server.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Before version 2.1, channels enabled for publisher confirms were returned to the cache before the confirms were received.
Some other process could check out the channel and perform some operation that causes the channel to close&#8201;&#8212;&#8201;such as publishing a message to a non-existent exchange.
This could cause the confirm to be lost.
Version 2.1 and later no longer return the channel to the cache while confirms are outstanding.
The <code>RabbitTemplate</code> performs a logical <code>close()</code> on the channel after each operation.
In general, this means that only one confirm is outstanding on a channel at a time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.1, the <code>CorrelationData</code> object has a <code>ListenableFuture</code> that you can \used to get the result, instead of using a <code>ConfirmCallback</code> on the template.
The following example shows how to configure a <code>CorrelationData</code> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CorrelationData cd1 = new CorrelationData();
this.templateWithConfirmsEnabled.convertAndSend("exchange", queue.getName(), "foo", cd1);
assertTrue(cd1.getFuture().get(10, TimeUnit.SECONDS).isAck());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since it is a <code>ListenableFuture&lt;Confirm&gt;</code>, you can either <code>get()</code> the result when ready or add listeners for an asynchronous callback.
The <code>Confirm</code> object is a simple bean with 2 properties: <code>ack</code> and <code>reason</code> (for <code>nack</code> instances).
The reason is not populated for broker-generated <code>nack</code> instances.
It is populated for <code>nack</code> instances generated by the framework (for example, closing the connection while <code>ack</code> instances are outstanding).</p>
</div>
<div class="paragraph">
<p>In addition, when both confirms and returns are enabled, the <code>CorrelationData</code> is populated with the returned message.
It is guaranteed that this occurs before the future is set with the <code>ack</code>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#scoped-operations">Scoped Operations</a> for a simpler mechanism for waiting for publisher confirms.</p>
</div>
</div>
<div class="sect4">
<h5 id="scoped-operations">Scoped Operations</h5>
<div class="paragraph">
<p>Normally, when using the template, a <code>Channel</code> is checked out of the cache (or created), used for the operation, and returned to the cache for reuse.
In a multi-threaded environment, there is no guarantee that the next operation uses the same channel.
There may be times, however, where you want to have more control over the use of a channel and ensure that a number of operations are all performed on the same channel.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, a new method called <code>invoke</code> is provided, with an <code>OperationsCallback</code>.
Any operations performed within the scope of the callback and on the provided <code>RabbitOperations</code> argument use the same dedicated <code>Channel</code>, which will be closed at the end (not returned to a cache).
If the channel is a <code>PublisherCallbackChannel</code>, it is returned to the cache after all confirms have been received (see <a href="#template-confirms">Publisher Confirms and Returns</a>).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface OperationsCallback&lt;T&gt; {

    T doInRabbit(RabbitOperations operations);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>One example of why you might need this is if you wish to use the <code>waitForConfirms()</code> method on the underlying <code>Channel</code>.
This method was not previously exposed by the Spring API because the channel is, generally, cached and shared, as discussed earlier.
The <code>RabbitTemplate</code> now provides <code>waitForConfirms(long timeout)</code> and <code>waitForConfirmsOrDie(long timeout)</code>, which delegate to the dedicated channel used within the scope of the <code>OperationsCallback</code>.
The methods cannot be used outside of that scope, for obvious reasons.</p>
</div>
<div class="paragraph">
<p>Note that a higher-level abstraction that lets you correlate confirms to requests is provided elsewhere (see <a href="#template-confirms">Publisher Confirms and Returns</a>).
If you want only to wait until the broker has confirmed delivery, you can use the technique shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Collection&lt;?&gt; messages = getMessagesToSend();
Boolean result = this.template.invoke(t -&gt; {
    messages.forEach(m -&gt; t.convertAndSend(ROUTE, m));
    t.waitForConfirmsOrDie(10_000);
    return true;
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you wish <code>RabbitAdmin</code> operations to be invoked on the same channel within the scope of the <code>OperationsCallback</code>, the admin must have been constructed by using the same <code>RabbitTemplate</code> that was used for the <code>invoke</code> operation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding discussion is moot if the template operations are already performed within the scope of an existing transaction&#8201;&#8212;&#8201;for example, when running on a transacted listener container thread and performing operations on a transacted template.
In that case, the operations are performed on that channel and committed when the thread returns to the container.
It is not necessary to use <code>invoke</code> in that scenario.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using confirms in this way, much of the infrastructure set up for correlating confirms to requests is not really needed.
Starting with version 2.1, the connection factory supports a new property called <code>simplePublisherConfirms</code>.
When this is <code>true</code>, the infrastructure is avoided and the confirm processing can be more efficient.</p>
</div>
<div class="paragraph">
<p>Furthermore, the <code>RabbitTemplate</code> sets the <code>publisherSequenceNumber</code> property in the sent message <code>MessageProperties</code>.
If you wish to check (or log or otherwise use) specific confirms, you can do so with an overloaded <code>invoke</code> method, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public &lt;T&gt; T invoke(OperationsCallback&lt;T&gt; action, com.rabbitmq.client.ConfirmCallback acks,
        com.rabbitmq.client.ConfirmCallback nacks);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These <code>ConfirmCallback</code> objects (for <code>ack</code> and <code>nack</code> instances) are the Rabbit client callbacks, not the template callback.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example logs <code>ack</code> and <code>nack</code> instances:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Collection&lt;?&gt; messages = getMessagesToSend();
Boolean result = this.template.invoke(t -&gt; {
    messages.forEach(m -&gt; t.convertAndSend(ROUTE, m));
    t.waitForConfirmsOrDie(10_000);
    return true;
}, (tag, multiple) -&gt; {
        log.info("Ack: " + tag + ":" + multiple);
}, (tag, multiple) -&gt; {
        log.info("Nack: " + tag + ":" + multiple);
}));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="template-messaging">Messaging Integration</h5>
<div class="paragraph">
<p>Starting with version 1.4, <code>RabbitMessagingTemplate</code> (built on top of <code>RabbitTemplate</code>) provides an integration with the Spring Framework messaging abstraction&#8201;&#8212;&#8201;that is,
<code>org.springframework.messaging.Message</code>.
This lets you send and receive messages by using the <code>spring-messaging</code> <code>Message&lt;?&gt;</code> abstraction.
This abstraction is used by other Spring projects, such as Spring Integration and Spring&#8217;s STOMP support.
There are two message converters involved: one to convert between a spring-messaging <code>Message&lt;?&gt;</code> and Spring AMQP&#8217;s <code>Message</code> abstraction and one to convert between Spring AMQP&#8217;s <code>Message</code> abstraction and the format required by the underlying RabbitMQ client library.
By default, the message payload is converted by the provided <code>RabbitTemplate</code> instance&#8217;s message converter.
Alternatively, you can inject a custom <code>MessagingMessageConverter</code> with some other payload converter, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessagingMessageConverter amqpMessageConverter = new MessagingMessageConverter();
amqpMessageConverter.setPayloadConverter(myPayloadConverter);
rabbitMessagingTemplate.setAmqpMessageConverter(amqpMessageConverter);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="template-user-id">Validated User Id</h5>
<div class="paragraph">
<p>Starting with version 1.6, the template now supports a <code>user-id-expression</code> (<code>userIdExpression</code> when using Java configuration).
If a message is sent, the user id property is set (if not already set) after evaluating this expression.
The root object for the evaluation is the message to be sent.</p>
</div>
<div class="paragraph">
<p>The following examples show how to use the <code>user-id-expression</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:template ... user-id-expression="'guest'" /&gt;

&lt;rabbit:template ... user-id-expression="@myConnectionFactory.username" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example is a literal expression.
The second obtains the <code>username</code> property from a connection factory bean in the application context.</p>
</div>
</div>
<div class="sect4">
<h5 id="separate-connection">Using a Separate Connection</h5>
<div class="paragraph">
<p>Starting with version 2.0.2, you can set the <code>usePublisherConnection</code> property to <code>true</code> to use a different connection to that used by listener containers, when possible.
This is to avoid consumers being blocked when a producer is blocked for any reason.
The <code>CachingConnectionFactory</code> now maintains a second internal connection factory for this purpose.
If the rabbit template is running in a transaction started by the listener container, the container&#8217;s channel is used, regardless of this setting.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In general, you should not use a <code>RabbitAdmin</code> with a template that has this set to <code>true</code>.
Use the <code>RabbitAdmin</code> constructor that takes a connection factory.
If you use the other constructor that takes a template, ensure the template&#8217;s property is <code>false</code>.
This is because, often, an admin is used to declare queues for listener containers.
Using a template that has the property set to <code>true</code> would mean that exclusive queues (such as <code>AnonymousQueue</code>) would be declared on a different connection to that used by listener containers.
In that case, the queues cannot be used by the containers.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sending-messages">3.1.5. Sending Messages</h4>
<div class="paragraph">
<p>When sending a message, you can use any of the following methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void send(Message message) throws AmqpException;

void send(String routingKey, Message message) throws AmqpException;

void send(String exchange, String routingKey, Message message) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We can begin our discussion with the last method in the preceding listing, since it is actually the most explicit.
It lets an AMQP exchange name  (along with a routing key)be provided at runtime.
The last parameter is the callback that is responsible for actual creating the message instance.
An example of using this method to send a message might look this this:
The following example shows how to use the <code>send</code> method to send a message:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">amqpTemplate.send("marketData.topic", "quotes.nasdaq.THING1",
    new Message("12.34".getBytes(), someProperties));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can set the <code>exchange</code> property on the template itself if you plan to use that template instance to send to the same exchange most or all of the time.
In such cases, you can use the second method in the preceding listing.
The following example is functionally equivalent to the previous example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">amqpTemplate.setExchange("marketData.topic");
amqpTemplate.send("quotes.nasdaq.FOO", new Message("12.34".getBytes(), someProperties));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If both the <code>exchange</code> and <code>routingKey</code> properties are set on the template, you can use the method that accepts only the <code>Message</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">amqpTemplate.setExchange("marketData.topic");
amqpTemplate.setRoutingKey("quotes.nasdaq.FOO");
amqpTemplate.send(new Message("12.34".getBytes(), someProperties));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A better way of thinking about the exchange and routing key properties is that the explicit method parameters always override the template&#8217;s default values.
In fact, even if you do not explicitly set those properties on the template, there are always default values in place.
In both cases, the default is an empty <code>String</code>, but that is actually a sensible default.
As far as the routing key is concerned, it is not always necessary in the first place (for example, for
a <code>Fanout</code> exchange).
Furthermore, a queue may be bound to an exchange with an empty <code>String</code>.
Those are both legitimate scenarios for reliance on the default empty <code>String</code> value for the routing key property of the template.
As far as the exchange name is concerned, the empty <code>String</code> is commonly used because the AMQP specification defines the &#8220;default exchange&#8221; as having no name.
Since all queues are automatically bound to that default exchange (which is a direct exchange), using their name as the binding value, the second method in the preceding listing can be used for simple point-to-point messaging to any queue through the default exchange.
You can provide the queue name as the <code>routingKey</code>, either by providing the method parameter at runtime.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.send("queue.helloWorld", new Message("Hello World".getBytes(), someProperties));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can create a template that can be used for publishing primarily or exclusively to a single Queue.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.setRoutingKey("queue.helloWorld"); // but we'll always send to this Queue
template.send(new Message("Hello World".getBytes(), someProperties));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="message-builder">Message Builder API</h5>
<div class="paragraph">
<p>Starting with version 1.3, a message builder API is provided by the <code>MessageBuilder</code> and <code>MessagePropertiesBuilder</code>.
These methods provide a convenient &#8220;fluent&#8221; means of creating a message or message properties.
The following examples show the fluent API in action:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message message = MessageBuilder.withBody("foo".getBytes())
    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
    .setMessageId("123")
    .setHeader("bar", "baz")
    .build();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageProperties props = MessagePropertiesBuilder.newInstance()
    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
    .setMessageId("123")
    .setHeader("bar", "baz")
    .build();
Message message = MessageBuilder.withBody("foo".getBytes())
    .andProperties(props)
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each of the properties defined on the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/MessageProperties.html"><code>MessageProperties</code></a> can be set.
Other methods include <code>setHeader(String key, String value)</code>, <code>removeHeader(String key)</code>, <code>removeHeaders()</code>, and <code>copyProperties(MessageProperties properties)</code>.
Each property setting method has a <code>set*IfAbsent()</code> variant.
In the cases where a default initial value exists, the method is named <code>set*IfAbsentOrDefault()</code>.</p>
</div>
<div class="paragraph">
<p>Five static methods are provided to create an initial message builder:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static MessageBuilder withBody(byte[] body) <i class="conum" data-value="1"></i><b>(1)</b>

public static MessageBuilder withClonedBody(byte[] body) <i class="conum" data-value="2"></i><b>(2)</b>

public static MessageBuilder withBody(byte[] body, int from, int to) <i class="conum" data-value="3"></i><b>(3)</b>

public static MessageBuilder fromMessage(Message message) <i class="conum" data-value="4"></i><b>(4)</b>

public static MessageBuilder fromClonedMessage(Message message) <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The message created by the builder has a body that is a direct reference to the argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The message created by the builder has a body that is a new array containing a copy of bytes in the argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The message created by the builder has a body that is a new array containing the range of bytes from the argument.
See <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html"><code>Arrays.copyOfRange()</code></a> for more details.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The message created by the builder has a body that is a direct reference to the body of the argument.
The argument&#8217;s properties are copied to a new <code>MessageProperties</code>  object.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The message created by the builder has a body that is a new array containing a copy of the argument&#8217;s body.
The argument&#8217;s properties are copied to a new <code>MessageProperties</code>  object.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Three static methods are provided to create a <code>MessagePropertiesBuilder</code> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static MessagePropertiesBuilder newInstance() <i class="conum" data-value="1"></i><b>(1)</b>

public static MessagePropertiesBuilder fromProperties(MessageProperties properties) <i class="conum" data-value="2"></i><b>(2)</b>

public static MessagePropertiesBuilder fromClonedProperties(MessageProperties properties) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A new message properties object is initialized with default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The builder is initialized with, and <code>build()</code> will return, the provided properties object.,</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The argument&#8217;s properties are copied to a new <code>MessageProperties</code> object.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>With the <code>RabbitTemplate</code> implementation of <code>AmqpTemplate</code>, each of the <code>send()</code> methods has an overloaded version that takes an additional <code>CorrelationData</code> object.
When publisher confirms are enabled, this object is returned in the callback described in <a href="#amqp-template"><code>AmqpTemplate</code></a>.
This lets the sender correlate a confirm (<code>ack</code> or <code>nack</code>) with the sent message.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6.7, the <code>CorrelationAwareMessagePostProcessor</code> interface was introduced, allowing the correlation data to be modified after the message has been converted.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message postProcessMessage(Message message, Correlation correlation);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In version 2.0, this interface is deprecated.
The method has been moved to <code>MessagePostProcessor</code> with a default implementation that delegates to <code>postProcessMessage(Message message)</code>.</p>
</div>
<div class="paragraph">
<p>Also starting with version 1.6.7, a new callback interface called <code>CorrelationDataPostProcessor</code> is provided.
This is invoked after all <code>MessagePostProcessor</code> instances (provided in the <code>send()</code> method as well as those provided in <code>setBeforePublishPostProcessors()</code>).
Implementations can update or replace the correlation data supplied in the <code>send()</code> method (if any).
The <code>Message</code> and original <code>CorrelationData</code> (if any) are provided as arguments.
The following example shows how to use the <code>postProcess</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CorrelationData postProcess(Message message, CorrelationData correlationData);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_publisher_returns">Publisher Returns</h5>
<div class="paragraph">
<p>When the template&#8217;s <code>mandatory</code> property is <code>true</code>, returned messages are provided by the callback described in <a href="#amqp-template"><code>AmqpTemplate</code></a>.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4, the <code>RabbitTemplate</code> supports the SpEL <code>mandatoryExpression</code> property, which is evaluated against each request message as the root evaluation object, resolving to a <code>boolean</code> value.
Bean references, such as <code>@myBean.isMandatory(#root)</code>, can be used in the expression.</p>
</div>
<div class="paragraph">
<p>Publisher returns can also be used internally by the <code>RabbitTemplate</code> in send and receive operations.
See <a href="#reply-timeout">Reply Timeout</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="template-batching">Batching</h5>
<div class="paragraph">
<p>Version 1.4.2 introduced the <code>BatchingRabbitTemplate</code>.
This is a subclass of <code>RabbitTemplate</code> with an overridden <code>send</code> method that batches messages according to the <code>BatchingStrategy</code>.
Only when a batch is complete is the message sent to RabbitMQ.
The following listing shows the <code>BatchingStrategy</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BatchingStrategy {

	MessageBatch addToBatch(String exchange, String routingKey, Message message);

	Date nextRelease();

	Collection&lt;MessageBatch&gt; releaseBatches();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Batched data is held in memory.
Unsent messages can be lost in the event of a system failure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>SimpleBatchingStrategy</code> is provided.
It supports sending messages to a single exchange or routing key.
It has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>batchSize</code>: The number of messages in a batch before it is sent.</p>
</li>
<li>
<p><code>bufferLimit</code>: The maximum size of the batched message.
This preempts the <code>batchSize</code>, if exceeded, and causes a partial batch to be sent.</p>
</li>
<li>
<p><code>timeout</code>: A time after which a partial batch is sent when there is no new activity adding messages to the batch.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>SimpleBatchingStrategy</code> formats the batch by preceding each embedded message with a four-byte binary length.
This is communicated to the receiving system by setting the <code>springBatchFormat</code> message property to <code>lengthHeader4</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Batched messages are automatically de-batched by listener containers (by using the <code>springBatchFormat</code> message header).
Rejecting any message from a batch causes the entire batch to be rejected.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="receiving-messages">3.1.6. Receiving Messages</h4>
<div class="paragraph">
<p>Message reception is always a little more complicated than sending.
There are two ways to receive a <code>Message</code>.
The simpler option is to poll for one <code>Message</code> at a time with a polling method call.
The more complicated yet more common approach is to register a listener that receives <code>Messages</code> on-demand, asynchronously.
We consider an example of each approach in the next two sub-sections.</p>
</div>
<div class="sect4">
<h5 id="polling-consumer">Polling Consumer</h5>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> itself can be used for polled <code>Message</code> reception.
By default, if no message is available, <code>null</code> is returned immediately.
There is no blocking.
Starting with version 1.5, you can set a <code>receiveTimeout</code>, in milliseconds, and the receive methods block for up to that long, waiting for a message.
A value less than zero means block indefinitely (or at least until the connection to the broker is lost).
Version 1.6 introduced variants of the <code>receive</code> methods that let the timeout be passed in on each call.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Since the receive operation creates a new <code>QueueingConsumer</code> for each message, this technique is not really appropriate for high-volume environments.
Consider using an asynchronous consumer or a <code>receiveTimeout</code> of zero for those use cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are four simple <code>receive</code> methods available.
As with the <code>Exchange</code> on the sending side, there is a method that requires that a default queue property has been set
directly on the template itself, and there is a method that accepts a queue parameter at runtime.
Version 1.6 introduced variants to accept <code>timeoutMillis</code> to override <code>receiveTimeout</code> on a per-request basis.
The following listing shows the definitions of the four methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message receive() throws AmqpException;

Message receive(String queueName) throws AmqpException;

Message receive(long timeoutMillis) throws AmqpException;

Message receive(String queueName, long timeoutMillis) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As in the case of sending messages, the <code>AmqpTemplate</code> has some convenience methods for receiving POJOs instead of <code>Message</code> instances, and implementations provide a way to customize the <code>MessageConverter</code> used to create the <code>Object</code> returned:
The following listing shows those methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;

Message receiveAndConvert(long timeoutMillis) throws AmqpException;

Message receiveAndConvert(String queueName, long timeoutMillis) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.0, there are variants of these methods that take an additional <code>ParameterizedTypeReference</code> argument to convert complex types.
The template must be configured with a <code>SmartMessageConverter</code>.
See <a href="#json-complex">Converting From a <code>Message</code> With <code>RabbitTemplate</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>Similar to <code>sendAndReceive</code> methods, beginning with version 1.3, the <code>AmqpTemplate</code> has several convenience <code>receiveAndReply</code> methods for synchronously receiving, processing and replying to messages.
The following listing shows those method definitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;R, S&gt; boolean receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback)
	   throws AmqpException;

&lt;R, S&gt; boolean receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback)
 	throws AmqpException;

&lt;R, S&gt; boolean receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback,
	String replyExchange, String replyRoutingKey) throws AmqpException;

&lt;R, S&gt; boolean receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,
	String replyExchange, String replyRoutingKey) throws AmqpException;

&lt;R, S&gt; boolean receiveAndReply(ReceiveAndReplyCallback&lt;R, S&gt; callback,
 	ReplyToAddressCallback&lt;S&gt; replyToAddressCallback) throws AmqpException;

&lt;R, S&gt; boolean receiveAndReply(String queueName, ReceiveAndReplyCallback&lt;R, S&gt; callback,
			ReplyToAddressCallback&lt;S&gt; replyToAddressCallback) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> implementation takes care of the <code>receive</code> and <code>reply</code> phases.
In most cases, you should provide only an implementation of <code>ReceiveAndReplyCallback</code> to perform some business logic for the received message and build a reply object or message, if needed.
Note, a <code>ReceiveAndReplyCallback</code> may return <code>null</code>.
In this case, no reply is sent and <code>receiveAndReply</code> works like the <code>receive</code> method.
This lets the same queue be used for a mixture of messages, some of which may not need a reply.</p>
</div>
<div class="paragraph">
<p>Automatic message (request and reply) conversion is applied only if the provided callback is not an instance of <code>ReceiveAndReplyMessageCallback</code>, which provides a raw message exchange contract.</p>
</div>
<div class="paragraph">
<p>The <code>ReplyToAddressCallback</code> is useful for cases requiring custom logic to determine the <code>replyTo</code> address at runtime against the received message and reply from the <code>ReceiveAndReplyCallback</code>.
By default, <code>replyTo</code> information in the request message is used to route the reply.</p>
</div>
<div class="paragraph">
<p>The following listing shows an example of POJO-based receive and reply:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean received =
        this.template.receiveAndReply(ROUTE, new ReceiveAndReplyCallback&lt;Order, Invoice&gt;() {

                public Invoice handle(Order order) {
                        return processOrder(order);
                }
        });
if (received) {
        log.info("We received an order!");
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="async-consumer">Asynchronous Consumer</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Spring AMQP also supports annotated listener endpoints through the use of the <code>@RabbitListener</code> annotation and provides an open infrastructure to register endpoints programmatically.
This is by far the most convenient way to setup an asynchronous consumer.
See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more details.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The prefetch default value used to be 1, which could lead to under-utilization of efficient consumers.
Starting with version 2.0, the default prefetch value is now 250, which should keep consumers busy in most common scenarios and
thus improve throughput.</p>
</div>
<div class="paragraph">
<p>There are, nevertheless, scenarios where the prefetch value should be low:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For large messages, especially if the processing is slow (messages could add up to a large amount of memory in the client process)</p>
</li>
<li>
<p>When strict message ordering is necessary (the prefetch value should be set back to 1 in this case)</p>
</li>
<li>
<p>Other special cases</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.
We also recomend using <code>prefetch = 1</code> with the <code>MANUAL</code> <code>ack</code> mode.
The <code>basicAck</code> is an asynchronous operation and, if something wrong happens on the Broker (double <code>ack</code> for the same delivery tag, for example), you end up with processed subsequent messages in the batch that are unacknowledged on the Broker, and other consumers may see them.</p>
</div>
<div class="paragraph">
<p>See <a href="#containerAttributes">Message Listener Container Configuration</a>.</p>
</div>
<div class="paragraph">
<p>For more background about prefetch, see this post about <a href="https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/">consumer utilization in RabbitMQ</a>
and this post about <a href="https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/">queuing theory</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_message_listener">Message Listener</h6>
<div class="paragraph">
<p>For asynchronous <code>Message</code> reception, a dedicated component (not the <code>AmqpTemplate</code>) is involved.
That component is a container for a <code>Message</code>-consuming callback.
We consider the container and its properties later in this section.
First, though, we should look at the callback, since that is where your application code is integrated with the messaging system.
There are a few options for the callback, starting with an implementation of the <code>MessageListener</code> interface, which the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageListener {
    void onMessage(Message message);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If your callback logic depends on the AMQP Channel instance for any reason, you may instead use the <code>ChannelAwareMessageListener</code>.
It looks similar but has an extra parameter.
The following listing shows the <code>ChannelAwareMessageListener</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ChannelAwareMessageListener {
    void onMessage(Message message, Channel channel) throws Exception;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In version 2.1, this interface moved from package <code>o.s.amqp.rabbit.core</code> to <code>o.s.amqp.rabbit.listener.api</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="message-listener-adapter"><code>MessageListenerAdapter</code></h6>
<div class="paragraph">
<p>If you prefer to maintain a stricter separation between your application logic and the messaging API, you can rely upon an adapter implementation that is provided by the framework.
This is often referred to as &#8220;Message-driven POJO&#8221; support.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Version 1.5 introduced a more flexible mechanism for POJO messaging, the <code>@RabbitListener</code> annotation.
See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using the adapter, you need to provide only a reference to the instance that the adapter itself should invoke.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageListenerAdapter listener = new MessageListenerAdapter(somePojo);
listener.setDefaultListenerMethod("myMethod");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can subclass the adapter and provide an implementation of <code>getListenerMethodName()</code> to dynamically select different methods based on the message.
This method has two parameters, <code>originalMessage</code> and <code>extractedMessage</code>, the latter being the result of any conversion.
By default, a <code>SimpleMessageConverter</code> is configured.
See <a href="#simple-message-converter"><code>SimpleMessageConverter</code></a> for more information and information about other converters available.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4.2, the original message has <code>consumerQueue</code> and <code>consumerTag</code> properties, which can be used to determine the queue from which a message was received.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5, you can configure a map of consumer queue or tag to method name, to dynamically select the method to call.
If no entry is in the map, we fall back to the default listener method.
The default listener method (if not set) is <code>handleMessage</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, a convenient <code>FunctionalInterface</code> has been provided.
The following listing shows the definition of <code>FunctionalInterface</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface ReplyingMessageListener&lt;T, R&gt; {

	R handleMessage(T t);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This interface facilitates convenient configuration of the adapter by using Java 8 lamdas, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new MessageListenerAdapter((ReplyingMessageListener&lt;String, String&gt;) data -&gt; {
    ...
    return result;
}));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_container">Container</h6>
<div class="paragraph">
<p>Now that you have seen the various options for the <code>Message</code>-listening callback, we can turn our attention to the container.
Basically, the container handles the &#8220;active&#8221; responsibilities so that the listener callback can remain passive.
The container is an example of a &#8220;lifecycle&#8221; component.
It provides methods for starting and stopping.
When configuring the container, you essentially bridge the gap between an AMQP Queue and the <code>MessageListener</code> instance.
You must provide a reference to the <code>ConnectionFactory</code> and the queue names or Queue instances from which that listener should consume messages.</p>
</div>
<div class="paragraph">
<p>Prior to version 2.0, there was one listener container, the <code>SimpleMessageListenerContainer</code>.
There is now a second container, the <code>DirectMessageListenerContainer</code>.
The differences between the containers and criteria you might apply when choosing which to use are described in <a href="#choose-container">Choosing a Container</a>.</p>
</div>
<div class="paragraph">
<p>The following listing shows the most basic example, which works by using the, <code>SimpleMessageListenerContainer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
container.setConnectionFactory(rabbitConnectionFactory);
container.setQueueNames("some.queue");
container.setMessageListener(new MessageListenerAdapter(somePojo));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an &#8220;active&#8221; component, it is most common to create the listener container with a bean definition so that it can run in the background.
The following example shows one way to do so with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:listener-container connection-factory="rabbitConnectionFactory"&gt;
    &lt;rabbit:listener queues="some.queue" ref="somePojo" method="handle"/&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows another way to do so with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:listener-container connection-factory="rabbitConnectionFactory" type="direct"&gt;
    &lt;rabbit:listener queues="some.queue" ref="somePojo" method="handle"/&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Both of the preceding examples create a <code>DirectMessageListenerContainer</code> (notice the <code>type</code> attribute&#8201;&#8212;&#8201;it defaults to <code>simple</code>).</p>
</div>
<div class="paragraph">
<p>Alternately, you may prefer to use Java configuration, which looks similar to the preceding code snippet:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class ExampleAmqpConfiguration {

    @Bean
    public SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

    @Bean
    public ConnectionFactory rabbitConnectionFactory() {
        CachingConnectionFactory connectionFactory =
            new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public MessageListener exampleListener() {
        return new MessageListener() {
            public void onMessage(Message message) {
                System.out.println("received: " + message);
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="consumer-priority">Consumer Priority</h6>
<div class="paragraph">
<p>Starting with RabbitMQ Version 3.2, the broker now supports consumer priority (see <a href="https://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/">Using Consumer Priorities with RabbitMQ</a>).
This is enabled by setting the <code>x-priority</code> argument on the consumer.
The <code>SimpleMessageListenerContainer</code> now supports setting consumer arguments, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">container.setConsumerArguments(Collections.
&lt;String, Object&gt; singletonMap("x-priority", Integer.valueOf(10)));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For convenience, the namespace provides the <code>priority</code> attribute on the <code>listener</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:listener-container connection-factory="rabbitConnectionFactory"&gt;
    &lt;rabbit:listener queues="some.queue" ref="somePojo" method="handle" priority="10" /&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 1.3, you can modify the queues on which the container listens at runtime.
See <a href="#listener-queues">Listener Container Queues</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="lc-auto-delete"><code>auto-delete</code> Queues</h6>
<div class="paragraph">
<p>When a container is configured to listen to <code>auto-delete</code> queues, the queue has an <code>x-expires</code> option, or the <a href="https://www.rabbitmq.com/ttl.html">Time-To-Live</a> policy is configured on the Broker, the queue is removed by the broker when the container is stopped (that is, when the last consumer is cancelled).
Before version 1.3, the container could not be restarted because the queue was missing.
The <code>RabbitAdmin</code> only automatically redeclares queues and so on when the connection is closed or when it opens, which does not happen when the container is stopped and started.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.3, the container uses a <code>RabbitAdmin</code> to redeclare any missing queues during startup.</p>
</div>
<div class="paragraph">
<p>You can also use conditional declaration (see <a href="#conditional-declaration">Conditional Declaration</a>) together with an <code>auto-startup="false"</code> admin to defer queue declaration until the container is started.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue id="otherAnon" declared-by="containerAdmin" /&gt;

&lt;rabbit:direct-exchange name="otherExchange" auto-delete="true" declared-by="containerAdmin"&gt;
    &lt;rabbit:bindings&gt;
        &lt;rabbit:binding queue="otherAnon" key="otherAnon" /&gt;
    &lt;/rabbit:bindings&gt;
&lt;/rabbit:direct-exchange&gt;

&lt;rabbit:listener-container id="container2" auto-startup="false"&gt;
    &lt;rabbit:listener id="listener2" ref="foo" queues="otherAnon" admin="containerAdmin" /&gt;
&lt;/rabbit:listener-container&gt;

&lt;rabbit:admin id="containerAdmin" connection-factory="rabbitConnectionFactory"
    auto-startup="false" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the queue and exchange are declared by <code>containerAdmin</code>, which has <code>auto-startup="false"</code> so that the elements are not declared during context initialization.
Also, the container is not started for the same reason.
When the container is later started, it uses its reference to <code>containerAdmin</code> to declare the elements.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="de-batching">Batched Messages</h5>
<div class="paragraph">
<p>Batched messages are automatically de-batched by listener containers (using the <code>springBatchFormat</code> message header).
Rejecting any message from a batch causes the entire batch to be rejected.
See <a href="#template-batching">Batching</a> for more information about batching.</p>
</div>
</div>
<div class="sect4">
<h5 id="consumer-events">Consumer Events</h5>
<div class="paragraph">
<p>The containers publish application events whenever a listener
(consumer) experiences a failure of some kind.
The event <code>ListenerContainerConsumerFailedEvent</code> has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>container</code>: The listener container where the consumer experienced the problem.</p>
</li>
<li>
<p><code>reason</code>: A textual reason for the failure.</p>
</li>
<li>
<p><code>fatal</code>: A boolean indicating whether the failure was fatal.
With non-fatal exceptions, the container tries to restart the consumer, according to the <code>recoveryInterval</code> or <code>recoveryBackoff</code> (for the <code>SimpleMessageListenerContainer</code>) or the <code>monitorInterval</code> (for the <code>DirectMessageListenerContainer</code>).</p>
</li>
<li>
<p><code>throwable</code>: The <code>Throwable</code> that was caught.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These events can be consumed by implementing <code>ApplicationListener&lt;ListenerContainerConsumerFailedEvent&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
System-wide events (such as connection failures) are published by all consumers when <code>concurrentConsumers</code> is greater than 1.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a consumer fails because one if its queues is being used exclusively, by default, as well as publishing the event, a <code>WARN</code> log is issued.
To change this logging behavior, provide a custom <code>ConditionalExceptionLogger</code> in the <code>SimpleMessageListenerContainer</code> instance&#8217;s <code>exclusiveConsumerExceptionLogger</code> property.
See also <a href="#channel-close-logging">Logging Channel Close Events</a>.</p>
</div>
<div class="paragraph">
<p>Fatal errors are always logged at the <code>ERROR</code> level.
This it not modifiable.</p>
</div>
<div class="paragraph">
<p>Several other events are published at various stages of the container lifecycle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AsyncConsumerStartedEvent</code>: When the consumer is started.</p>
</li>
<li>
<p><code>AsyncConsumerRestartedEvent</code>: When the consumer is restarted after a failure - <code>SimpleMessageListenerContainer</code> only.</p>
</li>
<li>
<p><code>AsyncConsumerTerminatedEvent</code>: When a consumer is stopped normally.</p>
</li>
<li>
<p><code>AsyncConsumerStoppedEvent</code>: When the consumer is stopped - <code>SimpleMessageListenerContainer</code> only.</p>
</li>
<li>
<p><code>ConsumeOkEvent</code>: When a <code>consumeOk</code> is received from the broker, contains the queue name and <code>consumerTag</code></p>
</li>
<li>
<p><code>ListenerContainerIdleEvent</code>: See <a href="#idle-containers">Detecting Idle Asynchronous Consumers</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="consumerTags">Consumer Tags</h5>
<div class="paragraph">
<p>You can provide a strategy to generate consumer tags.
By default, the consumer tag is generated by the broker.
The following listing shows the <code>ConsumerTagStrategy</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ConsumerTagStrategy {

    String createConsumerTag(String queue);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The queue is made available so that it can (optionally) be used in the tag.</p>
</div>
<div class="paragraph">
<p>See <a href="#containerAttributes">Message Listener Container Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="async-annotation-driven">Annotation-driven Listener Endpoints</h5>
<div class="paragraph">
<p>The easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure.
In a nutshell, it lets you expose a method of a managed bean as a Rabbit listener endpoint.
The following example shows how to use the <code>@RabbitListener</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyService {

    @RabbitListener(queues = "myQueue")
    public void processOrder(String data) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The idea of the preceding example is that, whenever a message is available on the queue named <code>myQueue</code>, the <code>processOrder</code> method is invoked accordingly (in this case, with the payload of the message).</p>
</div>
<div class="paragraph">
<p>The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, by using a <code>RabbitListenerContainerFactory</code>.</p>
</div>
<div class="paragraph">
<p>In the preceding example, <code>myQueue</code> must already exist and be bound to some exchange.
The queue can be declared and bound automatically, as long as a <code>RabbitAdmin</code> exists in the application context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Property placeholders (<code>${some.property}</code>) or SpEL expressions (<code>#{someExpression}</code>) can be specified for the annotation properties (<code>queues</code> etc).
See <a href="#annotation-multiple-queues">Listening to Multiple Queues</a> for an example of why you might use SpEL instead of a property placeholder.
The following listing shows three examples of how to declare a Rabbit listener:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyService {

  @RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = "myQueue", durable = "true"),
        exchange = @Exchange(value = "auto.exch", ignoreDeclarationExceptions = "true"),
        key = "orderRoutingKey")
  )
  public void processOrder(Order order) {
    ...
  }

  @RabbitListener(bindings = @QueueBinding(
        value = @Queue,
        exchange = @Exchange(value = "auto.exch"),
        key = "invoiceRoutingKey")
  )
  public void processInvoice(Invoice invoice) {
    ...
  }

  @RabbitListener(queuesToDeclare = @Queue(name = "${my.queue}", durable = "true"))
  public String handleWithSimpleDeclare(String data) {
      ...
  }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the first example, a queue <code>myQueue</code> is declared automatically (durable) together with the exchange, if needed,
and bound to the exchange with the routing key.
In the second example, an anonymous (exclusive, auto-delete) queue is declared and bound.
Multiple <code>QueueBinding</code> entries can be provided, letting the listener listen to multiple queues.
In the third example, a queue with the name retrieved from property <code>my.queue</code> is declared, if necessary, with the default binding to the default exchange using the queue name as the routing key.</p>
</div>
<div class="paragraph">
<p>Since version 2.0, the <code>@Exchange</code> annotation supports any exchange types, including custom.
For more information, see <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP Concepts</a>.</p>
</div>
<div class="paragraph">
<p>You can use normal <code>@Bean</code> definitions when you need more advanced configuration.</p>
</div>
<div class="paragraph">
<p>Notice <code>ignoreDeclarationExceptions</code> on the exchange in the first example.
This allows, for example, binding to an existing exchange that might have different settings (such as <code>internal</code>).
By default, the properties of an existing exchange must match.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, you can now bind a queue to an exchange with multiple routing keys, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
    key = { "red", "yellow" }
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also specify arguments within <code>@QueueBinding</code> annotations for queues, exchanges,
and bindings, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = "auto.headers", autoDelete = "true",
                        arguments = @Argument(name = "x-message-ttl", value = "10000",
                                                type = "java.lang.Integer")),
        exchange = @Exchange(value = "auto.headers", type = ExchangeTypes.HEADERS, autoDelete = "true"),
        arguments = {
                @Argument(name = "x-match", value = "all"),
                @Argument(name = "thing1", value = "somevalue"),
                @Argument(name = "thing2")
        })
)
public String handleWithHeadersExchange(String foo) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the <code>x-message-ttl</code> argument is set to 10 seconds for the queue.
Since the argument type is not <code>String</code>, we have to specify its type&#8201;&#8212;&#8201;in this case, <code>Integer</code>.
As with all such declarations, if the queue already exists, the arguments must match those on the queue.
For the header exchange, we set the binding arguments to match messages that have the <code>thing1</code> header set to <code>somevalue</code>, and
the <code>thing2</code> header must be present with any value.
The <code>x-match</code> argument means both conditions must be satisfied.</p>
</div>
<div class="paragraph">
<p>The argument name, value, and type can be property placeholders (<code>${&#8230;&#8203;}</code>) or SpEL expressions (<code>#{&#8230;&#8203;}</code>).
The <code>name</code> must resolve to a <code>String</code>.
The expression for <code>type</code> must resolve to a <code>Class</code> or the fully-qualified name of a class.
The <code>value</code> must resolve to something that can be converted by the <code>DefaultConversionService</code> to the type (such as the <code>x-message-ttl</code> in the preceding example).</p>
</div>
<div class="paragraph">
<p>If a name resolves to <code>null</code> or an empty <code>String</code>, that <code>@Argument</code> is ignored.</p>
</div>
<div class="sect5">
<h6 id="meta-annotation-driven">Meta-annotations</h6>
<div class="paragraph">
<p>Sometimes you may want to use the same configuration for multiple listeners.
To reduce the boilerplate configuration, you can use meta-annotations to create your own listener annotation.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RabbitListener(bindings = @QueueBinding(
        value = @Queue,
        exchange = @Exchange(value = "metaFanout", type = ExchangeTypes.FANOUT)))
public @interface MyAnonFanoutListener {
}

public class MetaListener {

    @MyAnonFanoutListener
    public void handle1(String foo) {
        ...
    }

    @MyAnonFanoutListener
    public void handle2(String foo) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, each listener created by the <code>@MyAnonFanoutListener</code> annotation binds an anonymous, auto-delete
queue to the fanout exchange, <code>metaFanout</code>.
The meta-annotation mechanism is simple because attributes on the user-defined annotation are <strong>not</strong> examined - so
you cannot override settings from the meta-annotation.
You can use normal <code>@Bean</code> definitions when you need more advanced configuration.</p>
</div>
</div>
<div class="sect5">
<h6 id="async-annotation-driven-enable">Enable Listener Endpoint Annotations</h6>
<div class="paragraph">
<p>To enable support for <code>@RabbitListener</code> annotations, you can add <code>@EnableRabbit</code> to one of your <code>@Configuration</code> classes.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRabbit
public class AppConfig {

    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setConcurrentConsumers(3);
        factory.setMaxConcurrentConsumers(10);
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since version 2.0, a <code>DirectMessageListenerContainerFactory</code> is also available.
It creates <code>DirectMessageListenerContainer</code> instances.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For information to help you choose between <code>SimpleRabbitListenerContainerFactory</code> and <code>DirectRabbitListenerContainerFactory</code>, see <a href="#choose-container">Choosing a Container</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the infrastructure looks for a bean named <code>rabbitListenerContainerFactory</code> as the source for the factory to use to create message listener containers.
In this case, and ignoring the RabbitMQ infrastructure setup, the <code>processOrder</code> method can be invoked with a core poll size of three threads and a maximum pool size of ten threads.</p>
</div>
<div class="paragraph">
<p>You can customize the listener container factory to use for each annotation, or you can configure an explicit default by implementing the <code>RabbitListenerConfigurer</code> interface.
The default is required only if at least one endpoint is registered without a specific container factory.
See the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/rabbit/annotation/RabbitListenerConfigurer.html">Javadoc</a> for full details and examples.</p>
</div>
<div class="paragraph">
<p>The container factories provide methods for adding <code>MessagePostProcessor</code> instances that are applied after receiving messages (before invoking the listener) and before sending replies.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0.6, you can add a <code>RetryTemplate</code> and <code>RecoveryCallback</code> to the listener container factory.
It is used when sending replies.
The <code>RecoveryCallback</code> is invoked when retries are exhausted.
You can use a <code>SendRetryContextAccessor</code> to get information from the context.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">factory.setRetryTemplate(retryTemplate);
factory.setReplyRecoveryCallback(ctx -&gt; {
    Message failed = SendRetryContextAccessor.getMessage(ctx);
    Address replyTo = SendRetryContextAccessor.getAddress(ctx);
    Throwable t = ctx.getLastThrowable();
    ...
    return null;
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML configuration, you can use the <code>&lt;rabbit:annotation-driven&gt;</code> element.
Any beans annotated with <code>@RabbitListener</code> are detected.</p>
</div>
<div class="paragraph">
<p>For <code>SimpleRabbitListenerContainer</code> instances, you can use XML similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:annotation-driven/&gt;

&lt;bean id="rabbitListenerContainerFactory"
      class="org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="concurrentConsumers" value="3"/&gt;
    &lt;property name="maxConcurrentConsumers" value="10"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For <code>DirectMessageListenerContainer</code> instances, you can use XML similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:annotation-driven/&gt;

&lt;bean id="rabbitListenerContainerFactory"
      class="org.springframework.amqp.rabbit.config.DirectRabbitListenerContainerFactory"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="consumersPerQueue" value="3"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>@RabbitListener</code> annotation has a <code>concurrency</code> property.
It supports SpEL expressions (<code>#{&#8230;&#8203;}</code>) and property placeholders (<code>${&#8230;&#8203;}</code>).
Its meaning and allowed values depend on the container type, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the <code>DirectMessageListenerContainer</code>, the value must be a single integer value, which sets the <code>consumersPerQueue</code> property on the container.</p>
</li>
<li>
<p>For the <code>SimpleRabbitListenerContainer</code>, the value can be a single integer value, which sets the <code>concurrentConsumers</code> property on the container, or it can have the form, <code>m-n</code>, where <code>m</code> is the <code>concurrentConsumers</code> property and <code>n</code> is the <code>maxConcurrentConsumers</code> property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In either case, this setting overrides the settings on the factory.
Previously you had to define different container factories if you had listeners that required different concurrency.</p>
</div>
</div>
<div class="sect5">
<h6 id="async-annotation-conversion">Message Conversion for Annotated Methods</h6>
<div class="paragraph">
<p>There are two conversion steps in the pipeline before invoking the listener.
The first step uses a <code>MessageConverter</code> to convert the incoming Spring AMQP <code>Message</code> to a Spring-messaging <code>Message</code>.
When the target method is invoked, the message payload is converted, if necessary, to the method parameter type.</p>
</div>
<div class="paragraph">
<p>The default <code>MessageConverter</code> for the first step is a Spring AMQP <code>SimpleMessageConverter</code> that handles conversion to
<code>String</code> and <code>java.io.Serializable</code> objects.
All others remain as a <code>byte[]</code>.
In the following discussion, we call this the &#8220;message converter&#8221;.</p>
</div>
<div class="paragraph">
<p>The default converter for the second step is a <code>GenericMessageConverter</code>, which delegates to a conversion service
(an instance of <code>DefaultFormattingConversionService</code>).
In the following discussion, we call this the &#8220;method argument converter&#8221;.</p>
</div>
<div class="paragraph">
<p>To change the message converter, you can add it as a property to the container factory bean.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    ...
    factory.setMessageConverter(new Jackson2JsonMessageConverter());
    ...
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This configures a Jackson2 converter that expects header information to be present to guide the conversion.</p>
</div>
<div class="paragraph">
<p>You can also use a <code>ContentTypeDelegatingMessageConverter</code>, which can handle conversion of different content types.</p>
</div>
<div class="paragraph">
<p>In most cases, it is not necessary to customize the method argument converter unless, for example, you want to use
a custom <code>ConversionService</code>.</p>
</div>
<div class="paragraph">
<p>In versions prior to 1.6, the type information to convert the JSON had to be provided in message headers, or a
custom <code>ClassMapper</code> was required.
Starting with version 1.6, if there are no type information headers, the type can be inferred from the target
method arguments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This type inference works only for <code>@RabbitListener</code> at the method level.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#json-message-converter">Jackson2JsonMessageConverter</a> for more information.</p>
</div>
<div class="paragraph">
<p>If you wish to customize the method argument converter, you can do so as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRabbit
public class AppConfig implements RabbitListenerConfigurer {

    ...

    @Bean
    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
        factory.setMessageConverter(new GenericMessageConverter(myConversionService()));
        return factory;
    }

    @Bean
    public ConversionService myConversionService() {
        DefaultConversionService conv = new DefaultConversionService();
        conv.addConverter(mySpecialConverter());
        return conv;
    }

    @Override
    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());
    }

    ...

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For multi-method listeners (see <a href="#annotation-method-selection">Multi-method Listeners</a>), the method selection is based on the payload of the message <strong>after the message conversion</strong>.
The method argument converter is called only after the method has been selected.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="async-annotation-driven-registration">Programmatic Endpoint Registration</h6>
<div class="paragraph">
<p><code>RabbitListenerEndpoint</code> provides a model of a Rabbit endpoint and is responsible for configuring the container for that model.
The infrastructure lets you configure endpoints programmatically in addition to the ones that are detected by the <code>RabbitListener</code> annotation.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRabbit
public class AppConfig implements RabbitListenerConfigurer {

    @Override
    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();
        endpoint.setQueueNames("anotherQueue");
        endpoint.setMessageListener(message -&gt; {
            // processing
        });
        registrar.registerEndpoint(endpoint);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we used <code>SimpleRabbitListenerEndpoint</code>, which provides the actual <code>MessageListener</code> to invoke, but you could just as well build your own endpoint variant to describe a custom invocation mechanism.</p>
</div>
<div class="paragraph">
<p>It should be noted that you could just as well skip the use of <code>@RabbitListener</code> altogether and register your endpoints programmatically through <code>RabbitListenerConfigurer</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="async-annotation-driven-enable-signature">Annotated Endpoint Method Signature</h6>
<div class="paragraph">
<p>So far, we have been injecting a simple <code>String</code> in our endpoint, but it can actually have a very flexible method signature.
The follwoing example rewrites it to inject the <code>Order</code> with a custom header:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyService {

    @RabbitListener(queues = "myQueue")
    public void processOrder(Order order, @Header("order_type") String orderType) {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following list shows the main elements you can inject in listener endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The raw <code>org.springframework.amqp.core.Message</code>.</p>
</li>
<li>
<p>The <code>com.rabbitmq.client.Channel</code> on which the message was received.</p>
</li>
<li>
<p>The <code>org.springframework.messaging.Message</code> representing the incoming AMQP message.
Note that this message holds both the custom and the standard headers (as defined by <code>AmqpHeaders</code>).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 1.6, the inbound <code>deliveryMode</code> header is now available in the header with a name of
<code>AmqpHeaders.RECEIVED_DELIVERY_MODE</code> instead of <code>AmqpHeaders.DELIVERY_MODE</code>.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Header</code>-annotated method arguments to extract a specific header value, including standard AMQP headers.</p>
</li>
<li>
<p><code>@Headers</code>-annotated argument that must also be assignable to <code>java.util.Map</code> for getting access to all headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A non-annotated element that is not one of the supported types (that is,
<code>Message</code> and <code>Channel</code>) is considered to be the payload.
You can make that explicit by annotating the parameter with <code>@Payload</code>.
You can also turn on validation by adding an extra <code>@Valid</code>.</p>
</div>
<div class="paragraph">
<p>The ability to inject Spring’s message abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on the transport-specific API.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(queues = "myQueue")
public void processOrder(Message&lt;Order&gt; order) { ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Handling of method arguments is provided by <code>DefaultMessageHandlerMethodFactory</code>, which you can further customize to support additional method arguments.
The conversion and validation support can be customized there as well.</p>
</div>
<div class="paragraph">
<p>For instance, if we want to make sure our <code>Order</code> is valid before processing it, we can annotate the payload with <code>@Valid</code> and configure the necessary validator, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableRabbit
public class AppConfig implements RabbitListenerConfigurer {

    @Override
    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());
    }

    @Bean
    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="annotation-multiple-queues">Listening to Multiple Queues</h6>
<div class="paragraph">
<p>When you use the <code>queues</code> attribute, you can specify that the associated container can listen to multiple queues.
You can use a <code>@Header</code> annotation to make the queue name from which a message was received available to the POJO
method.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyService {

    @RabbitListener(queues = { "queue1", "queue2" } )
    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 1.5, you can externalize the queue names by using property placeholders and SpEL.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyService {

    @RabbitListener(queues = "#{'${property.with.comma.delimited.queue.names}'.split(',')}" )
    public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Prior to version 1.5, only a single queue could be specified this way.
Each queue needed a separate property.</p>
</div>
</div>
<div class="sect5">
<h6 id="async-annotation-driven-reply">Reply Management</h6>
<div class="paragraph">
<p>The existing support in <code>MessageListenerAdapter</code> already lets your method have a non-void return type.
When that is the case, the result of the invocation is encapsulated in a message sent either in the address specified in the <code>ReplyToAddress</code> header of the original message or in the default address configured on the listener.
You can set that default address by using the <code>@SendTo</code> annotation of the messaging abstraction.</p>
</div>
<div class="paragraph">
<p>Assuming our <code>processOrder</code> method should now return an <code>OrderStatus</code>, we can write it as follows to automatically send a reply:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(destination = "myQueue")
@SendTo("status")
public OrderStatus processOrder(Order order) {
    // order processing
    return status;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to set additional headers in a transport-independent manner, you could return a <code>Message</code> instead, something like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(destination = "myQueue")
@SendTo("status")
public Message&lt;OrderStatus&gt; processOrder(Order order) {
    // order processing
    return MessageBuilder
        .withPayload(status)
        .setHeader("code", 1234)
        .build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@SendTo</code> value is assumed as a reply <code>exchange</code> and <code>routingKey</code> pair that follws the <code>exchange/routingKey</code> pattern,
where one of those parts can be omitted.
The valid values are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thing1/thing2</code>: The <code>replyTo</code> exchange and the <code>routingKey</code>.
<code>thing1/</code>: The <code>replyTo</code> exchange and the default (empty) <code>routingKey</code>.
<code>thing2</code> or <code>/thing2</code>: The <code>replyTo</code> <code>routingKey</code> and the default (empty) exchange.
<code>/</code> or empty: The <code>replyTo</code> default exchange and the default <code>routingKey</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also, you can use <code>@SendTo</code> without a <code>value</code> attribute.
This case is equal to an empty <code>sendTo</code> pattern.
<code>@SendTo</code> is used only if the inbound message does not have a <code>replyToAddress</code> property.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5, the <code>@SendTo</code> value can be a bean initialization SpEL Expression, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(queues = "test.sendTo.spel")
@SendTo("#{spelReplyTo}")
public String capitalizeWithSendToSpel(String foo) {
    return foo.toUpperCase();
}
...
@Bean
public String spelReplyTo() {
    return "test.sendTo.reply.spel";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The expression must evaluate to a <code>String</code>, which can be a simple queue name (sent to the default exchange) or with
the form <code>exchange/routingKey</code> as discussed prior to the preceding example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>#{&#8230;&#8203;}</code> expression is evaluated once, during initialization.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For dynamic reply routing, the message sender should include a <code>reply_to</code> message property or use the alternate
runtime SpEL expression (described after the next example).</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6, the <code>@SendTo</code> can be a SpEL expression that is evaluated at runtime against the request
and reply, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(queues = "test.sendTo.spel")
@SendTo("!{'some.reply.queue.with.' + result.queueName}")
public Bar capitalizeWithSendToSpel(Foo foo) {
    return processTheFooAndReturnABar(foo);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The runtime nature of the SpEL expression is indicated with <code>!{&#8230;&#8203;}</code> delimiters.
The evaluation context <code>#root</code> object for the expression has three properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>request</code>: The <code>o.s.amqp.core.Message</code> request object.</p>
</li>
<li>
<p><code>source</code>: The <code>o.s.messaging.Message&lt;?&gt;</code> after conversion.</p>
</li>
<li>
<p><code>result</code>: The method result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The context has a map property accessor, a standard type converter, and a bean resolver, which lets other beans in the
context be referenced (for example, <code>@someBeanName.determineReplyQ(request, result)</code>).</p>
</div>
<div class="paragraph">
<p>In summary, <code>#{&#8230;&#8203;}</code> is evaluated once during initialization, with the <code>#root</code> object being the application context.
Beans are referenced by their names.
<code>!{&#8230;&#8203;}</code> is evaluated at runtime for each message, with the root object having the properties listed earlier.
Beans are referenced with their names, prefixed by <code>@</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, simple property placeholders are also supported (for example, <code>${some.reply.to}</code>).
With earlier versions, the following can be used as a work around, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(queues = "foo")
@SendTo("#{environment['my.send.to']}")
public String listen(Message in) {
    ...
    return ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="annotation-method-selection">Multi-method Listeners</h6>
<div class="paragraph">
<p>Starting with version 1.5.0, you can specify the <code>@RabbitListener</code> annotation at the class level.
Together with the new <code>@RabbitHandler</code> annotation, this lets a single listener invoke different methods, based on
the payload type of the incoming message.
This is best described using an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(id="multi", queues = "someQueue")
@SendTo("my.reply.queue")
public class MultiListenerBean {

    @RabbitHandler
    public String thing2(Thing2 thing2) {
        ...
    }

    @RabbitHandler
    public String cat(Cat cat) {
        ...
    }

    @RabbitHandler
    public String hat(@Header("amqp_receivedRoutingKey") String rk, @Payload Hat hat) {
        ...
    }

    @RabbitHandler(isDefault = true)
    public String defaultMethod(Object object) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the individual <code>@RabbitHandler</code> methods are invoked if the converted payload is a <code>Thing2</code>, a <code>Cat</code>, or a <code>Hat</code>.
You should understand that the system must be able to identify a unique method based on the payload type.
The type is checked for assignability to a single parameter that has no annotations or that is annotated with the <code>@Payload</code> annotation.
Notice that the same method signatures apply, as discussed in the method-level <code>@RabbitListener</code> (<a href="#message-listener-adapter">described earlier</a>).</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0.3, a <code>@RabbitHandler</code> method can be designated as the default method, which is invoked if there is no match on other methods.
At most, one method can be so designated.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>@RabbitHandler</code> is intended only for processing message payloads after conversion, if you wish to receive the unconverted raw <code>Message</code> object, you must use <code>@RabbitListener</code> on the method, not the class.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="repeatable-rabbit-listener"><code>@Repeatable</code> <code>@RabbitListener</code></h6>
<div class="paragraph">
<p>Starting with version 1.6, the <code>@RabbitListener</code> annotation is marked with <code>@Repeatable</code>.
This means that the annotation can appear on the same annotated element (method or class) multiple times.
In this case, a separate listener container is created for each annotation, each of which invokes the same listener
<code>@Bean</code>.
Repeatable annotations can be used with Java 8 or above.
When using Java 7 or earlier, you can achieve the same effect by using the <code>@RabbitListeners</code> &#8220;container&#8221; annotation, with an array of <code>@RabbitListener</code> annotations.</p>
</div>
</div>
<div class="sect5">
<h6 id="_proxy_rabbitlistener_and_generics">Proxy <code>@RabbitListener</code> and Generics</h6>
<div class="paragraph">
<p>If your service is intended to be proxied (for example, in the case of <code>@Transactional</code>), you should keep in mind some considerations when
the interface has generic parameters.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface TxService&lt;P&gt; {

   String handle(P payload, String header);

}

static class TxServiceImpl implements TxService&lt;Foo&gt; {

    @Override
    @RabbitListener(...)
    public String handle(Foo foo, String rk) {
         ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With a generic interface and a particular implementation, you are forced to switch to the CGLIB target class proxy because the actual implementation of the interface
<code>handle</code> method is a bridge method.
In the case of transaction management, the use of CGLIB is configured by using
an annotation option: <code>@EnableTransactionManagement(proxyTargetClass = true)</code>.
And in this case, all annotations have to be declared on the target method in the implementation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class TxServiceImpl implements TxService&lt;Foo&gt; {

    @Override
    @Transactional
    @RabbitListener(...)
    public String handle(@Payload Foo foo, @Header("amqp_receivedRoutingKey") String rk) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="annotation-error-handling">Handling Exceptions</h6>
<div class="paragraph">
<p>By default, if an annotated listener method throws an exception, it is thrown to the container and the message are requeued and redelivered, discarded, or routed to a dead letter exchange, depending on the container and broker configuration.
Nothing is returned to the sender.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>@RabbitListener</code> annotation has two new attributes: <code>errorHandler</code> and <code>returnExceptions</code>.</p>
</div>
<div class="paragraph">
<p>These are not configured by default.</p>
</div>
<div class="paragraph">
<p>You can use the <code>errorHandler</code> to provide the bean name of a <code>RabbitListenerErrorHandler</code> implementation.
This functional interface has one method, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface RabbitListenerErrorHandler {

    Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,
              ListenerExecutionFailedException exception) throws Exception;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, you have access to the raw message received from the container, the spring-messaging <code>Message&lt;?&gt;</code> object produced by the message converter, and the exception that was thrown by the listener (wrapped in a <code>ListenerExecutionFailedException</code>).
The error handler can either return some result (which is sent as the reply) or throw the original or a new exception (which is thrown to the container or returned to the sender, depending on the <code>returnExceptions</code> setting).</p>
</div>
<div class="paragraph">
<p>The <code>returnExceptions</code> attribute, when <code>true</code>, causes exceptions to be returned to the sender.
The exception is wrapped in a <code>RemoteInvocationResult</code> object.
On the sender side, there is an available <code>RemoteInvocationAwareMessageConverterAdapter</code>, which, if configured into the <code>RabbitTemplate</code>, re-throws the server-side exception, wrapped in an <code>AmqpRemoteException</code>.
The stack trace of the server exception is synthesized by merging the server and client stack traces.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This mechanism generally works only with the default <code>SimpleMessageConverter</code>, which uses Java serialization.
Exceptions are generally not &#8220;Jackson-friendly&#8221; and cannot be serialized to JSON.
If you use JSON, consider using an <code>errorHandler</code> to return some other Jackson-friendly <code>Error</code> object when an exception is thrown.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In version 2.1, this interface moved from package <code>o.s.amqp.rabbit.listener</code> to <code>o.s.amqp.rabbit.listener.api</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_container_management">Container Management</h6>
<div class="paragraph">
<p>Containers created for annotations are not registered with the application context.
You can obtain a collection of all containers by invoking <code>getListenerContainers()</code> on the
<code>RabbitListenerEndpointRegistry</code> bean.
You can then iterate over this collection, for example, to stop or start all containers or invoke the <code>Lifecycle</code> methods
on the registry itself, which will invoke the operations on each container.</p>
</div>
<div class="paragraph">
<p>You can also get a reference to an individual container by using its <code>id</code>, using <code>getListenerContainer(String id)</code>&#8201;&#8212;&#8201;for
example, <code>registry.getListenerContainer("multi")</code> for the container created by the snippet above.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5.2, you can obtain the <code>id</code> values of the registered containers with <code>getListenerContainerIds()</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5, you can now assign a <code>group</code> to the container on the <code>RabbitListener</code> endpoint.
This provides a mechanism to get a reference to a subset of containers.
Adding a <code>group</code> attribute causes a bean of type <code>Collection&lt;MessageListenerContainer&gt;</code> to be registered with the context with the group name.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-container-factories">Using Container Factories</h5>
<div class="paragraph">
<p>Listener container factories were introduced to support the <code>@RabbitListener</code> and registering containers with the <code>RabbitListenerEndpointRegistry</code>, as discussed in <a href="#async-annotation-driven-registration">Programmatic Endpoint Registration</a>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, they can be used to create any listener container&#8201;&#8212;&#8201;even a container without a listener (such as for use in Spring Integration).
Of course, a listener must be added before the container is started.</p>
</div>
<div class="paragraph">
<p>There are two ways to create such containers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a SimpleRabbitListenerEndpoint</p>
</li>
<li>
<p>Add the listener after creation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to use a <code>SimpleRabbitListenerEndpoint</code> to create a listener container:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleMessageListenerContainer factoryCreatedContainerSimpleListener(
        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {
    SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();
    endpoint.setQueueNames("queue.1");
    endpoint.setMessageListener(message -&gt; {
        ...
    });
    return rabbitListenerContainerFactory.createListenerContainer(endpoint);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add the listener after creation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleMessageListenerContainer factoryCreatedContainerNoListener(
        SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {
    SimpleMessageListenerContainer container = rabbitListenerContainerFactory.createListenerContainer();
    container.setMessageListener(message -&gt; {
        ...
    });
    container.setQueueNames("test.no.listener.yet");
    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In either case, the listener can also be a <code>ChannelAwareMessageListener</code>, since it is now a sub-interface of <code>MessageListener</code>.</p>
</div>
<div class="paragraph">
<p>These techniques are useful if you wish to create several containers with similar properties or use a pre-configured container factory such as the one provided by Spring Boot auto configuration or both.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Containers created this way are normal <code>@Bean</code> instances and are not registered in the <code>RabbitListenerEndpointRegistry</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="async-returns">Asynchronous <code>@RabbitListener</code> Return Types</h5>
<div class="paragraph">
<p>Starting with version 2.1, <code>@RabbitListener</code> (and <code>@RabbitHandler</code>) methods can be specified with asynchronous return types <code>ListenableFuture&lt;?&gt;</code> and <code>Mono&lt;?&gt;</code>, letting the reply be sent asynchronously.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The listener container factory must be configured with <code>AcknowledgeMode.MANUAL</code> so that the consumer thread will not ack the message; instead, the asynchronous completion will ack or nack the message when the async operation completes.
When the async result is completed with an error, whether the message is requeued or not depends on the exception type thrown, the container configuration, and the container error handler.
By default, the message will be requeued, unless the container&#8217;s <code>defaultRequeueRejected</code> property is set to <code>false</code>.
If the async result is completed with an <code>AmqpRejectAndDontRequeueException</code>, the message will not be requeued.
If some exception occurs within the listener method that prevents creation of the async result object, you MUST catch that exception and return an appropriate return object that will cause the message to be acknowledged or requeued.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="threading">Threading and Asynchronous Consumers</h5>
<div class="paragraph">
<p>A number of different threads are involved with asynchronous consumers.</p>
</div>
<div class="paragraph">
<p>Threads from the <code>TaskExecutor</code> configured in the <code>SimpleMessageListenerContainer</code> are used to invoke the <code>MessageListener</code> when a new message is delivered by <code>RabbitMQ Client</code>.
If not configured, a <code>SimpleAsyncTaskExecutor</code> is used.
If you use a pooled executor, you need to ensure the pool size is sufficient to handle the configured concurrency.
With the <code>DirectMessageListenerContainer</code>, the <code>MessageListener</code> is invoked directly on a <code>RabbitMQ Client</code> thread.
In this case, the <code>taskExecutor</code> is used for the task that monitors the consumers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the default <code>SimpleAsyncTaskExecutor</code>, for the threads the listener is invoked on, the listener container <code>beanName</code> is used in the <code>threadNamePrefix</code>.
This is useful for log analysis.
We generally recommend always including the thread name in the logging appender configuration.
When a <code>TaskExecutor</code> is specifically provided through the <code>taskExecutor</code> property on the container, it is used as is, without modification.
It is recommended that you use a similar technique to name the threads created by a custom <code>TaskExecutor</code> bean definition, to aid with thread identification in log messages.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Executor</code> configured in the <code>CachingConnectionFactory</code> is passed into the <code>RabbitMQ Client</code> when creating the connection, and its threads are used to deliver new messages to the listener container.
If this is not configured, the client uses an internal thread pool executor with a pool size of five.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
With the <code>DirectMessageListenerContainer</code>, you need to ensure that the connection factory is configured with a task executor that had sufficient threads to support your desired concurrency across all listener containers that use that factory.
The default pool size is only five.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>RabbitMQ client</code> uses a <code>ThreadFactory</code> to create threads for low-level I/O (socket) operations.
To modify this factory, you need to configure the underlying RabbitMQ <code>ConnectionFactory</code>, as discussed in <a href="#connection-factory">Configuring the Underlying Client Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="choose-container">Choosing a Container</h5>
<div class="paragraph">
<p>Version 2.0 introduced the <code>DirectMessageListenerContainer</code> (DMLC).
Previously, only the <code>SimpleMessageListenerContainer</code> (SMLC) was available.
The SMLC uses an internal queue and a dedicated thread for each consumer.
If a container is configured to listen to multiple queues, the same consumer thread is used to process all the queues.
Concurrency is controlled by <code>concurrentConsumers</code> and other properties.
As messages arrive from the RabbitMQ client, the client thread hands them off to the consumer thread through the queue.
This architecture was required because, in early versions of the RabbitMQ client, multiple concurrent deliveries were not possible.
Newer versions of the client have a revised threading model and can now support concurrency.
This has allowed the introduction of the DMLC where the listener is now invoked directly on the RabbitMQ Client thread.
Its architecture is, therefore, actually &#8220;simpler&#8221; than the SMLC.
However, there are some limitations with this approach, and certain features of the SMLC are not available with the DMLC.
Also, concurrency is controlled by <code>consumersPerQueue</code> (and the client library&#8217;s thread pool).
The <code>concurrentConsumers</code> and associated properties are not available with this container.</p>
</div>
<div class="paragraph">
<p>The following features are available with the SMLC but not the DMLC:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>txSize</code>: With the SMLC, you can set this to control how many messages are delivered in a transaction or to reduce the number of acks, but it may cause the number of duplicate deliveries to increase after a failure.
(The DMLC does have <code>messagesPerAck</code>, which you can use to reduce the acks, the same as with <code>txSize</code> and the SMLC, but it cannot be used with transactions&#8201;&#8212;&#8201;each message is delivered and ack&#8217;d in a separate transaction).</p>
</li>
<li>
<p><code>maxConcurrentConsumers</code> and consumer scaling intervals or triggers&#8201;&#8212;&#8201;there is no auto-scaling in the DMLC.
It does, however, let you programmatically change the <code>consumersPerQueue</code> property and the consumers are adjusted accordingly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, the DMLC has the following benefits over the SMLC:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding and removing queues at runtime is more efficient.
With the SMLC, the entire consumer thread is restarted (all consumers canceled and re-created).
With the DMLC, unaffected consumers are not canceled.</p>
</li>
<li>
<p>The context switch between the RabbitMQ Client thread and the consumer thread is avoided.</p>
</li>
<li>
<p>Threads are shared across consumers rather than having a dedicated thread for each consumer in the SMLC.
However, see the IMPORTANT note about the connection factory configuration in <a href="#threading">Threading and Asynchronous Consumers</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#containerAttributes">Message Listener Container Configuration</a> for information about which configuration properties apply to each container.</p>
</div>
</div>
<div class="sect4">
<h5 id="idle-containers">Detecting Idle Asynchronous Consumers</h5>
<div class="paragraph">
<p>While efficient, one problem with asynchronous consumers is detecting when they are idle&#8201;&#8212;&#8201;users might want to take
some action if no messages arrive for some period of time.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6, it is now possible to configure the listener container to publish a
<code>ListenerContainerIdleEvent</code> when some time passes with no message delivery.
While the container is idle, an event is published every <code>idleEventInterval</code> milliseconds.</p>
</div>
<div class="paragraph">
<p>To configure this feature, set <code>idleEventInterval</code> on the container.
The following example shows how to do so in XML and in Java (for both a <code>SimpleMessageListenerContainer</code> and a <code>SimpleRabbitListenerContainerFactory</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:listener-container connection-factory="connectionFactory"
        ...
        idle-event-interval="60000"
        ...
        &gt;
    &lt;rabbit:listener id="container1" queue-names="foo" ref="myListener" method="handle" /&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleMessageListenerContainer(ConnectionFactory connectionFactory) {
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);
    ...
    container.setIdleEventInterval(60000L);
    ...
    return container;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(rabbitConnectionFactory());
    factory.setIdleEventInterval(60000L);
    ...
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In each of these cases, an event is published once per minute while the container is idle.</p>
</div>
<div class="sect5">
<h6 id="_event_consumption">Event Consumption</h6>
<div class="paragraph">
<p>You can capture idle events by implementing <code>ApplicationListener</code>&#8201;&#8212;&#8201;either a general listener, or one narrowed to only
receive this specific event.
You can also use <code>@EventListener</code>, introduced in Spring Framework 4.2.</p>
</div>
<div class="paragraph">
<p>The following example combines the <code>@RabbitListener</code> and <code>@EventListener</code> into a single class.
You need to understand that the application listener gets events for all containers, so you may need to
check the listener ID if you want to take specific action based on which container is idle.
You can also use the <code>@EventListener</code> <code>condition</code> for this purpose.</p>
</div>
<div class="paragraph">
<p>The events have four properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code>: The listener container instance</p>
</li>
<li>
<p><code>id</code>: The listener ID (or container bean name)</p>
</li>
<li>
<p><code>idleTime</code>: The time the container had been idle when the event was published</p>
</li>
<li>
<p><code>queueNames</code>: The names of the queue(s) that the container listens to</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to create listeners by using both the <code>@RabbitListener</code> and the <code>@EventListener</code> annotations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java">public class Listener {

    @RabbitListener(id="someId", queues="#{queue.name}")
    public String listen(String foo) {
        return foo.toUpperCase();
    }

    @EventListener(condition = "event.listenerId == 'someId'")
    public void onApplicationEvent(ListenerContainerIdleEvent event) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Event listeners see events for all containers.
Consequently, in the preceding example, we narrow the events received based on the listener ID.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
If you wish to use the idle event to stop the lister container, you should not call <code>container.stop()</code> on the thread that calls the listener.
Doing so always causes delays and unnecessary log messages.
Instead, you should hand off the event to a different thread that can then stop the container.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="containers-and-broker-named-queues">3.1.7. Containers and Broker-Named queues</h4>
<div class="paragraph">
<p>While it is preferable to use <code>AnonymousQueue</code> instances as auto-delete queues, starting with version 2.1, you can use broker named queues with listener containers.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue queue() {
    return new Queue("", false, true, true);
}

@Bean
public SimpleMessageListenerContainer container() {
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(cf());
    container.setQueues(queue());
    container.setMessageListener(m -&gt; {
        ...
    });
    container.setMissingQueuesFatal(false);
    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice the empty <code>String</code> for the name.
When the <code>RabbitAdmin</code> declares queues, it updates the <code>Queue.actualName</code> property with the name returned by the broker.
You must use <code>setQueues()</code> when you configure the container for this to work, so that the container can access the declared name at runtime.
Just setting the names is insufficient.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot add broker-named queues to the containers while they are running.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When a connection is reset and a new one is established, the new queue gets a new name.
Since there is a race condition between the container restarting and the queue being re-declared, it is important to set the container&#8217;s <code>missingQueuesFatal</code> property to <code>false</code>, since the container is likely to initially try to reconnect to the old queue.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="message-converters">3.1.8. Message Converters</h4>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> also defines several methods for sending and receiving messages that delegate to a <code>MessageConverter</code>.
The <code>MessageConverter</code> provides a single method for each direction: one for converting <strong>to</strong> a <code>Message</code> and another for converting <strong>from</strong> a <code>Message</code>.
Notice that, when converting to a <code>Message</code>, you can also provide properties in addition to the object.
The <code>object</code> parameter typically corresponds to the Message body.
The following listing shows the <code>MessageConverter</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageConverter {

    Message toMessage(Object object, MessageProperties messageProperties)
            throws MessageConversionException;

    Object fromMessage(Message message) throws MessageConversionException;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The relevant <code>Message</code>-sending methods on the <code>AmqpTemplate</code> are simpler than the methods we discussed previously, because they do not require the <code>Message</code> instance.
Instead, the <code>MessageConverter</code> is responsible for &#8220;creating&#8221; each <code>Message</code> by converting the provided object to the byte array for the <code>Message</code> body and then adding any provided <code>MessageProperties</code>.
The following listing shows the definitions of the various methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void convertAndSend(Object message) throws AmqpException;

void convertAndSend(String routingKey, Object message) throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message)
    throws AmqpException;

void convertAndSend(Object message, MessagePostProcessor messagePostProcessor)
    throws AmqpException;

void convertAndSend(String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>On the receiving side, there are only two methods: one that accepts the queue name and one that relies on the template&#8217;s &#8220;queue&#8221; property having been set.
The following listing shows the definitions of the two methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>MessageListenerAdapter</code> mentioned in <a href="#async-consumer">Asynchronous Consumer</a> also uses a <code>MessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="simple-message-converter"><code>SimpleMessageConverter</code></h5>
<div class="paragraph">
<p>The default implementation of the <code>MessageConverter</code> strategy is called <code>SimpleMessageConverter</code>.
This is the converter that is used by an instance of <code>RabbitTemplate</code> if you do not explicitly configure an alternative.
It handles text-based content, serialized Java objects, and byte arrays.</p>
</div>
<div class="sect5">
<h6 id="_converting_from_a_message">Converting From a <code>Message</code></h6>
<div class="paragraph">
<p>If the content type of the input <code>Message</code> begins with "text" (for example,
"text/plain"), it also checks for the content-encoding property to determine the charset to be used when converting the <code>Message</code> body byte array to a Java <code>String</code>.
If no content-encoding property had been set on the input <code>Message</code>, it uses the UTF-8 charset by default.
If you need to override that default setting, you can configure an instance of <code>SimpleMessageConverter</code>, set its <code>defaultCharset</code> property, and inject that into a <code>RabbitTemplate</code> instance.</p>
</div>
<div class="paragraph">
<p>If the content-type property value of the input <code>Message</code> is set to "application/x-java-serialized-object", the <code>SimpleMessageConverter</code> tries to deserialize (rehydrate) the byte array into a Java object.
While that might be useful for simple prototyping, we do not recommend relying on Java serialization, since it leads to tight coupling between the producer and the consumer.
Of course, it also rules out usage of non-Java systems on either side.
With AMQP being a wire-level protocol, it would be unfortunate to lose much of that advantage with such restrictions.
In the next two sections, we explore some alternatives for passing rich domain object content without relying on Java serialization.</p>
</div>
<div class="paragraph">
<p>For all other content-types, the <code>SimpleMessageConverter</code> returns the <code>Message</code> body content directly as a byte array.</p>
</div>
<div class="paragraph">
<p>See <a href="#java-deserialization">Java Deserialization</a> for important information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_converting_to_a_message">Converting To a <code>Message</code></h6>
<div class="paragraph">
<p>When converting to a <code>Message</code> from an arbitrary Java Object, the <code>SimpleMessageConverter</code> likewise deals with byte arrays, strings, and serializable instances.
It converts each of these to bytes (in the case of byte arrays, there is nothing to convert), and it ses the content-type property accordingly.
If the <code>Object</code> to be converted does not match one of those types, the <code>Message</code> body is null.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="serializer-message-converter"><code>SerializerMessageConverter</code></h5>
<div class="paragraph">
<p>This converter is similar to the <code>SimpleMessageConverter</code> except that it can be configured with other Spring Framework
<code>Serializer</code> and <code>Deserializer</code> implementations for <code>application/x-java-serialized-object</code> conversions.</p>
</div>
<div class="paragraph">
<p>See <a href="#java-deserialization">Java Deserialization</a> for important information.</p>
</div>
</div>
<div class="sect4">
<h5 id="json-message-converter">Jackson2JsonMessageConverter</h5>
<div class="paragraph">
<p>This section covers using the <code>Jackson2JsonMessageConverter</code> to convert to and from a <code>Message</code>.
It has the following sections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Jackson2JsonMessageConverter-to-message">Converting to a <code>Message</code></a></p>
</li>
<li>
<p><a href="#Jackson2JsonMessageConverter-from-message">Converting from a <code>Message</code></a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="Jackson2JsonMessageConverter-to-message">Converting to a <code>Message</code></h6>
<div class="paragraph">
<p>As mentioned in the previous section, relying on Java serialization is generally not recommended.
One rather common alternative that is more flexible and portable across different languages and platforms is JSON
(JavaScript Object Notation).
The converter can be configured on any <code>RabbitTemplate</code> instance to override its usage of the <code>SimpleMessageConverter</code>
default.
The <code>Jackson2JsonMessageConverter</code> uses the <code>com.fasterxml.jackson</code> 2.x library.
The following example configures a <code>Jackson2JsonMessageConverter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.amqp.rabbit.core.RabbitTemplate"&gt;
    &lt;property name="connectionFactory" ref="rabbitConnectionFactory"/&gt;
    &lt;property name="messageConverter"&gt;
        &lt;bean class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"&gt;
            &lt;!-- if necessary, override the DefaultClassMapper --&gt;
            &lt;property name="classMapper" ref="customClassMapper"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As shown above, <code>Jackson2JsonMessageConverter</code> uses a <code>DefaultClassMapper</code> by default.
Type information is added to (and retrieved from) <code>MessageProperties</code>.
If an inbound message does not contain type information in <code>MessageProperties</code>, but you know the expected type, you
can configure a static type by using the <code>defaultType</code> property, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="jsonConverterWithDefaultType"
      class="o.s.amqp.support.converter.Jackson2JsonMessageConverter"&gt;
    &lt;property name="classMapper"&gt;
        &lt;bean class="org.springframework.amqp.support.converter.DefaultClassMapper"&gt;
            &lt;property name="defaultType" value="thing1.PurchaseOrder"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, you can provide custom mappings from the value in the <code><em>TypeId</em></code> header.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Jackson2JsonMessageConverter jsonMessageConverter() {
    Jackson2JsonMessageConverter jsonConverter = new Jackson2JsonMessageConverter();
    jsonConverter.setClassMapper(classMapper());
    return jsonConverter;
}

@Bean
public DefaultClassMapper classMapper() {
    DefaultClassMapper classMapper = new DefaultClassMapper();
    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;&gt;();
    idClassMapping.put("thing1", Thing1.class);
    idClassMapping.put("thing2", Thing2.class);
    classMapper.setIdClassMapping(idClassMapping);
    return classMapper;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, if the sending system sets the header to <code>thing1</code>, the converter creates a <code>Thing1</code> object, and so on.
See the <a href="#spring-rabbit-json">Receiving JSON from Non-Spring Applications</a> sample application for a complete discussion about converting messages from non-Spring applications.</p>
</div>
</div>
<div class="sect5">
<h6 id="Jackson2JsonMessageConverter-from-message">Converting from a <code>Message</code></h6>
<div class="paragraph">
<p>Inbound messages are converted to objects according to the type information added to headers by the sending system.</p>
</div>
<div class="paragraph">
<p>In versions prior to 1.6, if type information is not present, conversion would fail.
Starting with version 1.6, if type information is missing, the converter converts the JSON by using Jackson defaults (usually a map).</p>
</div>
<div class="paragraph">
<p>Also, starting with version 1.6, when you use <code>@RabbitListener</code> annotations (on methods), the inferred type information is added to the <code>MessageProperties</code>.
This lets the converter convert to the argument type of the target method.
This only applies if there is one parameter with no annotations or a single parameter with the <code>@Payload</code> annotation.
Parameters of type <code>Message</code> are ignored during the analysis.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the inferred type information will override the inbound <code><em>TypeId</em></code> and related headers created
by the sending system.
This lets the receiving system automatically convert to a different domain object.
This applies only if the parameter type is concrete (not abstract or an interface) or it is from the <code>java.util</code>
package.
In all other cases, the <code><em>TypeId</em></code> and related headers is used.
There are cases where you might wish to override the default behavior and always use the <code><em>TypeId</em></code> information.
For example, suppose you have a <code>@RabbitListener</code> that takes a <code>Thing1</code> argument but the message contains a <code>Thing2</code> that
is a subclass of <code>Thing1</code> (which is concrete).
The inferred type would be incorrect.
To handle this situation, set the <code>TypePrecedence</code> property on the <code>Jackson2JsonMessageConverter</code> to <code>TYPE_ID</code> instead
of the default <code>INFERRED</code>.
(The property is actually on the converter&#8217;s <code>DefaultJackson2JavaTypeMapper</code>, but a setter is provided on the converter
for convenience.)
If you inject a custom type mapper, you should set the property on the mapper instead.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When converting from the <code>Message</code>, an incoming <code>MessageProperties.getContentType()</code> must be JSON-compliant (<code>contentType.contains("json")</code> is used to check).
Otherwise, a <code>WARN</code> log message <code>Could not convert incoming message with content-type [&#8230;&#8203;]</code>, is emitted and <code>message.getBody()</code> is returned as is&#8201;&#8212;&#8201;as a <code>byte[]</code>.
So, to meet the <code>Jackson2JsonMessageConverter</code> requirements on the consumer side, the producer must add the <code>contentType</code> message property&#8201;&#8212;&#8201;for example, as <code>application/json</code> or <code>text/x-json</code> or by using the <code>Jackson2JsonMessageConverter</code>, which sets the header automatically.
The following listing shows a number of converter calls:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener
public void thing1(Thing1 thing1) {...}

@RabbitListener
public void thing1(@Payload Thing1 thing1, @Header("amqp_consumerQueue") String queue) {...}

@RabbitListener
public void thing1(Thing1 thing1, o.s.amqp.core.Message message) {...}

@RabbitListener
public void thing1(Thing1 thing1, o.s.messaging.Message&lt;Foo&gt; message) {...}

@RabbitListener
public void thing1(Thing1 thing1, String bar) {...}

@RabbitListener
public void thing1(Thing1 thing1, o.s.messaging.Message&lt;?&gt; message) {...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the first four cases in the preceding listing, the converter tries to convert to the <code>Thing1</code> type.
The fifth example is invalid because we cannot determine which argument should receive the message payload.
With the sixth example, the Jackson defaults apply due to the generic type being a <code>WildcardType</code>.</p>
</div>
<div class="paragraph">
<p>You can, however, create a custom converter and use the <code>targetMethod</code> message property to decide which type to convert
the JSON to.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This type inference can only be achieved when the <code>@RabbitListener</code> annotation is declared at the method level.
With class-level <code>@RabbitListener</code>, the converted type is used to select which <code>@RabbitHandler</code> method to invoke.
For this reason, the infrastructure provides the <code>targetObject</code> message property, which you can use in a custom
converter to determine the type.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 1.6.11, <code>Jackson2JsonMessageConverter</code> and, therefore, <code>DefaultJackson2JavaTypeMapper</code> (<code>DefaultClassMapper</code>) provide the <code>trustedPackages</code> option to overcome <a href="https://pivotal.io/security/cve-2017-4995">Serialization Gadgets</a> vulnerability.
By default and for backward compatiblity, the <code>Jackson2JsonMessageConverter</code> trusts all packages&#8201;&#8212;&#8201;that is, it uses <code>*</code> for the option.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="json-complex">Converting From a <code>Message</code> With <code>RabbitTemplate</code></h6>
<div class="paragraph">
<p>As mentioned earlier, type information is conveyed in message headers to assist the converter when converting from a message.
This works fine in most cases.
However, when using generic types, it can only convert simple objects and known &#8220;container&#8221; objects (lists, arrays, and maps).
Starting with version 2.0, the <code>Jackson2JsonMessageConverter</code> implements <code>SmartMessageConverter</code>, which lets it be used with the new <code>RabbitTemplate</code> methods that take a <code>ParameterizedTypeReference</code> argument.
This allows conversion of complex generic types, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt; thing1 =
    rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference&lt;Thing1&lt;Thing2&lt;Cat, Hat&gt;&gt;&gt;() { });</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 2.1, the <code>AbstractJsonMessageConverter</code> class has been removed.
It is no longer the base class for <code>Jackson2JsonMessageConverter</code>.
It has been replaced by <code>AbstractJackson2MessageConverter</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_marshallingmessageconverter"><code>MarshallingMessageConverter</code></h5>
<div class="paragraph">
<p>Yet another option is the <code>MarshallingMessageConverter</code>.
It delegates to the Spring OXM library&#8217;s implementations of the <code>Marshaller</code> and <code>Unmarshaller</code> strategy interfaces.
You can read more about that library <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html">here</a>.
In terms of configuration, it is most common to provide only the constructor argument, since most implementations of <code>Marshaller</code> also implement <code>Unmarshaller</code>.
The following example shows how to configure a <code>MarshallingMessageConverter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.amqp.rabbit.core.RabbitTemplate"&gt;
    &lt;property name="connectionFactory" ref="rabbitConnectionFactory"/&gt;
    &lt;property name="messageConverter"&gt;
        &lt;bean class="org.springframework.amqp.support.converter.MarshallingMessageConverter"&gt;
            &lt;constructor-arg ref="someImplemenationOfMarshallerAndUnmarshaller"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_jackson2xmlmessageconverter"><code>Jackson2XmlMessageConverter</code></h5>
<div class="paragraph">
<p>This class was introduced in version 2.1 and can be used to convert messages from and to XML.</p>
</div>
<div class="paragraph">
<p>Both <code>Jackson2XmlMessageConverter</code> and <code>Jackson2JsonMessageConverter</code> have the same base class: <code>AbstractJackson2MessageConverter</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>AbstractJackson2MessageConverter</code> class is introduced to replace a removed class: <code>AbstractJsonMessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Jackson2XmlMessageConverter</code> uses the <code>com.fasterxml.jackson</code> 2.x library.</p>
</div>
<div class="paragraph">
<p>You can use it the same way as <code>Jackson2JsonMessageConverter</code>, except it supports XML instead of JSON.
The following example configures a <code>Jackson2JsonMessageConverter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="xmlConverterWithDefaultType"
        class="org.springframework.amqp.support.converter.Jackson2XmlMessageConverter"&gt;
    &lt;property name="classMapper"&gt;
        &lt;bean class="org.springframework.amqp.support.converter.DefaultClassMapper"&gt;
            &lt;property name="defaultType" value="foo.PurchaseOrder"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#json-message-converter">Jackson2JsonMessageConverter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_contenttypedelegatingmessageconverter"><code>ContentTypeDelegatingMessageConverter</code></h5>
<div class="paragraph">
<p>This class was introduced in version 1.4.2 and allows delegation to a specific <code>MessageConverter</code> based on the content type property in the <code>MessageProperties</code>.
By default, it delegates to a <code>SimpleMessageConverter</code> if there is no <code>contentType</code> property or there is a value that matches none of the configured converters.
The following example configures a <code>ContentTypeDelegatingMessageConverter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="contentTypeConverter" class="ContentTypeDelegatingMessageConverter"&gt;
    &lt;property name="delegates"&gt;
        &lt;map&gt;
            &lt;entry key="application/json" value-ref="jsonMessageConverter" /&gt;
            &lt;entry key="application/xml" value-ref="xmlMessageConverter" /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="java-deserialization">Java Deserialization</h5>
<div class="paragraph">
<p>This section covers how to deserialize Java objects.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is a possible vulnerability when deserializing java objects from untrusted sources.</p>
</div>
<div class="paragraph">
<p>If you accept messages from untrusted sources with a <code>content-type</code> of <code>application/x-java-serialized-object</code>, you should
consider configuring which packages and classes are allowed to be deserialized.
This applies to both the <code>SimpleMessageConverter</code> and <code>SerializerMessageConverter</code> when it is configured to use a
<code>DefaultDeserializer</code> either implicitly or via configuration.</p>
</div>
<div class="paragraph">
<p>By default, the white list is empty, meaning all classes are deserialized.</p>
</div>
<div class="paragraph">
<p>You can set a list of patterns, such as <code>thing1.<strong></code>, <code>thing1.thing2.Cat</code> or <code></strong>.MySafeClass</code>.</p>
</div>
<div class="paragraph">
<p>The patterns are checked in order until a match is found.
If there is no match, a <code>SecurityException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>You can set the patterns using the <code>whiteListPatterns</code> property on these converters.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="message-properties-converters">Message Properties Converters</h5>
<div class="paragraph">
<p>The <code>MessagePropertiesConverter</code> strategy interface is used to convert between the Rabbit Client <code>BasicProperties</code> and Spring AMQP <code>MessageProperties</code>.
The default implementation (<code>DefaultMessagePropertiesConverter</code>) is usually sufficient for most purposes, but you can implement your own if needed.
The default properties converter converts <code>BasicProperties</code> elements of type <code>LongString</code> to <code>String</code> instances when the size is not greater than <code>1024</code> bytes.
Larger <code>LongString</code> instances are not converted (see the next paragraph).
This limit can be overridden with a constructor argument.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6, headers longer than the long string limit (default: 1024) are now left as
<code>LongString</code> instances by default by the <code>DefaultMessagePropertiesConverter</code>.
You can access the contents through the <code>getBytes[]</code>, <code>toString()</code>, or <code>getStream()</code> methods.</p>
</div>
<div class="paragraph">
<p>Previously, the <code>DefaultMessagePropertiesConverter</code> &#8220;converted&#8221; such headers to a <code>DataInputStream</code> (actually it just referenced the <code>LongString</code> instance&#8217;s <code>DataInputStream</code>).
On output, this header was not converted (except to a String&#8201;&#8212;&#8201;for example, <code>java.io.DataInputStream@1d057a39</code> by calling <code>toString()</code> on the stream).</p>
</div>
<div class="paragraph">
<p>Large incoming <code>LongString</code> headers are now correctly &#8220;converted&#8221; on output, too (by default).</p>
</div>
<div class="paragraph">
<p>A new constructor is provided to let you configure the converter to work as before.
The following listing shows the Javadoc comment and declaration of the method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Construct an instance where LongStrings will be returned
 * unconverted or as a java.io.DataInputStream when longer than this limit.
 * Use this constructor with 'true' to restore pre-1.6 behavior.
 * @param longStringLimit the limit.
 * @param convertLongLongStrings LongString when false,
 * DataInputStream when true.
 * @since 1.6
 */
public DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also starting with version 1.6, a new property called <code>correlationIdString</code> has been added to <code>MessageProperties</code>.
Previously, when converting to and from <code>BasicProperties</code> used by the RabbitMQ client, an unnecessary <code>byte[] &lt;&#8594; String</code> conversion was performed because <code>MessageProperties.correlationId</code> is a <code>byte[]</code>, but <code>BasicProperties</code> uses a <code>String</code>.
(Ultimately, the RabbitMQ client uses UTF-8 to convert the <code>String</code> to bytes to put in the protocol message).</p>
</div>
<div class="paragraph">
<p>To provide maximum backwards compatibility, a new property called <code>correlationIdPolicy</code> has been added to the
<code>DefaultMessagePropertiesConverter</code>.
This takes a <code>DefaultMessagePropertiesConverter.CorrelationIdPolicy</code> enum argument.
By default it is set to <code>BYTES</code>, which replicates the previous behavior.</p>
</div>
<div class="paragraph">
<p>For inbound messages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>STRING</code>: Only the <code>correlationIdString</code> property is mapped</p>
</li>
<li>
<p><code>BYTES</code>: Only the <code>correlationId</code> property is mapped</p>
</li>
<li>
<p><code>BOTH</code>: Both properties are mapped</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For outbound messages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>STRING</code>: Only the <code>correlationIdString</code> property is mapped</p>
</li>
<li>
<p><code>BYTES</code>: Only the <code>correlationId</code> property is mapped</p>
</li>
<li>
<p><code>BOTH</code>: Both properties are considered, with the <code>String</code> property taking precedence</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also starting with version 1.6, the inbound <code>deliveryMode</code> property is no longer mapped to <code>MessageProperties.deliveryMode</code>.
It is mapped to <code>MessageProperties.receivedDeliveryMode</code> instead.
Also, the inbound <code>userId</code> property is no longer mapped to <code>MessageProperties.userId</code>.
It is mapped to <code>MessageProperties.receivedUserId</code> instead.
These changes are to avoid unexpected propagation of these properties if the same <code>MessageProperties</code> object is used for an outbound message.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-processing">3.1.9. Modifying Messages - Compression and More</h4>
<div class="paragraph">
<p>A number of extension points exist.
They let you perform some processing on a message, either before it is sent to RabbitMQ or immediately after it is received.</p>
</div>
<div class="paragraph">
<p>As can be seen in <a href="#message-converters">Message Converters</a>, one such extension point is in the <code>AmqpTemplate</code> <code>convertAndReceive</code> operations, where you can provide a <code>MessagePostProcessor</code>.
For example, after your POJO has been converted, the <code>MessagePostProcessor</code> lets you set custom headers or properties on the <code>Message</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4.2, additional extension points have been added to the <code>RabbitTemplate</code> - <code>setBeforePublishPostProcessors()</code> and <code>setAfterReceivePostProcessors()</code>.
The first enables a post processor to run immediately before sending to RabbitMQ.
When using batching (see <a href="#template-batching">Batching</a>), this is invoked after the batch is assembled and before the batch is sent.
The second is invoked immediately after a message is received.</p>
</div>
<div class="paragraph">
<p>These extension points are used for such features as compression and, for this purpose, several <code>MessagePostProcessor</code> implementations are provided.
<code>GZipPostProcessor</code> and <code>ZipPostProcessor</code> compress messages before sending, and <code>GUnzipPostProcessor</code> and <code>UnzipPostProcessor</code> decompress received messages.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 2.1.5, the <code>GZipPostProcessor</code> can be configured with the <code>copyProperties = true</code> option to make a  copy of the original message properties.
By default, these properties are reused for performance reasons, and modified with compression content encoding and the optional <code>MessageProperties.SPRING_AUTO_DECOMPRESS</code> header.
If you retain a reference to the original outbound message, its properties will change as well.
So, if your application retains a copy of an outbound message with these message post processors, consider turning the <code>copyProperties</code> option on.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, the <code>SimpleMessageListenerContainer</code> also has a <code>setAfterReceivePostProcessors()</code> method, letting the decompression be performed after messages are received by the container.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1.4, <code>addBeforePublishPostProcessors()</code> and <code>addAfterReceivePostProcessors()</code> have been added to the <code>RabbitTemplate</code> to allow appending new post processors to the list of before publish and after receive post processors respectively.
Also there are methods provided to remove the post processors.
Similarly, <code>AbstractMessageListenerContainer</code> also has <code>addAfterReceivePostProcessors()</code> and <code>removeAfterReceivePostProcessor()</code> methods added.
See the Javadoc of <code>RabbitTemplate</code> and <code>AbstractMessageListenerContainer</code> for more detail.</p>
</div>
</div>
<div class="sect3">
<h4 id="request-reply">3.1.10. Request/Reply Messaging</h4>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> also provides a variety of <code>sendAndReceive</code> methods that accept the same argument options that were described earlier for the one-way send operations (<code>exchange</code>, <code>routingKey</code>, and <code>Message</code>).
Those methods are quite useful for request-reply scenarios, since they handle the configuration of the necessary <code>reply-to</code> property before sending and can listen for the reply message on an exclusive queue that is created internally for that purpose.</p>
</div>
<div class="paragraph">
<p>Similar request-reply methods are also available where the <code>MessageConverter</code> is applied to both the request and reply.
Those methods are named <code>convertSendAndReceive</code>.
See the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/AmqpTemplate.html">Javadoc of <code>AmqpTemplate</code></a> for more detail.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5.0, each of the <code>sendAndReceive</code> method variants has an overloaded version that takes <code>CorrelationData</code>.
Together with a properly configured connection factory, this enables the receipt of publisher confirms for the send side of the operation.
See <a href="#template-confirms">Publisher Confirms and Returns</a> and the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/rabbit/core/RabbitOperations.html">Javadoc for <code>RabbitOperations</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, there are variants of these methods (<code>convertSendAndReceiveAsType</code>) that take an additional <code>ParameterizedTypeReference</code> argument to convert complex returned types.
The template must be configured with a <code>SmartMessageConverter</code>.
See <a href="#json-complex">Converting From a <code>Message</code> With <code>RabbitTemplate</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, you can configure the <code>RabbitTemplate</code> with the <code>noLocalReplyConsumer</code> option to control a <code>noLocal</code> flag for reply consumers.
This is <code>false</code> by default.</p>
</div>
<div class="sect4">
<h5 id="reply-timeout">Reply Timeout</h5>
<div class="paragraph">
<p>By default, the send and receive methods timeout after five seconds and return null.
You can modify this behavior by setting the <code>replyTimeout</code> property.
Starting with version 1.5, if you set the <code>mandatory</code> property to <code>true</code> (or the <code>mandatory-expression</code> evaluates to <code>true</code> for a particular message), if the message cannot be delivered to a queue, an <code>AmqpMessageReturnedException</code> is thrown.
This exception has <code>returnedMessage</code>, <code>replyCode</code>, and <code>replyText</code> properties, as well as the <code>exchange</code> and <code>routingKey</code> used for the send.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This feature uses publisher returns.
You can enable it by setting <code>publisherReturns</code> to <code>true</code> on the <code>CachingConnectionFactory</code> (see <a href="#cf-pub-conf-ret">Publisher Confirms and Returns</a>).
Also, you must not have registered your own <code>ReturnCallback</code> with the <code>RabbitTemplate</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.1.2, a <code>replyTimedOut</code> method has been added, letting subclasses be informed of the timeout so that they can clean up any retained state.</p>
</div>
<div class="paragraph">
<p>Starting with versions 2.0.11 and 2.1.3, when you use the default <code>DirectReplyToMessageListenerContainer</code>, you can add an error handler by setting the template&#8217;s <code>replyErrorHandler</code> property.
This error handler is invoked for any failed deliveries, such as late replies and messages received without a correlation header.
The exception passed in is a <code>ListenerExecutionFailedException</code>, which has a <code>failedMessage</code> property.</p>
</div>
</div>
<div class="sect4">
<h5 id="direct-reply-to">RabbitMQ Direct reply-to</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 3.4.0, the RabbitMQ server supports <a href="https://www.rabbitmq.com/direct-reply-to.html">direct reply-to</a>.
This eliminates the main reason for a fixed reply queue (to avoid the need to create a temporary queue for each request).
Starting with Spring AMQP version 1.4.1 direct reply-to is used by default (if supported by the server) instead of creating temporary reply queues.
When no <code>replyQueue</code> is provided (or it is set with a name of <code>amq.rabbitmq.reply-to</code>), the <code>RabbitTemplate</code> automatically detects whether direct reply-to is supported and either uses it or falls back to using a temporary reply queue.
When using direct reply-to, a <code>reply-listener</code> is not required and should not be configured.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reply listeners are still supported with named queues (other than <code>amq.rabbitmq.reply-to</code>), allowing control of reply concurrency and so on.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6, if you wish to use a temporary, exclusive, auto-delete queue for each
reply, set the <code>useTemporaryReplyQueues</code> property to <code>true</code>.
This property is ignored if you set a <code>replyAddress</code>.</p>
</div>
<div class="paragraph">
<p>You can change the criteria that dictate whether to use direct reply-to by subclassing <code>RabbitTemplate</code> and overriding <code>useDirectReplyTo()</code> to check different criteria.
The method is called once only, when the first request is sent.</p>
</div>
<div class="paragraph">
<p>Prior to version 2.0, the <code>RabbitTemplate</code> created a new consumer for each request and canceled the consumer when the reply was received (or timed out).
Now the template uses a <code>DirectReplyToMessageListenerContainer</code> instead, letting the consumers be reused.
The template still takes care of correlating the replies, so there is no danger of a late reply going to a different sender.
If you want to revert to the previous behavior, set the <code>useDirectReplyToContainer</code> (<code>direct-reply-to-container</code> when using XML configuration) property to false.</p>
</div>
<div class="paragraph">
<p>The <code>AsyncRabbitTemplate</code> has no such option.
It always used a <code>DirectReplyToContainer</code> for replies when direct reply-to is used.</p>
</div>
</div>
<div class="sect4">
<h5 id="_message_correlation_with_a_reply_queue">Message Correlation With A Reply Queue</h5>
<div class="paragraph">
<p>When using a fixed reply queue (other than <code>amq.rabbitmq.reply-to</code>), you must provide correlation data so that replies can be correlated to requests.
See <a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html">RabbitMQ Remote Procedure Call (RPC)</a>.
By default, the standard <code>correlationId</code> property is used to hold the correlation data.
However, if you wish to use a custom property to hold correlation data, you can set the <code>correlation-key</code> attribute on the &lt;rabbit-template/&gt;.
Explicitly setting the attribute to <code>correlationId</code> is the same as omitting the attribute.
The client and server must use the same header for correlation data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring AMQP version 1.1 used a custom property called <code>spring_reply_correlation</code> for this data.
If you wish to revert to this behavior with the current version (perhaps to maintain compatibility with another application using 1.1), you must set the attribute to <code>spring_reply_correlation</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the template generates its own correlation ID (ignoring any user-supplied value).
If you wish to use your own correlation ID, set the <code>RabbitTemplate</code> instance&#8217;s <code>userCorrelationId</code> property to <code>true</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The correlation ID must be unique to avoid the possibility of a wrong reply being returned for a request.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reply-listener">Reply Listener Container</h5>
<div class="paragraph">
<p>When using RabbitMQ versions prior to 3.4.0, a new temporary queue is used for each reply.
However, a single reply queue can be configured on the template, which can be more efficient and also lets you set arguments on that queue.
In this case, however, you must also provide a &lt;reply-listener/&gt; sub element.
This element provides a listener container for the reply queue, with the template being the listener.
All of the <a href="#containerAttributes">Message Listener Container Configuration</a> attributes allowed on a &lt;listener-container/&gt; are allowed on the element, except for <code>connection-factory</code> and <code>message-converter</code>, which are inherited from the template&#8217;s configuration.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you run multiple instances of your application or use multiple <code>RabbitTemplate</code> instances, you <strong>MUST</strong> use a unique reply queue for each.
RabbitMQ has no ability to select messages from a queue, so, if they all use the samequ eue, each instance would compete for replies and not necessarily receive their own.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example defines a rabbit template with a connection factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:template id="amqpTemplate"
        connection-factory="connectionFactory"
        reply-queue="replies"
        reply-address="replyEx/routeReply"&gt;
    &lt;rabbit:reply-listener/&gt;
&lt;/rabbit:template&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>While the container and template share a connection factory, they do not share a channel.
Therefore, requests and replies are not performed within the same transaction (if transactional).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Prior to version 1.5.0, the <code>reply-address</code> attribute was not available.
Replies were always routed by using the default exchange and the <code>reply-queue</code> name as the routing key.
This is still the default, but you can now specify the new <code>reply-address</code> attribute.
The <code>reply-address</code> can contain an address with the form <code>&lt;exchange&gt;/&lt;routingKey&gt;</code> and the reply is routed to the specified exchange and routed to a queue bound with the routing key.
The <code>reply-address</code> has precedence over <code>reply-queue</code>.
When only <code>reply-address</code> is in use, the <code>&lt;reply-listener&gt;</code> must be configured as a separate <code>&lt;listener-container&gt;</code> component.
The <code>reply-address</code> and <code>reply-queue</code> (or <code>queues</code> attribute on the <code>&lt;listener-container&gt;</code>) must refer to the same queue logically.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With this configuration, a <code>SimpleListenerContainer</code> is used to receive the replies, with the <code>RabbitTemplate</code> being the <code>MessageListener</code>.
When defining a template with the <code>&lt;rabbit:template/&gt;</code> namespace element, as shown in the preceding example, the parser defines the container and wires in the template as the listener.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When the template does not use a fixed <code>replyQueue</code> (or is using direct reply-to&#8201;&#8212;&#8201;see <a href="#direct-reply-to">RabbitMQ Direct reply-to</a>), a listener container is not needed.
Direct <code>reply-to</code> is the preferred mechanism when using RabbitMQ 3.4.0 or later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you define your <code>RabbitTemplate</code> as a <code>&lt;bean/&gt;</code> or use an <code>@Configuration</code> class to define it as an <code>@Bean</code> or when you create the template programmatically, you need to define and wire up the reply listener container yourself.
If you fail to do this, the template never receives the replies and eventually times out and returns null as the reply to a call to a <code>sendAndReceive</code> method.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.5, the <code>RabbitTemplate</code> detects if it has been
configured as a <code>MessageListener</code> to receive replies.
If not, attempts to send and receive messages with a reply address
fail with an <code>IllegalStateException</code> (because the replies are never received).</p>
</div>
<div class="paragraph">
<p>Further, if a simple <code>replyAddress</code> (queue name) is used, the reply listener container verifies that it is listening
to a queue with the same name.
This check cannot be performed if the reply address is an exchange and routing key and a debug log message is written.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When wiring the reply listener and template yourself, it is important to ensure that the template&#8217;s <code>replyAddress</code> and the container&#8217;s <code>queues</code> (or <code>queueNames</code>) properties refer to the same queue.
The template inserts the reply address into the outbound message <code>replyTo</code> property.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following listing shows examples of how to manually wire up the beans:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="amqpTemplate" class="org.springframework.amqp.rabbit.core.RabbitTemplate"&gt;
    &lt;constructor-arg ref="connectionFactory" /&gt;
    &lt;property name="exchange" value="foo.exchange" /&gt;
    &lt;property name="routingKey" value="foo" /&gt;
    &lt;property name="replyQueue" ref="replyQ" /&gt;
    &lt;property name="replyTimeout" value="600000" /&gt;
    &lt;property name="useDirectReplyToContainer" value="false" /&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer"&gt;
    &lt;constructor-arg ref="connectionFactory" /&gt;
    &lt;property name="queues" ref="replyQ" /&gt;
    &lt;property name="messageListener" ref="amqpTemplate" /&gt;
&lt;/bean&gt;

&lt;rabbit:queue id="replyQ" name="my.reply.queue" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Bean
    public RabbitTemplate amqpTemplate() {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());
        rabbitTemplate.setMessageConverter(msgConv());
        rabbitTemplate.setReplyAddress(replyQueue().getName());
        rabbitTemplate.setReplyTimeout(60000);
        rabbitTemplate.setUseDirectReplyToContainer(false);
        return rabbitTemplate;
    }

    @Bean
    public SimpleMessageListenerContainer replyListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory());
        container.setQueues(replyQueue());
        container.setMessageListener(amqpTemplate());
        return container;
    }

    @Bean
    public Queue replyQueue() {
        return new Queue("my.reply.queue");
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A complete example of a <code>RabbitTemplate</code> wired with a fixed reply queue, together with a &#8220;remote&#8221; listener container that handles the request and returns the reply is shown in <a href="https://github.com/spring-projects/spring-amqp/tree/master/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/listener/JavaConfigFixedReplyQueueTests.java">this test case</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When the reply times out (<code>replyTimeout</code>), the <code>sendAndReceive()</code> methods return null.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Prior to version 1.3.6, late replies for timed out messages were only logged.
Now, if a late reply is received, it is rejected (the template throws an <code>AmqpRejectAndDontRequeueException</code>).
If the reply queue is configured to send rejected messages to a dead letter exchange, the reply can be retrieved for later analysis.
To do so, bind a queue to the configured dead letter exchange with a routing key equal to the reply queue&#8217;s name.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://www.rabbitmq.com/dlx.html">RabbitMQ Dead Letter Documentation</a> for more information about configuring dead lettering.
You can also take a look at the <code>FixedReplyQueueDeadLetterTests</code> test case for an example.</p>
</div>
</div>
<div class="sect4">
<h5 id="async-template"><code>AsyncRabbitTemplate</code></h5>
<div class="paragraph">
<p>Version 1.6 introduced the <code>AsyncRabbitTemplate</code>.
This has similar <code>sendAndReceive</code> (and <code>convertSendAndReceive</code>) methods to those on the <a href="#amqp-template"><code>AmqpTemplate</code></a>.
However, instead of blocking, they return a <code>ListenableFuture</code>.</p>
</div>
<div class="paragraph">
<p>The <code>sendAndReceive</code> methods return a <code>RabbitMessageFuture</code>.
The <code>convertSendAndReceive</code> methods return a <code>RabbitConverterFuture</code>.</p>
</div>
<div class="paragraph">
<p>You can either synchronously retrieve the result later, by invoking <code>get()</code> on the future, or you can register a callback that is called asynchronously with the result.
The following listing shows both approaches:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private AsyncRabbitTemplate template;

...

public void doSomeWorkAndGetResultLater() {

    ...

    ListenableFuture&lt;String&gt; future = this.template.convertSendAndReceive("foo");

    // do some more work

    String reply = null;
    try {
        reply = future.get();
    }
    catch (ExecutionException e) {
        ...
    }

    ...

}

public void doSomeWorkAndGetResultAsync() {

    ...

    RabbitConverterFuture&lt;String&gt; future = this.template.convertSendAndReceive("foo");
    future.addCallback(new ListenableFutureCallback&lt;String&gt;() {

        @Override
        public void onSuccess(String result) {
            ...
        }

        @Override
        public void onFailure(Throwable ex) {
            ...
        }

    });

    ...

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If <code>mandatory</code> is set and the message cannot be delivered, the future throws an <code>ExecutionException</code> with a cause of <code>AmqpMessageReturnedException</code>, which encapsulates the returned message and information about the return.</p>
</div>
<div class="paragraph">
<p>If <code>enableConfirms</code> is set, the future has a property called <code>confirm</code>, which is itself a <code>ListenableFuture&lt;Boolean&gt;</code> with <code>true</code> indicating a successful publish.
If the confirm future is <code>false</code>, the <code>RabbitFuture</code> has a further property called <code>nackCause</code>, which contains the reason for the failure, if available.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The publisher confirm is discarded if it is received after the reply, since the reply implies a successful publish.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can set the <code>receiveTimeout</code> property on the template to time out replies (it defaults to <code>30000</code> - 30 seconds).
If a timeout occurs, the future is completed with an <code>AmqpReplyTimeoutException</code>.</p>
</div>
<div class="paragraph">
<p>The template implements <code>SmartLifecycle</code>.
Stopping the template while there are pending replies causes the pending <code>Future</code> instances to be canceled.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the asynchronous template now supports <a href="https://www.rabbitmq.com/direct-reply-to.html">direct reply-to</a> instead of a configured reply queue.
To enable this feature, use one of the following constructors:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public AsyncRabbitTemplate(ConnectionFactory connectionFactory, String exchange, String routingKey)

public AsyncRabbitTemplate(RabbitTemplate template)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#direct-reply-to">RabbitMQ Direct reply-to</a> to use direct reply-to with the synchronous <code>RabbitTemplate</code>.</p>
</div>
<div class="paragraph">
<p>Version 2.0 introduced variants of these methods (<code>convertSendAndReceiveAsType</code>) that take an additional <code>ParameterizedTypeReference</code> argument to convert complex returned types.
You must configure the underlying <code>RabbitTemplate</code> with a <code>SmartMessageConverter</code>.
See <a href="#json-complex">Converting From a <code>Message</code> With <code>RabbitTemplate</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="remoting">Spring Remoting with AMQP</h5>
<div class="paragraph">
<p>The Spring Framework has a general remoting capability, allowing <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/remoting.html">Remote Procedure Calls (RPC)</a> that use various transports.
Spring-AMQP supports a similar mechanism with a <code>AmqpProxyFactoryBean</code> on the client and a <code>AmqpInvokerServiceExporter</code> on the server.
This provides RPC over AMQP.
On the client side, a <code>RabbitTemplate</code> is used as described <a href="#reply-listener">earlier</a>.
On the server side, the invoker (configured as a <code>MessageListener</code>) receives the message, invokes the configured service, and returns the reply by using the inbound message&#8217;s <code>replyTo</code> information.</p>
</div>
<div class="paragraph">
<p>You can inject the client factory bean into any bean (by using its <code>serviceInterface</code>).
The client can then invoke methods on the proxy, resulting in remote execution over AMQP.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With the default <code>MessageConverter</code> instances, the method parameters and returned value must be instances of <code>Serializable</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the server side, the <code>AmqpInvokerServiceExporter</code> has both <code>AmqpTemplate</code> and <code>MessageConverter</code> properties.
Currently, the template&#8217;s <code>MessageConverter</code> is not used.
If you need to supply a custom message converter, you should provide it by setting the <code>messageConverter</code> property.
On the client side, you can add a custom message converter to the <code>AmqpTemplate</code>, which is provided to the <code>AmqpProxyFactoryBean</code> by using its <code>amqpTemplate</code> property.</p>
</div>
<div class="paragraph">
<p>The following listing shows sample client and server configurations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="client"
	class="org.springframework.amqp.remoting.client.AmqpProxyFactoryBean"&gt;
	&lt;property name="amqpTemplate" ref="template" /&gt;
	&lt;property name="serviceInterface" value="foo.ServiceInterface" /&gt;
&lt;/bean&gt;

&lt;rabbit:connection-factory id="connectionFactory" /&gt;

&lt;rabbit:template id="template" connection-factory="connectionFactory" reply-timeout="2000"
	routing-key="remoting.binding" exchange="remoting.exchange" /&gt;

&lt;rabbit:admin connection-factory="connectionFactory" /&gt;

&lt;rabbit:queue name="remoting.queue" /&gt;

&lt;rabbit:direct-exchange name="remoting.exchange"&gt;
	&lt;rabbit:bindings&gt;
		&lt;rabbit:binding queue="remoting.queue" key="remoting.binding" /&gt;
	&lt;/rabbit:bindings&gt;
&lt;/rabbit:direct-exchange&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="listener"
	class="org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter"&gt;
	&lt;property name="serviceInterface" value="foo.ServiceInterface" /&gt;
	&lt;property name="service" ref="service" /&gt;
	&lt;property name="amqpTemplate" ref="template" /&gt;
&lt;/bean&gt;

&lt;bean id="service" class="foo.ServiceImpl" /&gt;

&lt;rabbit:connection-factory id="connectionFactory" /&gt;

&lt;rabbit:template id="template" connection-factory="connectionFactory" /&gt;

&lt;rabbit:queue name="remoting.queue" /&gt;

&lt;rabbit:listener-container connection-factory="connectionFactory"&gt;
	&lt;rabbit:listener ref="listener" queue-names="remoting.queue" /&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>AmqpInvokerServiceExporter</code> can process only properly formed messages, such as those sent from the <code>AmqpProxyFactoryBean</code>.
If it receives a message that it cannot interpret, a serialized <code>RuntimeException</code> is sent as a reply.
If the message has no <code>replyToAddress</code> property, the message is rejected and permanently lost if no dead letter exchange has been configured.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, if the request message cannot be delivered, the calling thread eventually times out and a <code>RemoteProxyFailureException</code> is thrown.
By default, the timeout is five seconds.
You can modify that duration by setting the <code>replyTimeout</code> property on the <code>RabbitTemplate</code>.
Starting with version 1.5, by setting the <code>mandatory</code> property to <code>true</code> and enabling returns on the connection factory (see <a href="#cf-pub-conf-ret">Publisher Confirms and Returns</a>), the calling thread throws an <code>AmqpMessageReturnedException</code>.
See <a href="#reply-timeout">Reply Timeout</a> for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="broker-configuration">3.1.11. Configuring the Broker</h4>
<div class="paragraph">
<p>The AMQP specification describes how the protocol can be used to configure queues, exchanges, and bindings on the broker.
These operations (which are portable from the 0.8 specification and higher) are present in the <code>AmqpAdmin</code> interface in the <code>org.springframework.amqp.core</code> package.
The RabbitMQ implementation of that class is <code>RabbitAdmin</code> located in the <code>org.springframework.amqp.rabbit.core</code> package.</p>
</div>
<div class="paragraph">
<p>The <code>AmqpAdmin</code> interface is based on using the Spring AMQP domain abstractions and is shown in the follwoing listing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface AmqpAdmin {

    // Exchange Operations

    void declareExchange(Exchange exchange);

    void deleteExchange(String exchangeName);

    // Queue Operations

    Queue declareQueue();

    String declareQueue(Queue queue);

    void deleteQueue(String queueName);

    void deleteQueue(String queueName, boolean unused, boolean empty);

    void purgeQueue(String queueName, boolean noWait);

    // Binding Operations

    void declareBinding(Binding binding);

    void removeBinding(Binding binding);

    Properties getQueueProperties(String queueName);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#scoped-operations">Scoped Operations</a>.</p>
</div>
<div class="paragraph">
<p>The <code>getQueueProperties()</code> method returns some limited information about the queue (message count and consumer count).
The keys for the properties returned are available as constants in the <code>RabbitTemplate</code> (<code>QUEUE_NAME</code>,
<code>QUEUE_MESSAGE_COUNT</code>, and <code>QUEUE_CONSUMER_COUNT</code>).
The <a href="#management-rest-api">RabbitMQ REST API</a> provides much more information in the <code>QueueInfo</code> object.</p>
</div>
<div class="paragraph">
<p>The no-arg <code>declareQueue()</code> method defines a queue on the broker with a name that is automatically generated.
The additional properties of this auto-generated queue are <code>exclusive=true</code>, <code>autoDelete=true</code>, and <code>durable=false</code>.</p>
</div>
<div class="paragraph">
<p>The <code>declareQueue(Queue queue)</code> method takes a <code>Queue</code> object and returns the name of the declared queue.
If the <code>name</code> property of the provided <code>Queue</code> is an empty <code>String</code>, the broker declares the queue with a generated name.
That name is returned to the caller.
That name is also added to the <code>actualName</code> property of the <code>Queue</code>.
You can use this functionality programmatically only by invoking the <code>RabbitAdmin</code> directly.
When using auto-declaration by the admin when defining a queue declaratively in the application context, you can set the name property to <code>""</code> (the empty string).
The broker then creates the name.
Starting with version 2.1, listener containers can use queues of this type.
See <a href="#containers-and-broker-named-queues">Containers and Broker-Named queues</a> for more information.</p>
</div>
<div class="paragraph">
<p>This is in contrast to an <code>AnonymousQueue</code> where the framework generates a unique (<code>UUID</code>) name and sets <code>durable</code> to
<code>false</code> and <code>exclusive</code>, <code>autoDelete</code> to <code>true</code>.
A <code>&lt;rabbit:queue/&gt;</code> with an empty (or missing) <code>name</code> attribute always creates an <code>AnonymousQueue</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#anonymous-queue"><code>AnonymousQueue</code></a> to understand why <code>AnonymousQueue</code> is preferred over broker-generated queue names as well as
how to control the format of the name.
Starting with version 2.1, anonymous queues are declared with argument <code>x-queue-master-locator</code> set to <code>client-local</code> by default.
This ensures that the queue is declared on the node to which the application is connected.
Declarative queues must have fixed names because they might be referenced elsewhere in the context&#8201;&#8212;&#8201;such as in the
listener shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:listener-container&gt;
    &lt;rabbit:listener ref="listener" queue-names="#{someQueue.name}" /&gt;
&lt;/rabbit:listener-container&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#automatic-declaration">Automatic Declaration of Exchanges, Queues, and Bindings</a>.</p>
</div>
<div class="paragraph">
<p>The RabbitMQ implementation of this interface is <code>RabbitAdmin</code>, which, when configured by using Spring XML, resembles the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:connection-factory id="connectionFactory"/&gt;

&lt;rabbit:admin id="amqpAdmin" connection-factory="connectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the <code>CachingConnectionFactory</code> cache mode is <code>CHANNEL</code> (the default), the <code>RabbitAdmin</code> implementation does automatic lazy declaration of queues, exchanges, and bindings declared in the same <code>ApplicationContext</code>.
These components are declared as soon as a <code>Connection</code> is opened to the broker.
There are some namespace features that make this very convenient&#8201;&#8212;&#8201;for example,
in the Stocks sample application, we have the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue id="tradeQueue"/&gt;

&lt;rabbit:queue id="marketDataQueue"/&gt;

&lt;fanout-exchange name="broadcast.responses"
                 xmlns="http://www.springframework.org/schema/rabbit"&gt;
    &lt;bindings&gt;
        &lt;binding queue="tradeQueue"/&gt;
    &lt;/bindings&gt;
&lt;/fanout-exchange&gt;

&lt;topic-exchange name="app.stock.marketdata"
                xmlns="http://www.springframework.org/schema/rabbit"&gt;
    &lt;bindings&gt;
        &lt;binding queue="marketDataQueue" pattern="${stocks.quote.pattern}"/&gt;
    &lt;/bindings&gt;
&lt;/topic-exchange&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we use anonymous queues (actually, internally, just queues with names generated by the framework, not by the broker) and refer to them by ID.
We can also declare queues with explicit names, which also serve as identifiers for their bean definitions in the context.
The following example configures a queue with an explicit name:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue name="stocks.trade.queue"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can provide both <code>id</code> and <code>name</code> attributes.
This lets you refer to the queue (for example, in a binding) by an ID that is independent of the queue name.
It also allows standard Spring features (such as property placeholders and SpEL expressions for the queue name).
These features are not available when you use the name as the bean identifier.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Queues can be configured with additional arguments&#8201;&#8212;&#8201;for example, <code>x-message-ttl</code>.
When you use the namespace support, they are provided in the form of a <code>Map</code> of argument-name/argument-value pairs, which are defined by using the <code>&lt;rabbit:queue-arguments&gt;</code> element.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue name="withArguments"&gt;
    &lt;rabbit:queue-arguments&gt;
        &lt;entry key="x-dead-letter-exchange" value="myDLX"/&gt;
        &lt;entry key="x-dead-letter-routing-key" value="dlqRK"/&gt;
    &lt;/rabbit:queue-arguments&gt;
&lt;/rabbit:queue&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the arguments are assumed to be strings.
For arguments of other types, you must provide the type.
The following example shows how to specify the type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue name="withArguments"&gt;
    &lt;rabbit:queue-arguments value-type="java.lang.Long"&gt;
        &lt;entry key="x-message-ttl" value="100"/&gt;
    &lt;/rabbit:queue-arguments&gt;
&lt;/rabbit:queue&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When providing arguments of mixed types, you must provide the type for each entry element.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue name="withArguments"&gt;
    &lt;rabbit:queue-arguments&gt;
        &lt;entry key="x-message-ttl"&gt;
            &lt;value type="java.lang.Long"&gt;100&lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry key="x-dead-letter-exchange" value="myDLX"/&gt;
        &lt;entry key="x-dead-letter-routing-key" value="dlqRK"/&gt;
    &lt;/rabbit:queue-arguments&gt;
&lt;/rabbit:queue&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With Spring Framework 3.2 and later, this can be declared a little more succinctly, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue name="withArguments"&gt;
    &lt;rabbit:queue-arguments&gt;
        &lt;entry key="x-message-ttl" value="100" value-type="java.lang.Long"/&gt;
        &lt;entry key="x-ha-policy" value="all"/&gt;
    &lt;/rabbit:queue-arguments&gt;
&lt;/rabbit:queue&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use Java configuration, the <code>x-queue-master-locator</code> is supported as a first class property through the <code>setMasterLocator()</code> method on the <code>Queue</code> class.
Starting with version 2.1, anonymous queues are declared with this property set to <code>client-local</code> by default.
This ensures that the queue is declared on the node the application is connected to.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The RabbitMQ broker does not allow declaration of a queue with mismatched arguments.
For example, if a <code>queue</code> already exists with no <code>time to live</code> argument, and you attempt to declare it with (for example) <code>key="x-message-ttl" value="100"</code>, an exception is thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the <code>RabbitAdmin</code> immediately stops processing all declarations when any exception occurs.
This could cause downstream issues, such as a listener container failing to initialize because another queue (defined after the one in error) is not declared.</p>
</div>
<div class="paragraph">
<p>This behavior can be modified by setting the <code>ignore-declaration-exceptions</code> attribute to <code>true</code> on the <code>RabbitAdmin</code> instance.
This option instructs the <code>RabbitAdmin</code> to log the exception and continue declaring other elements.
When configuring the <code>RabbitAdmin</code> using Java, this property is called <code>ignoreDeclarationExceptions</code>.
This is a global setting that applies to all elements.
Queues, exchanges, and bindings have a similar property that applies to just those elements.</p>
</div>
<div class="paragraph">
<p>Prior to version 1.6, this property took effect only if an <code>IOException</code> occurred on the channel, such as when there is a mismatch between current and desired properties.
Now, this property takes effect on any exception, including <code>TimeoutException</code> and others.</p>
</div>
<div class="paragraph">
<p>In addition, any declaration exceptions result in the publishing of a <code>DeclarationExceptionEvent</code>, which is an <code>ApplicationEvent</code> that can be consumed by any <code>ApplicationListener</code> in the context.
The event contains a reference to the admin, the element that was being declared, and the <code>Throwable</code>.</p>
</div>
<div class="sect4">
<h5 id="headers-exchange">Headers Exchange</h5>
<div class="paragraph">
<p>Starting with version 1.3, you can configure the <code>HeadersExchange</code> to match on multiple headers.
You can also specify whether any or all headers must match.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:headers-exchange name="headers-test"&gt;
    &lt;rabbit:bindings&gt;
        &lt;rabbit:binding queue="bucket"&gt;
            &lt;rabbit:binding-arguments&gt;
                &lt;entry key="foo" value="bar"/&gt;
                &lt;entry key="baz" value="qux"/&gt;
                &lt;entry key="x-match" value="all"/&gt;
            &lt;/rabbit:binding-arguments&gt;
        &lt;/rabbit:binding&gt;
    &lt;/rabbit:bindings&gt;
&lt;/rabbit:headers-exchange&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 1.6, you can configure <code>Exchanges</code> with an <code>internal</code> flag (defaults to <code>false</code>) and such an
<code>Exchange</code> is properly configured on the Broker through a <code>RabbitAdmin</code> (if one is present in the application context).
If the <code>internal</code> flag is <code>true</code> for an exchange, RabbitMQ does not let clients use the exchange.
This is useful for a dead letter exchange or exchange-to-exchange binding, where you do not wish the exchange to be used
directly by publishers.</p>
</div>
<div class="paragraph">
<p>To see how to use Java to configure the AMQP infrastructure, look at the Stock sample application,
where there is the <code>@Configuration</code> class <code>AbstractStockRabbitConfiguration</code>, which ,in turn has
<code>RabbitClientConfiguration</code> and <code>RabbitServerConfiguration</code> subclasses.
The following listing shows the code for <code>AbstractStockRabbitConfiguration</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public abstract class AbstractStockAppRabbitConfiguration {

    @Bean
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory =
            new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public RabbitTemplate rabbitTemplate() {
        RabbitTemplate template = new RabbitTemplate(connectionFactory());
        template.setMessageConverter(jsonMessageConverter());
        configureRabbitTemplate(template);
        return template;
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public TopicExchange marketDataExchange() {
        return new TopicExchange("app.stock.marketdata");
    }

    // additional code omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the Stock application, the server is configured by using the following <code>@Configuration</code> class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class RabbitServerConfiguration extends AbstractStockAppRabbitConfiguration  {

    @Bean
    public Queue stockRequestQueue() {
        return new Queue("app.stock.request");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is the end of the whole inheritance chain of <code>@Configuration</code> classes.
The end result is that <code>TopicExchange</code> and <code>Queue</code> are declared to the broker upon application startup.
There is no binding of  <code>TopicExchange</code> to a queue in the server configuration, as that is done in the client application.
The stock request queue, however, is automatically bound to the AMQP default exchange.
This behavior is defined by the specification.</p>
</div>
<div class="paragraph">
<p>The client <code>@Configuration</code> class is a little more interesting.
Its declaration follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class RabbitClientConfiguration extends AbstractStockAppRabbitConfiguration {

    @Value("${stocks.quote.pattern}")
    private String marketDataRoutingKey;

    @Bean
    public Queue marketDataQueue() {
        return amqpAdmin().declareQueue();
    }

    /**
     * Binds to the market data exchange.
     * Interested in any stock quotes
     * that match its routing key.
     */
    @Bean
    public Binding marketDataBinding() {
        return BindingBuilder.bind(
                marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
    }

    // additional code omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The client declares another queue through the <code>declareQueue()</code> method on the <code>AmqpAdmin</code>.
It binds that queue to the market data exchange with a routing pattern that is externalized in a properties file.</p>
</div>
</div>
<div class="sect4">
<h5 id="builder-api">Builder API for Queues and Exchanges</h5>
<div class="paragraph">
<p>Version 1.6 introduces a convenient fluent API for configuring <code>Queue</code> and <code>Exchange</code> objects when using Java configuration.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue queue() {
    return QueueBuilder.nonDurable("foo")
        .autoDelete()
        .exclusive()
        .withArgument("foo", "bar")
        .build();
}

@Bean
public Exchange exchange() {
  return ExchangeBuilder.directExchange("foo")
      .autoDelete()
      .internal()
      .withArgument("foo", "bar")
      .build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the Javadoc for <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/QueueBuilder.html"><code>org.springframework.amqp.core.QueueBuilder</code></a> and <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/ExchangeBuilder.html"><code>org.springframework.amqp.core.ExchangeBuilder</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>ExchangeBuilder</code> now creates durable exchanges by default, to be consistent with the simple constructors on the individual <code>AbstractExchange</code> classes.
To make a non-durable exchange with the builder, use <code>.durable(false)</code> before invoking <code>.build()</code>.
The <code>durable()</code> method with no parameter is no longer provided.</p>
</div>
</div>
<div class="sect4">
<h5 id="collection-declaration">Declaring Collections of Exchanges, Queues, and Bindings</h5>
<div class="paragraph">
<p>You can wrap collections of <code>Declarable</code> objects (<code>Queue</code>, <code>Exchange</code>, and <code>Binding</code>) in <code>Declarables</code> objects.
The <code>RabbitAdmin</code> detects such beans (as well as discrete <code>Declarable</code> beans) in the application context, and declares the contained objects on the broker whenever a connection is established (initially and after a connection failure).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public static class Config {

    @Bean
    public ConnectionFactory cf() {
        return new CachingConnectionFactory("localhost");
    }

    @Bean
    public RabbitAdmin admin(ConnectionFactory cf) {
        return new RabbitAdmin(cf);
    }

    @Bean
    public DirectExchange e1() {
    	return new DirectExchange("e1", false, true);
    }

    @Bean
    public Queue q1() {
    	return new Queue("q1", false, false, true);
    }

    @Bean
    public Binding b1() {
    	return BindingBuilder.bind(q1()).to(e1()).with("k1");
    }

    @Bean
    public Declarables es() {
        return new Declarables(
                new DirectExchange("e2", false, true),
                new DirectExchange("e3", false, true));
    }

    @Bean
    public Declarables qs() {
        return new Declarables(
                new Queue("q2", false, false, true),
                new Queue("q3", false, false, true));
    }

    @Bean
    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    public Declarables prototypes() {
        return new Declarables(new Queue(this.prototypeQueueName, false, false, true));
    }

    @Bean
    public Declarables bs() {
        return new Declarables(
                new Binding("q2", DestinationType.QUEUE, "e2", "k2", null),
                new Binding("q3", DestinationType.QUEUE, "e3", "k3", null));
    }

    @Bean
    public Declarables ds() {
        return new Declarables(
                new DirectExchange("e4", false, true),
                new Queue("q4", false, false, true),
                new Binding("q4", DestinationType.QUEUE, "e4", "k4", null));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In versions prior to 2.1, you could declare multiple <code>Declarable</code> instances by defining beans of type <code>Collection&lt;Declarable&gt;</code>.
This can cause undesirable side effects in some cases, because the admin has to iterate over all <code>Collection&lt;?&gt;</code> beans.
This feature is now disabled in favor of <code>Declarables</code>, as discussed earlier in this section.
You can revert to the previous behavior by setting the <code>RabbitAdmin</code> property called <code>declareCollections</code> to <code>true</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="conditional-declaration">Conditional Declaration</h5>
<div class="paragraph">
<p>By default, all queues, exchanges, and bindings are declared by all <code>RabbitAdmin</code> instances (assuming they have <code>auto-startup="true"</code>) in the application context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with the 1.2 release, you can conditionally declare these elements.
This is particularly useful when an application connects to multiple brokers and needs to specify with which brokers a particular element should be declared.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The classes representing these elements implement <code>Declarable</code>, which has two methods: <code>shouldDeclare()</code> and <code>getDeclaringAdmins()</code>.
The <code>RabbitAdmin</code> uses these methods to determine whether a particular instance should actually process the declarations on its <code>Connection</code>.</p>
</div>
<div class="paragraph">
<p>The properties are available as attributes in the namespace, as shown in the following examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:admin id="admin1" connection-factory="CF1" /&gt;

&lt;rabbit:admin id="admin2" connection-factory="CF2" /&gt;

&lt;rabbit:queue id="declaredByBothAdminsImplicitly" /&gt;

&lt;rabbit:queue id="declaredByBothAdmins" declared-by="admin1, admin2" /&gt;

&lt;rabbit:queue id="declaredByAdmin1Only" declared-by="admin1" /&gt;

&lt;rabbit:queue id="notDeclaredByAny" auto-declare="false" /&gt;

&lt;rabbit:direct-exchange name="direct" declared-by="admin1, admin2"&gt;
	&lt;rabbit:bindings&gt;
		&lt;rabbit:binding key="foo" queue="bar"/&gt;
	&lt;/rabbit:bindings&gt;
&lt;/rabbit:direct-exchange&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, the <code>auto-declare</code> attribute is <code>true</code> and, if the <code>declared-by</code> is not supplied (or is empty), then all <code>RabbitAdmin</code> instances declare the object (as long as the admin&#8217;s <code>auto-startup</code> attribute is <code>true</code>, the default).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, you can use Java-based <code>@Configuration</code> to achieve the same effect.
In the following example, the components are declared by <code>admin1</code> but not by`admin2`:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RabbitAdmin admin() {
    RabbitAdmin rabbitAdmin = new RabbitAdmin(cf1());
    rabbitAdmin.afterPropertiesSet();
    return rabbitAdmin;
}

@Bean
public RabbitAdmin admin2() {
    RabbitAdmin rabbitAdmin = new RabbitAdmin(cf2());
    rabbitAdmin.afterPropertiesSet();
    return rabbitAdmin;
}

@Bean
public Queue queue() {
    Queue queue = new Queue("foo");
    queue.setAdminsThatShouldDeclare(admin());
    return queue;
}

@Bean
public Exchange exchange() {
    DirectExchange exchange = new DirectExchange("bar");
    exchange.setAdminsThatShouldDeclare(admin());
    return exchange;
}

@Bean
public Binding binding() {
    Binding binding = new Binding("foo", DestinationType.QUEUE, exchange().getName(), "foo", null);
    binding.setAdminsThatShouldDeclare(admin());
    return binding;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="note-id-name">A Note On the <code>id</code> and <code>name</code> Attributes</h5>
<div class="paragraph">
<p>The <code>name</code> attribute on <code>&lt;rabbit:queue/&gt;</code> and <code>&lt;rabbit:exchange/&gt;</code> elements reflects the name of the entity in the broker.
For queues, if the <code>name</code> is omitted, an anonymous queue is created (see <a href="#anonymous-queue"><code>AnonymousQueue</code></a>).</p>
</div>
<div class="paragraph">
<p>In versions prior to 2.0, the <code>name</code> was also registered as a bean name alias (similar to <code>name</code> on <code>&lt;bean/&gt;</code> elements).</p>
</div>
<div class="paragraph">
<p>This caused two problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It prevented the declaration of a queue and exchange with the same name.</p>
</li>
<li>
<p>The alias was not resolved if it contained a SpEL expression (<code>#{&#8230;&#8203;}</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with version 2.0, if you declare one of these elements with both an <code>id</code> <em>and</em> a <code>name</code> attribute, the name is no longer declared as a bean name alias.
If you wish to declare a queue and exchange with the same <code>name</code>, you must provide an <code>id</code>.</p>
</div>
<div class="paragraph">
<p>There is no change if the element has only a <code>name</code> attribute.
The bean can still be referenced by the <code>name</code>&#8201;&#8212;&#8201;for example, in binding declarations.
However, you still cannot reference it if the name contains SpEL&#8201;&#8212;&#8201;you must provide an <code>id</code> for reference purposes.</p>
</div>
</div>
<div class="sect4">
<h5 id="anonymous-queue"><code>AnonymousQueue</code></h5>
<div class="paragraph">
<p>In general, when you need a uniquely-named, exclusive, auto-delete queue, we recommend that you use the <code>AnonymousQueue</code>
instead of broker-defined queue names (using <code>""</code> as a <code>Queue</code> name causes the broker to generate the queue
name).</p>
</div>
<div class="paragraph">
<p>This is because:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The queues are actually declared when the connection to the broker is established.
This is long after the beans are created and wired together.
Beans that use the queue need to know its name.
In fact, the broker might not even be running when the application is started.</p>
</li>
<li>
<p>If the connection to the broker is lost for some reason, the admin re-declares the <code>AnonymousQueue</code> with the same name.
If we used broker-declared queues, the queue name would change.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can control the format of the queue name used by <code>AnonymousQueue</code> instances.</p>
</div>
<div class="paragraph">
<p>By default, the queue name is prefixed by <code>spring.gen-</code> followed by a base64 representation of the <code>UUID</code>&#8201;&#8212;&#8201;for example: <code>spring.gen-MRBv9sqISkuCiPfOYfpo4g</code>.</p>
</div>
<div class="paragraph">
<p>You can provide an <code>AnonymousQueue.NamingStrategy</code> implementation in a constructor argument.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue anon1() {
    return new AnonymousQueue();
}

@Bean
public Queue anon2() {
    return new AnonymousQueue(new AnonymousQueue.Base64UrlNamingStrategy("something-"));
}

@Bean
public Queue anon3() {
    return new AnonymousQueue(AnonymousQueue.UUIDNamingStrategy.DEFAULT);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first bean generates a queue name prefixed by <code>spring.gen-</code> followed by a base64 representation of the <code>UUID</code>&#8201;&#8212;&#8201;for
example: <code>spring.gen-MRBv9sqISkuCiPfOYfpo4g</code>.
The second bean generates a queue name prefixed by <code>something-</code> followed by a base64 representation of the <code>UUID</code>.
The third bean generates a name by using only the UUID (no base64 conversion)&#8201;&#8212;&#8201;for example, <code>f20c818a-006b-4416-bf91-643590fedb0e</code>.</p>
</div>
<div class="paragraph">
<p>The base64 encoding uses the &#8220;URL and Filename Safe Alphabet&#8221; from RFC 4648.
Trailing padding characters (<code>=</code>) are removed.</p>
</div>
<div class="paragraph">
<p>You can provide your own naming strategy, whereby you can include other information (such as the application name or client host) in the queue name.</p>
</div>
<div class="paragraph">
<p>You can specify the naming strategy when you use XML configuration.
The <code>naming-strategy</code> attribute is present on the <code>&lt;rabbit:queue&gt;</code> element
for a bean reference that implements <code>AnonymousQueue.NamingStrategy</code>.
The following examples show how to specify the naming strategy in various ways:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:queue id="uuidAnon" /&gt;

&lt;rabbit:queue id="springAnon" naming-strategy="uuidNamer" /&gt;

&lt;rabbit:queue id="customAnon" naming-strategy="customNamer" /&gt;

&lt;bean id="uuidNamer" class="org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy" /&gt;

&lt;bean id="customNamer" class="org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy"&gt;
    &lt;constructor-arg value="custom.gen-" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example creates names such as <code>spring.gen-MRBv9sqISkuCiPfOYfpo4g</code>.
The second example creates names with a String representation of a UUID.
The third example creates names such as <code>custom.gen-MRBv9sqISkuCiPfOYfpo4g</code>.</p>
</div>
<div class="paragraph">
<p>You can also provide your own naming strategy bean.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, anonymous queues are declared with argument <code>x-queue-master-locator</code> set to <code>client-local</code> by default.
This ensures that the queue is declared on the node to which the application is connected.
You can revert to the previous behavior by calling <code>queue.setMasterLocator(null)</code> after constructing the instance.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="broker-events">3.1.12. Broker Event Listener</h4>
<div class="paragraph">
<p>When the <a href="https://www.rabbitmq.com/event-exchange.html">Event Exchange Plugin</a> is enabled, if you add a bean of type <code>BrokerEventListener</code> to the application context, it publishes selected broker events as <code>BrokerEvent</code> instances, which can be consumed with a normal Spring <code>ApplicationListener</code> or <code>@EventListener</code> method.
Events are published by the broker to a topic exchange <code>amq.rabbitmq.event</code> with a different routing key for each event type.
The listener uses event keys, which are used to bind an <code>AnonymousQueue</code> to the exchange so the listener receives only selected events.
Since it is a topic exchange, wildcards can be used (as well as explicitly requesting specific events), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public BrokerEventListener eventListener() {
    return new BrokerEventListener(connectionFactory(), "user.deleted", "channel.#", "queue.#");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can further narrow the received events in individual event listeners, by using normal Spring techniques, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EventListener(condition = "event.eventType == 'queue.created'")
public void listener(BrokerEvent event) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="delayed-message-exchange">3.1.13. Delayed Message Exchange</h4>
<div class="paragraph">
<p>Version 1.6 introduces support for the
<a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/">Delayed Message Exchange Plugin</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The plugin is currently marked as experimental but has been available for over a year (at the time of writing).
If changes to the plugin make it necessary, we plan to add support for such changes as soon as practical.
For that reason, this support in Spring AMQP should be considered experimental, too.
This functionality was tested with RabbitMQ 3.6.0 and version 0.0.1 of the plugin.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use a <code>RabbitAdmin</code> to declare an exchange as delayed, you can set the <code>delayed</code> property on the exchange bean to
<code>true</code>.
The <code>RabbitAdmin</code> uses the exchange type (<code>Direct</code>, <code>Fanout</code>, and so on) to set the <code>x-delayed-type</code> argument and
declare the exchange with type <code>x-delayed-message</code>.</p>
</div>
<div class="paragraph">
<p>The <code>delayed</code> property (default: <code>false</code>) is also available when configuring exchange beans using XML.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;rabbit:topic-exchange name="topic" delayed="true" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To send a delayed message, you can set the <code>x-delay</code> header through <code>MessageProperties</code>, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageProperties properties = new MessageProperties();
properties.setDelay(15000);
template.send(exchange, routingKey,
        MessageBuilder.withBody("foo".getBytes()).andProperties(properties).build());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">rabbitTemplate.convertAndSend(exchange, routingKey, "foo", new MessagePostProcessor() {

    @Override
    public Message postProcessMessage(Message message) throws AmqpException {
        message.getMessageProperties().setDelay(15000);
        return message;
    }

});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To check if a message was delayed, use the <code>getReceivedDelay()</code> method on the <code>MessageProperties</code>.
It is a separate property to avoid unintended propagation to an output message generated from an input message.</p>
</div>
</div>
<div class="sect3">
<h4 id="management-rest-api">3.1.14. RabbitMQ REST API</h4>
<div class="paragraph">
<p>When the management plugin is enabled, the RabbitMQ server exposes a REST API to monitor and configure the broker.
A <a href="https://github.com/rabbitmq/hop">Java Binding for the API</a> is now provided.
The <code>com.rabbitmq.http.client.Client</code> is a standard, immediate, and, therefore, blocking API.
It is based on the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web">Spring Web</a> module and its <code>RestTemplate</code> implementation.
On the other hand, the <code>com.rabbitmq.http.client.ReactorNettyClient</code> is a reactive, non-blocking implementation based on the <a href="https://projectreactor.io/docs/netty/release/reference/docs/index.html">Reactor Netty</a> project.</p>
</div>
<div class="paragraph">
<p>The hop dependency (<code>com.rabbitmq:http-client</code>) is now also <code>optional</code>.</p>
</div>
<div class="paragraph">
<p>See their Javadoc for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="exception-handling">3.1.15. Exception Handling</h4>
<div class="paragraph">
<p>Many operations with the RabbitMQ Java client can throw checked exceptions.
For example, there are a lot of cases where <code>IOException</code> instances may be thrown.
The <code>RabbitTemplate</code>, <code>SimpleMessageListenerContainer</code>, and other Spring AMQP components catch those exceptions and convert them into one of the exceptions within <code>AmqpException</code> hierarchy.
Those are defined in the 'org.springframework.amqp' package, and <code>AmqpException</code> is the base of the hierarchy.</p>
</div>
<div class="paragraph">
<p>When a listener throws an exception, it is wrapped in a <code>ListenerExecutionFailedException</code>.
Normally the message is rejected and requeued by the broker.
Setting <code>defaultRequeueRejected</code> to <code>false</code> causes messages to be discarded (or routed to a dead letter exchange).
As discussed in <a href="#async-listeners">Message Listeners and the Asynchronous Case</a>, the listener can throw an <code>AmqpRejectAndDontRequeueException</code> (or <code>ImmediateRequeueAmqpException</code>) to conditionally control this behavior.</p>
</div>
<div class="paragraph">
<p>However, there is a class of errors where the listener cannot control the behavior.
When a message that cannot be converted is encountered (for example, an invalid <code>content_encoding</code> header), some exceptions are thrown before the message reaches user code.
With <code>defaultRequeueRejected</code> set to <code>true</code> (default) (or throwing an <code>ImmediateRequeueAmqpException</code>), such messages would be redelivered over and over.
Before version 1.3.2, users needed to write a custom <code>ErrorHandler</code>, as discussed in <a href="#exception-handling">Exception Handling</a>, to avoid this situation.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.3.2, the default <code>ErrorHandler</code> is now a <code>ConditionalRejectingErrorHandler</code> that rejects (and does not requeue) messages that fail with an irrecoverable error.
Specifically, it rejects messages that fail with the following errors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>o.s.amqp&#8230;&#8203;MessageConversionException</code>: Can be thrown when converting the incoming message payload using a <code>MessageConverter</code>.</p>
</li>
<li>
<p><code>o.s.messaging&#8230;&#8203;MessageConversionException</code>: Can be thrown by the conversion service if additional conversion is required when mapping to a <code>@RabbitListener</code> method.</p>
</li>
<li>
<p><code>o.s.messaging&#8230;&#8203;MethodArgumentNotValidException</code>: Can be thrown if validation (for example, <code>@Valid</code>) is used in the listener and the validation fails.</p>
</li>
<li>
<p><code>o.s.messaging&#8230;&#8203;MethodArgumentTypeMismatchException</code>: Can be thrown if the inbound message was converted to a type that is not correct for the target method.
For example, the parameter is declared as <code>Message&lt;Foo&gt;</code> but <code>Message&lt;Bar&gt;</code> is received.</p>
</li>
<li>
<p><code>java.lang.NoSuchMethodException</code>: Added in version 1.6.3.</p>
</li>
<li>
<p><code>java.lang.ClassCastException</code>: Added in version 1.6.3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure an instance of this error handler with a <code>FatalExceptionStrategy</code> so that users can provide their own rules for conditional message rejection&#8201;&#8212;&#8201;for example, a delegate implementation to the <code>BinaryExceptionClassifier</code> from Spring Retry (<a href="#async-listeners">Message Listeners and the Asynchronous Case</a>).
In addition, the <code>ListenerExecutionFailedException</code> now has a <code>failedMessage</code> property that you can use in the decision.
If the <code>FatalExceptionStrategy.isFatal()</code> method returns <code>true</code>, the error handler throws an <code>AmqpRejectAndDontRequeueException</code>.
The default <code>FatalExceptionStrategy</code> logs a warning message when an exception is determined to be fatal.</p>
</div>
<div class="paragraph">
<p>Since version 1.6.3, a convenient way to add user exceptions to the fatal list is to subclass <code>ConditionalRejectingErrorHandler.DefaultExceptionStrategy</code> and override the <code>isUserCauseFatal(Throwable cause)</code> method to return <code>true</code> for fatal exceptions.</p>
</div>
<div class="paragraph">
<p>A common pattern for handling DLQ messages is to set a <code>time-to-live</code> on those messages as well as additional DLQ configuration such that these messages expire and are routed back to the main queue for retry.
The problem with this technique is that messages that cause fatal exceptions loop forever.
Starting with version 2.1, the <code>ConditionalRejectingErrorHandler</code> detects an <code>x-death</code> header on a message that causes a fatal exception to be thrown.
The message is logged and discarded.</p>
</div>
</div>
<div class="sect3">
<h4 id="transactions">3.1.16. Transactions</h4>
<div class="paragraph">
<p>The Spring Rabbit framework has support for automatic transaction management in the synchronous and asynchronous use cases with a number of different semantics that can be selected declaratively, as is familiar to existing users of Spring transactions.
This makes many if not most common messaging patterns easy to implement.</p>
</div>
<div class="paragraph">
<p>There are two ways to signal the desired transaction semantics to the framework.
In both the <code>RabbitTemplate</code> and <code>SimpleMessageListenerContainer</code>, there is a flag <code>channelTransacted</code> which, if <code>true</code>, tells the framework to use a transactional channel and to end all operations (send or receive) with a commit or rollback (depending on the outcome), with an exception signaling a rollback.
Another signal is to provide an external transaction with one of Spring&#8217;s <code>PlatformTransactionManager</code> implementations as a context for the ongoing operation.
If there is already a transaction in progress when the framework is sending or receiving a message, and the <code>channelTransacted</code> flag is <code>true</code>, the commit or rollback of the messaging transaction is deferred until the end of the current transaction.
If the <code>channelTransacted</code> flag is <code>false</code>, no transaction semantics apply to the messaging operation (it is auto-acked).</p>
</div>
<div class="paragraph">
<p>The <code>channelTransacted</code> flag is a configuration time setting.
It is declared and processed once when the AMQP components are created, usually at application startup.
The external transaction is more dynamic in principle because the system responds to the current thread state at runtime.
However, in practice, it is often also a configuration setting, when the transactions are layered onto an application declaratively.</p>
</div>
<div class="paragraph">
<p>For synchronous use cases with <code>RabbitTemplate</code>, the external transaction is provided by the caller, either declaratively or imperatively according to taste (the usual Spring transaction model).
The following example shows a declarative approach (usually preferred because it is non-invasive), where the template has been configured with <code>channelTransacted=true</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Transactional
public void doSomething() {
    String incoming = rabbitTemplate.receiveAndConvert();
    // do some more database processing...
    String outgoing = processInDatabaseAndExtractReply(incoming);
    rabbitTemplate.convertAndSend(outgoing);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, a <code>String</code> payload is received, converted, and sent as a message body inside a method marked as <code>@Transactional</code>.
If the database processing fails with an exception, the incoming message is returned to the broker, and the outgoing message is not sent.
This applies to any operations with the <code>RabbitTemplate</code> inside a chain of transactional methods (unless, for instance, the <code>Channel</code> is directly manipulated to commit the transaction early).</p>
</div>
<div class="paragraph">
<p>For asynchronous use cases with <code>SimpleMessageListenerContainer</code>, if an external transaction is needed, it has to be requested by the container when it sets up the listener.
To signal that an external transaction is required, the user provides an implementation of <code>PlatformTransactionManager</code> to the container when it is configured.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class ExampleExternalTransactionAmqpConfiguration {

    @Bean
    public SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setTransactionManager(transactionManager());
        container.setChannelTransacted(true);
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the transaction manager is added as a dependency injected from another bean definition (not shown), and the <code>channelTransacted</code> flag is also set to <code>true</code>.
The effect is that if the listener fails with an exception, the transaction is rolled back, and the message is also returned to the broker.
Significantly, if the transaction fails to commit (for example, because of
a database constraint error or connectivity problem), the AMQP transaction is also rolled back, and the message is returned to the broker.
This is sometimes known as a &#8220;Best Efforts 1 Phase Commit&#8221;, and is a very powerful pattern for reliable messaging.
If the <code>channelTransacted</code> flag was set to <code>false</code> (the default) in the preceding example, the external transaction would still be provided for the listener, but all messaging operations would be auto-acked, so the effect is to commit the messaging operations even on a rollback of the business operation.</p>
</div>
<div class="sect4">
<h5 id="conditional-rollback">Conditional Rollback</h5>
<div class="paragraph">
<p>Prior to version 1.6.6, adding a rollback rule to a container&#8217;s <code>transactionAttribute</code> when using an external transaction manager (such as JDBC) had no effect.
Exceptions always rolled back the transaction.</p>
</div>
<div class="paragraph">
<p>Also, when using a <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#transaction-declarative">transaction advice</a> in the container&#8217;s advice chain, conditional rollback was not very usefulm, because all listener exceptions are wrapped in a <code>ListenerExecutionFailedException</code>.</p>
</div>
<div class="paragraph">
<p>The first problem has been corrected, and the rules are now applied properly.
Further, the <code>ListenerFailedRuleBasedTransactionAttribute</code> is now provided.
It is a subclass of <code>RuleBasedTransactionAttribute</code>, with the only difference being that it is aware of the <code>ListenerExecutionFailedException</code> and uses the cause of such exceptions for the rule.
This transaction attribute can be used directly in the container or through a transaction advice.</p>
</div>
<div class="paragraph">
<p>The following example uses this rule:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AbstractMessageListenerContainer container() {
    ...
    container.setTransactionManager(transactionManager);
    RuleBasedTransactionAttribute transactionAttribute =
        new ListenerFailedRuleBasedTransactionAttribute();
    transactionAttribute.setRollbackRules(Collections.singletonList(
        new NoRollbackRuleAttribute(DontRollBackException.class)));
    container.setTransactionAttribute(transactionAttribute);
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transaction-rollback">A note on Rollback of Received Messages</h5>
<div class="paragraph">
<p>AMQP transactions apply only to messages and acks sent to the broker.
Consequently, when there is a rollback of a Spring transaction and a message has been received, Spring AMQP has to not only rollback the transaction but also manually reject the message (sort of a nack, but that is not what the specification calls it).
The action taken on message rejection is independent of transactions and depends on the <code>defaultRequeueRejected</code> property (default: <code>true</code>).
For more information about rejecting failed messages, see <a href="#async-listeners">Message Listeners and the Asynchronous Case</a>.</p>
</div>
<div class="paragraph">
<p>For more information about RabbitMQ transactions and their limitations, see <a href="https://www.rabbitmq.com/semantics.html">RabbitMQ Broker Semantics</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Prior to RabbitMQ 2.7.0, such messages (and any that are unacked when a channel is closed or aborts) went to the back of the queue on a Rabbit broker.
Since 2.7.0, rejected messages go to the front of the queue, in a similar manner to JMS rolled back messages.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Previously, message requeue on transaction rollback was inconsistent between local transactions and when a <code>TransactionManager</code> was provided.
In the former case, the normal requeue logic (<code>AmqpRejectAndDontRequeueException</code> or <code>defaultRequeueRejected=false</code>) applied (see <a href="#async-listeners">Message Listeners and the Asynchronous Case</a>).
With a transaction manager, the message was unconditionally requeued on rollback.
Starting with version 2.0, the behavior is consistent and the normal requeue logic is applied in both cases.
To revert to the previous behavior, you can set the container&#8217;s <code>alwaysRequeueWithTxManagerRollback</code> property to <code>true</code>.
See <a href="#containerAttributes">Message Listener Container Configuration</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_using_rabbittransactionmanager">Using <code>RabbitTransactionManager</code></h5>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/transaction/RabbitTransactionManager.html">RabbitTransactionManager</a> is an alternative to executing Rabbit operations within, and synchronized with, external transactions.
This transaction manager is an implementation of the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html"><code>PlatformTransactionManager</code></a> interface and should be used with a single Rabbit <code>ConnectionFactory</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This strategy is not able to provide XA transactions&#8201;&#8212;&#8201;for example, in order to share transactions between messaging and database access.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Application code is required to retrieve the transactional Rabbit resources through <code>ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactory, boolean)</code> instead of a standard <code>Connection.createChannel()</code> call with subsequent channel creation.
When using Spring AMQP&#8217;s <a href="https://docs.spring.io/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/core/RabbitTemplate.html">RabbitTemplate</a>, it will autodetect a thread-bound Channel and automatically participate in its transaction.</p>
</div>
<div class="paragraph">
<p>With Java Configuration, you can setup a new RabbitTransactionManager by using the following bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RabbitTransactionManager rabbitTransactionManager() {
    return new RabbitTransactionManager(connectionFactory);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML configuration, you can declare the following bean in your XML Application Context file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rabbitTxManager"
      class="org.springframework.amqp.rabbit.transaction.RabbitTransactionManager"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="containerAttributes">3.1.17. Message Listener Container Configuration</h4>
<div class="paragraph">
<p>There are quite a few options for configuring a <code>SimpleMessageListenerContainer</code> (SMLC) and a <code>DirectMessageListenerContainer</code> (DMLC) related to transactions and quality of service, and some of them interact with each other.
Properties that apply to the SMLC or DMLC are indicated by the check mark in the appropriate column.
See <a href="#choose-container">Choosing a Container</a> for information to help you decide which container is appropriate for your application.</p>
</div>
<div class="paragraph">
<p>The following table shows the container property names and their equivalent attribute names (in parentheses) when using the namespace to configure a <code>&lt;rabbit:listener-container/&gt;</code>.
The <code>type</code> attribute on that element can be <code>simple</code> (default) or <code>direct</code> to specify an <code>SMLC</code> or <code>DMLC</code> respectively.
Some properties are not exposed by the namespace.
These are indicated by <code>N/A</code> for the attribute.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Configuration options for a message listener container</caption>
<colgroup>
<col style="width: 26.6666%;">
<col style="width: 53.3333%;">
<col style="width: 10%;">
<col style="width: 10.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property
(Attribute)</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">SMLC</th>
<th class="tableblock halign-left valign-top">DMLC</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> (group)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is available only when using the namespace.
When specified, a bean of type <code>Collection&lt;MessageListenerContainer&gt;</code> is registered with this name, and the
container for each <code>&lt;listener/&gt;</code> element is added to the collection.
This allows, for example, starting and stopping the group of containers by iterating over the collection.
If multiple <code>&lt;listener-container/&gt;</code> elements have the same group value, the containers in the collection form
an aggregate of all containers so designated.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `channelTransacted`
(channel-transacted)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean flag to signal that all messages should be acknowledged in a transaction (either manually or automatically).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `acknowledgeMode`
(acknowledge)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>NONE</code>: No acks are sent (incompatible with <code>channelTransacted=true</code>).
RabbitMQ calls this &#8220;autoack&#8221;, because the broker assumes all messages are acked without any action from the consumer.</p>
</li>
<li>
<p><code>MANUAL</code>: The listener must acknowledge all messages by calling <code>Channel.basicAck()</code>.</p>
</li>
<li>
<p><code>AUTO</code>: The container acknowledges the message automatically, unless the <code>MessageListener</code> throws an exception.
Note that <code>acknowledgeMode</code> is complementary to <code>channelTransacted</code>&#8201;&#8212;&#8201;if the channel is transacted, the broker requires a commit notification in addition to the ack.
This is the default mode.
See also <code>txSize</code>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `transactionManager`
(transaction-manager)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">External transaction manager for the operation of the listener.
Also complementary to <code>channelTransacted</code>&#8201;&#8212;&#8201;if the <code>Channel</code> is transacted, its transaction is synchronized with the external transaction.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `prefetchCount`
(prefetch)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of unacknowledged messages that can be outstanding at each consumer.
The higher this value is, the faster the messages can be delivered, but the higher the risk of non-sequential processing.
Ignored if the <code>acknowledgeMode</code> is <code>NONE</code>.
This is increased, if necessary, to match the <code>txSize</code> or <code>messagePerAck</code>.
Defaults to 250 since 2.0.
You can set it to 1 to revert to the previous behavior.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
There are scenarios where the prefetch value should
be low&#8201;&#8212;&#8201;for example, with large messages, especially if the processing is slow (messages could add up
to a large amount of memory in the client process), and if strict message ordering is necessary
(the prefetch value should be set back to 1 in this case).
Also, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.
</td>
</tr>
</table>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `shutdownTimeout`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When a container shuts down (for example,
if its enclosing <code>ApplicationContext</code> is closed), it waits for in-flight messages to be processed up to this limit.
Defaults to five seconds.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `forceCloseChannel`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the consumers do not respond to a shutdown within <code>shutdownTimeout</code>, if this is <code>true</code>, the channel will be closed, causing any unacked messages to be requeued.
Defaults to <code>true</code> since 2.0.
You can set it to <code>false</code> to revert to the previous behavior.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `txSize`
(transaction-size)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When used with <code>acknowledgeMode</code> set to <code>AUTO</code>, the container tries to process up to this number of messages before sending an ack (waiting for each one up to the receive timeout setting).
This is also when a transactional channel is committed.
If the <code>prefetchCount</code> is less than the <code>txSize</code>, it is increased to match the <code>txSize</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `messagesPerAck`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of messages to receive between acks.
Use this to reduce the number of acks sent to the broker (at the cost of increasing the possibility of redelivered messages).
Generally, you should set this property only on high-volume listener containers.
If this is set and a message is rejected (exception thrown), pending acks are acknowledged and the failed message is rejected.
Not allowed with transacted channels.
If the <code>prefetchCount</code> is less than the <code>messagesPerAck</code>, it is increased to match the <code>messagesPerAck</code>.
Default: ack every message.
See also <code>ackTimeout</code> in this table.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `ackTimeout`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>messagesPerAck</code> is set, this timeout is used as an alternative to send an ack.
When a new message arrives, the count of unacked messages is compared to <code>messagesPerAck</code>, and the time since the last ack is compared to this value.
If either condition is <code>true</code>, the message is acknowledged.
When no new messages arrive and there are unacked messages, this timeout is approximate since the condition is only checked each <code>monitorInterval</code>.
See also <code>messagesPerAck</code> and <code>monitorInterval</code> in this table.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `receiveTimeout`
(receive-timeout)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum time to wait for each message.
If <code>acknowledgeMode=NONE</code>, this has very little effect&#8201;&#8212;&#8201;the container spins round and asks for another message.
It has the biggest effect for a transactional <code>Channel</code> with <code>txSize &gt; 1</code>, since it can cause messages already consumed not to be acknowledged until the timeout expires.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `autoStartup`
(auto-startup)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flag to indicate that the container should start when the <code>ApplicationContext</code> does (as part of the <code>SmartLifecycle</code> callbacks, which happen after all beans are initialized).
Defaults to <code>true</code>, but you can set it to <code>false</code> if your broker might not be available on startup and call <code>start()</code> later manually when you know the broker is ready.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `phase`
(phase)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>autoStartup</code> is <code>true</code>, the lifecycle phase within which this container should start and stop.
The lower the value, the earlier this container starts and the later it stops.
The default is <code>Integer.MAX_VALUE</code>, meaning the container starts as late as possible and stops as soon as possible.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `adviceChain`
(advice-chain)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of AOP Advice to apply to the listener execution.
This can be used to apply additional cross-cutting concerns, such as automatic retry in the event of broker death.
Note that simple re-connection after an AMQP error is handled by the <code>CachingConnectionFactory</code>, as long as the broker is still alive.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `taskExecutor`
(task-executor)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to a Spring <code>TaskExecutor</code> (or standard JDK 1.5+ <code>Executor</code>) for executing listener invokers.
Default is a <code>SimpleAsyncTaskExecutor</code>, using internally managed threads.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `errorHandler`
(error-handler)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to an <code>ErrorHandler</code> strategy for handling any uncaught exceptions that may occur during the execution of the MessageListener.
Default: <code>ConditionalRejectingErrorHandler</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `consumersPerQueue`
(consumers-per-queue)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of consumers to create for each configured queue.
See <a href="#listener-concurrency">Listener Concurrency</a>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `concurrentConsumers`
(concurrency)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of concurrent consumers to initially start for each listener.
See <a href="#listener-concurrency">Listener Concurrency</a>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `maxConcurrentConsumers`
(max-concurrency)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of concurrent consumers to start, if needed, on demand.
Must be greater than or equal to 'concurrentConsumers'.
See <a href="#listener-concurrency">Listener Concurrency</a>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `concurrency`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>m-n</code> The range of concurrent consumers for each listener (min, max).
If only <code>n</code> is provided, <code>n</code> is a fixed number of consumers.
See <a href="#listener-concurrency">Listener Concurrency</a>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `consumerStartTimeout`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds to wait for a consumer thread to start.
If this time elapses, an error log is written.
An example of when this might happen is if a configured <code>taskExecutor</code> has insufficient threads to support the container <code>concurrentConsumers</code>.</p>
<p class="tableblock">See <a href="#threading">Threading and Asynchronous Consumers</a>.
Default: 60000 (one minute).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `startConsumerMinInterval`
(min-start-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds that must elapse before each new consumer is started on demand.
See <a href="#listener-concurrency">Listener Concurrency</a>.
Default: 10000 (10 seconds).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `stopConsumerMinInterval`
(min-stop-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds that must elapse before a consumer is stopped since the last consumer was stopped when an idle consumer is detected.
See <a href="#listener-concurrency">Listener Concurrency</a>.
Default: 60000 (one minute).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `consecutiveActiveTrigger`
(min-consecutive-active)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The minimum number of consecutive messages received by a consumer, without a receive timeout occurring, when considering starting a new consumer.
Also impacted by 'txSize'.
See <a href="#listener-concurrency">Listener Concurrency</a>.
Default: 10.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `consecutiveIdleTrigger`
(min-consecutive-idle)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The minimum number of receive timeouts a consumer must experience before considering stopping a consumer.
Also impacted by 'txSize'.
See <a href="#listener-concurrency">Listener Concurrency</a>.
Default: 10.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `connectionFactory`
(connection-factory)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A reference to the <code>ConnectionFactory</code>.
When configuring byusing the XML namespace, the default referenced bean name is <code>rabbitConnectionFactory</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `defaultRequeueRejected`
(requeue-rejected)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines whether messages that are rejected because the listener threw an exception should be requeued or not.
Default: <code>true</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `recoveryInterval`
(recovery-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines the time in milliseconds between attempts to start a consumer if it fails to start for non-fatal reasons.
Default: 5000.
Mutually exclusive with <code>recoveryBackOff</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `recoveryBackOff`
(recovery-back-off)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the <code>BackOff</code> for intervals between attempts to start a consumer if it fails to start for non-fatal reasons.
Default is <code>FixedBackOff</code> with unlimited retries every five seconds.
Mutually exclusive with <code>recoveryInterval</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `exclusive`
(exclusive)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines whether the single consumer in this container has exclusive access to the queues.
The concurrency of the container must be 1 when this is <code>true</code>.
If another consumer has exclusive access, the container tries to recover the consumer, according to the
<code>recovery-interval</code> or <code>recovery-back-off</code>.
When using the namespace, this attribute appears on the <code>&lt;rabbit:listener/&gt;</code> element along with the queue names.
Default: <code>false</code>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `rabbitAdmin`
(admin)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When a listener container listens to at least one auto-delete queue and it is found to be missing during startup, the container uses a <code>RabbitAdmin</code> to declare the queue and any related bindings and exchanges.
If such elements are configured to use conditional declaration (see <a href="#conditional-declaration">Conditional Declaration</a>), the container must use the admin that was configured to declare those elements.
Specify that admin here.
It is required only when using auto-delete queues with conditional declaration.
If you do not wish the auto-delete queues to be declared until the container is started, set <code>auto-startup</code> to <code>false</code> on the admin.
Defaults to a <code>RabbitAdmin</code> that declares all non-conditional elements.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `missingQueuesFatal`
(missing-queues-fatal)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to <code>true</code> (default), if none of the configured queues are available on the broker, it is considered fatal.
This causes the application context to fail to initialize during startup.
Also, when the queues are deleted while the container is running, by default, the consumers make three retries to connect to the queues (at five second intervals) and stop the container if these attempts fail.</p>
</div>
<div class="paragraph">
<p>This was not configurable in previous versions.</p>
</div>
<div class="paragraph">
<p>When set to <code>false</code>, after making the three retries, the container goes into recovery mode, as with other problems, such as the broker being down.
The container tries to recover according to the <code>recoveryInterval</code> property.
During each recovery attempt, each consumer again tries four times to passively declare the queues at five second intervals.
This process continues indefinitely.</p>
</div>
<div class="paragraph">
<p>You can also use a properties bean to set the property globally for all containers, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:properties
        id="spring.amqp.global.properties"&gt;
    &lt;prop key="mlc.missing.queues.fatal"&gt;
        false
    &lt;/prop&gt;
&lt;/util:properties&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This global property is not applied to any containers that have an explicit <code>missingQueuesFatal</code> property set.</p>
</div>
<div class="paragraph">
<p>The default retry properties (three retries at five-second intervals) can be overridden by setting the properties below.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Missing queue detection is disabled while starting a container for a <code>@RabbitListener</code> in a bean that is marked <code>@Lazy</code>.
This is to avoid a potential deadlock which can delay the start of such containers for up to 60 seconds.
Applications using lazy listener beans should check the queue(s) before getting a reference to the lazy bean.
</td>
</tr>
</table>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> possibleAuthentication
FailureFatal
(possible-authentication-failure-fatal)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to <code>true</code> (default), if a <code>PossibleAuthenticationFailureException</code> is thrown during connection, it is considered fatal.
This causes the application context to fail to initialize during startup.</p>
</div>
<div class="paragraph">
<p>Since <em>version 2.0</em>.</p>
</div>
<div class="paragraph">
<p>When set to <code>false</code>, after making the 3 retries, the container will go into recovery mode, as with other problems, such as the broker being down.
The container will attempt to recover according to the <code>recoveryInterval</code> property.
During each recovery attempt, each consumer will again try 4 times to start.
This process will continue indefinitely.</p>
</div>
<div class="paragraph">
<p>You can also use a properties bean to set the property globally for all containers, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:properties
    id="spring.amqp.global.properties"&gt;
  &lt;prop
    key="mlc.possible.authentication.failure.fatal"&gt;
     false
  &lt;/prop&gt;
&lt;/util:properties&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This global property will not be applied to any containers that have an explicit <code>missingQueuesFatal</code> property set.</p>
</div>
<div class="paragraph">
<p>The default retry properties (3 retries at 5 second intervals) can be overridden using the properties after this one.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `mismatchedQueuesFatal`
(mismatched-queues-fatal)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When the container starts, if this property is <code>true</code> (default: <code>false</code>), the container checks that all queues declared in the context are compatible with queues already on the broker.
If mismatched properties (such as <code>auto-delete</code>) or arguments (skuch as <code>x-message-ttl</code>) exist, the container (and application context) fails to start with a fatal exception.</p>
</div>
<div class="paragraph">
<p>If the problem is detected during recovery (for example, after a lost connection), the container is stopped.</p>
</div>
<div class="paragraph">
<p>There must be a single <code>RabbitAdmin</code> in the application context (or one specifically configured on the container by using the <code>rabbitAdmin</code> property).
Otherwise, this property must be <code>false</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the broker is not available during initial startup, the container starts and the conditions are checked when the connection is established.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The check is done against all queues in the context, not just the queues that a particular listener is configured to use.
If you wish to limit the checks to just those queues used by a container, you should configure a separate <code>RabbitAdmin</code> for the container, and provide a reference to it using the <code>rabbitAdmin</code> property.
See <a href="#conditional-declaration">Conditional Declaration</a> for more information.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Mismatched queue argument detection is disabled while starting a container for a <code>@RabbitListener</code> in a bean that is marked <code>@Lazy</code>.
This is to avoid a potential deadlock which can delay the start of such containers for up to 60 seconds.
Applications using lazy listener beans should check the queue arguments before getting a reference to the lazy bean.
</td>
</tr>
</table>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `autoDeclare`
(auto-declare)</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to <code>true</code> (default), the container uses a <code>RabbitAdmin</code> to redeclare all AMQP objects (queues, exchanges, bindings), if it detects that at least one of its queues is missing during startup, perhaps because it is an <code>auto-delete</code> or an expired queue, but the redeclaration proceeds if the queue is missing for any reason.
To disable this behavior, set this property to <code>false</code>.
Note that the container fails to start if all of its queues are missing.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Prior to version 1.6, if there was more than one admin in the context, the container would randomly select one.
If there were no admins, it would create one internally.
In either case, this could cause unexpected results.
Starting with version 1.6, for <code>autoDeclare</code> to work, there must be exactly one <code>RabbitAdmin</code> in the context, or a reference to a specific instance must be configured on the container using the <code>rabbitAdmin</code> property.
</td>
</tr>
</table>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `declarationRetries`
(declaration-retries)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of retry attempts when passive queue declaration fails.
Passive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.
When none of the configured queues can be passively declared (for any reason) after the retries are exhausted, the container behavior is controlled by the 'missingQueuesFatal` property, described earlier.
Default: Three retries (for a total of four attempts).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `failedDeclarationRetryInterval`
(failed-declaration-retry-
interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The interval between passive queue declaration retry attempts.
Passive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.
Default: 5000 (five seconds).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `retryDeclarationInterval`
(missing-queue-retry-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a subset of the configured queues are available during consumer initialization, the consumer starts consuming from those queues.
The consumer tries to passively declare the missing queues by using this interval.
When this interval elapses, the 'declarationRetries' and 'failedDeclarationRetryInterval' is used again.
If there are still missing queues, the consumer again waits for this interval before trying again.
This process continues indefinitely until all queues are available.
Default: 60000 (one minute).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `consumerTagStrategy`
(consumer-tag-strategy)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set an implementation of <a href="#consumerTags">ConsumerTagStrategy</a>, enabling the creation of a (unique) tag for each consumer.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `idleEventInterval`
(idle-event-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#idle-containers">Detecting Idle Asynchronous Consumers</a>.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `monitorInterval`
(monitor-interval)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With the DMLC, a task is scheduled to run at this interval to monitor the state of the consumers and recover any that have failed.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `taskScheduler`
(task-scheduler)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With the DMLC, the scheduler used to run the monitor task at the 'monitorInterval'.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `exclusiveConsumer`
`ExceptionLogger`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An exception logger used when an exclusive consumer cannot gain access to a queue.
By default, this is logged at the <code>WARN</code> level.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `statefulRetryFatalWithNullMessageId`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When using a stateful retry advice, if a message with a missing <code>messageId</code> property is received, it is considered
fatal for the consumer (it is stopped) by default.
Set this to <code>false</code> to discard (or route to a dead-letter queue) such messages.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `alwaysRequeueWithTxManagerRollback`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set to <code>true</code> to always requeue messages on rollback when a transaction manager is configured.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `noLocal`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set to <code>true</code> to disable delivery from the server to consumers messages published on the same channel&#8217;s connection.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `afterReceivePostProcessors`
(N/A)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of <code>MessagePostProcessor</code> instances that are invoked before invoking the listener.
Post processors can implement <code>PriorityOrdered</code> or <code>Ordered</code>.
The array is sorted with un-ordered members invoked last.
If a post processor returns <code>null</code>, the message is discarded (and acknowledged, if appropriate).</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="listener-concurrency">3.1.18. Listener Concurrency</h4>
<div class="sect4">
<h5 id="_simplemessagelistenercontainer">SimpleMessageListenerContainer</h5>
<div class="paragraph">
<p>By default, the listener container starts a single consumer that receives messages from the queues.</p>
</div>
<div class="paragraph">
<p>When examining the table in the previous section, you can see a number of properties and attributes that control concurrency.
The simplest is <code>concurrentConsumers</code>, which creates that (fixed) number of consumers that concurrently process messages.</p>
</div>
<div class="paragraph">
<p>Prior to version 1.3.0, this was the only setting available and the container had to be stopped and started again to change the setting.</p>
</div>
<div class="paragraph">
<p>Since version 1.3.0, you can now dynamically adjust the <code>concurrentConsumers</code> property.
If it is changed while the container is running, consumers are added or removed as necessary to adjust to the new setting.</p>
</div>
<div class="paragraph">
<p>In addition, a new property called <code>maxConcurrentConsumers</code> has been added and the container dynamically adjusts the concurrency based on workload.
This works in conjunction with four additional properties: <code>consecutiveActiveTrigger</code>, <code>startConsumerMinInterval</code>, <code>consecutiveIdleTrigger</code>, and <code>stopConsumerMinInterval</code>.
With the default settings, the algorithm to increase consumers works as follows:</p>
</div>
<div class="paragraph">
<p>If the <code>maxConcurrentConsumers</code> has not been reached and an existing consumer is active for ten consecutive cycles AND at least 10 seconds has elapsed since the last consumer was started, a new consumer is started.
A consumer is considered active if it received at least one message in <code>txSize</code> * <code>receiveTimeout</code> milliseconds.</p>
</div>
<div class="paragraph">
<p>With the default settings, the algorithm to decrease consumers works as follows:</p>
</div>
<div class="paragraph">
<p>If there are more than <code>concurrentConsumers</code> running and a consumer detects ten consecutive timeouts (idle) AND the last consumer was stopped at least 60 seconds ago, a consumer is stopped.
The timeout depends on the <code>receiveTimeout</code> and the <code>txSize</code> properties.
A consumer is considered idle if it receives no messages in <code>txSize</code> * <code>receiveTimeout</code> milliseconds.
So, with the default timeout (one second) and a <code>txSize</code> of four, stopping a consumer is considered after 40 seconds of idle time (four timeouts correspond to one idle detection).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Practically, consumers can be stopped only if the whole container is idle for some time.
This is because the broker shares its work across all the active consumers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each consumer uses a single channel, regardless of the number of configured queues.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>concurrentConsumers</code> and <code>maxConcurrentConsumers</code> properties can be set with the <code>concurrency</code> property&#8201;&#8212;&#8201;for example, <code>2-4</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_directmessagelistenercontainer">Using <code>DirectMessageListenerContainer</code></h5>
<div class="paragraph">
<p>With this container, concurrency is based on the configured queues and <code>consumersPerQueue</code>.
Each consumer for each queue uses a separate channel, and the concurrency is controlled by the rabbit client library.
By default, at the time of writing, it uses a pool of <code>DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors() * 2</code> threads.</p>
</div>
<div class="paragraph">
<p>You can configure a <code>taskExecutor</code> to provide the required maximum concurrency.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exclusive-consumer">3.1.19. Exclusive Consumer</h4>
<div class="paragraph">
<p>Starting with version 1.3, you can configure the listener container with a single exclusive consumer.
This prevents other containers from consuming from the queues until the current consumer is cancelled.
The concurrency of such a container must be <code>1</code>.</p>
</div>
<div class="paragraph">
<p>When using exclusive consumers, other containers try to consume from the queues according to the <code>recoveryInterval</code> property and log a <code>WARN</code> message if the attempt fails.</p>
</div>
</div>
<div class="sect3">
<h4 id="listener-queues">3.1.20. Listener Container Queues</h4>
<div class="paragraph">
<p>Version 1.3 introduced a number of improvements for handling multiple queues in a listener container.</p>
</div>
<div class="paragraph">
<p>The container must be configured to listen on at least one queue.
This was the case previously, too, but now queues can be added and removed at runtime.
The container recycles (cancels and re-creates) the consumers when any pre-fetched messages have been processed.
See the <a href="https://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/rabbit/listener/AbstractMessageListenerContainer.html">Javadoc</a> for the <code>addQueues</code>, <code>addQueueNames</code>, <code>removeQueues</code> and <code>removeQueueNames</code> methods.
When removing queues, at least one queue must remain.</p>
</div>
<div class="paragraph">
<p>A consumer now starts if any of its queues are available.
Previously, the container would stop if any queues were unavailable.
Now, this is only the case if none of the queues are available.
If not all queues are available, the container tries to passively declare (and consume from) the missing queues every 60 seconds.</p>
</div>
<div class="paragraph">
<p>Also, if a consumer receives a cancel from the broker (for example, if a queue is deleted) the consumer tries to recover, and the recovered consumer continues to process messages from any other configured queues.
Previously, a cancel on one queue cancelled the entire consumer and, eventually, the container would stop due to the missing queue.</p>
</div>
<div class="paragraph">
<p>If you wish to permanently remove a queue, you should update the container before or after deleting to queue, to avoid future attempts trying to consume from it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resilience_recovering_from_errors_and_broker_failures">3.1.21. Resilience: Recovering from Errors and Broker Failures</h4>
<div class="paragraph">
<p>Some of the key (and most popular) high-level features that Spring AMQP provides are to do with recovery and automatic re-connection in the event of a protocol error or broker failure.
We have seen all the relevant components already in this guide, but it should help to bring them all together here and call out the features and recovery scenarios individually.</p>
</div>
<div class="paragraph">
<p>The primary reconnection features are enabled by the <code>CachingConnectionFactory</code> itself.
It is also often beneficial to use the <code>RabbitAdmin</code> auto-declaration features.
In addition, if you care about guaranteed delivery, you probably also need to use the <code>channelTransacted</code> flag in <code>RabbitTemplate</code> and <code>SimpleMessageListenerContainer</code> and the <code>AcknowledgeMode.AUTO</code> (or manual if you do the acks yourself) in the <code>SimpleMessageListenerContainer</code>.</p>
</div>
<div class="sect4">
<h5 id="automatic-declaration">Automatic Declaration of Exchanges, Queues, and Bindings</h5>
<div class="paragraph">
<p>The <code>RabbitAdmin</code> component can declare exchanges, queues, and bindings on startup.
It does this lazily, through a <code>ConnectionListener</code>.
Consequently, if the broker is not present on startup, it does not matter.
The first time a <code>Connection</code> is used (for example,
by sending a message) the listener fires and the admin features is applied.
A further benefit of doing the auto declarations in a listener is that, if the connection is dropped for any reason (for example,
broker death, network glitch, and others), they are applied again when the connection is re-established.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Queues declared this way must have fixed names&#8201;&#8212;&#8201;either explicitly declared or generated by the framework for <code>AnonymousQueue</code> instances.
Anonymous queues are non-durable, exclusive, and auto-deleting.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Automatic declaration is performed only when the <code>CachingConnectionFactory</code> cache mode is <code>CHANNEL</code> (the default).
This limitation exists because exclusive and auto-delete queues are bound to the connection.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See also <a href="#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="retry">Failures in Synchronous Operations and Options for Retry</h5>
<div class="paragraph">
<p>If you lose your connection to the broker in a synchronous sequence when using <code>RabbitTemplate</code> (for instance), Spring AMQP throws an <code>AmqpException</code> (usually, but not always, <code>AmqpIOException</code>).
We do not try to hide the fact that there was a problem, so you have to be able to catch and respond to the exception.
The easiest thing to do if you suspect that the connection was lost (and it was not your fault) is to try the operation again.
You can do this manually, or you could look at using Spring Retry to handle the retry (imperatively or declaratively).</p>
</div>
<div class="paragraph">
<p>Spring Retry provides a couple of AOP interceptors and a great deal of flexibility to specify the parameters of the retry (number of attempts, exception types, backoff algorithm, and others).
Spring AMQP also provides some convenience factory beans for creating Spring Retry interceptors in a convenient form for AMQP use cases, with strongly typed callback interfaces that you can use to implement custom recovery logic.
See the Javadoc and properties of <code>StatefulRetryOperationsInterceptor</code> and <code>StatelessRetryOperationsInterceptor</code> for more detail.
Stateless retry is appropriate if there is no transaction or if a transaction is started inside the retry callback.
Note that stateless retry is simpler to configure and analyze than stateful retry, but it is not usually appropriate if there is an ongoing transaction that must be rolled back or definitely is going to roll back.
A dropped connection in the middle of a transaction should have the same effect as a rollback.
Consequently, for reconnections where the transaction is started higher up the stack, stateful retry is usually the best choice.
Stateful retry needs a mechanism to uniquely identify a message.
The simplest approach is to have the sender put a unique value in the <code>MessageId</code> message property.
The provided message converters provide an option to do this: you can set <code>createMessageIds</code> to <code>true</code>.
Otherwise, you can inject a <code>MessageKeyGenerator</code> implementation into the interceptor.
The key generator must return a unique key for each message.
In versions prior to version 2.0, a <code>MissingMessageIdAdvice</code> was provided.
It enabled messages without a <code>messageId</code> property to be retried exactly once (ignoring the retry settings).
This advice is no longer provided, since, along with <code>spring-retry</code> version 1.2, its functionality is built into the interceptor and message listener containers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For backwards compatibility, a message with a null message ID is considered fatal for the consumer (consumer is stopped) by default (after one retry).
To replicate the functionality provided by the <code>MissingMessageIdAdvice</code>, you can set the <code>statefulRetryFatalWithNullMessageId</code> property to <code>false</code> on the listener container.
With that setting, the consumer continues to run and the message is rejected (after one retry).
It is discarded or routed to the dead letter queue (if one is configured).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 1.3, a builder API is provided to aid in assembling these interceptors by using Java (in <code>@Configuration</code> classes).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StatefulRetryOperationsInterceptor interceptor() {
	return RetryInterceptorBuilder.stateful()
			.maxAttempts(5)
			.backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval
			.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Only a subset of retry capabilities can be configured this way.
More advanced features would need the configuration of a <code>RetryTemplate</code> as a Spring bean.
See the <a href="https://docs.spring.io/spring-retry/docs/api/current/">Spring Retry Javadoc</a> for complete information about available policies and their configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="async-listeners">Message Listeners and the Asynchronous Case</h5>
<div class="paragraph">
<p>If a <code>MessageListener</code> fails because of a business exception, the exception is handled by the message listener container, which then goes back to listening for another message.
If the failure is caused by a dropped connection (not a business exception), the consumer that is collecting messages for the listener has to be cancelled and restarted.
The <code>SimpleMessageListenerContainer</code> handles this seamlessly, and it leaves a log to say that the listener is being restarted.
In fact, it loops endlessly, trying to restart the consumer.
Only if the consumer is very badly behaved indeed will it give up.
One side effect is that if the broker is down when the container starts, it keeps trying until a connection can be established.</p>
</div>
<div class="paragraph">
<p>Business exception handling, as opposed to protocol errors and dropped connections, might need more thought and some custom configuration, especially if transactions or container acks are in use.
Prior to 2.8.x, RabbitMQ had no definition of dead letter behavior.
Consequently, by default, a message that is rejected or rolled back because of a business exception can be redelivered endlessly.
To put a limit on the client on the number of re-deliveries, one choice is a <code>StatefulRetryOperationsInterceptor</code> in the advice chain of the listener.
The interceptor can have a recovery callback that implements a custom dead letter action&#8201;&#8212;&#8201;whatever is appropriate for your particular environment.</p>
</div>
<div class="paragraph">
<p>Another alternative is to set the container&#8217;s <code>defaultRequeueRejected</code> property to <code>false</code>.
This causes all failed messages to be discarded.
When using RabbitMQ 2.8.x or higher, this also facilitates delivering the message to a dead letter exchange.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can throw a <code>AmqpRejectAndDontRequeueException</code>.
Doing so prevents message requeuing, regardless of the setting of the <code>defaultRequeueRejected</code> property.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, an <code>ImmediateRequeueAmqpException</code> is introduced to perform exactly the opposite logic: the message will be requeued, regardless of the setting of the <code>defaultRequeueRejected</code> property.</p>
</div>
<div class="paragraph">
<p>Often, a combination of both techniques is used.
You can use a <code>StatefulRetryOperationsInterceptor</code> in the advice chain with a <code>MessageRecoverer</code> that throws an <code>AmqpRejectAndDontRequeueException</code>.
The <code>MessageRecover</code> is called when all retries have been exhausted.
The <code>RejectAndDontRequeueRecoverer</code> does exactly that.
The default <code>MessageRecoverer</code> consumes the errant message and emits a <code>WARN</code> message.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.3, a new <code>RepublishMessageRecoverer</code> is provided, to allow publishing of failed messages after retries are exhausted.</p>
</div>
<div class="paragraph">
<p>When a recoverer consumes the final exception, the message is ack&#8217;d and is not sent to the dead letter exchange, if any.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>RepublishMessageRecoverer</code> is used on the consumer side, the received message has <code>deliveryMode</code> in the <code>receivedDeliveryMode</code> message property.
In this case the <code>deliveryMode</code> is <code>null</code>.
That means a <code>NON_PERSISTENT</code> delivery mode on the broker.
Starting with version 2.0, you can configure the <code>RepublishMessageRecoverer</code> for the <code>deliveryMode</code> to set into the message to republish if it is <code>null</code>.
By default, it uses <code>MessageProperties</code> default value - <code>MessageDeliveryMode.PERSISTENT</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to set a <code>RepublishMessageRecoverer</code> as the recoverer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
RetryOperationsInterceptor interceptor() {
	return RetryInterceptorBuilder.stateless()
			.maxAttempts(5)
			.recoverer(new RepublishMessageRecoverer(amqpTemplate(), "something", "somethingelse"))
			.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>RepublishMessageRecoverer</code> publishes the message with additional information in message headers, such as the exception message, stack trace, original exchange, and routing key.
Additional headers can be added by creating a subclass and overriding <code>additionalHeaders()</code>.
The <code>deliveryMode</code> (or any other properties) can also be changed in the <code>additionalHeaders()</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RepublishMessageRecoverer recoverer = new RepublishMessageRecoverer(amqpTemplate, "error") {

    protected Map&lt;? extends String, ? extends Object&gt; additionalHeaders(Message message, Throwable cause) {
        message.getMessageProperties()
            .setDeliveryMode(message.getMessageProperties().getReceivedDeliveryMode());
        return null;
    }

};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.1, an <code>ImmediateRequeueMessageRecoverer</code> is  added to throw an <code>ImmediateRequeueAmqpException</code>, which notifies a listener container to requeue the current failed message.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exception_classification_for_spring_retry">Exception Classification for Spring Retry</h5>
<div class="paragraph">
<p>Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.
The default configuration retries for all exceptions.
Given that user exceptions are wrapped in a <code>ListenerExecutionFailedException</code>, we need to ensure that the classification examines the exception causes.
The default classifier looks only at the top level exception.</p>
</div>
<div class="paragraph">
<p>Since Spring Retry 1.0.3, the <code>BinaryExceptionClassifier</code> has a property called <code>traverseCauses</code> (default: <code>false</code>).
When <code>true</code>, it travers exception causes until it finds a match or there is no cause.</p>
</div>
<div class="paragraph">
<p>To use this classifier for retry, you can use a <code>SimpleRetryPolicy</code> created with the constructor that takes the max attempts, the <code>Map</code> of <code>Exception</code> instances, and the boolean (<code>traverseCauses</code>) and inject this policy into the <code>RetryTemplate</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_debugging">3.1.22. Debugging</h4>
<div class="paragraph">
<p>Spring AMQP provides extensive logging, especially at the <code>DEBUG</code> level.</p>
</div>
<div class="paragraph">
<p>If you wish to monitor the AMQP protocol between the application and broker, you can use a tool such as WireShark, which has a plugin to decode the protocol.
Alternatively, the RabbitMQ Java client comes with a very useful class called <code>Tracer</code>.
When run as a <code>main</code>, by default, it listens on port 5673 and connects to port 5672 on localhost.
You can run it and change your connection factory configuration to connect to port 5673 on localhost.
It displays the decoded protocol on the console.
Refer to the <code>Tracer</code> Javadoc for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging">3.2. Logging Subsystem AMQP Appenders</h3>
<div class="paragraph">
<p>The framework provides logging appenders for some popular logging subsystems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>logback (since Spring AMQP version 1.4)</p>
</li>
<li>
<p>log4j2 (since Spring AMQP version 1.6)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The appenders are configured byusing the normal mechanisms for the logging subsystem, available properties are specified
in the following sections.</p>
</div>
<div class="sect3">
<h4 id="_common_properties">3.2.1. Common properties</h4>
<div class="paragraph">
<p>The following properties are available with all appenders:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Common Appender Properties</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `exchangeName`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `logs`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the exchange to which to publish log events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `exchangeType`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `topic`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type of the exchange to which to publish log events&#8201;&#8212;&#8201;needed only if the appender declares the exchange.
See <code>declareExchange</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `routingKeyPattern`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `%c.%p`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logging subsystem pattern format to use to generate a routing key.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `applicationId`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre></pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application ID&#8201;&#8212;&#8201;added to the routing key if the pattern includes <code>%X{applicationId}</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `senderPoolSize`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `2`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of threads to use to publish log events.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `maxSenderRetries`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `30`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">How many times to retry sending a message if the broker is unavailable or there is some other error.
Retries are delayed as follows: <code>N ^ log(N)</code>, where <code>N</code> is the retry number.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `addresses`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre></pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A comma-delimited list of broker addresses in the following form: <code>host:port[,host:port]*</code> - overrides <code>host</code> and <code>port</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `host`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `localhost`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RabbitMQ host to which to connect .</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `port`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `5672`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RabbitMQ port to which to connect.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `virtualHost`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `/`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RabbitMQ virtual host to which to connect.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `username`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `guest`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RabbitMQ user to use when connecting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `password`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `guest`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RabbitMQ password for this user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `useSsl`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `false`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to use SSL for the RabbitMQ connection.
See <a href="#_rabbitconnectionfactorybean_and_configuring_ssl">[_rabbitconnectionfactorybean_and_configuring_ssl]</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `sslAlgorithm`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The SSL algorithm to use.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `sslPropertiesLocation`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of the SSL properties file.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `keyStore`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of the keystore.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `keyStorePassphrase`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passphrase for the keystore.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `keyStoreType`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `JKS`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The keystore type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `trustStore`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of the truststore.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `trustStorePassphrase`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passphrase for the truststore.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `trustStoreType`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `JKS`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The truststore type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `contentType`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `text/plain`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>content-type</code> property of log messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `contentEncoding`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre></pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>content-encoding</code> property of log messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `declareExchange`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `false`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to declare the configured exchange when this appender starts.
See also <code>durable</code> and <code>autoDelete</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `durable`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `true`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>declareExchange</code> is <code>true</code>, the durable flag is set to this value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `autoDelete`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `false`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>declareExchange</code> is <code>true</code>, the auto-delete flag is set to this value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `charset`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Character set to use when converting <code>String</code> to <code>byte[]</code>.
Default: null (the system default charset is used).
If the character set is unsupported on the current platform, we fall back to using the system character set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `deliveryMode`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `PERSISTENT`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PERSISTENT</code> or <code>NON_PERSISTENT</code> to determine whether or not RabbitMQ should persist the messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `generateId`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `false`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to determine whether the <code>messageId</code> property is set to a unique value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `clientConnectionProperties`</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `null`</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A comma-delimited list of <code>key:value</code> pairs for custom client properties to the RabbitMQ connection.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_log4j_2_appender">3.2.2. Log4j 2 Appender</h4>
<div class="paragraph">
<p>The following example shows how to configure a Log4j 2 appender:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Appenders&gt;
    ...
    &lt;RabbitMQ name="rabbitmq"
        addresses="foo:5672,bar:5672" user="guest" password="guest" virtualHost="/"
        exchange="log4j2" exchangeType="topic" declareExchange="true" durable="true" autoDelete="false"
        applicationId="myAppId" routingKeyPattern="%X{applicationId}.%c.%p"
        contentType="text/plain" contentEncoding="UTF-8" generateId="true" deliveryMode="NON_PERSISTENT"
        charset="UTF-8"
        senderPoolSize="3" maxSenderRetries="5"&gt;
    &lt;/RabbitMQ&gt;
&lt;/Appenders&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with versions 1.6.10 and 1.7.3, by default, the log4j2 sppender publishes the messages to RabbitMQ on the calling thread.
This is because Log4j 2 does not, by default, create thread-safe events.
If the broker is down, the <code>maxSenderRetries</code> is used to retry, with no delay between retries.
If you wish to restore the previous behavior of publishing the messages on separate threads (<code>senderPoolSize</code>), you can set the <code>async</code> property to <code>true</code>.
However, you also need to configure Log4j 2 to use the <code>DefaultLogEventFactory</code> instead of the <code>ReusableLogEventFactory</code>.
One way to do that is to set the system property <code>-Dlog4j2.enable.threadlocals=false</code>.
If you use asynchronous publishing with the <code>ReusableLogEventFactory</code>, events have a high likelihood of being corrupted due to cross-talk.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_logback_appender">3.2.3. Logback Appender</h4>
<div class="paragraph">
<p>The following example shows how to configure a logback appender:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;appender name="AMQP" class="org.springframework.amqp.rabbit.logback.AmqpAppender"&gt;
    &lt;layout&gt;
        &lt;pattern&gt;&lt;![CDATA[ %d %p %t [%c] - &lt;%m&gt;%n ]]&gt;&lt;/pattern&gt;
    &lt;/layout&gt;
    &lt;addresses&gt;foo:5672,bar:5672&lt;/addresses&gt;
    &lt;abbreviation&gt;36&lt;/abbreviation&gt;
    &lt;includeCallerData&gt;false&lt;/includeCallerData&gt;
    &lt;applicationId&gt;myApplication&lt;/applicationId&gt;
    &lt;routingKeyPattern&gt;%property{applicationId}.%c.%p&lt;/routingKeyPattern&gt;
    &lt;generateId&gt;true&lt;/generateId&gt;
    &lt;charset&gt;UTF-8&lt;/charset&gt;
    &lt;durable&gt;false&lt;/durable&gt;
    &lt;deliveryMode&gt;NON_PERSISTENT&lt;/deliveryMode&gt;
    &lt;declareExchange&gt;true&lt;/declareExchange&gt;
&lt;/appender&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 1.7.1, the Logback <code>AmqpAppender</code> provides  an <code>includeCallerData</code> option, which is <code>false</code> by default.
Extracting caller data can be rather expensive, because the log event has to create a throwable and inspect it to determine the calling location.
Therefore, by default, caller data associated with an event is not extracted when the event is added to the event queue.
You can configure the appender to include caller data by setting the <code>includeCallerData</code> property to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0.0, the Logback <code>AmqpAppender</code> supports <a href="https://logback.qos.ch/manual/encoders.html">Logback encoders</a> with the <code>encoder</code> option.
The <code>encoder</code> and <code>layout</code> options are mutually exclusive.</p>
</div>
</div>
<div class="sect3">
<h4 id="_customizing_the_messages">3.2.4. Customizing the Messages</h4>
<div class="paragraph">
<p>By default, AMQP appenders populate the following message properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>deliveryMode</code></p>
</li>
<li>
<p>contentType</p>
</li>
<li>
<p><code>contentEncoding</code>, if configured</p>
</li>
<li>
<p><code>messageId</code>, if <code>generateId</code> is configured</p>
</li>
<li>
<p><code>timestamp</code> of the log event</p>
</li>
<li>
<p><code>appId</code>, if applicationId is configured</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition they populate headers with the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>categoryName</code> of the log event</p>
</li>
<li>
<p>The level of the log event</p>
</li>
<li>
<p><code>thread</code>: the name of the thread where log event happened</p>
</li>
<li>
<p>The location of the stack trace of the log event call</p>
</li>
<li>
<p>A copy of all the MDC properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of the appenders can be subclassed, letting you modify the messages before publishing.
The following example shows how to customize log messages:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyEnhancedAppender extends AmqpAppender {

    @Override
    public Message postProcessMessageBeforeSend(Message message, Event event) {
        message.getMessageProperties().setHeader("foo", "bar");
        return message;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_customizing_the_client_properties">3.2.5. Customizing the Client Properties</h4>
<div class="paragraph">
<p>You can add custom client properties by adding either string properties or more complex properties.</p>
</div>
<div class="sect4">
<h5 id="_simple_string_properties">Simple String Properties</h5>
<div class="paragraph">
<p>Each appender supports adding client properties to the RabbitMQ connection.</p>
</div>
<div class="paragraph">
<p>The following example shows how to add a custom client property for logback:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;appender name="AMQP" ...&gt;
    ...
    &lt;clientConnectionProperties&gt;thing1:thing2,cat:hat&lt;/clientConnectionProperties&gt;
    ...
&lt;/appender&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 1. log4j2</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Appenders&gt;
    ...
    &lt;RabbitMQ name="rabbitmq"
        ...
        clientConnectionProperties="thing1:thing2,cat:hat"
        ...
    &lt;/RabbitMQ&gt;
&lt;/Appenders&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The properties are a comma-delimited list of <code>key:value</code> pairs.
Keys and values cannot contain commas or colons.</p>
</div>
<div class="paragraph">
<p>These properties appear on the RabbitMQ Admin UI when the connection is viewed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_technique_for_logback">Advanced Technique for Logback</h5>
<div class="paragraph">
<p>You can subclass the Logback appender.
Doing so lets you modify the client connection properties before the connection is established.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyEnhancedAppender extends AmqpAppender {

    private String thing1;

    @Override
    protected void updateConnectionClientProperties(Map&lt;String, Object&gt; clientProperties) {
        clientProperties.put("thing1", this.thing1);
    }

    public void setThing1(String thing1) {
        this.thing1 = thing1;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then you can add <code>&lt;thing1&gt;thing2&lt;/thing1&gt;</code> to logback.xml.</p>
</div>
<div class="paragraph">
<p>For String properties such as those shown in the preceding example, the previous technique can be used.
Subclasses allow for adding richer properties (such as adding a <code>Map</code> or numeric property).</p>
</div>
<div class="paragraph">
<p>With Log4j 2, subclasses are not supported, due to the way Log4j 2 uses static factory methods.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_queue_implementation">3.2.6. Providing a Custom Queue Implementation</h4>
<div class="paragraph">
<p>The <code>AmqpAppenders</code> use a <code>BlockingQueue</code> to asynchronously publish logging events to RabbitMQ.
By default, a <code>LinkedBlockingQueue</code> is used.
However, you can supply any kind of custom <code>BlockingQueue</code> implementation.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so for Logback:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyEnhancedAppender extends AmqpAppender {

    @Override
    protected BlockingQueue&lt;Event&gt; createEventQueue() {
        return new ArrayBlockingQueue();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The Log4j 2 appender supports using a <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html#BlockingQueueFactory"><code>BlockingQueueFactory</code></a>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Appenders&gt;
    ...
    &lt;RabbitMQ name="rabbitmq"
              bufferSize="10" ... &gt;
        &lt;ArrayBlockingQueue/&gt;
    &lt;/RabbitMQ&gt;
&lt;/Appenders&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sample-apps">3.3. Sample Applications</h3>
<div class="paragraph">
<p>The <a href="https://github.com/SpringSource/spring-amqp-samples">Spring AMQP Samples</a> project includes two sample applications.
The first is a simple &#8220;Hello World&#8221; example that demonstrates both synchronous and asynchronous message reception.
It provides an excellent starting point for acquiring an understanding of the essential components.
The second sample is based on a stock-trading use case to demonstrate the types of interaction that would be common in real world applications.
In this chapter, we provide a quick walk-through of each sample so that you can focus on the most important components.
The samples are both Maven-based, so you should be able to import them directly into any Maven-aware IDE (such as <a href="https://www.springsource.org/sts">SpringSource Tool Suite</a>).</p>
</div>
<div class="sect3">
<h4 id="hello-world-sample">3.3.1. The &#8220;Hello World&#8221; Sample</h4>
<div class="paragraph">
<p>The &#8220;Hello World&#8221; sample demonstrates both synchronous and asynchronous message reception.
You can import the <code>spring-rabbit-helloworld</code> sample into the IDE and then follow the discussion below.</p>
</div>
<div class="sect4">
<h5 id="hello-world-sync">Synchronous Example</h5>
<div class="paragraph">
<p>Within the <code>src/main/java</code> directory, navigate to the <code>org.springframework.amqp.helloworld</code> package.
Open the <code>HelloWorldConfiguration</code> class and notice that it contains the <code>@Configuration</code> annotation at the class level and notice some <code>@Bean</code> annotations at method-level.
This is an example of Spring&#8217;s Java-based configuration.
You can read more about that <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java">here</a>.</p>
</div>
<div class="paragraph">
<p>The following listing shows how the connection factory is created:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConnectionFactory connectionFactory() {
    CachingConnectionFactory connectionFactory =
        new CachingConnectionFactory("localhost");
    connectionFactory.setUsername("guest");
    connectionFactory.setPassword("guest");
    return connectionFactory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration also contains an instance of <code>RabbitAdmin</code>, which, by default, looks for any beans of type exchange, queue, or binding and then declares them on the broker.
In fact, the <code>helloWorldQueue</code> bean that is generated in <code>HelloWorldConfiguration</code> is an example because it is an instance of <code>Queue</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>helloWorldQueue</code> bean definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue helloWorldQueue() {
    return new Queue(this.helloWorldQueueName);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Looking back at the <code>rabbitTemplate</code> bean configuration, you can see that it has the name of <code>helloWorldQueue</code> set as its <code>queue</code> property (for receiving messages) and for its <code>routingKey</code> property (for sending messages).</p>
</div>
<div class="paragraph">
<p>Now that we have explored the configuration, we can look at the code that actually uses these components.
First, open the <code>Producer</code> class from within the same package.
It contains a <code>main()</code> method where the Spring <code>ApplicationContext</code> is created.</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>main</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    ApplicationContext context =
        new AnnotationConfigApplicationContext(RabbitConfiguration.class);
    AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.class);
    amqpTemplate.convertAndSend("Hello World");
    System.out.println("Sent: Hello World");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>AmqpTemplate</code> bean is retrieved and used for sending a <code>Message</code>.
Since the client code should rely on interfaces whenever possible, the type is <code>AmqpTemplate</code> rather than <code>RabbitTemplate</code>.
Even though the bean created in <code>HelloWorldConfiguration</code> is an instance of <code>RabbitTemplate</code>, relying on the interface means that this code is more portable (you can change the configuration independently of the code).
Since the <code>convertAndSend()</code> method is invoked, the template delegates to its <code>MessageConverter</code> instance.
In this case, it uses the default <code>SimpleMessageConverter</code>, but a different implementation could be provided to the <code>rabbitTemplate</code> bean, as defined in <code>HelloWorldConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Now open the <code>Consumer</code> class.
It actually shares the same configuration base class, which means it shares the <code>rabbitTemplate</code> bean.
That is why we configured that template with both a <code>routingKey</code> (for sending) and a <code>queue</code> (for receiving).
As we describe in <a href="#amqp-template"><code>AmqpTemplate</code></a>, you could instead pass the 'routingKey' argument to the send method and the 'queue' argument to the receive method.
The <code>Consumer</code> code is basically a mirror image of the Producer, calling <code>receiveAndConvert()</code> rather than <code>convertAndSend()</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows the main method for the <code>Consumer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    ApplicationContext context =
        new AnnotationConfigApplicationContext(RabbitConfiguration.class);
    AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.class);
    System.out.println("Received: " + amqpTemplate.receiveAndConvert());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you run the <code>Producer</code> and then run the <code>Consumer</code>, you should see <code>Received: Hello World</code> in the console output.</p>
</div>
</div>
<div class="sect4">
<h5 id="hello-world-async">Asynchronous Example</h5>
<div class="paragraph">
<p><a href="#hello-world-sync">Synchronous Example</a> walked through the synchronous Hello World sample.
This section describes a slightly more advanced but significantly more powerful option.
With a few modifications, the Hello World sample can provide an example of asynchronous reception, also known as message-driven POJOs.
In fact, there is a sub-package that provides exactly that: <code>org.springframework.amqp.samples.helloworld.async</code>.</p>
</div>
<div class="paragraph">
<p>Again, we start with the sending side.
Open the <code>ProducerConfiguration</code> class and notice that it creates a <code>connectionFactory</code> and a <code>rabbitTemplate</code> bean.
This time, since the configuration is dedicated to the message sending side, we do not even need any queue definitions, and the <code>RabbitTemplate</code> has only the 'routingKey' property set.
Recall that messages are sent to an exchange rather than being sent directly to a queue.
The AMQP default exchange is a direct exchange with no name.
All queues are bound to that default exchange with their name as the routing key.
That is why we only need to provide the routing key here.</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>rabbitTemplate</code> defintion:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public RabbitTemplate rabbitTemplate() {
    RabbitTemplate template = new RabbitTemplate(connectionFactory());
    template.setRoutingKey(this.helloWorldQueueName);
    return template;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since this sample demonstrates asynchronous message reception, the producing side is designed to continuously send messages (if it were a message-per-execution model like the synchronous version, it would not be quite so obvious that it is, in fact, a message-driven consumer).
The component responsible for continuously sending messages is defined as an inner class within the <code>ProducerConfiguration</code>.
It is configured to run every three seconds.</p>
</div>
<div class="paragraph">
<p>The following listing shows the component:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class ScheduledProducer {

    @Autowired
    private volatile RabbitTemplate rabbitTemplate;

    private final AtomicInteger counter = new AtomicInteger();

    @Scheduled(fixedRate = 3000)
    public void sendMessage() {
        rabbitTemplate.convertAndSend("Hello World " + counter.incrementAndGet());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You do not need to understand all of the details, since the real focus should be on the receiving side (which we cover next).
However, if you are not yet familiar with Spring task scheduling support, you can learn more <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-annotation-support">here</a>.
The short story is that the <code>postProcessor</code> bean in the <code>ProducerConfiguration</code> registers the task with a scheduler.</p>
</div>
<div class="paragraph">
<p>Now we can turn to the receiving side.
To emphasize the message-driven POJO behavior, we start with the component that react to the messages.
The class is called <code>HelloWorldHandler</code> and is shown in the following listing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HelloWorldHandler {

    public void handleMessage(String text) {
        System.out.println("Received: " + text);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That class is a POJO.
It does not extend any base class, it does not implement any interfaces, and it does not even contain any imports.
It is being &#8220;adapted&#8221; to the <code>MessageListener</code> interface by the Spring AMQP <code>MessageListenerAdapter</code>.
You can then configure that adapter on a <code>SimpleMessageListenerContainer</code>.
For this sample, the container is created in the <code>ConsumerConfiguration</code> class.
You can see the POJO wrapped in the adapter there.</p>
</div>
<div class="paragraph">
<p>The following listing shows how the <code>listenerContainer</code> is defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleMessageListenerContainer listenerContainer() {
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory());
    container.setQueueName(this.helloWorldQueueName);
    container.setMessageListener(new MessageListenerAdapter(new HelloWorldHandler()));
    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>SimpleMessageListenerContainer</code> is a Spring lifecycle component and, by default, starts automatically.
If you look in the <code>Consumer</code> class, you can see that its <code>main()</code> method consists of nothing more than a one-line bootstrap to create the <code>ApplicationContext</code>.
The Producer&#8217;s <code>main()</code> method is also a one-line bootstrap, since the component whose method is annotated with <code>@Scheduled</code> also starts automatically.
You can start the <code>Producer</code> and <code>Consumer</code> in any order, and you should see messages being sent and received every three seconds.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stock_trading">3.3.2. Stock Trading</h4>
<div class="paragraph">
<p>The Stock Trading sample demonstrates more advanced messaging scenarios than <a href="#hello-world-sample">the Hello World sample</a>.
However, the configuration is very similar, if a bit more involved.
Since we  walked through the Hello World configuration in detail, here, we focus on what makes this sample different.
There is a server that pushes market data (stock quotations) to a topic exchange.
Then, clients can subscribe to the market data feed by binding a queue with a routing pattern (for example,
<code>app.stock.quotes.nasdaq.*</code>).
The other main feature of this demo is a request-reply &#8220;stock trade&#8221; interaction that is initiated by the client and handled by the server.
That involves a private <code>replyTo</code> queue that is sent by the client within the order request message itself.</p>
</div>
<div class="paragraph">
<p>The server&#8217;s core configuration is in the <code>RabbitServerConfiguration</code> class within the <code>org.springframework.amqp.rabbit.stocks.config.server</code> package.
It extends the <code>AbstractStockAppRabbitConfiguration</code>.
That is where the resources common to the server and client are defined, including the market data topic exchange (whose name is 'app.stock.marketdata') and the queue that the server exposes for stock trades (whose name is 'app.stock.request').
In that common configuration file, you also see that a <code>Jackson2JsonMessageConverter</code> is configured on the <code>RabbitTemplate</code>.</p>
</div>
<div class="paragraph">
<p>The server-specific configuration consists of two things.
First, it configures the market data exchange on the <code>RabbitTemplate</code> so that it does not need to provide that exchange name with every call to send a <code>Message</code>.
It does this within an abstract callback method defined in the base configuration class.
The following listing shows that method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void configureRabbitTemplate(RabbitTemplate rabbitTemplate) {
    rabbitTemplate.setExchange(MARKET_DATA_EXCHANGE_NAME);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Second, the stock request queue is declared.
It does not require any explicit bindings in this case, because it is bound to the default no-name exchange with its own name as the routing key.
As mentioned earlier, the AMQP specification defines that behavior.
The following listing shows the definition of the <code>stockRequestQueue</code> bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue stockRequestQueue() {
    return new Queue(STOCK_REQUEST_QUEUE_NAME);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that you have seen the configuration of the server&#8217;s AMQP resources, navigate to the <code>org.springframework.amqp.rabbit.stocks</code> package under the <code>src/test/java</code> directory.
There, you can see the actual <code>Server</code> class that provides a <code>main()</code> method.
It creates an <code>ApplicationContext</code> based on the <code>server-bootstrap.xml</code> config file.
There, you can see the scheduled task that publishes dummy market data.
That configuration relies upon Spring&#8217;s <code>task</code> namespace support.
The bootstrap config file also imports a few other files.
The most interesting one is <code>server-messaging.xml</code>, which is directly under <code>src/main/resources</code>.
There, you can see the <code>messageListenerContainer</code> bean that is responsible for handling the stock trade requests.
Finally, have a look at the <code>serverHandler</code> bean that is defined in <code>server-handlers.xml</code> (which is also in 'src/main/resources').
That bean is an instance of the <code>ServerHandler</code> class and is a good example of a message-driven POJO that can also send reply messages.
Notice that it is not itself coupled to the framework or any of the AMQP concepts.
It accepts a <code>TradeRequest</code> and returns a <code>TradeResponse</code>.
The following listing shows the definition of the <code>handleMessage</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public TradeResponse handleMessage(TradeRequest tradeRequest) { ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have seen the most important configuration and code for the server, we can turn to the client.
The best starting point is probably <code>RabbitClientConfiguration</code>, in the <code>org.springframework.amqp.rabbit.stocks.config.client</code> package.
Notice that it declares two queues without providing explicit names.
The following listing shows the bean definitions for the two queues:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Queue marketDataQueue() {
    return amqpAdmin().declareQueue();
}

@Bean
public Queue traderJoeQueue() {
    return amqpAdmin().declareQueue();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Those are private queues, and unique names are generated automatically.
The first generated queue is used by the client to bind to the market data exchange that has been exposed by the server.
Recall that, in AMQP, consumers interact with queues while producers interact with exchanges.
The &#8220;binding&#8221; of queues to exchanges is what tells the broker to deliver (or route) messages from a given exchange to a queue.
Since the market data exchange is a topic exchange, the binding can be expressed with a routing pattern.
The <code>RabbitClientConfiguration</code> does so with a <code>Binding</code> object, and that object is generated with the <code>BindingBuilder</code> fluent API.
The following listing shows the <code>Binding</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${stocks.quote.pattern}")
private String marketDataRoutingKey;

@Bean
public Binding marketDataBinding() {
    return BindingBuilder.bind(
        marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the actual value has been externalized in a properties file (<code>client.properties</code> under <code>src/main/resources</code>), and that we use Spring&#8217;s <code>@Value</code> annotation to inject that value.
This is generally a good idea.
Otherwise, the value would have been hardcoded in a class and unmodifiable without recompilation.
In this case, it is much easier to run multiple versions of the client while making changes to the routing pattern used for binding.
We can try that now.</p>
</div>
<div class="paragraph">
<p>Start by running <code>org.springframework.amqp.rabbit.stocks.Server</code> and then <code>org.springframework.amqp.rabbit.stocks.Client</code>.
You should see dummy quotations for <code>NASDAQ</code> stocks, because the current value associated with the 'stocks.quote.pattern' key in client.properties is 'app.stock.quotes.nasdaq.<strong>'.
Now, while keeping the existing <code>Server</code> and <code>Client</code> running, change that property value to 'app.stock.quotes.nyse.</strong>' and start a second <code>Client</code> instance.
You should see that the first client still receives NASDAQ quotes while the second client receives NYSE quotes.
You could instead change the pattern to get all stocks or even an individual ticker.</p>
</div>
<div class="paragraph">
<p>The final feature we explore is the request-reply interaction from the lient&#8217;s perspective.
Recall that we have already seen the <code>ServerHandler</code> that accepts <code>TradeRequest</code> objects and returns <code>TradeResponse</code> objects.
The corresponding code on the <code>Client</code> side is <code>RabbitStockServiceGateway</code> in the <code>org.springframework.amqp.rabbit.stocks.gateway</code> package.
It delegates to the <code>RabbitTemplate</code> in order to send messages.
The following listing shows the <code>send</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void send(TradeRequest tradeRequest) {
    getRabbitTemplate().convertAndSend(tradeRequest, new MessagePostProcessor() {
        public Message postProcessMessage(Message message) throws AmqpException {
            message.getMessageProperties().setReplyTo(new Address(defaultReplyToQueue));
            try {
                message.getMessageProperties().setCorrelationId(
                    UUID.randomUUID().toString().getBytes("UTF-8"));
            }
            catch (UnsupportedEncodingException e) {
                throw new AmqpException(e);
            }
            return message;
        }
    });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that, prior to sending the message, it sets the <code>replyTo</code> address.
It provides the queue that was generated by the <code>traderJoeQueue</code> bean definition (shown earlier).
The following listing shows the <code>@Bean</code> definition for the <code>StockServiceGateway</code> class itself:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StockServiceGateway stockServiceGateway() {
    RabbitStockServiceGateway gateway = new RabbitStockServiceGateway();
    gateway.setRabbitTemplate(rabbitTemplate());
    gateway.setDefaultReplyToQueue(traderJoeQueue());
    return gateway;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you are no longer running the server and client, start them now.
Try sending a request with the format of '100 TCKR'.
After a brief artificial delay that simulates &#8220;processing&#8221; of the request, you should see a confirmation message appear on the client.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-rabbit-json">3.3.3. Receiving JSON from Non-Spring Applications</h4>
<div class="paragraph">
<p>Spring applications, when sending JSON, set the <code><em>TypeId</em></code> header to the fully qualified class name to assist the receiving application in converting the JSON back to a Java object.</p>
</div>
<div class="paragraph">
<p>The <code>spring-rabbit-json</code> sample explores several techniques to convert the JSON from a non-Spring application.</p>
</div>
<div class="paragraph">
<p>See also <a href="#json-message-converter">Jackson2JsonMessageConverter</a> as well as the <a href="https://docs.spring.io/spring-amqp/docs/current/api/index.html?org/springframework/amqp/support/converter/DefaultClassMapper.html">Javadoc for the <code>DefaultClassMapper</code></a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing">3.4. Testing Support</h3>
<div class="paragraph">
<p>Writing integration for asynchronous applications is necessarily more complex than testing simpler applications.
This is made more complex when abstractions such as the <code>@RabbitListener</code> annotations come into the picture.
The question is how to verify that, after sending a message, the listener received the message as expected.</p>
</div>
<div class="paragraph">
<p>The framework itself has many unit and integration tests.
Some using mocks while, others use integration testing with a live RabbitMQ broker.
You can consult those tests for some ideas for testing scenarios.</p>
</div>
<div class="paragraph">
<p>Spring AMQP version 1.6 introduced the <code>spring-rabbit-test</code> jar, which provides support for testing some of these more complex scenarios.
It is anticipated that this project will expand over time, but we need community feedback to make suggestions for the features needed to help with testing.
Please use <a href="https://jira.spring.io/browse/AMQP">JIRA</a> or <a href="https://github.com/spring-projects/spring-amqp/issues">GitHub Issues</a> to provide such feedback.</p>
</div>
<div class="sect3">
<h4 id="mockito-answer">3.4.1. Mockito <code>Answer&lt;?&gt;</code> Implementations</h4>
<div class="paragraph">
<p>There are currently two <code>Answer&lt;?&gt;</code> implementations to help with testing.</p>
</div>
<div class="paragraph">
<p>The first, <code>LatchCountDownAndCallRealMethodAnswer</code>, provides an <code>Answer&lt;Void&gt;</code> that returns <code>null</code> and counts down a latch.
The following example shows how to use <code>LatchCountDownAndCallRealMethodAnswer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LatchCountDownAndCallRealMethodAnswer answer = new LatchCountDownAndCallRealMethodAnswer(2);
doAnswer(answer)
    .when(listener).foo(anyString(), anyString());

...

assertTrue(answer.getLatch().await(10, TimeUnit.SECONDS));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second, <code>LambdaAnswer&lt;T&gt;</code> provides a mechanism to optionally call the real method and provides an opportunity
to return a custom result, based on the <code>InvocationOnMock</code> and the result (if any).</p>
</div>
<div class="paragraph">
<p>Consider the following POJO:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Thing {

    public String thing(String thing) {
        return thing.toUpperCase();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following class tests the <code>Thing</code> POJO:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Thing thing = spy(new Thing());

doAnswer(new LambdaAnswer&lt;String&gt;(true, (i, r) -&gt; r + r))
    .when(thing).thing(anyString());
assertEquals("THINGTHING", thing.thing("thing"));

doAnswer(new LambdaAnswer&lt;String&gt;(true, (i, r) -&gt; r + i.getArguments()[0]))
    .when(thing).thing(anyString());
assertEquals("THINGthing", thing.thing("thing"));

doAnswer(new LambdaAnswer&lt;String&gt;(false, (i, r) -&gt;
    "" + i.getArguments()[0] + i.getArguments()[0])).when(thing).thing(anyString());
assertEquals("thingthing", thing.thing("thing"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to test the <code>Thing</code> POJO with Java 7 or earlier:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">doAnswer(new LambdaAnswer&lt;String&gt;(true, new ValueToReturn&lt;String&gt;() {
    @Override
    public String apply(InvocationOnMock i, String r) {
        return r + r;
    }
})).when(thing).thing(anyString());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-harness">3.4.2. <code>@RabbitListenerTest</code> and <code>RabbitListenerTestHarness</code></h4>
<div class="paragraph">
<p>Annotating one of your <code>@Configuration</code> classes with <code>@RabbitListenerTest</code> causes the framework to replace the
standard <code>RabbitListenerAnnotationBeanPostProcessor</code> with a subclass called <code>RabbitListenerTestHarness</code> (it also enables
<code>@RabbitListener</code> detection through <code>@EnableRabbit</code>).</p>
</div>
<div class="paragraph">
<p>The <code>RabbitListenerTestHarness</code> enhances the listener in two ways.
First, it wraps the listener in a <code>Mockito Spy</code>, enabling normal <code>Mockito</code> stubbing and verification operations.
It can also add an <code>Advice</code> to the listener, enabling access to the arguments, result, and any exceptions that are thrown.
You can control which (or both) of these are enabled with attributes on the <code>@RabbitListenerTest</code>.
The latter is provided for access to lower-level data about the invocation.
It also supports blocking the test thread until the async listener is called.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>final</code> <code>@RabbitListener</code> methods cannot be spied or advised.
Also, only listeners with an <code>id</code> attribute can be spied or advised.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider some examples.</p>
</div>
<div class="paragraph">
<p>The following example uses spy:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@RabbitListenerTest
public class Config {

    @Bean
    public Listener listener() {
        return new Listener();
    }

    ...

}

public class Listener {

    @RabbitListener(id="foo", queues="#{queue1.name}")
    public String foo(String foo) {
        return foo.toUpperCase();
    }

    @RabbitListener(id="bar", queues="#{queue2.name}")
    public void foo(@Payload String foo, @Header("amqp_receivedRoutingKey") String rk) {
        ...
    }

}

public class MyTests {

    @Autowired
    private RabbitListenerTestHarness harness; <i class="conum" data-value="1"></i><b>(1)</b>

    @Test
    public void testTwoWay() throws Exception {
        assertEquals("FOO", this.rabbitTemplate.convertSendAndReceive(this.queue1.getName(), "foo"));

        Listener listener = this.harness.getSpy("foo"); <i class="conum" data-value="2"></i><b>(2)</b>
        assertNotNull(listener);
        verify(listener).foo("foo");
    }

    @Test
    public void testOneWay() throws Exception {
        Listener listener = this.harness.getSpy("bar");
        assertNotNull(listener);

        LatchCountDownAndCallRealMethodAnswer answer = new LatchCountDownAndCallRealMethodAnswer(2); <i class="conum" data-value="3"></i><b>(3)</b>
        doAnswer(answer).when(listener).foo(anyString(), anyString()); <i class="conum" data-value="4"></i><b>(4)</b>

        this.rabbitTemplate.convertAndSend(this.queue2.getName(), "bar");
        this.rabbitTemplate.convertAndSend(this.queue2.getName(), "baz");

        assertTrue(answer.getLatch().await(10, TimeUnit.SECONDS));
        verify(listener).foo("bar", this.queue2.getName());
        verify(listener).foo("baz", this.queue2.getName());
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the harness into the test case so we can get access to the spy.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get a reference to the spy so we can verify it was invoked as expected.
Since this is a send and receive operation, there is no need to suspend the test thread because it was already
suspended in the <code>RabbitTemplate</code> waiting for the reply.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In this case, we&#8217;re only using a send operation so we need a latch to wait for the asynchronous call to the listener
on the container thread.
We use one of the <a href="#mockito-answer">Answer&lt;?&gt;</a> implementations to help with that.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Configure the spy to invoke the <code>Answer</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example uses the capture advice:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@ComponentScan
@RabbitListenerTest(spy = false, capture = true)
public class Config {

}

@Service
public class Listener {

    private boolean failed;

    @RabbitListener(id="foo", queues="#{queue1.name}")
    public String foo(String foo) {
        return foo.toUpperCase();
    }

    @RabbitListener(id="bar", queues="#{queue2.name}")
    public void foo(@Payload String foo, @Header("amqp_receivedRoutingKey") String rk) {
        if (!failed &amp;&amp; foo.equals("ex")) {
            failed = true;
            throw new RuntimeException(foo);
        }
        failed = false;
    }

}

public class MyTests {

    @Autowired
    private RabbitListenerTestHarness harness; <i class="conum" data-value="1"></i><b>(1)</b>

    @Test
    public void testTwoWay() throws Exception {
        assertEquals("FOO", this.rabbitTemplate.convertSendAndReceive(this.queue1.getName(), "foo"));

        InvocationData invocationData =
            this.harness.getNextInvocationDataFor("foo", 0, TimeUnit.SECONDS); <i class="conum" data-value="2"></i><b>(2)</b>
        assertThat(invocationData.getArguments()[0], equalTo("foo"));     <i class="conum" data-value="3"></i><b>(3)</b>
        assertThat((String) invocationData.getResult(), equalTo("FOO"));
    }

    @Test
    public void testOneWay() throws Exception {
        this.rabbitTemplate.convertAndSend(this.queue2.getName(), "bar");
        this.rabbitTemplate.convertAndSend(this.queue2.getName(), "baz");
        this.rabbitTemplate.convertAndSend(this.queue2.getName(), "ex");

        InvocationData invocationData =
            this.harness.getNextInvocationDataFor("bar", 10, TimeUnit.SECONDS); <i class="conum" data-value="4"></i><b>(4)</b>
        Object[] args = invocationData.getArguments();
        assertThat((String) args[0], equalTo("bar"));
        assertThat((String) args[1], equalTo(queue2.getName()));

        invocationData = this.harness.getNextInvocationDataFor("bar", 10, TimeUnit.SECONDS);
        args = invocationData.getArguments();
        assertThat((String) args[0], equalTo("baz"));

        invocationData = this.harness.getNextInvocationDataFor("bar", 10, TimeUnit.SECONDS);
        args = invocationData.getArguments();
        assertThat((String) args[0], equalTo("ex"));
        assertEquals("ex", invocationData.getThrowable().getMessage()); <i class="conum" data-value="5"></i><b>(5)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the harness into the test case so we can get access to the spy.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>harness.getNextInvocationDataFor()</code> to retrieve the invocation data - in this case since it was a request/reply
scenario there is no need to wait for any time because the test thread was suspended in the <code>RabbitTemplate</code> waiting
for the result.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can then verify that the argument and result was as expected.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This time we need some time to wait for the data, since it&#8217;s an async operation on the container thread and we need
to suspend the test thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When the listener throws an exception, it is available in the <code>throwable</code> property of the invocation data.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-template">3.4.3. Using <code>TestRabbitTemplate</code></h4>
<div class="paragraph">
<p>The <code>TestRabbitTemplate</code> is provided to perform some basic integration testing without the need for a broker.
When you add it as a <code>@Bean</code> in your test case, it discovers all the listener containers in the context, whether declared as <code>@Bean</code> or <code>&lt;bean/&gt;</code> or using the <code>@RabbitListener</code> annotation.
It currently only supports routing by queue name.
The template extracts the message listener from the container and invokes it directly on the test thread.
Request-reply messaging (<code>sendAndReceive</code> methods) is supported for listeners that return replies.</p>
</div>
<div class="paragraph">
<p>The following test case uses the template:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
public class TestRabbitTemplateTests {

    @Autowired
    private TestRabbitTemplate template;

    @Autowired
    private Config config;

    @Test
    public void testSimpleSends() {
        this.template.convertAndSend("foo", "hello1");
        assertThat(this.config.fooIn, equalTo("foo:hello1"));
        this.template.convertAndSend("bar", "hello2");
        assertThat(this.config.barIn, equalTo("bar:hello2"));
        assertThat(this.config.smlc1In, equalTo("smlc1:"));
        this.template.convertAndSend("foo", "hello3");
        assertThat(this.config.fooIn, equalTo("foo:hello1"));
        this.template.convertAndSend("bar", "hello4");
        assertThat(this.config.barIn, equalTo("bar:hello2"));
        assertThat(this.config.smlc1In, equalTo("smlc1:hello3hello4"));

        this.template.setBroadcast(true);
        this.template.convertAndSend("foo", "hello5");
        assertThat(this.config.fooIn, equalTo("foo:hello1foo:hello5"));
        this.template.convertAndSend("bar", "hello6");
        assertThat(this.config.barIn, equalTo("bar:hello2bar:hello6"));
        assertThat(this.config.smlc1In, equalTo("smlc1:hello3hello4hello5hello6"));
    }

    @Test
    public void testSendAndReceive() {
        assertThat(this.template.convertSendAndReceive("baz", "hello"), equalTo("baz:hello"));
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Configuration
    @EnableRabbit
    public static class Config {

        public String fooIn = "";

        public String barIn = "";

        public String smlc1In = "smlc1:";

        @Bean
        public TestRabbitTemplate template() throws IOException {
            return new TestRabbitTemplate(connectionFactory());
        }

        @Bean
        public ConnectionFactory connectionFactory() throws IOException {
            ConnectionFactory factory = mock(ConnectionFactory.class);
            Connection connection = mock(Connection.class);
            Channel channel = mock(Channel.class);
            willReturn(connection).given(factory).createConnection();
            willReturn(channel).given(connection).createChannel(anyBoolean());
            given(channel.isOpen()).willReturn(true);
            return factory;
        }

        @Bean
        public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() throws IOException {
            SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
            factory.setConnectionFactory(connectionFactory());
            return factory;
        }

        @RabbitListener(queues = "foo")
        public void foo(String in) {
            this.fooIn += "foo:" + in;
        }

        @RabbitListener(queues = "bar")
        public void bar(String in) {
            this.barIn += "bar:" + in;
        }

        @RabbitListener(queues = "baz")
        public String baz(String in) {
            return "baz:" + in;
        }

        @Bean
        public SimpleMessageListenerContainer smlc1() throws IOException {
            SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory());
            container.setQueueNames("foo", "bar");
            container.setMessageListener(new MessageListenerAdapter(new Object() {

                @SuppressWarnings("unused")
                public void handleMessage(String in) {
                    smlc1In += in;
                }

            }));
            return container;
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="junit-rules">3.4.4. JUnit4 <code>@Rules</code></h4>
<div class="paragraph">
<p>Spring AMQP version 1.7 and later provide an additional jar called <code>spring-rabbit-junit</code>.
This jar contains a couple of utility <code>@Rule</code> instances for use when running JUnit4 tests.
See <a href="#junit5-conditions">JUnit5 Conditions</a> for JUnit5 testing.</p>
</div>
<div class="sect4">
<h5 id="_using_brokerrunning">Using <code>BrokerRunning</code></h5>
<div class="paragraph">
<p><code>BrokerRunning</code> provides a mechanism to let tests succeed when a broker is not running (on <code>localhost</code>, by default).</p>
</div>
<div class="paragraph">
<p>It also has utility methods to initialize and empty queues and delete queues and exchanges.</p>
</div>
<div class="paragraph">
<p>The following example shows its usage:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule
public static BrokerRunning brokerRunning = BrokerRunning.isRunningWithEmptyQueues("foo", "bar");

@AfterClass
public static void tearDown() {
    brokerRunning.removeTestQueues("some.other.queue.too") // removes foo, bar as well
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are several <code>isRunning&#8230;&#8203;</code> static methods, such as <code>isBrokerAndManagementRunning()</code>, which verifies the broker has the management plugin enabled.</p>
</div>
<div class="sect5">
<h6 id="brokerRunning-configure">Configuring the Rule</h6>
<div class="paragraph">
<p>There are times when you want tests to fail if there is no broker, such as a nightly CI build.
To disable the rule at runtime, set an environment variable called <code>RABBITMQ_SERVER_REQUIRED</code> to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>You can override the broker properties, such as hostname with either setters or environment variables:</p>
</div>
<div class="paragraph">
<p>The following example shows how to override properties with setters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule
public static BrokerRunning brokerRunning = BrokerRunning.isRunningWithEmptyQueues("foo", "bar");

static {
    brokerRunning.setHostName("10.0.0.1")
}

@AfterClass
public static void tearDown() {
    brokerRunning.removeTestQueues("some.other.queue.too") // removes foo, bar as well
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also override properties by setting the following environment variables:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final String BROKER_ADMIN_URI = "RABBITMQ_TEST_ADMIN_URI";
public static final String BROKER_HOSTNAME = "RABBITMQ_TEST_HOSTNAME";
public static final String BROKER_PORT = "RABBITMQ_TEST_PORT";
public static final String BROKER_USER = "RABBITMQ_TEST_USER";
public static final String BROKER_PW = "RABBITMQ_TEST_PASSWORD";
public static final String BROKER_ADMIN_USER = "RABBITMQ_TEST_ADMIN_USER";
public static final String BROKER_ADMIN_PW = "RABBITMQ_TEST_ADMIN_PASSWORD";</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These environment variables override the default settings (<code>localhost:5672</code> for amqp and <code><a href="http://localhost:15672/api/" class="bare">localhost:15672/api/</a></code> for the management REST API).</p>
</div>
<div class="paragraph">
<p>Changing the host name affects both the <code>amqp</code> and <code>management</code> REST API connection (unless the admin uri is explicitly set).</p>
</div>
<div class="paragraph">
<p><code>BrokerRunning</code> also provides a <code>static</code> method called <code>setEnvironmentVariableOverrides</code> that lets you can pass in a map containing these variables.
They override system environment variables.
This might be useful if you wish to use different configuration for tests in multiple test suites.
IMPORTANT: The method must be called before invoking any of the <code>isRunning()</code> static methods that create the rule instance.
Variable values are applied to all instances created after this invocation.
Invoke <code>clearEnvironmentVariableOverrides()</code> to reset the rule to use defaults (including any actual environment variables).</p>
</div>
<div class="paragraph">
<p>In your test cases, you can use those properties when creating the connection factory.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConnectionFactory rabbitConnectionFactory() {
    CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
    connectionFactory.setHost(brokerRunning.getHostName());
    connectionFactory.setPort(brokerRunning.getPort());
    connectionFactory.setUsername(brokerRunning.getUser());
    connectionFactory.setPassword(brokerRunning.getPassword());
    return connectionFactory;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_longrunningintegrationtest">Using <code>LongRunningIntegrationTest</code></h5>
<div class="paragraph">
<p><code>LongRunningIntegrationTest</code> is a rule that disables long running tests.
You might want to use this on a developer system but ensure that the rule is disabled on, for example, nightly CI builds.</p>
</div>
<div class="paragraph">
<p>The following example shows its usage:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
public LongRunningIntegrationTest longTests = new LongRunningIntegrationTest();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To disable the rule at runtime, set an environment variable called <code>RUN_LONG_INTEGRATION_TESTS</code> to <code>true</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="junit5-conditions">3.4.5. JUnit5 Conditions</h4>
<div class="paragraph">
<p>Version 2.0.2 introduced support for JUnit5.</p>
</div>
<div class="sect4">
<h5 id="_using_the_rabbitavailable_annotation">Using the <code>@RabbitAvailable</code> Annotation</h5>
<div class="paragraph">
<p>This class-level annotation is similar to the <code>BrokerRunning</code> <code>@Rule</code> discussed in <a href="#junit-rules">JUnit4 <code>@Rules</code></a>.
It is processed by the <code>RabbitAvailableCondition</code>.</p>
</div>
<div class="paragraph">
<p>The annotation has two properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>queues</code>: An array of queues that are declared (and purged) before each test and deleted when all tests are complete.</p>
</li>
<li>
<p><code>management</code>: Set this to <code>true</code> if your tests also require the management plugin installed on the broker.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is used to check whether the broker is available and skip the tests if not.
As discussed in <a href="#brokerRunning-configure">Configuring the Rule</a>, the environment variable called <code>RABBITMQ_SERVER_REQUIRED</code>, if <code>true</code>, causes the tests to fail fast if there is no broker.
You can configure the condition by using environment variables as discussed in <a href="#brokerRunning-configure">Configuring the Rule</a>.</p>
</div>
<div class="paragraph">
<p>In addition, the <code>RabbitAvailableCondition</code> supports argument resolution for parameterized test constructors and methods.
Two argument types are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BrokerRunning</code>: The instance</p>
</li>
<li>
<p><code>ConnectionFactory</code>: The <code>BrokerRunning</code> instance&#8217;s RabbitMQ connection factory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows both:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitAvailable(queues = "rabbitAvailableTests.queue")
public class RabbitAvailableCTORInjectionTests {

    private final ConnectionFactory connectionFactory;

    public RabbitAvailableCTORInjectionTests(BrokerRunning brokerRunning) {
        this.connectionFactory = brokerRunning.getConnectionFactory();
    }

    @Test
    public void test(ConnectionFactory cf) throws Exception {
        assertSame(cf, this.connectionFactory);
        Connection conn = this.connectionFactory.newConnection();
        Channel channel = conn.createChannel();
        DeclareOk declareOk = channel.queueDeclarePassive("rabbitAvailableTests.queue");
        assertEquals(0, declareOk.getConsumerCount());
        channel.close();
        conn.close();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding test is in the framework itself and verifies the argument injection and that the condition created the queue properly.</p>
</div>
<div class="paragraph">
<p>A practical user test might be as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitAvailable(queues = "rabbitAvailableTests.queue")
public class RabbitAvailableCTORInjectionTests {

    private final CachingConnectionFactory connectionFactory;

    public RabbitAvailableCTORInjectionTests(BrokerRunning brokerRunning) {
        this.connectionFactory =
            new CachingConnectionFactory(brokerRunning.getConnectionFactory());
    }

    @Test
    public void test() throws Exception {
        RabbitTemplate template = new RabbitTemplate(this.connectionFactory);
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use a Spring annotation application context within a test class, you can get a reference to the condition&#8217;s connection factory through a static method called <code>RabbitAvailableCondition.getBrokerRunning()</code>.
The following test comes from the framework and demonstrates the usage:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitAvailable(queues = {
        RabbitTemplateMPPIntegrationTests.QUEUE,
        RabbitTemplateMPPIntegrationTests.REPLIES })
@SpringJUnitConfig
@DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)
public class RabbitTemplateMPPIntegrationTests {

    public static final String QUEUE = "mpp.tests";

    public static final String REPLIES = "mpp.tests.replies";

    @Autowired
    private RabbitTemplate template;

    @Autowired
    private Config config;

    @Test
    public void test() {

        ...

    }

    @Configuration
    @EnableRabbit
    public static class Config {

        @Bean
        public CachingConnectionFactory cf() {
            return new CachingConnectionFactory(RabbitAvailableCondition
                    .getBrokerRunning()
                    .getConnectionFactory());
        }

        @Bean
        public RabbitTemplate template() {

            ...

        }

        @Bean
        public SimpleRabbitListenerContainerFactory
                            rabbitListenerContainerFactory() {

            ...

        }

        @RabbitListener(queues = QUEUE)
        public byte[] foo(byte[] in) {
            return in;
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_the_longrunning_annotation">Using the <code>@LongRunning</code> Annotation</h5>
<div class="paragraph">
<p>Similar to the <code>LongRunningIntegrationTest</code> JUnit4 <code>@Rule</code>, this annotation causes tests to be skipped unless an environment variable (or system property) is set to <code>true</code>.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitAvailable(queues = SimpleMessageListenerContainerLongTests.QUEUE)
@LongRunning
public class SimpleMessageListenerContainerLongTests {

    public static final String QUEUE = "SimpleMessageListenerContainerLongTests.queue";

...

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the variable is <code>RUN_LONG_INTEGRATION_TESTS</code>, but you can specify the variable name in the annotation&#8217;s <code>value</code> attribute.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_integration_reference">4. Spring Integration - Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation provides a quick introduction to the AMQP support within the Spring Integration project.</p>
</div>
<div class="sect2">
<h3 id="spring-integration-amqp">4.1. Spring Integration AMQP Support</h3>
<div class="paragraph">
<p>This brief chapter covers the relationship between the Spring Integration and the Spring AMQP projects.</p>
</div>
<div class="sect3">
<h4 id="spring-integration-amqp-introduction">4.1.1. Introduction</h4>
<div class="paragraph">
<p>The <a href="https://www.springsource.org/spring-integration">Spring Integration</a> project includes AMQP Channel Adapters and Gateways that build upon the Spring AMQP project.
Those adapters are developed and released in the Spring Integration project.
In Spring Integration, &#8220;Channel Adapters&#8221; are unidirectional (one-way), whereas &#8220;Gateways&#8221; are bidirectional (request-reply).
We provide an inbound-channel-adapter, an outbound-channel-adapter, an inbound-gateway, and an outbound-gateway.</p>
</div>
<div class="paragraph">
<p>Since the AMQP adapters are part of the Spring Integration release, the documentation is available as part of the Spring Integration distribution.
We provide a quick overview of the main features here.
See the <a href="https://docs.spring.io/spring-integration/reference/htmlsingle/">Spring Integration Reference Guide</a> for much more detail.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inbound_channel_adapter">4.1.2. Inbound Channel Adapter</h4>
<div class="paragraph">
<p>To receive AMQP Messages from a queue, you can configure an <code>&lt;inbound-channel-adapter&gt;</code>.
The following example shows how to configure an inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;amqp:inbound-channel-adapter channel="fromAMQP"
                              queue-names="some.queue"
                              connection-factory="rabbitConnectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_outbound_channel_adapter">4.1.3. Outbound Channel Adapter</h4>
<div class="paragraph">
<p>To send AMQP Messages to an exchange, you can configure an <code>&lt;outbound-channel-adapter&gt;</code>.
You can optionallyi provide a 'routing-key' in addition to the exchange name.
The following example shows how to define an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;amqp:outbound-channel-adapter channel="toAMQP"
                               exchange-name="some.exchange"
                               routing-key="foo"
                               amqp-template="rabbitTemplate"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inbound_gateway">4.1.4. Inbound Gateway</h4>
<div class="paragraph">
<p>To receive an AMQP Message from a queue and respond to its reply-to address, you can configure an <code>&lt;inbound-gateway&gt;</code>.
The following example shows how to define an inbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;amqp:inbound-gateway request-channel="fromAMQP"
                      reply-channel="toAMQP"
                      queue-names="some.queue"
                      connection-factory="rabbitConnectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_outbound_gateway">4.1.5. Outbound Gateway</h4>
<div class="paragraph">
<p>To send AMQP Messages to an exchange and receive back a response from a remote client, you can configure an <code>&lt;outbound-gateway&gt;</code>.
You can optionally provide a 'routing-key' in addition to the exchange name.
The following example shows how to define an outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;amqp:outbound-gateway request-channel="toAMQP"
                       reply-channel="fromAMQP"
                       exchange-name="some.exchange"
                       routing-key="foo"
                       amqp-template="rabbitTemplate"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources">5. Other Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to this reference documentation, there exist a number of other resources that may help you learn about AMQP.</p>
</div>
<div class="sect2">
<h3 id="further-reading">5.1. Further Reading</h3>
<div class="paragraph">
<p>For those who are not familiar with AMQP, the <a href="https://www.amqp.org/resources/download">specification</a> is actually quite readable.
It is, of course, the authoritative source of information, and the Spring AMQP code should be easy to understand for anyone who is familiar with the spec.
Our current implementation of the RabbitMQ support is based on their 2.8.x version, and it officially supports AMQP 0.8 and 0.9.1.
We recommend reading the 0.9.1 document.</p>
</div>
<div class="paragraph">
<p>There are many great articles, presentations, and blogs available on the RabbitMQ <a href="https://www.rabbitmq.com/how.html">Getting Started</a> page.
Since that is currently the only supported implementation for Spring AMQP, we also recommend that as a general starting point for all broker-related concerns.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_change_history">Appendix A: Change History</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes what changes have been made as versions have changed.</p>
</div>
<div class="sect2">
<h3 id="_current_release">A.1. Current Release</h3>
<div class="paragraph">
<p>See <a href="#whats-new">What&#8217;s New</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="previous-whats-new">A.2. Previous Releases</h3>
<div class="sect3">
<h4 id="_changes_in_2_0_since_1_7">A.2.1. Changes in 2.0 Since 1.7</h4>
<div class="sect4">
<h5 id="_using_cachingconnectionfactory">Using <code>CachingConnectionFactory</code></h5>
<div class="paragraph">
<p>Starting with version 2.0.2, you can configure the <code>RabbitTemplate</code> to use a different connection to that used by listener containers.
This change avoids deadlocked consumers when producers are blocked for any reason.
See <a href="#separate-connection">Using a Separate Connection</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_amqp_client_library_2">AMQP Client library</h5>
<div class="paragraph">
<p>Spring AMQP now uses the new 5.0.x version of the <code>amqp-client</code> library provided by the RabbitMQ team.
This client has auto recovery configured by default.
See <a href="#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of version 4.0, the client enables automatic recovery by default.
While compatible with this feature, Spring AMQP has its own recovery mechanisms, and the client recovery feature generally is not needed.
We recommend that you disable <code>amqp-client</code> automatic recovery, to avoid getting <code>AutoRecoverConnectionNotCurrentlyOpenException</code> instances when the broker is available but the connection has not yet recovered.
Starting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the <code>CachingConnectionFactory</code>.
RabbitMQ <code>ConnectionFactory</code> instances created by the <code>RabbitConnectionFactoryBean</code> also have the option disabled by default.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_general_changes">General Changes</h5>
<div class="paragraph">
<p>The <code>ExchangeBuilder</code> now builds durable exchanges by default.
The <code>@Exchange</code> annotation used within a <code>@QeueueBinding</code> also declares durable exchanges by default.
The <code>@Queue</code> annotation used within a <code>@RabbitListener</code> by default declares durable queues if named and non-durable if anonymous.
See <a href="#builder-api">Builder API for Queues and Exchanges</a> and <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_deleted_classes">Deleted Classes</h5>
<div class="paragraph">
<p><code>UniquelyNameQueue</code> is no longer provided.
It is unusual to create a durable non-auto-delete queue with a unique name.
This class has been deleted.
If you require its functionality, use <code>new Queue(UUID.randomUUID().toString())</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_new_listener_container">New Listener Container</h5>
<div class="paragraph">
<p>The <code>DirectMessageListenerContainer</code> has been added alongside the existing <code>SimpleMessageListenerContainer</code>.
See <a href="#choose-container">Choosing a Container</a> and <a href="#containerAttributes">Message Listener Container Configuration</a> for information about choosing which container to use as well as how to configure them.</p>
</div>
</div>
<div class="sect4">
<h5 id="_log4j_appender">Log4j Appender</h5>
<div class="paragraph">
<p>This appender is no longer available due to the end-of-life of log4j.
See <a href="#logging">Logging Subsystem AMQP Appenders</a> for information about the available log appenders.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_changes_2"><code>RabbitTemplate</code> Changes</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Previously, a non-transactional <code>RabbitTemplate</code> participated in an existing transaction if it ran on a transactional listener container thread.
This was a serious bug.
However, users might have relied on this behavior.
Starting with version 1.6.2, you must set the <code>channelTransacted</code> boolean on the template for it to participate in the container transaction.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> now uses a <code>DirectReplyToMessageListenerContainer</code> (by default) instead of creating a new consumer for each request.
See <a href="#direct-reply-to">RabbitMQ Direct reply-to</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>AsyncRabbitTemplate</code> now supports direct reply-to.
See <a href="#async-template"><code>AsyncRabbitTemplate</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> and <code>AsyncRabbitTemplate</code> now have <code>receiveAndConvert</code> and <code>convertSendAndReceiveAsType</code> methods that take a <code>ParameterizedTypeReference&lt;T&gt;</code> argument, letting the caller specify the type to which to convert the result.
This is particularly useful for complex types or when type information is not conveyed in message headers.
It requires a <code>SmartMessageConverter</code> such as the <code>Jackson2JsonMessageConverter</code>.
See <a href="#receiving-messages">Receiving Messages</a>, <a href="#request-reply">Request/Reply Messaging</a>, <a href="#async-template"><code>AsyncRabbitTemplate</code></a>, and <a href="#json-complex">Converting From a <code>Message</code> With <code>RabbitTemplate</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now use a <code>RabbitTemplate</code> to perform multiple operations on a dedicated channel.
See <a href="#scoped-operations">Scoped Operations</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_adapter">Listener Adapter</h5>
<div class="paragraph">
<p>A convenient <code>FunctionalInterface</code> is available for using lambdas with the <code>MessageListenerAdapter</code>.
See <a href="#message-listener-adapter"><code>MessageListenerAdapter</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_changes_2">Listener Container Changes</h5>
<div class="sect5">
<h6 id="_prefetch_default_value">Prefetch Default Value</h6>
<div class="paragraph">
<p>The prefetch default value used to be 1, which could lead to under-utilization of efficient consumers.
The default prefetch value is now 250, which should keep consumers busy in most common scenarios and,
thus, improve throughput.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
There are scenarios where the prefetch value should
be low&#8201;&#8212;&#8201;for example, with large messages, especially if the processing is slow (messages could add up
to a large amount of memory in the client process), and if strict message ordering is necessary
(the prefetch value should be set back to 1 in this case).
Also, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more background about prefetch, see this post about <a href="https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/">consumer utilization in RabbitMQ</a>
and this post about <a href="https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/">queuing theory</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_message_count">Message Count</h6>
<div class="paragraph">
<p>Previously, <code>MessageProperties.getMessageCount()</code> returned <code>0</code> for messages emitted by the container.
This property applies only when you use <code>basicGet</code> (for example, from <code>RabbitTemplate.receive()</code> methods) and is now initialized to <code>null</code> for container messages.</p>
</div>
</div>
<div class="sect5">
<h6 id="_transaction_rollback_behavior">Transaction Rollback Behavior</h6>
<div class="paragraph">
<p>Message re-queue on transaction rollback is now consistent, regardless of whether or not a transaction manager is configured.
See <a href="#transaction-rollback">A note on Rollback of Received Messages</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_shutdown_behavior">Shutdown Behavior</h6>
<div class="paragraph">
<p>If the container threads do not respond to a shutdown within <code>shutdownTimeout</code>, the channels are forced closed by default.
See <a href="#containerAttributes">Message Listener Container Configuration</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_after_receive_message_post_processors">After Receive Message Post Processors</h6>
<div class="paragraph">
<p>If a <code>MessagePostProcessor</code> in the <code>afterReceiveMessagePostProcessors</code> property returns <code>null</code>, the message is discarded (and acknowledged if appropriate).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_connection_factory_changes_2">Connection Factory Changes</h5>
<div class="paragraph">
<p>The connection and channel listener interfaces now provide a mechanism to obtain information about exceptions.
See <a href="#connection-channel-listeners">Connection and Channel Listeners</a> and <a href="#publishing-is-async">Publishing is Asynchronous&#8201;&#8212;&#8201;How to Detect Successes and Failures</a> for more information.</p>
</div>
<div class="paragraph">
<p>A new <code>ConnectionNameStrategy</code> is now provided to populate the application-specific identification of the target RabbitMQ connection from the <code>AbstractConnectionFactory</code>.
See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_retry_changes">Retry Changes</h5>
<div class="paragraph">
<p>The <code>MissingMessageIdAdvice</code> is no longer provided.
Its functionality is now built-in.
See <a href="#retry">Failures in Synchronous Operations and Options for Retry</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_anonymous_queue_naming">Anonymous Queue Naming</h5>
<div class="paragraph">
<p>By default, <code>AnonymousQueues</code> are now named with the default <code>Base64UrlNamingStrategy</code> instead of a simple <code>UUID</code> string.
See <a href="#anonymous-queue"><code>AnonymousQueue</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitlistener_changes_2"><code>@RabbitListener</code> Changes</h5>
<div class="paragraph">
<p>You can now provide simple queue declarations (bound only to the default exchange) in <code>@RabbitListener</code> annotations.
See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now configure <code>@RabbitListener</code> annotations so that any exceptions are returned to the sender.
You can also configure a <code>RabbitListenerErrorHandler</code> to handle exceptions.
See <a href="#annotation-error-handling">Handling Exceptions</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now bind a queue with multiple routing keys when you use the <code>@QueueBinding</code> annotation.
Also <code>@QueueBinding.exchange()</code> now supports custom exchange types and declares durable exchanges by default.</p>
</div>
<div class="paragraph">
<p>You can now set the <code>concurrency</code> of the listener container at the annotation level rather than having to configure a different container factory for different concurrency settings.</p>
</div>
<div class="paragraph">
<p>You can now set the <code>autoStartup</code> property of the listener container at the annotation level, overriding the default setting in the container factory.</p>
</div>
<div class="paragraph">
<p>You can now set after receive and before send (reply) <code>MessagePostProcessor</code> instances in the <code>RabbitListener</code> container factories.</p>
</div>
<div class="paragraph">
<p>See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0.3, one of the <code>@RabbitHandler</code> annotationss on a class-level <code>@RabbitListener</code> can be designated as the default.
See <a href="#annotation-method-selection">Multi-method Listeners</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_container_conditional_rollback">Container Conditional Rollback</h5>
<div class="paragraph">
<p>When using an external transaction manager (such as JDBC), rule-based rollback is now supported when you provide the container with a transaction attribute.
It is also now more flexible when you use a transaction advice.
See <a href="#conditional-rollback">Conditional Rollback</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_remove_jackson_1_x_support">Remove Jackson 1.x support</h5>
<div class="paragraph">
<p>Deprecated in previous versions, Jackson <code>1.x</code> converters and related components have now been deleted.
You can use similar components based on Jackson 2.x.
See <a href="#json-message-converter">Jackson2JsonMessageConverter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_json_message_converter">JSON Message Converter</h5>
<div class="paragraph">
<p>When the <code><em>TypeId</em></code> is set to <code>Hashtable</code> for an inbound JSON message, the default conversion type is now <code>LinkedHashMap</code>.
Previously, it was <code>Hashtable</code>.
To revert to a <code>Hashtable</code>, you can use <code>setDefaultMapType</code> on the <code>DefaultClassMapper</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_xml_parsers">XML Parsers</h5>
<div class="paragraph">
<p>When parsing <code>Queue</code> and <code>Exchange</code> XML components, the parsers no longer register the <code>name</code> attribute value as a bean alias if an <code>id</code> attribute is present.
See <a href="#note-id-name">A Note On the <code>id</code> and <code>name</code> Attributes</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_blocked_connection">Blocked Connection</h5>
<div class="paragraph">
<p>You can now inject the <code>com.rabbitmq.client.BlockedListener</code> into the <code>org.springframework.amqp.rabbit.connection.Connection</code> object.
Also, the <code>ConnectionBlockedEvent</code> and <code>ConnectionUnblockedEvent</code> events are emitted by the <code>ConnectionFactory</code> when the connection is blocked or unblocked by the Broker.</p>
</div>
<div class="paragraph">
<p>See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_1_7_since_1_6">A.2.2. Changes in 1.7 Since 1.6</h4>
<div class="sect4">
<h5 id="_amqp_client_library_3">AMQP Client library</h5>
<div class="paragraph">
<p>Spring AMQP now uses the new 4.0.x version of the <code>amqp-client</code> library provided by the RabbitMQ team.
This client has auto-recovery configured by default.
See <a href="#auto-recovery">RabbitMQ Automatic Connection/Topology recovery</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 4.0.x client enables automatic recovery by default.
While compatible with this feature, Spring AMQP has its own recovery mechanisms, and the client recovery feature generally is not needed.
We recommend disabling <code>amqp-client</code> automatic recovery, to avoid getting <code>AutoRecoverConnectionNotCurrentlyOpenException</code> instances when the broker is available but the connection has not yet recovered.
Starting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the <code>CachingConnectionFactory</code>.
RabbitMQ <code>ConnectionFactory</code> instances created by the <code>RabbitConnectionFactoryBean</code> also have the option disabled by default.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_log4j_2_upgrade">Log4j 2 upgrade</h5>
<div class="paragraph">
<p>The minimum Log4j 2 version (for the <code>AmqpAppender</code>) is now <code>2.7</code>.
The framework is no longer compatible with previous versions.
See <a href="#logging">Logging Subsystem AMQP Appenders</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_logback_appender_2">Logback Appender</h5>
<div class="paragraph">
<p>This appender no longer captures caller data (method, line number) by default.
You can re-enable it by setting the <code>includeCallerData</code> configuration option.
See <a href="#logging">Logging Subsystem AMQP Appenders</a> for information about the available log appenders.</p>
</div>
</div>
<div class="sect4">
<h5 id="_spring_retry_upgrade">Spring Retry Upgrade</h5>
<div class="paragraph">
<p>The minimum Spring Retry version is now <code>1.2</code>.
The framework is no longer compatible with previous versions.</p>
</div>
<div class="sect5">
<h6 id="_shutdown_behavior_2">Shutdown Behavior</h6>
<div class="paragraph">
<p>You can now set <code>forceCloseChannel</code> to <code>true</code> so that, if the container threads do not respond to a shutdown within <code>shutdownTimeout</code>, the channels are forced closed,
causing any unacked messages to be re-queued.
See <a href="#containerAttributes">Message Listener Container Configuration</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fasterxml_jackson_upgrade">FasterXML Jackson upgrade</h5>
<div class="paragraph">
<p>The minimum Jackson version is now <code>2.8</code>.
The framework is no longer compatible with previous versions.</p>
</div>
</div>
<div class="sect4">
<h5 id="_junit_rules">JUnit <code>@Rules</code></h5>
<div class="paragraph">
<p>Rules that have previously been used internally by the framework have now been made available in a separate jar called <code>spring-rabbit-junit</code>.
See <a href="#junit-rules">JUnit4 <code>@Rules</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_container_conditional_rollback_2">Container Conditional Rollback</h5>
<div class="paragraph">
<p>When you use an external transaction manager (such as JDBC), rule-based rollback is now supported when you provide the container with a transaction attribute.
It is also now more flexible when you use a transaction advice.</p>
</div>
</div>
<div class="sect4">
<h5 id="_connection_naming_strategy">Connection Naming Strategy</h5>
<div class="paragraph">
<p>A new <code>ConnectionNameStrategy</code> is now provided to populate the application-specific identification of the target RabbitMQ connection from the <code>AbstractConnectionFactory</code>.
See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_changes_3">Listener Container Changes</h5>
<div class="sect5">
<h6 id="_transaction_rollback_behavior_2">Transaction Rollback Behavior</h6>
<div class="paragraph">
<p>You can now configure message re-queue on transaction rollback to be consistent, regardless of whether or not a transaction manager is configured.
See <a href="#transaction-rollback">A note on Rollback of Received Messages</a> for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_earlier_releases">A.2.3. Earlier Releases</h4>
<div class="paragraph">
<p>See <a href="#previous-whats-new">Previous Releases</a> for changes in previous versions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_1_6_since_1_5">A.2.4. Changes in 1.6 Since 1.5</h4>
<div class="sect4">
<h5 id="_testing_support">Testing Support</h5>
<div class="paragraph">
<p>A new testing support library is now provided.
See <a href="#testing">Testing Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_builder">Builder</h5>
<div class="paragraph">
<p>Builders that provide a fluent API for configuring <code>Queue</code> and <code>Exchange</code> objects are now available.
See <a href="#builder-api">Builder API for Queues and Exchanges</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_namespace_changes">Namespace Changes</h5>
<div class="sect5">
<h6 id="_connection_factory">Connection Factory</h6>
<div class="paragraph">
<p>You can now add a <code>thread-factory</code> to a connection factory bean declaration&#8201;&#8212;&#8201;for example, to name the threads
created by the <code>amqp-client</code> library.
See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
<div class="paragraph">
<p>When you use <code>CacheMode.CONNECTION</code>, you can now limit the total number of connections allowed.
See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_queue_definitions">Queue Definitions</h6>
<div class="paragraph">
<p>You can now provide a naming strategy for anonymous queues.
See <a href="#anonymous-queue"><code>AnonymousQueue</code></a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_changes_4">Listener Container Changes</h5>
<div class="sect5">
<h6 id="_idle_message_listener_detection">Idle Message Listener Detection</h6>
<div class="paragraph">
<p>You can now configure listener containers to publish <code>ApplicationEvent</code> instances when idle.
See <a href="#idle-containers">Detecting Idle Asynchronous Consumers</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_mismatched_queue_detection">Mismatched Queue Detection</h6>
<div class="paragraph">
<p>By default, when a listener container starts, if queues with mismatched properties or arguments are detected,
the container logs the exception but continues to listen.
The container now has a property called <code>mismatchedQueuesFatal</code>, which prevents the container (and context) from
starting if the problem is detected during startup.
It also stops the container if the problem is detected later, such as after recovering from a connection failure.
See <a href="#containerAttributes">Message Listener Container Configuration</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_listener_container_logging">Listener Container Logging</h6>
<div class="paragraph">
<p>Now, listener container provides its <code>beanName</code> to the internal <code>SimpleAsyncTaskExecutor</code> as a <code>threadNamePrefix</code>.
It is useful for logs analysis.</p>
</div>
</div>
<div class="sect5">
<h6 id="_default_error_handler">Default Error Handler</h6>
<div class="paragraph">
<p>The default error handler (<code>ConditionalRejectingErrorHandler</code>) now considers irrecoverable <code>@RabbitListener</code>
exceptions as fatal.
See <a href="#exception-handling">Exception Handling</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_autodeclare_and_rabbitadmin_instances"><code>AutoDeclare</code> and <code>RabbitAdmin</code> Instances</h5>
<div class="paragraph">
<p>See <a href="#containerAttributes">Message Listener Container Configuration</a> (<code>autoDeclare</code>) for some changes to the semantics of that option with respect to the use
of <code>RabbitAdmin</code> instances in the application context.</p>
</div>
</div>
<div class="sect4">
<h5 id="_amqptemplate_receive_with_timeout"><code>AmqpTemplate</code>: Receive with Timeout</h5>
<div class="paragraph">
<p>A number of new <code>receive()</code> methods with <code>timeout</code> have been introduced for the <code>AmqpTemplate</code>
and its <code>RabbitTemplate</code> implementation.
See <a href="#polling-consumer">Polling Consumer</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_asyncrabbittemplate">Using <code>AsyncRabbitTemplate</code></h5>
<div class="paragraph">
<p>A new <code>AsyncRabbitTemplate</code> has been introduced.
This template provides a number of send and receive methods, where the return value is a <code>ListenableFuture</code>, which can
be used later to obtain the result either synchronously or asynchronously.
See <a href="#async-template"><code>AsyncRabbitTemplate</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_changes_3"><code>RabbitTemplate</code> Changes</h5>
<div class="paragraph">
<p>1.4.1 introduced the ability to use <a href="https://www.rabbitmq.com/direct-reply-to.html">direct reply-to</a> when the broker supports it.
It is more efficient than using a temporary queue for each reply.
This version lets you override this default behavior and use a temporary queue by setting the <code>useTemporaryReplyQueues</code> property to <code>true</code>.
See <a href="#direct-reply-to">RabbitMQ Direct reply-to</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> now supports a <code>user-id-expression</code> (<code>userIdExpression</code> when using Java configuration).
See <a href="https://www.rabbitmq.com/validated-user-id.html">Validated User-ID RabbitMQ documentation</a> and <a href="#template-user-id">Validated User Id</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_message_properties">Message Properties</h5>
<div class="sect5">
<h6 id="_using_correlationid">Using <code>CorrelationId</code></h6>
<div class="paragraph">
<p>The <code>correlationId</code> message property can now be a <code>String</code>.
See <a href="#message-properties-converters">Message Properties Converters</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_long_string_headers">Long String Headers</h6>
<div class="paragraph">
<p>Previously, the <code>DefaultMessagePropertiesConverter</code> &#8220;converted&#8221; headers longer than the long string limit (default 1024)
to a <code>DataInputStream</code> (actually, it referenced the <code>LongString</code> instance&#8217;s <code>DataInputStream</code>).
On output, this header was not converted (except to a String&#8201;&#8212;&#8201;for example, <code>java.io.DataInputStream@1d057a39</code> by calling
<code>toString()</code> on the stream).</p>
</div>
<div class="paragraph">
<p>With this release, long <code>LongString</code> instances are now left as <code>LongString</code> instances by default.
You can access the contents by using the <code>getBytes[]</code>, <code>toString()</code>, or <code>getStream()</code> methods.
A large incoming <code>LongString</code> is now correctly &#8220;converted&#8221; on output too.</p>
</div>
<div class="paragraph">
<p>See <a href="#message-properties-converters">Message Properties Converters</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_inbound_delivery_mode">Inbound Delivery Mode</h6>
<div class="paragraph">
<p>The <code>deliveryMode</code> property is no longer mapped to the <code>MessageProperties.deliveryMode</code>.
This change avoids unintended propagation if the the same <code>MessageProperties</code> object is used to send an outbound message.
Instead, the inbound <code>deliveryMode</code> header is mapped to <code>MessageProperties.receivedDeliveryMode</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#message-properties-converters">Message Properties Converters</a> for more information.</p>
</div>
<div class="paragraph">
<p>When using annotated endpoints, the header is provided in the header named <code>AmqpHeaders.RECEIVED_DELIVERY_MODE</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#async-annotation-driven-enable-signature">Annotated Endpoint Method Signature</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_inbound_user_id">Inbound User ID</h6>
<div class="paragraph">
<p>The <code>user_id</code> property is no longer mapped to the <code>MessageProperties.userId</code>.
This change avoids unintended propagation if the the same <code>MessageProperties</code> object is used to send an outbound message.
Instead, the inbound <code>userId</code> header is mapped to <code>MessageProperties.receivedUserId</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#message-properties-converters">Message Properties Converters</a> for more information.</p>
</div>
<div class="paragraph">
<p>When you use annotated endpoints, the header is provided in the header named <code>AmqpHeaders.RECEIVED_USER_ID</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#async-annotation-driven-enable-signature">Annotated Endpoint Method Signature</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitadmin_changes_2"><code>RabbitAdmin</code> Changes</h5>
<div class="sect5">
<h6 id="_declaration_failures">Declaration Failures</h6>
<div class="paragraph">
<p>Previously, the <code>ignoreDeclarationFailures</code> flag took effect only for <code>IOException</code> on the channel (such as mis-matched
arguments).
It now takes effect for any exception (such as <code>TimeoutException</code>).
In addition, a <code>DeclarationExceptionEvent</code> is now published whenever a declaration fails.
The <code>RabbitAdmin</code> last declaration event is also available as a property <code>lastDeclarationExceptionEvent</code>.
See <a href="#broker-configuration">Configuring the Broker</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitlistener_changes_3"><code>@RabbitListener</code> Changes</h5>
<div class="sect5">
<h6 id="_multiple_containers_for_each_bean">Multiple Containers for Each Bean</h6>
<div class="paragraph">
<p>When you use Java 8 or later, you can now add multiple <code>@RabbitListener</code> annotations to <code>@Bean</code> classes or
their methods.
When using Java 7 or earlier, you can use the <code>@RabbitListeners</code> container annotation to provide the same
functionality.
See <a href="#repeatable-rabbit-listener"><code>@Repeatable</code> <code>@RabbitListener</code></a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_sendto_spel_expressions"><code>@SendTo</code> SpEL Expressions</h6>
<div class="paragraph">
<p><code>@SendTo</code> for routing replies with no <code>replyTo</code> property can now be SpEL expressions evaluated against the
request/reply.
See <a href="#async-annotation-driven-reply">Reply Management</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_queuebinding_improvements"><code>@QueueBinding</code> Improvements</h6>
<div class="paragraph">
<p>You can now specify arguments for queues, exchanges, and bindings in <code>@QueueBinding</code> annotations.
Header exchanges are now supported by <code>@QueueBinding</code>.
See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_delayed_message_exchange">Delayed Message Exchange</h5>
<div class="paragraph">
<p>Spring AMQP now has first class support for the RabbitMQ Delayed Message Exchange plugin.
See <a href="#delayed-message-exchange">Delayed Message Exchange</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exchange_internal_flag">Exchange Internal Flag</h5>
<div class="paragraph">
<p>Any <code>Exchange</code> definitions can now be marked as <code>internal</code>, and <code>RabbitAdmin</code> passes the value to the broker when
declaring the exchange.
See <a href="#broker-configuration">Configuring the Broker</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cachingconnectionfactory_changes"><code>CachingConnectionFactory</code> Changes</h5>
<div class="sect5">
<h6 id="_cachingconnectionfactory_cache_statistics"><code>CachingConnectionFactory</code> Cache Statistics</h6>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> now provides cache properties at runtime and over JMX.
See <a href="#runtime-cache-properties">Runtime Cache Properties</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_accessing_the_underlying_rabbitmq_connection_factory">Accessing the Underlying RabbitMQ Connection Factory</h6>
<div class="paragraph">
<p>A new getter has been added to provide access to the underlying factory.
You can use this getter, for example, to add custom connection properties.
See <a href="#custom-client-props">Adding Custom Client Connection Properties</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_channel_cache">Channel Cache</h6>
<div class="paragraph">
<p>The default channel cache size has been increased from 1 to 25.
See <a href="#connections">Connection and Resource Management</a> for more information.</p>
</div>
<div class="paragraph">
<p>In addition, the <code>SimpleMessageListenerContainer</code> no longer adjusts the cache size to be at least as large as the number
of <code>concurrentConsumers</code>&#8201;&#8212;&#8201;this was superfluous, since the container consumer channels are never cached.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_rabbitconnectionfactorybean">Using <code>RabbitConnectionFactoryBean</code></h5>
<div class="paragraph">
<p>The factory bean now exposes a property to add client connection properties to connections made by the resulting
factory.</p>
</div>
</div>
<div class="sect4">
<h5 id="_java_deserialization">Java Deserialization</h5>
<div class="paragraph">
<p>You can now configure a &#8220;white list&#8221; of allowable classes when you use Java deserialization.
You should consider creating a white list if you accept messages with serialized java objects from
untrusted sources.
See <a href="#java-deserialization">Java Deserialization</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_json_messageconverter">JSON <code>MessageConverter</code></h5>
<div class="paragraph">
<p>Improvements to the JSON message converter now allow the consumption of messages that do not have type information
in message headers.
See <a href="#async-annotation-conversion">Message Conversion for Annotated Methods</a> and <a href="#json-message-converter">Jackson2JsonMessageConverter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_logging_appenders">Logging Appenders</h5>
<div class="sect5">
<h6 id="_log4j_2">Log4j 2</h6>
<div class="paragraph">
<p>A log4j 2 appender has been added, and the appenders can now be configured with an <code>addresses</code> property to connect
to a broker cluster.</p>
</div>
</div>
<div class="sect5">
<h6 id="_client_connection_properties">Client Connection Properties</h6>
<div class="paragraph">
<p>You can now add custom client connection properties to RabbitMQ connections.</p>
</div>
<div class="paragraph">
<p>See <a href="#logging">Logging Subsystem AMQP Appenders</a> for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_1_5_since_1_4">A.2.5. Changes in 1.5 Since 1.4</h4>
<div class="sect4">
<h5 id="_spring_erlang_is_no_longer_supported"><code>spring-erlang</code> Is No Longer Supported</h5>
<div class="paragraph">
<p>The <code>spring-erlang</code> jar is no longer included in the distribution.
Use <a href="#management-rest-api">the RabbitMQ REST API</a> instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cachingconnectionfactory_changes_2"><code>CachingConnectionFactory</code> Changes</h5>
<div class="sect5">
<h6 id="_empty_addresses_property_in_cachingconnectionfactory">Empty Addresses Property in <code>CachingConnectionFactory</code></h6>
<div class="paragraph">
<p>Previously, if the connection factory was configured with a host and port but an empty String was also supplied for
<code>addresses</code>, the host and port were ignored.
Now, an empty <code>addresses</code> String is treated the same as a <code>null</code>, and the host and port are used.</p>
</div>
</div>
<div class="sect5">
<h6 id="_uri_constructor">URI Constructor</h6>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> has an additional constructor, with a <code>URI</code> parameter, to configure the broker connection.</p>
</div>
</div>
<div class="sect5">
<h6 id="_connection_reset">Connection Reset</h6>
<div class="paragraph">
<p>A new method called <code>resetConnection()</code> has been added to let users reset the connection (or connections).
You might use this, for example, to reconnect to the primary broker after failing over to the secondary broker.
This <strong>does</strong> impact in-process operations.
The existing <code>destroy()</code> method does exactly the same, but the new method has a less daunting name.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_properties_to_control_container_queue_declaration_behavior">Properties to Control Container Queue Declaration Behavior</h5>
<div class="paragraph">
<p>When the listener container consumers start, they attempt to passively declare the queues to ensure they are available
on the broker.
Previously, if these declarations failed (for example, because the queues didn&#8217;t exist) or when an HA queue was being
moved, the retry logic was fixed at three retry attempts at five-second intervals.
If the queues still do not exist, the behavior is controlled by the <code>missingQueuesFatal</code> property (default: <code>true</code>).
Also, for containers configured to listen from multiple queues, if only a subset of queues are available, the consumer
retried the missing queues on a fixed interval of 60 seconds.</p>
</div>
<div class="paragraph">
<p>The <code>declarationRetries</code>, <code>failedDeclarationRetryInterval</code>, and <code>retryDeclarationInterval</code> properties are now configurable.
See <a href="#containerAttributes">Message Listener Container Configuration</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_class_package_change">Class Package Change</h5>
<div class="paragraph">
<p>The <code>RabbitGatewaySupport</code> class has been moved from <code>o.s.amqp.rabbit.core.support</code> to <code>o.s.amqp.rabbit.core</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_defaultmessagepropertiesconverter_changes"><code>DefaultMessagePropertiesConverter</code> Changes</h5>
<div class="paragraph">
<p>You can now configure the <code>DefaultMessagePropertiesConverter</code> to
determine the maximum length of a <code>LongString</code> that is converted
to a <code>String</code> rather than to a <code>DataInputStream</code>.
The converter has an alternative constructor that takes the value as a limit.
Previously, this limit was hard-coded at <code>1024</code> bytes.
(Also available in 1.4.4).</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitlistener_improvements"><code>@RabbitListener</code> Improvements</h5>
<div class="sect5">
<h6 id="_queuebinding_for_rabbitlistener"><code>@QueueBinding</code> for <code>@RabbitListener</code></h6>
<div class="paragraph">
<p>The <code>bindings</code> attribute has been added to the <code>@RabbitListener</code> annotation as mutually exclusive with the <code>queues</code>
attribute to allow the specification of the <code>queue</code>, its <code>exchange</code>, and <code>binding</code> for declaration by a <code>RabbitAdmin</code> on
the Broker.</p>
</div>
</div>
<div class="sect5">
<h6 id="_spel_in_sendto">SpEL in <code>@SendTo</code></h6>
<div class="paragraph">
<p>The default reply address (<code>@SendTo</code>) for a <code>@RabbitListener</code> can now be a SpEL expression.</p>
</div>
</div>
<div class="sect5">
<h6 id="_multiple_queue_names_through_properties">Multiple Queue Names through Properties</h6>
<div class="paragraph">
<p>You can now use a combination of SpEL and property placeholders to specify multiple queues for a listener.</p>
</div>
<div class="paragraph">
<p>See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_automatic_exchange_queue_and_binding_declaration">Automatic Exchange, Queue, and Binding Declaration</h5>
<div class="paragraph">
<p>You can now declare beans that define a collection of these entities, and the <code>RabbitAdmin</code> adds the
contents to the list of entities that it declares when a connection is established.
See <a href="#collection-declaration">Declaring Collections of Exchanges, Queues, and Bindings</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_changes_4"><code>RabbitTemplate</code> Changes</h5>
<div class="sect5">
<h6 id="_reply_address_added"><code>reply-address</code> Added</h6>
<div class="paragraph">
<p>The <code>reply-address</code> attribute has been added to the <code>&lt;rabbit-template&gt;</code> component as an alternative <code>reply-queue</code>.
See <a href="#request-reply">Request/Reply Messaging</a> for more information.
(Also available in 1.4.4 as a setter on the <code>RabbitTemplate</code>).</p>
</div>
</div>
<div class="sect5">
<h6 id="_blocking_receive_methods">Blocking <code>receive</code> Methods</h6>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> now supports blocking in <code>receive</code> and <code>convertAndReceive</code> methods.
See <a href="#polling-consumer">Polling Consumer</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_mandatory_with_sendandreceive_methods">Mandatory with <code>sendAndReceive</code> Methods</h6>
<div class="paragraph">
<p>When the <code>mandatory</code> flag is set when using the <code>sendAndReceive</code> and <code>convertSendAndReceive</code> methods, the calling thread
throws an <code>AmqpMessageReturnedException</code> if the request message cannot be deliverted.
See <a href="#reply-timeout">Reply Timeout</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_improper_reply_listener_configuration">Improper Reply Listener Configuration</h6>
<div class="paragraph">
<p>The framework tries to verify proper configuration of a reply listener container when using a named reply queue.</p>
</div>
<div class="paragraph">
<p>See <a href="#reply-listener">Reply Listener Container</a> for more information.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitmanagementtemplate_added"><code>RabbitManagementTemplate</code> Added</h5>
<div class="paragraph">
<p>The <code>RabbitManagementTemplate</code> has been introduced to monitor and configure the RabbitMQ Broker by using the REST API provided by its <a href="https://www.rabbitmq.com/management.html">management plugin</a>.
See <a href="#management-rest-api">RabbitMQ REST API</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_bean_names_xml">Listener Container Bean Names (XML)</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>id</code> attribute on the <code>&lt;listener-container/&gt;</code> element has been removed.
Starting with this release, the <code>id</code> on the <code>&lt;listener/&gt;</code> child element is used alone to name the listener container bean created for each listener element.</p>
</div>
<div class="paragraph">
<p>Normal Spring bean name overrides are applied.
If a later <code>&lt;listener/&gt;</code> is parsed with the same <code>id</code> as an existing bean, the new definition overrides the existing one.
Previously, bean names were composed from the <code>id</code> attributes of the <code>&lt;listener-container/&gt;</code> and <code>&lt;listener/&gt;</code> elements.</p>
</div>
<div class="paragraph">
<p>When migrating to this release, if you have <code>id</code> attributes on your <code>&lt;listener-container/&gt;</code> elements, remove them and set the <code>id</code> on the child <code>&lt;listener/&gt;</code> element instead.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>However, to support starting and stopping containers as a group, a new <code>group</code> attribute has been added.
When this attribute is defined, the containers created by this element are added to a bean with this name, of type <code>Collection&lt;SimpleMessageListenerContainer&gt;</code>.
You can iterate over this group to start and stop containers.</p>
</div>
</div>
<div class="sect4">
<h5 id="_class_level_rabbitlistener">Class-Level <code>@RabbitListener</code></h5>
<div class="paragraph">
<p>The <code>@RabbitListener</code> annotation can now be applied at the class level.
Together with the new <code>@RabbitHandler</code> method annotation, this lets you select the handler method based on payload type.
See <a href="#annotation-method-selection">Multi-method Listeners</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_simplemessagelistenercontainer_backoff_support"><code>SimpleMessageListenerContainer</code>: BackOff Support</h5>
<div class="paragraph">
<p>The <code>SimpleMessageListenerContainer</code> can now be supplied with a <code>BackOff</code> instance for <code>consumer</code> startup recovery.
See <a href="#containerAttributes">Message Listener Container Configuration</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_channel_close_logging">Channel Close Logging</h5>
<div class="paragraph">
<p>A mechanism to control the log levels of channel closure has been introduced.
See <a href="#channel-close-logging">Logging Channel Close Events</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_application_events">Application Events</h5>
<div class="paragraph">
<p>The <code>SimpleMessageListenerContainer</code> now emits application events when consumers fail.
See <a href="#consumer-events">Consumer Events</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_tag_configuration">Consumer Tag Configuration</h5>
<div class="paragraph">
<p>Previously, the consumer tags for asynchronous consumers were generated by the broker.
With this release, it is now possible to supply a naming strategy to the listener container.
See <a href="#consumerTags">Consumer Tags</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_messagelisteneradapter">Using <code>MessageListenerAdapter</code></h5>
<div class="paragraph">
<p>The <code>MessageListenerAdapter</code> now supports a map of queue names (or consumer tags) to method names, to determine
which delegate method to call based on the queue from which the message was received.</p>
</div>
</div>
<div class="sect4">
<h5 id="_localizedqueueconnectionfactory_added"><code>LocalizedQueueConnectionFactory</code> Added</h5>
<div class="paragraph">
<p><code>LocalizedQueueConnectionFactory</code> is a new connection factory that connects to the node in a cluster where a mirrored queue actually resides.</p>
</div>
<div class="paragraph">
<p>See <a href="#queue-affinity">Queue Affinity and the <code>LocalizedQueueConnectionFactory</code></a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_anonymous_queue_naming_2">Anonymous Queue Naming</h5>
<div class="paragraph">
<p>Starting with version 1.5.3, you can now control how <code>AnonymousQueue</code> names are generated.
See <a href="#anonymous-queue"><code>AnonymousQueue</code></a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_1_4_since_1_3">A.2.6. Changes in 1.4 Since 1.3</h4>
<div class="sect4">
<h5 id="_rabbitlistener_annotation"><code>@RabbitListener</code> Annotation</h5>
<div class="paragraph">
<p>POJO listeners can be annotated with <code>@RabbitListener</code>, enabled by <code>@EnableRabbit</code> or <code>&lt;rabbit:annotation-driven /&gt;</code>.
Spring Framework 4.1 is required for this feature.
See <a href="#async-annotation-driven">Annotation-driven Listener Endpoints</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitmessagingtemplate_added"><code>RabbitMessagingTemplate</code> Added</h5>
<div class="paragraph">
<p>A new <code>RabbitMessagingTemplate</code> lets you interact with RabbitMQ by using <code>spring-messaging</code> <code>Message</code> instances.
Internally, it uses the <code>RabbitTemplate</code>, which you can configure as normal.
Spring Framework 4.1 is required for this feature.
See <a href="#template-messaging">Messaging Integration</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_missingqueuesfatal_attribute">Listener Container <code>missingQueuesFatal</code> Attribute</h5>
<div class="paragraph">
<p>1.3.5 introduced the <code>missingQueuesFatal</code> property on the <code>SimpleMessageListenerContainer</code>.
This is now available on the listener container namespace element.
See <a href="#containerAttributes">Message Listener Container Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_confirmcallback_interface">RabbitTemplate <code>ConfirmCallback</code> Interface</h5>
<div class="paragraph">
<p>The <code>confirm</code> method on this interface has an additional parameter called <code>cause</code>.
When available, this parameter contains the reason for a negative acknowledgement (nack).
See <a href="#template-confirms">Publisher Confirms and Returns</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitconnectionfactorybean_added"><code>RabbitConnectionFactoryBean</code> Added</h5>
<div class="paragraph">
<p><code>RabbitConnectionFactoryBean</code> creates the underlying RabbitMQ <code>ConnectionFactory</code> used by the <code>CachingConnectionFactory</code>.
This enables configuration of SSL options using Spring&#8217;s dependency injection.
See <a href="#connection-factory">Configuring the Underlying Client Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_cachingconnectionfactory_2">Using <code>CachingConnectionFactory</code></h5>
<div class="paragraph">
<p>The <code>CachingConnectionFactory</code> now lets the <code>connectionTimeout</code> be set as a property or as an attribute in the namespace.
It sets the property on the underlying RabbitMQ <code>ConnectionFactory</code>.
See <a href="#connection-factory">Configuring the Underlying Client Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_log_appender">Log Appender</h5>
<div class="paragraph">
<p>The Logback <code>org.springframework.amqp.rabbit.logback.AmqpAppender</code> has been introduced.
It provides options similar to <code>org.springframework.amqp.rabbit.log4j.AmqpAppender</code>.
For more information, see the JavaDoc of these classes.</p>
</div>
<div class="paragraph">
<p>The Log4j <code>AmqpAppender</code> now supports the <code>deliveryMode</code> property (<code>PERSISTENT</code> or <code>NON_PERSISTENT</code>, default: <code>PERSISTENT</code>).
Previously, all log4j messages were <code>PERSISTENT</code>.</p>
</div>
<div class="paragraph">
<p>The appender also supports modification of the <code>Message</code> before sending&#8201;&#8212;&#8201;allowing, for example, the addition of custom headers.
Subclasses should override the <code>postProcessMessageBeforeSend()</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_queues">Listener Queues</h5>
<div class="paragraph">
<p>The listener container now, by default, redeclares any missing queues during startup.
A new <code>auto-declare</code> attribute has been added to the <code>&lt;rabbit:listener-container&gt;</code> to prevent these re-declarations.
See <a href="#lc-auto-delete"><code>auto-delete</code> Queues</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_mandatory_and_connectionfactoryselector_expressions"><code>RabbitTemplate</code>: <code>mandatory</code> and <code>connectionFactorySelector</code> Expressions</h5>
<div class="paragraph">
<p>The <code>mandatoryExpression</code>, <code>sendConnectionFactorySelectorExpression</code>, and <code>receiveConnectionFactorySelectorExpression</code> SpEL Expression`s properties have been added to <code>RabbitTemplate</code>.
The <code>mandatoryExpression</code> is used to evaluate a <code>mandatory</code> boolean value against each request message when a <code>ReturnCallback</code> is in use.
See <a href="#template-confirms">Publisher Confirms and Returns</a>.
The <code>sendConnectionFactorySelectorExpression</code> and <code>receiveConnectionFactorySelectorExpression</code> are used when an <code>AbstractRoutingConnectionFactory</code> is provided, to determine the <code>lookupKey</code> for the target <code>ConnectionFactory</code> at runtime on each AMQP protocol interaction operation.
See <a href="#routing-connection-factory">Routing Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listeners_and_the_routing_connection_factory">Listeners and the Routing Connection Factory</h5>
<div class="paragraph">
<p>You can configure a <code>SimpleMessageListenerContainer</code> with a routing connection factory to enable connection selection based on the queue names.
See <a href="#routing-connection-factory">Routing Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbittemplate_recoverycallback_option"><code>RabbitTemplate</code>: <code>RecoveryCallback</code> Option</h5>
<div class="paragraph">
<p>The <code>recoveryCallback</code> property has been added for use in the <code>retryTemplate.execute()</code>.
See <a href="#template-retry">Adding Retry Capabilities</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_messageconversionexception_change"><code>MessageConversionException</code> Change</h5>
<div class="paragraph">
<p>This exception is now a subclass of <code>AmqpException</code>.
Consider the following code:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
    template.convertAndSend("thing1", "thing2", "cat");
}
catch (AmqpException e) {
	...
}
catch (MessageConversionException e) {
	...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second catch block is no longer reachable and needs to be moved above the catch-all <code>AmqpException</code> catch block.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitmq_3_4_compatibility">RabbitMQ 3.4 Compatibility</h5>
<div class="paragraph">
<p>Spring AMQP is now compatible with the RabbitMQ 3.4, including direct reply-to.
See <a href="#compatibility">Compatibility</a> and <a href="#direct-reply-to">RabbitMQ Direct reply-to</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="_contenttypedelegatingmessageconverter_added"><code>ContentTypeDelegatingMessageConverter</code> Added</h5>
<div class="paragraph">
<p>The <code>ContentTypeDelegatingMessageConverter</code> has been introduced to select the <code>MessageConverter</code> to use, based on the <code>contentType</code> property in the <code>MessageProperties</code>.
See <a href="#message-converters">Message Converters</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_1_3_since_1_2">A.2.7. Changes in 1.3 Since 1.2</h4>
<div class="sect4">
<h5 id="_listener_concurrency">Listener Concurrency</h5>
<div class="paragraph">
<p>The listener container now supports dynamic scaling of the number of consumers based on workload, or you can programmatically change the concurrency without stopping the container.
See <a href="#listener-concurrency">Listener Concurrency</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_queues_2">Listener Queues</h5>
<div class="paragraph">
<p>The listener container now permits the queues on which it listens to be modified at runtime.
Also, the container now starts if at least one of its configured queues is available for use.
See <a href="#listener-queues">Listener Container Queues</a></p>
</div>
<div class="paragraph">
<p>This listener container now redeclares any auto-delete queues during startup.
See <a href="#lc-auto-delete"><code>auto-delete</code> Queues</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_priority">Consumer Priority</h5>
<div class="paragraph">
<p>The listener container now supports consumer arguments, letting the <code>x-priority</code> argument be set.
See <a href="#consumer-priority">Consumer Priority</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_exclusive_consumer">Exclusive Consumer</h5>
<div class="paragraph">
<p>You can now configure <code>SimpleMessageListenerContainer</code> with a single <code>exclusive</code> consumer, preventing other consumers from listening to the queue.
See <a href="#exclusive-consumer">Exclusive Consumer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbit_admin">Rabbit Admin</h5>
<div class="paragraph">
<p>You can now have the broker generate the queue name, regardless of <code>durable</code>, <code>autoDelete</code>, and <code>exclusive</code> settings.
See <a href="#broker-configuration">Configuring the Broker</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_direct_exchange_binding">Direct Exchange Binding</h5>
<div class="paragraph">
<p>Previously, omitting the <code>key</code> attribute from a <code>binding</code> element of a <code>direct-exchange</code> configuration caused the queue or exchange to be bound with an empty string as the routing key.
Now it is bound with the the name of the provided <code>Queue</code> or <code>Exchange</code>.
If you wish to bind with an empty string routing key, you need to specify <code>key=""</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_amqptemplate_changes"><code>AmqpTemplate</code> Changes</h5>
<div class="paragraph">
<p>The <code>AmqpTemplate</code> now provides several synchronous <code>receiveAndReply</code> methods.
These are implemented by the <code>RabbitTemplate</code>.
For more information see <a href="#receiving-messages">Receiving Messages</a>.</p>
</div>
<div class="paragraph">
<p>The <code>RabbitTemplate</code> now supports configuring a <code>RetryTemplate</code> to attempt retries (with optional back-off policy) for when the broker is not available.
For more information see <a href="#template-retry">Adding Retry Capabilities</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_caching_connection_factory">Caching Connection Factory</h5>
<div class="paragraph">
<p>You can now configure the caching connection factory to cache <code>Connection</code> instances and their <code>Channel</code> instances instead of using a single connection and caching only <code>Channel</code> instances.
See <a href="#connections">Connection and Resource Management</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_binding_arguments">Binding Arguments</h5>
<div class="paragraph">
<p>The <code>&lt;binding&gt;</code> of the <code>&lt;exchange&gt;</code> now supports parsing of the <code>&lt;binding-arguments&gt;</code> sub-element.
You can now configure the <code>&lt;binding&gt;</code> of the <code>&lt;headers-exchange&gt;</code> with a <code>key/value</code> attribute pair (to match on a single header) or with a <code>&lt;binding-arguments&gt;</code> sub-element (allowing matching on multiple headers).
These options are mutually exclusive.
See <a href="#headers-exchange">Headers Exchange</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_routing_connection_factory">Routing Connection Factory</h5>
<div class="paragraph">
<p>A new <code>SimpleRoutingConnectionFactory</code> has been introduced.
It allows configuration of <code>ConnectionFactories</code> mapping, to determine the target <code>ConnectionFactory</code> to use at runtime.
See <a href="#routing-connection-factory">Routing Connection Factory</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_messagebuilder_and_messagepropertiesbuilder"><code>MessageBuilder</code> and <code>MessagePropertiesBuilder</code></h5>
<div class="paragraph">
<p>&#8220;Fluent APIs&#8221; for building messages or message properties are now provided.
See <a href="#message-builder">Message Builder API</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_retryinterceptorbuilder_change"><code>RetryInterceptorBuilder</code> Change</h5>
<div class="paragraph">
<p>A &#8220;Fluent API&#8221; for building listener container retry interceptors is now provided.
See <a href="#retry">Failures in Synchronous Operations and Options for Retry</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_republishmessagerecoverer_added"><code>RepublishMessageRecoverer</code> Added</h5>
<div class="paragraph">
<p>This new <code>MessageRecoverer</code> is provided to allow publishing a failed message to another queue (including stack trace information in the header) when retries are exhausted.
See <a href="#async-listeners">Message Listeners and the Asynchronous Case</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_default_error_handler_since_1_3_2">Default Error Handler (Since 1.3.2)</h5>
<div class="paragraph">
<p>A default <code>ConditionalRejectingErrorHandler</code> has been added to the listener container.
This error handler detects fatal message conversion problems and instructs the container to reject the message to prevent the broker from continually redelivering the unconvertible message.
See <a href="#exception-handling">Exception Handling</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_listener_container_missingqueuesfatal_property_since_1_3_5">Listener Container 'missingQueuesFatal` Property (Since 1.3.5)</h5>
<div class="paragraph">
<p>The <code>SimpleMessageListenerContainer</code> now has a property called <code>missingQueuesFatal</code> (default: <code>true</code>).
Previously, missing queues were always fatal.
See <a href="#containerAttributes">Message Listener Container Configuration</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_to_1_2_since_1_1">A.2.8. Changes to 1.2 Since 1.1</h4>
<div class="sect4">
<h5 id="_rabbitmq_version">RabbitMQ Version</h5>
<div class="paragraph">
<p>Spring AMQP now uses RabbitMQ 3.1.x by default (but retains compatibility with earlier versions).
Certain deprecations have been added for features no longer supported by RabbitMQ 3.1.x&#8201;&#8212;&#8201;federated exchanges and the <code>immediate</code> property on the <code>RabbitTemplate</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbit_admin_2">Rabbit Admin</h5>
<div class="paragraph">
<p><code>RabbitAdmin</code> now provides an option to let exchange, queue, and binding declarations continue when a declaration fails.
Previously, all declarations stopped on a failure.
By setting <code>ignore-declaration-exceptions</code>, such exceptions are logged (at the <code>WARN</code> level), but further declarations continue.
An example where this might be useful is when a queue declaration fails because of a slightly different <code>ttl</code> setting that would normally stop other declarations from proceeding.</p>
</div>
<div class="paragraph">
<p><code>RabbitAdmin</code> now provides an additional method called <code>getQueueProperties()</code>.
You can use this determine if a queue exists on the broker (returns <code>null</code> for a non-existent queue).
In addition, it returns the current number of messages in the queue as well as the current number of consumers.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbit_template">Rabbit Template</h5>
<div class="paragraph">
<p>Previously, when the <code>&#8230;&#8203;sendAndReceive()</code> methods were used with a fixed reply queue, two custom headers were used for correlation data and to retain and restore reply queue information.
With this release, the standard message property (<code>correlationId</code>) is used by default, although you can specify a custom property to use instead.
In addition, nested <code>replyTo</code> information is now retained internally in the template, instead of using a custom header.</p>
</div>
<div class="paragraph">
<p>The <code>immediate</code> property is deprecated.
You must not set this property when using RabbitMQ 3.0.x or greater.</p>
</div>
</div>
<div class="sect4">
<h5 id="_json_message_converters">JSON Message Converters</h5>
<div class="paragraph">
<p>A Jackson 2.x <code>MessageConverter</code> is now provided, along with the existing converter that uses Jackson 1.x.</p>
</div>
</div>
<div class="sect4">
<h5 id="_automatic_declaration_of_queues_and_other_items">Automatic Declaration of Queues and Other Items</h5>
<div class="paragraph">
<p>Previously, when declaring queues, exchanges and bindings, you could not define which connection factory was used for the declarations.
Each <code>RabbitAdmin</code> declared all components by using its connection.</p>
</div>
<div class="paragraph">
<p>Starting with this release, you can now limit declarations to specific <code>RabbitAdmin</code> instances.
See <a href="#conditional-declaration">Conditional Declaration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_amqp_remoting">AMQP Remoting</h5>
<div class="paragraph">
<p>Facilities are now provided for using Spring remoting techniques, using AMQP as the transport for the RPC calls.
For more information see <a href="#remoting">Spring Remoting with AMQP</a></p>
</div>
</div>
<div class="sect4">
<h5 id="_requested_heart_beats">Requested Heart Beats</h5>
<div class="paragraph">
<p>Several users have asked for the underlying client connection factory&#8217;s <code>requestedHeartBeats</code> property to be exposed on the Spring AMQP <code>CachingConnectionFactory</code>.
This is now available.
Previously, it was necessary to configure the AMQP client factory as a separate bean and provide a reference to it in the <code>CachingConnectionFactory</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changes_to_1_1_since_1_0">A.2.9. Changes to 1.1 Since 1.0</h4>
<div class="sect4">
<h5 id="_general">General</h5>
<div class="paragraph">
<p>Spring-AMQP is now built with Gradle.</p>
</div>
<div class="paragraph">
<p>Adds support for publisher confirms and returns.</p>
</div>
<div class="paragraph">
<p>Adds support for HA queues and broker failover.</p>
</div>
<div class="paragraph">
<p>Adds support for dead letter exchanges and dead letter queues.</p>
</div>
</div>
<div class="sect4">
<h5 id="_amqp_log4j_appender">AMQP Log4j Appender</h5>
<div class="paragraph">
<p>Adds an option to support adding a message ID to logged messages.</p>
</div>
<div class="paragraph">
<p>Adds an option to allow the specification of a <code>Charset</code> name to be used when converting <code>String</code> to <code>byte[]</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-05-13 14:52:31 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>