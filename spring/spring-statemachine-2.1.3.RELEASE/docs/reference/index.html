<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Spring Statemachine - Reference Documentation</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Spring Statemachine - Reference Documentation</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">Preface</a></li>
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel1">
<li><a href="#background">Background</a></li>
<li><a href="#usage-scenarios">Usage Scenarios</a></li>
</ul>
</li>
<li><a href="#statemachine-getting-started">Getting started</a>
<ul class="sectlevel1">
<li><a href="#system-requirement">System Requirement</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#using-gradle">Using Gradle</a></li>
<li><a href="#using-maven">Using Maven</a></li>
<li><a href="#developing-your-first-spring-statemachine-application">Developing Your First Spring Statemachine Application</a></li>
</ul>
</li>
<li><a href="#whatsnew">What&#8217;s New</a>
<ul class="sectlevel1">
<li><a href="#in-1-1">In 1.1</a></li>
<li><a href="#in-1-2">In 1.2</a>
<ul class="sectlevel2">
<li><a href="#in-1-2-8">In 1.2.8</a></li>
</ul>
</li>
<li><a href="#in-2-0">In 2.0</a>
<ul class="sectlevel2">
<li><a href="#in-2-0-0">In 2.0.0</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#statemachine">Using Spring Statemachine</a>
<ul class="sectlevel1">
<li><a href="#sm-config">Statemachine Configuration</a>
<ul class="sectlevel2">
<li><a href="#statemachine-config-annotations">Using <code>enable</code> Annotations</a></li>
<li><a href="#statemachine-config-states">Configuring States</a></li>
<li><a href="#configuring-hierarchical-states">Configuring Hierarchical States</a></li>
<li><a href="#configuring-regions">Configuring Regions</a></li>
<li><a href="#configuring-transitions">Configuring Transitions</a></li>
<li><a href="#configuring-guards">Configuring Guards</a></li>
<li><a href="#statemachine-config-actions">Configuring Actions</a></li>
<li><a href="#configuring-pseudo-states">Configuring Pseudo States</a></li>
<li><a href="#statemachine-config-commonsettings">Configuring Common Settings</a></li>
<li><a href="#configuring-model">Configuring Model</a></li>
<li><a href="#statemachine-config-thingstoremember">Things to Remember</a></li>
</ul>
</li>
<li><a href="#sm-machineid">State Machine ID</a>
<ul class="sectlevel2">
<li><a href="#using-code-enablestatemachine-code">Using <code>@EnableStateMachine</code></a></li>
<li><a href="#using-code-enablestatemachinefactory-code">Using <code>@EnableStateMachineFactory</code></a></li>
<li><a href="#using-code-statemachinemodelfactory-code">Using <code>StateMachineModelFactory</code></a></li>
</ul>
</li>
<li><a href="#sm-factories">State Machine Factories</a>
<ul class="sectlevel2">
<li><a href="#factory-through-an-adapter">Factory through an Adapter</a></li>
<li><a href="#state-machine-through-a-builder">State Machine through a Builder</a></li>
</ul>
</li>
<li><a href="#sm-deferevents">Using Deferred Events</a></li>
<li><a href="#sm-scopes">Using Scopes</a></li>
<li><a href="#sm-actions">Using Actions</a>
<ul class="sectlevel2">
<li><a href="#spel-expressions-with-actions">SpEL Expressions with Actions</a></li>
</ul>
</li>
<li><a href="#sm-guards">Using Guards</a>
<ul class="sectlevel2">
<li><a href="#spel-expressions-with-guards">SpEL Expressions with Guards</a></li>
</ul>
</li>
<li><a href="#sm-extendedstate">Using Extended State</a></li>
<li><a href="#sm-statecontext">Using <code>StateContext</code></a>
<ul class="sectlevel2">
<li><a href="#sm-statecontext-stage">Stages</a></li>
</ul>
</li>
<li><a href="#sm-triggers">Triggering Transitions</a>
<ul class="sectlevel2">
<li><a href="#using-code-eventtrigger-code">Using <code>EventTrigger</code></a></li>
<li><a href="#using-code-timertrigger-code">Using <code>TimerTrigger</code></a></li>
</ul>
</li>
<li><a href="#sm-listeners">Listening to State Machine Events</a>
<ul class="sectlevel2">
<li><a href="#application-context-events">Application Context Events</a></li>
<li><a href="#using-code-statemachinelistener-code">Using <code>StateMachineListener</code></a></li>
<li><a href="#limitations-and-problems">Limitations and Problems</a></li>
</ul>
</li>
<li><a href="#sm-context">Context Integration</a>
<ul class="sectlevel2">
<li><a href="#enabling-integration">Enabling Integration</a></li>
<li><a href="#method-parameters">Method Parameters</a></li>
<li><a href="#state-machine-transition-annotations">Transition Annotations</a></li>
<li><a href="#state-annotations">State Annotations</a></li>
<li><a href="#event-annotation">Event Annotation</a></li>
<li><a href="#state-machine-annotations">State Machine Annotations</a></li>
<li><a href="#extended-state-annotation">Extended State Annotation</a></li>
</ul>
</li>
<li><a href="#sm-accessor">Using <code>StateMachineAccessor</code></a></li>
<li><a href="#sm-interceptor">Using <code>StateMachineInterceptor</code></a></li>
<li><a href="#sm-security">State Machine Security</a>
<ul class="sectlevel2">
<li><a href="#configuring-security">Configuring Security</a></li>
<li><a href="#securing-events">Securing Events</a></li>
<li><a href="#securing-transitions">Securing Transitions</a></li>
<li><a href="#securing-actions">Securing Actions</a></li>
<li><a href="#sm-security-attributes-expressions">Using Security Attributes and Expressions</a></li>
<li><a href="#sm-security-details">Understanding Security</a></li>
</ul>
</li>
<li><a href="#sm-error-handling">State Machine Error Handling</a></li>
<li><a href="#sm-service">State Machine Services</a>
<ul class="sectlevel2">
<li><a href="#sm-service-statemachineservice">Using <code>StateMachineService</code></a></li>
</ul>
</li>
<li><a href="#sm-persist">Persisting a State Machine</a>
<ul class="sectlevel2">
<li><a href="#sm-persist-statemachinecontext">Using <code>StateMachineContext</code></a></li>
<li><a href="#sm-persist-statemachinepersister">Using <code>StateMachinePersister</code></a></li>
<li><a href="#sm-persist-redis">Using Redis</a></li>
<li><a href="#sm-persist-statemachineruntimepersister">Using <code>StateMachineRuntimePersister</code></a></li>
</ul>
</li>
<li><a href="#sm-boot">Spring Boot Support</a>
<ul class="sectlevel2">
<li><a href="#sm-boot-monitoring">Monitoring and Tracing</a></li>
<li><a href="#repository-config">Repository Config</a></li>
</ul>
</li>
<li><a href="#sm-monitoring">Monitoring a State Machine</a></li>
<li><a href="#sm-distributed">Using Distributed States</a>
<ul class="sectlevel2">
<li><a href="#using-code-zookeeperstatemachineensemble-code">Using <code>ZookeeperStateMachineEnsemble</code></a></li>
</ul>
</li>
<li><a href="#sm-test">Testing Support</a></li>
<li><a href="#sm-papyrus">Eclipse Modeling Support</a>
<ul class="sectlevel2">
<li><a href="#using-code-umlstatemachinemodelfactory-code">Using <code>UmlStateMachineModelFactory</code></a></li>
<li><a href="#creating-a-model">Creating a Model</a></li>
<li><a href="#defining-states">Defining States</a></li>
<li><a href="#defining-events">Defining Events</a></li>
<li><a href="#sm-papyrus-transitions">Defining Transitions</a></li>
<li><a href="#defining-timers">Defining Timers</a></li>
<li><a href="#sm-papyrus-choice">Defining a Choice</a></li>
<li><a href="#defining-a-junction">Defining a Junction</a></li>
<li><a href="#defining-entry-and-exit-points">Defining Entry and Exit Points</a></li>
<li><a href="#defining-history-states">Defining History States</a></li>
<li><a href="#defining-forks-and-joins">Defining Forks and Joins</a></li>
<li><a href="#defining-actions">Defining Actions</a></li>
<li><a href="#defining-guards">Defining Guards</a></li>
<li><a href="#sm-papyrus-beanref">Defining a Bean Reference</a></li>
<li><a href="#sm-papyrus-spelref">Defining a SpEL Reference</a></li>
<li><a href="#sm-papyrus-submachineref">Using a Sub-Machine Reference</a></li>
</ul>
</li>
<li><a href="#sm-repository">Repository Support</a>
<ul class="sectlevel2">
<li><a href="#sm-repository-config">Repository Configuration</a></li>
<li><a href="#sm-repository-persistence">Repository Persistence</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#statemachine-recipes">Recipes</a>
<ul class="sectlevel1">
<li><a href="#statemachine-recipes-persist">Persist</a></li>
<li><a href="#statemachine-recipes-tasks">Tasks</a></li>
</ul>
</li>
<li><a href="#statemachine-examples">State Machine Examples</a>
<ul class="sectlevel1">
<li><a href="#statemachine-examples-turnstile">Turnstile</a></li>
<li><a href="#statemachine-examples-showcase">Showcase</a></li>
<li><a href="#statemachine-examples-cdplayer">CD Player</a></li>
<li><a href="#statemachine-examples-tasks">Tasks</a></li>
<li><a href="#statemachine-examples-washer">Washer</a></li>
<li><a href="#statemachine-examples-persist">Persist</a></li>
<li><a href="#statemachine-examples-zookeeper">Zookeeper</a></li>
<li><a href="#statemachine-examples-web">Web</a></li>
<li><a href="#statemachine-examples-scope">Scope</a></li>
<li><a href="#statemachine-examples-security">Security</a></li>
<li><a href="#statemachine-examples-eventservice">Event Service</a></li>
<li><a href="#statemachine-examples-deploy">Deploy</a></li>
<li><a href="#statemachine-examples-ordershipping">Order Shipping</a></li>
<li><a href="#statemachine-examples-datajpa">JPA Configuration</a></li>
<li><a href="#statemachine-examples-datapersist">Data Persist</a></li>
<li><a href="#statemachine-examples-datajpamultipersist">Data Multi Persist</a></li>
<li><a href="#statemachine-examples-monitoring">Monitoring</a></li>
</ul>
</li>
<li><a href="#statemachine-faq">FAQ</a>
<ul class="sectlevel1">
<li><a href="#state-changes">State Changes</a></li>
<li><a href="#extended-state">Extended State</a></li>
</ul>
</li>
<li><a href="#appendices">Appendices</a>
<ul class="sectlevel1">
<li><a href="#support-content">Appendix A: Support Content</a>
<ul class="sectlevel2">
<li><a href="#classes-used-in-this-document">Classes Used in This Document</a></li>
</ul>
</li>
<li><a href="#state-machine-concepts">Appendix B: State Machine Concepts</a>
<ul class="sectlevel2">
<li><a href="#quick-example">Quick Example</a></li>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#crashcourse">A State Machine Crash Course</a></li>
</ul>
</li>
<li><a href="#appendices-zookeeper">Appendix C: Distributed State Machine Technical Paper</a>
<ul class="sectlevel2">
<li><a href="#abstract">Abstract</a></li>
<li><a href="#state-machine-technical-paper-introduction">Introduction</a></li>
<li><a href="#generic-concepts">Generic Concepts</a></li>
<li><a href="#the-role-of-code-zookeeperstatemachinepersist-code">The Role of <code>ZookeeperStateMachinePersist</code></a></li>
<li><a href="#the-role-of-code-zookeeperstatemachineensemble-code">The Role of <code>ZookeeperStateMachineEnsemble</code></a></li>
<li><a href="#distributed-tolerance">Distributed Tolerance</a></li>
</ul>
</li>
<li><a href="#devdocs">Developer Documentation</a>
<ul class="sectlevel2">
<li><a href="#devdocs-configmodel">StateMachine Config Model</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The concept of a state machine is most likely older than any reader
of this reference documentation and definitely older than the Java
language itself. Description of finite automata dates back to 1943
when gentlemen Warren McCulloch and Walter Pitts wrote a paper about
it. Later George H. Mealy presented a state machine concept (known as
a &#8220;Mealy Machine&#8221;) in 1955. A year later, in 1956, Edward F.
Moore presented another paper, in which he described what is known as
a &#8220;Moore Machine&#8221;. If
you have ever read anything about state machines, the names, Mealy and Moore,
should have popped up at some point.</p>
</div>
<div class="paragraph">
<p>This reference documentation contains the following parts:</p>
</div>
<div class="paragraph">
<p><a href="#introduction">Introduction</a> contains introduction to this reference documentation.</p>
</div>
<div class="paragraph">
<p><a href="#statemachine">Using Spring Statemachine</a> describes the usage of Spring Statemachine(SSM).</p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples">State Machine Examples</a> contains more detailed state machine examples.</p>
</div>
<div class="paragraph">
<p><a href="#statemachine-faq">FAQ</a> contains frequently asked questions.</p>
</div>
<div class="paragraph">
<p><a href="#appendices">Appendices</a> contains generic information about used material and state machines.</p>
</div>
</div>
</div>
<h1 id="introduction" class="sect0"><a class="anchor" href="#introduction"></a>Introduction</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Spring Statemachine (SSM) is a framework that lets application developers
use traditional state machine concepts with Spring applications. SSM
provides the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easy-to-use flat (one-level) state machine for simple use cases.</p>
</li>
<li>
<p>Hierarchical state machine structure to ease complex state
configuration.</p>
</li>
<li>
<p>State machine regions to provide even more complex state
configurations.</p>
</li>
<li>
<p>Usage of triggers, transitions, guards, and actions.</p>
</li>
<li>
<p>Type-safe configuration adapter.</p>
</li>
<li>
<p>State machine event listeners.</p>
</li>
<li>
<p>Spring IoC integration to associate beans with a state machine.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before you continue, we recommend going through the appendices <a href="#glossary">Glossary</a>
and <a href="#crashcourse">A State Machine Crash Course</a> to get a generic idea of what state machines are.
The rest of the documentation expects you to be
familiar with state machine concepts.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background"><a class="anchor" href="#background"></a>Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>State machines are powerful because their behavior is always guaranteed to be
consistent and relatively easily debugged due to how operational
rules are written in stone when a machine is started. The idea is that your
application is now in and may exist in a finite number of states. Then something
happens that takes your application from one state to the next.
A state machine is driven by triggers, which are based on either
events or timers.</p>
</div>
<div class="paragraph">
<p>It is much easier to design high-level logic outside of your
application and then interact with a state machine in various
different ways. You can interact with a state machine by
sending events, listening to what a state machine does, or requesting
the current state.</p>
</div>
<div class="paragraph">
<p>Traditionally, state machines are added to an existing project when
developers realize that the code base is starting to look like a plate
full of spaghetti. Spaghetti code looks like a never ending, hierarchical
structure of IF, ELSE, and BREAK clauses, and compilers should probably
ask developers to go home when things are starting to look too complex.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="usage-scenarios"><a class="anchor" href="#usage-scenarios"></a>Usage Scenarios</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A project is a good candidate to use a state machine when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can represent the application or part of its structure as states.</p>
</li>
<li>
<p>You want to split complex logic into smaller manageable tasks.</p>
</li>
<li>
<p>The application is already suffering concurrency issues with (for example)
something happening asynchronously.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You are already trying to implement a state machine when you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use boolean flags or enums to model situations.</p>
</li>
<li>
<p>Have variables that have meaning only for some part of your
application lifecycle.</p>
</li>
<li>
<p>Loop through an if-else structure (or, worse, multiple such structures),
check whether a particular flag or
enum is set, and then make further exceptions about what to do when certain
combinations of your flags and enums exist or do not exist.</p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="statemachine-getting-started" class="sect0"><a class="anchor" href="#statemachine-getting-started"></a>Getting started</h1>
<div class="openblock partintro">
<div class="content">
If you are just getting started with Spring Statemachine,
this is the section for you! Here, we answer the basic
“<code>what?</code>”, “<code>how?</code>” and “<code>why?</code>” questions. We start with a gentle
introduction to Spring Statemachine. We then build our
first Spring Statemachine application and discuss some
core principles as we go.
</div>
</div>
<div class="sect1">
<h2 id="system-requirement"><a class="anchor" href="#system-requirement"></a>System Requirement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Statemachine {revnumber} is built and tested with
JDK 8 (all artifacts have JDK 7 compatibility) and Spring
Framework {spring-version}. It does not require any other
dependencies outside of Spring Framework within its core system.</p>
</div>
<div class="paragraph">
<p>Other optional parts (such as <a href="#sm-distributed">Using Distributed States</a>) have dependencies on
Zookeeper, while <a href="#statemachine-examples">State Machine Examples</a> has dependencies
on <code>spring-shell</code> and <code>spring-boot</code>, which pull other dependencies
beyond the framework itself. Also, the optional security and data access features have
dependencies to on Spring Security and Spring Data modules.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modules"><a class="anchor" href="#modules"></a>Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following table describes the modules that are available for Spring Statemachine.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-core</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The core system of Spring Statemachine.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-recipes-common</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Common recipes that do not require dependencies outside of the core
framework.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-kryo</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Kryo</code> serializers for Spring Statemachine.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-data-common</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Common support module for <code>Spring Data</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-data-jpa</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for <code>Spring Data JPA</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-data-redis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for <code>Spring Data Redis</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-data-mongodb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for <code>Spring Data MongoDB</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-zookeeper</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zookeeper integration for a distributed state machine.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-test</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for state machine testing.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-cluster</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for Spring Cloud Cluster.
Note that Spring Cloud Cluster has been superseded by Spring Integration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-uml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for UI UML modeling with Eclipse Papyrus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-autoconfigure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support module for Spring Boot.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-bom</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bill of Materials pom.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-statemachine-starter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Boot starter.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="using-gradle"><a class="anchor" href="#using-gradle"></a>Using Gradle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following listing shows a typical <code>build.gradle</code> file created by choosing various settings at <a href="https://start.spring.io" class="bare">https://start.spring.io</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">buildscript {
	ext {
		springBootVersion = '{spring-boot-version}'
	}
	repositories {
		mavenCentral()
		maven { url "https://repo.spring.io/snapshot" }
		maven { url "https://repo.spring.io/milestone" }
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
	}
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
	mavenCentral()
	maven { url "https://repo.spring.io/snapshot" }
	maven { url "https://repo.spring.io/milestone" }
}


ext {
	springStatemachineVersion = '{revnumber}'
}

dependencies {
	compile('org.springframework.statemachine:spring-statemachine-starter')
	testCompile('org.springframework.boot:spring-boot-starter-test')
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.statemachine:spring-statemachine-bom:${springStatemachineVersion}"
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Replace <code>0.0.1-SNAPSHOT</code> with a version you want to use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With a normal project structure, you can build this project with the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># ./gradlew clean build</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The expected Spring Boot-packaged fat jar would be <code>build/libs/demo-0.0.1-SNAPSHOT.jar</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You do not need the`libs-milestone` and <code>libs-snapshot</code> repositories for
production development.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-maven"><a class="anchor" href="#using-maven"></a>Using Maven</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following example shows a typical <code>pom.xml</code> file, which was created by choosing various options at <a href="https://start.spring.io" class="bare">https://start.spring.io</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;demo&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;packaging&gt;jar&lt;/packaging&gt;

	&lt;name&gt;gs-statemachine&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Statemachine&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;{spring-boot-version}&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
		&lt;spring-statemachine.version&gt;{revnumber}&lt;/spring-statemachine.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.statemachine&lt;/groupId&gt;
			&lt;artifactId&gt;spring-statemachine-starter&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework.statemachine&lt;/groupId&gt;
				&lt;artifactId&gt;spring-statemachine-bom&lt;/artifactId&gt;
				&lt;version&gt;${spring-statemachine.version}&lt;/version&gt;
				&lt;type&gt;pom&lt;/type&gt;
				&lt;scope&gt;import&lt;/scope&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;

	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;


&lt;/project&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Replace <code>0.0.1-SNAPSHOT</code> with a version you want to use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With a normal project structure, you can build this project with the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># mvn clean package</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The expected Spring Boot-packaged fat-jar would be <code>target/demo-0.0.1-SNAPSHOT.jar</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You do not need the <code>libs-milestone</code> and <code>libs-snapshot</code> repositories for
production development.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developing-your-first-spring-statemachine-application"><a class="anchor" href="#developing-your-first-spring-statemachine-application"></a>Developing Your First Spring Statemachine Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can start by creating a simple Spring Boot <code>Application</code> class
that implements <code>CommandLineRunner</code>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class Application implements CommandLineRunner {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then you need to add states and events, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    SI, S1, S2
}

public enum Events {
    E1, E2
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then you need to add state machine configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class StateMachineConfig
        extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

    @Override
    public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
            throws Exception {
        config
            .withConfiguration()
                .autoStartup(true)
                .listener(listener());
    }

    @Override
    public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
            throws Exception {
        states
            .withStates()
                .initial(States.SI)
                    .states(EnumSet.allOf(States.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
            throws Exception {
        transitions
            .withExternal()
                .source(States.SI).target(States.S1).event(Events.E1)
                .and()
            .withExternal()
                .source(States.S1).target(States.S2).event(Events.E2);
    }

    @Bean
    public StateMachineListener&lt;States, Events&gt; listener() {
        return new StateMachineListenerAdapter&lt;States, Events&gt;() {
            @Override
            public void stateChanged(State&lt;States, Events&gt; from, State&lt;States, Events&gt; to) {
                System.out.println("State change to " + to.getId());
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then you need to implement <code>CommandLineRunner</code> and autowire <code>StateMachine</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private StateMachine&lt;States, Events&gt; stateMachine;

@Override
public void run(String... args) throws Exception {
    stateMachine.sendEvent(Events.E1);
    stateMachine.sendEvent(Events.E2);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Depending on whether you build your application with <code>Gradle</code> or <code>Maven</code>,
you can run it by using <code>java -jar build/libs/gs-statemachine-0.1.0.jar</code> or
<code>java -jar target/gs-statemachine-0.1.0.jar</code>, respectively.</p>
</div>
<div class="paragraph">
<p>The result of this command should be normal Spring Boot output.
However, you should also find the following lines:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">State change to SI
State change to S1
State change to S2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These lines indicate that the machine you constructed
is moving from one state to another, as it should.</p>
</div>
</div>
</div>
<h1 id="whatsnew" class="sect0"><a class="anchor" href="#whatsnew"></a>What&#8217;s New</h1>
<div class="sect1">
<h2 id="in-1-1"><a class="anchor" href="#in-1-1"></a>In 1.1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Statemachine 1.1 focuses on security and better
interoperability with web applications. It includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Comprehensive support for Spring Security has been added. See <a href="#sm-security">State Machine Security</a>.</p>
</li>
<li>
<p>Context integration with `@WithStateMachine' has been greatly
enhanced. See <a href="#sm-context">Context Integration</a>.</p>
</li>
<li>
<p><code>StateContext</code> is now a first class citizen, letting you
interact with a State Machine. See <a href="#sm-statecontext">Using <code>StateContext</code></a>.</p>
</li>
<li>
<p>Features around persistence have been enhanced with built-in
support for redis. See <a href="#sm-persist-redis">Using Redis</a>.</p>
</li>
<li>
<p>A new feature helps with persist operations. See
<a href="#sm-persist-statemachinepersister">Using <code>StateMachinePersister</code></a>.</p>
</li>
<li>
<p>Configuration model classes are now in a public API.</p>
</li>
<li>
<p>New features in timer-based events.</p>
</li>
<li>
<p>New <code>Junction</code> pseudostate. See <a href="#statemachine-config-states-junction">Junction State</a>.</p>
</li>
<li>
<p>New Exit Point and Entry Point pseudostates. See <a href="#statemachine-config-states-exitentry">Exit and Entry Point States</a>.</p>
</li>
<li>
<p>Configuration model verifier.</p>
</li>
<li>
<p>New samples. See <a href="#statemachine-examples-security">Security</a> and <a href="#statemachine-examples-eventservice">Event Service</a>.</p>
</li>
<li>
<p>UI modeling support using Eclipse Papyrus. See <a href="#sm-papyrus">Eclipse Modeling Support</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="in-1-2"><a class="anchor" href="#in-1-2"></a>In 1.2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Statemachine 1.2 focuses on generic enhancements, better
UML support, and integrations with external config repositories.
It includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Support for UML sub-machines. See <a href="#sm-papyrus-submachineref">Using a Sub-Machine Reference</a>.</p>
</li>
<li>
<p>A new repository abstraction that keeps machine configuration in an
external repository. See <a href="#sm-repository">Repository Support</a>.</p>
</li>
<li>
<p>New support for state actions. See <a href="#state-actions">State Actions</a>.</p>
</li>
<li>
<p>New transition error action concepts. See <a href="#statemachine-config-transition-actions-errorhandling">Transition Action Error Handling</a>.</p>
</li>
<li>
<p>New action error concepts. See <a href="#statemachine-config-state-actions-errorhandling">State Action Error Handling</a>.</p>
</li>
<li>
<p>Initial work for Spring Boot support. See <a href="#sm-boot">Spring Boot Support</a>.</p>
</li>
<li>
<p>Support for tracing and monitoring. See <a href="#sm-monitoring">Monitoring a State Machine</a>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="in-1-2-8"><a class="anchor" href="#in-1-2-8"></a>In 1.2.8</h3>
<div class="paragraph">
<p>Spring Statemachine 1.2.8 contains a bit more functionality than normally
not seen in a point release, but these changes did not merit a fork of
Spring Statemachine 1.3. It includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JPA entity classes have changed table names. See <a href="#sm-repository-config-jpa">JPA</a>.</p>
</li>
<li>
<p>A new sample. See <a href="#statemachine-examples-datapersist">Data Persist</a>.</p>
</li>
<li>
<p>New entity classes for persistence. See <a href="#sm-repository-persistence">Repository Persistence</a>.</p>
</li>
<li>
<p>Transition conflict policy. See
<a href="#statemachine-config-commonsettings">Configuring Common Settings</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="in-2-0"><a class="anchor" href="#in-2-0"></a>In 2.0</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Statemachine 2.0 focuses on Spring Boot 2.x support.</p>
</div>
<div class="sect2">
<h3 id="in-2-0-0"><a class="anchor" href="#in-2-0-0"></a>In 2.0.0</h3>
<div class="paragraph">
<p>Spring Statemachine 2.0.0 includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The format of monitoring and tracing has been changed. See <a href="#sm-boot-monitoring">Monitoring and Tracing</a>.</p>
</li>
<li>
<p>The <code>spring-statemachine-boot</code> module has been renamed to <code>spring-statemachine-autoconfigure</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="statemachine" class="sect0"><a class="anchor" href="#statemachine"></a>Using Spring Statemachine</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This part of the reference documentation explains the core functionality
that Spring Statemachine provides to any Spring based application.</p>
</div>
<div class="paragraph">
<p>It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sm-config">Statemachine Configuration</a> describes the generic configuration support.</p>
</li>
<li>
<p><a href="#sm-machineid">State Machine ID</a> describes the use of machine id.</p>
</li>
<li>
<p><a href="#sm-factories">State Machine Factories</a> describes the generic state machine factory support.</p>
</li>
<li>
<p><a href="#sm-deferevents">Using Deferred Events</a> describes the deferred event support.</p>
</li>
<li>
<p><a href="#sm-scopes">Using Scopes</a> describes the scope support.</p>
</li>
<li>
<p><a href="#sm-actions">Using Actions</a> describes the actions support.</p>
</li>
<li>
<p><a href="#sm-guards">Using Guards</a> describes the guard support.</p>
</li>
<li>
<p><a href="#sm-extendedstate">Using Extended State</a> describes the extended state support.</p>
</li>
<li>
<p><a href="#sm-statecontext">Using <code>StateContext</code></a> describes the state context support.</p>
</li>
<li>
<p><a href="#sm-triggers">Triggering Transitions</a> describes the use of triggers.</p>
</li>
<li>
<p><a href="#sm-listeners">Listening to State Machine Events</a> describes the use of state machine listeners.</p>
</li>
<li>
<p><a href="#sm-context">Context Integration</a> describes the generic Spring application context support.</p>
</li>
<li>
<p><a href="#sm-accessor">Using <code>StateMachineAccessor</code></a> describes the state machine internal accessor support.</p>
</li>
<li>
<p><a href="#sm-interceptor">Using <code>StateMachineInterceptor</code></a> describes the state machine error handling support.</p>
</li>
<li>
<p><a href="#sm-security">State Machine Security</a> describes the state machine security support.</p>
</li>
<li>
<p><a href="#sm-error-handling">State Machine Error Handling</a> describes the state machine interceptor support.</p>
</li>
<li>
<p><a href="#sm-service">State Machine Services</a> describes the state machine service support.</p>
</li>
<li>
<p><a href="#sm-persist">Persisting a State Machine</a> describes the state machine persisting support.</p>
</li>
<li>
<p><a href="#sm-boot">Spring Boot Support</a> describes the Spring Boot support.</p>
</li>
<li>
<p><a href="#sm-monitoring">Monitoring a State Machine</a> describes the monitoring and trancing support.</p>
</li>
<li>
<p><a href="#sm-distributed">Using Distributed States</a> describes the distributed state machine support.</p>
</li>
<li>
<p><a href="#sm-test">Testing Support</a> describes the state machine testing support.</p>
</li>
<li>
<p><a href="#sm-papyrus">Eclipse Modeling Support</a> describes the state machine UML modeling support.</p>
</li>
<li>
<p><a href="#sm-repository">Repository Support</a> describes the state machine repository config support.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-config"><a class="anchor" href="#sm-config"></a>Statemachine Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the common tasks when using a state machine is to design its
runtime configuration. This chapter focuses on how Spring
Statemachine is configured and how it leverages Spring&#8217;s lightweight
IoC containers to simplify the application internals to make it more
manageable.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Configuration examples in this section are not feature complete. That is,
you always need to have definitions of both states and transitions.
Otherwise, state machine configuration would be ill-formed. We have
simply made code snippets less verbose by leaving other needed parts
out.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="statemachine-config-annotations"><a class="anchor" href="#statemachine-config-annotations"></a>Using <code>enable</code> Annotations</h3>
<div class="paragraph">
<p>We use two familiar Spring <em>enabler</em> annotations to ease configuration:
<code>@EnableStateMachine</code> and <code>@EnableStateMachineFactory</code>.
These annotations, when placed in a <code>@Configuration</code> class, enable
some basic functionality needed by a state machine.</p>
</div>
<div class="paragraph">
<p>You can use <code>@EnableStateMachine</code> when you need a configuration to create an
instance of <code>StateMachine</code>. Usually, a <code>@Configuration</code> class extends adapters
(<code>EnumStateMachineConfigurerAdapter</code> or <code>StateMachineConfigurerAdapter</code>), which
lets you override configuration callback methods. We automatically
detect whether you use these adapter classes and modify the runtime configuration
logic accordingly.</p>
</div>
<div class="paragraph">
<p>You can use <code>@EnableStateMachineFactory</code> when you need a configuration to create an
instance of a <code>StateMachineFactory</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Usage examples of these are shown in below sections.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="statemachine-config-states"><a class="anchor" href="#statemachine-config-states"></a>Configuring States</h3>
<div class="paragraph">
<p>We get into more complex configuration examples a bit later in this guide, but
we first start with something simple. For most simple state
machine, you can use <code>EnumStateMachineConfigurerAdapter</code> and define
possible states and choose the initial and optional end states.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1Enums
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use strings instead of enumerations as states and
events by using <code>StateMachineConfigurerAdapter</code>, as shown in the next example. Most
of the configuration examples ues enumerations, but, generally speaking,
you can interchange strings and enumerations.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1Strings
		extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("S1")
				.end("SF")
				.states(new HashSet&lt;String&gt;(Arrays.asList("S1","S2","S3","S4")));
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using enumerations brings a safer set of states and event types but
limits possible combinations to compile time. Strings do not have this
limitation and let you use more dynamic ways to build state
machine configurations but do not allow same level of safety.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuring-hierarchical-states"><a class="anchor" href="#configuring-hierarchical-states"></a>Configuring Hierarchical States</h3>
<div class="paragraph">
<p>You can define hierarchical states can by using multiple <code>withStates()</code>
calls, where you can use <code>parent()</code> to indicate that these
particular states are sub-states of some other state.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config2
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.state(States.S1)
				.and()
				.withStates()
					.parent(States.S1)
					.initial(States.S2)
					.state(States.S2);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-regions"><a class="anchor" href="#configuring-regions"></a>Configuring Regions</h3>
<div class="paragraph">
<p>There are no special configuration methods to mark a collection of
states to be part of an orthogonal state. To put it simply, orthogonal
state is created when the same hierarchical state machine has multiple sets
of states, each of which has an initial state. Because an individual state
machine can only have one initial state, multiple initial states must
mean that a specific state must have multiple independent regions.
The following example shows how to define regions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config10
		extends EnumStateMachineConfigurerAdapter&lt;States2, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States2, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States2.S1)
				.state(States2.S2)
				.and()
				.withStates()
					.parent(States2.S2)
					.initial(States2.S2I)
					.state(States2.S21)
					.end(States2.S2F)
					.and()
				.withStates()
					.parent(States2.S2)
					.initial(States2.S3I)
					.state(States2.S31)
					.end(States2.S3F);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When persisting machines with regions or generally
relying on any functionalities to reset a machine, you may need
to have a dedicated ID for a region. By default, this ID
is a generated UUID. As the following example shows, <code>StateConfigurer</code> has
a method called <code>region(String id)</code> that lets you set the ID for a region:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config10RegionId
		extends EnumStateMachineConfigurerAdapter&lt;States2, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States2, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States2.S1)
				.state(States2.S2)
				.and()
				.withStates()
					.parent(States2.S2)
					.region("R1")
					.initial(States2.S2I)
					.state(States2.S21)
					.end(States2.S2F)
					.and()
				.withStates()
					.parent(States2.S2)
					.region("R2")
					.initial(States2.S3I)
					.state(States2.S31)
					.end(States2.S3F);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-transitions"><a class="anchor" href="#configuring-transitions"></a>Configuring Transitions</h3>
<div class="paragraph">
<p>We support three different types of transitions: <code>external</code>,
<code>internal</code>, and <code>local</code>. Transitions are triggered either by a signal
(which is an event sent into a state machine) or by a timer.
The following example shows how to define all three kinds of transitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config3
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.S1).target(States.S2)
				.event(Events.E1)
				.and()
			.withInternal()
				.source(States.S2)
				.event(Events.E2)
				.and()
			.withLocal()
				.source(States.S2).target(States.S3)
				.event(Events.E3);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-guards"><a class="anchor" href="#configuring-guards"></a>Configuring Guards</h3>
<div class="paragraph">
<p>You can use guards to protect state transitions. You can use the <code>Guard</code> interface
to do an evaluation where a method has access to a <code>StateContext</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config4
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.S1).target(States.S2)
				.event(Events.E1)
				.guard(guard())
				.and()
			.withExternal()
				.source(States.S2).target(States.S3)
				.event(Events.E2)
				.guardExpression("true");

	}

	@Bean
	public Guard&lt;States, Events&gt; guard() {
		return new Guard&lt;States, Events&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;States, Events&gt; context) {
				return true;
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we used two different types of guard configurations. First, we
created a simple <code>Guard</code> as a bean and attached it to the transition between
states <code>S1</code> and <code>S2</code>.</p>
</div>
<div class="paragraph">
<p>Second, we used a SPeL expression as a guard to dicate that the
expression must return a <code>BOOLEAN</code> value. Behind the scenes, this
expression-based guard is a <code>SpelExpressionGuard</code>. We attached it to
the transition between states <code>S2</code> and <code>S3</code>. Both guards
always evaluate to <code>true</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="statemachine-config-actions"><a class="anchor" href="#statemachine-config-actions"></a>Configuring Actions</h3>
<div class="paragraph">
<p>You can define actions to be executed with transitions and states.
An action is always run as a result of a transition that
originates from a trigger. The following example shows how to define an action:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config51
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.S1)
				.target(States.S2)
				.event(Events.E1)
				.action(action());
	}

	@Bean
	public Action&lt;States, Events&gt; action() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				// do something
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, a single <code>Action</code> is defined as a bean named <code>action</code> and associated
with a transition from <code>S1</code> to <code>S2</code>.
The following example shows how to use an action multiple times:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config52
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1, action())
				.state(States.S1, action(), null)
				.state(States.S2, null, action())
				.state(States.S2, action())
				.state(States.S3, action(), action());
	}

	@Bean
	public Action&lt;States, Events&gt; action() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				// do something
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Usually, you would not define the same <code>Action</code> instance for different
stages, but we did it here to not make too much noise in a code
snippet.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the preceding example, a single <code>Action</code> is defined by the bean named <code>action</code> and associated
with states <code>S1</code>, <code>S2</code>, and <code>S3</code>. We need to clarify what is going on here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We defined an action for the initial state, <code>S1</code>.</p>
</li>
<li>
<p>We defined an entry action for state <code>S1</code> and left the exit action empty.</p>
</li>
<li>
<p>We defined an exit action for state <code>S2</code> and left the entry action empty.</p>
</li>
<li>
<p>We defined a single state action for state <code>S2</code>.</p>
</li>
<li>
<p>We defined both entry and exit actions for state <code>S3</code>.</p>
</li>
<li>
<p>Note that state <code>S1</code> is used twice with <code>initial()</code> and <code>state()</code>
functions. You need to do this only if you want to define entry or exit
actions with initial state.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Defining action with <code>initial()</code> function only runs a particular
action when a state machine or sub state is started. This action
is an initializing action that is run only once. An action defined
with <code>state()</code> is then run if the state machine transitions back
and forward between initial and non-initial states.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="state-actions"><a class="anchor" href="#state-actions"></a>State Actions</h4>
<div class="paragraph">
<p>State actions are run differently compared to entry and exit
actions, because execution happens after state has been entered
and can be cancelled if state exit happens before a particular action
has been completed.</p>
</div>
<div class="paragraph">
<p>State actions are run by using a normal Spring <code>TaskScheduler</code>
wrapped within a <code>Runnable</code> that can get cancelled through
<code>ScheduledFuture</code>. This means that, whatever you do in your
action, you need to be able to catch <code>InterruptedException</code> or, more generally,
periodically check whether <code>Thread</code> is interrupted.</p>
</div>
<div class="paragraph">
<p>The following example shows typical configuration that uses default the <code>IMMEDIATE_CANCEL</code>, which
would immediately cancel a running task when its state is complete:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config1 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config) throws Exception {
		config
			.withConfiguration()
				.stateDoActionPolicy(StateDoActionPolicy.IMMEDIATE_CANCEL);
	}

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states) throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2", context -&gt; {})
				.state("S3");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions) throws Exception {
		transitions
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1")
				.and()
			.withExternal()
				.source("S2")
				.target("S3")
				.event("E2");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can set a policy to <code>TIMEOUT_CANCEL</code> together with a global timeout
for each machine. This changes state behavior to await action completion
before cancelation is requested. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config) throws Exception {
	config
		.withConfiguration()
			.stateDoActionPolicy(StateDoActionPolicy.TIMEOUT_CANCEL)
			.stateDoActionPolicyTimeout(10, TimeUnit.SECONDS);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If <code>Event</code> directly takes a machine into a state so that event headers
are available to a particular action, you can also use a dedicated
event header to set a specific timeout (defined in <code>millis</code>).
You can use the reserved header value <code>StateMachineMessageHeaders.HEADER_DO_ACTION_TIMEOUT</code>
for this purpose. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateMachine&lt;String, String&gt; stateMachine;

void sendEventUsingTimeout() {
	stateMachine.sendEvent(MessageBuilder
			.withPayload("E1")
			.setHeader(StateMachineMessageHeaders.HEADER_DO_ACTION_TIMEOUT, 5000)
			.build());

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="statemachine-config-transition-actions-errorhandling"><a class="anchor" href="#statemachine-config-transition-actions-errorhandling"></a>Transition Action Error Handling</h4>
<div class="paragraph">
<p>You can always catch exceptions manually. However, with actions defined for
transitions, you can define an error action that is called if an
exception is raised. The exception is then available from a <code>StateContext</code>
passed to that action. The following example shows how to create a state
that handles an exception:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config53
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.S1)
				.target(States.S2)
				.event(Events.E1)
				.action(action(), errorAction());
	}

	@Bean
	public Action&lt;States, Events&gt; action() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				throw new RuntimeException("MyError");
			}
		};
	}

	@Bean
	public Action&lt;States, Events&gt; errorAction() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				// RuntimeException("MyError") added to context
				Exception exception = context.getException();
				exception.getMessage();
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If need be, you can manually create imilar logic for every action.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.S1)
			.target(States.S2)
			.event(Events.E1)
			.action(Actions.errorCallingAction(action(), errorAction()));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="statemachine-config-state-actions-errorhandling"><a class="anchor" href="#statemachine-config-state-actions-errorhandling"></a>State Action Error Handling</h4>
<div class="paragraph">
<p>Logic similar to the logic that handles errors in state transitions is also available
for entry to a state and exit from a state.</p>
</div>
<div class="paragraph">
<p>For these situations, <code>StateConfigurer</code> has methods called <code>stateEntry</code>, <code>stateDo</code>, and
<code>stateExit</code>. These methods define an <code>error</code> action together with a normal (non-error) <code>action</code>.
The following example shows how to use all three methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config55
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.stateEntry(States.S2, action(), errorAction())
				.stateDo(States.S2, action(), errorAction())
				.stateExit(States.S2, action(), errorAction())
				.state(States.S3);
	}

	@Bean
	public Action&lt;States, Events&gt; action() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				throw new RuntimeException("MyError");
			}
		};
	}

	@Bean
	public Action&lt;States, Events&gt; errorAction() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				// RuntimeException("MyError") added to context
				Exception exception = context.getException();
				exception.getMessage();
			}
		};
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-pseudo-states"><a class="anchor" href="#configuring-pseudo-states"></a>Configuring Pseudo States</h3>
<div class="paragraph">
<p><em>Pseudo state</em> configuration is usually done by configuring states and
transitions. Pseudo states are automatically added to state machine as
states.</p>
</div>
<div class="sect3">
<h4 id="initial-state"><a class="anchor" href="#initial-state"></a>Initial State</h4>
<div class="paragraph">
<p>You can mark a particular state as initial state by using the <code>initial()</code>
method. This initial action is good, for example, to initialize
extended state variables. The following example shows how to use the <code>initial()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config11
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1, initialAction())
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

	@Bean
	public Action&lt;States, Events&gt; initialAction() {
		return new Action&lt;States, Events&gt;() {

			@Override
			public void execute(StateContext&lt;States, Events&gt; context) {
				// do something initially
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="terminate-state"><a class="anchor" href="#terminate-state"></a>Terminate State</h4>
<div class="paragraph">
<p>You can mark a particular state as being an end state by using the <code>end()</code> method.
You can do so at most once for each individual sub-machine or region.
The following example shows how to use the <code>end()</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1Enums
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="state-history"><a class="anchor" href="#state-history"></a>State History</h4>
<div class="paragraph">
<p>You can define state history once for each individual state machine.
You need to choose its state identifier and set either <code>History.SHALLOW</code> or
<code>History.DEEP</code>. The following example uses <code>History.SHALLOW</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config12
		extends EnumStateMachineConfigurerAdapter&lt;States3, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States3, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States3.S1)
				.state(States3.S2)
				.and()
				.withStates()
					.parent(States3.S2)
					.initial(States3.S2I)
					.state(States3.S21)
					.state(States3.S22)
					.history(States3.SH, History.SHALLOW);
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States3, Events&gt; transitions)
			throws Exception {
		transitions
			.withHistory()
				.source(States3.SH)
				.target(States3.S22);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also, as the preceding example shows, you can optionally define a default
transition from a history state into a state vertex in a same machine.
This transition takes place as a default if, for example, the machine has
never been entered&#8201;&#8212;&#8201;thus, no history would be available. If a default
state transition is not defined, then normal entry into a region is
done. This default transition is also used if a machine&#8217;s history is
a final state.</p>
</div>
</div>
<div class="sect3">
<h4 id="choice-state"><a class="anchor" href="#choice-state"></a>Choice State</h4>
<div class="paragraph">
<p>Choice needs to be defined in both states and transitions to work
properly. You can mark a particular state as being a choice state by using the <code>choice()</code>
method. This state needs to match source state when a transition is
configured for this choice.</p>
</div>
<div class="paragraph">
<p>You can configure a transition by using <code>withChoice()</code>, where you define source
state and a <code>first/then/last</code> structure, which is equivalent to a normal
<code>if/elseif/else</code>. With <code>first</code> and <code>then</code>, you can specify a guard just
as you would use a condition with <code>if/elseif</code> clauses.</p>
</div>
<div class="paragraph">
<p>A transition needs to be able to exist, so you must make sure to use <code>last</code>.
Otherwise, the configuration is ill-formed. The following example shows how to define
a choice state:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config13
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.SI)
				.choice(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withChoice()
				.source(States.S1)
				.first(States.S2, s2Guard())
				.then(States.S3, s3Guard())
				.last(States.S4);
	}

	@Bean
	public Guard&lt;States, Events&gt; s2Guard() {
		return new Guard&lt;States, Events&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;States, Events&gt; context) {
				return false;
			}
		};
	}

	@Bean
	public Guard&lt;States, Events&gt; s3Guard() {
		return new Guard&lt;States, Events&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;States, Events&gt; context) {
				return true;
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Actions can be run with both incoming and outgoing transitions of
a choice pseudostate. As the following example shows, one dummy lambda
action is defined that leads into a choice state and one similar dummy
lambda action is defined for one outgoing transition (where it also
defines an error action):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config23
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.SI)
				.choice(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.SI)
				.action(c -&gt; {
						// action with SI-S1
					})
				.target(States.S1)
				.and()
			.withChoice()
				.source(States.S1)
				.first(States.S2, c -&gt; {
						return true;
					})
				.last(States.S3, c -&gt; {
						// action with S1-S3
					}, c -&gt; {
						// error callback for action S1-S3
					});
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Junction have same api format meaning actions can be defined
similarly.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="statemachine-config-states-junction"><a class="anchor" href="#statemachine-config-states-junction"></a>Junction State</h4>
<div class="paragraph">
<p>You need to define a junction in both states and transitions for it to work
properly. You can mark a particular state as being a choice state by using the <code>junction()</code>
method. This state needs to match the source state when a transition is
configured for this choice.</p>
</div>
<div class="paragraph">
<p>You can configure the transition by using <code>withJunction()</code> where you define source
state and a <code>first/then/last</code> structure (which is equivalent to a normal
<code>if/elseif/else</code>). With <code>first</code> and <code>then</code>, you can specify a guard as
you would use a condition with <code>if/elseif</code> clauses.</p>
</div>
<div class="paragraph">
<p>A transition needs to be able to exist, so you must make sure to use <code>last</code>.
Otherwise, the configuration is ill-formed.
The following example uses a junction:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config20
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.SI)
				.junction(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withJunction()
				.source(States.S1)
				.first(States.S2, s2Guard())
				.then(States.S3, s3Guard())
				.last(States.S4);
	}

	@Bean
	public Guard&lt;States, Events&gt; s2Guard() {
		return new Guard&lt;States, Events&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;States, Events&gt; context) {
				return false;
			}
		};
	}

	@Bean
	public Guard&lt;States, Events&gt; s3Guard() {
		return new Guard&lt;States, Events&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;States, Events&gt; context) {
				return true;
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The difference between choice and junction is purely academic, as both are
implemented with <code>first/then/last</code> structures . However, in theory, based
on UML modeling, <code>choice</code> allows only one incoming transition while
<code>junction</code> allows multiple incoming transitions. At a code level, the
functionality is pretty much identical.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="fork-state"><a class="anchor" href="#fork-state"></a>Fork State</h4>
<div class="paragraph">
<p>You must define a fork in both states and transitions for it to work
properly. You can mark a particular state as being a choice state by using the <code>fork()</code>
method. This state needs to match source state when a transition is
configured for this fork.</p>
</div>
<div class="paragraph">
<p>The target state needs to be a super state or an immediate state in a
regions. Using a super state as a target takes all regions into
initial states. Targeting individual state gives more controlled entry
into regions. The following example uses a fork:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config14
		extends EnumStateMachineConfigurerAdapter&lt;States2, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States2, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States2.S1)
				.fork(States2.S2)
				.state(States2.S3)
				.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S2I)
					.state(States2.S21)
					.state(States2.S22)
					.end(States2.S2F)
					.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S3I)
					.state(States2.S31)
					.state(States2.S32)
					.end(States2.S3F);
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States2, Events&gt; transitions)
			throws Exception {
		transitions
			.withFork()
				.source(States2.S2)
				.target(States2.S22)
				.target(States2.S32);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="join-state"><a class="anchor" href="#join-state"></a>Join State</h4>
<div class="paragraph">
<p>You must define a join in both states and transitions for it to work
properly. You can mark aparticular state as being a choice state by using the <code>join()</code>
method. This state does not need to match either source states or a
target state in a transition configuration.</p>
</div>
<div class="paragraph">
<p>You can select a target state where a transition goes when all source states
have been joined. If you use state hosting regions as the source, the end
states of a region are used as joins. Otherwise, you can pick any
states from a region. The following exmaple uses a join:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config15
		extends EnumStateMachineConfigurerAdapter&lt;States2, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States2, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States2.S1)
				.state(States2.S3)
				.join(States2.S4)
				.state(States2.S5)
				.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S2I)
					.state(States2.S21)
					.state(States2.S22)
					.end(States2.S2F)
					.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S3I)
					.state(States2.S31)
					.state(States2.S32)
					.end(States2.S3F);
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States2, Events&gt; transitions)
			throws Exception {
		transitions
			.withJoin()
				.source(States2.S2F)
				.source(States2.S3F)
				.target(States2.S4)
				.and()
			.withExternal()
				.source(States2.S4)
				.target(States2.S5);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also have multiple transitions originate from a
join state. It this case, we advise you to use guards and define your guards
such that only one guard evaluates to <code>TRUE</code> at any given time. Otherwise,
transition behavior is not predictable. This is shown in the following example, where the guard
checks whwther the extended state has variables:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config22
		extends EnumStateMachineConfigurerAdapter&lt;States2, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States2, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States2.S1)
				.state(States2.S3)
				.join(States2.S4)
				.state(States2.S5)
				.end(States2.SF)
				.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S2I)
					.state(States2.S21)
					.state(States2.S22)
					.end(States2.S2F)
					.and()
				.withStates()
					.parent(States2.S3)
					.initial(States2.S3I)
					.state(States2.S31)
					.state(States2.S32)
					.end(States2.S3F);
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States2, Events&gt; transitions)
			throws Exception {
		transitions
			.withJoin()
				.source(States2.S2F)
				.source(States2.S3F)
				.target(States2.S4)
				.and()
			.withExternal()
				.source(States2.S4)
				.target(States2.S5)
				.guardExpression("!extendedState.variables.isEmpty()")
				.and()
			.withExternal()
				.source(States2.S4)
				.target(States2.SF)
				.guardExpression("extendedState.variables.isEmpty()");
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="statemachine-config-states-exitentry"><a class="anchor" href="#statemachine-config-states-exitentry"></a>Exit and Entry Point States</h4>
<div class="paragraph">
<p>You can use exit and entry points to do more controlled exit and entry
from and into a submachine.
The following example uses the <code>withEntry</code> and <code>withExit</code> methods to define entry points:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config21 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
		.withStates()
			.initial("S1")
			.state("S2")
			.state("S3")
			.and()
			.withStates()
				.parent("S2")
				.initial("S21")
				.entry("S2ENTRY")
				.exit("S2EXIT")
				.state("S22");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
		.withExternal()
			.source("S1").target("S2")
			.event("E1")
			.and()
		.withExternal()
			.source("S1").target("S2ENTRY")
			.event("ENTRY")
			.and()
		.withExternal()
			.source("S22").target("S2EXIT")
			.event("EXIT")
			.and()
		.withEntry()
			.source("S2ENTRY").target("S22")
			.and()
		.withExit()
			.source("S2EXIT").target("S3");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As shown in the preceding, you need to mark particular states as being <code>exit</code> and
<code>entry</code> states. Then you create a normal transitions into those states
and also specify <code>withExit()</code> and <code>withEntry()</code>, where those states
exit and entry respectively.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="statemachine-config-commonsettings"><a class="anchor" href="#statemachine-config-commonsettings"></a>Configuring Common Settings</h3>
<div class="paragraph">
<p>You can set part of a common state machine configuration by using
<code>ConfigurationConfigurer</code>. This you set set <code>BeanFactory</code>,
<code>TaskExecutor</code>, <code>TaskScheduler</code>, and an autostart flag for a state machine≥
It also lets you register <code>StateMachineListener</code> instances.
The following example shows how to use <code>ConfigurationConfigurer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config17
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
			throws Exception {
		config
			.withConfiguration()
				.autoStartup(true)
				.machineId("myMachineId")
				.beanFactory(new StaticListableBeanFactory())
				.taskExecutor(new SyncTaskExecutor())
				.taskScheduler(new ConcurrentTaskScheduler())
				.listener(new StateMachineListenerAdapter&lt;States, Events&gt;())
				.transitionConflictPolicy(TransitionConflictPolicy.CHILD);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the state machine <code>autoStartup</code> flag is disabled, because all
instances that handle sub-states are controlled by the state machine itself
and cannot be automatically started. Also, it is much safer to leave
whether a machine should be started
automatically or not to the user. This flag controls only the autostart of a
top-level state machine.</p>
</div>
<div class="paragraph">
<p>Setting <code>machineId</code> within a configuration class is simply a convenience for those times when
you want or need to do it there.</p>
</div>
<div class="paragraph">
<p>Setting a <code>BeanFactory</code>, <code>TaskExecutor</code>, or <code>TaskScheduler</code> is another
convenience for you, and those settings are also used within the framework itself.</p>
</div>
<div class="paragraph">
<p>Registering <code>StateMachineListener</code> instances is also partly for
convenience but is required if you want to catch a callback during a
state machine lifecycle, such as getting notified of a state machine&#8217;s
start and stop events. Note that you cannot listen a state
machine&#8217;s start events if <code>autoStartup</code> is enabled, unless you register a listener
during a configuration phase.</p>
</div>
<div class="paragraph">
<p>You can use <code>transitionConflictPolicy</code> when multiple
transition paths could be selected. One usual use case for this is when a
machine contains anonymous transitions that lead out from a sub-state
and a parent state and you want to define a policy in which one is
selected. This is a global setting within a machine instance and
defaults to <code>CHILD</code>.</p>
</div>
<div class="paragraph">
<p>You can use <code>withDistributed()</code> to configure <code>DistributedStateMachine</code>. It
lets you set a <code>StateMachineEnsemble</code>, which (if it exists) automatically
wraps any created <code>StateMachine</code> with <code>DistributedStateMachine</code> and
enables distributed mode. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config18
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
			throws Exception {
		config
			.withDistributed()
				.ensemble(stateMachineEnsemble());
	}

	@Bean
	public StateMachineEnsemble&lt;States, Events&gt; stateMachineEnsemble()
			throws Exception {
		// naturally not null but should return ensemble instance
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more about distributed states, see <a href="#sm-distributed">Using Distributed States</a>.</p>
</div>
<div class="paragraph">
<p>The <code>StateMachineModelVerifier</code> interface is used internally to
do some sanity checks for a state machine&#8217;s structure. Its purpose is to
fail fast early instead of letting common configuration errors into a
state machine. By default, a verifier is automatically enabled and the
<code>DefaultStateMachineModelVerifier</code> implementation is used.</p>
</div>
<div class="paragraph">
<p>With <code>withVerifier()</code>, you can disable verifier or set a custom one if
needed. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config19
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
			throws Exception {
		config
			.withVerifier()
				.enabled(true)
				.verifier(verifier());
	}

	@Bean
	public StateMachineModelVerifier&lt;States, Events&gt; verifier() {
		return new StateMachineModelVerifier&lt;States, Events&gt;() {

			@Override
			public void verify(StateMachineModel&lt;States, Events&gt; model) {
				// throw exception indicating malformed model
			}
		};
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more about config model, see <a href="#devdocs-configmodel">StateMachine Config Model</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>withSecurity</code>, <code>withMonitoring</code> and <code>withPersistence</code> configuration methods
are documented in <a href="#sm-security">State Machine Security</a>, <a href="#sm-monitoring">Monitoring a State Machine</a>, and
<a href="#sm-persist-statemachineruntimepersister">Using <code>StateMachineRuntimePersister</code></a>, respectively.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuring-model"><a class="anchor" href="#configuring-model"></a>Configuring Model</h3>
<div class="paragraph">
<p><code>StateMachineModelFactory</code> is a hook that lets you configure a statemachine model
without using a manual configuration. Essentially, it is a third-party
integration to integrate into a configuration model.
You can hook <code>StateMachineModelFactory</code> into a configuration model by
using a <code>StateMachineModelConfigurer</code>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public static class Config1 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineModelConfigurer&lt;String, String&gt; model) throws Exception {
		model
			.withModel()
				.factory(modelFactory());
	}

	@Bean
	public StateMachineModelFactory&lt;String, String&gt; modelFactory() {
		return new CustomStateMachineModelFactory();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The follwoing example uses <code>CustomStateMachineModelFactory</code> to
define two states (<code>S1</code> and <code>S2</code>) and an event (<code>E1</code>) between those
states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class CustomStateMachineModelFactory implements StateMachineModelFactory&lt;String, String&gt; {

	@Override
	public StateMachineModel&lt;String, String&gt; build() {
		ConfigurationData&lt;String, String&gt; configurationData = new ConfigurationData&lt;&gt;();
		Collection&lt;StateData&lt;String, String&gt;&gt; stateData = new ArrayList&lt;&gt;();
		stateData.add(new StateData&lt;String, String&gt;("S1", true));
		stateData.add(new StateData&lt;String, String&gt;("S2"));
		StatesData&lt;String, String&gt; statesData = new StatesData&lt;&gt;(stateData);
		Collection&lt;TransitionData&lt;String, String&gt;&gt; transitionData = new ArrayList&lt;&gt;();
		transitionData.add(new TransitionData&lt;String, String&gt;("S1", "S2", "E1"));
		TransitionsData&lt;String, String&gt; transitionsData = new TransitionsData&lt;&gt;(transitionData);
		StateMachineModel&lt;String, String&gt; stateMachineModel = new DefaultStateMachineModel&lt;String, String&gt;(configurationData,
				statesData, transitionsData);
		return stateMachineModel;
	}

	@Override
	public StateMachineModel&lt;String, String&gt; build(String machineId) {
		return build();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Defining a custom model is usually not what people are looking for,
although it is possible. However, it is a central concept of allowing
external access to this configuration model.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find an example of using this model factory integration in
<a href="#sm-papyrus">Eclipse Modeling Support</a>. You can find more generic info about custom model integration
in <a href="#devdocs">Developer Documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="statemachine-config-thingstoremember"><a class="anchor" href="#statemachine-config-thingstoremember"></a>Things to Remember</h3>
<div class="paragraph">
<p>When defining actions, guards, or any other references from a
configuration, it pays to remember how Spring Framework works
with beans. In the next example, we have defined a normal configuration with
states <code>S1</code> and <code>S2</code> and four transitions between those. All transitions
are guarded by either <code>guard1</code> or <code>guard2</code>. You must ensure that
<code>guard1</code> is created as a real bean because it is annotated with
<code>@Bean</code>, while <code>guard2</code> is not.</p>
</div>
<div class="paragraph">
<p>This means that event <code>E3</code> would get the <code>guard2</code> condition as
<code>TRUE</code>, and <code>E4</code> would get the <code>guard2</code> condition as <code>FALSE</code>, because those are
coming from plain method calls to those functions.</p>
</div>
<div class="paragraph">
<p>However, because <code>guard1</code> is defined as a <code>@Bean</code>, it is proxied by the
Spring Framework. Thus, additional calls to its method result in
only one instantiation of that instance. Event <code>E1</code> would first get the
proxied instance with condition <code>TRUE</code>, while event <code>E2</code> would get the same
instance with <code>TRUE</code> condition when the method call was defined with
<code>FALSE</code>. This is not a Spring State Machine-specific behavior. Rather, it is
how Spring Framework works with beans.
The following example shows how this arrangement works:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1
		extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("S1").target("S2").event("E1").guard(guard1(true))
				.and()
			.withExternal()
				.source("S1").target("S2").event("E2").guard(guard1(false))
				.and()
			.withExternal()
				.source("S1").target("S2").event("E3").guard(guard2(true))
				.and()
			.withExternal()
				.source("S1").target("S2").event("E4").guard(guard2(false));
	}

	@Bean
	public Guard&lt;String, String&gt; guard1(final boolean value) {
		return new Guard&lt;String, String&gt;() {
			@Override
			public boolean evaluate(StateContext&lt;String, String&gt; context) {
				return value;
			}
		};
	}

	public Guard&lt;String, String&gt; guard2(final boolean value) {
		return new Guard&lt;String, String&gt;() {
			@Override
			public boolean evaluate(StateContext&lt;String, String&gt; context) {
				return value;
			}
		};
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-machineid"><a class="anchor" href="#sm-machineid"></a>State Machine ID</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Various classes and interfaces use <code>machineId</code> either as a variable or as a
parameter in methods. This section takes a closer look at how
<code>machineId</code> relates to normal machine operation and instantiation.</p>
</div>
<div class="paragraph">
<p>During runtime, a <code>machineId</code> really does not have any big operational
role except to distinguish machines from each other&#8201;&#8212;&#8201;for example, when
following logs or doing deeper debugging. Having a lot of different
machine instances quickly gets developers lost in translation if there is
no easy way to identify these instances. As a result, we added the option to set the
<code>machineId</code>.</p>
</div>
<div class="sect2">
<h3 id="using-code-enablestatemachine-code"><a class="anchor" href="#using-code-enablestatemachine-code"></a>Using <code>@EnableStateMachine</code></h3>
<div class="paragraph">
<p>Setting <code>machineId</code> in Java configuration as <code>mymachine</code> then exposes that value
for logs. This same <code>machineId</code> is also available from the
<code>StateMachine.getId()</code> method. The following example uses the <code>machineId</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
		throws Exception {
	config
		.withConfiguration()
			.machineId("mymachine");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example of log output shows the <code>mymachine</code> ID:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">11:23:54,509  INFO main support.LifecycleObjectSupport [main] -
started S2 S1  / S1 / uuid=8fe53d34-8c85-49fd-a6ba-773da15fcaf1 / id=mymachine</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The manual builder (see <a href="#state-machine-via-builder">[state-machine-via-builder]</a>) uses the same configuration
interface, meaning that the behavior is equivalent.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-code-enablestatemachinefactory-code"><a class="anchor" href="#using-code-enablestatemachinefactory-code"></a>Using <code>@EnableStateMachineFactory</code></h3>
<div class="paragraph">
<p>You can see the same <code>machineId</code> getting configured if you use a
<code>StateMachineFactory</code> and request a new machine by using that ID,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">StateMachineFactory&lt;String, String&gt; factory = context.getBean(StateMachineFactory.class);
StateMachine&lt;String, String&gt; machine = factory.getStateMachine("mymachine");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-code-statemachinemodelfactory-code"><a class="anchor" href="#using-code-statemachinemodelfactory-code"></a>Using <code>StateMachineModelFactory</code></h3>
<div class="paragraph">
<p>Behind the scenes, all machine configurations are first translated into a
<code>StateMachineModel</code> so that <code>StateMachineFactory</code> need not know
from where the configuration originated, as a machine can be built from
Java configuration, UML, or a repository. If you want to go crazy, you can also use a custom
<code>StateMachineModel</code>, which is the lowest possible
level at which to define configuration.</p>
</div>
<div class="paragraph">
<p>What do all of these have to do with a <code>machineId</code>?
<code>StateMachineModelFactory</code> also has a method with the following signature:
<code>StateMachineModel&lt;S, E&gt; build(String machineId)</code> which a <code>StateMachineModelFactory</code>
implementation may choose to use.</p>
</div>
<div class="paragraph">
<p><code>RepositoryStateMachineModelFactory</code> (see <a href="#sm-repository">Repository Support</a>) uses
<code>machineId</code> to support different configurations in a persistent
store through Spring Data Repository interfaces. For example, both
<code>StateRepository</code> and <code>TransitionRepository</code> have a method (<code>List&lt;T&gt;
findByMachineId(String machineId)</code>), to build different states and
transitions by a <code>machineId</code>. With
<code>RepositoryStateMachineModelFactory</code>, if <code>machineId</code> is used as empty
or NULL, it defaults to repository configuration (in a backing-persistent model)
without a known machine id.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, <code>UmlStateMachineModelFactory</code> does not distinguish between
different machine IDs, as UML source is always coming from the same
file. This may change in future releases.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-factories"><a class="anchor" href="#sm-factories"></a>State Machine Factories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are use cases when a state machine needs to be created dynamically
instead of by defining static configuration at compile time. For example,
if there are custom components that use their own state machines
and these components are created dynamically, it is impossible to have
a static state machine that is built during the application start. Internally,
state machines are always built through factory interfaces. This then
gives you an option to use this feature programmatically.
Configuration for a state machine factory is exactly the same as shown
in various examples in this document where state machine configuration
is hard coded.</p>
</div>
<div class="sect2">
<h3 id="factory-through-an-adapter"><a class="anchor" href="#factory-through-an-adapter"></a>Factory through an Adapter</h3>
<div class="paragraph">
<p>Actually creating a state machine by using <code>@EnableStateMachine</code>
works through a factory, so <code>@EnableStateMachineFactory</code> merely exposes
that factory through its interface. The following example uses
<code>@EnableStateMachineFactory</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachineFactory
public class Config6
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.S1)
				.end(States.SF)
				.states(EnumSet.allOf(States.class));
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that you have used <code>@EnableStateMachineFactory</code> to create a factory
instead of a state machine bean, you can inject it and use it (as is) to
request new state machines. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Bean3 {

	@Autowired
	StateMachineFactory&lt;States, Events&gt; factory;

	void method() {
		StateMachine&lt;States,Events&gt; stateMachine = factory.getStateMachine();
		stateMachine.start();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="adapter-factory-limitations"><a class="anchor" href="#adapter-factory-limitations"></a>Adapter Factory Limitations</h4>
<div class="paragraph">
<p>The current limitation of factory is that all the actions and guard with which it
associates a state machine share the same instance.
This means that, from your actions and guard, you need to
specifically handle the case in which the same bean is called by different
state machines. This limitation is something that will be resolved in
future releases.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-machine-through-a-builder"><a class="anchor" href="#state-machine-through-a-builder"></a>State Machine through a Builder</h3>
<div class="paragraph">
<p>Using adapters (as shown above) has a limitation imposed by its
requirement to work through Spring <code>@Configuration</code> classes and the
application context. While this is a very clear model to configure a
state machine, it limits configuration at compile time,
which is not always what a user wants to do. If there is a requirement
to build more dynamic state machines, you can use a simple builder pattern
to construct similar instances. By using strings as states and
events, you can use this builder pattern to build fully dynamic state
machines outside of a Spring application context. The following example
shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">StateMachine&lt;String, String&gt; buildMachine1() throws Exception {
	Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();
	builder.configureStates()
		.withStates()
			.initial("S1")
			.end("SF")
			.states(new HashSet&lt;String&gt;(Arrays.asList("S1","S2","S3","S4")));
	return builder.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The builder uses the same configuration interfaces behind the scenes that
the <code>@Configuration</code> model uses for adapter classes. The same model goes to
configuring transitions, states, and common configuration through a builder&#8217;s
methods. This means that whatever you can use with a normal
<code>EnumStateMachineConfigurerAdapter</code> or <code>StateMachineConfigurerAdapter</code>
you can use dynamically through a builder.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, the <code>builder.configureStates()</code>, <code>builder.configureTransitions()</code>,
and <code>builder.configureConfiguration()</code> interface methods cannot be
chained together, meaning that builder methods need to be called individually.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example sets a number of options with a builder:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">StateMachine&lt;String, String&gt; buildMachine2() throws Exception {
	Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();
	builder.configureConfiguration()
		.withConfiguration()
			.autoStartup(false)
			.beanFactory(null)
			.taskExecutor(null)
			.taskScheduler(null)
			.listener(null);
	return builder.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You need to understand when common configuration needs
to be used with machines instantiated from a builder. You can use a configurer
returned from a <code>withConfiguration()</code> to setup <code>autoStart</code>,
<code>TaskScheduler</code>, <code>TaskExecutor</code>, and <code>BeanFactory</code>. You can also use one to register
a <code>StateMachineListener</code>. If a <code>StateMachine</code> instance returned from
a builder is registered as a bean by using <code>@Bean</code>, <code>BeanFactory</code>
is attached automatically and you can find the default <code>TaskExecutor</code>
from there. If you use instances outside of a spring application context,
you must use these methods to set up the needed facilities.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-deferevents"><a class="anchor" href="#sm-deferevents"></a>Using Deferred Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When an event is sent, it may fire an <code>EventTrigger</code>, which may then cause
a transition to happen, if a state machine is in a state where a trigger is
evaluated successfully. Normally, this may lead to a situation where
an event is not accepted and is dropped. However, you may wish
postpone this event until a state machine enters another state. In that case,
you can accept that event. In other words, an event
arrives at an inconvenient time.</p>
</div>
<div class="paragraph">
<p>Spring Statemachine provides a mechanism for deferring events for later
processing. Every state can have a list of deferred events. If an event
in the current state’s deferred event list occurs, the event is saved
(deferred) for future processing until a state is entered that does not list
the event in its deferred event list. When such a state is entered, the
state machine automatically recalls any saved events that are no longer
deferred and then either consumes or discards these events. It is possible
for a superstate to have a transition defined on an event that is deferred
by a substate. Following same hierarchical state machines concepts, the substate
takes precedence over the superstate, the event is deferred, and the
transition for the superstate is not run. With orthogonal regions,
where one orthogonal region defers an event and another accepts the event, the
accept takes precedence and the event is consumed and not deferred.</p>
</div>
<div class="paragraph">
<p>The most obvious use case for event deferring is when an event causes
a transition into a particular state and the state machine is then returned back
to its original state where a second event should cause the same
transition. The following example shows this situation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config5 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("READY")
				.state("DEPLOYPREPARE", "DEPLOY")
				.state("DEPLOYEXECUTE", "DEPLOY");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("READY").target("DEPLOYPREPARE")
				.event("DEPLOY")
				.and()
			.withExternal()
				.source("DEPLOYPREPARE").target("DEPLOYEXECUTE")
				.and()
			.withExternal()
				.source("DEPLOYEXECUTE").target("READY");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the state machine has a state of <code>READY</code>, which indicates that the machine is
ready to process events that would take it into a <code>DEPLOY</code> state, where the
actual deployment would happen. After a deploy action has been run, the machine
is returned back to the <code>READY</code> state. Sending multiple events in a
<code>READY</code> state does not cause any trouble if the machine is using synchronous executors,
because event sending would block between event calls. However, if the executor uses
threads, other events may get lost, because the machine is no longer in a state where
events can be processed. Thus, deferring some of these events lets the machine
preserve them. The following example shows how to configure such an arrangement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config6 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("READY")
				.state("DEPLOY", "DEPLOY")
				.state("DONE")
				.and()
				.withStates()
					.parent("DEPLOY")
					.initial("DEPLOYPREPARE")
					.state("DEPLOYPREPARE", "DONE")
					.state("DEPLOYEXECUTE");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("READY").target("DEPLOY")
				.event("DEPLOY")
				.and()
			.withExternal()
				.source("DEPLOYPREPARE").target("DEPLOYEXECUTE")
				.and()
			.withExternal()
				.source("DEPLOYEXECUTE").target("READY")
				.and()
			.withExternal()
				.source("READY").target("DONE")
				.event("DONE")
				.and()
			.withExternal()
				.source("DEPLOY").target("DONE")
				.event("DONE");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the state machine uses nested states instead of a flat
state model, so the <code>DEPLOY</code> event can be deferred directly in a substate.
It also shows the concept of deferring the <code>DONE</code> event in a
sub-state that would then override the anonymous transition between
the <code>DEPLOY</code> and <code>DONE</code> states if the state machine happens to be in a
<code>DEPLOYPREPARE</code> state when the <code>DONE</code> event is dispatched. In the
<code>DEPLOYEXECUTE</code> state when the <code>DONE</code> event is not deferred, this event would
be handled in a super state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-scopes"><a class="anchor" href="#sm-scopes"></a>Using Scopes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Support for scopes in a state machine is very limited, but you can
enable <code>session</code> scope by using a normal Spring <code>@Scope</code> annotation in one of two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the state machine is built manually by using a builder and returned into the
context as a <code>@Bean</code>.</p>
</li>
<li>
<p>Through a configuration adapter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both of
these need <code>@Scope</code> to be present, with <code>scopeName</code> set to
<code>session</code> and <code>proxyMode</code> set to <code>ScopedProxyMode.TARGET_CLASS</code>. The following examples
show both use cases:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class Config3 {

	@Bean
	@Scope(scopeName="session", proxyMode=ScopedProxyMode.TARGET_CLASS)
	StateMachine&lt;String, String&gt; stateMachine() throws Exception {
		Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();
		builder.configureConfiguration()
			.withConfiguration()
				.autoStartup(true)
				.taskExecutor(new SyncTaskExecutor());
		builder.configureStates()
			.withStates()
				.initial("S1")
				.state("S2");
		builder.configureTransitions()
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1");
		StateMachine&lt;String, String&gt; stateMachine = builder.build();
		return stateMachine;
	}

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
@Scope(scopeName="session", proxyMode=ScopedProxyMode.TARGET_CLASS)
public static class Config4 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config) throws Exception {
		config
			.withConfiguration()
				.autoStartup(true);
	}

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states) throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions) throws Exception {
		transitions
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1");
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>TIP:See <a href="#statemachine-examples-scope">Scope</a> for how to use session scoping.</p>
</div>
<div class="paragraph">
<p>Once you have scoped a state machine into <code>session</code>, autowiring it into
a <code>@Controller</code> gives a new state machine instance per session.
Each state machine is then destroyed when <code>HttpSession</code> is invalidated.
The following example shows how to use a state machine in a controller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class StateMachineController {

	@Autowired
	StateMachine&lt;String, String&gt; stateMachine;

	@RequestMapping(path="/state", method=RequestMethod.POST)
	public HttpEntity&lt;Void&gt; setState(@RequestParam("event") String event) {
		stateMachine.sendEvent(event);
		return new ResponseEntity&lt;Void&gt;(HttpStatus.ACCEPTED);
	}

	@RequestMapping(path="/state", method=RequestMethod.GET)
	@ResponseBody
	public String getState() {
		return stateMachine.getState().getId();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using state machines in a <code>session</code> scopes needs careful planning,
mostly because it is a relatively heavy component.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Statemachine poms have no dependencies to Spring MVC
classes, which you will need to work with session scope. However, if you are
working with a web application, you have already pulled those dependencies
directly from Spring MVC or Spring Boot.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-actions"><a class="anchor" href="#sm-actions"></a>Using Actions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Actions are one of the most useful components that you can use to
interact and collaborate with a state machine. You can run actions
in various places in a state machine and its states lifecycle&#8201;&#8212;&#8201;for example,
entering or exiting states or during transitions.
The following example shows how to use actions in a state machine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
		throws Exception {
	states
		.withStates()
			.initial(States.SI)
			.state(States.S1, action1(), action2())
			.state(States.S2, action1(), action2())
			.state(States.S3, action1(), action3());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>action1</code> and <code>action2</code> beans are attached to the <code>entry</code> and
<code>exit</code> states, respectively. The following example defines those actions (and <code>action3</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public Action&lt;States, Events&gt; action1() {
	return new Action&lt;States, Events&gt;() {

		@Override
		public void execute(StateContext&lt;States, Events&gt; context) {
		}
	};
}

@Bean
public BaseAction action2() {
	return new BaseAction();
}

@Bean
public SpelAction action3() {
	ExpressionParser parser = new SpelExpressionParser();
	return new SpelAction(
			parser.parseExpression(
					"stateMachine.sendEvent(T(org.springframework.statemachine.docs.Events).E1)"));
}

public class BaseAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
	}
}

public class SpelAction extends SpelExpressionAction&lt;States, Events&gt; {

	public SpelAction(Expression expression) {
		super(expression);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can directly implement <code>Action</code> as an anonymous function or create
your own implementation and define the appropriate implementation as a
bean.</p>
</div>
<div class="paragraph">
<p>In the preceding example, <code>action3</code> uses a SpEL expression to send the <code>Events.E1</code> event into
a state machine.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>StateContext</code> is described in <a href="#sm-statecontext">Using <code>StateContext</code></a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="spel-expressions-with-actions"><a class="anchor" href="#spel-expressions-with-actions"></a>SpEL Expressions with Actions</h3>
<div class="paragraph">
<p>You can also use a SpEL expression as a replacement for a
full <code>Action</code> implementation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-guards"><a class="anchor" href="#sm-guards"></a>Using Guards</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As shown in <a href="#statemachine\-config\-thingstoremember">[statemachine\-config\-thingstoremember]</a>, the <code>guard1</code> and <code>guard2</code> beans are attached to the entry and
exit states, respectively.
The following example also uses guards on events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.SI).target(States.S1)
			.event(Events.E1)
			.guard(guard1())
			.and()
		.withExternal()
			.source(States.S1).target(States.S2)
			.event(Events.E1)
			.guard(guard2())
			.and()
		.withExternal()
			.source(States.S2).target(States.S3)
			.event(Events.E2)
			.guardExpression("extendedState.variables.get('myvar')");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can directly implement <code>Guard</code> as an anonymous function or create
your own implementation and define the appropriate implementation as a
bean. In the preceding example, <code>guardExpression</code> checkS whether the extended
state variable named <code>myvar</code> evaluates to <code>TRUE</code>.
The following example implements some sample guards:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public Guard&lt;States, Events&gt; guard1() {
	return new Guard&lt;States, Events&gt;() {

		@Override
		public boolean evaluate(StateContext&lt;States, Events&gt; context) {
			return true;
		}
	};
}

@Bean
public BaseGuard guard2() {
	return new BaseGuard();
}

public class BaseGuard implements Guard&lt;States, Events&gt; {

	@Override
	public boolean evaluate(StateContext&lt;States, Events&gt; context) {
		return false;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>StateContext</code> is described in section <a href="#sm-statecontext">Using <code>StateContext</code></a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="spel-expressions-with-guards"><a class="anchor" href="#spel-expressions-with-guards"></a>SpEL Expressions with Guards</h3>
<div class="paragraph">
<p>You can also use a SpEL expression as a replacement for a
full Guard implementation. The only requirement is that the expression needs
to return a <code>Boolean</code> value to satisfy the <code>Guard</code> implementation. This can be
demonstrated with a <code>guardExpression()</code> function that takes an
expression as an argument.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-extendedstate"><a class="anchor" href="#sm-extendedstate"></a>Using Extended State</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Assume that you need to create a state machine that tracks how
many times a user is pressing a key on a keyboard and then terminates
when keys are pressed 1000 times. A possible but really naive solution
would be to create a new state for each 1000 key presses.
You might suddenly have an astronomical number of
states, which, naturally, is not very practical.</p>
</div>
<div class="paragraph">
<p>This is where extended state variables come to the rescue by not needing
to add more states to drive state machine changes. Instead,
you can do a simple variable change during a transition.</p>
</div>
<div class="paragraph">
<p><code>StateMachine</code> has a method called <code>getExtendedState()</code>. It returns an
interface called <code>ExtendedState</code>, which gives access to extended state
variables. You can access these variables directly through a state machine or through
<code>StateContext</code> during a callback from actions or transitions.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public Action&lt;String, String&gt; myVariableAction() {
	return new Action&lt;String, String&gt;() {

		@Override
		public void execute(StateContext&lt;String, String&gt; context) {
			context.getExtendedState()
				.getVariables().put("mykey", "myvalue");
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to get notified for extended state variable
changes, you have two options: either use <code>StateMachineListener</code> or
listen for <code>extendedStateChanged(key, value)</code> callbacks. The following example
uses the <code>extendedStateChanged</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExtendedStateVariableListener
		extends StateMachineListenerAdapter&lt;String, String&gt; {

	@Override
	public void extendedStateChanged(Object key, Object value) {
		// do something with changed variable
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can implement a Spring Application context listener for
<code>OnExtendedStateChanged</code>. As mentioned in <a href="#sm-listeners">Listening to State Machine Events</a>,
you can also listen all <code>StateMachineEvent</code> events.
The following example uses <code>onApplicationEvent</code> to listen for state changes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExtendedStateVariableEventListener
		implements ApplicationListener&lt;OnExtendedStateChanged&gt; {

	@Override
	public void onApplicationEvent(OnExtendedStateChanged event) {
		// do something with changed variable
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-statecontext"><a class="anchor" href="#sm-statecontext"></a>Using <code>StateContext</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-statemachine/docs/{spring-statemachine-version}/api/org/springframework/statemachine/StateContext.html"><code>StateContext</code></a> is one of the most important objects
when working with a state machine, as it is passed into various methods
and callbacks to give the current state of a state machine and
where it is possibly going. You can think of it as a
snapshot of the current state machine stage when
is when <code>StateContext</code> is retreived.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Spring Statemachine 1.0.x, <code>StateContext</code> usage was relatively naive
in terms of how it was used to pass stuff around as a simple &#8220;POJO&#8221;.
Starting from Spring Statemachine 1.1.x, its role has been greatly
improved by making it a first class citizen in a state machine.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use <code>StateContext</code> to get access to the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The current <code>Message</code> or <code>Event</code> (or their <code>MessageHeaders</code>, if known).</p>
</li>
<li>
<p>The state machine&#8217;s <code>Extended State</code>.</p>
</li>
<li>
<p>The <code>StateMachine</code> itself.</p>
</li>
<li>
<p>To possible state machine errors.</p>
</li>
<li>
<p>To the current <code>Transition</code>, if applicable.</p>
</li>
<li>
<p>The source state of the state machine.</p>
</li>
<li>
<p>The target state of the state machine.</p>
</li>
<li>
<p>The current <code>Stage</code>, as described in <a href="#sm-statecontext-stage">Stages</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>StateContext</code> is passed into various components, such as
<code>Action</code> and <code>Guard</code>.</p>
</div>
<div class="sect2">
<h3 id="sm-statecontext-stage"><a class="anchor" href="#sm-statecontext-stage"></a>Stages</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-statemachine/docs/{spring-statemachine-version}/api/org/springframework/statemachine/StateContext.Stage.html"><code>Stage</code></a> is arepresentation of a <code>stage</code> on
which a state machine is currently interacting with a user. The currently available
stages are <code>EVENT_NOT_ACCEPTED</code>, <code>EXTENDED_STATE_CHANGED</code>,
<code>STATE_CHANGED</code>, <code>STATE_ENTRY</code>, <code>STATE_EXIT</code>, <code>STATEMACHINE_ERROR</code>,
<code>STATEMACHINE_START</code>, <code>STATEMACHINE_STOP</code>, <code>TRANSITION</code>,
<code>TRANSITION_START</code>, and <code>TRANSITION_END</code>. These states may look familiar, as
they match how you can interact with listeners (as described in
<a href="#sm-listeners">Listening to State Machine Events</a>).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-triggers"><a class="anchor" href="#sm-triggers"></a>Triggering Transitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Driving a state machine is done by using transitions, which are triggered
by triggers. The currently supported triggers are <code>EventTrigger</code> and
<code>TimerTrigger</code>.</p>
</div>
<div class="sect2">
<h3 id="using-code-eventtrigger-code"><a class="anchor" href="#using-code-eventtrigger-code"></a>Using <code>EventTrigger</code></h3>
<div class="paragraph">
<p><code>EventTrigger</code> is the most useful trigger, because it lets you
directly interact with a state machine by sending events to it. These
events are also called signals. You can add a trigger to a transition
by associating a state with it during configuration.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateMachine&lt;States, Events&gt; stateMachine;

void signalMachine() {
	stateMachine.sendEvent(Events.E1);

	Message&lt;Events&gt; message = MessageBuilder
			.withPayload(Events.E2)
			.setHeader("foo", "bar")
			.build();
	stateMachine.sendEvent(message);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example sends an event two different ways. First, it
sends a type-safe event by using the state machine API method called
<code>sendEvent(E event)</code>. Second, it sends an event wrapped in a Spring
messaging <code>Message</code> by using the API method called <code>sendEvent(Message&lt;E&gt; message)</code>
with a custom event headers. This lets us add arbitrary extra
information to an event, which is then visible to <code>StateContext</code> when
(for example) you implement actions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Message headers are generally passed on until machine runs to
completion for a specific event. For example if an event is causing
transition into a state <code>A</code> which have an anonymous transition into a
state <code>B</code>, original event is available for actions or guards in state
<code>B</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-code-timertrigger-code"><a class="anchor" href="#using-code-timertrigger-code"></a>Using <code>TimerTrigger</code></h3>
<div class="paragraph">
<p><code>TimerTrigger</code> is useful when something needs to be triggered
automatically without any user interaction. <code>Trigger</code> is added to a
transition by associating a timer with it during a configuration.</p>
</div>
<div class="paragraph">
<p>Currently, there are two types of supported timers, one that fires
continuously and one that fires once a source state is entered.
The following example shows how to use the triggers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config2 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2")
				.state("S3");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("S1").target("S2").event("E1")
				.and()
			.withExternal()
				.source("S1").target("S3").event("E2")
				.and()
			.withInternal()
				.source("S2")
				.action(timerAction())
				.timer(1000)
				.and()
			.withInternal()
				.source("S3")
				.action(timerAction())
				.timerOnce(1000);
	}

	@Bean
	public TimerAction timerAction() {
		return new TimerAction();
	}
}

public class TimerAction implements Action&lt;String, String&gt; {

	@Override
	public void execute(StateContext&lt;String, String&gt; context) {
		// do something in every 1 sec
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example has three states: <code>S1</code>, <code>S2</code>, and <code>S3</code>. We have a normal
external transition from <code>S1</code> to <code>S2</code> and from <code>S1</code> to <code>S3</code> with
events <code>E1</code> and <code>E2</code>, respectively. The interesting parts
for working with <code>TimerTrigger</code> are when we define
internal transitions for source states <code>S2</code> and <code>S3</code>.</p>
</div>
<div class="paragraph">
<p>For both transitions, we invoke the <code>Action</code> bean (<code>timerAction</code>), where
source state <code>S2</code> uses <code>timer</code> and <code>S3</code> uses <code>timerOnce</code>.
Values given are in milliseconds (<code>1000</code> milliseconds, or one second, in both cases).</p>
</div>
<div class="paragraph">
<p>Once a state machine receives event <code>E1</code>, it does a transition
from <code>S1</code> to <code>S2</code> and the timer kicks in. When the state is <code>S2</code>,
<code>TimerTrigger</code> runs and causes a transition associated with that
state&#8201;&#8212;&#8201;in this case, the internal transition that has the
<code>timerAction</code> defined.</p>
</div>
<div class="paragraph">
<p>Once a state machine receives the <code>E2</code>, event it does a transition
from <code>S1</code> to <code>S3</code> and the timer kicks in. This timer is executed only once
after the state is entered (after a delay defined in a timer).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Behind the scenes, timers are simple triggers that may cause a
transition to happen. Defining a transition with a <code>timer()</code> keeps
firing triggers and causes transition only if the source state is active.
Transition with <code>timerOnce()</code> is a little different, as it
triggers only after a delay when a source state is actually entered.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>timerOnce()</code> if you want something to happen after a delay
exactly once when state is entered.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-listeners"><a class="anchor" href="#sm-listeners"></a>Listening to State Machine Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are use cases where you want to know what is happening with
a state machine, react to something, or get logging details for
debugging purposes. Spring Statemachine provides interfaces for adding listeners. These listeners
then give an option to get callbacks when various state changes,
actions, and so on happen.</p>
</div>
<div class="paragraph">
<p>You basically have two options: listen to Spring application
context events or directly attach a listener to a state machine. Both of
these basically provide the same information. One produces
events as event classes, and the other produces callbacks via a listener
interface. Both of these have pros and cons, which we discuss later.</p>
</div>
<div class="sect2">
<h3 id="application-context-events"><a class="anchor" href="#application-context-events"></a>Application Context Events</h3>
<div class="paragraph">
<p>Application context events classes are <code>OnTransitionStartEvent</code>,
<code>OnTransitionEvent</code>, <code>OnTransitionEndEvent</code>, <code>OnStateExitEvent</code>,
<code>OnStateEntryEvent</code>, <code>OnStateChangedEvent</code>, <code>OnStateMachineStart</code>,
<code>OnStateMachineStop</code>, and others that extend the base event class,
<code>StateMachineEvent</code>. These can be used as is with a Spring
<code>ApplicationListener</code>.</p>
</div>
<div class="paragraph">
<p><code>StateMachine</code> sends context events through <code>StateMachineEventPublisher</code>.
The default implementation is automatically created if a <code>@Configuration</code>
class is annotated with <code>@EnableStateMachine</code>.
The following example gets a <code>StateMachineApplicationEventListener</code>
from a bean defined in a <code>@Configuration</code> class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class StateMachineApplicationEventListener
		implements ApplicationListener&lt;StateMachineEvent&gt; {

	@Override
	public void onApplicationEvent(StateMachineEvent event) {
	}
}

@Configuration
public class ListenerConfig {

	@Bean
	public StateMachineApplicationEventListener contextListener() {
		return new StateMachineApplicationEventListener();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Context events are also automatically enabled by using <code>@EnableStateMachine</code>,
with <code>StateMachine</code> used to build a machine and registered as a bean,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class ManualBuilderConfig {

	@Bean
	public StateMachine&lt;String, String&gt; stateMachine() throws Exception {

		Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();
		builder.configureStates()
			.withStates()
				.initial("S1")
				.state("S2");
		builder.configureTransitions()
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1");
		return builder.build();
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-code-statemachinelistener-code"><a class="anchor" href="#using-code-statemachinelistener-code"></a>Using <code>StateMachineListener</code></h3>
<div class="paragraph">
<p>By using <code>StateMachineListener</code>, you can either extend it and
implement all callback methods or use the <code>StateMachineListenerAdapter</code>
class, which contains stub method implementations and choose which ones
to override.
The following example uses the latter approach:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class StateMachineEventListener
		extends StateMachineListenerAdapter&lt;States, Events&gt; {

	@Override
	public void stateChanged(State&lt;States, Events&gt; from, State&lt;States, Events&gt; to) {
	}

	@Override
	public void stateEntered(State&lt;States, Events&gt; state) {
	}

	@Override
	public void stateExited(State&lt;States, Events&gt; state) {
	}

	@Override
	public void transition(Transition&lt;States, Events&gt; transition) {
	}

	@Override
	public void transitionStarted(Transition&lt;States, Events&gt; transition) {
	}

	@Override
	public void transitionEnded(Transition&lt;States, Events&gt; transition) {
	}

	@Override
	public void stateMachineStarted(StateMachine&lt;States, Events&gt; stateMachine) {
	}

	@Override
	public void stateMachineStopped(StateMachine&lt;States, Events&gt; stateMachine) {
	}

	@Override
	public void eventNotAccepted(Message&lt;Events&gt; event) {
	}

	@Override
	public void extendedStateChanged(Object key, Object value) {
	}

	@Override
	public void stateMachineError(StateMachine&lt;States, Events&gt; stateMachine, Exception exception) {
	}

	@Override
	public void stateContext(StateContext&lt;States, Events&gt; stateContext) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we created our own listener class
(<code>StateMachineEventListener</code>) that extends
<code>StateMachineListenerAdapter</code>.</p>
</div>
<div class="paragraph">
<p>The <code>stateContext</code> listener method gives access to various
<code>StateContext</code> changes on a different stages. You can find more about about it in
<a href="#sm-statecontext">Using <code>StateContext</code></a>.</p>
</div>
<div class="paragraph">
<p>Once you have defined your own listener, you can registered it in a
state machine by using the <code>addStateListener</code> method. It is a matter of
flavor whether to hook it up within a spring configuration or do it
manually at any time during the application life-cycle.
The following example shows how to attach a listener:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Config7 {

	@Autowired
	StateMachine&lt;States, Events&gt; stateMachine;

	@Bean
	public StateMachineEventListener stateMachineEventListener() {
		StateMachineEventListener listener = new StateMachineEventListener();
		stateMachine.addStateListener(listener);
		return listener;
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="limitations-and-problems"><a class="anchor" href="#limitations-and-problems"></a>Limitations and Problems</h3>
<div class="paragraph">
<p>Spring application context is not the fastest event bus out there, so we
advise giving some thought to the rate of events the state machine
sends. For better performance, it may be better to use the
<code>StateMachineListener</code> interface. For this specific reason,
you can use the <code>contextEvents</code> flag with <code>@EnableStateMachine</code> and
<code>@EnableStateMachineFactory</code> to disable Spring application context
events, as shown in the preceding section.
The following example shows how to disable Spring application context events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine(contextEvents = false)
public class Config8
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {
}

@Configuration
@EnableStateMachineFactory(contextEvents = false)
public class Config9
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-context"><a class="anchor" href="#sm-context"></a>Context Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is a little limited to do interaction with a state machine by
either listening to its events or using actions with states and
transitions. From time to time, this approach is going be too limited and
verbose to create interaction with the application with which a state machine
works. For this specific use case, we have made a Spring-style
context integration that easily inserts state machine functionality
into your beans.</p>
</div>
<div class="paragraph">
<p>The available annotations has been harmonized to enable access to the same
state machine execution points that are available from
<a href="#sm-listeners">Listening to State Machine Events</a>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>@WithStateMachine</code> annotation to associate a state
machine with an existing bean. Then you can start adding
supported annotations to the methods of that bean.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean1 {

	@OnTransition
	public void anyTransition() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also attach any other state machine from an
application context by using the annotation <code>name</code> field.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine(name = "myMachineBeanName")
public class Bean2 {

	@OnTransition
	public void anyTransition() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Sometimes, it is more convenient to use <code>machine id</code>, which is something
you can set to better identify multiple instances. This ID maps to
the <code>getId()</code> method in the <code>StateMachine</code> interface.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine(id = "myMachineId")
public class Bean16 {

	@OnTransition
	public void anyTransition() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use <code>@WithStateMachine</code> as a meta-annotation, as shown
in the preceding example. In this case, you could annotate your bean with <code>WithMyBean</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@WithStateMachine(name = "myMachineBeanName")
public @interface WithMyBean {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The return type of these methods does not matter and is effectively
discarded.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="enabling-integration"><a class="anchor" href="#enabling-integration"></a>Enabling Integration</h3>
<div class="paragraph">
<p>You can enable all the features of <code>@WithStateMachine</code> by using
the <code>@EnableWithStateMachine</code> annotation, which imports the needed
configuration into the Spring Application Context. Both
<code>@EnableStateMachine</code> and <code>@EnableStateMachineFactory</code> are already
annotated with this annotation, so there is no need to add it again.
However, if a machine is built and configured without
configuration adapters, you must use <code>@EnableWithStateMachine</code>
to use these features with <code>@WithStateMachine</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static StateMachine&lt;String, String&gt; buildMachine(BeanFactory beanFactory) throws Exception {
	Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();

	builder.configureConfiguration()
		.withConfiguration()
			.machineId("myMachineId")
			.beanFactory(beanFactory);

	builder.configureStates()
		.withStates()
			.initial("S1")
			.state("S2");

	builder.configureTransitions()
		.withExternal()
			.source("S1")
			.target("S2")
			.event("E1");

	return builder.build();
}

@WithStateMachine(id = "myMachineId")
static class Bean17 {

	@OnStateChanged
	public void onStateChanged() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If a machine is not created as a bean, you need to set
<code>BeanFactory</code> for a machine, as shown in the prededing example. Otherwise, tge machine is
unaware of handlers that call your <code>@WithStateMachine</code> methods.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="method-parameters"><a class="anchor" href="#method-parameters"></a>Method Parameters</h3>
<div class="paragraph">
<p>Every annotation support exactly the same set of possible method
parameters, but runtime behavior differs, depending on the
annotation itself and the stage in which the annotated method is called. To
better understand how context works, see
<a href="#sm-statecontext">Using <code>StateContext</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For differences between method parameters, see the sections that desdribe the
individual annotation, later in this document.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Effectively, all annotated methods are called by using Spring SPel
expressions, which are built dynamically during the process. To make
this work, these expressions needs to have a root object (against which they evaluate).
This root object is a <code>StateContext</code>. We have also made some
tweaks internally so that it is possible to  access <code>StateContext</code> methods
directly without going through the context handle.</p>
</div>
<div class="paragraph">
<p>The simplest method parameter is a <code>StateContext</code> itself.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean3 {

	@OnTransition
	public void anyTransition(StateContext&lt;String, String&gt; stateContext) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can access the rest of the <code>StateContext</code> content.
Tke number and order of the parameters does not matter.
The following example shows how to access the various parts of the <code>StateContext</code> content:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean4 {

	@OnTransition
	public void anyTransition(
			@EventHeaders Map&lt;String, Object&gt; headers,
			@EventHeader("myheader1") Object myheader1,
			@EventHeader(name = "myheader2", required = false) String myheader2,
			ExtendedState extendedState,
			StateMachine&lt;String, String&gt; stateMachine,
			Message&lt;String&gt; message,
			Exception e) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Instead of getting all event headers with <code>@EventHeaders</code>, you can use
<code>@EventHeader</code>, which can bound to a single header.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="state-machine-transition-annotations"><a class="anchor" href="#state-machine-transition-annotations"></a>Transition Annotations</h3>
<div class="paragraph">
<p>The annotations for transitions are <code>@OnTransition</code>, <code>@OnTransitionStart</code>,
and <code>@OnTransitionEnd</code>.</p>
</div>
<div class="paragraph">
<p>These annotations behave exactly the same. To show how they work, we show
how <code>@OnTransition</code> is used. Within this annotation, a property&#8217;s
you can use <code>source</code> and <code>target</code> to qualify a transition. If
<code>source</code> and <code>target</code> are left empty, any transition is matched.
The following example shows how to use the <code>@OnTransition</code> annotation
(remember that <code>@OnTransitionStart</code> and <code>@OnTransitionEnd</code> work the same way):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean5 {

	@OnTransition(source = "S1", target = "S2")
	public void fromS1ToS2() {
	}

	@OnTransition
	public void anyTransition() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, you cannot use the <code>@OnTransition</code> annotation with a state and
event enumerations that you have created, due to Java language limitations.
For this reason, you need to use string representations.</p>
</div>
<div class="paragraph">
<p>Additionally, you can access <code>Event Headers</code> and
<code>ExtendedState</code> by adding the needed arguments to a method. The method
is then called automatically with these arguments.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean6 {

	@StatesOnTransition(source = States.S1, target = States.S2)
	public void fromS1ToS2(@EventHeaders Map&lt;String, Object&gt; headers, ExtendedState extendedState) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, if you want to have a type-safe annotation, you can
create a new annotation and use <code>@OnTransition</code> as a meta-annotation.
This user-level annotation can make references to actual states and
events enumerations, and the framework tries to match these in the same way.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@OnTransition
public @interface StatesOnTransition {

	States[] source() default {};

	States[] target() default {};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example,  we created a <code>@StatesOnTransition</code> annotation that defines
<code>source</code> and <code>target</code> in a type-safe manner.
The following example uses that annotation in a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean7 {

	@StatesOnTransition(source = States.S1, target = States.S2)
	public void fromS1ToS2() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-annotations"><a class="anchor" href="#state-annotations"></a>State Annotations</h3>
<div class="paragraph">
<p>The following annotations for states are available: <code>@OnStateChanged</code>, <code>@OnStateEntry</code>, and
<code>@OnStateExit</code>. The following example shows how to use <code>OnStateChanged</code> annotation (the
other two work the same way):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean8 {

	@OnStateChanged
	public void anyStateChange() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can with <a href="#state-machine-transition-annotations">Transition Annotations</a>, you can define
target and source states. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean9 {

	@OnStateChanged(source = "S1", target = "S2")
	public void stateChangeFromS1toS2() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For type safety, new annotations need to be created for enumerations by using
<code>@OnStateChanged</code> as a meta-annotation. The following examples show how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@OnStateChanged
public @interface StatesOnStates {

	States[] source() default {};

	States[] target() default {};
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean10 {

	@StatesOnStates(source = States.S1, target = States.S2)
	public void fromS1ToS2() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The methods for state entry and exit behave in the same way, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean11 {

	@OnStateEntry
	public void anyStateEntry() {
	}

	@OnStateExit
	public void anyStateExit() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="event-annotation"><a class="anchor" href="#event-annotation"></a>Event Annotation</h3>
<div class="paragraph">
<p>There is one event-related annotation. It is named <code>@OnEventNotAccepted</code>.
If you specify the <code>event</code> property, you can listen for a specific event not being
accepted. If you do not specify an event, you can list for any event not being
accepted. The following example shows both ways to use the <code>@OnEventNotAccepted</code>
annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean12 {

	@OnEventNotAccepted
	public void anyEventNotAccepted() {
	}

	@OnEventNotAccepted(event = "E1")
	public void e1EventNotAccepted() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-machine-annotations"><a class="anchor" href="#state-machine-annotations"></a>State Machine Annotations</h3>
<div class="paragraph">
<p>The following annotations are available for a state machine: <code>@OnStateMachineStart</code>,
<code>@OnStateMachineStop</code>, and <code>@OnStateMachineError</code>.</p>
</div>
<div class="paragraph">
<p>During a state machine&#8217;s start and stop, lifecycle methods are called.
The following example shows how to use <code>@OnStateMachineStart</code> and
<code>@OnStateMachineStop</code> to listen to these events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean13 {

	@OnStateMachineStart
	public void onStateMachineStart() {
	}

	@OnStateMachineStop
	public void onStateMachineStop() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If a state machine goes into an error with exception, <code>@OnStateMachineStop</code>
annotation is called. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean14 {

	@OnStateMachineError
	public void onStateMachineError() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extended-state-annotation"><a class="anchor" href="#extended-state-annotation"></a>Extended State Annotation</h3>
<div class="paragraph">
<p>There is one extended state-related annotation. It is named
<code>@OnExtendedStateChanged</code>. You can also listen to changes only
for specific <code>key</code> changes. The following example shows how to use the
<code>@OnExtendedStateChanged</code>, both with and without a <code>key</code> property:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class Bean15 {

	@OnExtendedStateChanged
	public void anyStateChange() {
	}

	@OnExtendedStateChanged(key = "key1")
	public void key1Changed() {
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-accessor"><a class="anchor" href="#sm-accessor"></a>Using <code>StateMachineAccessor</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>StateMachine</code> is the main interface for communicating with a state machine.
From time to time, you may need to get more dynamic and
programmatic access to internal structures of a state machine and its
nested machines and regions. For these use cases, <code>StateMachine</code>
exposes a functional interface called <code>StateMachineAccessor</code>, which provides
an interface to get access to individual <code>StateMachine</code> and
<code>Region</code> instances.</p>
</div>
<div class="paragraph">
<p><code>StateMachineFunction</code> is a simple functional interface that lets
you apply the <code>StateMachineAccess</code> interface to a state machine. With
JDK 7, these create code that is a little verbose code. However, with JDK 8 lambdas,
the doce is relatively non-verbose.</p>
</div>
<div class="paragraph">
<p>The <code>doWithAllRegions</code> method gives access to all <code>Region</code> instances in
a state machine. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">stateMachine.getStateMachineAccessor().doWithAllRegions(new StateMachineFunction&lt;StateMachineAccess&lt;String,String&gt;&gt;() {

	@Override
	public void apply(StateMachineAccess&lt;String, String&gt; function) {
		function.setRelay(stateMachine);
	}
});

stateMachine.getStateMachineAccessor()
	.doWithAllRegions(access -&gt; access.setRelay(stateMachine));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>doWithRegion</code> method gives access to single <code>Region</code> instance in a
state machine. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">stateMachine.getStateMachineAccessor().doWithRegion(new StateMachineFunction&lt;StateMachineAccess&lt;String,String&gt;&gt;() {

	@Override
	public void apply(StateMachineAccess&lt;String, String&gt; function) {
		function.setRelay(stateMachine);
	}
});

stateMachine.getStateMachineAccessor()
	.doWithRegion(access -&gt; access.setRelay(stateMachine));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>withAllRegions</code> method gives access to all of the <code>Region</code> instances in
a state machine. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">for (StateMachineAccess&lt;String, String&gt; access : stateMachine.getStateMachineAccessor().withAllRegions()) {
	access.setRelay(stateMachine);
}

stateMachine.getStateMachineAccessor().withAllRegions()
	.stream().forEach(access -&gt; access.setRelay(stateMachine));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>withRegion</code> method gives access to single <code>Region</code> instance in a
state machine. The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">stateMachine.getStateMachineAccessor()
	.withRegion().setRelay(stateMachine);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-interceptor"><a class="anchor" href="#sm-interceptor"></a>Using <code>StateMachineInterceptor</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Instead of using a <code>StateMachineListener</code> interface, you can
use a <code>StateMachineInterceptor</code>. One conceptual difference is that you can use an
interceptor to intercept and stop a current state
change or change its transition logic. Instead of implementing a full interface,
you can use an adapter class called <code>StateMachineInterceptorAdapter</code> to override
the default no-op methods.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One recipe (<a href="#statemachine-recipes-persist">Persist</a>) and one sample
(<a href="#statemachine-examples-persist">Persist</a>) are related to using an
interceptor.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can register an interceptor through <code>StateMachineAccessor</code>. The concept of
an interceptor is a relatively deep internal feature and, thus, is not
exposed directly through the <code>StateMachine</code> interface.</p>
</div>
<div class="paragraph">
<p>The following example shows how to add a <code>StateMachineInterceptor</code> and override selected
methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">stateMachine.getStateMachineAccessor()
	.withRegion().addStateMachineInterceptor(new StateMachineInterceptor&lt;String, String&gt;() {

		@Override
		public Message&lt;String&gt; preEvent(Message&lt;String&gt; message, StateMachine&lt;String, String&gt; stateMachine) {
			return message;
		}

		@Override
		public StateContext&lt;String, String&gt; preTransition(StateContext&lt;String, String&gt; stateContext) {
			return stateContext;
		}

		@Override
		public void preStateChange(State&lt;String, String&gt; state, Message&lt;String&gt; message,
				Transition&lt;String, String&gt; transition, StateMachine&lt;String, String&gt; stateMachine) {
		}

		@Override
		public void preStateChange(State&lt;String, String&gt; state, Message&lt;String&gt; message,
				Transition&lt;String, String&gt; transition, StateMachine&lt;String, String&gt; stateMachine,
				StateMachine&lt;String, String&gt; rootStateMachine) {
		}

		@Override
		public StateContext&lt;String, String&gt; postTransition(StateContext&lt;String, String&gt; stateContext) {
			return stateContext;
		}

		@Override
		public void postStateChange(State&lt;String, String&gt; state, Message&lt;String&gt; message,
				Transition&lt;String, String&gt; transition, StateMachine&lt;String, String&gt; stateMachine) {
		}

		@Override
		public void postStateChange(State&lt;String, String&gt; state, Message&lt;String&gt; message,
				Transition&lt;String, String&gt; transition, StateMachine&lt;String, String&gt; stateMachine,
				StateMachine&lt;String, String&gt; rootStateMachine) {
		}

		@Override
		public Exception stateMachineError(StateMachine&lt;String, String&gt; stateMachine,
				Exception exception) {
			return exception;
		}
	});</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more about the error handling shown in preceding example, see
<a href="#sm-error-handling">State Machine Error Handling</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-security"><a class="anchor" href="#sm-security"></a>State Machine Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Security features are built atop of functionality from
<a href="https://projects.spring.io/spring-security">Spring Security</a>. Security features are
handy when it is required to protect part of a state machine
execution and interaction with it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
We expect you to be fairly familiar with Spring Security, meaning
that we do not go into details of how the overall security framework works. For
this information, you should read the Spring Security reference documentation
(available <a href="https://spring.io/projects/spring-security#learn">here</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first level of defense with security is naturally protecting events,
which really drive what is going to
happen in a state machine. You can then define more fine-grained security settings
for transitions and actions. This parallel to giving an employee access to a building
and then giving access to specific rooms within the building and even the ability
to turn on and off the lights in specific rooms. If you trust
your users, event security may be all you need. If not,
you need to apply more detailed security.</p>
</div>
<div class="paragraph">
<p>You can find more detailed information in <a href="#sm-security-details">Understanding Security</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For a complete example, see the <a href="#statemachine-examples-security">Security</a> sample.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="configuring-security"><a class="anchor" href="#configuring-security"></a>Configuring Security</h3>
<div class="paragraph">
<p>All generic configurations for security are done in
<code>SecurityConfigurer</code>, which is obtained from
<code>StateMachineConfigurationConfigurer</code>. By default, security is disabled,
even if Spring Security classes are
present. The following example shows how to enable security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config4 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withSecurity()
				.enabled(true)
				.transitionAccessDecisionManager(null)
				.eventAccessDecisionManager(null);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you absolutely need to, you can customize <code>AccessDecisionManager</code> for both events and
transitions. If you do not define decision managers or
set them to <code>null</code>, default managers are created internally.</p>
</div>
</div>
<div class="sect2">
<h3 id="securing-events"><a class="anchor" href="#securing-events"></a>Securing Events</h3>
<div class="paragraph">
<p>Event security is defined on a global level by a <code>SecurityConfigurer</code>.
The following example shows how to enable event security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config1 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withSecurity()
				.enabled(true)
				.event("true")
				.event("ROLE_ANONYMOUS", ComparisonType.ANY);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration example, we use an expression of <code>true</code>, which always evaluates
to <code>TRUE</code>. Using an expression that always evaluates to <code>TRUE</code>
would not make sense in a real application but shows the point that
expression needs to return either <code>TRUE</code> or <code>FALSE</code>. We also defined an
attribute of <code>ROLE_ANONYMOUS</code> and a <code>ComparisonType</code> of <code>ANY</code>. For more about using attributes
and expressions, see <a href="#sm-security-attributes-expressions">Using Security Attributes and Expressions</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="securing-transitions"><a class="anchor" href="#securing-transitions"></a>Securing Transitions</h3>
<div class="paragraph">
<p>You can define transition security globally, as the following example shows.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config6 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withSecurity()
				.enabled(true)
				.transition("true")
				.transition("ROLE_ANONYMOUS", ComparisonType.ANY);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If security is defined in a transition itself, it override any
globally set security. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config2 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("S0")
				.target("S1")
				.event("A")
				.secured("ROLE_ANONYMOUS", ComparisonType.ANY)
				.secured("hasTarget('S1')");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more about using attributes and expressions, see <a href="#sm-security-attributes-expressions">Using Security Attributes and Expressions</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="securing-actions"><a class="anchor" href="#securing-actions"></a>Securing Actions</h3>
<div class="paragraph">
<p>There are no dedicated security definitions for actions in a state
machine, but you can secure actions by using a global method security
from Spring Security. This requires that an <code>Action</code> be
defined as a proxied <code>@Bean</code> and its <code>execute</code> method be annotated with
<code>@Secured</code>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class Config3 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withSecurity()
				.enabled(true);
	}

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("S0")
				.state("S1");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("S0")
				.target("S1")
				.action(securedAction())
				.event("A");
	}

	@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)
	@Bean
	public Action&lt;String, String&gt; securedAction() {
		return new Action&lt;String, String&gt;() {

			@Secured("ROLE_ANONYMOUS")
			@Override
			public void execute(StateContext&lt;String, String&gt; context) {
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Global method security needs to be enabled with Spring Security.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)
public static class Config5 extends WebSecurityConfigurerAdapter {

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()
				.withUser("user").password("password").roles("USER");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the Spring Security reference guide (available
<a href="https://spring.io/projects/spring-security#learn">here</a>) for more detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-security-attributes-expressions"><a class="anchor" href="#sm-security-attributes-expressions"></a>Using Security Attributes and Expressions</h3>
<div class="paragraph">
<p>Generally, you can define security properties in either of two ways: by
using security attributes and by using security expressions.
Attributes are easier to use but are relatively limited in terms of
functionality. Expressions provide more features but are a little bit
harder to use.</p>
</div>
<div class="sect3">
<h4 id="generic-attribute-usage"><a class="anchor" href="#generic-attribute-usage"></a>Generic Attribute Usage</h4>
<div class="paragraph">
<p>By default, <code>AccessDecisionManager</code> instances for events and
transitions both use a <code>RoleVoter</code>, meaning you can use role attributes
from Spring Security.</p>
</div>
<div class="paragraph">
<p>For attributes, we have three different comparison types: <code>ANY</code>, <code>ALL</code>, and
<code>MAJORITY</code>. These comparison types map onto default access decision managers
(<code>AffirmativeBased</code>, <code>UnanimousBased</code>, and <code>ConsensusBased</code>, respectively).
If you have defined a custom <code>AccessDecisionManager</code>, the comparison type is
effectively discarded, as it is used only to create a default manager.</p>
</div>
</div>
<div class="sect3">
<h4 id="generic-expression-usage"><a class="anchor" href="#generic-expression-usage"></a>Generic Expression Usage</h4>
<div class="paragraph">
<p>Security expressions must return either <code>TRUE</code> or <code>FALSE</code>.</p>
</div>
<div class="paragraph">
<p>The base class for the expression root objects is
<code>SecurityExpressionRoot</code>. It provides some common expressions, which
are available in both transition and event security. The following table
describes the most often used built-in expressions:</p>
</div>
<table id="common-expressions" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Common built-in expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasRole([role])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified role. By
default, if the supplied role does not start with <code>ROLE_</code>, it is
added. You can customize this by modifying the <code>defaultRolePrefix</code> on
<code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyRole([role1,role2])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied
roles (given as a comma-separated list of strings). By default, if each
supplied role does not start with <code>ROLE_</code>, it is added. You can customize this
by modifying the <code>defaultRolePrefix</code> on
<code>DefaultWebSecurityExpressionHandler</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAuthority([authority])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has the specified authority.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyAuthority([authority1,authority2])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal has any of the supplied
roles (given as a comma-separated list of strings).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the principal object that represents the
current user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows direct access to the current <code>Authentication</code> object obtained
from the <code>SecurityContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>permitAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>denyAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always evaluates to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAnonymous()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is an anonymous user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isRememberMe()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the current principal is a remember-me user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not anonymous.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isFullyAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user is not an anonymous or a remember-me user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object target, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the
given permission&#8201;&#8212;&#8201;for example, <code>hasPermission(domainObject, 'read')</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object targetId, String targetType, Object
permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the user has access to the provided target for the
given permission&#8201;&#8212;&#8201;for example, <code>hasPermission(1,
'com.example.domain.Message', 'read')</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="event-attributes"><a class="anchor" href="#event-attributes"></a>Event Attributes</h4>
<div class="paragraph">
<p>You can match an event ID by using a prefix of <code>EVENT_</code>. For example, matching
event <code>A</code> would match an attribute of <code>EVENT_A</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="event-expressions"><a class="anchor" href="#event-expressions"></a>Event Expressions</h4>
<div class="paragraph">
<p>The base class for the expression root object for events is
<code>EventSecurityExpressionRoot</code>. It provides access to a <code>Message</code>
object, which is passed around with eventing. <code>EventSecurityExpressionRoot</code>
has only one method, which the following table describes:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Event expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasEvent(Object event)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the event matches given event.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="transition-attributes"><a class="anchor" href="#transition-attributes"></a>Transition Attributes</h4>
<div class="paragraph">
<p>When matching transition sources and targets, you can use the
<code>TRANSITION_SOURCE_</code> and  <code>TRANSITION_TARGET_</code> prefixes respectively.</p>
</div>
</div>
<div class="sect3">
<h4 id="transition-expressions"><a class="anchor" href="#transition-expressions"></a>Transition Expressions</h4>
<div class="paragraph">
<p>The base class for the expression root object for transitions is
<code>TransitionSecurityExpressionRoot</code>. It provides access to a
<code>Transition</code>
object, which is passed around for transition changes.
<code>TransitionSecurityExpressionRoot</code> has two methods, which the following
table describes:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Transition expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasSource(Object source)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the transition source matches given source.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasTarget(Object target)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>true</code> if the transition target matches given target.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sm-security-details"><a class="anchor" href="#sm-security-details"></a>Understanding Security</h3>
<div class="paragraph">
<p>This section provides more detailed information about how security works within a
state machine. You may not really need to know, but it is
always better to be transparent instead of hiding all the magic what
happens behind the scenes.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Security makes sense only if Spring Statemachine runs in a walled
garden where user have no direct access to the application and could consequently
modify Spring Security&#8217;s <code>SecurityContext</code> hold in a local thread.
If the user controls the JVM, then effectively there is no security
at all.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The integration point for security is created with a
<a href="#sm-interceptor"><code>StateMachineInterceptor</code></a>, which is then automatically added into a
state machine if security is enabled. The specific class is
<code>StateMachineSecurityInterceptor</code>, which intercepts events and
transitions. This interceptor then consults Spring Security&#8217;s
<code>AccessDecisionManager</code> to determine whether an event can be sent or whether a transition can be
executed. Effectively, if a decision or a vote with a <code>AccessDecisionManager</code>
results in an exception, the event or transition is denied.</p>
</div>
<div class="paragraph">
<p>Due to how <code>AccessDecisionManager</code> from Spring Security works, we
need one instance of it per secured object. This is one reason why there
are different managers for events and transitions. In this case, events
and transitions are different class objects that we secure.</p>
</div>
<div class="paragraph">
<p>By default, for events, voters (<code>EventExpressionVoter</code>, <code>EventVoter</code>, and
<code>RoleVoter</code>) are added into an <code>AccessDecisionManager</code>.</p>
</div>
<div class="paragraph">
<p>By default, for transitions, voters (<code>TransitionExpressionVoter</code>,
<code>TransitionVoter</code>, and <code>RoleVoter</code>) are added into an <code>AccessDecisionManager</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-error-handling"><a class="anchor" href="#sm-error-handling"></a>State Machine Error Handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If a state machine detects an internal error during a state transition
logic, it may throw an exception. Before this exception is processed
internally, you are given a chance to intercept.</p>
</div>
<div class="paragraph">
<p>Normally, you can use <code>StateMachineInterceptor</code> to intercept errors and the
following listing shows an example of it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">StateMachine&lt;String, String&gt; stateMachine;

void addInterceptor() {
	stateMachine.getStateMachineAccessor()
		.doWithRegion(new StateMachineFunction&lt;StateMachineAccess&lt;String, String&gt;&gt;() {

		@Override
		public void apply(StateMachineAccess&lt;String, String&gt; function) {
			function.addStateMachineInterceptor(
					new StateMachineInterceptorAdapter&lt;String, String&gt;() {
				@Override
				public Exception stateMachineError(StateMachine&lt;String, String&gt; stateMachine,
						Exception exception) {
					// return null indicating handled error
					return exception;
				}
			});
		}
	});

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When errors are detected, the normal event notify mechanism is executed.
This lets you use either a <code>StateMachineListener</code> or a Spring Application
context event listener. For more about these, see
<a href="#sm-listeners">Listening to State Machine Events</a>.</p>
</div>
<div class="paragraph">
<p>Having said that, the following example shows a simple listener:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ErrorStateMachineListener
		extends StateMachineListenerAdapter&lt;String, String&gt; {

	@Override
	public void stateMachineError(StateMachine&lt;String, String&gt; stateMachine, Exception exception) {
		// do something with error
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a generic <code>ApplicationListener</code> checking <code>StateMachineEvent</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class GenericApplicationEventListener
		implements ApplicationListener&lt;StateMachineEvent&gt; {

	@Override
	public void onApplicationEvent(StateMachineEvent event) {
		if (event instanceof OnStateMachineError) {
			// do something with error
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also directly define <code>ApplicationListener</code> to
recognize only <code>StateMachineEvent</code> instances, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ErrorApplicationEventListener
		implements ApplicationListener&lt;OnStateMachineError&gt; {

	@Override
	public void onApplicationEvent(OnStateMachineError event) {
		// do something with error
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Actions defined for transitions also have their own error handling
logic. See <a href="#statemachine-config-transition-actions-errorhandling">Transition Action Error Handling</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-service"><a class="anchor" href="#sm-service"></a>State Machine Services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>StateMachine services are higher-level implementations meant to
provide more user-level functionalities to ease normal runtime
operations. Currently, only one service interface
(<code>StateMachineService</code>) exists.</p>
</div>
<div class="sect2">
<h3 id="sm-service-statemachineservice"><a class="anchor" href="#sm-service-statemachineservice"></a>Using <code>StateMachineService</code></h3>
<div class="paragraph">
<p><code>StateMachineService</code> is an interface that is meant to handle running machines
and have simple methods to &#8220;acquire&#8221; and &#8220;release&#8221; machines. It has
one default implementation, named <code>DefaultStateMachineService</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-persist"><a class="anchor" href="#sm-persist"></a>Persisting a State Machine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traditionally, an instance of a state machine is used as is within a
running program. You can achieve more dynamic behavior by using
dynamic builders and factories, which allows state machine
instantiation on-demand. Building an instance of a state machine is a
relatively heavy operation. Consequently, if you need to (for example) handle
an arbitrary state change in a database by using a state machine, you need to
find a better and faster way to do it.</p>
</div>
<div class="paragraph">
<p>The persist feature lets you save a state of a state machine
into an external repository and later reset a state machine based off the
serialized state. For example, if you have a database table keeping
orders, it would be way too expensive to update an order state with a state
machine if a new instance would need to be built for every change.
The persist feature lets you reset a state machine state without
instantiating a new state machine instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is one recipe (see <a href="#statemachine-recipes-persist">Persist</a>) and one sample
(see <a href="#statemachine-examples-persist">Persist</a>) that provide more info about
persisting states.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While you can build a custom persistence feature by using a
<code>StateMachineListener</code>, it has one conceptual problem. When a listener
notifies about a change of state, the state change has already happened. If a
custom persistent method within a listener fails to update the serialized
state in an external repository, the state in a state machine and the state in
an external repository are then in an inconsistent state.</p>
</div>
<div class="paragraph">
<p>You can isntead use a state machine interceptor to try to save the
serialized state into external storage during the state
change within a state machine. If this interceptor callback fails,
you can halt the state change attempt and, instead of ending in an
inconsistent state, you can then handle this error manually. See
<a href="#sm-interceptor">Using <code>StateMachineInterceptor</code></a> for how to use interceptors.</p>
</div>
<div class="sect2">
<h3 id="sm-persist-statemachinecontext"><a class="anchor" href="#sm-persist-statemachinecontext"></a>Using <code>StateMachineContext</code></h3>
<div class="paragraph">
<p>You cannot persist a <code>StateMachine</code> by using normal java
serialization, as the object graph is too rich and contains too many
dependencies on other Spring context classes. <code>StateMachineContext</code>
is a runtime representation of a state machine that you can use to
restore an existing machine into a state represented by a particular
<code>StateMachineContext</code> object.</p>
</div>
<div class="paragraph">
<p><code>StateMachineContext</code> contains two different ways to include information
for a child context. These are generally used when a machine contains
orthogonal regions. First, a context can have a list of child contexts
that can be used as is if they exist. Second, you can
include a list of references that are used if raw context children
are not in place. These child references are really the only way to
persist a machine where multiple parallel regions are running
independently.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <a href="#statemachine-examples-datajpamultipersist">Data Multi Persist</a> sample shows
how you can persist parallel regions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sm-persist-statemachinepersister"><a class="anchor" href="#sm-persist-statemachinepersister"></a>Using <code>StateMachinePersister</code></h3>
<div class="paragraph">
<p>Building a <code>StateMachineContext</code> and then restoring a state machine
from it has always been a little bit of &#8220;black magic&#8221; if done
manually. The <code>StateMachinePersister</code> interface aims to ease these
operations by providing <code>persist</code> and <code>restore</code> methods. The default
implementation of this interface is <code>DefaultStateMachinePersister</code>.</p>
</div>
<div class="paragraph">
<p>We can show how to use a <code>StateMachinePersister</code> by following
a snippets from tests. We start by creating two similar configurations
(<code>machine1</code> and <code>machine2</code>) for a state machine. Note that we could build different
machines for this demonstration in other ways but this way
works for this case. The following example configures the two state machines:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine(name = "machine1")
static class Config1 extends Config {
}

@Configuration
@EnableStateMachine(name = "machine2")
static class Config2 extends Config {
}

static class Config extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states) throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S1")
				.state("S2");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions) throws Exception {
		transitions
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As we are using a <code>StateMachinePersist</code> object, we can create an in-memory
implementation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This in-memory sample is only for demonstration purposes. For real
applications, you should use a real persistent storage implementation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following listing shows how to use the in-memory sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static class InMemoryStateMachinePersist implements StateMachinePersist&lt;String, String, String&gt; {

	private final HashMap&lt;String, StateMachineContext&lt;String, String&gt;&gt; contexts = new HashMap&lt;&gt;();

	@Override
	public void write(StateMachineContext&lt;String, String&gt; context, String contextObj) throws Exception {
		contexts.put(contextObj, context);
	}

	@Override
	public StateMachineContext&lt;String, String&gt; read(String contextObj) throws Exception {
		return contexts.get(contextObj);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After we have instantiated the two different machines, we can transfer
<code>machine1</code> into state <code>S2</code> through event <code>E1</code>. Then we can persist it and restore
<code>machine2</code>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">InMemoryStateMachinePersist stateMachinePersist = new InMemoryStateMachinePersist();
StateMachinePersister&lt;String, String, String&gt; persister = new DefaultStateMachinePersister&lt;&gt;(stateMachinePersist);

StateMachine&lt;String, String&gt; stateMachine1 = context.getBean("machine1", StateMachine.class);
StateMachine&lt;String, String&gt; stateMachine2 = context.getBean("machine2", StateMachine.class);
stateMachine1.start();

stateMachine1.sendEvent("E1");
assertThat(stateMachine1.getState().getIds(), contains("S2"));

persister.persist(stateMachine1, "myid");
persister.restore(stateMachine2, "myid");
assertThat(stateMachine2.getState().getIds(), contains("S2"));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sm-persist-redis"><a class="anchor" href="#sm-persist-redis"></a>Using Redis</h3>
<div class="paragraph">
<p><code>RepositoryStateMachinePersist</code> (which implements
<code>StateMachinePersist</code>) offers support for persisting a state machine into Redis.
 The specific implementation is a
<code>RedisStateMachineContextRepository</code>, which uses <code>kryo</code> serialization to
persist a <code>StateMachineContext</code> into <code>Redis</code>.</p>
</div>
<div class="paragraph">
<p>For <code>StateMachinePersister</code>, we have a Redis-related
<code>RedisStateMachinePersister</code> implementation, which takes an instance of
a <code>StateMachinePersist</code> and uses <code>String</code> as its context object.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the <a href="#statemachine-examples-eventservice">Event Service</a> sample for detailed usage.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>RedisStateMachineContextRepository</code> needs a
<code>RedisConnectionFactory</code> for it to work. We recommend using a
<code>JedisConnectionFactory</code> for it, as the preceding example shows.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-persist-statemachineruntimepersister"><a class="anchor" href="#sm-persist-statemachineruntimepersister"></a>Using <code>StateMachineRuntimePersister</code></h3>
<div class="paragraph">
<p><code>StateMachineRuntimePersister</code> is a simple extension to
<code>StateMachinePersist</code> that adds an interface-level method to get
<code>StateMachineInterceptor</code> associated with it. This interceptor is then
required to persist a machine during state changes without needing to
stop and start a machine.</p>
</div>
<div class="paragraph">
<p>Currently, there are implementations for this interface for the
supported Spring Data Repositories. These implementations are
<code>JpaPersistingStateMachineInterceptor</code>, <code>MongoDbPersistingStateMachineInterceptor</code>,
and <code>RedisPersistingStateMachineInterceptor</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the <a href="#statemachine-examples-datapersist">Data Persist</a> sample for detailed usage.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-boot"><a class="anchor" href="#sm-boot"></a>Spring Boot Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The auto-configuration module (<code>spring-statemachine-autoconfigure</code>) contains all
the logic for integrating with Spring Boot, which provides functionality for
auto-configuration and actuators. All you need is to have this Spring Statemachine
library as part of a boot application.</p>
</div>
<div class="sect2">
<h3 id="sm-boot-monitoring"><a class="anchor" href="#sm-boot-monitoring"></a>Monitoring and Tracing</h3>
<div class="paragraph">
<p><code>BootStateMachineMonitor</code> is created automatically and associated with
a state machine. <code>BootStateMachineMonitor</code> is a custom <code>StateMachineMonitor</code>
implementation that integrates with Spring Boot&#8217;s <code>MeterRegistry</code> and endpoints
through a custom <code>StateMachineTraceRepository</code>. Optionally, you can disable this auto-configuration
by setting the <code>spring.statemachine.monitor.enabled</code> key to
<code>false</code>. The
<a href="#statemachine-examples-monitoring">Monitoring</a> sample shows how to use this auto-configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="repository-config"><a class="anchor" href="#repository-config"></a>Repository Config</h3>
<div class="paragraph">
<p>If the required classes are found from the classpath, Spring Data Repositories
 and entity class scanning is automatically auto-configured
for <a href="#sm-repository">Repository Support</a>.</p>
</div>
<div class="paragraph">
<p>The currently supported configurations are <code>JPA</code>, <code>Redis</code>, and
<code>MongoDB</code>. You can disable repository auto-configuration by using the
<code>spring.statemachine.data.jpa.repositories.enabled</code>,
<code>spring.statemachine.data.redis.repositories.enabled</code> and
<code>spring.statemachine.data.mongo.repositories.enabled</code> properties, respectively.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-monitoring"><a class="anchor" href="#sm-monitoring"></a>Monitoring a State Machine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use <code>StateMachineMonitor</code> to get more information about the
durations of how long transitions and actions take to execute. The following listing
shows how this interface is implemented.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TestStateMachineMonitor extends AbstractStateMachineMonitor&lt;String, String&gt; {

	@Override
	public void transition(StateMachine&lt;String, String&gt; stateMachine, Transition&lt;String, String&gt; transition, long duration) {
	}

	@Override
	public void action(StateMachine&lt;String, String&gt; stateMachine, Action&lt;String, String&gt; action, long duration) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once you have a <code>StateMachineMonitor</code> implementation, you can add it to
a state machine through configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withMonitoring()
				.monitor(stateMachineMonitor());
	}

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states) throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions) throws Exception {
		transitions
			.withExternal()
				.source("S1")
				.target("S2")
				.event("E1");
	}

	@Bean
	public StateMachineMonitor&lt;String, String&gt; stateMachineMonitor() {
		return new TestStateMachineMonitor();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the <a href="#statemachine-examples-monitoring">Monitoring</a> sample for detailed usage.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-distributed"><a class="anchor" href="#sm-distributed"></a>Using Distributed States</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Distributed state is probably one of a most complicated concepts of a
Spring state machine. What exactly is a distributed state? A state
within a single state machine is naturally really simple to understand,
but, when there is a need to introduce a shared distributed state
through a state machine, things get a little complicated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Distributed state functionality is still a preview feature and is not
yet considered to be stable in this particular release. We expect this
feature to mature towards its first official release.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For information about generic configuration support, see
<a href="#statemachine-config-commonsettings">Configuring Common Settings</a>. For an actual usage example, see
the <a href="#statemachine-examples-zookeeper">Zookeeper</a> sample.</p>
</div>
<div class="paragraph">
<p>A distributed state machine is implemented through a
<code>DistributedStateMachine</code> class that wraps an actual instance
of a <code>StateMachine</code>. <code>DistributedStateMachine</code> intercepts
communication with a <code>StateMachine</code> instance and works with
distributed state abstractions handled through the
<code>StateMachineEnsemble</code> interface. Depending on the actual implementation,
you can also use the <code>StateMachinePersist</code> interface to serialize a
<code>StateMachineContext</code>, which contains enough information to reset a
<code>StateMachine</code>.</p>
</div>
<div class="paragraph">
<p>While a distributed state machine is implemented through an abstraction,
only one implementation currently exists. It is based on Zookeeper.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a Zookeeper-based distributed state
machine`:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config
		extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withDistributed()
				.ensemble(stateMachineEnsemble())
				.and()
			.withConfiguration()
				.autoStartup(true);
	}

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		// config states
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		// config transitions
	}

	@Bean
	public StateMachineEnsemble&lt;String, String&gt; stateMachineEnsemble()
			throws Exception {
		return new ZookeeperStateMachineEnsemble&lt;String, String&gt;(curatorClient(), "/zkpath");
	}

	@Bean
	public CuratorFramework curatorClient()
			throws Exception {
		CuratorFramework client = CuratorFrameworkFactory
				.builder()
				.defaultData(new byte[0])
				.connectString("localhost:2181").build();
		client.start();
		return client;
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find the current technical documentation for a Zookeeker-based distributed
state machine <a href="#appendices-zookeeper">in the appendix</a>.</p>
</div>
<div class="sect2">
<h3 id="using-code-zookeeperstatemachineensemble-code"><a class="anchor" href="#using-code-zookeeperstatemachineensemble-code"></a>Using <code>ZookeeperStateMachineEnsemble</code></h3>
<div class="paragraph">
<p><code>ZookeeperStateMachineEnsemble</code> itself needs two mandatory settings,
an instance of <code>curatorClient</code> and a <code>basePath</code>. The client is a
<code>CuratorFramework</code>, and the path is the root of a tree in a <code>Zookeeper</code> instance.</p>
</div>
<div class="paragraph">
<p>Optionally, you can set <code>cleanState</code>, which defaults to <code>TRUE</code>
and clears existing data if no members exists in an ensemble. You can set
it to <code>FALSE</code> if you want to preserve distributed state within
application restarts.</p>
</div>
<div class="paragraph">
<p>Optionally, you can set the size of a <code>logSize</code> (defaults
to <code>32</code>) to a keep history of state changes. The value of this
setting must be a power of two. <code>32</code> is generally a good default
value. If a particular state machine is left behind by more than the
size of the log, it is put into an error state and disconnected from the
ensemble, indicating it has lost its history and its ability to fully reconstruct the
synchronized status.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-test"><a class="anchor" href="#sm-test"></a>Testing Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have also added a set of utility classes to ease testing of state
machine instances. These are used in the framework itself but are also
very useful for end users.</p>
</div>
<div class="paragraph">
<p><code>StateMachineTestPlanBuilder</code> builds a <code>StateMachineTestPlan</code>,
which has one method (called <code>test()</code>). That method runs a plan.
<code>StateMachineTestPlanBuilder</code> contains a fluent builder API to let you add
steps to a plan. During these steps, you can send events and check
various conditions, such as state changes, transitions, and extended state
variables.</p>
</div>
<div class="paragraph">
<p>The following example uses <code>StateMachineBuilder</code> to build a state machine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private StateMachine&lt;String, String&gt; buildMachine() throws Exception {
	StateMachineBuilder.Builder&lt;String, String&gt; builder = StateMachineBuilder.builder();

	builder.configureConfiguration()
		.withConfiguration()
			.taskExecutor(new SyncTaskExecutor())
			.autoStartup(true);

	builder.configureStates()
			.withStates()
				.initial("SI")
				.state("S1");

	builder.configureTransitions()
			.withExternal()
				.source("SI").target("S1")
				.event("E1")
				.action(c -&gt; {
					c.getExtendedState().getVariables().put("key1", "value1");
				});

	return builder.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following test plan, we have two steps. First, we check that the initial
state (<code>SI</code>) is indeed set. Second, we send an event (<code>E1</code>) and expect
one state change to happen and expect the machine to end up in a state of <code>S1</code>.
The following listing shows the test plan:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">StateMachine&lt;String, String&gt; machine = buildMachine();
StateMachineTestPlan&lt;String, String&gt; plan =
		StateMachineTestPlanBuilder.&lt;String, String&gt;builder()
			.defaultAwaitTime(2)
			.stateMachine(machine)
			.step()
				.expectStates("SI")
				.and()
			.step()
				.sendEvent("E1")
				.expectStateChanged(1)
				.expectStates("S1")
				.expectVariable("key1")
				.expectVariable("key1", "value1")
				.expectVariableWith(hasKey("key1"))
				.expectVariableWith(hasValue("value1"))
				.expectVariableWith(hasEntry("key1", "value1"))
				.expectVariableWith(not(hasKey("key2")))
				.and()
			.build();
plan.test();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These utilities are also used within a framework to test distributed
state machine features. Note that you can add multiple machines to a plan.
If you add multiple machines, yuo can also choose to
send an event a particular machine, a random machine, or all machines.</p>
</div>
<div class="paragraph">
<p>The preceding testing example uses the following Hamcrest imports:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.collection.IsMapContaining.hasKey;
import static org.hamcrest.collection.IsMapContaining.hasValue;
import static org.hamcrest.collection.IsMapContaining.hasEntry;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
All possible options for expected results are documented in the Javadoc for
<a href="https://docs.spring.io/spring-statemachine/docs/{spring-statemachine-version}/api/org/springframework/statemachine/test/StateMachineTestPlanBuilder.StateMachineTestPlanStepBuilder.html"><code>StateMachineTestPlanStepBuilder</code></a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-papyrus"><a class="anchor" href="#sm-papyrus"></a>Eclipse Modeling Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Defining a state machine configuration with UI modeling is supported
through the Eclipse Papyrus framework.</p>
</div>
<div class="paragraph">
<p>From the Eclipse wizard, you can create a new Papyrus Model with the UML Diagram
Language. In this example, it is named <code>simple-machine</code>. Then you
have an option to choose from various diagram kinds, and you must choose a <code>StateMachine
Diagram</code>.</p>
</div>
<div class="paragraph">
<p>We want to create a machine that has two states (<code>S1</code> and <code>S2</code>), where
<code>S1</code> is the initial state. Then, we need to create event <code>E1</code> to do a transition
from <code>S1</code> to <code>S2</code>. In Papyrus, a machine would then look like something
the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="imageblock">
<div class="content">
<img src="images/simple-machine.png" alt="simple machine" width="500">
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Behind the scenes, a raw UML file would look like the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;uml:Model xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML" xmi:id="_AMP3IP8fEeW45bORGB4c_A" name="RootElement"&gt;
  &lt;packagedElement xmi:type="uml:StateMachine" xmi:id="_AMRFQP8fEeW45bORGB4c_A" name="StateMachine"&gt;
    &lt;region xmi:type="uml:Region" xmi:id="_AMRsUP8fEeW45bORGB4c_A" name="Region1"&gt;
      &lt;transition xmi:type="uml:Transition" xmi:id="_chgcgP8fEeW45bORGB4c_A" source="_EZrg4P8fEeW45bORGB4c_A" target="_FAvg4P8fEeW45bORGB4c_A"&gt;
        &lt;trigger xmi:type="uml:Trigger" xmi:id="_hs5jUP8fEeW45bORGB4c_A" event="_NeH84P8fEeW45bORGB4c_A"/&gt;
      &lt;/transition&gt;
      &lt;transition xmi:type="uml:Transition" xmi:id="_egLIoP8fEeW45bORGB4c_A" source="_Fg0IEP8fEeW45bORGB4c_A" target="_EZrg4P8fEeW45bORGB4c_A"/&gt;
      &lt;subvertex xmi:type="uml:State" xmi:id="_EZrg4P8fEeW45bORGB4c_A" name="S1"/&gt;
      &lt;subvertex xmi:type="uml:State" xmi:id="_FAvg4P8fEeW45bORGB4c_A" name="S2"/&gt;
      &lt;subvertex xmi:type="uml:Pseudostate" xmi:id="_Fg0IEP8fEeW45bORGB4c_A"/&gt;
    &lt;/region&gt;
  &lt;/packagedElement&gt;
  &lt;packagedElement xmi:type="uml:Signal" xmi:id="_L01D0P8fEeW45bORGB4c_A" name="E1"/&gt;
  &lt;packagedElement xmi:type="uml:SignalEvent" xmi:id="_NeH84P8fEeW45bORGB4c_A" name="SignalEventE1" signal="_L01D0P8fEeW45bORGB4c_A"/&gt;
&lt;/uml:Model&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When opening an existing model that has been defined as UML, you have three
files: <code>.di</code>, <code>.notation</code>, and <code>.uml</code>. If a model was not created in your
eclipse&#8217;s session, it does not understand how to open an actual state
chart. This is a known issue in the Papyrus plugin, and there is an easy
workaround. In a Papyrus perspective, you can see a model explorer for
your model. Double click Diagram StateMachine Diagram, which
instructs Eclipse to open this specific model in its proper Papyrus
modeling plugin.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="using-code-umlstatemachinemodelfactory-code"><a class="anchor" href="#using-code-umlstatemachinemodelfactory-code"></a>Using <code>UmlStateMachineModelFactory</code></h3>
<div class="paragraph">
<p>After a UML file is in place in your project, you can import it into your
configuration by using <code>StateMachineModelConfigurer</code>, where
<code>StateMachineModelFactory</code> is associated with a model.
<code>UmlStateMachineModelFactory</code> is a special factory that knows how to
process a Eclipse Papyrus_generated UML structure. The source UML file can
either be given as a Spring <code>Resource</code> or as a normal location string.
The following example shows how to create an instance of
<code>UmlStateMachineModelFactory</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public static class Config1 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineModelConfigurer&lt;String, String&gt; model) throws Exception {
		model
			.withModel()
				.factory(modelFactory());
	}

	@Bean
	public StateMachineModelFactory&lt;String, String&gt; modelFactory() {
		return new UmlStateMachineModelFactory("classpath:org/springframework/statemachine/uml/docs/simple-machine.uml");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As usual, Spring Statemachine works with guards and
actions, which are defined as beans. Those need to be hooked into UML
by its internal modeling structure. The following sections show
how customized bean references are defined within UML definitions.
Note that it is also possible to register particular methods manually
without defining those as beans.</p>
</div>
<div class="paragraph">
<p>If <code>UmlStateMachineModelFactory</code> is created as a bean, its
<code>ResourceLoader</code> is automatically wired to find registered actions and
guards. You can also manually define a
<code>StateMachineComponentResolver</code>, which is then used to find these
components. The factory also has <em>registerAction</em> and
<em>registerGuard</em> methods, which you can use to register these components. For more
about this, see <a href="#sm-papyrus-statemachinecomponentresolver">Using <code>StateMachineComponentResolver</code></a>.</p>
</div>
<div class="paragraph">
<p>A UML model is relatively loose when it comes to an implementation such as
Spring Statemachine itself. Spring Statemachine leaves how to implement a lot of features and
functionalities up to the actual implementation. The following sections go
through how Spring Statemachine implements UML models based on
the Eclipse Papyrus plugin.</p>
</div>
<div class="sect3">
<h4 id="sm-papyrus-statemachinecomponentresolver"><a class="anchor" href="#sm-papyrus-statemachinecomponentresolver"></a>Using <code>StateMachineComponentResolver</code></h4>
<div class="paragraph">
<p>The next example shows how <code>UmlStateMachineModelFactory</code> is defined with
a <code>StateMachineComponentResolver</code>, which registers the
<code>myAction</code> and <code>myGuard</code> functions, respectively. Note that these components
are not created as beans. The following listing shows the example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public static class Config2 extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineModelConfigurer&lt;String, String&gt; model) throws Exception {
		model
			.withModel()
				.factory(modelFactory());
	}

	@Bean
	public StateMachineModelFactory&lt;String, String&gt; modelFactory() {
		UmlStateMachineModelFactory factory = new UmlStateMachineModelFactory(
				"classpath:org/springframework/statemachine/uml/docs/simple-machine.uml");
		factory.setStateMachineComponentResolver(stateMachineComponentResolver());
		return factory;
	}

	@Bean
	public StateMachineComponentResolver&lt;String, String&gt; stateMachineComponentResolver() {
		DefaultStateMachineComponentResolver&lt;String, String&gt; resolver = new DefaultStateMachineComponentResolver&lt;&gt;();
		resolver.registerAction("myAction", myAction());
		resolver.registerGuard("myGuard", myGuard());
		return resolver;
	}

	public Action&lt;String, String&gt; myAction() {
		return new Action&lt;String, String&gt;() {

			@Override
			public void execute(StateContext&lt;String, String&gt; context) {
			}
		};
	}

	public Guard&lt;String, String&gt; myGuard() {
		return new Guard&lt;String, String&gt;() {

			@Override
			public boolean evaluate(StateContext&lt;String, String&gt; context) {
				return false;
			}
		};
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-model"><a class="anchor" href="#creating-a-model"></a>Creating a Model</h3>
<div class="paragraph">
<p>We start by creating an empty state machine model, shown in the following image:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-1.png" alt="papyrus gs 1" width="300">
</div>
</div>
<div class="paragraph">
<p>You can start by creating a new model and giving it a name, as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-2.png" alt="papyrus gs 2" width="300">
</div>
</div>
<div class="paragraph">
<p>Then you need to choose StateMachine Diagram, as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-3.png" alt="papyrus gs 3">
</div>
</div>
<div class="paragraph">
<p>You end up with an empty state machine.</p>
</div>
<div class="paragraph">
<p>In the preceding images, you should have created a sample named <code>model</code>.
You should have wound up with three files: <code>model.di</code>,
<code>model.notation</code>, and <code>model.uml</code>. You can then used these files in any other
Eclipse instance. Further, you can import <code>model.uml</code> into a
Spring Statemachine.</p>
</div>
</div>
<div class="sect2">
<h3 id="defining-states"><a class="anchor" href="#defining-states"></a>Defining States</h3>
<div class="paragraph">
<p>The state identifier comes from a component name in a diagram.
You must have an initial state in your machine, which you can do by adding
a root element and then drawing a transition to your own initial state,
as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-4.png" alt="papyrus gs 4">
</div>
</div>
<div class="paragraph">
<p>In the preceding image, we added a root element and an initial state (<code>S1</code>). Then we drew a transition
between those two to indicate that <code>S1</code> is an initial state.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-5.png" alt="papyrus gs 5">
</div>
</div>
<div class="paragraph">
<p>In the preceding image, we added a second state (<code>S2</code>) and added a transition between
S1 and S2 (indicating that we have two states).</p>
</div>
</div>
<div class="sect2">
<h3 id="defining-events"><a class="anchor" href="#defining-events"></a>Defining Events</h3>
<div class="paragraph">
<p>To associate an event with a transition, you need to create a Signal
(<code>E1</code>, in this case). To do so, choose RootElement &#8594; New Child &#8594; Signal.
The following image shows the result:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-6.png" alt="papyrus gs 6">
</div>
</div>
<div class="paragraph">
<p>Then you need to crate a SignalEvent with the new Signal, <code>E1</code>.
To do so, choose RootElement &#8594; New Child &#8594; SignalEvent.
The following image shows the result:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-7.png" alt="papyrus gs 7">
</div>
</div>
<div class="paragraph">
<p>Now that you have defined a <code>SignalEvent</code>, you can use it to associate
a trigger with a transition. For more about that, see
<a href="#sm-papyrus-transitions">Defining Transitions</a>.</p>
</div>
<div class="sect3">
<h4 id="deferring-an-event"><a class="anchor" href="#deferring-an-event"></a>Deferring an Event</h4>
<div class="paragraph">
<p>You can defer events to process them at a more appropriate time. In
UML, this is done from a state itself. Choose any state, create a
new trigger under <strong>Deferrable trigger</strong> and choose the SignalEvent which
matches the Signal you want to defer.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sm-papyrus-transitions"><a class="anchor" href="#sm-papyrus-transitions"></a>Defining Transitions</h3>
<div class="paragraph">
<p>You can create a transition by drawing a transition line between the
source and target states. In the preceding images, we have states <code>S1</code> and <code>S2</code> and an
anonymous transition between the two. We want to associate event
<code>E1</code> with that transition. We choose a transition, create a new
trigger, and define SignalEventE1 for that, as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-8.png" alt="papyrus gs 8">
</div>
</div>
<div class="paragraph">
<p>This gives you something like the arrangement shown in the following image:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-9.png" alt="papyrus gs 9">
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you omit SignalEvent for a transition, it becomes an
anonymous transition.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="defining-timers"><a class="anchor" href="#defining-timers"></a>Defining Timers</h3>
<div class="paragraph">
<p>Transitions can also happen based on timed events. Spring Statemachine
support two types of timers, ones which fires continuously on a
background and ones which fires once with a delay when state is
entered.</p>
</div>
<div class="paragraph">
<p>To add a new TimeEvent child to Model Explorer, modify When as an
expression defined as LiteralInteger. The value of it (in milliseconds) becomes the timer.
Leave Is Relative false to make the timer fire continuously.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-10.png" alt="papyrus gs 10">
</div>
</div>
<div class="paragraph">
<p>To define one timed based event that triggers when a state is entered, the process is exactly
same as described earlier, but leave Is Relative set to true. The following image
shows the result:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-11.png" alt="papyrus gs 11">
</div>
</div>
<div class="paragraph">
<p>Then the user can pick one of these timed events instead of a
signal event for a particular transition.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-papyrus-choice"><a class="anchor" href="#sm-papyrus-choice"></a>Defining a Choice</h3>
<div class="paragraph">
<p>A choice is defined by drawing one incoming transition into a
CHOICE state and drawing multiple outgoing transitions from it to target
states. The configuration model in our <code>StateConfigurer</code> lets you define
an if/elseif/else structure. However, with UML, we need to work with
individual Guards for outgoing transitions.</p>
</div>
<div class="paragraph">
<p>You must ensure that the guards defined for transitions do not overlap so that,
whatever happens, only one guard evaluates to TRUE at any given
time. This gives precise and predictable results for choice branch
evaluation. Also we recommend leaving one transition without a guard
so that at least one transition path is guaranteed.
The following image shows the result of making a choice with three branches:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-16.png" alt="papyrus gs 16">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Junction works similarly same, except that it allows multiple incoming
transitions. Thus, its behavior compared to Choice is purely
academic. The actual logic to select the outgoing transition is exactly the same.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="defining-a-junction"><a class="anchor" href="#defining-a-junction"></a>Defining a Junction</h3>
<div class="paragraph">
<p>See <a href="#sm-papyrus-choice">Defining a Choice</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="defining-entry-and-exit-points"><a class="anchor" href="#defining-entry-and-exit-points"></a>Defining Entry and Exit Points</h3>
<div class="paragraph">
<p>You can use EntryPoint and ExitPoint to create controlled entry and exit
with states that have sub-states. In the following state chart, events <code>E1</code> and
<code>E2</code> have normal state behavior by entering and exiting state
<code>S2</code>, where normal state behavior happens by entering initial state
<code>S21</code>.</p>
</div>
<div class="paragraph">
<p>Using event <code>E3</code> takes the machine into the <code>ENTRY</code> EntryPoint, which then
leads to <code>S22</code> without activating initial state <code>S21</code> at any time.
Similarly the <code>EXIT</code> ExitPoint with event <code>E4</code> controls the specific exit
into state <code>S4</code>, while normal exit behavior from <code>S2</code> would take the
machine into state <code>S3</code>. While on state <code>S22</code>, you can choose from
events <code>E4</code> and <code>E2</code> to take the machine into states <code>S3</code> or <code>S4</code>,
respectively. The following image shows the result:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-17.png" alt="papyrus gs 17">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If state is defined as a sub-machine reference and you need to use entry and exit points,
you must externally define a ConnectionPointReference, with
its entry and exit reference set to point to a correct entry or exit point
within a submachine reference. Only after that, is it possible to
target a transition that correctly links from the outside to the inside of
a sub-machine reference. With ConnectionPointReference, you may need
to find these settings from Properties &#8594; Advanced &#8594; UML &#8594;
Entry/Exit. The UML specification lets you define multiple entries and exits. However,
with a state machine, only one is allowed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="defining-history-states"><a class="anchor" href="#defining-history-states"></a>Defining History States</h3>
<div class="paragraph">
<p>When working with history states, three different concepts are in play.
UML defines a Deep History and a Shallow History. The Default History
State comes into play when history state is not yet known. These are
represented in following sections.</p>
</div>
<div class="sect3">
<h4 id="shallow-history"><a class="anchor" href="#shallow-history"></a>Shallow History</h4>
<div class="paragraph">
<p>In the following image, Shallow History is selected and a transition is defined into it:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-18.png" alt="papyrus gs 18">
</div>
</div>
</div>
<div class="sect3">
<h4 id="deep-history"><a class="anchor" href="#deep-history"></a>Deep History</h4>
<div class="paragraph">
<p>Deep History is used for state that has other deep nested states,
thus giving a chance to save whole nested state structure.
The following image shows a definition that uses Deep History:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-19.png" alt="papyrus gs 19">
</div>
</div>
</div>
<div class="sect3">
<h4 id="default-history"><a class="anchor" href="#default-history"></a>Default History</h4>
<div class="paragraph">
<p>In cases where a Transition terminates on a history when
the state has not been entered before it had reached its
final state, there is an option to force
a transition to a specific substate, using the default
history mechanism. For this to happen, you must define a transition
into this default state. This is the transition from <code>SH</code> to
<code>S22</code>.</p>
</div>
<div class="paragraph">
<p>In the following image, state <code>S22</code> is entered if state <code>S2</code> has
never been active, as its history has never been recorded. If state
<code>S2</code> has been active, then either <code>S20</code> or <code>S21</code> gets chosen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-20.png" alt="papyrus gs 20">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defining-forks-and-joins"><a class="anchor" href="#defining-forks-and-joins"></a>Defining Forks and Joins</h3>
<div class="paragraph">
<p>Both Fork and Join are represented as bars in Papyrus. As shown
in the next image, you need to draw one outgoing transition from <code>FORK</code> into state
<code>S2</code> to have orthogonal regions. <code>JOIN</code> is then the reverse, where
joined states are collected together from incoming transitions.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-21.png" alt="papyrus gs 21">
</div>
</div>
</div>
<div class="sect2">
<h3 id="defining-actions"><a class="anchor" href="#defining-actions"></a>Defining Actions</h3>
<div class="paragraph">
<p>You can assoiate swtate entry and exit actions by using a behavior.
For more about this, see <a href="#sm-papyrus-beanref">Defining a Bean Reference</a>.</p>
</div>
<div class="sect3">
<h4 id="using-an-initial-action"><a class="anchor" href="#using-an-initial-action"></a>Using an Initial Action</h4>
<div class="paragraph">
<p>An initial action (as shown in <a href="#statemachine-config-actions">Configuring Actions</a>) is defined
in UML by adding an action in the transition that leads from the Initial State
marker into the actual state. This Action is then run when the state
machine is started.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defining-guards"><a class="anchor" href="#defining-guards"></a>Defining Guards</h3>
<div class="paragraph">
<p>You can define a guard by first adding a Constraint and then defining
its Specification as OpaqueExpression, which works in the same way
as <a href="#sm-papyrus-beanref">Defining a Bean Reference</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-papyrus-beanref"><a class="anchor" href="#sm-papyrus-beanref"></a>Defining a Bean Reference</h3>
<div class="paragraph">
<p>When you need to make a bean reference in any UML effect,
action, or guard, you can do so with
<code>FunctionBehavior</code> or <code>OpaqueBehavior</code>, where the defined language needs to
be <code>bean</code> and the language body msut have a bean reference id.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-papyrus-spelref"><a class="anchor" href="#sm-papyrus-spelref"></a>Defining a SpEL Reference</h3>
<div class="paragraph">
<p>When you need to use a SpEL expression instead of a bean reference in
any UML effect, action, or guard, you can do so by using
<code>FunctionBehavior</code> or <code>OpaqueBehavior</code>, where the defined language needs to
be <code>spel</code> and the language body must be a SpEL expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="sm-papyrus-submachineref"><a class="anchor" href="#sm-papyrus-submachineref"></a>Using a Sub-Machine Reference</h3>
<div class="paragraph">
<p>Normally, when you use sub-states, you draw those into the state
chart itself. The chart may become too complex and big to
follow, so we also support defining a sub-state as a state machine
reference.</p>
</div>
<div class="paragraph">
<p>To create a sub-machine reference, you must first create a new diagram and give it a name
(for example, SubStateMachine Diagram). The following image shows the menu choices to use:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-12.png" alt="papyrus gs 12">
</div>
</div>
<div class="paragraph">
<p>Give the new diagram the design you need.
The following image shows a simple design as an example:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-13.png" alt="papyrus gs 13">
</div>
</div>
<div class="paragraph">
<p>From the state you want to link (in this case,m state <code>S2</code>), click the
<code>Submachine</code> field and choose your linked machine (in our example,
<code>SubStateMachine</code>).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-14.png" alt="papyrus gs 14">
</div>
</div>
<div class="paragraph">
<p>Finally, in the following image, you can see that state <code>S2</code> is linked to <code>SubStateMachine</code> as a
sub-state.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/papyrus-gs-15.png" alt="papyrus gs 15">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sm-repository"><a class="anchor" href="#sm-repository"></a>Repository Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section contains documentation related to using 'Spring Data
Repositories' in Spring Statemachine.</p>
</div>
<div class="sect2">
<h3 id="sm-repository-config"><a class="anchor" href="#sm-repository-config"></a>Repository Configuration</h3>
<div class="paragraph">
<p>You can keep machine configuration in external
storage, from which it can be loaded on demand, instead of creating a static
configuration by using either Java configuration or UML-based configuration. This
integration works through a Spring Data Repository abstraction.</p>
</div>
<div class="paragraph">
<p>We have created a special <code>StateMachineModelFactory</code> implementation
called <code>RepositoryStateMachineModelFactory</code>. It can use the base
repository interfaces (<code>StateRepository</code>, <code>TransitionRepository</code>,
<code>ActionRepository</code> and <code>GuardRepository</code>) and base entity
interfaces (<code>RepositoryState</code>, <code>RepositoryTransition</code>,
<code>RepositoryAction</code>, and <code>RepositoryGuard</code>).</p>
</div>
<div class="paragraph">
<p>Due to way how entities and repositories work in Spring Data,
from a user perspective, read access can be fully abstracted as it is
done in <code>RepositoryStateMachineModelFactory</code>. There is no need to
know the actual mapped entity class with which a repository works.
Writing into a repository is always dependent on using a real
repository-specific entity class. From a machine-configuration point
of view, we do not need to know these, meaning that we do not need to know
whether the actual implementation is JPA, Redis, or anything else
that Spring Data supports. Using an actual repository-related
entity class comes into play when you manually try to write new
states or transitions into a backed repository.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Entity classes for <code>RepositoryState</code> and <code>RepositoryTransition</code> have a
<code>machineId</code> field, which is at your disposal and can be used to
differentiate between configurations&#8201;&#8212;&#8201;for example, if machines are built
via <code>StateMachineFactory</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Actual implementations are documented in later sections.
The following images are UML-equivalent state charts of repository
configurations.</p>
</div>
<div id="image-sm-repository-simplemachine" class="imageblock">
<div class="content">
<img src="images/sm-repository-simplemachine.png" alt="sm repository simplemachine">
</div>
<div class="title">Figure 1. SimpleMachine</div>
</div>
<div id="image-sm-repository-simplesubmachine" class="imageblock">
<div class="content">
<img src="images/sm-repository-simplesubmachine.png" alt="sm repository simplesubmachine">
</div>
<div class="title">Figure 2. SimpleSubMachine</div>
</div>
<div id="image-sm-repository-showcasemachine" class="imageblock">
<div class="content">
<img src="images/sm-repository-showcasemachine.png" alt="sm repository showcasemachine">
</div>
<div class="title">Figure 3. ShowcaseMachine</div>
</div>
<div class="sect3">
<h4 id="sm-repository-config-jpa"><a class="anchor" href="#sm-repository-config-jpa"></a>JPA</h4>
<div class="paragraph">
<p>The actual repository implementations for JPA are
<code>JpaStateRepository</code>, <code>JpaTransitionRepository</code>, <code>JpaActionRepository</code>,
and <code>JpaGuardRepository</code>, which are backed by the
entity classes <code>JpaRepositoryState</code>, <code>JpaRepositoryTransition</code>,
<code>JpaRepositoryAction</code>, and <code>JpaRepositoryGuard</code>, respectively.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Unfortunately, version '1.2.8' had to make a change in JPA&#8217;s entity
model regarding used table names. Previously, generated table names
always had a prefix of <code>JPA_REPOSITORY_</code>, derived from entity class
names. As this caused breaking issues with databases imposing
restrictions on database object lengths, all entity classes have
spesific definitions to force table names. For example,
<code>JPA_REPOSITORY_STATE</code> is now 'STATE'&#8201;&#8212;&#8201;and so on with other
ntity classes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The generic way to update states and transitions manually for JPA is shown
in the following example (equivalent to the machine shown in
<a href="#image-sm-repository-simplemachine">SimpleMachine</a>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;JpaRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;JpaRepositoryTransition&gt; transitionRepository;

void addConfig() {
	JpaRepositoryState stateS1 = new JpaRepositoryState("S1", true);
	JpaRepositoryState stateS2 = new JpaRepositoryState("S2");
	JpaRepositoryState stateS3 = new JpaRepositoryState("S3");

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);

	JpaRepositoryTransition transitionS1ToS2 = new JpaRepositoryTransition(stateS1, stateS2, "E1");
	JpaRepositoryTransition transitionS2ToS3 = new JpaRepositoryTransition(stateS2, stateS3, "E2");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example is also equivalent to the machine shown in
<a href="#image-sm-repository-simplesubmachine">SimpleSubMachine</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;JpaRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;JpaRepositoryTransition&gt; transitionRepository;

void addConfig() {
	JpaRepositoryState stateS1 = new JpaRepositoryState("S1", true);
	JpaRepositoryState stateS2 = new JpaRepositoryState("S2");
	JpaRepositoryState stateS3 = new JpaRepositoryState("S3");

	JpaRepositoryState stateS21 = new JpaRepositoryState("S21", true);
	stateS21.setParentState(stateS2);
	JpaRepositoryState stateS22 = new JpaRepositoryState("S22");
	stateS22.setParentState(stateS2);

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);
	stateRepository.save(stateS21);
	stateRepository.save(stateS22);

	JpaRepositoryTransition transitionS1ToS2 = new JpaRepositoryTransition(stateS1, stateS2, "E1");
	JpaRepositoryTransition transitionS2ToS3 = new JpaRepositoryTransition(stateS21, stateS22, "E2");
	JpaRepositoryTransition transitionS21ToS22 = new JpaRepositoryTransition(stateS2, stateS3, "E3");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
	transitionRepository.save(transitionS21ToS22);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>First, you must access all repositories.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;JpaRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;JpaRepositoryTransition&gt; transitionRepository;

@Autowired
ActionRepository&lt;JpaRepositoryAction&gt; actionRepository;

@Autowired
GuardRepository&lt;JpaRepositoryGuard&gt; guardRepository;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Second, you mus create actions and guards.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JpaRepositoryGuard foo0Guard = new JpaRepositoryGuard();
foo0Guard.setName("foo0Guard");

JpaRepositoryGuard foo1Guard = new JpaRepositoryGuard();
foo1Guard.setName("foo1Guard");

JpaRepositoryAction fooAction = new JpaRepositoryAction();
fooAction.setName("fooAction");

guardRepository.save(foo0Guard);
guardRepository.save(foo1Guard);
actionRepository.save(fooAction);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Third, you must create states.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JpaRepositoryState stateS0 = new JpaRepositoryState("S0", true);
stateS0.setInitialAction(fooAction);
JpaRepositoryState stateS1 = new JpaRepositoryState("S1", true);
stateS1.setParentState(stateS0);
JpaRepositoryState stateS11 = new JpaRepositoryState("S11", true);
stateS11.setParentState(stateS1);
JpaRepositoryState stateS12 = new JpaRepositoryState("S12");
stateS12.setParentState(stateS1);
JpaRepositoryState stateS2 = new JpaRepositoryState("S2");
stateS2.setParentState(stateS0);
JpaRepositoryState stateS21 = new JpaRepositoryState("S21", true);
stateS21.setParentState(stateS2);
JpaRepositoryState stateS211 = new JpaRepositoryState("S211", true);
stateS211.setParentState(stateS21);
JpaRepositoryState stateS212 = new JpaRepositoryState("S212");
stateS212.setParentState(stateS21);

stateRepository.save(stateS0);
stateRepository.save(stateS1);
stateRepository.save(stateS11);
stateRepository.save(stateS12);
stateRepository.save(stateS2);
stateRepository.save(stateS21);
stateRepository.save(stateS211);
stateRepository.save(stateS212);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Fourth and finally, you must  create transitions.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JpaRepositoryTransition transitionS1ToS1 = new JpaRepositoryTransition(stateS1, stateS1, "A");
transitionS1ToS1.setGuard(foo1Guard);

JpaRepositoryTransition transitionS1ToS11 = new JpaRepositoryTransition(stateS1, stateS11, "B");
JpaRepositoryTransition transitionS21ToS211 = new JpaRepositoryTransition(stateS21, stateS211, "B");
JpaRepositoryTransition transitionS1ToS2 = new JpaRepositoryTransition(stateS1, stateS2, "C");
JpaRepositoryTransition transitionS1ToS0 = new JpaRepositoryTransition(stateS1, stateS0, "D");
JpaRepositoryTransition transitionS211ToS21 = new JpaRepositoryTransition(stateS211, stateS21, "D");
JpaRepositoryTransition transitionS0ToS211 = new JpaRepositoryTransition(stateS0, stateS211, "E");
JpaRepositoryTransition transitionS1ToS211 = new JpaRepositoryTransition(stateS1, stateS211, "F");
JpaRepositoryTransition transitionS2ToS21 = new JpaRepositoryTransition(stateS2, stateS21, "F");
JpaRepositoryTransition transitionS11ToS211 = new JpaRepositoryTransition(stateS11, stateS211, "G");

JpaRepositoryTransition transitionS0 = new JpaRepositoryTransition(stateS0, stateS0, "H");
transitionS0.setKind(TransitionKind.INTERNAL);
transitionS0.setGuard(foo0Guard);
transitionS0.setActions(new HashSet&lt;&gt;(Arrays.asList(fooAction)));

JpaRepositoryTransition transitionS1 = new JpaRepositoryTransition(stateS1, stateS1, "H");
transitionS1.setKind(TransitionKind.INTERNAL);

JpaRepositoryTransition transitionS2 = new JpaRepositoryTransition(stateS2, stateS2, "H");
transitionS2.setKind(TransitionKind.INTERNAL);
transitionS2.setGuard(foo1Guard);
transitionS2.setActions(new HashSet&lt;&gt;(Arrays.asList(fooAction)));

JpaRepositoryTransition transitionS11ToS12 = new JpaRepositoryTransition(stateS11, stateS12, "I");
JpaRepositoryTransition transitionS12ToS212 = new JpaRepositoryTransition(stateS12, stateS212, "I");
JpaRepositoryTransition transitionS211ToS12 = new JpaRepositoryTransition(stateS211, stateS12, "I");

JpaRepositoryTransition transitionS11 = new JpaRepositoryTransition(stateS11, stateS11, "J");
JpaRepositoryTransition transitionS2ToS1 = new JpaRepositoryTransition(stateS2, stateS1, "K");

transitionRepository.save(transitionS1ToS1);
transitionRepository.save(transitionS1ToS11);
transitionRepository.save(transitionS21ToS211);
transitionRepository.save(transitionS1ToS2);
transitionRepository.save(transitionS1ToS0);
transitionRepository.save(transitionS211ToS21);
transitionRepository.save(transitionS0ToS211);
transitionRepository.save(transitionS1ToS211);
transitionRepository.save(transitionS2ToS21);
transitionRepository.save(transitionS11ToS211);
transitionRepository.save(transitionS0);
transitionRepository.save(transitionS1);
transitionRepository.save(transitionS2);
transitionRepository.save(transitionS11ToS12);
transitionRepository.save(transitionS12ToS212);
transitionRepository.save(transitionS211ToS12);
transitionRepository.save(transitionS11);
transitionRepository.save(transitionS2ToS1);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find a complete example
<a href="#statemachine-examples-datajpa">here</a>. This example also shows how you can
pre-populate a repository from an existing JSON file that has
definitions for entity classes.</p>
</div>
</div>
<div class="sect3">
<h4 id="sm-repository-config-redis"><a class="anchor" href="#sm-repository-config-redis"></a>Redis</h4>
<div class="paragraph">
<p>The actual repository implementations for a Redis instance are
<code>RedisStateRepository</code>, <code>RedisTransitionRepository</code>, <code>RedisActionRepository</code>,
and <code>RedisGuardRepository</code>, which are backed by the
entity classes <code>RedisRepositoryState</code>, <code>RedisRepositoryTransition</code>,
<code>RedisRepositoryAction</code>, and <code>RedisRepositoryGuard</code>, respectively.</p>
</div>
<div class="paragraph">
<p>The next example shows the generic way to manually update states and transitions for Redis.
This is equivalent to machine shown in
<a href="#image-sm-repository-simplemachine">SimpleMachine</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;RedisRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;RedisRepositoryTransition&gt; transitionRepository;

void addConfig() {
	RedisRepositoryState stateS1 = new RedisRepositoryState("S1", true);
	RedisRepositoryState stateS2 = new RedisRepositoryState("S2");
	RedisRepositoryState stateS3 = new RedisRepositoryState("S3");

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);


	RedisRepositoryTransition transitionS1ToS2 = new RedisRepositoryTransition(stateS1, stateS2, "E1");
	RedisRepositoryTransition transitionS2ToS3 = new RedisRepositoryTransition(stateS2, stateS3, "E2");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example is equivalent to machine shown in
<a href="#image-sm-repository-simplesubmachine">SimpleSubMachine</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;RedisRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;RedisRepositoryTransition&gt; transitionRepository;

void addConfig() {
	RedisRepositoryState stateS1 = new RedisRepositoryState("S1", true);
	RedisRepositoryState stateS2 = new RedisRepositoryState("S2");
	RedisRepositoryState stateS3 = new RedisRepositoryState("S3");

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);


	RedisRepositoryTransition transitionS1ToS2 = new RedisRepositoryTransition(stateS1, stateS2, "E1");
	RedisRepositoryTransition transitionS2ToS3 = new RedisRepositoryTransition(stateS2, stateS3, "E2");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sm-repository-config-mongodb"><a class="anchor" href="#sm-repository-config-mongodb"></a>MongoDB</h4>
<div class="paragraph">
<p>The actual repository implementations for a MongoDB instance are
<code>MongoDbStateRepository</code>, <code>MongoDbTransitionRepository</code>, <code>MongoDbActionRepository</code>,
and <code>MongoDbGuardRepository</code>, which are backed by the
entity classes <code>MongoDbRepositoryState</code>, <code>MongoDbRepositoryTransition</code>,
<code>MongoDbRepositoryAction</code>, and <code>MongoDbRepositoryGuard</code>, respectively.</p>
</div>
<div class="paragraph">
<p>The next example shows the generic way to manually update states and transitions for MongoDB.
This is equivalent to the machine shown in
<a href="#image-sm-repository-simplemachine">SimpleMachine</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;MongoDbRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;MongoDbRepositoryTransition&gt; transitionRepository;

void addConfig() {
	MongoDbRepositoryState stateS1 = new MongoDbRepositoryState("S1", true);
	MongoDbRepositoryState stateS2 = new MongoDbRepositoryState("S2");
	MongoDbRepositoryState stateS3 = new MongoDbRepositoryState("S3");

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);

	MongoDbRepositoryTransition transitionS1ToS2 = new MongoDbRepositoryTransition(stateS1, stateS2, "E1");
	MongoDbRepositoryTransition transitionS2ToS3 = new MongoDbRepositoryTransition(stateS2, stateS3, "E2");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example is equivalent to the machine shown in
<a href="#image-sm-repository-simplesubmachine">SimpleSubMachine</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateRepository&lt;MongoDbRepositoryState&gt; stateRepository;

@Autowired
TransitionRepository&lt;MongoDbRepositoryTransition&gt; transitionRepository;

void addConfig() {
	MongoDbRepositoryState stateS1 = new MongoDbRepositoryState("S1", true);
	MongoDbRepositoryState stateS2 = new MongoDbRepositoryState("S2");
	MongoDbRepositoryState stateS3 = new MongoDbRepositoryState("S3");

	MongoDbRepositoryState stateS21 = new MongoDbRepositoryState("S21", true);
	stateS21.setParentState(stateS2);
	MongoDbRepositoryState stateS22 = new MongoDbRepositoryState("S22");
	stateS22.setParentState(stateS2);

	stateRepository.save(stateS1);
	stateRepository.save(stateS2);
	stateRepository.save(stateS3);
	stateRepository.save(stateS21);
	stateRepository.save(stateS22);

	MongoDbRepositoryTransition transitionS1ToS2 = new MongoDbRepositoryTransition(stateS1, stateS2, "E1");
	MongoDbRepositoryTransition transitionS2ToS3 = new MongoDbRepositoryTransition(stateS21, stateS22, "E2");
	MongoDbRepositoryTransition transitionS21ToS22 = new MongoDbRepositoryTransition(stateS2, stateS3, "E3");

	transitionRepository.save(transitionS1ToS2);
	transitionRepository.save(transitionS2ToS3);
	transitionRepository.save(transitionS21ToS22);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sm-repository-persistence"><a class="anchor" href="#sm-repository-persistence"></a>Repository Persistence</h3>
<div class="paragraph">
<p>Apart from storing machine configuration (as shown in
<a href="#sm-repository-config">Repository Configuration</a>), in an external repository, you canx also
persist machines into repositories.</p>
</div>
<div class="paragraph">
<p>The <code>StateMachineRepository</code> interface is a central access point that
interacts with machine persistence and is backed by the entity class
<code>RepositoryStateMachine</code>.</p>
</div>
<div class="sect3">
<h4 id="sm-repository-persistence-jpa"><a class="anchor" href="#sm-repository-persistence-jpa"></a>JPA</h4>
<div class="paragraph">
<p>The actual repository implementation for JPA is
<code>JpaStateMachineRepository</code>, which is backed by the entity class
<code>JpaRepositoryStateMachine</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows the generic way to persist a machine for JPA:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateMachineRepository&lt;JpaRepositoryStateMachine&gt; stateMachineRepository;

void persist() {

	JpaRepositoryStateMachine machine = new JpaRepositoryStateMachine();
	machine.setMachineId("machine");
	machine.setState("S1");
	// raw byte[] representation of a context
	machine.setStateMachineContext(new byte[] { 0 });

	stateMachineRepository.save(machine);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sm-repository-persistence-redis"><a class="anchor" href="#sm-repository-persistence-redis"></a>Redis</h4>
<div class="paragraph">
<p>The actual repository implementation for a Redis is
<code>RedisStateMachineRepository</code>, which is backed by the entity class
<code>RedisRepositoryStateMachine</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows the generic way to persist a machine for Redis:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateMachineRepository&lt;RedisRepositoryStateMachine&gt; stateMachineRepository;

void persist() {

	RedisRepositoryStateMachine machine = new RedisRepositoryStateMachine();
	machine.setMachineId("machine");
	machine.setState("S1");
	// raw byte[] representation of a context
	machine.setStateMachineContext(new byte[] { 0 });

	stateMachineRepository.save(machine);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sm-repository-persistence-mongodb"><a class="anchor" href="#sm-repository-persistence-mongodb"></a>MongoDB</h4>
<div class="paragraph">
<p>The actual repository implementation for MongoDB is
<code>MongoDbStateMachineRepository</code>, which is backed by the entity class
<code>MongoDbRepositoryStateMachine</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows the generic way to persist a machine for MongoDB:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
StateMachineRepository&lt;MongoDbRepositoryStateMachine&gt; stateMachineRepository;

void persist() {

	MongoDbRepositoryStateMachine machine = new MongoDbRepositoryStateMachine();
	machine.setMachineId("machine");
	machine.setState("S1");
	// raw byte[] representation of a context
	machine.setStateMachineContext(new byte[] { 0 });

	stateMachineRepository.save(machine);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="statemachine-recipes" class="sect0"><a class="anchor" href="#statemachine-recipes"></a>Recipes</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This chapter contains documentation for existing built-in state
machine recipes.</p>
</div>
<div class="paragraph">
<p>Spring Statemachine is a foundational framework. That is, it does not have much
higher-level functionality or many dependencies beyond Spring Framework.
Consequently, correctly using a state machine may be difficult. To help,
we have created a set of recipe modules that address common use cases.</p>
</div>
<div class="paragraph">
<p>What exactly is a recipe? A state machine recipe is a module that addresses a common
use case. In essence, a state machine recipe is both an example that we have tried to
make it easy for you to reuse and extend.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Recipes are a great way to make external contributions to the Spring
Statemachine project. If you are not ready to contribute to the
framework core itself, a custom and common recipe is a great way to
share functionality with other users.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-recipes-persist"><a class="anchor" href="#statemachine-recipes-persist"></a>Persist</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The persist recipe is a simple utility that lets you use a single state
machine instance to persist and update the state of an arbitrary item in
a repository.</p>
</div>
<div class="paragraph">
<p>The recipe&#8217;s main class is <code>PersistStateMachineHandler</code>, which makes three assumptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An instance of a <code>StateMachine&lt;String, String&gt;</code> needs to be used
with a <code>PersistStateMachineHandler</code>. Note that states and Events are required
to be type of <code>String</code>.</p>
</li>
<li>
<p><code>PersistStateChangeListener</code> needs to be registered with handler
to react to persist request.</p>
</li>
<li>
<p>The <code>handleEventWithState</code> method is used to orchestrate state changes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can find a sample that shows how to use this recipe at
<a href="#statemachine-examples-persist">Persist</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-recipes-tasks"><a class="anchor" href="#statemachine-recipes-tasks"></a>Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The tasks recipe is a concept to run DAG (Directed Acrylic Graph) of <code>Runnable</code> instances that use
a state machine. This recipe has been developed from ideas introduced
in <a href="#statemachine-examples-tasks">Tasks</a> sample.</p>
</div>
<div class="paragraph">
<p>The next image shows the generic concept of a state machine. In this state chart,
everything under <code>TASKS</code> shows a generic concept of how a single
task is executed. Because this recipe lets you register a deep
hierarchical DAG of tasks (meaning a real state chart would be a deeply
nested collection of sub-states and regions), we have no need to be
more precise.</p>
</div>
<div class="paragraph">
<p>For example, if you have only two registered tasks, the following state chart
would be correct when <code>TASK_id</code> is replaced with <code>TASK_1</code> and <code>TASK_2</code> (assuming
the registered tasks IDs are <code>1</code> and <code>2</code>).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart9.png" alt="statechart9" width="500">
</div>
</div>
<div class="paragraph">
<p>Executing a <code>Runnable</code> may result an error. Especially if a complex
DAG of tasks is involved, you want to have a way to handle
task execution errors and then have a way to continue execution
without executing already successfully executed tasks. Also,
it would be nice if some execution errors can be handled
automatically. As a last fallback, if an error cannot be handled
automatically, the state machine is put into a state where the user can handle
errors manually.</p>
</div>
<div class="paragraph">
<p><code>TasksHandler</code> contains a builder method to configure a handler instance
and follows a simple builder pattern. You can use this builder to
register <code>Runnable</code> tasks and <code>TasksListener</code> instances, define
<code>StateMachinePersist</code> hook, and set up custom <code>TaskExecutor</code> instance.</p>
</div>
<div class="paragraph">
<p>Now we can take a simple <code>Runnable</code> that runs a simple sleep as the following
example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private Runnable sleepRunnable() {
	return new Runnable() {

		@Override
		public void run() {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
			}
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding example is the base for all of the examples in this chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To execute multiple <code>sleepRunnable</code> tasks, you can register tasks and
execute <code>runTasks()</code> method from <code>TasksHandler</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">TasksHandler handler = TasksHandler.builder()
		.task("1", sleepRunnable())
		.task("2", sleepRunnable())
		.task("3", sleepRunnable())
		.build();

handler.runTasks();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To listen to what is happening with a task execution, you can register an instance of
a <code>TasksListener</code> with a <code>TasksHandler</code>. This recipe
provides an adapter <code>TasksListenerAdapter</code> if you do not want to
implement a full interface. The listener provides a various hooks to
listen tasks execution events. The following example shows the definition of the
<code>MyTasksListener</code> class:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private class MyTasksListener extends TasksListenerAdapter {

	@Override
	public void onTasksStarted() {
	}

	@Override
	public void onTasksContinue() {
	}

	@Override
	public void onTaskPreExecute(Object id) {
	}

	@Override
	public void onTaskPostExecute(Object id) {
	}

	@Override
	public void onTaskFailed(Object id, Exception exception) {
	}

	@Override
	public void onTaskSuccess(Object id) {
	}

	@Override
	public void onTasksSuccess() {
	}

	@Override
	public void onTasksError() {
	}

	@Override
	public void onTasksAutomaticFix(TasksHandler handler, StateContext&lt;String, String&gt; context) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can either register listeners by using a builder or register them directly with a
<code>TasksHandler</code> as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MyTasksListener listener1 = new MyTasksListener();
MyTasksListener listener2 = new MyTasksListener();

TasksHandler handler = TasksHandler.builder()
		.task("1", sleepRunnable())
		.task("2", sleepRunnable())
		.task("3", sleepRunnable())
		.listener(listener1)
		.build();

handler.addTasksListener(listener2);
handler.removeTasksListener(listener2);

handler.runTasks();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Every task
needs to have a unique identifier, and (optionally) a task can be
defined to be a sub-task. Effectively, this creates a DAG of tasks.
The following example shows how to create a deep nested DAG of tasks:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">TasksHandler handler = TasksHandler.builder()
		.task("1", sleepRunnable())
		.task("1", "12", sleepRunnable())
		.task("1", "13", sleepRunnable())
		.task("2", sleepRunnable())
		.task("2", "22", sleepRunnable())
		.task("2", "23", sleepRunnable())
		.task("3", sleepRunnable())
		.task("3", "32", sleepRunnable())
		.task("3", "33", sleepRunnable())
		.build();

handler.runTasks();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When an error happens and the state machine running these tasks goes into an
<code>ERROR</code> state, you can call <code>fixCurrentProblems</code> handler method to
reset the current state of the tasks kept in the state machine&#8217;s extended state
variables. You can then use the <code>continueFromError</code> handler method to
instruct the state machine to transition from the <code>ERROR</code> state back to the
<code>READY</code> state, where you can again run tasks.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">TasksHandler handler = TasksHandler.builder()
		.task("1", sleepRunnable())
		.task("2", sleepRunnable())
		.task("3", sleepRunnable())
		.build();

		handler.runTasks();
		handler.fixCurrentProblems();
		handler.continueFromError();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="statemachine-examples" class="sect0"><a class="anchor" href="#statemachine-examples"></a>State Machine Examples</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This part of the reference documentation explains the use of state
machines together with sample code and UML state charts. We use a few
shortcuts when representing the relationship between a state chart, Spring Statemachine
configuration, and what an application does with a state machine. For
complete examples, you should study the samples repository.</p>
</div>
<div class="paragraph">
<p>Samples are built directly from a main source distribution during a
normal build cycle. This chapter includes the following samples:</p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-turnstile">Turnstile</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-showcase">Showcase</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-cdplayer">CD Player</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-tasks">Tasks</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-washer">Washer</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-persist">Persist</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-zookeeper">Zookeeper</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-web">Web</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-scope">Scope</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-security">Security</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-eventservice">Event Service</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-deploy">Deploy</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-ordershipping">Order Shipping</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-datajpa">JPA Configuration</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-datapersist">Data Persist</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-datajpamultipersist">Data Multi Persist</a></p>
</div>
<div class="paragraph">
<p><a href="#statemachine-examples-monitoring">Monitoring</a></p>
</div>
<div class="paragraph">
<p>The following listing shows how to build the samples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash" data-lang="bash">./gradlew clean build -x test</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Every sample is located in its own directory under
<code>spring-statemachine-samples</code>. The samples are based on Spring Boot and
Spring Shell, and you can find the usual Boot fat jars under every sample
project&#8217;s <code>build/libs</code> directory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The filenames for the jars to which we refer in this section are populated during a
build of this document, meaning that, if you build samples from
master, you have files with a <code>BUILD-SNAPSHOT</code> postfix.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-turnstile"><a class="anchor" href="#statemachine-examples-turnstile"></a>Turnstile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Turnstile is a simple device that gives you access if payment is
made. It is a concept that is simple to model using a state machine. In its
simplest, form there are only two states: <code>LOCKED</code> and <code>UNLOCKED</code>. Two
events, <code>COIN</code> and <code>PUSH</code> can happen, depending on whether someone
makes a payment or tries to go through the turnstile.
The following image shows the state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart1.png" alt="statechart1" width="500">
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">States</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    LOCKED, UNLOCKED
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Events</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    COIN, PUSH
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the code that configures the state machine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class StateMachineConfig
		extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.LOCKED)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.LOCKED)
				.target(States.UNLOCKED)
				.event(Events.COIN)
				.and()
			.withExternal()
				.source(States.UNLOCKED)
				.target(States.LOCKED)
				.event(Events.PUSH);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can see how this sample state machine interacts with events by
running the <code>turnstile</code> sample. The following listing shows how to do so
and shows the command&#8217;s output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">$ java -jar spring-statemachine-samples-turnstile-{revnumber}.jar

sm&gt;sm print
+----------------------------------------------------------------+
|                              SM                                |
+----------------------------------------------------------------+
|                                                                |
|         +----------------+          +----------------+         |
|     *--&gt;|     LOCKED     |          |    UNLOCKED    |         |
|         +----------------+          +----------------+         |
|     +---| entry/         |          | entry/         |---+     |
|     |   | exit/          |          | exit/          |   |     |
|     |   |                |          |                |   |     |
| PUSH|   |                |---COIN--&gt;|                |   |COIN |
|     |   |                |          |                |   |     |
|     |   |                |          |                |   |     |
|     |   |                |&lt;--PUSH---|                |   |     |
|     +--&gt;|                |          |                |&lt;--+     |
|         |                |          |                |         |
|         +----------------+          +----------------+         |
|                                                                |
+----------------------------------------------------------------+

sm&gt;sm start
State changed to LOCKED
State machine started

sm&gt;sm event COIN
State changed to UNLOCKED
Event COIN send

sm&gt;sm event PUSH
State changed to LOCKED
Event PUSH send</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-showcase"><a class="anchor" href="#statemachine-examples-showcase"></a>Showcase</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Showcase is a complex state machine that shows all possible transition
topologies up to four levels of state nesting.
The following image shows the state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart2.png" alt="statechart2" width="500">
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">States</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    S0, S1, S11, S12, S2, S21, S211, S212
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Events</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    A, B, C, D, E, F, G, H, I
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the code that configures the state machine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - states</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
		throws Exception {
	states
		.withStates()
			.initial(States.S0, fooAction())
			.state(States.S0)
			.and()
			.withStates()
				.parent(States.S0)
				.initial(States.S1)
				.state(States.S1)
				.and()
				.withStates()
					.parent(States.S1)
					.initial(States.S11)
					.state(States.S11)
					.state(States.S12)
					.and()
			.withStates()
				.parent(States.S0)
				.state(States.S2)
				.and()
				.withStates()
					.parent(States.S2)
					.initial(States.S21)
					.state(States.S21)
					.and()
					.withStates()
						.parent(States.S21)
						.initial(States.S211)
						.state(States.S211)
						.state(States.S212);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the code that configures the state machine&#8217;s transitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - transitions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.S1).target(States.S1).event(Events.A)
			.guard(foo1Guard())
			.and()
		.withExternal()
			.source(States.S1).target(States.S11).event(Events.B)
			.and()
		.withExternal()
			.source(States.S21).target(States.S211).event(Events.B)
			.and()
		.withExternal()
			.source(States.S1).target(States.S2).event(Events.C)
			.and()
		.withExternal()
			.source(States.S2).target(States.S1).event(Events.C)
			.and()
		.withExternal()
			.source(States.S1).target(States.S0).event(Events.D)
			.and()
		.withExternal()
			.source(States.S211).target(States.S21).event(Events.D)
			.and()
		.withExternal()
			.source(States.S0).target(States.S211).event(Events.E)
			.and()
		.withExternal()
			.source(States.S1).target(States.S211).event(Events.F)
			.and()
		.withExternal()
			.source(States.S2).target(States.S11).event(Events.F)
			.and()
		.withExternal()
			.source(States.S11).target(States.S211).event(Events.G)
			.and()
		.withExternal()
			.source(States.S211).target(States.S0).event(Events.G)
			.and()
		.withInternal()
			.source(States.S0).event(Events.H)
			.guard(foo0Guard())
			.action(fooAction())
			.and()
		.withInternal()
			.source(States.S2).event(Events.H)
			.guard(foo1Guard())
			.action(fooAction())
			.and()
		.withInternal()
			.source(States.S1).event(Events.H)
			.and()
		.withExternal()
			.source(States.S11).target(States.S12).event(Events.I)
			.and()
		.withExternal()
			.source(States.S211).target(States.S212).event(Events.I)
			.and()
		.withExternal()
			.source(States.S12).target(States.S212).event(Events.I);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the code that configures the state machine&#8217;s actions and guards:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - actions and guards</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public FooGuard foo0Guard() {
	return new FooGuard(0);
}

@Bean
public FooGuard foo1Guard() {
	return new FooGuard(1);
}

@Bean
public FooAction fooAction() {
	return new FooAction();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows how the single action is defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Action</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private static class FooAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
		Integer foo = context.getExtendedState().get("foo", Integer.class);
		if (foo == null) {
			log.info("Init foo to 0");
			variables.put("foo", 0);
		} else if (foo == 0) {
			log.info("Switch foo to 1");
			variables.put("foo", 1);
		} else if (foo == 1) {
			log.info("Switch foo to 0");
			variables.put("foo", 0);
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows how the single guard is defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Guard</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private static class FooGuard implements Guard&lt;States, Events&gt; {

	private final int match;

	public FooGuard(int match) {
		this.match = match;
	}

	@Override
	public boolean evaluate(StateContext&lt;States, Events&gt; context) {
		Object foo = context.getExtendedState().getVariables().get("foo");
		return !(foo == null || !foo.equals(match));
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the output that this state machine produces when it runs and
various events are sent to it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
Init foo to 0
Entry state S0
Entry state S1
Entry state S11
State machine started

sm&gt;sm event A
Event A send

sm&gt;sm event C
Exit state S11
Exit state S1
Entry state S2
Entry state S21
Entry state S211
Event C send

sm&gt;sm event H
Switch foo to 1
Internal transition source=S0
Event H send

sm&gt;sm event C
Exit state S211
Exit state S21
Exit state S2
Entry state S1
Entry state S11
Event C send

sm&gt;sm event A
Exit state S11
Exit state S1
Entry state S1
Entry state S11
Event A send</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding output, we can see that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The state machine is started, which takes it to its initial state (<code>S11</code>)
through superstates (<code>S1</code>) and (<code>S0</code>). Also, the extended state variable, <code>foo</code>, is
initialized to <code>0</code>.</p>
</li>
<li>
<p>We try to execute a self transition in state <code>S1</code> with event <code>A</code>, but
nothing happens because the transition is guarded by variable <code>foo</code> to
be <code>1</code>.</p>
</li>
<li>
<p>We send event <code>C</code>, which takes us to the other state machine, where
the initial state (<code>S211</code>) and its superstates are entered. In there, we
can use event <code>H</code>, which does a simple internal transition to flip the
<code>foo</code> variable. Then we go back by using event <code>C</code>.</p>
</li>
<li>
<p>Event <code>A</code> is sent again, and now <code>S1</code> does a self transition because the
guard evaluates to <code>true</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example offers a closer look at how hierarchical states and their event
handling works:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm variables
No variables

sm&gt;sm start
Init foo to 0
Entry state S0
Entry state S1
Entry state S11
State machine started

sm&gt;sm variables
foo=0

sm&gt;sm event H
Internal transition source=S1
Event H send

sm&gt;sm variables
foo=0

sm&gt;sm event C
Exit state S11
Exit state S1
Entry state S2
Entry state S21
Entry state S211
Event C send

sm&gt;sm variables
foo=0

sm&gt;sm event H
Switch foo to 1
Internal transition source=S0
Event H send

sm&gt;sm variables
foo=1

sm&gt;sm event H
Switch foo to 0
Internal transition source=S2
Event H send

sm&gt;sm variables
foo=0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding sample:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We print extended state variables in various stages.</p>
</li>
<li>
<p>With event <code>H</code>, we end up running an internal transition,
which is logged with its source state.</p>
</li>
<li>
<p>Note how event <code>H</code> is handled in
different states (<code>S0</code>, <code>S1</code>, and <code>S2</code>). This is a good example of how
hierarchical states and their event handling works. If state <code>S2</code> is
unable to handle event <code>H</code> due to a guard condition, its parent is
checked next. This guarantees that, while the machine is on state <code>S2</code>, the <code>foo</code> flag
is always flipped around. However, in state <code>S1</code>, event <code>H</code> always
matches to its dummy transition without guard or action, so it never
happens.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-cdplayer"><a class="anchor" href="#statemachine-examples-cdplayer"></a>CD Player</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CD Player is a sample which resembles a use case that many people have
used in the real world. CD Player itself is a really simple entity that allows a
user to open a deck, insert or change a disk, and then drive the player&#8217;s
functionality by pressing various buttons (<code>eject</code>, <code>play</code>,
<code>stop</code>, <code>pause</code>, <code>rewind</code>, and <code>backward</code>).</p>
</div>
<div class="paragraph">
<p>How many of us have really given thought to what it will take to
make code that interacts with hardware to drive a CD Player. Yes, the
concept of a player is simple, but, if you look behind the scenes,
things actually get a bit convoluted.</p>
</div>
<div class="paragraph">
<p>You have probably noticed that, if your deck is open and you press play, the
deck closes and a song starts to play (if a CD was inserted).
In a sense, when the deck is open, you first need to close
it and then try to start playing (again, if a CD is actually inserted). Hopefully,
you have now realized that a simple CD Player is so simple.
Sure, you can wrap all this with a simple class that has a few boolean variables
and probably a few nested if-else clauses. That will do the job, but what
about if you need to make all this behavior much more complex? Do you
really want to keep adding more flags and if-else clauses?</p>
</div>
<div class="paragraph">
<p>The following image shows the state machine for our simple CD player:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart3.png" alt="statechart3" width="500">
</div>
</div>
<div class="paragraph">
<p>The rest of this section goes through how this sample and its state machine is designed and
how those two interacts with each other. The following three configuration sections
are used within an <code>EnumStateMachineConfigurerAdapter</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
		throws Exception {
	states
		.withStates()
			.initial(States.IDLE)
			.state(States.IDLE)
			.and()
			.withStates()
				.parent(States.IDLE)
				.initial(States.CLOSED)
				.state(States.CLOSED, closedEntryAction(), null)
				.state(States.OPEN)
				.and()
		.withStates()
			.state(States.BUSY)
			.and()
			.withStates()
				.parent(States.BUSY)
				.initial(States.PLAYING)
				.state(States.PLAYING)
				.state(States.PAUSED);

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.CLOSED).target(States.OPEN).event(Events.EJECT)
			.and()
		.withExternal()
			.source(States.OPEN).target(States.CLOSED).event(Events.EJECT)
			.and()
		.withExternal()
			.source(States.OPEN).target(States.CLOSED).event(Events.PLAY)
			.and()
		.withExternal()
			.source(States.PLAYING).target(States.PAUSED).event(Events.PAUSE)
			.and()
		.withInternal()
			.source(States.PLAYING)
			.action(playingAction())
			.timer(1000)
			.and()
		.withInternal()
			.source(States.PLAYING).event(Events.BACK)
			.action(trackAction())
			.and()
		.withInternal()
			.source(States.PLAYING).event(Events.FORWARD)
			.action(trackAction())
			.and()
		.withExternal()
			.source(States.PAUSED).target(States.PLAYING).event(Events.PAUSE)
			.and()
		.withExternal()
			.source(States.BUSY).target(States.IDLE).event(Events.STOP)
			.and()
		.withExternal()
			.source(States.IDLE).target(States.BUSY).event(Events.PLAY)
			.action(playAction())
			.guard(playGuard())
			.and()
		.withInternal()
			.source(States.OPEN).event(Events.LOAD).action(loadAction());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ClosedEntryAction closedEntryAction() {
	return new ClosedEntryAction();
}

@Bean
public LoadAction loadAction() {
	return new LoadAction();
}

@Bean
public TrackAction trackAction() {
	return new TrackAction();
}

@Bean
public PlayAction playAction() {
	return new PlayAction();
}

@Bean
public PlayingAction playingAction() {
	return new PlayingAction();
}

@Bean
public PlayGuard playGuard() {
	return new PlayGuard();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We used <code>EnumStateMachineConfigurerAdapter</code> to configure states and
transitions.</p>
</li>
<li>
<p>The <code>CLOSED</code> and <code>OPEN</code> states are defined as substates of <code>IDLE</code>, and
the <code>PLAYING</code> and <code>PAUSED</code> states are defined as substates of <code>BUSY</code>.</p>
</li>
<li>
<p>With the <code>CLOSED</code> state, we added an entry action as a bean called
<code>closedEntryAction</code>.</p>
</li>
<li>
<p>In the transitions we mostly map events to expected state
transitions, such as <code>EJECT</code> closing and opening a deck and <code>PLAY</code>, <code>STOP</code>,
and <code>PAUSE</code> doing their natural transitions. For other transitions, we did the following:</p>
<div class="ulist">
<ul>
<li>
<p>For source state <code>PLAYING</code>, we added a timer trigger, which is
needed to automatically track elapsed time within a playing track and
to have a facility for making the decision about when to switch the to next track.</p>
</li>
<li>
<p>For the <code>PLAY</code> event, if the source state is <code>IDLE</code> and the target state is
<code>BUSY</code>, we defined an action called <code>playAction</code> and a guard called <code>playGuard</code>.</p>
</li>
<li>
<p>For the <code>LOAD</code> event and the <code>OPEN</code> state, we defined an internal
transition with an action called <code>loadAction</code>, which tracks inserting a disc with
extended-state variables.</p>
</li>
<li>
<p>The <code>PLAYING</code> state defines three internal transitions. One is
triggered by a timer that runs an action called <code>playingAction</code>, which updates
the extended state variables. The other two transitions use <code>trackAction</code>
with different events (<code>BACK</code> and <code>FORWARD</code>, respectively) to handle
when the user wants to go back or forward in tracks.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>This machine has only have six states, which are defined by the following enumeration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
	// super state of PLAYING and PAUSED
    BUSY,
    PLAYING,
    PAUSED,
	// super state of CLOSED and OPEN
    IDLE,
    CLOSED,
    OPEN
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Events represent the buttons the user can
press and whether the user loads a disc into the player.
The following enumeration defines the events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    PLAY, STOP, PAUSE, EJECT, LOAD, FORWARD, BACK
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>cdPlayer</code> and <code>library</code> beans are used to drive the application.
The following listing shows the definition of these two beans:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public CdPlayer cdPlayer() {
	return new CdPlayer();
}

@Bean
public Library library() {
	return Library.buildSampleLibrary();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We define extended state variable keys as simple enumerations,
as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Variables {
	CD, TRACK, ELAPSEDTIME
}

public enum Headers {
	TRACKSHIFT
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We wanted to make this sample type safe, so we define our own
annotation (<code>@StatesOnTransition</code>), which has a mandatory meta
annotation (<code>@OnTransition</code>).
The following listing defines the <code>@StatesOnTransition</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@OnTransition
public @interface StatesOnTransition {

	States[] source() default {};

	States[] target() default {};

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ClosedEntryAction</code> is an entry action for the <code>CLOSED</code> state, to
send a <code>PLAY</code> event to the state machine if a disc is present.
The following listing defines <code>ClosedEntryAction</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class ClosedEntryAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		if (context.getTransition() != null
				&amp;&amp; context.getEvent() == Events.PLAY
				&amp;&amp; context.getTransition().getTarget().getId() == States.CLOSED
				&amp;&amp; context.getExtendedState().getVariables().get(Variables.CD) != null) {
			context.getStateMachine().sendEvent(Events.PLAY);
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>LoadAction</code> update an extended state variable if event
headers contain information about a disc to load.
The following listing defines <code>LoadAction</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class LoadAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		Object cd = context.getMessageHeader(Variables.CD);
		context.getExtendedState().getVariables().put(Variables.CD, cd);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>PlayAction</code> resets the player&#8217;s elapsed time, which is kept as
an extended state variable.
The following listing defines <code>PlayAction</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class PlayAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		context.getExtendedState().getVariables().put(Variables.ELAPSEDTIME, 0l);
		context.getExtendedState().getVariables().put(Variables.TRACK, 0);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>PlayGuard</code> guards the transition from <code>IDLE</code> to <code>BUSY</code> with the
<code>PLAY</code> event if the <code>CD</code> extended state variable does not indicate that a
disc has been loaded.
The following listing defines <code>PlayGuard</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class PlayGuard implements Guard&lt;States, Events&gt; {

	@Override
	public boolean evaluate(StateContext&lt;States, Events&gt; context) {
		ExtendedState extendedState = context.getExtendedState();
		return extendedState.getVariables().get(Variables.CD) != null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>PlayingAction</code> updates an extended state variable called <code>ELAPSEDTIME</code>, which
the player can use to read and update its LCD status display. <code>PlayingAction</code> also handles
track shifting when the user goe back or forward in tracks.
The following example defines <code>PlayingAction</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class PlayingAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
		Object elapsed = variables.get(Variables.ELAPSEDTIME);
		Object cd = variables.get(Variables.CD);
		Object track = variables.get(Variables.TRACK);
		if (elapsed instanceof Long) {
			long e = ((Long)elapsed) + 1000l;
			if (e &gt; ((Cd) cd).getTracks()[((Integer) track)].getLength()*1000) {
				context.getStateMachine().sendEvent(MessageBuilder
						.withPayload(Events.FORWARD)
						.setHeader(Headers.TRACKSHIFT.toString(), 1).build());
			} else {
				variables.put(Variables.ELAPSEDTIME, e);
			}
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>TrackAction</code> handles track shift actions when the user goes back or forward
in tracks. If a track is the last on a disc, playing is stopped and the <code>STOP</code>
event is sent to a state machine.
The following example defines <code>TrackAction</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class TrackAction implements Action&lt;States, Events&gt; {

	@Override
	public void execute(StateContext&lt;States, Events&gt; context) {
		Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
		Object trackshift = context.getMessageHeader(Headers.TRACKSHIFT.toString());
		Object track = variables.get(Variables.TRACK);
		Object cd = variables.get(Variables.CD);
		if (trackshift instanceof Integer &amp;&amp; track instanceof Integer &amp;&amp; cd instanceof Cd) {
			int next = ((Integer)track) + ((Integer)trackshift);
			if (next &gt;= 0 &amp;&amp;  ((Cd)cd).getTracks().length &gt; next) {
				variables.put(Variables.ELAPSEDTIME, 0l);
				variables.put(Variables.TRACK, next);
			} else if (((Cd)cd).getTracks().length &lt;= next) {
				context.getStateMachine().sendEvent(Events.STOP);
			}
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>One other important aspect of state machines is that they have their
own responsibilities (mostly around handling states) and that all application
level logic should be kept outside. This means that applications need
to have a ways to interact with a state machine. Also, note
that we annotated <code>CdPlayer</code> with <code>@WithStateMachine</code>, which instructs a
state machine to find methods from your POJO, which are then called
with various transitions.
The following example shows how it updates its LCD status display:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@OnTransition(target = "BUSY")
public void busy(ExtendedState extendedState) {
	Object cd = extendedState.getVariables().get(Variables.CD);
	if (cd != null) {
		cdStatus = ((Cd)cd).getName();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we use the <code>@OnTransition</code> annotation to hook a callback
when a transition happens with a target state of <code>BUSY</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows how our state machine handles whether the player is closed:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@StatesOnTransition(target = {States.CLOSED, States.IDLE})
public void closed(ExtendedState extendedState) {
	Object cd = extendedState.getVariables().get(Variables.CD);
	if (cd != null) {
		cdStatus = ((Cd)cd).getName();
	} else {
		cdStatus = "No CD";
	}
	trackStatus = "";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@OnTransition</code> (which we used in the preceding examples) can only be
used with strings that are matched from enumerations. <code>@StatesOnTransition</code>
lets you create your own type-safe annotations that use real enumerations.</p>
</div>
<div class="paragraph">
<p>The following example shows how this state machine actually works.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
Entry state IDLE
Entry state CLOSED
State machine started

sm&gt;cd lcd
No CD

sm&gt;cd library
0: Greatest Hits
  0: Bohemian Rhapsody  05:56
  1: Another One Bites the Dust  03:36
1: Greatest Hits II
  0: A Kind of Magic  04:22
  1: Under Pressure  04:08

sm&gt;cd eject
Exit state CLOSED
Entry state OPEN

sm&gt;cd load 0
Loading cd Greatest Hits

sm&gt;cd play
Exit state OPEN
Entry state CLOSED
Exit state CLOSED
Exit state IDLE
Entry state BUSY
Entry state PLAYING

sm&gt;cd lcd
Greatest Hits Bohemian Rhapsody 00:03

sm&gt;cd forward

sm&gt;cd lcd
Greatest Hits Another One Bites the Dust 00:04

sm&gt;cd stop
Exit state PLAYING
Exit state BUSY
Entry state IDLE
Entry state CLOSED

sm&gt;cd lcd
Greatest Hits</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding run:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The state machine is started, which causes the machine to be initialized.</p>
</li>
<li>
<p>The CD player&#8217;s LCD screen status is printed.</p>
</li>
<li>
<p>The CD library is printed.</p>
</li>
<li>
<p>The CD player&#8217;s deck is opened.</p>
</li>
<li>
<p>The CD with index 0 is loaded into a deck.</p>
</li>
<li>
<p>Play causes the deck to get closed and immediate play, because a disc
was inserted.</p>
</li>
<li>
<p>We print the LCD status and request the next track.</p>
</li>
<li>
<p>We stop playing.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-tasks"><a class="anchor" href="#statemachine-examples-tasks"></a>Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Tasks sample demonstrates parallel task handling within
regions and adds error handling to either
automatically or manually fix task problems before continuing back
to a state where the tasks can be run again.
The following image shows the Tasks state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart5.png" alt="statechart5" width="500">
</div>
</div>
<div class="paragraph">
<p>On a high level, in this state machine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We always try to get into the <code>READY</code> state so that we can use the
RUN event to execute tasks.</p>
</li>
<li>
<p>Tkhe <code>TASKS</code> state, which is composed of three independent regions, has been
put in the middle of <code>FORK</code> and <code>JOIN</code> states, which will cause the regions to
go into their initial states and to be joined by their end states.</p>
</li>
<li>
<p>From the <code>JOIN</code> state, we automatically go into a <code>CHOICE</code> state, which checks
for the existence of error flags in extended state variables. Tasks can set
these flags, and doing so gives the <code>CHOICE</code> state the ability to go into the <code>ERROR</code>
state, where errors can be handled either automatically or manually.</p>
</li>
<li>
<p>The <code>AUTOMATIC</code> state in <code>ERROR</code> can try to automatically fix an error and goes
back to <code>READY</code> if it succeeds. If the error is something what
cannot be handled automatically, user intervention is needed and the
machine is put into the <code>MANUAL</code> state by the <code>FALLBACK</code> event.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">States</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    READY,
    FORK, JOIN, CHOICE,
    TASKS, T1, T1E, T2, T2E, T3, T3E,
    ERROR, AUTOMATIC, MANUAL
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Events</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    RUN, FALLBACK, CONTINUE, FIX;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing configures the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - states</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
		throws Exception {
	states
		.withStates()
			.initial(States.READY)
			.fork(States.FORK)
			.state(States.TASKS)
			.join(States.JOIN)
			.choice(States.CHOICE)
			.state(States.ERROR)
			.and()
			.withStates()
				.parent(States.TASKS)
				.initial(States.T1)
				.end(States.T1E)
				.and()
			.withStates()
				.parent(States.TASKS)
				.initial(States.T2)
				.end(States.T2E)
				.and()
			.withStates()
				.parent(States.TASKS)
				.initial(States.T3)
				.end(States.T3E)
				.and()
			.withStates()
				.parent(States.ERROR)
				.initial(States.AUTOMATIC)
				.state(States.AUTOMATIC, automaticAction(), null)
				.state(States.MANUAL);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing configures the possible transitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - transitions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.READY).target(States.FORK)
			.event(Events.RUN)
			.and()
		.withFork()
			.source(States.FORK).target(States.TASKS)
			.and()
		.withExternal()
			.source(States.T1).target(States.T1E)
			.and()
		.withExternal()
			.source(States.T2).target(States.T2E)
			.and()
		.withExternal()
			.source(States.T3).target(States.T3E)
			.and()
		.withJoin()
			.source(States.TASKS).target(States.JOIN)
			.and()
		.withExternal()
			.source(States.JOIN).target(States.CHOICE)
			.and()
		.withChoice()
			.source(States.CHOICE)
			.first(States.ERROR, tasksChoiceGuard())
			.last(States.READY)
			.and()
		.withExternal()
			.source(States.ERROR).target(States.READY)
			.event(Events.CONTINUE)
			.and()
		.withExternal()
			.source(States.AUTOMATIC).target(States.MANUAL)
			.event(Events.FALLBACK)
			.and()
		.withInternal()
			.source(States.MANUAL)
			.action(fixAction())
			.event(Events.FIX);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following guard sends a choice entry into the <code>ERROR</code> state and needs to
return <code>TRUE</code> if an error has happened. This guard checks that
all extended state variables(<code>T1</code>, <code>T2</code>, and <code>T3</code>) are <code>TRUE</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public Guard&lt;States, Events&gt; tasksChoiceGuard() {
	return new Guard&lt;States, Events&gt;() {

		@Override
		public boolean evaluate(StateContext&lt;States, Events&gt; context) {
			Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
			return !(ObjectUtils.nullSafeEquals(variables.get("T1"), true)
					&amp;&amp; ObjectUtils.nullSafeEquals(variables.get("T2"), true)
					&amp;&amp; ObjectUtils.nullSafeEquals(variables.get("T3"), true));
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following actions below send events to the state machine to request
the next step, which is either to fall back or to continue back to ready.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public Action&lt;States, Events&gt; automaticAction() {
	return new Action&lt;States, Events&gt;() {

		@Override
		public void execute(StateContext&lt;States, Events&gt; context) {
			Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
			if (ObjectUtils.nullSafeEquals(variables.get("T1"), true)
					&amp;&amp; ObjectUtils.nullSafeEquals(variables.get("T2"), true)
					&amp;&amp; ObjectUtils.nullSafeEquals(variables.get("T3"), true)) {
				context.getStateMachine().sendEvent(Events.CONTINUE);
			} else {
				context.getStateMachine().sendEvent(Events.FALLBACK);
			}
		}
	};
}

@Bean
public Action&lt;States, Events&gt; fixAction() {
	return new Action&lt;States, Events&gt;() {

		@Override
		public void execute(StateContext&lt;States, Events&gt; context) {
			Map&lt;Object, Object&gt; variables = context.getExtendedState().getVariables();
			variables.put("T1", true);
			variables.put("T2", true);
			variables.put("T3", true);
			context.getStateMachine().sendEvent(Events.CONTINUE);
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Currently, the default region execution is synchronous, but you can change
it to be asynchronous by changing <code>TaskExecutor</code>. Task simulates
work by sleeping two seconds so that you can see how actions in
regions are executed inparallel.
The following listing shows the <code>TaskExecutor</code> bean definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean(name = StateMachineSystemConstants.TASK_EXECUTOR_BEAN_NAME)
public TaskExecutor taskExecutor() {
	ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
	taskExecutor.setCorePoolSize(5);
	return taskExecutor;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how this state machine actually works:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
State machine started
Entry state READY

sm&gt;tasks run
Entry state TASKS
run task on T3
run task on T2
run task on T1
run task on T2 done
run task on T1 done
run task on T3 done
Entry state T2
Entry state T3
Entry state T1
Entry state T1E
Entry state T2E
Entry state T3E
Exit state TASKS
Entry state JOIN
Exit state JOIN
Entry state READY</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding listing, we can see that tasks run multiple times.
In the next listing, we introduce errors:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;tasks list
Tasks {T1=true, T3=true, T2=true}

sm&gt;tasks fail T1

sm&gt;tasks list
Tasks {T1=false, T3=true, T2=true}

sm&gt;tasks run
Entry state TASKS
run task on T1
run task on T3
run task on T2
run task on T1 done
run task on T3 done
run task on T2 done
Entry state T1
Entry state T3
Entry state T2
Entry state T1E
Entry state T2E
Entry state T3E
Exit state TASKS
Entry state JOIN
Exit state JOIN
Entry state ERROR
Entry state AUTOMATIC
Exit state AUTOMATIC
Exit state ERROR
Entry state READY</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding listing, if we simulate a failure for task T1, it is fixed
automatically.
In the next listing, we introduce more errors:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;tasks list
Tasks {T1=true, T3=true, T2=true}

sm&gt;tasks fail T2

sm&gt;tasks run
Entry state TASKS
run task on T2
run task on T1
run task on T3
run task on T2 done
run task on T1 done
run task on T3 done
Entry state T2
Entry state T1
Entry state T3
Entry state T1E
Entry state T2E
Entry state T3E
Exit state TASKS
Entry state JOIN
Exit state JOIN
Entry state ERROR
Entry state AUTOMATIC
Exit state AUTOMATIC
Entry state MANUAL

sm&gt;tasks fix
Exit state MANUAL
Exit state ERROR
Entry state READY</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the precding example, if we simulate failure for either task <code>T2</code> or <code>T3</code>, the state
machine goes to the <code>MANUAL</code> state, where problem needs to be fixed manually
before it can go back to the <code>READY</code> state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-washer"><a class="anchor" href="#statemachine-examples-washer"></a>Washer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The washer sample demonstrates how to use a history state to recover a
running state configuration with a simulated power-off situation.</p>
</div>
<div class="paragraph">
<p>Anyone who has ever used a washing machine knows that if you somehow pause
the program, it continue from the same state when unpaused.
You can implement this kind of behavior in a state machine by using
a history pseudo state.
The following image shows our state machine for a washer:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart6.png" alt="statechart6" width="500">
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">States</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    RUNNING, HISTORY, END,
    WASHING, RINSING, DRYING,
    POWEROFF
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the enumeration that defines the events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Events</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    RINSE, DRY, STOP,
    RESTOREPOWER, CUTPOWER
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing configures the possible states:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - states</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
		throws Exception {
	states
		.withStates()
			.initial(States.RUNNING)
			.state(States.POWEROFF)
			.end(States.END)
			.and()
			.withStates()
				.parent(States.RUNNING)
				.initial(States.WASHING)
				.state(States.RINSING)
				.state(States.DRYING)
				.history(States.HISTORY, History.SHALLOW);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing configures the possible transitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Configuration - transitions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.WASHING).target(States.RINSING)
			.event(Events.RINSE)
			.and()
		.withExternal()
			.source(States.RINSING).target(States.DRYING)
			.event(Events.DRY)
			.and()
		.withExternal()
			.source(States.RUNNING).target(States.POWEROFF)
			.event(Events.CUTPOWER)
			.and()
		.withExternal()
			.source(States.POWEROFF).target(States.HISTORY)
			.event(Events.RESTOREPOWER)
			.and()
		.withExternal()
			.source(States.RUNNING).target(States.END)
			.event(Events.STOP);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how this state machine actually works:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
Entry state RUNNING
Entry state WASHING
State machine started

sm&gt;sm event RINSE
Exit state WASHING
Entry state RINSING
Event RINSE send

sm&gt;sm event DRY
Exit state RINSING
Entry state DRYING
Event DRY send

sm&gt;sm event CUTPOWER
Exit state DRYING
Exit state RUNNING
Entry state POWEROFF
Event CUTPOWER send

sm&gt;sm event RESTOREPOWER
Exit state POWEROFF
Entry state RUNNING
Entry state WASHING
Entry state DRYING
Event RESTOREPOWER send</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding run:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The state machine is started, which causes machine to get initialized.</p>
</li>
<li>
<p>The state machine goes to RINSING state.</p>
</li>
<li>
<p>The state machine goes to DRYING state.</p>
</li>
<li>
<p>The state machine cuts power and goes to POWEROFF state.</p>
</li>
<li>
<p>The state is restored from the HISTORY state, which takes state machine back
to its previous known state.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-persist"><a class="anchor" href="#statemachine-examples-persist"></a>Persist</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Persist is a sample that uses the <a href="#statemachine-recipes-persist">Persist</a> recipe to
demonstrate how database entry update logic can be controlled by a
state machine.</p>
</div>
<div class="paragraph">
<p>The following image shows the state machine logic and configuration:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart10.png" alt="statechart10" width="500">
</div>
</div>
<div class="paragraph">
<p>The following listing shows the state machine configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">StateMachine Config</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
static class StateMachineConfig
		extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("PLACED")
				.state("PROCESSING")
				.state("SENT")
				.state("DELIVERED");
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("PLACED").target("PROCESSING")
				.event("PROCESS")
				.and()
			.withExternal()
				.source("PROCESSING").target("SENT")
				.event("SEND")
				.and()
			.withExternal()
				.source("SENT").target("DELIVERED")
				.event("DELIVER");
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following configuration creates <code>PersistStateMachineHandler</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Handler Config</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
static class PersistHandlerConfig {

	@Autowired
	private StateMachine&lt;String, String&gt; stateMachine;

	@Bean
	public Persist persist() {
		return new Persist(persistStateMachineHandler());
	}

	@Bean
	public PersistStateMachineHandler persistStateMachineHandler() {
		return new PersistStateMachineHandler(stateMachine);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the <code>Order</code> class used with this sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Order Class</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class Order {
	int id;
	String state;

	public Order(int id, String state) {
		this.id = id;
		this.state = state;
	}

	@Override
	public String toString() {
		return "Order [id=" + id + ", state=" + state + "]";
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the state machine&#8217;s output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;persist db
Order [id=1, state=PLACED]
Order [id=2, state=PROCESSING]
Order [id=3, state=SENT]
Order [id=4, state=DELIVERED]

sm&gt;persist process 1
Exit state PLACED
Entry state PROCESSING

sm&gt;persist db
Order [id=2, state=PROCESSING]
Order [id=3, state=SENT]
Order [id=4, state=DELIVERED]
Order [id=1, state=PROCESSING]

sm&gt;persist deliver 3
Exit state SENT
Entry state DELIVERED

sm&gt;persist db
Order [id=2, state=PROCESSING]
Order [id=4, state=DELIVERED]
Order [id=1, state=PROCESSING]
Order [id=3, state=DELIVERED]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding run, the state machine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Listed rows from an existing embedded database, which is already
populated with sample data.</p>
</li>
<li>
<p>Requested to update order <code>1</code> into the <code>PROCESSING</code> state.</p>
</li>
<li>
<p>List database entries again and see that the state has been changed from
<code>PLACED</code> to <code>PROCESSING</code>.</p>
</li>
<li>
<p>Update order <code>3</code> to update its state from <code>SENT</code> to
<code>DELIVERED</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may wonder where the database is, because there are literally no
signs of it in the sample code. The sample is based on Spring Boot and,
because the necessary classes are in a classpath, an embedded <code>HSQL</code> instance
is created automatically.</p>
</div>
<div class="paragraph">
<p>Spring Boot even creates an instance of <code>JdbcTemplate</code>, which you
can autowire, as we did in <code>Persist.java</code>, shown in the following listing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private JdbcTemplate jdbcTemplate;</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we need to handle state changes. The following listing shows how we do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void change(int order, String event) {
	Order o = jdbcTemplate.queryForObject("select id, state from orders where id = ?", new Object[] { order },
			new RowMapper&lt;Order&gt;() {
				public Order mapRow(ResultSet rs, int rowNum) throws SQLException {
					return new Order(rs.getInt("id"), rs.getString("state"));
				}
			});
	handler.handleEventWithState(MessageBuilder.withPayload(event).setHeader("order", order).build(), o.state);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, we use a <code>PersistStateChangeListener</code> to update the database, as the
following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private class LocalPersistStateChangeListener implements PersistStateChangeListener {

	@Override
	public void onPersist(State&lt;String, String&gt; state, Message&lt;String&gt; message,
			Transition&lt;String, String&gt; transition, StateMachine&lt;String, String&gt; stateMachine) {
		if (message != null &amp;&amp; message.getHeaders().containsKey("order")) {
			Integer order = message.getHeaders().get("order", Integer.class);
			jdbcTemplate.update("update orders set state = ? where id = ?", state.getId(), order);
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-zookeeper"><a class="anchor" href="#statemachine-examples-zookeeper"></a>Zookeeper</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Zookeeper is a distributed version from the
<a href="#statemachine-examples-turnstile">Turnstile</a> sample.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This sample needs an external <code>Zookeeper</code> instance that is accessible from
<code>localhost</code> and has the default port and settings.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuration of this sample is almost the same as the <code>turnstile</code> sample. We
add only the configuration for the distributed state machine where we
configure <code>StateMachineEnsemble</code>, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config) throws Exception {
	config
		.withDistributed()
			.ensemble(stateMachineEnsemble());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The actual <code>StateMachineEnsemble</code> needs to be created as a bean, together
with the <code>CuratorFramework</code> client, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineEnsemble&lt;String, String&gt; stateMachineEnsemble() throws Exception {
	return new ZookeeperStateMachineEnsemble&lt;String, String&gt;(curatorClient(), "/foo");
}

@Bean
public CuratorFramework curatorClient() throws Exception {
	CuratorFramework client = CuratorFrameworkFactory.builder().defaultData(new byte[0])
			.retryPolicy(new ExponentialBackoffRetry(1000, 3))
			.connectString("localhost:2181").build();
	client.start();
	return client;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the next example, we need to create two different shell instances.
We need to create one instance, see what happens, and then create the second instance.
The following command starts the shell instances (remember to start only one instance for now):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">@n1:~# java -jar spring-statemachine-samples-zookeeper-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When state machine is started, its initial state is
<code>LOCKED</code>. Then it sends a <code>COIN</code> event to transition into <code>UNLOCKED</code> state.
The following example shows what happens:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Shell1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
Entry state LOCKED
State machine started

sm&gt;sm event COIN
Exit state LOCKED
Entry state UNLOCKED
Event COIN send

sm&gt;sm state
UNLOCKED</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now you can open a second shell instance and start a state machine,
by using the same command that you used to start the first state machine. You should see
that the distributed state (<code>UNLOCKED</code>) is entered instead of the default
initial state (<code>LOCKED</code>).</p>
</div>
<div class="paragraph">
<p>The following example shows the state machine and its output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Shell2</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm start
State machine started

sm&gt;sm state
UNLOCKED</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then from either shell (we use second instance in the next example), send a
<code>PUSH</code> event to transit from the <code>UNLOCKED</code> into the <code>LOCKED</code> state.
The following example shows the state machine command and its output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Shell2</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;sm event PUSH
Exit state UNLOCKED
Entry state LOCKED
Event PUSH send</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the other shell (the first shell if you ran the preceding command in the second shell),
you should see the state be changed automatically,
based on distributed state kept in Zookeeper.
The following example shows the state machine command and its output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Shell1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">sm&gt;Exit state UNLOCKED
Entry state LOCKED</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-web"><a class="anchor" href="#statemachine-examples-web"></a>Web</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Web is a distributed state machine example that uses a zookeeper state machine to handle
distributed state. See <a href="#statemachine-examples-zookeeper">Zookeeper</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This example is meant to be run on multiple
browser sessions against multiple different hosts.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This sample uses a modified state machine structure from
<a href="#statemachine-examples-showcase">Showcase</a> to work with a distributed state
machine. The following image shows the state machine logic:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart11.png" alt="statechart11" width="500">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Due to the nature of this sample, an instance of a <code>Zookeeper</code> state machine is expected to
be available from a localhost for every individual sample instance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This demonstration uses an example that starts three different sample instances.
If you run different instances on the same host, you need to
distinguish the port each one uses by adding <code>--server.port=&lt;myport&gt;</code> to the command.
Otherwise the default port for each host is <code>8080</code>.</p>
</div>
<div class="paragraph">
<p>In this sample run, we have three hosts: <code>n1</code>, <code>n2</code>, and <code>n3</code>. Each one
has a local zookeeper instance running and a state machine sample running
on a port <code>8080</code>.</p>
</div>
<div class="paragraph">
<p>In there different terminals, start the three different state machines by running
the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-web-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When all instances are running, you should see that all show similar
information when you access them with a browser. The states should be <code>S0</code>, <code>S1</code>, and <code>S11</code>.
The extended state variable named <code>foo</code> should have a value of <code>0</code>. The main state is <code>S11</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-dist-n1-1.png" alt="sm dist n1 1" width="500">
</div>
</div>
<div class="paragraph">
<p>When you press the <code>Event C</code> button in any of the browser windows, the
distributed state is changed to <code>S211,</code> which is the target state
denoted by the transition associated with an event of type <code>C</code>.
The following image shows the change:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-dist-n2-2.png" alt="sm dist n2 2" width="500">
</div>
</div>
<div class="paragraph">
<p>Now we can press the <code>Event H</code> button and see that the
internal transition runs on all state machines to change the
the value of the extended state variable named <code>foo</code> from <code>0</code> to <code>1</code>. This change is
first done on the state machine that receives the event and is then propagated
to the other state machines. You should see only the variable named <code>foo</code> change
from <code>0</code> to <code>1</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-dist-n3-3.png" alt="sm dist n3 3" width="500">
</div>
</div>
<div class="paragraph">
<p>Finally, we can send <code>Event K</code>, which takes the state
machine state back to state <code>S11</code>. You should see this happen in
all of the browsers. The following image shows the result in one browser:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-dist-n1-4.png" alt="sm dist n1 4" width="500">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-scope"><a class="anchor" href="#statemachine-examples-scope"></a>Scope</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scope is a state machine example that uses session scope to provide an
individual instance for every user.
The following image shows the states and events within the Scope state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart12.png" alt="statechart12" width="500">
</div>
</div>
<div class="paragraph">
<p>This simple state machine has three states: <code>S0</code>, <code>S1</code>, and <code>S2</code>.
Transitions between those are controlled by three events: <code>A</code>, <code>B</code>, and <code>C</code>.</p>
</div>
<div class="paragraph">
<p>To start the state machine, run the following command in a terminal:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-scope-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the instance is running, you can open a browser and play with the state
machine. If you open the same page in a different browser, (for example, one in
Chrome and one in Firefox), you should get a new state machine
instance for each user session.
The following image shows the state machine in a browser:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-scope-1.png" alt="sm scope 1" width="500">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-security"><a class="anchor" href="#statemachine-examples-security"></a>Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Security is a state machine example that uses most of the possible combinations of
securing a state machine. It secures sending events, transitions,
and actions.
The following image shows the state machine&#8217;s states and events:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart13.png" alt="statechart13" width="500">
</div>
</div>
<div class="paragraph">
<p>To start the state machine, run the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-secure-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We secure event sending by requiring that users have a role of <code>USER</code>.
Spring Security ensures that no other users can send events to this
state machine.
The following listing secures event sending:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
		throws Exception {
	config
		.withConfiguration()
			.autoStartup(true)
			.and()
		.withSecurity()
			.enabled(true)
			.event("hasRole('USER')");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this sample we define two users:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A user named <code>user</code> who has a role of <code>USER</code></p>
</li>
<li>
<p>A user named <code>admin</code> who has two roles: <code>USER</code> and <code>ADMIN</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The password for both users is <code>password</code>.
The following listing configures the two users:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled = true)
static class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.inMemoryAuthentication()
				.withUser("user")
					.password("password")
					.roles("USER")
					.and()
				.withUser("admin")
					.password("password")
					.roles("USER", "ADMIN");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We define various transitions between states according to the state chart
shown at the beginning of the example. Only a user with an active <code>ADMIN</code> role can run
the external transitions between <code>S2</code> and <code>S3</code>. Similarly only an <code>ADMIN</code> can
run the internal transition the <code>S1</code> state.
The following listing defines the transitions, including their security:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
		throws Exception {
	transitions
		.withExternal()
			.source(States.S0).target(States.S1).event(Events.A)
			.and()
		.withExternal()
			.source(States.S1).target(States.S2).event(Events.B)
			.and()
		.withExternal()
			.source(States.S2).target(States.S0).event(Events.C)
			.and()
		.withExternal()
			.source(States.S2).target(States.S3).event(Events.E)
			.secured("ROLE_ADMIN", ComparisonType.ANY)
			.and()
		.withExternal()
			.source(States.S3).target(States.S0).event(Events.C)
			.and()
		.withInternal()
			.source(States.S0).event(Events.D)
			.action(adminAction())
			.and()
		.withInternal()
			.source(States.S1).event(Events.F)
			.action(transitionAction())
			.secured("ROLE_ADMIN", ComparisonType.ANY);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing uses a method called <code>adminAction</code> whose return type is <code>Action</code> to
specify that the action is secured with a role of <code>ADMIN</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)
@Bean
public Action&lt;States, Events&gt; adminAction() {
	return new Action&lt;States, Events&gt;() {

		@Secured("ROLE_ADMIN")
		@Override
		public void execute(StateContext&lt;States, Events&gt; context) {
			log.info("Executed only for admin role");
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following <code>Action</code> runs an internal transition in state <code>S</code> when event <code>F</code> is sent.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public Action&lt;States, Events&gt; transitionAction() {
	return new Action&lt;States, Events&gt;() {

		@Override
		public void execute(StateContext&lt;States, Events&gt; context) {
			log.info("Executed only for admin role");
		}
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The transition itself is secured with a
role of <code>ADMIN</code>, so this transition does not run if the current user
does not hate that role.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-eventservice"><a class="anchor" href="#statemachine-examples-eventservice"></a>Event Service</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The event service example shows how you can use state machine concepts as
a processing engine for events. This sample evolved from a question:</p>
</div>
<div class="paragraph">
<p>Can I use Spring Statemachine as a microservice to feed events to
different state machine instances? In fact, Spring Statemachine can feed
events to potentially millions of different state machine instances.</p>
</div>
<div class="paragraph">
<p>This example uses a <code>Redis</code> instance to persist state machine
instances.</p>
</div>
<div class="paragraph">
<p>Obviously, a million state machine instances in a JVM would be
a bad idea, due to memory constraints. This leads to
other features of Spring Statemachine that let you persist a
<code>StateMachineContext</code> and re-use existing instances.</p>
</div>
<div class="paragraph">
<p>For this example, we assume that a shopping application
sends different types of <code>PageView</code> events to a separate
microservice which then tracks user behavior by using a state
machine. The following image shows the state model, which has a few states
that represent a user navigating a product items list, adding and removing
items from a cart, going to a payment page, and initiating a payment
operation:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart14.png" alt="statechart14" width="500">
</div>
</div>
<div class="paragraph">
<p>An actual shopping application would send these events into
this service by (for example) using a rest call. More about this
later.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that the focus here is to have an application that exposes a
<code>REST</code> API that the user can use to send events that can be processed by a
state machine for each request.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following state machine configuration models what we have in a
state chart. Various actions update the state machine&#8217;s <code>Extended
State</code> to track the number of entries into various states and also how
many times the internal transitions for <code>ADD</code> and <code>DEL</code> are called and whether
<code>PAY</code> has been executed:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean(name = "stateMachineTarget")
@Scope(scopeName="prototype")
public StateMachine&lt;States, Events&gt; stateMachineTarget() throws Exception {
	Builder&lt;States, Events&gt; builder = StateMachineBuilder.&lt;States, Events&gt;builder();

	builder.configureConfiguration()
		.withConfiguration()
			.autoStartup(true);

	builder.configureStates()
		.withStates()
			.initial(States.HOME)
			.states(EnumSet.allOf(States.class));

	builder.configureTransitions()
		.withInternal()
			.source(States.ITEMS).event(Events.ADD)
			.action(addAction())
			.and()
		.withInternal()
			.source(States.CART).event(Events.DEL)
			.action(delAction())
			.and()
		.withInternal()
			.source(States.PAYMENT).event(Events.PAY)
			.action(payAction())
			.and()
		.withExternal()
			.source(States.HOME).target(States.ITEMS)
			.action(pageviewAction())
			.event(Events.VIEW_I)
			.and()
		.withExternal()
			.source(States.CART).target(States.ITEMS)
			.action(pageviewAction())
			.event(Events.VIEW_I)
			.and()
		.withExternal()
			.source(States.ITEMS).target(States.CART)
			.action(pageviewAction())
			.event(Events.VIEW_C)
			.and()
		.withExternal()
			.source(States.PAYMENT).target(States.CART)
			.action(pageviewAction())
			.event(Events.VIEW_C)
			.and()
		.withExternal()
			.source(States.CART).target(States.PAYMENT)
			.action(pageviewAction())
			.event(Events.VIEW_P)
			.and()
		.withExternal()
			.source(States.ITEMS).target(States.HOME)
			.action(resetAction())
			.event(Events.RESET)
			.and()
		.withExternal()
			.source(States.CART).target(States.HOME)
			.action(resetAction())
			.event(Events.RESET)
			.and()
		.withExternal()
			.source(States.PAYMENT).target(States.HOME)
			.action(resetAction())
			.event(Events.RESET);

	return builder.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Do not focus on <code>stateMachineTarget</code> or
<code>@Scope</code> for now, as we explain those later in this section.</p>
</div>
<div class="paragraph">
<p>We set up a <code>RedisConnectionFactory</code> that defaults to
localhost and default port. We use <code>StateMachinePersist</code> with a
<code>RepositoryStateMachinePersist</code> implementation. Finally, we create a
<code>RedisStateMachinePersister</code> that uses a previously
created <code>StateMachinePersist</code> bean.</p>
</div>
<div class="paragraph">
<p>These are then used in a <code>Controller</code> that handles <code>REST</code> calls,
as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public RedisConnectionFactory redisConnectionFactory() {
	return new JedisConnectionFactory();
}

@Bean
public StateMachinePersist&lt;States, Events, String&gt; stateMachinePersist(RedisConnectionFactory connectionFactory) {
	RedisStateMachineContextRepository&lt;States, Events&gt; repository =
			new RedisStateMachineContextRepository&lt;States, Events&gt;(connectionFactory);
	return new RepositoryStateMachinePersist&lt;States, Events&gt;(repository);
}

@Bean
public RedisStateMachinePersister&lt;States, Events&gt; redisStateMachinePersister(
		StateMachinePersist&lt;States, Events, String&gt; stateMachinePersist) {
	return new RedisStateMachinePersister&lt;States, Events&gt;(stateMachinePersist);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We create a bean named <code>stateMachineTarget</code>.
State machine instantiation is a relatively
expensive operation, so it is better to try to pool instances instead
of instantiating a new instance for every request. To do so, we first
create a <code>poolTargetSource</code> that wraps <code>stateMachineTarget</code> and pools
it with a max size of three. When then proxy this  <code>poolTargetSource</code> with
<code>ProxyFactoryBean</code> by using a <code>request</code> scope. Effectively, this means
that every <code>REST</code> request gets a pooled state machine instance from
a bean factory. Later, we show how these instances are used.
The following listing shows how we create the <code>ProxyFactoryBean</code>
and set the target source:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public ProxyFactoryBean stateMachine() {
	ProxyFactoryBean pfb = new ProxyFactoryBean();
	pfb.setTargetSource(poolTargetSource());
	return pfb;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows we set the maximum size and set the target bean name:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public CommonsPool2TargetSource poolTargetSource() {
	CommonsPool2TargetSource pool = new CommonsPool2TargetSource();
	pool.setMaxSize(3);
	pool.setTargetBeanName("stateMachineTarget");
	return pool;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can get into actual demo. You need to have a Redis server running on
localhost with default settings. Then you need to run the Boot-based sample
application by running the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-eventservice-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In a browser, you see something like the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-eventservice-1.png" alt="sm eventservice 1" width="500">
</div>
</div>
<div class="paragraph">
<p>In this UI, you can use three users: <code>joe</code>, <code>bob</code>, and <code>dave</code>.
Clicking a button shows the current state and the extended state. Enabling a
radio button before clicking a button sends a particular event for that
user. This arrangement lets you play with the UI.</p>
</div>
<div class="paragraph">
<p>In our <code>StateMachineController</code>, we autowire <code>StateMachine</code> and
<code>StateMachinePersister</code>. <code>StateMachine</code> is <code>request</code> scoped, so you
get a new instance for each request, while <code>StateMachinePersist</code> is a normal
singleton bean.
The following listing autowires <code>StateMachine</code> and
<code>StateMachinePersist</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private StateMachine&lt;States, Events&gt; stateMachine;

@Autowired
private StateMachinePersister&lt;States, Events, String&gt; stateMachinePersister;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following listing, <code>feedAndGetState</code> is used with a UI to do same things that an
actual <code>REST</code> api might do:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/state")
public String feedAndGetState(@RequestParam(value = "user", required = false) String user,
		@RequestParam(value = "id", required = false) Events id, Model model) throws Exception {
	model.addAttribute("user", user);
	model.addAttribute("allTypes", Events.values());
	model.addAttribute("stateChartModel", stateChartModel);
	// we may get into this page without a user so
	// do nothing with a state machine
	if (StringUtils.hasText(user)) {
		resetStateMachineFromStore(user);
		if (id != null) {
			feedMachine(user, id);
		}
		model.addAttribute("states", stateMachine.getState().getIds());
		model.addAttribute("extendedState", stateMachine.getExtendedState().getVariables());
	}
	return "states";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following listing, <code>feedPageview</code> is a <code>REST</code> method that accepts a post with
JSON content.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping(value = "/feed",method= RequestMethod.POST)
@ResponseStatus(HttpStatus.OK)
public void feedPageview(@RequestBody(required = true) Pageview event) throws Exception {
	Assert.notNull(event.getUser(), "User must be set");
	Assert.notNull(event.getId(), "Id must be set");
	resetStateMachineFromStore(event.getUser());
	feedMachine(event.getUser(), event.getId());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following listing, <code>feedMachine</code> sends an event into a <code>StateMachine</code> and persists
its state by using a <code>StateMachinePersister</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private void feedMachine(String user, Events id) throws Exception {
	stateMachine.sendEvent(id);
	stateMachinePersister.persist(stateMachine, "testprefix:" + user);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows a <code>resetStateMachineFromStore</code> that is used to restore a state machine
for a particular user:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private StateMachine&lt;States, Events&gt; resetStateMachineFromStore(String user) throws Exception {
	return stateMachinePersister.restore(stateMachine, "testprefix:" + user);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you would usually send an event by using a UI, you can do the same by using <code>REST</code> calls,
as the following curl command shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># curl http://localhost:8080/feed -H "Content-Type: application/json" --data '{"user":"joe","id":"VIEW_I"}'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>At this point, you should have content in Redis with a key of
<code>testprefix:joe</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text">$ ./redis-cli
127.0.0.1:6379&gt; KEYS *
1) "testprefix:joe"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The next three images show when state for <code>joe</code> has been changed from
<code>HOME</code> to <code>ITEMS</code> and when the <code>ADD</code> action has been executed.</p>
</div>
<div class="paragraph">
<p>The following image the <code>ADD</code> event being sent:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-eventservice-2.png" alt="sm eventservice 2" width="500">
</div>
</div>
<div class="paragraph">
<p>Now your are still on the <code>ITEMS</code> state, and the internal transition caused
the <code>COUNT</code> extended state variable to increase to <code>1</code>, as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-eventservice-3.png" alt="sm eventservice 3" width="500">
</div>
</div>
<div class="paragraph">
<p>Now you can run the following <code>curl</code> rest call a few times (or do it through the UI) and
see the <code>COUNT</code> variable increase with every call:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># curl http://localhost:8080/feed -H "Content-Type: application/json" # --data '{"user":"joe","id":"ADD"}'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows the result of these operations:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-eventservice-4.png" alt="sm eventservice 4" width="500">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-deploy"><a class="anchor" href="#statemachine-examples-deploy"></a>Deploy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The deploy example shows how you can use state machine concepts with
UML modeling to provide a generic error handling state. This state
machine is a relatively complex example of how you can use various features
to provide a centralized error handling concept.
The following image shows the deploy state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-deployer.png" alt="model deployer" width="500">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding state chart was designed by using the Eclipse Papyrus Plugin
(see<a href="#sm-papyrus">Eclipse Modeling Support</a>) and imported into Spring StateMachine through the resulting UML
model file. Actions and guards defined in a model are resolved
from a Spring Application Context.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this state machine scenario, we have two different behaviors
(<code>DEPLOY</code> and <code>UNDEPLOY</code>) that user tries to execute.</p>
</div>
<div class="paragraph">
<p>In the preceding state chart:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the <code>DEPLOY</code> state, the <code>INSTALL</code> and <code>START</code> states are entered
conditionally. We enter <code>START</code> directly if a product is already
installed and have no need to try to <code>START</code> if install fails.</p>
</li>
<li>
<p>In the <code>UNDEPLOY</code> state, we enter <code>STOP</code> conditionally if the application is
already running.</p>
</li>
<li>
<p>Conditional choices for <code>DEPLOY</code> and <code>UNDEPLOY</code> are done through a
choice pseudostate within those states, and the choices are selected
by guards.</p>
</li>
<li>
<p>We use exit point pseudostates to have a more controlled exit from the
<code>DEPLOY</code> and <code>UNDEPLOY</code> states.</p>
</li>
<li>
<p>After exiting from <code>DEPLOY</code> and <code>UNDEPLOY</code>, we go through a junction
pseudostate to choose whether to go through an <code>ERROR</code> state
(if an error was added into an extended state).</p>
</li>
<li>
<p>Finally, we go back to the <code>READY</code> state to process new requests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now we can get to the actual demo. Run the boot based sample application
by running the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-deploy-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In a browser, you can see something like the following image:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-deploy-1.png" alt="sm deploy 1" width="500">
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As we do not have real install, start, or stop functionality, we
simulate failures by checking the existence of particular message headers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now you can start to send events to a machine and choose various
message headers to drive functionality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-ordershipping"><a class="anchor" href="#statemachine-examples-ordershipping"></a>Order Shipping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The order shipping example shows how you can use state machine concepts
to build a simple order processing system.</p>
</div>
<div class="paragraph">
<p>The following image shows a state chart that drives this order shipping sample.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-ordershipping-1.png" alt="sm ordershipping 1">
</div>
</div>
<div class="paragraph">
<p>In the preceding state chart:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The state machine enters the <code>WAIT_NEW_ORDER</code> (default) state.</p>
</li>
<li>
<p>The event <code>PLACE_ORDER</code> transitions into the <code>RECEIVE_ORDER</code> state and the entry
action (<code>entryReceiveOrder</code>) is executed.</p>
</li>
<li>
<p>If the order is <code>OK</code>, the state machine goes into two regions, one handling order
production and one handling user-level payment. Otherwise, the state machine goes
into <code>CUSTOMER_ERROR</code>, which is a final state.</p>
</li>
<li>
<p>The state machine loops in a lower region to remind the user to pay
until <code>RECEIVE_PAYMENT</code> is sent successfully to indicate correct
payment.</p>
</li>
<li>
<p>Both regions go into waiting states (<code>WAIT_PRODUCT</code> and
<code>WAIT_ORDER</code>), where they are joined before the parent orthogonal state
(<code>HANDLE_ORDER</code>) is exited.</p>
</li>
<li>
<p>Finally, the state machine goes through <code>SHIP_ORDER</code> to its final state
(<code>ORDER_SHIPPED</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following command runs the sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-ordershipping-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In a browser, you can see something similar to the following image. You can start by choosing
a customer and an order to create a state machine.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-ordershipping-2.png" alt="sm ordershipping 2">
</div>
</div>
<div class="paragraph">
<p>The state machine for a particular order is now created and you can start to play
with placing an order and sending a payment. Other settings (such as
<code>makeProdPlan</code>, <code>produce</code>, and <code>payment</code>) let you control how the state
machine works.
The following image shows the state machine waiting for an order:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-ordershipping-3.png" alt="sm ordershipping 3">
</div>
</div>
<div class="paragraph">
<p>Finally, you can see what machine does by refreshing a page, as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-ordershipping-4.png" alt="sm ordershipping 4">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-datajpa"><a class="anchor" href="#statemachine-examples-datajpa"></a>JPA Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JPA configuration example shows how you can use state machine concepts
with a machine configuration kept in a database. This sample uses
an embedded H2 database with an H2 Console (to ease playing with the
database).</p>
</div>
<div class="paragraph">
<p>This sample uses <code>spring-statemachine-autoconfigure</code> (which, by default,
auto-configures the repositories and entity classes needed for JPA).
Thus, you need only <code>@SpringBootApplication</code>.
The following example shows the <code>Application</code> class with the <code>@SpringBootApplication</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to create a <code>RepositoryStateMachineModelFactory</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachineFactory
public static class Config extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Autowired
	private StateRepository&lt;? extends RepositoryState&gt; stateRepository;

	@Autowired
	private TransitionRepository&lt;? extends RepositoryTransition&gt; transitionRepository;

	@Override
	public void configure(StateMachineModelConfigurer&lt;String, String&gt; model) throws Exception {
		model
			.withModel()
				.factory(modelFactory());
	}

	@Bean
	public StateMachineModelFactory&lt;String, String&gt; modelFactory() {
		return new RepositoryStateMachineModelFactory(stateRepository, transitionRepository);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the following command to run the sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-datajpa-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Accessing the application at <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> brings up a newly
constructed machine for each request. You can then choose to send
events to a machine. The possible events and machine configuration are
updated from a database with every request.
The following image shows the UI and the initial events that are created when
this state machine starts:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpa-1.png" alt="sm datajpa 1">
</div>
</div>
<div class="paragraph">
<p>To access the embedded console, you can use the JDBC URL (which is <code>jdbc:h2:mem:testdb</code>, if it is
not already set).
The following image shows the H2 console:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpa-2.png" alt="sm datajpa 2">
</div>
</div>
<div class="paragraph">
<p>From the console, you can see the database tables and modify
them as you wish.
The following image shows the result of a simple query in the UI:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpa-3.png" alt="sm datajpa 3">
</div>
</div>
<div class="paragraph">
<p>Now that you have gotten this far, you have probably wondered how those default
states and transitions got populated into the database. Spring Data
has a nice trick to auto-populate repositories, and we
used this feature through <code>Jackson2RepositoryPopulatorFactoryBean</code>.
The following example shows how we create such a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineJackson2RepositoryPopulatorFactoryBean jackson2RepositoryPopulatorFactoryBean() {
	StateMachineJackson2RepositoryPopulatorFactoryBean factoryBean = new StateMachineJackson2RepositoryPopulatorFactoryBean();
	factoryBean.setResources(new Resource[]{new ClassPathResource("data.json")});
	return factoryBean;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the source of the data with which we populate the database:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json">[
	{
		"@id": "10",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryAction",
		"spel": "T(System).out.println('hello exit S1')"
	},
	{
		"@id": "11",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryAction",
		"spel": "T(System).out.println('hello entry S2')"
	},
	{
		"@id": "12",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryAction",
		"spel": "T(System).out.println('hello state S3')"
	},
	{
		"@id": "13",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryAction",
		"spel": "T(System).out.println('hello')"
	},
	{
		"@id": "1",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryState",
		"initial": true,
		"state": "S1",
		"exitActions": ["10"]
	},
	{
		"@id": "2",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryState",
		"initial": false,
		"state": "S2",
		"entryActions": ["11"]
	},
	{
		"@id": "3",
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryState",
		"initial": false,
		"state": "S3",
		"stateActions": ["12"]
	},
	{
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryTransition",
		"source": "1",
		"target": "2",
		"event": "E1",
		"kind": "EXTERNAL"
	},
	{
		"_class": "org.springframework.statemachine.data.jpa.JpaRepositoryTransition",
		"source": "2",
		"target": "3",
		"event": "E2",
		"actions": ["13"]
	}
]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-datapersist"><a class="anchor" href="#statemachine-examples-datapersist"></a>Data Persist</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The data persist sample shows how you can state machine concepts
with a persisting machine in an external repository. This sample uses
an embedded H2 database with an H2 Console (to ease playing with the
database). Optionally, you can also enable Redis or MongoDB.</p>
</div>
<div class="paragraph">
<p>This sample uses <code>spring-statemachine-autoconfigure</code> (which, by default,
auto-configures the repositories and entity classes needed for JPA).
Thus, you need only <code>@SpringBootApplication</code>.
The following example shows the <code>Application</code> class with the <code>@SpringBootApplication</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>StateMachineRuntimePersister</code> interface works on the runtime
level of a <code>StateMachine</code>. Its implementation,
<code>JpaPersistingStateMachineInterceptor</code>, is meant to be used with a
JPA.
The following listing creates a <code>StateMachineRuntimePersister</code> bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("jpa")
public static class JpaPersisterConfig {

	@Bean
	public StateMachineRuntimePersister&lt;States, Events, String&gt; stateMachineRuntimePersister(
			JpaStateMachineRepository jpaStateMachineRepository) {
		return new JpaPersistingStateMachineInterceptor&lt;&gt;(jpaStateMachineRepository);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how you can use a very similar configuration
to create a bean for MongoDB:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("mongo")
public static class MongoPersisterConfig {

	@Bean
	public StateMachineRuntimePersister&lt;States, Events, String&gt; stateMachineRuntimePersister(
			MongoDbStateMachineRepository jpaStateMachineRepository) {
		return new MongoDbPersistingStateMachineInterceptor&lt;&gt;(jpaStateMachineRepository);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how you can use a very similar configuration
to create a bean for Redis:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("redis")
public static class RedisPersisterConfig {

	@Bean
	public StateMachineRuntimePersister&lt;States, Events, String&gt; stateMachineRuntimePersister(
			RedisStateMachineRepository jpaStateMachineRepository) {
		return new RedisPersistingStateMachineInterceptor&lt;&gt;(jpaStateMachineRepository);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can configure <code>StateMachine</code> to use runtime persistence by using the
<code>withPersistence</code> configuration method.
The following listing shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private StateMachineRuntimePersister&lt;States, Events, String&gt; stateMachineRuntimePersister;

@Override
public void configure(StateMachineConfigurationConfigurer&lt;States, Events&gt; config)
		throws Exception {
	config
		.withPersistence()
			.runtimePersister(stateMachineRuntimePersister);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This sample also uses <code>DefaultStateMachineService</code>, which makes it
easier to work with multiple machines.
The following listing shows how to create an instance of <code>DefaultStateMachineService</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineService&lt;States, Events&gt; stateMachineService(
		StateMachineFactory&lt;States, Events&gt; stateMachineFactory,
		StateMachineRuntimePersister&lt;States, Events, String&gt; stateMachineRuntimePersister) {
	return new DefaultStateMachineService&lt;States, Events&gt;(stateMachineFactory, stateMachineRuntimePersister);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the logic that drives the <code>StateMachineService</code> in this sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private synchronized StateMachine&lt;States, Events&gt; getStateMachine(String machineId) throws Exception {
	listener.resetMessages();
	if (currentStateMachine == null) {
		currentStateMachine = stateMachineService.acquireStateMachine(machineId);
		currentStateMachine.addStateListener(listener);
		currentStateMachine.start();
	} else if (!ObjectUtils.nullSafeEquals(currentStateMachine.getId(), machineId)) {
		stateMachineService.releaseStateMachine(currentStateMachine.getId());
		currentStateMachine.stop();
		currentStateMachine = stateMachineService.acquireStateMachine(machineId);
		currentStateMachine.addStateListener(listener);
		currentStateMachine.start();
	}
	return currentStateMachine;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the following command to run the sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-datapersist-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the <code>jpa</code> profile is enabled in <code>application.yml</code>. If you want to try
other backends, enable either the <code>mongo</code> profile or the <code>redis</code> profile.
The following commands specify which profile to use (<code>jpa</code> is the default,
but we included it for the sake of completeness):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-datapersist-{revnumber}.jar --spring.profiles.active=jpa
# java -jar spring-statemachine-samples-datapersist-{revnumber}.jar --spring.profiles.active=mongo
# java -jar spring-statemachine-samples-datapersist-{revnumber}.jar --spring.profiles.active=redis</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Accessing the application at <a href="http://localhost:8080" class="bare">http://localhost:8080</a> brings up a newly
constructed state machine for each request, and you can choose to send
events to a machine. The possible events and machine configuration are
updated from a database with every request.</p>
</div>
<div class="paragraph">
<p>The state machines in this sample have a simple configuration with states 'S1'
to 'S6' and events 'E1' to 'E6' to transition the state machine between those
states. You can use two state machine identifiers (<code>datajpapersist1</code> and
<code>datajpapersist2</code>) to request a particular state machine.
The following image shows the UI that lets you pick a machine and an event and that shows
what happens when you do:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpapersist-1.png" alt="sm datajpapersist 1">
</div>
</div>
<div class="paragraph">
<p>The sample defaults to using machine 'datajpapersist1' and goes to its
initial state 'S1'.
The following image shows the result of using those defaults:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpapersist-2.png" alt="sm datajpapersist 2">
</div>
</div>
<div class="paragraph">
<p>If you send events <code>E1</code> and <code>E2</code> to the <code>datajpapersist1</code> state machine, its
state is persisted as 'S3'.
The following image shows the result of doing so:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpapersist-3.png" alt="sm datajpapersist 3">
</div>
</div>
<div class="paragraph">
<p>If you then request state machine <code>datajpapersist1</code> but send no events,
the state machine is restored back to its persisted state, <code>S3</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-datajpamultipersist"><a class="anchor" href="#statemachine-examples-datajpamultipersist"></a>Data Multi Persist</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The data multi ersist sample is an extension of two other samples:
<a href="#statemachine-examples-datajpa">JPA Configuration</a> and <a href="#statemachine-examples-datapersist">Data Persist</a>.
We still keep machine configuration in a database and persist into a
database. However, this time, we also have a machine that contains two orthogonal
regions, to show how those are persisted independently. This sample
also uses an embedded H2 database with an H2 Console (to ease playing
with the database).</p>
</div>
<div class="paragraph">
<p>This sample uses <code>spring-statemachine-autoconfigure</code> (which, by default,
auto-configures the repositories and entity classes needed for JPA).
Thus, you need only <code>@SpringBootApplication</code>.
The following example shows the <code>Application</code> class with the <code>@SpringBootApplication</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As in the other data-driven samples, we again create a <code>StateMachineRuntimePersister</code>,
as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineRuntimePersister&lt;String, String, String&gt; stateMachineRuntimePersister(
		JpaStateMachineRepository jpaStateMachineRepository) {
	return new JpaPersistingStateMachineInterceptor&lt;&gt;(jpaStateMachineRepository);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A <code>StateMachineService</code> bean makes it easier to work with a machines.
The following listing shows how to create such a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineService&lt;String, String&gt; stateMachineService(
		StateMachineFactory&lt;String, String&gt; stateMachineFactory,
		StateMachineRuntimePersister&lt;String, String, String&gt; stateMachineRuntimePersister) {
	return new DefaultStateMachineService&lt;String, String&gt;(stateMachineFactory, stateMachineRuntimePersister);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We use JSON data to import the configuration.
The following example creates a bean to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public StateMachineJackson2RepositoryPopulatorFactoryBean jackson2RepositoryPopulatorFactoryBean() {
	StateMachineJackson2RepositoryPopulatorFactoryBean factoryBean = new StateMachineJackson2RepositoryPopulatorFactoryBean();
	factoryBean.setResources(new Resource[] { new ClassPathResource("datajpamultipersist.json") });
	return factoryBean;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows how we get a <code>RepositoryStateMachineModelFactory</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachineFactory
public static class Config extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Autowired
	private StateRepository&lt;? extends RepositoryState&gt; stateRepository;

	@Autowired
	private TransitionRepository&lt;? extends RepositoryTransition&gt; transitionRepository;

	@Autowired
	private StateMachineRuntimePersister&lt;String, String, String&gt; stateMachineRuntimePersister;

	@Override
	public void configure(StateMachineConfigurationConfigurer&lt;String, String&gt; config)
			throws Exception {
		config
			.withPersistence()
				.runtimePersister(stateMachineRuntimePersister);
	}

	@Override
	public void configure(StateMachineModelConfigurer&lt;String, String&gt; model)
			throws Exception {
		model
			.withModel()
				.factory(modelFactory());
	}

	@Bean
	public StateMachineModelFactory&lt;String, String&gt; modelFactory() {
		return new RepositoryStateMachineModelFactory(stateRepository, transitionRepository);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can run the sample by using the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-datajpamultipersist-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Accessing the application at <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> brings up a newly
constructed machine for each request and lets you send
events to a machine. The possible events and the state machine configuration are
updated from a database for each request. We also print out
all state machine contexts and the current root machine,
as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpamultipersist-1.png" alt="sm datajpamultipersist 1">
</div>
</div>
<div class="paragraph">
<p>The state machine named <code>datajpamultipersist1</code> is a simple &#8220;flat&#8221; machine where states <code>S1</code>,
<code>S2</code> and <code>S3</code> are transitioned by events <code>E1</code>, <code>E2</code>, and <code>E3</code> (respectively).
However, the state machine named <code>datajpamultipersist2</code> contains two
regions (<code>R1</code> and <code>R2</code>) directly under the root level. That is why this
root level machine really does not have a state. We need
that root level machine to host those regions.</p>
</div>
<div class="paragraph">
<p>Regions <code>R1</code> and <code>R2</code> in the <code>datajpamultipersist2</code> state machine contains states
<code>S10</code>, <code>S11</code>, and <code>S12</code> and <code>S20</code>, <code>S21</code>, and <code>S22</code> (respectively). Events
<code>E10</code>, <code>E11</code>, and <code>E12</code> are used for region <code>R1</code> and events <code>E20</code>, <code>E21</code>,
and event <code>E22</code> is used for region <code>R2</code>. The following images shows what happens when we
send events <code>E10</code> and <code>E20</code> to the
<code>datajpamultipersist2</code> state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpamultipersist-2.png" alt="sm datajpamultipersist 2">
</div>
</div>
<div class="paragraph">
<p>Regions have their own contexts with their own IDs, and the actual
ID is postfixed with <code>#</code> and the region ID. As the following image shows,
different regions in a database have different contexts:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-datajpamultipersist-3.png" alt="sm datajpamultipersist 3">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statemachine-examples-monitoring"><a class="anchor" href="#statemachine-examples-monitoring"></a>Monitoring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The monitoring sample shows how you can use state machine concepts to
monitor state machine transitions and actions.
The following listing configures the state machine that we use for this sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public static class Config extends StateMachineConfigurerAdapter&lt;String, String&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;String, String&gt; states)
			throws Exception {
		states
			.withStates()
				.initial("S1")
				.state("S2", null, (c) -&gt; {System.out.println("hello");})
				.state("S3", (c) -&gt; {System.out.println("hello");}, null);
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;String, String&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source("S1").target("S2").event("E1")
				.action((c) -&gt; {System.out.println("hello");})
				.and()
			.withExternal()
				.source("S2").target("S3").event("E2");
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the following command to run the sample:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text" data-lang="text"># java -jar spring-statemachine-samples-monitoring-{revnumber}.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows the state machine&#8217;s initial state:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-monitoring-1.png" alt="sm monitoring 1">
</div>
</div>
<div class="paragraph">
<p>The following image shows the state of the state machine after we have
performed some actions:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-monitoring-2.png" alt="sm monitoring 2">
</div>
</div>
<div class="paragraph">
<p>You can view metrics from Spring Boot by running the following two <code>curl</code>
commands (shown with their output):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json"># curl http://localhost:8080/actuator/metrics/ssm.transition.duration

{
  "name":"ssm.transition.duration",
  "measurements":[
    {
      "statistic":"COUNT",
      "value":3.0
    },
    {
      "statistic":"TOTAL_TIME",
      "value":0.007
    },
    {
      "statistic":"MAX",
      "value":0.004
    }
  ],
  "availableTags":[
    {
      "tag":"transitionName",
      "values":[
        "INITIAL_S1",
        "EXTERNAL_S1_S2"
      ]
    }
  ]
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json"># curl http://localhost:8080/actuator/metrics/ssm.transition.transit

{
  "name":"ssm.transition.transit",
  "measurements":[
    {
      "statistic":"COUNT",
      "value":3.0
    }
  ],
  "availableTags":[
    {
      "tag":"transitionName",
      "values":[
        "EXTERNAL_S1_S2",
        "INITIAL_S1"
      ]
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also view tracing from Spring Boot by running the following <code>curl</code>
command (shown with its output):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json"># curl http://localhost:8080/actuator/statemachinetrace

[
  {
    "timestamp":"2018-02-11T06:44:12.723+0000",
    "info":{
      "duration":2,
      "machine":null,
      "transition":"EXTERNAL_S1_S2"
    }
  },
  {
    "timestamp":"2018-02-11T06:44:12.720+0000",
    "info":{
      "duration":0,
      "machine":null,
      "action":"demo.monitoring.StateMachineConfig$Config$$Lambda$576/1499688007@22b47b2f"
    }
  },
  {
    "timestamp":"2018-02-11T06:44:12.714+0000",
    "info":{
      "duration":1,
      "machine":null,
      "transition":"INITIAL_S1"
    }
  },
  {
    "timestamp":"2018-02-11T06:44:09.689+0000",
    "info":{
      "duration":4,
      "machine":null,
      "transition":"INITIAL_S1"
    }
  }
]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="statemachine-faq" class="sect0"><a class="anchor" href="#statemachine-faq"></a>FAQ</h1>
<div class="openblock partintro">
<div class="content">
This chapter answers the questions that Spring Statemachine users most often ask.
</div>
</div>
<div class="sect1">
<h2 id="state-changes"><a class="anchor" href="#state-changes"></a>State Changes</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">How can I automatically transit to the next state?</div>
<p>You can choose from three approaches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement an action and send an appropriate event to a state machine
to trigger a transition into the proper target state.</p>
</li>
<li>
<p>Define a deferred event within a state and, before sending an event,
send another event that is deferred. Doing so causes the next
appropriate state transition when it is more convenient to handle
that event.</p>
</li>
<li>
<p>Implement a triggerless transition, which automatically causes a
state transition into the next state when state is entered and its
actions has been completed.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extended-state"><a class="anchor" href="#extended-state"></a>Extended State</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">How I can initialize variables on state machine start?</div>
<p>An important concept in a state machine is that nothing really happens
unless a trigger causes a state transition that
then can fire actions. However, having said that, Spring Statemachine
always has an initial transition when a state machine is started. With
this initial transition, you can run a simple action that, within
a <code>StateContext</code>, can do whatever it likes with extended state
variables.</p>
</div>
</div>
</div>
<h1 id="appendices" class="sect0"><a class="anchor" href="#appendices"></a>Appendices</h1>
<div class="sect1">
<h2 id="support-content"><a class="anchor" href="#support-content"></a>Appendix A: Support Content</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix provides generic information about the classes and
material that are used in this reference documentation.</p>
</div>
<div class="sect2">
<h3 id="classes-used-in-this-document"><a class="anchor" href="#classes-used-in-this-document"></a>Classes Used in This Document</h3>
<div class="paragraph">
<p>The following listings show the classes used throughout this reference guide:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
    SI,S1,S2,S3,S4,SF
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States2 {
	S1,S2,S3,S4,S5,SF,
	S2I,S21,S22,S2F,
	S3I,S31,S32,S3F
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States3 {
    S1,S2,SH,
    S2I,S21,S22,S2F
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Events {
    E1,E2,E3,E4,EF
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="state-machine-concepts"><a class="anchor" href="#state-machine-concepts"></a>Appendix B: State Machine Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix provides generial information about state machines.</p>
</div>
<div class="sect2">
<h3 id="quick-example"><a class="anchor" href="#quick-example"></a>Quick Example</h3>
<div class="paragraph">
<p>Assuming we have states named <code>STATE1</code> and <code>STATE2</code> and events named <code>EVENT1</code> and
<code>EVENT2</code>, you can define the logic of the state machine as the following image shows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart0.png" alt="statechart0" width="500">
</div>
</div>
<div class="paragraph">
<p>The following listings define the state machine in the preceding image:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum States {
	STATE1, STATE2
}

public enum Events {
	EVENT1, EVENT2
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableStateMachine
public class Config1 extends EnumStateMachineConfigurerAdapter&lt;States, Events&gt; {

	@Override
	public void configure(StateMachineStateConfigurer&lt;States, Events&gt; states)
			throws Exception {
		states
			.withStates()
				.initial(States.STATE1)
				.states(EnumSet.allOf(States.class));
	}

	@Override
	public void configure(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)
			throws Exception {
		transitions
			.withExternal()
				.source(States.STATE1).target(States.STATE2)
				.event(Events.EVENT1)
				.and()
			.withExternal()
				.source(States.STATE2).target(States.STATE1)
				.event(Events.EVENT2);
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WithStateMachine
public class MyBean {

	@OnTransition(target = "STATE1")
	void toState1() {
	}

	@OnTransition(target = "STATE2")
	void toState2() {
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyApp {

	@Autowired
	StateMachine&lt;States, Events&gt; stateMachine;

	void doSignals() {
		stateMachine.sendEvent(Events.EVENT1);
		stateMachine.sendEvent(Events.EVENT2);
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="glossary"><a class="anchor" href="#glossary"></a>Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>State Machine</strong></dt>
<dd>
<p>The main entity that drives a collection of states, together with regions,
transitions, and events.</p>
</dd>
<dt class="hdlist1"><strong>State</strong></dt>
<dd>
<p>A state models a situation during which some invariant condition
holds. The state is the main entity of a state machine where state changes
are driven by events.</p>
</dd>
<dt class="hdlist1"><strong>Extended State</strong></dt>
<dd>
<p>An extended state is a special set of variables kept in a state
machine to reduce the number of needed states.</p>
</dd>
<dt class="hdlist1"><strong>Transition</strong></dt>
<dd>
<p>A transition is a relationship between a source state and a target
state. It may be part of a compound transition, which takes the state
machine from one state configuration to another, representing the complete
response of the state machine to an occurrence of an event of a
particular type.</p>
</dd>
<dt class="hdlist1"><strong>Event</strong></dt>
<dd>
<p>An entity that is sent to a state machine and then drives a various
state changes.</p>
</dd>
<dt class="hdlist1"><strong>Initial State</strong></dt>
<dd>
<p>A special state in which the state machine starts. The initial state is
always bound to a particular state machine or a region. A state
machine with multiple regions may have a multiple initial states.</p>
</dd>
<dt class="hdlist1"><strong>End State</strong></dt>
<dd>
<p>(Also called as a final state.) A special kind of state signifying
that the enclosing region is completed. If the enclosing region is
directly contained in a state machine and all other regions in the
state machine are also completed, the entire state
machine is completed.</p>
</dd>
<dt class="hdlist1"><strong>History State</strong></dt>
<dd>
<p>A pseudo state that lets a state machine remember its last
active state. Two types of history state exists: <em>shallow</em> (which
remembers only top level state) and <em>deep</em> (which remembers active states in
sub-machines).</p>
</dd>
<dt class="hdlist1"><strong>Choice State</strong></dt>
<dd>
<p>A pseudo state that allows for making a transition choice based on (for example)
event headers or extended state variables.</p>
</dd>
<dt class="hdlist1"><strong>Junction State</strong></dt>
<dd>
<p>A pseudo state that is relatively similar to choice state but allows
multiple incoming transitions, while choice allows only one incoming
transition.</p>
</dd>
<dt class="hdlist1"><strong>Fork State</strong></dt>
<dd>
<p>A pseudo state that gives controlled entry into a region.</p>
</dd>
<dt class="hdlist1"><strong>Join State</strong></dt>
<dd>
<p>A pseudo state that gives controlled exit from a region.</p>
</dd>
<dt class="hdlist1"><strong>Entry Point</strong></dt>
<dd>
<p>A pseudo state that allows controlled entry into a submachine.</p>
</dd>
<dt class="hdlist1"><strong>Exit Point</strong></dt>
<dd>
<p>A pseudo state that allows controlled exit from a submachine.</p>
</dd>
<dt class="hdlist1"><strong>Region</strong></dt>
<dd>
<p>A region is an orthogonal part of either a composite state or a state
machine. It contains states and transitions.</p>
</dd>
<dt class="hdlist1"><strong>Guard</strong></dt>
<dd>
<p>A boolean expression evaluated dynamically based on the value of
extended state variables and event parameters. Guard conditions affect
the behavior of a state machine by enabling actions or transitions
only when they evaluate to <code>TRUE</code> and disabling them when they evaluate
to <code>FALSE</code>.</p>
</dd>
<dt class="hdlist1"><strong>Action</strong></dt>
<dd>
<p>A action is a behavior run during the triggering of the
transition.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="crashcourse"><a class="anchor" href="#crashcourse"></a>A State Machine Crash Course</h3>
<div class="paragraph">
<p>This appendix provides a generic crash course to state machine
concepts.</p>
</div>
<div class="sect3">
<h4 id="states"><a class="anchor" href="#states"></a>States</h4>
<div class="paragraph">
<p>A state is a model in which a state machine can be. It is always
easier to describe state as a real world example rather than trying to use
abstract concepts ingeneric documentation. To that end, consider
a simple example of a keyboard&#8201;&#8212;&#8201;most of us use one every single day.
If you have a full keyboard that has normal keys on the left side and
the numeric keypad on the right side, you may have noticed that the
numeric keypad may be in a two different states, depending on whether
numlock is activated. If it is not active, pressing the number pad keys
result in navigation by using arrows and so on. If the number pad is active, pressing
those keys results in numbers being typed. Essentially, the number pad part of a keyboard
can be in two different states.</p>
</div>
<div class="paragraph">
<p>To relate state concept to programming, it means that instead of using
flags, nested if/else/break clauses, or other impractical (and sometimes tortuous) logic, you can
rely on state, state variables, or another interaction with a
state machine.</p>
</div>
</div>
<div class="sect3">
<h4 id="pseudo-states"><a class="anchor" href="#pseudo-states"></a>Pseudo States</h4>
<div class="paragraph">
<p>Pseudostate is a special type of state that usually introduces more
higher-level logic into a state machine by either giving a state a
special meaning (such as initial state). A state machine can then internally
react to these states by doing various actions that are available in UML state
machine concepts.</p>
</div>
<div class="sect4">
<h5 id="initial"><a class="anchor" href="#initial"></a>Initial</h5>
<div class="paragraph">
<p>The <strong>Initial pseudostate</strong> state is always needed for every single state
machine, whether you have a simple one-level state machine or a more
complex state machine composed of submachines or regions. The initial
state defines where a state machine should go when it starts.
Without it, a state machine is ill-formed.</p>
</div>
</div>
<div class="sect4">
<h5 id="end"><a class="anchor" href="#end"></a>End</h5>
<div class="paragraph">
<p>The <strong>Terminate pseudostate</strong> (which is also called &#8220;end state&#8221;) indicates
that a particular state machine has reached its final state. Effectively,
this mean that a state machine no longer processes any events and does
not transit to any other state. However, in the case where submachines are
regions, a state machine can restart from its terminal state.</p>
</div>
</div>
<div class="sect4">
<h5 id="choice"><a class="anchor" href="#choice"></a>Choice</h5>
<div class="paragraph">
<p>You can use the <strong>Choice pseudostate</strong> choose a dynamic conditional branch of
a transition from this state. The dynamic condition is evaluated by guards
so that one branch is selected. Usually a
simple if/elseif/else structure is used to make sure that one
branch is selected. Otherwise, the state machine might end up in a deadlock,
and the configuration is ill-formed.</p>
</div>
</div>
<div class="sect4">
<h5 id="junction"><a class="anchor" href="#junction"></a>Junction</h5>
<div class="paragraph">
<p>The <strong>Junction pseudostate</strong> is functionally similar to choice, as both are
implemented with if/elseif/else structures. The only real difference is
that junction allows multiple incoming transitions, while choice
allows only one. Thus difference is largely academic but does have some
differences, such as when a state machine is designed is used with a real UI modeling
framework.</p>
</div>
</div>
<div class="sect4">
<h5 id="history"><a class="anchor" href="#history"></a>History</h5>
<div class="paragraph">
<p>You can use the <strong>History pseudostate</strong> to remember the last active state
configuration. After a state machine has exited, you can use a history state
to restore a previously known configuration. There are two types
of history states available: <code>SHALLOW</code> (which remembers only the active state of a
state machine itself) and <code>DEEP</code> (which also remembers nested states).</p>
</div>
<div class="paragraph">
<p>A history state could be implemented externally by listening state
machine events, but this would soon make for very difficult logic,
especially if a state machine contains complex nested structures.
Letting the state machine itself handle the recording of history states
makes things much simpler. The user need only create a
transition into a history state, and the state machine handles the needed
logic to go back to its last known recorded state.</p>
</div>
<div class="paragraph">
<p>In cases where a Transition terminates on a history state when the state
has not been previously entered (in other words, no prior history exists) or it had reached its
end state, a transition can force the state machine to a specific substate, by
using the default history mechanism. This transition originates
in the history state and terminates on a specific vertex (the default history
state) of the region that contains the history state. This transition is
taken only if its execution leads to the history state and the state had never before been
active. Otherwise, the normal history entry into the region is executed.
If no default history transition is defined, the standard default entry of
the region is performed.</p>
</div>
</div>
<div class="sect4">
<h5 id="fork"><a class="anchor" href="#fork"></a>Fork</h5>
<div class="paragraph">
<p>You can use the <strong>Fork pseudostate</strong> to do an explicit entry into one or more regions.
The following image shows how a fork works:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart7.png" alt="statechart7" width="500">
</div>
</div>
<div class="paragraph">
<p>The target state can be a parent state that hosts regions, which simply
means that regions are activated by entering their initial states. You
can also add targets directly to any state in a region, which
allows more controlled entry into a state.</p>
</div>
</div>
<div class="sect4">
<h5 id="join"><a class="anchor" href="#join"></a>Join</h5>
<div class="paragraph">
<p>The <strong>Join pseudostate</strong> merges together several transitions that
originate from different regions. It is generally used to wait
and block for participating regions to get into its join target states.
The following image shows how a join works:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart8.png" alt="statechart8" width="500">
</div>
</div>
<div class="paragraph">
<p>The source state can be a parent state that hosts regions, which means that
join states are the terminal states of the participating regions.
You can also define source states to be any state in a
region, which allows controlled exit from regions.</p>
</div>
</div>
<div class="sect4">
<h5 id="entry-point"><a class="anchor" href="#entry-point"></a>Entry Point</h5>
<div class="paragraph">
<p>An <strong>Entry Point pseudostate</strong> represents an entry point for a state
machine or a composite state that provides encapsulation of the insides
of the state or state machine. In each region of the state machine or
composite state that owns the entry point, there is at most a single
transition from the entry point to a vertex within that region.</p>
</div>
</div>
<div class="sect4">
<h5 id="exit-point"><a class="anchor" href="#exit-point"></a>Exit Point</h5>
<div class="paragraph">
<p>An <strong>Exit Point pseudostate</strong> is an exit point of a state machine or
composite state that provides encapsulation of the insides of the state
or state machine. Transitions that terminate on an exit point within any
region of the composite state (or a state machine referenced by a
submachine state) imply exiting of this composite state or submachine
state (with execution of its associated exit behavior).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="guard-conditions"><a class="anchor" href="#guard-conditions"></a>Guard Conditions</h4>
<div class="paragraph">
<p>Guard conditions are expressions which evaluates to either <code>TRUE</code> or
<code>FALSE</code>, based on extended state variables and event parameters. Guards
are used with actions and transitions to dynamically choose whether a
particular action or transition should be run. The various spects of guards,
event parameters, and extended state variables exist to make state
machine design much more simple.</p>
</div>
</div>
<div class="sect3">
<h4 id="events"><a class="anchor" href="#events"></a>Events</h4>
<div class="paragraph">
<p>Event is the most-used trigger behavior to drive a state machine.
There are other ways to trigger behavior in a state machine
(such as a timer), but events are the ones that really let users
interact with a state machine. Events are also called &#8220;signals&#8221;.
They basically indicate something that can possibly alter a state machine state.</p>
</div>
</div>
<div class="sect3">
<h4 id="transitions"><a class="anchor" href="#transitions"></a>Transitions</h4>
<div class="paragraph">
<p>A transition is a relationship between a source state and a target
state. A switch from one state to another is a state transition caused
by a trigger.</p>
</div>
<div class="sect4">
<h5 id="internal-transition"><a class="anchor" href="#internal-transition"></a>Internal Transition</h5>
<div class="paragraph">
<p>Internal transition is used when an action needs to be run without
causing a state transition. In an internal transition, the source state and the target
state is always the same, and it is identical with a self-transition in the
absence of state entry and exit actions.</p>
</div>
</div>
<div class="sect4">
<h5 id="external-versus-local-transitions"><a class="anchor" href="#external-versus-local-transitions"></a>External versus Local Transitions</h5>
<div class="paragraph">
<p>In most cases, external and local transitions are functionally
equivalent, except in cases where the transition happens between super
and sub states. Local transitions do not cause exit and entry to a
source state if the target state is a substate of a source state.
Conversely, local transitions do not cause exit and entry to a target
state if the target is a superstate of a source state.
The following image shows the difference between local and external transitions
with very simplistic super and sub states:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statechart4.png" alt="statechart4" width="500">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="triggers"><a class="anchor" href="#triggers"></a>Triggers</h4>
<div class="paragraph">
<p>A trigger begins a transition. Triggers can be driven by either events or timers.</p>
</div>
</div>
<div class="sect3">
<h4 id="actions"><a class="anchor" href="#actions"></a>Actions</h4>
<div class="paragraph">
<p>Actions really glue state machine state changes
to a user&#8217;s own code. A state machine can run an action on various
changes and on the steps in a state machine (such as entering or exiting a state)
or doing a state transition.</p>
</div>
<div class="paragraph">
<p>Actions usually have access to a state context, which gives running
code a choice to interact with a state machine in various ways.
State context exposes a whole state machine so that a user can
access extended state variables, event headers (if a transition is based
on an event), or an actual transition (where it is possible to see more
detailed about where this state change is coming from and where it is going).</p>
</div>
</div>
<div class="sect3">
<h4 id="hierarchical-state-machines"><a class="anchor" href="#hierarchical-state-machines"></a>Hierarchical State Machines</h4>
<div class="paragraph">
<p>The concept of a hierarchical state machine is used to simplify state
design when particular states must exist together.</p>
</div>
<div class="paragraph">
<p>Hierarchical states are really an innovation in UML state machines over
traditional state machines, such as Mealy or Moore machines.
Hierarchical states lets you define some level of abstraction (parallel
to how a Java developer might define a class structure with abstract
classes). For example, with a nested state machine, you can
define  transition on a multiple level of states (possibly with
different conditions). A state machine always tries to see if the current
state is able to handle an event, together with  transition guard
conditions. If these conditions do not evaluate to <code>TRUE</code>, the state
machine merely see what the super state can handle.</p>
</div>
</div>
<div class="sect3">
<h4 id="regions"><a class="anchor" href="#regions"></a>Regions</h4>
<div class="paragraph">
<p>Regions (which are also called as orthogonal regions) are usually viewed
as exclusive OR (XOR) operations applied to states. The concept of a region in
terms of a state machine is usually a little difficult to understand,
but things gets a little simpler with a simple example.</p>
</div>
<div class="paragraph">
<p>Some of us have a full size keyboard with the main keys on the left side and numeric
keys on the right side. You have probably noticed that both sides really
have their own state, which you see if you press a &#8220;numlock&#8221; key (which
alters only the behaviour of the number pad itself). If you do not have a full-size
keyboard, you can buy an external USB number pad.
Given that the left and right side of a keyboard can each exist without the
other, they must have totally different states, which means they are
operating on different state machines. In state machine terms, the main part of a
keyboard is one region and the number pad is another region.</p>
</div>
<div class="paragraph">
<p>It would be a little inconvenient to handle two different
state machines as totally separate entities, because they
still work together in some fashion. This independence lets orthogonal regions
combine together in multiple simultaneous states within a single state
in a state machine.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendices-zookeeper"><a class="anchor" href="#appendices-zookeeper"></a>Appendix C: Distributed State Machine Technical Paper</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix provides more detailed technical documentation about
using a Zookeeper instance with Spring Statemachine.</p>
</div>
<div class="sect2">
<h3 id="abstract"><a class="anchor" href="#abstract"></a>Abstract</h3>
<div class="paragraph">
<p>Introducing a &#8220;distributed state&#8221; on top of a single state machine
instance running on a single JVM is a difficult and a complex topic.
The concept of a &#8220;Distributed State Machine&#8221; introduces a few relatively complex
problems on top of a simple state machine, due to its run-to-completion
model and, more generally, because of its single-thread execution model,
though orthogonal regions can be run in parallel. One other natural
problem is that state machine transition execution is driven by triggers,
which are either <code>event</code> or <code>timer</code> based.</p>
</div>
<div class="paragraph">
<p>Spring State Machine tries to solve the problem of spanning
a generic &#8220;State Machine&#8221; through a JVM boundary by supporting distributed
state machines. Here we show that you can use generic
&#8220;State Machine&#8221; concepts across multiple JVMs and Spring
Application Contexts.</p>
</div>
<div class="paragraph">
<p>We found that, if <code>Distributed State Machine</code> abstraction is carefully chosen
and backing distributed state repository guarantees <code>CP</code> readiness, it is
possible to create a consistent state machine that can share
distributed state among other state machines in an ensemble.</p>
</div>
<div class="paragraph">
<p>Our results demonstrate that distributed state changes are consistent if the backing
repository is &#8220;CP&#8221; (discussed <a href="#state-machine-technical-paper-introduction">later</a>).
We anticipate our distributed state machine can provide
a foundation to applications that need to work with shared distributed
states. This model aims to provide good methods for cloud applications
to have much easier ways to communicate with each other without having
to explicitly build these distributed state concepts.</p>
</div>
</div>
<div class="sect2">
<h3 id="state-machine-technical-paper-introduction"><a class="anchor" href="#state-machine-technical-paper-introduction"></a>Introduction</h3>
<div class="paragraph">
<p>Spring State Machine is not forced to use a single threaded execution
model, because, once multiple regions are used, regions can be executed in
parallel if the necessary configuration is applied. This is an important
topic, because, once a user wants to have parallel state machine
execution, it makes state changes faster for independent regions.</p>
</div>
<div class="paragraph">
<p>When state changes are no longer driven by a trigger in a local JVM or a
local state machine instance, transition logic needs to be controlled
externally in an arbitrary persistent storage. This storage needs to
have a way to notify participating state machines when distributed
state is changed.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP Theorem</a> states that
it is impossible for a distributed computer system to simultaneously
provide all three of the following guarantees: consistency,
availability, and partition tolerance.</p>
</div>
<div class="paragraph">
<p>This means that,
whatever is chosen for a backing persistence storage, it is advisable
to be &#8220;CP&#8221;. In this context, &#8220;CP&#8221; means &#8220;consistency&#8221; and &#8220;partition
tolerance&#8221;. Naturally, a distributed Spring Statemachine does not care
about its &#8220;CAP&#8221; level but, in reality, &#8220;consistency&#8221; and
&#8220;partition tolerance&#8221; are more important than &#8220;availability&#8221;. This is
an exact reason why (for example) Zookeeper uses &#8220;CP&#8221; storage.</p>
</div>
<div class="paragraph">
<p>All tests presented in this article are accomplished by running custom
Jepsen tests in the following environment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A cluster having nodes n1, n2, n3, n4 and n5.</p>
</li>
<li>
<p>Each node has a <code>Zookeeper</code> instance that constructs an ensemble with
all other nodes.</p>
</li>
<li>
<p>Each node has a <a href="#statemachine-examples-web">Web</a> sample installed,
to connect to a local <code>Zookeeper</code> node.</p>
</li>
<li>
<p>Every state machine instance communicates only with a local
<code>Zookeeper</code> instance. While connecting a machine to multiple instances
is possible, it is not used here.</p>
</li>
<li>
<p>All state machine instances, when started, create a
<code>StateMachineEnsemble</code> by using a Zookeeper ensemble.</p>
</li>
<li>
<p>Each sample contains a custom rest API, which Jepsen uses to send
events and check particular state machine statuses.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All Jepsen tests for <code>Spring Distributed Statemachine</code> are available from
<a href="https://github.com/spring-projects/spring-statemachine/tree/master/jepsen/spring-statemachine-jepsen">Jepsen
Tests.</a></p>
</div>
</div>
<div class="sect2">
<h3 id="generic-concepts"><a class="anchor" href="#generic-concepts"></a>Generic Concepts</h3>
<div class="paragraph">
<p>One design decision of a <code>Distributed State Machine</code> was not to make each
individual state machine instance be aware that it is part of a
&#8220;distributed ensemble&#8221;. Because the main functions and features of a
<code>StateMachine</code> can be accessed through its interface, it makes sense to
wrap this instance in a <code>DistributedStateMachine</code>, which
intercepts all state machine communication and collaborates with an
ensemble to orchestrate distributed state changes.</p>
</div>
<div class="paragraph">
<p>One other important concept is to be able to persist enough
information from a state machine to reset a state machine state
from an arbitrary state into a new deserialized state. This is naturally
needed when a new state machine instance joins with an ensemble
and needs to synchronize its own internal state with a distributed
state. Together with using concepts of distributed states and state
persisting, it is possible to create a distributed state machine.
Currently, the only backing repository of a <code>Distributed State Machine</code> is
implemented by using Zookeeper.</p>
</div>
<div class="paragraph">
<p>As mentioned in <a href="#sm-distributed">Using Distributed States</a>, distributed states are enabled by
wrapping an instance of a <code>StateMachine</code> in a
<code>DistributedStateMachine</code>. The specific <code>StateMachineEnsemble</code>
implementation is <code>ZookeeperStateMachineEnsemble</code> provides
integration with Zookeeper.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-role-of-code-zookeeperstatemachinepersist-code"><a class="anchor" href="#the-role-of-code-zookeeperstatemachinepersist-code"></a>The Role of <code>ZookeeperStateMachinePersist</code></h3>
<div class="paragraph">
<p>We wanted to have a generic interface (<code>StateMachinePersist</code>) that
Can persist <code>StateMachineContext</code> into arbitrary storage and
<code>ZookeeperStateMachinePersist</code> implements this interface for
<code>Zookeeper</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-role-of-code-zookeeperstatemachineensemble-code"><a class="anchor" href="#the-role-of-code-zookeeperstatemachineensemble-code"></a>The Role of <code>ZookeeperStateMachineEnsemble</code></h3>
<div class="paragraph">
<p>While a distributed state machine uses one set of serialized
contexts to update its own state, with zookeeper, we have a
conceptual problem around how to listen to these context changes. We
can serialize context into a zookeeper <code>znode</code> and eventually
listen when the <code>znode</code> data is modified. However, <code>Zookeeper</code> does not
guarantee that you get a notification for every data change,
because a registered <code>watcher</code> for a <code>znode</code> is disabled once it fires
and the user need to re-register that <code>watcher</code>. During this short time,
a <code>znode</code> data can be changed, thus resulting in missing events. It is
actually very easy to miss these events by changing data from
multiple threads in a concurrent manner.</p>
</div>
<div class="paragraph">
<p>To overcome this issue, we keep individual context changes
in multiple <code>znodes</code> and we use a simple integer counter to mark
which <code>znode</code> is the current active one. Doing so lets us replay missed
events. We do not want to create more and more znodes and then later
delete old ones. Instead, we use the simple concept of a circular
set of znodes. This lets us use a predefined set of znodes where
the current node can be determined with a simple integer counter. We already have
this counter by tracking the main <code>znode</code> data version (which, in
<code>Zookeeper</code>, is an integer).</p>
</div>
<div class="paragraph">
<p>The size of a circular buffer is mandated to be a power of two, to avoid
trouble when the integer goes to overflow. For this reason, we need not
handle any specific cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="distributed-tolerance"><a class="anchor" href="#distributed-tolerance"></a>Distributed Tolerance</h3>
<div class="paragraph">
<p>To show how a various distributed actions against a state
machine work in real life, we use a set of Jepsen tests to
simulate various conditions that might happen in a real distributed
cluster. These include a &#8220;brain split&#8221; on a network level, parallel
events with multiple &#8220;distributed state machines&#8221;, and changes in
&#8220;extended state variables&#8221;. Jepsen tests are based on a sample
<a href="#statemachine-examples-web">Web</a>, where this sample instance runs on
multiple hosts together with a Zookeeper instance on every node
where the state machine is run. Essentially, every state machine sample
connects to a local Zookeeper instance, which lets us, by using
Jepsen, to simulate network conditions.</p>
</div>
<div class="paragraph">
<p>The plotted graphs shown later in this chapter contain states and events that
directly map to a state chart, which you can be find in
<a href="#statemachine-examples-web">Web</a>.</p>
</div>
<div class="sect3">
<h4 id="sm-tech-isolated-events"><a class="anchor" href="#sm-tech-isolated-events"></a>Isolated Events</h4>
<div class="paragraph">
<p>Sending an isolated single event into exactly one state machine in an
ensemble is the simplest testing scenario and demonstrates that a
state change in one state machine is properly propagated into other
state machines in an ensemble.</p>
</div>
<div class="paragraph">
<p>In this test, we demonstrate that a state change in one machine
eventually causes a consistent state change in other machines.
The following image shows the events and state changes for a test state machine:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-isolated-events.png" alt="sm tech isolated events" width="500">
</div>
</div>
<div class="paragraph">
<p>In the preceding image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All machines report state <code>S21</code>.</p>
</li>
<li>
<p>Event <code>I</code> is sent to node <code>n1</code> and all nodes report state change
from <code>S21</code> to <code>S22</code>.</p>
</li>
<li>
<p>Event <code>C</code> is sent to node <code>n2</code> and all nodes report state change
from <code>S22</code> to <code>S211</code>.</p>
</li>
<li>
<p>Event <code>I</code> is sent to node <code>n5</code> and all nodes report state change
from <code>S211</code> to <code>S212</code>.</p>
</li>
<li>
<p>Event <code>K</code> is sent to node <code>n3</code> and all nodes report state change
from <code>S212</code> to <code>S21</code>.</p>
</li>
<li>
<p>We cycle events <code>I</code>, <code>C</code>, <code>I</code>, and <code>K</code> one more time, through random nodes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="parallel-events"><a class="anchor" href="#parallel-events"></a>Parallel Events</h4>
<div class="paragraph">
<p>One logical problem with multiple distributed state machines is that, if the
same event is sent into multiple state machines at exactly the same
time, only one of those events causes a distributed state
transitions. This is a somewhat expected scenario, because the first state
machine (for this event) that is able to change a distributed state
controls the distributed transition logic. Effectively, all other
machines that receive this same event silently discard the event,
because the distributed state is no longer in a state where a particular
event can be processed.</p>
</div>
<div class="paragraph">
<p>In the test shown in the following image, we demonstrate that a state change caused by a
parallel event throughout an ensemble eventually causes a
consistent state change in all machines:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-parallel-events.png" alt="sm tech parallel events" width="500">
</div>
</div>
<div class="paragraph">
<p>In the preceding image, we use the same event flow that we used in the previous sample
(<a href="#sm-tech-isolated-events">Isolated Events</a>), with the difference that events are always
sent to all nodes.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrent-extended-state-variable-changes"><a class="anchor" href="#concurrent-extended-state-variable-changes"></a>Concurrent Extended State Variable Changes</h4>
<div class="paragraph">
<p>Extended state machine variables are not guaranteed to be atomic at
any given time, but, after a distributed state change, all state machines
in an ensemble should have a synchronized extended state.</p>
</div>
<div class="paragraph">
<p>In this test, we demonstrate that a change in extended state
variables in one distributed state machine eventually becomes
consistent in all the distributed state machines.
The following image shows this test:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-isolated-events-with-variable.png" alt="sm tech isolated events with variable" width="500">
</div>
</div>
<div class="paragraph">
<p>In the preceding image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Event <code>J</code> is send to node <code>n5</code> with event variable <code>testVariable</code>
having value <code>v1</code>. All nodes then report having a variable named
<code>testVariable</code> with a value of <code>v1</code>.</p>
</li>
<li>
<p>Event <code>J</code> is repeated from variable <code>v2</code> to <code>v8</code>, doing the same checks.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="partition-tolerance"><a class="anchor" href="#partition-tolerance"></a>Partition Tolerance</h4>
<div class="paragraph">
<p>We need to always assume that, sooner or later, things in a cluster
go bad, whether it is a crash of a Zookeeper instance, a state
machine crash, or a network problem such as a &#8220;brain split&#8221;. (A brain split is a
situation where existing cluster members are isolated so that only
parts of hosts are able to see each other). The usual scenario is that a
brain split creates minority and majority partitions of an
ensemble such that hosts in the minority cannot participate in an ensemble
until the network status has been healed.</p>
</div>
<div class="paragraph">
<p>In the following tests, we demonstrate that various types of brain split in
an ensemble eventually cause a fully synchronized state of all the
distributed state machines.</p>
</div>
<div class="paragraph">
<p>There are two scenarios that have a straight brain split in a
network where where <code>Zookeeper</code> and <code>Statemachine</code> instances are
split in half (assuming each <code>Statemachine</code> connects to a
local <code>Zookeeper</code> instance):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the current zookeeper leader is kept in a majority, all clients
connected to the majority keep functioning properly.</p>
</li>
<li>
<p>If the current zookeeper leader is left in the minority, all clients
disconnect from it and try to connect back till previous
minority members have successfully joined back to existing majority
ensemble.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In our current Jepsen tests, we cannot separate Zookeeper split-brain
scenarios between the leader being left in the majority or in the minority, so we need to
run the tests multiple times to accomplish this situation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the following plots, we have mapped a state machine error state into an
<code>error</code> to indicate that the state machine is in an error state instead of
a normal state. Please remember this when interpreting chart states.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this first test, we show that, when an existing Zookeeper leader was
kept in the majority, three out of five machines continue as is.
The following image shows this test:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-partition-half-1.png" alt="sm tech partition half 1" width="500">
</div>
</div>
<div class="paragraph">
<p>In the preceding image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first event, <code>C</code>, is sent to all machines, leading a state change to
<code>S211</code>.</p>
</li>
<li>
<p>Jepsen nemesis causes a brain split, which causes partitions
of <code>n1/n2/n5</code> and <code>n3/n4</code>. Nodes <code>n3/n4</code> are left in the minority, and
nodes <code>n1/n2/n5</code> construct a new healthy majority. Nodes in the
majority keep functioning without problems, but nodes in the minority
go into error states.</p>
</li>
<li>
<p>Jepsen heals the network and, after some time, nodes <code>n3/n4</code> join
back into the ensemble and synchronize its distributed status.</p>
</li>
<li>
<p>Finally, event <code>K1</code> is sent to all state machines to ensure that the ensemble
is working properly. This state change leads back to state
<code>S21</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the second test, we show that, when the existing zookeeper leader was
kept in the minority, all machines error out.
The following image shows the second test:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-partition-half-2.png" alt="sm tech partition half 2" width="500">
</div>
</div>
<div class="paragraph">
<p>In the preceding image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first event, <code>C</code>, is sent to all machines leading to a state change to
<code>S211</code>.</p>
</li>
<li>
<p>Jepsen nemesis causes a brain split, which causes partitions
such that the existing <code>Zookeeper</code> leader is kept in the minority and all
instances are disconnected from the ensemble.</p>
</li>
<li>
<p>Jepsen heals the network and, after some time, all nodes join
back into the ensemble and synchronize its distributed status.</p>
</li>
<li>
<p>Finally, event <code>K1</code> is sent to all state machines to ensure that ensemble
workS properly. This state change leads back to state
<code>S21</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="crash-and-join-tolerance"><a class="anchor" href="#crash-and-join-tolerance"></a>Crash and Join Tolerance</h4>
<div class="paragraph">
<p>In this test, we demonstrate that killing an existing state machine
and then joining a new instance back into an ensemble keeps the
distributed state healthy and the newly joined state machines synchronize
their states properly.
The following image shows the crash and join tolerance test:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sm-tech-stop-start.png" alt="sm tech stop start" width="500">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this test, states are not checked between first the <code>X</code> and last the <code>X</code>.
Thus, the graph shows a flat line in between. The states are checked
exactly where the state change happens between <code>S21</code> and <code>S211</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the preceding image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All state machines are transitioned from the initial state (<code>S21</code>) into
state <code>S211</code> so that we can test proper state synchronize during the join.</p>
</li>
<li>
<p><code>X</code> marks when a specific node has been crashed and started.</p>
</li>
<li>
<p>At the same time, we request states from all machines and plot the result.</p>
</li>
<li>
<p>Finally, we do a simple transition back to <code>S21</code> from <code>S211</code> to make
sure that all state machines still function properly.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="devdocs"><a class="anchor" href="#devdocs"></a>Developer Documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix provides generic information for adevelopers who may
want to contribute or other people who want to understand how state
machine works or understand its internal concepts.</p>
</div>
<div class="sect2">
<h3 id="devdocs-configmodel"><a class="anchor" href="#devdocs-configmodel"></a>StateMachine Config Model</h3>
<div class="paragraph">
<p><code>StateMachineModel</code> and other related SPI classes are an abstraction
between various configuration and factory classes. This also allows
easier integration for others to build state machines.</p>
</div>
<div class="paragraph">
<p>As the following listing shows, you can instantiate a state machine by building a model
with configuration data classes and then asking a factory to build a
state machine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// setup configuration data
ConfigurationData&lt;String, String&gt; configurationData = new ConfigurationData&lt;&gt;();

// setup states data
Collection&lt;StateData&lt;String, String&gt;&gt; stateData = new ArrayList&lt;&gt;();
stateData.add(new StateData&lt;String, String&gt;("S1", true));
stateData.add(new StateData&lt;String, String&gt;("S2"));
StatesData&lt;String, String&gt; statesData = new StatesData&lt;&gt;(stateData);

// setup transitions data
Collection&lt;TransitionData&lt;String, String&gt;&gt; transitionData = new ArrayList&lt;&gt;();
transitionData.add(new TransitionData&lt;String, String&gt;("S1", "S2", "E1"));
TransitionsData&lt;String, String&gt; transitionsData = new TransitionsData&lt;&gt;(transitionData);

// setup model
StateMachineModel&lt;String, String&gt; stateMachineModel = new DefaultStateMachineModel&lt;&gt;(configurationData, statesData,
		transitionsData);

// instantiate machine via factory
ObjectStateMachineFactory&lt;String, String&gt; factory = new ObjectStateMachineFactory&lt;&gt;(stateMachineModel);
StateMachine&lt;String, String&gt; stateMachine = factory.getStateMachine();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-03 06:34:05 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>