<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Gary Russell, Artem Bilan, Biju Kunjummen, Jay Bryant">
<title>Spring for Apache Kafka</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body id="spring-kafka-reference" class="book toc2 toc-left">
<div id="header">
<h1>Spring for Apache Kafka</h1>
<div class="details">
<span id="author" class="author">Gary Russell</span><br>
<span id="author2" class="author">Artem Bilan</span><br>
<span id="author3" class="author">Biju Kunjummen</span><br>
<span id="author4" class="author">Jay Bryant</span><br>
<span id="revnumber">version 2.2.6.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">1. Preface</a></li>
<li><a href="#whats-new-part">2. What&#8217;s new?</a>
<ul class="sectlevel2">
<li><a href="#spring-kafka-intro-new">2.1. What&#8217;s New in 2.2 Since 2.1</a>
<ul class="sectlevel3">
<li><a href="#kafka-client-version">2.1.1. Kafka Client Version</a></li>
<li><a href="#class-and-package-changes">2.1.2. Class and Package Changes</a></li>
<li><a href="#after-rollback-processing">2.1.3. After Rollback Processing</a></li>
<li><a href="#concurrentkafkalistenercontainerfactory-changes">2.1.4. <code>ConcurrentKafkaListenerContainerFactory</code> Changes</a></li>
<li><a href="#listener-container-changes">2.1.5. Listener Container Changes</a></li>
<li><a href="#kafkalistener-changes">2.1.6. @KafkaListener Changes</a></li>
<li><a href="#header-mapping-changes">2.1.7. Header Mapping Changes</a></li>
<li><a href="#embedded-kafka-changes">2.1.8. Embedded Kafka Changes</a></li>
<li><a href="#jsonserializerdeserializer-enhancements">2.1.9. JsonSerializer/Deserializer Enhancements</a></li>
<li><a href="#kafka-streams-changes">2.1.10. Kafka Streams Changes</a></li>
<li><a href="#transactional-id">2.1.11. Transactional ID</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#introduction">3. Introduction</a>
<ul class="sectlevel2">
<li><a href="#quick-tour">3.1. Quick Tour for the Impatient</a>
<ul class="sectlevel3">
<li><a href="#compatibility">3.1.1. Compatibility</a></li>
<li><a href="#a-very-very-quick-example">3.1.2. A Very, Very Quick Example</a></li>
<li><a href="#with-java-configuration">3.1.3. With Java Configuration</a></li>
<li><a href="#even-quicker-with-spring-boot">3.1.4. Even Quicker, with Spring Boot</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">4. Reference</a>
<ul class="sectlevel2">
<li><a href="#kafka">4.1. Using Spring for Apache Kafka</a>
<ul class="sectlevel3">
<li><a href="#configuring-topics">4.1.1. Configuring Topics</a></li>
<li><a href="#sending-messages">4.1.2. Sending Messages</a>
<ul class="sectlevel4">
<li><a href="#kafka-template">Using <code>KafkaTemplate</code></a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#replying-template">Using <code>ReplyingKafkaTemplate</code></a></li>
</ul>
</li>
<li><a href="#receiving-messages">4.1.3. Receiving Messages</a>
<ul class="sectlevel4">
<li><a href="#message-listeners">Message Listeners</a></li>
<li><a href="#message-listener-container">Message Listener Containers</a></li>
<li><a href="#kafka-listener-annotation"><code>@KafkaListener</code> Annotation</a></li>
<li><a href="#container-thread-naming">Container Thread Naming</a></li>
<li><a href="#kafka-listener-meta"><code>@KafkaListener</code> as a Meta Annotation</a></li>
<li><a href="#class-level-kafkalistener"><code>@KafkaListener</code> on a Class</a></li>
<li><a href="#kafkalistener-lifecycle"><code>@KafkaListener</code> Lifecycle Management</a></li>
<li><a href="#kafka-validation"><code>@KafkaListener</code> <code>@Payload</code> Validation</a></li>
<li><a href="#rebalance-listeners">Rebalancing Listeners</a></li>
<li><a href="#annotation-send-to">Forwarding Listener Results using <code>@SendTo</code></a></li>
<li><a href="#filtering-messages">Filtering Messages</a></li>
<li><a href="#retrying-deliveries">Retrying Deliveries</a></li>
<li><a href="#stateful-retry">Stateful Retry</a></li>
<li><a href="#idle-containers">Detecting Idle and Non-Responsive Consumers</a></li>
<li><a href="#topicpartition-initial-offset">Topic/Partition Initial Offset</a></li>
<li><a href="#seek">Seeking to a Specific Offset</a></li>
<li><a href="#container-factory">Container factory</a></li>
<li><a href="#thread-safety">Thread Safety</a></li>
</ul>
</li>
<li><a href="#pause-resume">4.1.4. Pausing and Resuming Listener Containers</a></li>
<li><a href="#events">4.1.5. Events</a></li>
<li><a href="#serdes">4.1.6. Serialization, Deserialization, and Message Conversion</a>
<ul class="sectlevel4">
<li><a href="#serdes-mapping-types">Mapping Types</a></li>
<li><a href="#spring-messaging-message-conversion">Spring Messaging Message Conversion</a></li>
<li><a href="#error-handling-deserializer">Using <code>ErrorHandlingDeserializer</code></a></li>
<li><a href="#payload-conversion-with-batch">Payload Conversion with Batch Listeners</a></li>
<li><a href="#conversionservice-customization"><code>ConversionService</code> Customization</a></li>
</ul>
</li>
<li><a href="#headers">4.1.7. Message Headers</a></li>
<li><a href="#tombstones">4.1.8. Null Payloads and Log Compaction of 'Tombstone' Records</a></li>
<li><a href="#annotation-error-handling">4.1.9. Handling Exceptions</a>
<ul class="sectlevel4">
<li><a href="#listener-error-handlers">Listener Error Handlers</a></li>
<li><a href="#container-error-handlers">Container Error Handlers</a></li>
<li><a href="#consumer-aware-container-error-handlers">Consumer-Aware Container Error Handlers</a></li>
<li><a href="#seek-to-current">Seek To Current Container Error Handlers</a></li>
<li><a href="#container-stopping-error-handlers">Container Stopping Error Handlers</a></li>
<li><a href="#after-rollback">After-rollback Processor</a></li>
<li><a href="#dead-letters">Publishing Dead-letter Records</a></li>
</ul>
</li>
<li><a href="#kerberos">4.1.10. Kerberos</a></li>
</ul>
</li>
<li><a href="#kafka-streams">4.2. Kafka Streams Support</a>
<ul class="sectlevel3">
<li><a href="#basics">4.2.1. Basics</a></li>
<li><a href="#spring-management">4.2.2. Spring Management</a></li>
<li><a href="#json-serialization-and-deserialization">4.2.3. JSON Serialization and Deserialization</a></li>
<li><a href="#using-kafkastreamsbrancher">4.2.4. Using <code>KafkaStreamsBrancher</code></a></li>
<li><a href="#streams-config">4.2.5. Configuration</a></li>
<li><a href="#kafka-streams-example">4.2.6. Kafka Streams Example</a></li>
</ul>
</li>
<li><a href="#testing">4.3. Testing Applications</a>
<ul class="sectlevel3">
<li><a href="#junit">4.3.1. JUnit</a></li>
<li><a href="#configuring-topics-2">4.3.2. Configuring Topics</a></li>
<li><a href="#using-the-same-brokers-for-multiple-test-classes">4.3.3. Using the Same Brokers for Multiple Test Classes</a></li>
<li><a href="#embedded-kafka-annotation">4.3.4. @EmbeddedKafka Annotation</a></li>
<li><a href="#embedded-broker-in-springboottest-annotations">4.3.5. Embedded Broker in <code>@SpringBootTest</code> Annotations</a>
<ul class="sectlevel4">
<li><a href="#kafka-testing-junit4-class-rule">JUnit4 Class Rule</a></li>
<li><a href="#kafka-testing-embeddedkafka-annotation"><code>@EmbeddedKafka</code> Annotation or <code>EmbeddedKafkaBroker</code> Bean</a></li>
</ul>
</li>
<li><a href="#hamcrest-matchers">4.3.6. Hamcrest Matchers</a></li>
<li><a href="#assertj-conditions">4.3.7. AssertJ Conditions</a></li>
<li><a href="#example">4.3.8. Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-integration">5. Spring Integration</a>
<ul class="sectlevel2">
<li><a href="#si-kafka">5.1. Spring Integration for Apache Kafka</a>
<ul class="sectlevel3">
<li><a href="#si-outbound">5.1.1. Outbound Channel Adapter</a></li>
<li><a href="#si-inbound">5.1.2. Message-driven Channel Adapter</a></li>
<li><a href="#si-outbound-gateway">5.1.3. Outbound Gateway</a></li>
<li><a href="#si-inbound-gateway">5.1.4. Inbound Gateway</a></li>
<li><a href="#message-conversion">5.1.5. Message Conversion</a></li>
<li><a href="#si-tombstones">5.1.6. Null Payloads and Log Compaction 'Tombstone' Records</a></li>
<li><a href="#whats-new-in-spring-integration-for-apache-kafka">5.1.7. What&#8217;s New in Spring Integration for Apache Kafka</a>
<ul class="sectlevel4">
<li><a href="#2-1-x">2.1.x</a></li>
<li><a href="#2-2-x">2.2.x</a></li>
<li><a href="#2-3-x">2.3.x</a></li>
<li><a href="#3-0-x">3.0.x</a></li>
<li><a href="#3-1-x">3.1.x</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">6. Other Resources</a></li>
<li><a href="#deps-for-21x">Appendix A: Override Dependencies to use the 2.1.x kafka-clients with an Embedded Broker</a></li>
<li><a href="#history">Appendix B: Change History</a>
<ul class="sectlevel2">
<li><a href="#migration">B.1. Changes between 2.0 and 2.1</a>
<ul class="sectlevel3">
<li><a href="#kafka-client-version-2">B.1.1. Kafka Client Version</a></li>
<li><a href="#json-improvements">B.1.2. JSON Improvements</a></li>
<li><a href="#container-stopping-error-handlers-2">B.1.3. Container Stopping Error Handlers</a></li>
<li><a href="#pausing-and-resuming-containers">B.1.4. Pausing and Resuming Containers</a></li>
<li><a href="#stateful-retry-2">B.1.5. Stateful Retry</a></li>
<li><a href="#client-id">B.1.6. Client ID</a></li>
<li><a href="#logging-offset-commits">B.1.7. Logging Offset Commits</a></li>
<li><a href="#default-kafkahandler">B.1.8. Default @KafkaHandler</a></li>
<li><a href="#replyingkafkatemplate">B.1.9. ReplyingKafkaTemplate</a></li>
<li><a href="#chainedkafkatransactionmanager">B.1.10. ChainedKafkaTransactionManager</a></li>
<li><a href="#migration-guide-from-2-0">B.1.11. Migration Guide from 2.0</a></li>
</ul>
</li>
<li><a href="#changes-between-1-3-and-2-0">B.2. Changes Between 1.3 and 2.0</a>
<ul class="sectlevel3">
<li><a href="#spring-framework-and-java-versions">B.2.1. Spring Framework and Java Versions</a></li>
<li><a href="#kafkalistener-changes-2">B.2.2. <code>@KafkaListener</code> Changes</a></li>
<li><a href="#message-listeners-2">B.2.3. Message Listeners</a></li>
<li><a href="#using-consumerawarerebalancelistener">B.2.4. Using <code>ConsumerAwareRebalanceListener</code></a></li>
</ul>
</li>
<li><a href="#changes-between-1-2-and-1-3">B.3. Changes Between 1.2 and 1.3</a>
<ul class="sectlevel3">
<li><a href="#support-for-transactions">B.3.1. Support for Transactions</a></li>
<li><a href="#support-for-headers">B.3.2. Support for Headers</a></li>
<li><a href="#creating-topics">B.3.3. Creating Topics</a></li>
<li><a href="#support-for-kafka-timestamps">B.3.4. Support for Kafka Timestamps</a></li>
<li><a href="#kafkalistener-changes-3">B.3.5. <code>@KafkaListener</code> Changes</a></li>
<li><a href="#embeddedkafka-annotation">B.3.6. <code>@EmbeddedKafka</code> Annotation</a></li>
<li><a href="#kerberos-configuration">B.3.7. Kerberos Configuration</a></li>
</ul>
</li>
<li><a href="#changes-between-1-1-and-1-2">B.4. Changes between 1.1 and 1.2</a></li>
<li><a href="#changes-between-1-0-and-1-1">B.5. Changes between 1.0 and 1.1</a>
<ul class="sectlevel3">
<li><a href="#kafka-client">B.5.1. Kafka Client</a></li>
<li><a href="#batch-listeners-2">B.5.2. Batch Listeners</a></li>
<li><a href="#null-payloads">B.5.3. Null Payloads</a></li>
<li><a href="#initial-offset">B.5.4. Initial Offset</a></li>
<li><a href="#seek-2">B.5.5. Seek</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>2.2.6.RELEASE</strong></p>
</div>
<div class="paragraph">
<p>&#169; 2016 - 2019 by Pivotal Software, Inc.</p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>1. Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring for Apache Kafka project applies core Spring concepts to the development of Kafka-based messaging solutions.
We provide a &#8220;template&#8221; as a high-level abstraction for sending messages.
We also provide support for Message-driven POJOs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="whats-new-part"><a class="anchor" href="#whats-new-part"></a>2. What&#8217;s new?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="spring-kafka-intro-new"><a class="anchor" href="#spring-kafka-intro-new"></a>2.1. What&#8217;s New in 2.2 Since 2.1</h3>
<div class="paragraph">
<p>This section covers the changes made from version 2.1 to version 2.2.</p>
</div>
<div class="sect3">
<h4 id="kafka-client-version"><a class="anchor" href="#kafka-client-version"></a>2.1.1. Kafka Client Version</h4>
<div class="paragraph">
<p>This version requires the 2.0.0 <code>kafka-clients</code> or higher.</p>
</div>
</div>
<div class="sect3">
<h4 id="class-and-package-changes"><a class="anchor" href="#class-and-package-changes"></a>2.1.2. Class and Package Changes</h4>
<div class="paragraph">
<p>The <code>ContainerProperties</code> class has been moved from <code>org.springframework.kafka.listener.config</code> to <code>org.springframework.kafka.listener</code>.</p>
</div>
<div class="paragraph">
<p>The <code>AckMode</code> enum has been moved from <code>AbstractMessageListenerContainer</code> to <code>ContainerProperties</code>.</p>
</div>
<div class="paragraph">
<p>The <code>setBatchErrorHandler()</code> and <code>setErrorHandler()</code> methods have been moved from <code>ContainerProperties</code> to both <code>AbstractMessageListenerContainer</code> and <code>AbstractKafkaListenerContainerFactory</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="after-rollback-processing"><a class="anchor" href="#after-rollback-processing"></a>2.1.3. After Rollback Processing</h4>
<div class="paragraph">
<p>A new <code>AfterRollbackProcessor</code> strategy is provided.
See <a href="#after-rollback">After-rollback Processor</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrentkafkalistenercontainerfactory-changes"><a class="anchor" href="#concurrentkafkalistenercontainerfactory-changes"></a>2.1.4. <code>ConcurrentKafkaListenerContainerFactory</code> Changes</h4>
<div class="paragraph">
<p>You can now use the <code>ConcurrentKafkaListenerContainerFactory</code> to create and configure any <code>ConcurrentMessageListenerContainer</code>, not only those for <code>@KafkaListener</code> annotations.
See <a href="#container-factory">Container factory</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="listener-container-changes"><a class="anchor" href="#listener-container-changes"></a>2.1.5. Listener Container Changes</h4>
<div class="paragraph">
<p>A new container property (<code>missingTopicsFatal</code>) has been added.
See <a href="#kafka-container">Using <code>KafkaMessageListenerContainer</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>A <code>ConsumerStoppedEvent</code> is now emitted when a consumer terminates.
See <a href="#thread-safety">Thread Safety</a> for more information.</p>
</div>
<div class="paragraph">
<p>Batch listeners can optionally receive the complete <code>ConsumerRecords&lt;?, ?&gt;</code> object instead of a <code>List&lt;ConsumerRecord&lt;?, ?&gt;</code>.
See <a href="#batch-listeners">Batch listeners</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultAfterRollbackProcessor</code> and <code>SeekToCurrentErrorHandler</code> can now recover (skip) records that keep failing, and, by default, does so after 10 failures.
They can be configured to publish failed records to a dead-letter topic.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2.4, the consumer&#8217;s group ID can be used while selecting the dead letter topic name.</p>
</div>
<div class="paragraph">
<p>See <a href="#after-rollback">After-rollback Processor</a>, <a href="#seek-to-current">Seek To Current Container Error Handlers</a>, and <a href="#dead-letters">Publishing Dead-letter Records</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>ConsumerStoppingEvent</code> has been added.
See <a href="#events">Events</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>SeekToCurrentErrorHandler</code> can now be configured to commit the offset of a recovered record when the container is configured with <code>AckMode.MANUAL_IMMEDIATE</code> (since 2.2.4).
See <a href="#seek-to-current">Seek To Current Container Error Handlers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafkalistener-changes"><a class="anchor" href="#kafkalistener-changes"></a>2.1.6. @KafkaListener Changes</h4>
<div class="paragraph">
<p>You can now override the <code>concurrency</code> and <code>autoStartup</code> properties of the listener container factory by setting properties on the annotation.
You can now add configuration to determine which headers (if any) are copied to a reply message.
See <a href="#kafka-listener-annotation"><code>@KafkaListener</code> Annotation</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now use <code>@KafkaListener</code> as a meta-annotation on your own annotations.
See <a href="#kafka-listener-meta"><code>@KafkaListener</code> as a Meta Annotation</a> for more information.</p>
</div>
<div class="paragraph">
<p>It is now easier to configure a <code>Validator</code> for <code>@Payload</code> validation.
See <a href="#kafka-validation"><code>@KafkaListener</code> <code>@Payload</code> Validation</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now specify kafka consumer properties directly on the annotation; these will override any properties with the same name defined in the consumer factory (since version 2.2.4).
See <a href="#annotation-properties">Annotation Properties</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="header-mapping-changes"><a class="anchor" href="#header-mapping-changes"></a>2.1.7. Header Mapping Changes</h4>
<div class="paragraph">
<p>Headers of type <code>MimeType</code> and <code>MediaType</code> are now mapped as simple strings in the <code>RecordHeader</code> value.
Previously, they were mapped as JSON and only <code>MimeType</code> was decoded.
<code>MediaType</code> could not be decoded.
They are now simple strings for interoperability.</p>
</div>
<div class="paragraph">
<p>Also, the <code>DefaultKafkaHeaderMapper</code> has a new <code>addToStringClasses</code> method, allowing the specification of types that should be mapped by using <code>toString()</code> instead of JSON.
See <a href="#headers">Message Headers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="embedded-kafka-changes"><a class="anchor" href="#embedded-kafka-changes"></a>2.1.8. Embedded Kafka Changes</h4>
<div class="paragraph">
<p>The <code>KafkaEmbedded</code> class and its <code>KafkaRule</code> interface have been deprecated in favor of the <code>EmbeddedKafkaBroker</code> and its JUnit 4 <code>EmbeddedKafkaRule</code> wrapper.
The <code>@EmbeddedKafka</code> annotation now populates an <code>EmbeddedKafkaBroker</code> bean instead of the deprecated <code>KafkaEmbedded</code>.
This change allows the use of <code>@EmbeddedKafka</code> in JUnit 5 tests.
The <code>@EmbeddedKafka</code> annotation now has the attribute <code>ports</code> to specify the port that populates the <code>EmbeddedKafkaBroker</code>.
See <a href="#testing">Testing Applications</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="jsonserializerdeserializer-enhancements"><a class="anchor" href="#jsonserializerdeserializer-enhancements"></a>2.1.9. JsonSerializer/Deserializer Enhancements</h4>
<div class="paragraph">
<p>You can now provide type mapping information by using producer and consumer properties.</p>
</div>
<div class="paragraph">
<p>New constructors are available on the deserializer to allow overriding the type header information with the supplied target type.</p>
</div>
<div class="paragraph">
<p>The <code>JsonDeserializer</code> now removes any type information headers by default.</p>
</div>
<div class="paragraph">
<p>You can now configure the <code>JsonDeserializer</code> to ignore type information headers by using a Kafka property (since 2.2.3).</p>
</div>
<div class="paragraph">
<p>See <a href="#serdes">Serialization, Deserialization, and Message Conversion</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafka-streams-changes"><a class="anchor" href="#kafka-streams-changes"></a>2.1.10. Kafka Streams Changes</h4>
<div class="paragraph">
<p>The streams configuration bean must now be a <code>KafkaStreamsConfiguration</code> object instead of a <code>StreamsConfig</code> object.</p>
</div>
<div class="paragraph">
<p>The <code>StreamsBuilderFactoryBean</code> has been moved from package <code>&#8230;&#8203;core</code> to <code>&#8230;&#8203;config</code>.</p>
</div>
<div class="paragraph">
<p>The <code>KafkaStreamBrancher</code> has been introduced for better end-user experience when conditional branches are built on top of <code>KStream</code> instance.</p>
</div>
<div class="paragraph">
<p>See <a href="#kafka-streams">Kafka Streams Support</a> and <a href="#streams-config">Configuration</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="transactional-id"><a class="anchor" href="#transactional-id"></a>2.1.11. Transactional ID</h4>
<div class="paragraph">
<p>When a transaction is started by the listener container, the <code>transactional.id</code> is now the <code>transactionIdPrefix</code> appended with <code>&lt;group.id&gt;.&lt;topic&gt;.&lt;partition&gt;</code>.
This change allows proper fencing of zombies, <a href="https://www.confluent.io/blog/transactions-apache-kafka/">as described here</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>3. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This first part of the reference documentation is a high-level overview of Spring for Apache Kafka and the underlying concepts and some code snippets that can help you get up and running as quickly as possible.</p>
</div>
<div class="sect2">
<h3 id="quick-tour"><a class="anchor" href="#quick-tour"></a>3.1. Quick Tour for the Impatient</h3>
<div class="paragraph">
<p>This is the five-minute tour to get started with Spring Kafka.</p>
</div>
<div class="paragraph">
<p>Prerequisites: You must install and run Apache Kafka.
Then you must grab the spring-kafka JAR and all of its dependencies.
The easiest way to do that is to declare a dependency in your build tool.
The following example shows how to do so with Maven:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
  &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to do so with Gradle:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile 'org.springframework.kafka:spring-kafka:2.2.6.RELEASE'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="compatibility"><a class="anchor" href="#compatibility"></a>3.1.1. Compatibility</h4>
<div class="paragraph">
<p>This quick tour works with the following versions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Kafka Clients 2.0.0</p>
</li>
<li>
<p>Spring Framework 5.1.x</p>
</li>
<li>
<p>Minimum Java version: 8</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="a-very-very-quick-example"><a class="anchor" href="#a-very-very-quick-example"></a>3.1.2. A Very, Very Quick Example</h4>
<div class="paragraph">
<p>As the following example shows, you can use plain Java to send and receive a message:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testAutoCommit() throws Exception {
    logger.info("Start auto");
    ContainerProperties containerProps = new ContainerProperties("topic1", "topic2");
    final CountDownLatch latch = new CountDownLatch(4);
    containerProps.setMessageListener(new MessageListener&lt;Integer, String&gt;() {

        @Override
        public void onMessage(ConsumerRecord&lt;Integer, String&gt; message) {
            logger.info("received: " + message);
            latch.countDown();
        }

    });
    KafkaMessageListenerContainer&lt;Integer, String&gt; container = createContainer(containerProps);
    container.setBeanName("testAuto");
    container.start();
    Thread.sleep(1000); // wait a bit for the container to start
    KafkaTemplate&lt;Integer, String&gt; template = createTemplate();
    template.setDefaultTopic(topic1);
    template.sendDefault(0, "foo");
    template.sendDefault(2, "bar");
    template.sendDefault(0, "baz");
    template.sendDefault(2, "qux");
    template.flush();
    assertTrue(latch.await(60, TimeUnit.SECONDS));
    container.stop();
    logger.info("Stop auto");

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private KafkaMessageListenerContainer&lt;Integer, String&gt; createContainer(
                        ContainerProperties containerProps) {
    Map&lt;String, Object&gt; props = consumerProps();
    DefaultKafkaConsumerFactory&lt;Integer, String&gt; cf =
                            new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(props);
    KafkaMessageListenerContainer&lt;Integer, String&gt; container =
                            new KafkaMessageListenerContainer&lt;&gt;(cf, containerProps);
    return container;
}

private KafkaTemplate&lt;Integer, String&gt; createTemplate() {
    Map&lt;String, Object&gt; senderProps = senderProps();
    ProducerFactory&lt;Integer, String&gt; pf =
              new DefaultKafkaProducerFactory&lt;Integer, String&gt;(senderProps);
    KafkaTemplate&lt;Integer, String&gt; template = new KafkaTemplate&lt;&gt;(pf);
    return template;
}

private Map&lt;String, Object&gt; consumerProps() {
    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
    props.put(ConsumerConfig.GROUP_ID_CONFIG, group);
    props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);
    props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, "100");
    props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, "15000");
    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class);
    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
    return props;
}

private Map&lt;String, Object&gt; senderProps() {
    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
    props.put(ProducerConfig.RETRIES_CONFIG, 0);
    props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);
    props.put(ProducerConfig.LINGER_MS_CONFIG, 1);
    props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);
    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class);
    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
    return props;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="with-java-configuration"><a class="anchor" href="#with-java-configuration"></a>3.1.3. With Java Configuration</h4>
<div class="paragraph">
<p>You can do the same work as appears in the previous example with Spring configuration in Java.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private Listener listener;

@Autowired
private KafkaTemplate&lt;Integer, String&gt; template;

@Test
public void testSimple() throws Exception {
    template.send("annotated1", 0, "foo");
    template.flush();
    assertTrue(this.listener.latch1.await(10, TimeUnit.SECONDS));
}

@Configuration
@EnableKafka
public class Config {

    @Bean
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt;
                        kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
                                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }

    @Bean
    public ConsumerFactory&lt;Integer, String&gt; consumerFactory() {
        return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs());
    }

    @Bean
    public Map&lt;String, Object&gt; consumerConfigs() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, embeddedKafka.getBrokersAsString());
        ...
        return props;
    }

    @Bean
    public Listener listener() {
        return new Listener();
    }

    @Bean
    public ProducerFactory&lt;Integer, String&gt; producerFactory() {
        return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());
    }

    @Bean
    public Map&lt;String, Object&gt; producerConfigs() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, embeddedKafka.getBrokersAsString());
        ...
        return props;
    }

    @Bean
    public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;Integer, String&gt;(producerFactory());
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Listener {

    private final CountDownLatch latch1 = new CountDownLatch(1);

    @KafkaListener(id = "foo", topics = "annotated1")
    public void listen1(String foo) {
        this.latch1.countDown();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="even-quicker-with-spring-boot"><a class="anchor" href="#even-quicker-with-spring-boot"></a>3.1.4. Even Quicker, with Spring Boot</h4>
<div class="paragraph">
<p>Spring Boot can make things even simpler.
The following Spring Boot application sends three messages to a topic, receives them, and stops:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application implements CommandLineRunner {

    public static Logger logger = LoggerFactory.getLogger(Application.class);

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args).close();
    }

    @Autowired
    private KafkaTemplate&lt;String, String&gt; template;

    private final CountDownLatch latch = new CountDownLatch(3);

    @Override
    public void run(String... args) throws Exception {
        this.template.send("myTopic", "foo1");
        this.template.send("myTopic", "foo2");
        this.template.send("myTopic", "foo3");
        latch.await(60, TimeUnit.SECONDS);
        logger.info("All received");
    }

    @KafkaListener(topics = "myTopic")
    public void listen(ConsumerRecord&lt;?, ?&gt; cr) throws Exception {
        logger.info(cr.toString());
        latch.countDown();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Boot takes care of most of the configuration.
When we use a local broker, the only properties we need are the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. application.properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.kafka.consumer.group-id=foo
spring.kafka.consumer.auto-offset-reset=earliest</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We need the first property because we are using group management to assign topic partitions to consumers, so we need a group.
The second property ensures the new consumer group gets the messages we sent, because the container might start after the sends have completed.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="anchor" href="#reference"></a>4. Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation details the various components that comprise Spring for Apache Kafka.
The <a href="#kafka">main chapter</a> covers the core classes to develop a Kafka application with Spring.</p>
</div>
<div class="sect2">
<h3 id="kafka"><a class="anchor" href="#kafka"></a>4.1. Using Spring for Apache Kafka</h3>
<div class="paragraph">
<p>This section offers detailed explanations of the various concerns that impact using Spring for Apache Kafka.
For a quick but less detailed introduction, see <a href="#quick-tour">Quick Tour for the Impatient</a>.</p>
</div>
<div class="sect3">
<h4 id="configuring-topics"><a class="anchor" href="#configuring-topics"></a>4.1.1. Configuring Topics</h4>
<div class="paragraph">
<p>If you define a <code>KafkaAdmin</code> bean in your application context, it can automatically add topics to the broker.
To do so, you can add a <code>NewTopic</code> <code>@Bean</code> for each topic to the application context.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaAdmin admin() {
    Map&lt;String, Object&gt; configs = new HashMap&lt;&gt;();
    configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,
            StringUtils.arrayToCommaDelimitedString(embeddedKafka().getBrokerAddresses()));
    return new KafkaAdmin(configs);
}

@Bean
public NewTopic topic1() {
    return new NewTopic("thing1", 10, (short) 2);
}

@Bean
public NewTopic topic2() {
    return new NewTopic("thing2", 10, (short) 2);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, if the broker is not available, a message is logged, but the context continues to load.
You can programmatically invoke the admin&#8217;s <code>initialize()</code> method to try again later.
If you wish this condition to be considered fatal, set the admin&#8217;s <code>fatalIfBrokerNotAvailable</code> property to <code>true</code>.
The context then fails to initialize.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the broker supports it (1.0.0 or higher), the admin increases the number of partitions if it is found that an existing topic has fewer partitions than the <code>NewTopic.numPartitions</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more advanced features, such as assigning partitions to replicas, you can use the <code>AdminClient</code> directly.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private KafkaAdmin admin;

...

    AdminClient client = AdminClient.create(admin.getConfig());
    ...
    client.close();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sending-messages"><a class="anchor" href="#sending-messages"></a>4.1.2. Sending Messages</h4>
<div class="paragraph">
<p>This section covers how to send messages.</p>
</div>
<div class="sect4">
<h5 id="kafka-template"><a class="anchor" href="#kafka-template"></a>Using <code>KafkaTemplate</code></h5>
<div class="paragraph">
<p>This section covers how to use <code>KafkaTemplate</code> to send messages.</p>
</div>
<div class="sect5">
<h6 id="overview"><a class="anchor" href="#overview"></a>Overview</h6>
<div class="paragraph">
<p>The <code>KafkaTemplate</code> wraps a producer and provides convenience methods to send data to Kafka topics.
The following listing shows the relevant methods from <code>KafkaTemplate</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, Long timestamp, K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, Long timestamp, K key, V data);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(ProducerRecord&lt;K, V&gt; record);

ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(Message&lt;?&gt; message);

Map&lt;MetricName, ? extends Metric&gt; metrics();

List&lt;PartitionInfo&gt; partitionsFor(String topic);

&lt;T&gt; T execute(ProducerCallback&lt;K, V, T&gt; callback);

// Flush the producer.

void flush();

interface ProducerCallback&lt;K, V, T&gt; {

    T doInKafka(Producer&lt;K, V&gt; producer);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/core/KafkaTemplate.html">Javadoc</a> for more detail.</p>
</div>
<div class="paragraph">
<p>The <code>sendDefault</code> API requires that a default topic has been provided to the template.</p>
</div>
<div class="paragraph">
<p>The API takes in a <code>timestamp</code> as a parameter and stores this timestamp in the record.
How the user-provided timestamp is stored depends on the timestamp type configured on the Kafka topic.
If the topic is configured to use <code>CREATE_TIME</code>, the user specified timestamp is recorded (or generated if not specified).
If the topic is configured to use <code>LOG_APPEND_TIME</code>, the user-specified timestamp is ignored and the broker adds in the local broker time.</p>
</div>
<div class="paragraph">
<p>The <code>metrics</code> and <code>partitionsFor</code> methods delegate to the same methods on the underlying <a href="https://kafka.apache.org/0101/javadoc/org/apache/kafka/clients/producer/Producer.html"><code>Producer</code></a>.
The <code>execute</code> method provides direct access to the underlying <a href="https://kafka.apache.org/0101/javadoc/org/apache/kafka/clients/producer/Producer.html"><code>Producer</code></a>.</p>
</div>
<div class="paragraph">
<p>To use the template, you can configure a producer factory and provide it in the template&#8217;s constructor.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ProducerFactory&lt;Integer, String&gt; producerFactory() {
    return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());
}

@Bean
public Map&lt;String, Object&gt; producerConfigs() {
    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
    // See https://kafka.apache.org/documentation/#producerconfigs for more properties
    return props;
}

@Bean
public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() {
    return new KafkaTemplate&lt;Integer, String&gt;(producerFactory());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure the template by using standard <code>&lt;bean/&gt;</code> definitions.</p>
</div>
<div class="paragraph">
<p>Then, to use the template, you can invoke one of its methods.</p>
</div>
<div class="paragraph">
<p>When you use the methods with a <code>Message&lt;?&gt;</code> parameter, the topic, partition, and key information is provided in a message header that includes the following items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KafkaHeaders.TOPIC</code></p>
</li>
<li>
<p><code>KafkaHeaders.PARTITION_ID</code></p>
</li>
<li>
<p><code>KafkaHeaders.MESSAGE_KEY</code></p>
</li>
<li>
<p><code>KafkaHeaders.TIMESTAMP</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload is the data.</p>
</div>
<div class="paragraph">
<p>Optionally, you can configure the <code>KafkaTemplate</code> with a <code>ProducerListener</code> to get an asynchronous callback with the results of the send (success or failure) instead of waiting for the <code>Future</code> to complete.
The following listing shows the definition of the <code>ProducerListener</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ProducerListener&lt;K, V&gt; {

    void onSuccess(String topic, Integer partition, K key, V value, RecordMetadata recordMetadata);

    void onError(String topic, Integer partition, K key, V value, Exception exception);

    boolean isInterestedInSuccess();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the template is configured with a <code>LoggingProducerListener</code>, which logs errors and does nothing when the send is successful.</p>
</div>
<div class="paragraph">
<p><code>onSuccess</code> is called only if <code>isInterestedInSuccess</code> returns <code>true</code>.</p>
</div>
<div class="paragraph">
<p>For convenience, the abstract <code>ProducerListenerAdapter</code> is provided in case you want to implement only one of the methods.
It returns <code>false</code> for <code>isInterestedInSuccess</code>.</p>
</div>
<div class="paragraph">
<p>Notice that the send methods return a <code>ListenableFuture&lt;SendResult&gt;</code>.
You can register a callback with the listener to receive the result of the send asynchronously.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future = template.send("something");
future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() {

    @Override
    public void onSuccess(SendResult&lt;Integer, String&gt; result) {
        ...
    }

    @Override
    public void onFailure(Throwable ex) {
        ...
    }

});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>SendResult</code> has two properties, a <code>ProducerRecord</code> and <code>RecordMetadata</code>.
See the Kafka API documentation for information about those objects.</p>
</div>
<div class="paragraph">
<p>If you wish to block the sending thread to await the result, you can invoke the future&#8217;s <code>get()</code> method.
You may wish to invoke <code>flush()</code> before waiting or, for convenience, the template has a constructor with an <code>autoFlush</code> parameter that causes the template to <code>flush()</code> on each send.
Note, however, that flushing likely significantly reduces performance.</p>
</div>
</div>
<div class="sect5">
<h6 id="examples"><a class="anchor" href="#examples"></a>Examples</h6>
<div class="paragraph">
<p>This section shows examples of sending messages to Kafka:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Non Blocking (Async)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void sendToKafka(final MyOutputData data) {
    final ProducerRecord&lt;String, String&gt; record = createRecord(data);

    ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future = template.send(record);
    future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() {

        @Override
        public void onSuccess(SendResult&lt;Integer, String&gt; result) {
            handleSuccess(data);
        }

        @Override
        public void onFailure(Throwable ex) {
            handleFailure(data, record, ex);
        }

    });
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Blocking (Sync)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void sendToKafka(final MyOutputData data) {
    final ProducerRecord&lt;String, String&gt; record = createRecord(data);

    try {
        template.send(record).get(10, TimeUnit.SECONDS);
        handleSuccess(data);
    }
    catch (ExecutionException e) {
        handleFailure(data, record, e.getCause());
    }
    catch (TimeoutException | InterruptedException e) {
        handleFailure(data, record, e);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transactions"><a class="anchor" href="#transactions"></a>Transactions</h5>
<div class="paragraph">
<p>This section describes how Spring for Apache Kafka supports transactions.</p>
</div>
<div class="sect5">
<h6 id="overview-2"><a class="anchor" href="#overview-2"></a>Overview</h6>
<div class="paragraph">
<p>The 0.11.0.0 client library added support for transactions.
Spring for Apache Kafka adds support in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KafkaTransactionManager</code>: Used with normal Spring transaction support (<code>@Transactional</code>, <code>TransactionTemplate</code> etc).</p>
</li>
<li>
<p>Transactional <code>KafkaMessageListenerContainer</code></p>
</li>
<li>
<p>Local transactions with <code>KafkaTemplate</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Transactions are enabled by providing the <code>DefaultKafkaProducerFactory</code> with a <code>transactionIdPrefix</code>.
In that case, instead of managing a single shared <code>Producer</code>, the factory maintains a cache of transactional producers.
When the user calls <code>close()</code> on a producer, it is returned to the cache for reuse instead of actually being closed.
The <code>transactional.id</code> property of each producer is <code>transactionIdPrefix</code> + <code>n</code>, where <code>n</code> starts with <code>0</code> and is incremented for each new producer, unless the transaction is started by a listener container with a record-based listener.
In that case, the <code>transactional.id</code> is <code>&lt;transactionIdPrefix&gt;.&lt;group.id&gt;.&lt;topic&gt;.&lt;partition&gt;</code>.
This is to properly support fencing zombies, <a href="https://www.confluent.io/blog/transactions-apache-kafka/">as described here</a>.
This new behavior was added in versions 1.3.7, 2.0.6, 2.1.10, and 2.2.0.
If you wish to revert to the previous behavior, you can set the <code>producerPerConsumerPartition</code> property on the <code>DefaultKafkaProducerFactory</code> to <code>false</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While transactions are supported with batch listeners, zombie fencing cannot be supported because a batch may contain records from multiple topics or partitions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="using-kafkatransactionmanager"><a class="anchor" href="#using-kafkatransactionmanager"></a>Using <code>KafkaTransactionManager</code></h6>
<div class="paragraph">
<p>The <code>KafkaTransactionManager</code> is an implementation of Spring Framework&#8217;s <code>PlatformTransactionManager</code>.
It is provided with a reference to the producer factory in its constructor.
If you provide a custom producer factory, it must support transactions.
See <code>ProducerFactory.transactionCapable()</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>KafkaTransactionManager</code> with normal Spring transaction support (<code>@Transactional</code>, <code>TransactionTemplate</code>, and others).
If a transaction is active, any <code>KafkaTemplate</code> operations performed within the scope of the transaction use the transaction&#8217;s <code>Producer</code>.
The manager commits or rolls back the transaction, depending on success or failure.
You must configure the <code>KafkaTemplate</code> to use the same <code>ProducerFactory</code> as the transaction manager.</p>
</div>
</div>
<div class="sect5">
<h6 id="transactional-listener-container-and-exactly-once-processing"><a class="anchor" href="#transactional-listener-container-and-exactly-once-processing"></a>Transactional Listener Container and Exactly Once Processing</h6>
<div class="paragraph">
<p>You can provide a listener container with a <code>KafkaAwareTransactionManager</code> instance.
When so configured, the container starts a transaction before invoking the listener.
Any <code>KafkaTemplate</code> operations performed by the listener participate in the transaction.
If the listener successfully processes the record (or multiple records, when using a <code>BatchMessageListener</code>), the container sends the offsets to the transaction by using <code>producer.sendOffsetsToTransaction()</code>), before the transaction manager commits the transaction.
If the listener throws an exception, the transaction is rolled back and the consumer is repositioned so that the rolled-back record(s) can be retrieved on the next poll.
See <a href="#after-rollback">After-rollback Processor</a> for more information and for handling records that repeatedly fail.</p>
</div>
</div>
<div class="sect5">
<h6 id="transaction-synchronization"><a class="anchor" href="#transaction-synchronization"></a>Transaction Synchronization</h6>
<div class="paragraph">
<p>If you need to synchronize a Kafka transaction with some other transaction, configure the listener container with the appropriate transaction manager (one that supports synchronization, such as the <code>DataSourceTransactionManager</code>).
Any operations performed on a transactional <code>KafkaTemplate</code> from the listener participate in a single transaction.
The Kafka transaction is committed (or rolled back) immediately after the controlling transaction.
Before exiting the listener, you should invoke one of the template&#8217;s <code>sendOffsetsToTransaction</code> methods (unless you use a <a href="#chained-transaction-manager"><code>ChainedKafkaTransactionManager</code></a>).
For convenience, the listener container binds its consumer group ID to the thread, so, generally, you can use the first method.
The following listing shows the two method signatures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void sendOffsetsToTransaction(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets);

void sendOffsetsToTransaction(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, String consumerGroupId);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the first signature of the <code>sendOffsetsToTransaction</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
KafkaMessageListenerContainer container(ConsumerFactory&lt;String, String&gt; cf,
            final KafkaTemplate template) {
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setTransactionManager(new SomeOtherTransactionManager());
    ...
    props.setMessageListener((MessageListener&lt;String, String&gt;) m -&gt; {
        template.send("foo", "bar");
        template.send("baz", "qux");
        template.sendOffsetsToTransaction(
            Collections.singletonMap(new TopicPartition(m.topic(), m.partition()),
                new OffsetAndMetadata(m.offset() + 1)));
    });
    return new KafkaMessageListenerContainer&lt;&gt;(cf, props);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The offset to be committed is one greater than the offset of the records processed by the listener.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You should call this should only when you use transaction synchronization.
When a listener container is configured to use a <code>KafkaTransactionManager</code>, it takes care of sending the offsets to the transaction.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="chained-transaction-manager"><a class="anchor" href="#chained-transaction-manager"></a>Using <code>ChainedKafkaTransactionManager</code></h6>
<div class="paragraph">
<p>The <code>ChainedKafkaTransactionManager</code> was introduced in version 2.1.3.
This is a subclass of <code>ChainedTransactionManager</code> that can have exactly one <code>KafkaTransactionManager</code>.
Since it is a <code>KafkaAwareTransactionManager</code>, the container can send the offsets to the transaction in the same way as when the container is configured with a simple <code>KafkaTransactionManager</code>.
This provides another mechanism for synchronizing transactions without having to send the offsets to the transaction in the listener code.
You should chain your transaction managers in the desired order and provide the <code>ChainedTransactionManager</code> in the <code>ContainerProperties</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="kafkatemplate-local-transactions"><a class="anchor" href="#kafkatemplate-local-transactions"></a><code>KafkaTemplate</code> Local Transactions</h6>
<div class="paragraph">
<p>You can use the <code>KafkaTemplate</code> to execute a series of operations within a local transaction.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean result = template.executeInTransaction(t -&gt; {
    t.sendDefault("thing1", "thing2");
    t.sendDefault("cat", "hat");
    return true;
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The argument in the callback is the template itself (<code>this</code>).
If the callback exits normally, the transaction is committed.
If an exception is thrown, the transaction is rolled back.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If there is a <code>KafkaTransactionManager</code> (or synchronized) transaction in process, it is not used.
Instead, a new "nested" transaction is used.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="replying-template"><a class="anchor" href="#replying-template"></a>Using <code>ReplyingKafkaTemplate</code></h5>
<div class="paragraph">
<p>Version 2.1.3 introduced a subclass of <code>KafkaTemplate</code> to provide request/reply semantics.
The class is named <code>ReplyingKafkaTemplate</code> and has one method (in addition to those in the superclass).
The following listing shows the method&#8217;s signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RequestReplyFuture&lt;K, V, R&gt; sendAndReceive(ProducerRecord&lt;K, V&gt; record);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result is a <code>ListenableFuture</code> that is asynchronously populated with the result (or an exception, for a timeout).
The result also has a <code>sendFuture</code> property, which is the result of calling <code>KafkaTemplate.send()</code>.
You can use this future to determine the result of the send operation.</p>
</div>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to use the feature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class KRequestingApplication {

    public static void main(String[] args) {
        SpringApplication.run(KRequestingApplication.class, args).close();
    }

    @Bean
    public ApplicationRunner runner(ReplyingKafkaTemplate&lt;String, String, String&gt; template) {
        return args -&gt; {
            ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("kRequests", "foo");
            RequestReplyFuture&lt;String, String, String&gt; replyFuture = template.sendAndReceive(record);
            SendResult&lt;String, String&gt; sendResult = replyFuture.getSendFuture().get();
            System.out.println("Sent ok: " + sendResult.getRecordMetadata());
            ConsumerRecord&lt;String, String&gt; consumerRecord = replyFuture.get();
            System.out.println("Return value: " + consumerRecord.value());
        };
    }

    @Bean
    public ReplyingKafkaTemplate&lt;String, String, String&gt; replyingTemplate(
            ProducerFactory&lt;String, String&gt; pf,
            ConcurrentMessageListenerContainer&lt;Long, String&gt; repliesContainer) {

        return new ReplyingKafkaTemplate&lt;&gt;(pf, repliesContainer);
    }

    @Bean
    public ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer(
            ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; containerFactory) {

        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer =
                containerFactory.createContainer("replies");
        repliesContainer.getContainerProperties().setGroupId("repliesGroup");
        repliesContainer.setAutoStartup(false);
        return repliesContainer;
    }

    @Bean
    public NewTopic kRequests() {
        return new NewTopic("kRequests", 10, (short) 2);
    }

    @Bean
    public NewTopic kReplies() {
        return new NewTopic("kReplies", 10, (short) 2);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that we can use Boot&#8217;s auto-configured container factory to create the reply container.</p>
</div>
<div class="paragraph">
<p>The template sets a header called <code>KafkaHeaders.CORRELATION_ID</code>, which must be echoed back by the server side.</p>
</div>
<div class="paragraph">
<p>In this case, the following <code>@KafkaListener</code> application responds:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class KReplyingApplication {

    public static void main(String[] args) {
        SpringApplication.run(KReplyingApplication.class, args);
    }

    @KafkaListener(id="server", topics = "kRequests")
    @SendTo // use default replyTo expression
    public String listen(String in) {
        System.out.println("Server received: " + in);
        return in.toUpperCase();
    }

    @Bean
    public NewTopic kRequests() {
        return new NewTopic("kRequests", 10, (short) 2);
    }

    @Bean // not required if Jackson is on the classpath
    public MessagingMessageConverter simpleMapperConverter() {
        MessagingMessageConverter messagingMessageConverter = new MessagingMessageConverter();
        messagingMessageConverter.setHeaderMapper(new SimpleKafkaHeaderMapper());
        return messagingMessageConverter;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@KafkaListener</code> infrastructure echoes the correlation ID and determines the reply topic.</p>
</div>
<div class="paragraph">
<p>See <a href="#annotation-send-to">Forwarding Listener Results using <code>@SendTo</code></a> for more information about sending replies.
The template uses the default header <code>KafKaHeaders.REPLY_TOPIC</code> to indicate the topic to which the reply goes.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the template tries to detect the reply topic or partition from the configured reply container.
If the container is configured to listen to a single topic or a single <code>TopicPartitionInitialOffset</code>, it is used to set the reply headers.
If the container is configured otherwise, the user must set up the reply headers.
In this case, an <code>INFO</code> log message is written during initialization.
The following example uses <code>KafkaHeaders.REPLY_TOPIC</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">record.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, "kReplies".getBytes()));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you configure with a single reply <code>TopicPartitionInitialOffset</code>, you can use the same reply topic for multiple templates, as long as each instance listens on a different partition.
When configuring with a single reply topic, each instance must use a different <code>group.id</code>.
In this case, all instances receive each reply, but only the instance that sent the request finds the correlation ID.
This may be useful for auto-scaling, but with the overhead of additional network traffic and the small cost of discarding each unwanted reply.
When you use this setting, we recommend that you set the template&#8217;s <code>sharedReplyTopic</code> to <code>true</code>, which reduces the logging level of unexpected replies to DEBUG instead of the default ERROR.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have multiple client instances and you do not configure them as discussed in the preceding paragraph, each instance needs a dedicated reply topic.
An alternative is to set the <code>KafkaHeaders.REPLY_PARTITION</code> and use a dedicated partition for each instance.
The <code>Header</code> contains a four-byte int (big-endian).
The server must use this header to route the reply to the correct topic (<code>@KafkaListener</code> does this).
In this case, though, the reply container must not use Kafka&#8217;s group management feature and must be configured to listen on a fixed partition (by using a <code>TopicPartitionInitialOffset</code> in its <code>ContainerProperties</code> constructor).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>DefaultKafkaHeaderMapper</code> requires Jackson to be on the classpath (for the <code>@KafkaListener</code>).
If it is not available, the message converter has no header mapper, so you must configure a <code>MessagingMessageConverter</code> with a <code>SimpleKafkaHeaderMapper</code>, as shown earlier.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="receiving-messages"><a class="anchor" href="#receiving-messages"></a>4.1.3. Receiving Messages</h4>
<div class="paragraph">
<p>You can receive messages by configuring a <code>MessageListenerContainer</code> and providing a message listener or by
using the <code>@KafkaListener</code> annotation.</p>
</div>
<div class="sect4">
<h5 id="message-listeners"><a class="anchor" href="#message-listeners"></a>Message Listeners</h5>
<div class="paragraph">
<p>When you use a <a href="#message-listener-container">message listener container</a>, you must provide a listener to receive data.
There are currently eight supported interfaces for message listeners.
The following listing shows these interfaces:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageListener&lt;K, V&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    void onMessage(ConsumerRecord&lt;K, V&gt; data);

}

public interface AcknowledgingMessageListener&lt;K, V&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    void onMessage(ConsumerRecord&lt;K, V&gt; data, Acknowledgment acknowledgment);

}

public interface ConsumerAwareMessageListener&lt;K, V&gt; extends MessageListener&lt;K, V&gt; { <i class="conum" data-value="3"></i><b>(3)</b>

    void onMessage(ConsumerRecord&lt;K, V&gt; data, Consumer&lt;?, ?&gt; consumer);

}

public interface AcknowledgingConsumerAwareMessageListener&lt;K, V&gt; extends MessageListener&lt;K, V&gt; { <i class="conum" data-value="4"></i><b>(4)</b>

    void onMessage(ConsumerRecord&lt;K, V&gt; data, Acknowledgment acknowledgment, Consumer&lt;?, ?&gt; consumer);

}

public interface BatchMessageListener&lt;K, V&gt; { <i class="conum" data-value="5"></i><b>(5)</b>

    void onMessage(List&lt;ConsumerRecord&lt;K, V&gt;&gt; data);

}

public interface BatchAcknowledgingMessageListener&lt;K, V&gt; { <i class="conum" data-value="6"></i><b>(6)</b>

    void onMessage(List&lt;ConsumerRecord&lt;K, V&gt;&gt; data, Acknowledgment acknowledgment);

}

public interface BatchConsumerAwareMessageListener&lt;K, V&gt; extends BatchMessageListener&lt;K, V&gt; { <i class="conum" data-value="7"></i><b>(7)</b>

    void onMessage(List&lt;ConsumerRecord&lt;K, V&gt;&gt; data, Consumer&lt;?, ?&gt; consumer);

}

public interface BatchAcknowledgingConsumerAwareMessageListener&lt;K, V&gt; extends BatchMessageListener&lt;K, V&gt; { <i class="conum" data-value="8"></i><b>(8)</b>

    void onMessage(List&lt;ConsumerRecord&lt;K, V&gt;&gt; data, Acknowledgment acknowledgment, Consumer&lt;?, ?&gt; consumer);

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use this interface for processing individual <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using auto-commit or one of the container-managed <a href="#committing-offsets">commit methods</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use this interface for processing individual <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using one of the manual <a href="#committing-offsets">commit methods</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Use this interface for processing individual <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using auto-commit or one of the container-managed <a href="#committing-offsets">commit methods</a>.
Access to the <code>Consumer</code> object is provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Use this interface for processing individual <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using one of the manual <a href="#committing-offsets">commit methods</a>.
Access to the <code>Consumer</code> object is provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Use this interface for processing all <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using auto-commit or one of the container-managed <a href="#committing-offsets">commit methods</a>.
<code>AckMode.RECORD</code> is not supported when you use this interface, since the listener is given the complete batch.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Use this interface for processing all <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using one of the manual <a href="#committing-offsets">commit methods</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Use this interface for processing all <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using auto-commit or one of the container-managed <a href="#committing-offsets">commit methods</a>.
<code>AckMode.RECORD</code> is not supported when you use this interface, since the listener is given the complete batch.
Access to the <code>Consumer</code> object is provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Use this interface for processing all <code>ConsumerRecord</code> instances received from the Kafka consumer <code>poll()</code> operation when using one of the manual <a href="#committing-offsets">commit methods</a>.
Access to the <code>Consumer</code> object is provided.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>Consumer</code> object is not thread-safe.
You must only invoke its methods on the thread that calls the listener.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="message-listener-container"><a class="anchor" href="#message-listener-container"></a>Message Listener Containers</h5>
<div class="paragraph">
<p>Two <code>MessageListenerContainer</code> implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KafkaMessageListenerContainer</code></p>
</li>
<li>
<p><code>ConcurrentMessageListenerContainer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>KafkaMessageListenerContainer</code> receives all message from all topics or partitions on a single thread.
The <code>ConcurrentMessageListenerContainer</code> delegates to one or more <code>KafkaMessageListenerContainer</code> instances to provide multi-threaded consumption.</p>
</div>
<div class="sect5">
<h6 id="kafka-container"><a class="anchor" href="#kafka-container"></a>Using <code>KafkaMessageListenerContainer</code></h6>
<div class="paragraph">
<p>The following constructors are available:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public KafkaMessageListenerContainer(ConsumerFactory&lt;K, V&gt; consumerFactory,
                    ContainerProperties containerProperties)

public KafkaMessageListenerContainer(ConsumerFactory&lt;K, V&gt; consumerFactory,
                    ContainerProperties containerProperties,
                    TopicPartitionInitialOffset... topicPartitions)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each takes a <code>ConsumerFactory</code> and information about topics and partitions, as well as other configuration in a <code>ContainerProperties</code> object.
The second constructor is used by the <code>ConcurrentMessageListenerContainer</code> (<a href="#using-ConcurrentMessageListenerContainer">described later</a>) to distribute <code>TopicPartitionInitialOffset</code> across the consumer instances.
<code>ContainerProperties</code> has the following constructors:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public ContainerProperties(TopicPartitionInitialOffset... topicPartitions)

public ContainerProperties(String... topics)

public ContainerProperties(Pattern topicPattern)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first constructor takes an array of <code>TopicPartitionInitialOffset</code> arguments to explicitly instruct the container about which partitions to use (using the consumer <code>assign()</code> method) and with an optional initial offset.
A positive value is an absolute offset by default.
A negative value is relative to the current last offset within a partition by default.
A constructor for <code>TopicPartitionInitialOffset</code> that takes an additional <code>boolean</code> argument is provided.
If this is <code>true</code>, the initial offsets (positive or negative) are relative to the current position for this consumer.
The offsets are applied when the container is started.
The second takes an array of topics, and Kafka allocates the partitions based on the <code>group.id</code> property&#8201;&#8212;&#8201;distributing partitions across the group.
The third uses a regex <code>Pattern</code> to select the topics.</p>
</div>
<div class="paragraph">
<p>To assign a <code>MessageListener</code> to a container, you can use the <code>ContainerProps.setMessageListener</code> method when creating the Container.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ContainerProperties containerProps = new ContainerProperties("topic1", "topic2");
containerProps.setMessageListener(new MessageListener&lt;Integer, String&gt;() {
    ...
});
DefaultKafkaConsumerFactory&lt;Integer, String&gt; cf =
                        new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(consumerProps());
KafkaMessageListenerContainer&lt;Integer, String&gt; container =
                        new KafkaMessageListenerContainer&lt;&gt;(cf, containerProps);
return container;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Refer to the <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/listener/ContainerProperties.html">Javadoc</a> for <code>ContainerProperties</code> for more information about the various properties that you can set.</p>
</div>
<div class="paragraph">
<p>Since version 2.1.1, a new property called <code>logContainerConfig</code> is available.
When <code>true</code> and <code>INFO</code> logging is enabled each listener container writes a log message summarizing its configuration properties.</p>
</div>
<div class="paragraph">
<p>By default, logging of topic offset commits is performed at the <code>DEBUG</code> logging level.
Starting with version 2.1.2, a property in <code>ContainerProperties</code> called <code>commitLogLevel</code> lets you specify the log level for these messages.
For example, to change the log level to <code>INFO</code>, you can use <code>containerProperties.setCommitLogLevel(LogIfLevelEnabled.Level.INFO);</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, a new container property called <code>missingTopicsFatal</code> has been added (default: <code>true</code>).
This prevents the container from starting if any of the configured topics are not present on the broker.
It does not apply if the container is configured to listen to a topic pattern (regex).
Previously, the container threads looped within the <code>consumer.poll()</code> method waiting for the topic to appear while logging many messages.
Aside from the logs, there was no indication that there was a problem.
To restore the previous behavior, you can set the property to <code>false</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="using-ConcurrentMessageListenerContainer"><a class="anchor" href="#using-ConcurrentMessageListenerContainer"></a>Using <code>ConcurrentMessageListenerContainer</code></h6>
<div class="paragraph">
<p>The single constructor is similar to the first <code>KafkaListenerContainer</code> constructor.
The following listing shows the constructor&#8217;s signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public ConcurrentMessageListenerContainer(ConsumerFactory&lt;K, V&gt; consumerFactory,
                            ContainerProperties containerProperties)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It also has a <code>concurrency</code> property.
For example, <code>container.setConcurrency(3)</code> creates three <code>KafkaMessageListenerContainer</code> instances.</p>
</div>
<div class="paragraph">
<p>For the first constructor, Kafka distributes the partitions across the consumers using its group management capabilities.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When listening to multiple topics, the default partition distribution may not be what you expect.
For example, if you have three topics with five partitions each and you want to use <code>concurrency=15</code>, you see only five active consumers, each assigned one partition from each topic, with the other 10 consumers being idle.
This is because the default Kafka <code>PartitionAssignor</code> is the <code>RangeAssignor</code> (see its Javadoc).
For this scenario, you may want to consider using the <code>RoundRobinAssignor</code> instead, which distributes the partitions across all of the consumers.
Then, each consumer is assigned one topic or partition.
To change the <code>PartitionAssignor</code>, you can set the <code>partition.assignment.strategy</code> consumer property (<code>ConsumerConfigs.PARTITION_ASSIGNMENT_STRATEGY_CONFIG</code>) in the properties provided to the <code>DefaultKafkaConsumerFactory</code>.</p>
</div>
<div class="paragraph">
<p>When using Spring Boot, you can assign set the strategy as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.kafka.consumer.properties.partition.assignment.strategy=\
org.apache.kafka.clients.consumer.RoundRobinAssignor</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For the second constructor, the <code>ConcurrentMessageListenerContainer</code> distributes the <code>TopicPartition</code> instances across the delegate <code>KafkaMessageListenerContainer</code> instances.</p>
</div>
<div class="paragraph">
<p>If, say, six <code>TopicPartition</code> instances are provided and the <code>concurrency</code> is <code>3</code>; each container gets two partitions.
For five <code>TopicPartition</code> instances, two containers get two partitions, and the third gets one.
If the <code>concurrency</code> is greater than the number of <code>TopicPartitions</code>, the <code>concurrency</code> is adjusted down such that each container gets one partition.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>client.id</code> property (if set) is appended with <code>-n</code> where <code>n</code> is the consumer instance that corresponds to the concurrency.
This is required to provide unique names for MBeans when JMX is enabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 1.3, the <code>MessageListenerContainer</code> provides access to the metrics of the underlying <code>KafkaConsumer</code>.
In the case of <code>ConcurrentMessageListenerContainer</code>, the <code>metrics()</code> method returns the metrics for all the target <code>KafkaMessageListenerContainer</code> instances.
The metrics are grouped into the <code>Map&lt;MetricName, ? extends Metric&gt;</code> by the <code>client-id</code> provided for the underlying <code>KafkaConsumer</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="committing-offsets"><a class="anchor" href="#committing-offsets"></a>Committing Offsets</h6>
<div class="paragraph">
<p>Several options are provided for committing offsets.
If the <code>enable.auto.commit</code> consumer property is <code>true</code>, Kafka auto-commits the offsets according to its configuration.
If it is <code>false</code>, the containers support several <code>AckMode</code> settings (described in the next list).</p>
</div>
<div class="paragraph">
<p>The consumer <code>poll()</code> method returns one or more <code>ConsumerRecords</code>.
The <code>MessageListener</code> is called for each record.
The following lists describes the action taken by the container for each <code>AckMode</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RECORD</code>: Commit the offset when the listener returns after processing the record.</p>
</li>
<li>
<p><code>BATCH</code>: Commit the offset when all the records returned by the <code>poll()</code> have been processed.</p>
</li>
<li>
<p><code>TIME</code>: Commit the offset when all the records returned by the <code>poll()</code> have been processed, as long as the <code>ackTime</code> since the last commit has been exceeded.</p>
</li>
<li>
<p><code>COUNT</code>: Commit the offset when all the records returned by the <code>poll()</code> have been processed, as long as <code>ackCount</code> records have been received since the last commit.</p>
</li>
<li>
<p><code>COUNT_TIME</code>: Similar to <code>TIME</code> and <code>COUNT</code>, but the commit is performed if either condition is <code>true</code>.</p>
</li>
<li>
<p><code>MANUAL</code>: The message listener is responsible to <code>acknowledge()</code> the <code>Acknowledgment</code>.
After that, the same semantics as <code>BATCH</code> are applied.</p>
</li>
<li>
<p><code>MANUAL_IMMEDIATE</code>: Commit the offset immediately when the <code>Acknowledgment.acknowledge()</code> method is called by the listener.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MANUAL</code>, and <code>MANUAL_IMMEDIATE</code> require the listener to be an <code>AcknowledgingMessageListener</code> or a <code>BatchAcknowledgingMessageListener</code>.
See <a href="#message-listeners">Message Listeners</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on the <code>syncCommits</code> container property, the <code>commitSync()</code> or <code>commitAsync()</code> method on the consumer is used.</p>
</div>
<div class="paragraph">
<p>The <code>Acknowledgment</code> has the following method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Acknowledgment {

    void acknowledge();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This method gives the listener control over when offsets are committed.</p>
</div>
</div>
<div class="sect5">
<h6 id="container-auto-startup"><a class="anchor" href="#container-auto-startup"></a>Listener Container Auto Startup</h6>
<div class="paragraph">
<p>The listener containers implement <code>SmartLifecycle</code>, and <code>autoStartup</code> is <code>true</code> by default.
The containers are started in a late phase (<code>Integer.MAX-VALUE - 100</code>).
Other components that implement <code>SmartLifecycle</code>, to handle data from listeners, should be started in an earlier phase.
The <code>- 100</code> leaves room for later phases to enable components to be auto-started after the containers.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kafka-listener-annotation"><a class="anchor" href="#kafka-listener-annotation"></a><code>@KafkaListener</code> Annotation</h5>
<div class="paragraph">
<p>The <code>@KafkaListener</code> annotation is used to designate a bean method as a listener for a listener container.
The bean is wrapped in a <code>MessagingMessageListenerAdapter</code> configured with various features, such as converters to convert the data, if necessary, to match the method parameters.</p>
</div>
<div class="paragraph">
<p>You can configure most attributes on the annotation with SpEL by using <code>#{&#8230;&#8203;}</code> or property placeholders (<code>${&#8230;&#8203;}</code>).
See the <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/annotation/KafkaListener.html">Javadoc</a> for more information.</p>
</div>
<div class="sect5">
<h6 id="record-listener"><a class="anchor" href="#record-listener"></a>Record Listeners</h6>
<div class="paragraph">
<p>The <code>@KafkaListener</code> annotation provides a mechanism for simple POJO listeners.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Listener {

    @KafkaListener(id = "foo", topics = "myTopic", clientIdPrefix = "myClientId")
    public void listen(String data) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This mechanism requires an <code>@EnableKafka</code> annotation on one of your <code>@Configuration</code> classes and a listener container factory, which is used to configure the underlying <code>ConcurrentMessageListenerContainer</code>.
By default, a bean with name <code>kafkaListenerContainerFactory</code> is expected.
The following example shows how to use <code>ConcurrentMessageListenerContainer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableKafka
public class KafkaConfig {

    @Bean
    KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt;
                        kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
                                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3);
        factory.getContainerProperties().setPollTimeout(3000);
        return factory;
    }

    @Bean
    public ConsumerFactory&lt;Integer, String&gt; consumerFactory() {
        return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs());
    }

    @Bean
    public Map&lt;String, Object&gt; consumerConfigs() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, embeddedKafka.getBrokersAsString());
        ...
        return props;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that, to set container properties, you must use the <code>getContainerProperties()</code> method on the factory.
It is used as a template for the actual properties injected into the container.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1.1, you can now set the <code>client.id</code> property for consumers created by the annotation.
The <code>clientIdPrefix</code> is suffixed with <code>-n</code>, where <code>n</code> is an integer representing the container number when using concurrency.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, you can now override the container factory&#8217;s <code>concurrency</code> and <code>autoStartup</code> properties by using properties on the annotation itself.
The properties can be simple values, property placeholders, or SpEL expressions.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "myListener", topics = "myTopic",
        autoStartup = "${listen.auto.start:true}", concurrency = "${listen.concurrency:3}")
public void listen(String data) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure POJO listeners with explicit topics and partitions (and, optionally, their initial offsets).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "thing2", topicPartitions =
        { @TopicPartition(topic = "topic1", partitions = { "0", "1" }),
          @TopicPartition(topic = "topic2", partitions = "0",
             partitionOffsets = @PartitionOffset(partition = "1", initialOffset = "100"))
        })
public void listen(ConsumerRecord&lt;?, ?&gt; record) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can specify each partition in the <code>partitions</code> or <code>partitionOffsets</code> attribute but not both.</p>
</div>
<div class="paragraph">
<p>When using manual <code>AckMode</code>, you can also provide the listener with the <code>Acknowledgment</code>.
The following example also shows how to use a different container factory.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "cat", topics = "myTopic",
          containerFactory = "kafkaManualAckListenerContainerFactory")
public void listen(String data, Acknowledgment ack) {
    ...
    ack.acknowledge();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, metadata about the message is available from message headers.
You can use the following header names to retrieve the headers of the message:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KafkaHeaders.RECEIVED_MESSAGE_KEY</code></p>
</li>
<li>
<p><code>KafkaHeaders.RECEIVED_TOPIC</code></p>
</li>
<li>
<p><code>KafkaHeaders.RECEIVED_PARTITION_ID</code></p>
</li>
<li>
<p><code>KafkaHeaders.RECEIVED_TIMESTAMP</code></p>
</li>
<li>
<p><code>KafkaHeaders.TIMESTAMP_TYPE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to use the headers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "qux", topicPattern = "myTopic1")
public void listen(@Payload String foo,
        @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) Integer key,
        @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition,
        @Header(KafkaHeaders.RECEIVED_TOPIC) String topic,
        @Header(KafkaHeaders.RECEIVED_TIMESTAMP) long ts
        ) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="batch-listeners"><a class="anchor" href="#batch-listeners"></a>Batch listeners</h6>
<div class="paragraph">
<p>Starting with version 1.1, you can configure <code>@KafkaListener</code> methods to receive the entire batch of consumer records received from the consumer poll.
To configure the listener container factory to create batch listeners, you can set the <code>batchListener</code> property.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaListenerContainerFactory&lt;?&gt; batchFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    factory.setConsumerFactory(consumerFactory());
    factory.setBatchListener(true);  // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to receive a list of payloads:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "list", topics = "myTopic", containerFactory = "batchFactory")
public void listen(List&lt;String&gt; list) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The topic, partition, offset, and so on are available in headers that parallel the payloads.
The following example shows how to use the headers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "list", topics = "myTopic", containerFactory = "batchFactory")
public void listen(List&lt;String&gt; list,
        @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) List&lt;Integer&gt; keys,
        @Header(KafkaHeaders.RECEIVED_PARTITION_ID) List&lt;Integer&gt; partitions,
        @Header(KafkaHeaders.RECEIVED_TOPIC) List&lt;String&gt; topics,
        @Header(KafkaHeaders.OFFSET) List&lt;Long&gt; offsets) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can receive a <code>List</code> of <code>Message&lt;?&gt;</code> objects with each offset and other details in each message, but it must be the only parameter (aside from optional <code>Acknowledgment</code>, when using manual commits, and/or <code>Consumer&lt;?, ?&gt;</code> parameters) defined on the method.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "listMsg", topics = "myTopic", containerFactory = "batchFactory")
public void listen14(List&lt;Message&lt;?&gt;&gt; list) {
    ...
}

@KafkaListener(id = "listMsgAck", topics = "myTopic", containerFactory = "batchFactory")
public void listen15(List&lt;Message&lt;?&gt;&gt; list, Acknowledgment ack) {
    ...
}

@KafkaListener(id = "listMsgAckConsumer", topics = "myTopic", containerFactory = "batchFactory")
public void listen16(List&lt;Message&lt;?&gt;&gt; list, Acknowledgment ack, Consumer&lt;?, ?&gt; consumer) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>No conversion is performed on the payloads in this case.</p>
</div>
<div class="paragraph">
<p>If the <code>BatchMessagingMessageConverter</code> is configured with a <code>RecordMessageConverter</code>, you can also add a generic type to the <code>Message</code> parameter and the payloads are converted.
See <a href="#payload-conversion-with-batch">Payload Conversion with Batch Listeners</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can also receive a list of <code>ConsumerRecord&lt;?, ?&gt;</code> objects, but it must be the only parameter (aside from optional <code>Acknowledgment</code>, when using manual commits and <code>Consumer&lt;?, ?&gt;</code> parameters) defined on the method.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "listCRs", topics = "myTopic", containerFactory = "batchFactory")
public void listen(List&lt;ConsumerRecord&lt;Integer, String&gt;&gt; list) {
    ...
}

@KafkaListener(id = "listCRsAck", topics = "myTopic", containerFactory = "batchFactory")
public void listen(List&lt;ConsumerRecord&lt;Integer, String&gt;&gt; list, Acknowledgment ack) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the listener can receive the complete <code>ConsumerRecords&lt;?, ?&gt;</code> object returned by the <code>poll()</code> method, letting the listener access additional methods, such as <code>partitions()</code> (which returns the <code>TopicPartition</code> instances in the list) and <code>records(TopicPartition)</code> (which gets selective records).
Again, this must be the only parameter (aside from optional <code>Acknowledgment</code>, when using manual commits or <code>Consumer&lt;?, ?&gt;</code> parameters) on the method.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "pollResults", topics = "myTopic", containerFactory = "batchFactory")
public void pollResults(ConsumerRecords&lt;?, ?&gt; records) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the container factory has a <code>RecordFilterStrategy</code> configured, it is ignored for <code>ConsumerRecords&lt;?, ?&gt;</code> listeners, with a <code>WARN</code> log message emitted.
Records can only be filtered with a batch listener if the <code>&lt;List&lt;?&gt;&gt;</code> form of listener is used.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="annotation-properties"><a class="anchor" href="#annotation-properties"></a>Annotation Properties</h6>
<div class="paragraph">
<p>Starting with version 2.0, the <code>id</code> property (if present) is used as the Kafka consumer <code>group.id</code> property, overriding the configured property in the consumer factory, if present.
You can also set <code>groupId</code> explicitly or set <code>idIsGroup</code> to false to restore the previous behavior of using the consumer factory <code>group.id</code>.</p>
</div>
<div class="paragraph">
<p>You can use property placeholders or SpEL expressions within most annotation properties, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(topics = "${some.property}")

@KafkaListener(topics = "#{someBean.someProperty}",
    groupId = "#{someBean.someProperty}.group")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.1.2, the SpEL expressions support a special token: <code>__listener</code>.
It is a pseudo bean name that represents the current bean instance within which this annotation exists.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Listener listener1() {
    return new Listener("topic1");
}

@Bean
public Listener listener2() {
    return new Listener("topic2");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the beans in the previous example, we can then use the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Listener {

    private final String topic;

    public Listener(String topic) {
        this.topic = topic;
    }

    @KafkaListener(topics = "#{__listener.topic}",
        groupId = "#{__listener.topic}.group")
    public void listen(...) {
        ...
    }

    public String getTopic() {
        return this.topic;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If, in the unlikely event that you have an actual bean called <code>__listener</code>, you can change the expression token byusing the <code>beanRef</code> attribute.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(beanRef = "__x", topics = "#{__x.topic}",
    groupId = "#{__x.topic}.group")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.2.4, you can specify Kafka consumer properties directly on the annotation, these will override any properties with the same name configured in the consumer factory. You <strong>cannot</strong> specify the <code>group.id</code> and <code>client.id</code> properties this way; they will be ignored; use the <code>groupId</code> and <code>clientIdPrefix</code> annotation properties for those.</p>
</div>
<div class="paragraph">
<p>The properties are specified as individual strings with the normal Java <code>Properties</code> file format: <code>foo:bar</code>, <code>foo=bar</code>, or <code>foo bar</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(topics = "myTopic", groupId="group", properties= {
    "max.poll.interval.ms:60000",
    ConsumerConfig.MAX_POLL_RECORDS_CONFIG + "=100"
})</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="container-thread-naming"><a class="anchor" href="#container-thread-naming"></a>Container Thread Naming</h5>
<div class="paragraph">
<p>Listener containers currently use two task executors, one to invoke the consumer and another that is used to invoke the listener when the kafka consumer property <code>enable.auto.commit</code> is <code>false</code>.
You can provide custom executors by setting the <code>consumerExecutor</code> and <code>listenerExecutor</code> properties of the container&#8217;s <code>ContainerProperties</code>.
When using pooled executors, be sure that enough threads are available to handle the concurrency across all the containers in which they are used.
When using the <code>ConcurrentMessageListenerContainer</code>, a thread from each is used for each consumer (<code>concurrency</code>).</p>
</div>
<div class="paragraph">
<p>If you do not provide a consumer executor, a <code>SimpleAsyncTaskExecutor</code> is used.
This executor creates threads with names similar to <code>&lt;beanName&gt;-C-1</code> (consumer thread).
For the <code>ConcurrentMessageListenerContainer</code>, the <code>&lt;beanName&gt;</code> part of the thread name becomes <code>&lt;beanName&gt;-m</code>, where <code>m</code> represents the consumer instance.
<code>n</code> increments each time the container is started.
So, with a bean name of <code>container</code>, threads in this container will be named <code>container-0-C-1</code>, <code>container-1-C-1</code> etc., after the container is started the first time; <code>container-0-C-2</code>, <code>container-1-C-2</code> etc., after a stop and subsequent start.</p>
</div>
</div>
<div class="sect4">
<h5 id="kafka-listener-meta"><a class="anchor" href="#kafka-listener-meta"></a><code>@KafkaListener</code> as a Meta Annotation</h5>
<div class="paragraph">
<p>Starting with version 2.2, you can now use <code>@KafkaListener</code> as a meta annotation.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@KafkaListener
public @interface MyThreeConsumersListener {

    @AliasFor(annotation = KafkaListener.class, attribute = "id")
    String id();

    @AliasFor(annotation = KafkaListener.class, attribute = "topics")
    String[] topics();

    @AliasFor(annotation = KafkaListener.class, attribute = "concurrency")
    String concurrency() default "3";

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You must alias at least one of <code>topics</code>, <code>topicPattern</code>, or <code>topicPartitions</code> (and, usually, <code>id</code> or <code>groupId</code> unless you have specified a <code>group.id</code> in the consumer factory configuration).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MyThreeConsumersListener(id = "my.group", topics = "my.topic")
public void listen1(String in) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="class-level-kafkalistener"><a class="anchor" href="#class-level-kafkalistener"></a><code>@KafkaListener</code> on a Class</h5>
<div class="paragraph">
<p>When you use <code>@KafkaListener</code> at the class-level, you must specify <code>@KafkaHandler</code> at the method level.
When messages are delivered, the converted message payload type is used to determine which method to call.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "multi", topics = "myTopic")
static class MultiListenerBean {

    @KafkaHandler
    public void listen(String foo) {
        ...
    }

    @KafkaHandler
    public void listen(Integer bar) {
        ...
    }

    @KafkaHandler(isDefault = true`)
    public void listenDefault(Object object) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.1.3, you can designate a <code>@KafkaHandler</code> method as the default method that is invoked if there is no match on other methods.
At most, one method can be so designated.
When using <code>@KafkaHandler</code> methods, the payload must have already been converted to the domain object (so the match can be performed).
Use a custom deserializer, the <code>JsonDeserializer</code>, or the <code>(String|Bytes)JsonMessageConverter</code> with its <code>TypePrecedence</code> set to <code>TYPE_ID</code>.
See <a href="#serdes">Serialization, Deserialization, and Message Conversion</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="kafkalistener-lifecycle"><a class="anchor" href="#kafkalistener-lifecycle"></a><code>@KafkaListener</code> Lifecycle Management</h5>
<div class="paragraph">
<p>The listener containers created for <code>@KafkaListener</code> annotations are not beans in the application context.
Instead, they are registered with an infrastructure bean of type <code>KafkaListenerEndpointRegistry</code>.
This bean is automatically declared by the framework and manages the containers' lifecycles; it will auto-start any containers that have <code>autoStartup</code> set to <code>true</code>.
All containers created by all container factories must be in the same <code>phase</code>.
See <a href="#container-auto-startup">Listener Container Auto Startup</a> for more information.
You can manage the lifecycle programmatically by using the registry.
Starting or stopping the registry will start or stop all the registered containers.
Alternatively, you can get a reference to an individual container by using its <code>id</code> attribute.
You can set <code>autoStartup</code> on the annotation, which overrides the default setting configured into the container factory.
You can get a reference to the bean from the application context, such as auto-wiring, to manage its registered containers.
The following examples show how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "myContainer", topics = "myTopic", autoStartup = "false")
public void listen(...) { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private KafkaListenerEndpointRegistry registry;

...

    this.registry.getListenerContainer("myContainer").start();

...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The registry only maintains the life cycle of containers it manages; containers declared as beans are not managed by the registry and can be obtained from the application context.
A collection of managed containers can be obtained by calling the registry&#8217;s <code>getListenerContainers()</code> method.
Version 2.2.5 added a convenience method <code>getAllListenerContainers()</code>, which returns a collection of all containers, including those managed by the registry and those declared as beans.
The collection returned will include any prototype beans that have been initialized, but it will not initialize any lazy bean declarations.</p>
</div>
</div>
<div class="sect4">
<h5 id="kafka-validation"><a class="anchor" href="#kafka-validation"></a><code>@KafkaListener</code> <code>@Payload</code> Validation</h5>
<div class="paragraph">
<p>Starting with version 2.2, it is now easier to add a <code>Validator</code> to validate <code>@KafkaListener</code> <code>@Payload</code> arguments.
Previously, you had to configure a custom <code>DefaultMessageHandlerMethodFactory</code> and add it to the registrar.
Now, you can add the validator to the registrar itself.
The following code shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableKafka
public class Config implements KafkaListenerConfigurer {

    ...

    @Override
    public void configureKafkaListeners(KafkaListenerEndpointRegistrar registrar) {
      registrar.setValidator(new MyValidator());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use Spring Boot with the validation starter, a <code>LocalValidatorFactoryBean</code> is auto-configured, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableKafka
public class Config implements KafkaListenerConfigurer {

    @Autowired
    private LocalValidatorFactoryBean validator;
    ...

    @Override
    public void configureKafkaListeners(KafkaListenerEndpointRegistrar registrar) {
      registrar.setValidator(this.validator);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The follwing examples show how to validate:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class ValidatedClass {

  @Max(10)
  private int bar;

  public int getBar() {
    return this.bar;
  }

  public void setBar(int bar) {
    this.bar = bar;
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id="validated", topics = "annotated35", errorHandler = "validationErrorHandler",
      containerFactory = "kafkaJsonListenerContainerFactory")
public void validatedListener(@Payload @Valid ValidatedClass val) {
    ...
}

@Bean
public KafkaListenerErrorHandler validationErrorHandler() {
    return (m, e) -&gt; {
        ...
    };
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rebalance-listeners"><a class="anchor" href="#rebalance-listeners"></a>Rebalancing Listeners</h5>
<div class="paragraph">
<p><code>ContainerProperties</code> has a property called <code>consumerRebalanceListener</code>, which takes an implementation of the Kafka client&#8217;s <code>ConsumerRebalanceListener</code> interface.
If this property is not provided, the container configures a logging listener that logs rebalance events at the <code>INFO</code> level.
The framework also adds a sub-interface <code>ConsumerAwareRebalanceListener</code>.
The following listing shows the <code>ConsumerAwareRebalanceListener</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ConsumerAwareRebalanceListener extends ConsumerRebalanceListener {

    void onPartitionsRevokedBeforeCommit(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions);

    void onPartitionsRevokedAfterCommit(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions);

    void onPartitionsAssigned(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that there are two callbacks when partitions are revoked.
The first is called immediately.
The second is called after any pending offsets are committed.
This is useful if you wish to maintain offsets in some external repository, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">containerProperties.setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {

    @Override
    public void onPartitionsRevokedBeforeCommit(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions) {
        // acknowledge any pending Acknowledgments (if using manual acks)
    }

    @Override
    public void onPartitionsRevokedAfterCommit(Consumer&lt;?, ?&gt; consumer, Collection&lt;TopicPartition&gt; partitions) {
        // ...
            store(consumer.position(partition));
        // ...
    }

    @Override
    public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions) {
        // ...
            consumer.seek(partition, offsetTracker.getOffset() + 1);
        // ...
    }
});</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="annotation-send-to"><a class="anchor" href="#annotation-send-to"></a>Forwarding Listener Results using <code>@SendTo</code></h5>
<div class="paragraph">
<p>Starting with version 2.0, if you also annotate a <code>@KafkaListener</code> with a <code>@SendTo</code> annotation and the method invocation returns a result, the result is forwarded to the topic specified by the <code>@SendTo</code>.</p>
</div>
<div class="paragraph">
<p>The <code>@SendTo</code> value can have several forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@SendTo("someTopic")</code> routes to the literal topic</p>
</li>
<li>
<p><code>@SendTo("#{someExpression}")</code> routes to the topic determined by evaluating the expression once during application context initialization.</p>
</li>
<li>
<p><code>@SendTo("!{someExpression}")</code> routes to the topic determined by evaluating the expression at runtime.
The <code>#root</code> object for the evaluation has three properties:</p>
<div class="ulist">
<ul>
<li>
<p><code>request</code>: The inbound <code>ConsumerRecord</code> (or <code>ConsumerRecords</code> object for a batch listener))</p>
</li>
<li>
<p><code>source</code>: The <code>org.springframework.messaging.Message&lt;?&gt;</code> converted from the <code>request</code>.</p>
</li>
<li>
<p><code>result</code>: The method return result.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@SendTo</code> (no properties): This is treated as <code>!{source.headers['kafka_replyTopic']}</code> (since version 2.1.3).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with versions 2.1.11 and 2.2.1, property placeholders are resolved within <code>@SendTo</code> values.</p>
</div>
<div class="paragraph">
<p>The result of the expression evaluation must be a <code>String</code> that represents the topic name.
The following examples show the various ways to use <code>@SendTo</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(topics = "annotated21")
@SendTo("!{request.value()}") // runtime SpEL
public String replyingListener(String in) {
    ...
}

@KafkaListener(topics = "${some.property:annotated22}")
@SendTo("#{myBean.replyTopic}") // config time SpEL
public Collection&lt;String&gt; replyingBatchListener(List&lt;String&gt; in) {
    ...
}

@KafkaListener(topics = "annotated23", errorHandler = "replyErrorHandler")
@SendTo("annotated23reply") // static reply topic definition
public String replyingListenerWithErrorHandler(String in) {
    ...
}
...
@KafkaListener(topics = "annotated25")
@SendTo("annotated25reply1")
public class MultiListenerSendTo {

    @KafkaHandler
    public String foo(String in) {
        ...
    }

    @KafkaHandler
    @SendTo("!{'annotated25reply2'}")
    public String bar(@Payload(required = false) KafkaNull nul,
            @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) int key) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.2, you can add a <code>ReplyHeadersConfigurer</code> to the listener container factory.
This is consulted to determine which headers you want to set in the reply message.
The following example shows how to add a <code>ReplyHeadersConfigurer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
        new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    factory.setConsumerFactory(cf());
    factory.setReplyTemplate(template());
    factory.setReplyHeadersConfigurer((k, v) -&gt; k.equals("cat"));
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also add more headers if you wish.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
        new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    factory.setConsumerFactory(cf());
    factory.setReplyTemplate(template());
    factory.setReplyHeadersConfigurer(new ReplyHeadersConfigurer() {

      @Override
      public boolean shouldCopy(String headerName, Object headerValue) {
        return false;
      }

      @Override
      public Map&lt;String, Object&gt; additionalHeaders() {
        return Collections.singletonMap("qux", "fiz");
      }

    });
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use <code>@SendTo</code>, you must configure the <code>ConcurrentKafkaListenerContainerFactory</code> with a <code>KafkaTemplate</code> in its <code>replyTemplate</code> property to perform the send.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unless you use <a href="#replying-template">request/reply semantics</a> only the simple <code>send(topic, value)</code> method is used, so you may wish to create a subclass to generate the partition or key.
The following example shows how to do so:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaTemplate&lt;String, String&gt; myReplyingTemplate() {
    return new KafkaTemplate&lt;Integer, String&gt;(producerFactory()) {

        @Override
        public ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; send(String topic, String data) {
            return super.send(topic, partitionForData(data), keyForData(data), data);
        }

        ...

    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the listener method returns <code>Message&lt;?&gt;</code> or <code>Collection&lt;Message&lt;?&gt;&gt;</code>, the listener method is responsible for setting up the message headers for the reply.
For example, when handling a request from a <code>ReplyingKafkaTemplate</code>, you might do the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "messageReturned", topics = "someTopic")
public Message&lt;?&gt; listen(String in, @Header(KafkaHeaders.REPLY_TOPIC) byte[] replyTo,
        @Header(KafkaHeaders.CORRELATION_ID) byte[] correlation) {
    return MessageBuilder.withPayload(in.toUpperCase())
            .setHeader(KafkaHeaders.TOPIC, replyTo)
            .setHeader(KafkaHeaders.MESSAGE_KEY, 42)
            .setHeader(KafkaHeaders.CORRELATION_ID, correlation)
            .setHeader("someOtherHeader", "someValue")
            .build();
}</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using request/reply semantics, the target partition can be requested by the sender.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can annotate a <code>@KafkaListener</code> method with <code>@SendTo</code> even if no result is returned.
This is to allow the configuration of an <code>errorHandler</code> that can forward information about a failed message delivery to some topic.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "voidListenerWithReplyingErrorHandler", topics = "someTopic",
        errorHandler = "voidSendToErrorHandler")
@SendTo("failures")
public void voidListenerWithReplyingErrorHandler(String in) {
    throw new RuntimeException("fail");
}

@Bean
public KafkaListenerErrorHandler voidSendToErrorHandler() {
    return (m, e) -&gt; {
        return ... // some information about the failure and input data
    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#annotation-error-handling">Handling Exceptions</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="filtering-messages"><a class="anchor" href="#filtering-messages"></a>Filtering Messages</h5>
<div class="paragraph">
<p>In certain scenarios, such as rebalancing, a message that has already been processed may be redelivered.
The framework cannot know whether such a message has been processed or not.
That is an application-level function.
This is known as the <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/IdempotentReceiver.html">Idempotent Receiver</a> pattern and Spring Integration provides an <a href="https://docs.spring.io/spring-integration/reference/html/#idempotent-receiver">implementation of it</a>.</p>
</div>
<div class="paragraph">
<p>The Spring for Apache Kafka project also provides some assistance by means of the <code>FilteringMessageListenerAdapter</code> class, which can wrap your <code>MessageListener</code>.
This class takes an implementation of <code>RecordFilterStrategy</code> in which you implement the <code>filter</code> method to signal that a message is a duplicate and should be discarded.
This has an additional property called <code>ackDiscarded</code>, which indicates whether the adapter should acknowledge the discarded record.
It is <code>false</code> by default.</p>
</div>
<div class="paragraph">
<p>When you use <code>@KafkaListener</code>, set the <code>RecordFilterStrategy</code> (and optionally <code>ackDiscarded</code>) on the container factory so that the listener is wrapped in the appropriate filtering adapter.</p>
</div>
<div class="paragraph">
<p>In addition, a <code>FilteringBatchMessageListenerAdapter</code> is provided, for when you use a batch <a href="#message-listeners">message listener</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>FilteringBatchMessageListenerAdapter</code> is ignored if your <code>@KafkaListener</code> receives a <code>ConsumerRecords&lt;?, ?&gt;</code> instead of <code>List&lt;ConsumerRecord&lt;?, ?&gt;&gt;</code>, because <code>ConsumerRecords</code> is immutable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="retrying-deliveries"><a class="anchor" href="#retrying-deliveries"></a>Retrying Deliveries</h5>
<div class="paragraph">
<p>If your listener throws an exception, the default behavior is to invoke the <code>ErrorHandler</code>, if configured, or logged otherwise.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Two error handler interfaces (<code>ErrorHandler</code> and <code>BatchErrorHandler</code>) are provided.
You must configure the appropriate type to match the <a href="#message-listeners">message listener</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To retry deliveries, a convenient listener adapter <code>RetryingMessageListenerAdapter</code>  is provided.</p>
</div>
<div class="paragraph">
<p>You can configure it with a <code>RetryTemplate</code> and <code>RecoveryCallback&lt;Void&gt;</code> - see the <a href="https://github.com/spring-projects/spring-retry">spring-retry</a> project for information about these components.
If a recovery callback is not provided, the exception is thrown to the container after retries are exhausted.
In that case, the <code>ErrorHandler</code> is invoked, if configured, or logged otherwise.</p>
</div>
<div class="paragraph">
<p>When you use <code>@KafkaListener</code>, you can set the <code>RetryTemplate</code> (and optionally <code>recoveryCallback</code>) on the container factory.
When you do so, the listener is wrapped in the appropriate retrying adapter.</p>
</div>
<div class="paragraph">
<p>The contents of the <code>RetryContext</code> passed into the <code>RecoveryCallback</code> depend on the type of listener.
The context always has a <code>record</code> attribute, which is the record for which the failure occurred.
If your listener is acknowledging or consumer aware, additional <code>acknowledgment</code> or <code>consumer</code> attributes are available.
For convenience, the <code>RetryingMessageListenerAdapter</code> provides static constants for these keys.
See its <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/listener/adapter/AbstractRetryingMessageListenerAdapter.html">Javadoc</a> for more information.</p>
</div>
<div class="paragraph">
<p>A retry adapter is not provided for any of the batch <a href="#message-listeners">message listeners</a>, because the framework has no knowledge of where in a batch the failure occurred.
If you need retry capabilities when you use a batch listener, we recommend that you use a <code>RetryTemplate</code> within the listener itself.</p>
</div>
</div>
<div class="sect4">
<h5 id="stateful-retry"><a class="anchor" href="#stateful-retry"></a>Stateful Retry</h5>
<div class="paragraph">
<p>You should understand that the retry discussed in the <a href="#retrying-deliveries">preceding section</a> suspends the consumer thread (if a <code>BackOffPolicy</code> is used).
There are no calls to <code>Consumer.poll()</code> during the retries.
Kafka has two properties to determine consumer health.
The <code>session.timeout.ms</code> is used to determine if the consumer is active.
Since version <code>0.10.1.0</code>, heartbeats are sent on a background thread, so a slow consumer no longer affects that.
<code>max.poll.interval.ms</code> (default: five minutes) is used to determine if a consumer appears to be hung (taking too long to process records from the last poll).
If the time between <code>poll()</code> calls exceeds this, the broker revokes the assigned partitions and performs a rebalance.
For lengthy retry sequences, with back off, this can easily happen.</p>
</div>
<div class="paragraph">
<p>Since version 2.1.3, you can avoid this problem by using stateful retry in conjunction with a <code>SeekToCurrentErrorHandler</code>.
In this case, each delivery attempt throws the exception back to the container, the error handler re-seeks the unprocessed offsets, and the same message is redelivered by the next <code>poll()</code>.
This avoids the problem of exceeding the <code>max.poll.interval.ms</code> property (as long as an individual delay between attempts does not exceed it).
So, when you use an <code>ExponentialBackOffPolicy</code>, you must ensure that the <code>maxInterval</code> is less than the <code>max.poll.interval.ms</code> property.
To enable stateful retry, you can use the <code>RetryingMessageListenerAdapter</code> constructor that takes a <code>stateful</code> <code>boolean</code> argument (set it to <code>true</code>).
When you configure the listener container factory (for <code>@KafkaListener</code>), set the factory&#8217;s <code>statefulRetry</code> property to <code>true</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="idle-containers"><a class="anchor" href="#idle-containers"></a>Detecting Idle and Non-Responsive Consumers</h5>
<div class="paragraph">
<p>While efficient, one problem with asynchronous consumers is detecting when they are idle.
You might want to take some action if no messages arrive for some period of time.</p>
</div>
<div class="paragraph">
<p>You can configure the listener container to publish a <code>ListenerContainerIdleEvent</code> when some time passes with no message delivery.
While the container is idle, an event is published every <code>idleEventInterval</code> milliseconds.</p>
</div>
<div class="paragraph">
<p>To configure this feature, set the <code>idleEventInterval</code> on the container.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaMessageListenerContainer(ConsumerFactory&lt;String, String&gt; consumerFactory) {
    ContainerProperties containerProps = new ContainerProperties("topic1", "topic2");
    ...
    containerProps.setIdleEventInterval(60000L);
    ...
    KafkaMessageListenerContainer&lt;String, String&gt; container = new KafKaMessageListenerContainer&lt;&gt;(...);
    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to set the <code>idleEventInterval</code> for a <code>@KafkaListener</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentKafkaListenerContainerFactory kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory =
                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    ...
    factory.getContainerProperties().setIdleEventInterval(60000L);
    ...
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In each of these cases, an event is published once per minute while the container is idle.</p>
</div>
<div class="paragraph">
<p>In addition, if the broker is unreachable, the consumer <code>poll()</code> method does not exit, so no messages are received and idle events cannot be generated.
To solve this issue, the container publishes a <code>NonResponsiveConsumerEvent</code> if a poll does not return within 3x the <code>pollInterval</code> property.
By default, this check is performed once every 30 seconds in each container.
You can modify this behavior by setting the <code>monitorInterval</code> and <code>noPollThreshold</code> properties in the <code>ContainerProperties</code> when configuring the listener container.
Receiving such an event lets you stop the containers, thus waking the consumer so that it can terminate.</p>
</div>
<div class="sect5">
<h6 id="event-consumption"><a class="anchor" href="#event-consumption"></a>Event Consumption</h6>
<div class="paragraph">
<p>You can capture these events by implementing <code>ApplicationListener</code>&#8201;&#8212;&#8201;either a general listener or one narrowed to only receive this specific event.
You can also use <code>@EventListener</code>, introduced in Spring Framework 4.2.</p>
</div>
<div class="paragraph">
<p>The next example combines <code>@KafkaListener</code> and <code>@EventListener</code> into a single class.
You should understand that the application listener gets events for all containers, so you may need to check the listener ID if you want to take specific action based on which container is idle.
You can also use the <code>@EventListener</code> <code>condition</code> for this purpose.</p>
</div>
<div class="paragraph">
<p>See <a href="#events">Events</a> for information about event properties.</p>
</div>
<div class="paragraph">
<p>The event is normally published on the consumer thread, so it is safe to interact with the <code>Consumer</code> object.</p>
</div>
<div class="paragraph">
<p>The following example uses both <code>@KafkaListener</code> and <code>@EventListener</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">public class Listener {

    @KafkaListener(id = "qux", topics = "annotated")
    public void listen4(@Payload String foo, Acknowledgment ack) {
        ...
    }

    @EventListener(condition = "event.listenerId.startsWith('qux-')")
    public void eventHandler(ListenerContainerIdleEvent event) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Event listeners see events for all containers.
Consequently, in the preceding example, we narrow the events received based on the listener ID.
Since containers created for the <code>@KafkaListener</code> support concurrency, the actual containers are named <code>id-n</code> where the <code>n</code> is a unique value for each instance to support the concurrency.
That is why we use <code>startsWith</code> in the condition.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
If you wish to use the idle event to stop the lister container, you should not call <code>container.stop()</code> on the thread that calls the listener.
Doing so causes delays and unnecessary log messages.
Instead, you should hand off the event to a different thread that can then stop the container.
Also, you should not <code>stop()</code> the container instance if it is a child container.
You should stop the concurrent container instead.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="current-positions-when-idle"><a class="anchor" href="#current-positions-when-idle"></a>Current Positions when Idle</h6>
<div class="paragraph">
<p>Note that you can obtain the current positions when idle is detected by implementing <code>ConsumerSeekAware</code> in your listener.
See <code>onIdleContainer()</code> in `<a href="#seek">Seeking to a Specific Offset</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="topicpartition-initial-offset"><a class="anchor" href="#topicpartition-initial-offset"></a>Topic/Partition Initial Offset</h5>
<div class="paragraph">
<p>There are several ways to set the initial offset for a partition.</p>
</div>
<div class="paragraph">
<p>When manually assigning partitions, you can set the initial offset (if desired) in the configured <code>TopicPartitionInitialOffset</code> arguments (see <a href="#message-listener-container">Message Listener Containers</a>).
You can also seek to a specific offset at any time.</p>
</div>
<div class="paragraph">
<p>When you use group management where the broker assigns partitions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For a new <code>group.id</code>, the initial offset is determined by the <code>auto.offset.reset</code> consumer property (<code>earliest</code> or <code>latest</code>).</p>
</li>
<li>
<p>For an existing group ID, the initial offset is the current offset for that group ID.
You can, however, seek to a specific offset during initialization (or at any time thereafter).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="seek"><a class="anchor" href="#seek"></a>Seeking to a Specific Offset</h5>
<div class="paragraph">
<p>In order to seek, your listener must implement <code>ConsumerSeekAware</code>, which has the following methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void registerSeekCallback(ConsumerSeekCallback callback);

void onPartitionsAssigned(Map&lt;TopicPartition, Long&gt; assignments, ConsumerSeekCallback callback);

void onIdleContainer(Map&lt;TopicPartition, Long&gt; assignments, ConsumerSeekCallback callback);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first method is called when the container is started.
You should use this callback when seeking at some arbitrary time after initialization.
You should save a reference to the callback.
If you use the same listener in multiple containers (or in a <code>ConcurrentMessageListenerContainer</code>), you should store the callback in a <code>ThreadLocal</code> or some other structure keyed by the listener <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>When using group management, the second method is called when assignments change.
You can use this method, for example, for setting initial offsets for the partitions, by calling the callback.
You must use the callback argument, not the one passed into <code>registerSeekCallback</code>.
This method is never called if you explicitly assign partitions yourself.
Use the <code>TopicPartitionInitialOffset</code> in that case.</p>
</div>
<div class="paragraph">
<p>The callback has the following methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void seek(String topic, int partition, long offset);

void seekToBeginning(String topic, int partition);

void seekToEnd(String topic, int partition);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also perform seek operations from <code>onIdleContainer()</code> when an idle container is detected.
See <a href="#idle-containers">Detecting Idle and Non-Responsive Consumers</a> for how to enable idle container detection.</p>
</div>
<div class="paragraph">
<p>To arbitrarily seek at runtime, use the callback reference from the <code>registerSeekCallback</code> for the appropriate thread.</p>
</div>
</div>
<div class="sect4">
<h5 id="container-factory"><a class="anchor" href="#container-factory"></a>Container factory</h5>
<div class="paragraph">
<p>As discussed in <a href="#kafka-listener-annotation"><code>@KafkaListener</code> Annotation</a>, a <code>ConcurrentKafkaListenerContainerFactory</code> is used to create containers for annotated methods.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, you can use the same factory to create any <code>ConcurrentMessageListenerContainer</code>.
This might be useful if you want to create several containers with similar properties or you wish to use some externally configured factory, such as the one provided by Spring Boot auto-configuration.
Once the container is created, you can further modify its properties, many of which are set by using <code>container.getContainerProperties()</code>.
The following example configures a <code>ConcurrentMessageListenerContainer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentMessageListenerContainer&lt;String, String&gt;(
        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory) {

    ConcurrentMessageListenerContainer&lt;String, String&gt; container =
        factory.createContainer("topic1", "topic2");
    container.setMessageListener(m -&gt; { ... } );
    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Containers created this way are not added to the endpoint registry.
They should be created as <code>@Bean</code> definitions so that they are registered with the application context.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="thread-safety"><a class="anchor" href="#thread-safety"></a>Thread Safety</h5>
<div class="paragraph">
<p>When using a concurrent message listener container, a single listener instance is invoked on all consumer threads.
Listeners, therefore, need to be thread-safe, and it is preferable to use stateless listeners.
If it is not possible to make your listener thread-safe or adding synchronization would significantly reduce the benefit of adding concurrency, you can use one of a few techniques:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>n</code> containers with <code>concurrency=1</code> with a prototype scoped <code>MessageListener</code> bean so that each container gets its own instance (this is not possible when using <code>@KafkaListener</code>).</p>
</li>
<li>
<p>Keep the state in <code>ThreadLocal&lt;?&gt;</code> instances.</p>
</li>
<li>
<p>Have the singleton listener delegate to a bean that is declared in <code>SimpleThreadScope</code> (or a similar scope).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To facilitate cleaning up thread state (for the second and third items in the preceding list), starting with version 2.2, the listener container publishes a <code>ConsumerStoppedEvent</code> when each thread exits.
You can consume these events with an <code>ApplicationListener</code> or <code>@EventListener</code> method to remove <code>ThreadLocal&lt;?&gt;</code> instances or <code>remove()</code> thread-scoped beans from the scope.
Note that <code>SimpleThreadScope</code> does not destroy beans that have a destruction interface (such as <code>DisposableBean</code>), so you should <code>destroy()</code> the instance yourself.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the application context&#8217;s event multicaster invokes event listeners on the calling thread.
If you change the multicaster to use an async executor, thread cleanup is not effective.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pause-resume"><a class="anchor" href="#pause-resume"></a>4.1.4. Pausing and Resuming Listener Containers</h4>
<div class="paragraph">
<p>Version 2.1.3 added <code>pause()</code> and <code>resume()</code> methods to listener containers.
Previously, you could pause a consumer within a <code>ConsumerAwareMessageListener</code> and resume it by listening for a <code>ListenerContainerIdleEvent</code>, which provides access to the <code>Consumer</code> object.
While you could pause a consumer in an idle container byi using an event listener, in some cases, this was not thread-safe, since there is no guarantee that the event listener is invoked on the consumer thread.
To safely pause and resume consumers, you should use the <code>pause</code> and <code>resume</code> methods on the listener containers.
A <code>pause()</code> takes effect just before the next <code>poll()</code>; a <code>resume()</code> takes effect just after the current <code>poll()</code> returns.
When a container is paused, it continues to <code>poll()</code> the consumer, avoiding a rebalance if group management is being used, but it does not retrieve any records.
See the Kafka documentation for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1.5, you can call <code>isPauseRequested()</code> to see if <code>pause()</code> has been called.
However, the consumers might not have actually paused yet.
<code>isConsumerPaused()</code> returns true if all <code>Consumer</code> instances have actually paused.</p>
</div>
<div class="paragraph">
<p>In addition (also since 2.1.5), <code>ConsumerPausedEvent</code> and <code>ConsumerResumedEvent</code> instances are published with the container as the <code>source</code> property and the <code>TopicPartition</code> instances involved in the <code>partitions</code> property.</p>
</div>
<div class="paragraph">
<p>The following simple Spring Boot application demonstrates by using the container registry to get a reference to a <code>@KafkaListener</code> method&#8217;s container and pausing or resuming its consumers as well as receiving the corresponding events:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application implements ApplicationListener&lt;KafkaEvent&gt; {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args).close();
    }

    @Override
    public void onApplicationEvent(KafkaEvent event) {
        System.out.println(event);
    }

    @Bean
    public ApplicationRunner runner(KafkaListenerEndpointRegistry registry,
            KafkaTemplate&lt;String, String&gt; template) {
        return args -&gt; {
            template.send("pause.resume.topic", "thing1");
            Thread.sleep(10_000);
            System.out.println("pausing");
            registry.getListenerContainer("pause.resume").pause();
            Thread.sleep(10_000);
            template.send("pause.resume.topic", "thing2");
            Thread.sleep(10_000);
            System.out.println("resuming");
            registry.getListenerContainer("pause.resume").resume();
            Thread.sleep(10_000);
        };
    }

    @KafkaListener(id = "pause.resume", topics = "pause.resume.topic")
    public void listen(String in) {
        System.out.println(in);
    }

    @Bean
    public NewTopic topic() {
        return new NewTopic("pause.resume.topic", 2, (short) 1);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the results of the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>partitions assigned: [pause.resume.topic-1, pause.resume.topic-0]
thing1
pausing
ConsumerPausedEvent [partitions=[pause.resume.topic-1, pause.resume.topic-0]]
resuming
ConsumerResumedEvent [partitions=[pause.resume.topic-1, pause.resume.topic-0]]
thing2</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="events"><a class="anchor" href="#events"></a>4.1.5. Events</h4>
<div class="paragraph">
<p>The following events are published by listener containers and their consumers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ContainerIdleEvent</code>: Issued when no messages have been received in <code>idleInterval</code> (if configured).</p>
</li>
<li>
<p><code>NonResponsiveConsumerEvent</code>: Issued when the consumer appears to be blocked in the <code>poll</code> method.</p>
</li>
<li>
<p><code>ConsumerPausedEvent</code>: Issued by each consumer when the container is paused.</p>
</li>
<li>
<p><code>ConsumerResumedEvent</code>: Issued by each consumer when the container is resumed.</p>
</li>
<li>
<p><code>ConsumerStoppingEvent</code>: Issued by each consumer just before stopping.</p>
</li>
<li>
<p><code>ConsumerStoppedEvent</code>: Issued after the consumer is closed.
See <a href="#thread-safety">Thread Safety</a>.</p>
</li>
<li>
<p><code>ContainerStoppedEvent</code>: Issued when all consumers have terminated.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the application context&#8217;s event multicaster invokes event listeners on the calling thread.
If you change the multicaster to use an async executor, you must not invoke any <code>Consumer</code> methods when the event contains a reference to the consumer.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ContainerIdleEvent</code> has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code>: The listener container instance that published the event.</p>
</li>
<li>
<p><code>container</code>: The listener container or the parent listener container, if the source container is a child.</p>
</li>
<li>
<p><code>id</code>: The listener ID (or container bean name).</p>
</li>
<li>
<p><code>idleTime</code>: The time the container had been idle when the event was published.</p>
</li>
<li>
<p><code>topicPartitions</code>: The topics and partitions that the container was assigned at the time the event was generated.</p>
</li>
<li>
<p><code>consumer</code>: A reference to the Kafka <code>Consumer</code> object.
For example, if the consumer&#8217;s <code>pause()</code> method was previously called, it can <code>resume()</code> when the event is received.</p>
</li>
<li>
<p><code>paused</code>: Whether the container is currently paused.
See <a href="#pause-resume">Pausing and Resuming Listener Containers</a> for more information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>NonResponsiveConsumerEvent</code> has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code>: The listener container instance that published the event.</p>
</li>
<li>
<p><code>container</code>: The listener container or the parent listener container, if the source container is a child.</p>
</li>
<li>
<p><code>id</code>: The listener ID (or container bean name).</p>
</li>
<li>
<p><code>timeSinceLastPoll</code>: The time just before the container last called <code>poll()</code>.</p>
</li>
<li>
<p><code>topicPartitions</code>: The topics and partitions that the container was assigned at the time the event was generated.</p>
</li>
<li>
<p><code>consumer</code>: A reference to the Kafka <code>Consumer</code> object.
For example, if the consumer&#8217;s <code>pause()</code> method was previously called, it can <code>resume()</code> when the event is received.</p>
</li>
<li>
<p><code>paused</code>: Whether the container is currently paused.
See <a href="#pause-resume">Pausing and Resuming Listener Containers</a> for more information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ConsumerPausedEvent</code>, <code>ConsumerResumedEvent</code>, and <code>ConsumerStopping</code> events have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code>: The listener container instance that published the event.</p>
</li>
<li>
<p><code>container</code>: The listener container or the parent listener container, if the source container is a child.</p>
</li>
<li>
<p><code>partitions</code>: The <code>TopicPartition</code> instances involved.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ConsumerStoppedEvent</code> and <code>ContainerStoppedEvent</code> events have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code>: The listener container instance that published the event.</p>
</li>
<li>
<p><code>container</code>: The listener container or the parent listener container, if the source container is a child.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All containers (whether a child or a parent) publish <code>ContainerStoppedEvent</code>.
For a parent container, the source and container properties are identical.</p>
</div>
</div>
<div class="sect3">
<h4 id="serdes"><a class="anchor" href="#serdes"></a>4.1.6. Serialization, Deserialization, and Message Conversion</h4>
<div class="paragraph">
<p>Apache Kafka provides a high-level API for serializing and deserializing record values as well as their keys.
It is present with the <code>org.apache.kafka.common.serialization.Serializer&lt;T&gt;</code> and
<code>org.apache.kafka.common.serialization.Deserializer&lt;T&gt;</code> abstractions with some built-in implementations.
Meanwhile, we can specify serializer and deserializer classes by using <code>Producer</code> or <code>Consumer</code> configuration properties.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class);
props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
...
props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class);
props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more complex or particular cases, the <code>KafkaConsumer</code> (and, therefore, <code>KafkaProducer</code>) provides overloaded constructors to accept <code>Serializer</code> and <code>Deserializer</code> instances for <code>keys</code> and <code>values</code>, respectively.</p>
</div>
<div class="paragraph">
<p>When you use this API, the <code>DefaultKafkaProducerFactory</code> and <code>DefaultKafkaConsumerFactory</code> also provide properties (through constructors or setter methods) to inject custom <code>Serializer</code> and <code>Deserializer</code> instances into the target <code>Producer</code> or <code>Consumer</code>.</p>
</div>
<div class="paragraph">
<p>Spring for Apache Kafka also provides <code>JsonSerializer</code> and <code>JsonDeserializer</code> implementations that are based on the Jackson JSON object mapper.
The <code>JsonSerializer</code> allows writing any Java object as a JSON <code>byte[]</code>.
The <code>JsonDeserializer</code> requires an additional <code>Class&lt;?&gt; targetType</code> argument to allow the deserialization of a consumed <code>byte[]</code> to the proper target object.
The following example shows how to create a <code>JsonDeserializer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JsonDeserializer&lt;Thing&gt; thingDeserializer = new JsonDeserializer&lt;&gt;(Thing.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can customize both <code>JsonSerializer</code> and <code>JsonDeserializer</code> with an <code>ObjectMapper</code>.
You can also extend them to implement some particular configuration logic in the <code>configure(Map&lt;String, ?&gt; configs, boolean isKey)</code> method.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.1, you can convey type information in record <code>Headers</code>, allowing the handling of multiple types.
In addition, you can configure the serializer and deserializer by using the following Kafka properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JsonSerializer.ADD_TYPE_INFO_HEADERS</code> (default <code>true</code>): You can set it to <code>false</code> to disable this feature on the <code>JsonSerializer</code> (sets the <code>addTypeInfo</code> property).</p>
</li>
<li>
<p><code>JsonSerializer.TYPE_MAPPINGS</code> (default <code>empty</code>): See <a href="#serdes-mapping-types">Mapping Types</a>.</p>
</li>
<li>
<p><code>JsonDeserializer.USE_TYPE_INFO_HEADERS</code> (default <code>true</code>): You can set it to <code>false</code> to ignore headers set by the serializer.</p>
</li>
<li>
<p><code>JsonDeserializer.REMOVE_TYPE_INFO_HEADERS</code> (default <code>true</code>): You can set it to <code>false</code> to retain headers set by the serializer.</p>
</li>
<li>
<p><code>JsonDeserializer.KEY_DEFAULT_TYPE</code>: Fallback type for deserialization of keys if no header information is present.</p>
</li>
<li>
<p><code>JsonDeserializer.VALUE_DEFAULT_TYPE</code>: Fallback type for deserialization of values if no header information is present.</p>
</li>
<li>
<p><code>JsonDeserializer.TRUSTED_PACKAGES</code> (default <code>java.util</code>, <code>java.lang</code>): Comma-delimited list of package patterns allowed for deserialization.
<code>*</code> means deserialize all.</p>
</li>
<li>
<p><code>JsonDeserializer.TYPE_MAPPINGS</code> (default <code>empty</code>): See <a href="#serdes-mapping-types">Mapping Types</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the type information headers (if added by the serializer) are removed by the deserializer.
You can revert to the previous behavior by setting the <code>removeTypeHeaders</code> property to <code>false</code>, either directly on the deserializer or with the configuration property described earlier.</p>
</div>
<div class="sect4">
<h5 id="serdes-mapping-types"><a class="anchor" href="#serdes-mapping-types"></a>Mapping Types</h5>
<div class="paragraph">
<p>Starting with version 2.2, you can now provide type mappings by using the properties in the preceding list.
Previously, you had to customize the type mapper within the serializer and deserializer.
Mappings consist of a comma-delimited list of <code>token:className</code> pairs.
On outbound, the payload&#8217;s class name is mapped to the corresponding token.
On inbound, the token in the type header is mapped to the corresponding class name.</p>
</div>
<div class="paragraph">
<p>The following example creates a set of mappings:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">senderProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
senderProps.put(JsonSerializer.TYPE_MAPPINGS, "cat:com.mycat.Cat, hat:com.myhat.hat");
...
consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
consumerProps.put(JsonDeSerializer.TYPE_MAPPINGS, "cat:com.yourcat.Cat, hat:com.yourhat.hat");</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The corresponding objects must be compatible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-messaging.html#boot-features-kafka">Spring Boot</a>, you can provide these properties in the <code>application.properties</code> (or yaml) file.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.type.mapping=cat:com.mycat.Cat,hat:com.myhat.Hat</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can perform only simple configuration with properties.
For more advanced configuration (such as using a custom <code>ObjectMapper</code> in the serializer and deserializer), you should use the producer and consumer factory constructors that accept a pre-built serializer and deserializer.
The following Spring Boot example overrides the default factories:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConsumerFactory&lt;Foo, Bar&gt; kafkaConsumerFactory(KafkaProperties properties,
    JsonDeserializer customDeserializer) {

    return new DefaultKafkaConsumerFactory&lt;&gt;(properties.buildConsumerProperties(),
        customDeserializer, customDeserializer);
}

@Bean
public ProducererFactory&lt;Foo, Bar&gt; kafkaProducerFactory(KafkaProperties properties,
    JsonSserializer customSerializer) {

    return new DefaultKafkaConsumerFactory&lt;&gt;(properties.buildProducerProperties(),
        customSerializer, customSerializer);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Setters are also provided, as an alternative to using these constructors.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.2, you can explicitly configure the deserializer to use the supplied target type and ignore type information in headers by using one of the overloaded constructors that have a boolean <code>useHeadersIfPresent</code> (which is <code>true</code> by default).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DefaultKafkaConsumerFactory&lt;Integer, Cat1&gt; cf = new DefaultKafkaConsumerFactory&lt;&gt;(props,
        new IntegerDeserializer(), new JsonDeserializer&lt;&gt;(Cat1.class, false));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-messaging-message-conversion"><a class="anchor" href="#spring-messaging-message-conversion"></a>Spring Messaging Message Conversion</h5>
<div class="paragraph">
<p>Although the <code>Serializer</code> and <code>Deserializer</code> API is quite simple and flexible from the low-level Kafka <code>Consumer</code> and <code>Producer</code> perspective, you might need more flexibility at the Spring Messaging level, when using either <code>@KafkaListener</code> or <a href="#si-kafka">Spring Integration</a>.
To let you easily convert to and from <code>org.springframework.messaging.Message</code>, Spring for Apache Kafka provides a <code>MessageConverter</code> abstraction with the <code>MessagingMessageConverter</code> implementation and its <code>StringJsonMessageConverter</code> and <code>BytesJsonMessageConverter</code> customization.
You can inject the <code>MessageConverter</code> into a <code>KafkaTemplate</code> instance directly and by using <code>AbstractKafkaListenerContainerFactory</code> bean definition for the <code>@KafkaListener.containerFactory()</code> property.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaListenerContainerFactory&lt;?&gt; kafkaJsonListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
        new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    factory.setConsumerFactory(consumerFactory());
    factory.setMessageConverter(new StringJsonMessageConverter());
    return factory;
}
...
@KafkaListener(topics = "jsonData",
                containerFactory = "kafkaJsonListenerContainerFactory")
public void jsonListener(Cat cat) {
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use a <code>@KafkaListener</code>, the parameter type is provided to the message converter to assist with the conversion.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This type inference can be achieved only when the <code>@KafkaListener</code> annotation is declared at the method level.
With a class-level <code>@KafkaListener</code>, the payload type is used to select which <code>@KafkaHandler</code> method to invoke, so it must already have been converted before the method can be chosen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use the <code>StringJsonMessageConverter</code>, you should use a <code>StringDeserializer</code> in the Kafka consumer configuration and a <code>StringSerializer</code> in the Kafka producer configuration when you use Spring Integration or the <code>KafkaTemplate.send(Message&lt;?&gt; message)</code> method.
When you use the <code>BytesJsonMessageConverter</code>, you should use a <code>BytesDeserializer</code> in the Kafka consumer configuration and <code>BytesSerializer</code> in the Kafka producer configuration when you use Spring Integration or the <code>KafkaTemplate.send(Message&lt;?&gt; message)</code> method (see <a href="#kafka-template">Using <code>KafkaTemplate</code></a>).
Generally, the <code>BytesJsonMessageConverter</code> is more efficient because it avoids a <code>String</code> to and from <code>byte[]</code> conversion.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="error-handling-deserializer"><a class="anchor" href="#error-handling-deserializer"></a>Using <code>ErrorHandlingDeserializer</code></h5>
<div class="paragraph">
<p>When a deserializer fails to deserialize a message, Spring has no way to handle the problem, because it occurs before the <code>poll()</code> returns.
To solve this problem, version 2.2 introduced the <code>ErrorHandlingDeserializer2</code>.
This deserializer delegates to a real deserializer (key or value).
If the delegate fails to deserialize the record content, the <code>ErrorHandlingDeserializer2</code> returns a <code>null</code> value and a <code>DeserializationException</code> in a header that contains the cause and the raw bytes.
When you use a record-level <code>MessageListener</code>, if the <code>ConsumerRecord</code> contains a <code>DeserializationException</code> header for either the key or value, the container&#8217;s <code>ErrorHandler</code> is called with the failed <code>ConsumerRecord</code>.
The record is not passed to the listener.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can configure the <code>ErrorHandlingDeserializer2</code> to create a custom value by providing a <code>failedDeserializationFunction</code>, which is a <code>BiConsumer&lt;byte[], Headers, T&gt;</code>.
This function is invoked to create an instance of <code>T</code>, which is passed to the listener in the usual fashion.
The raw record value and headers are provided to the function.
You can find the <code>DeserializationException</code> (as a serialized Java object) in headers.
See the <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/serializer/ErrorHandlingDeserializer2.html">Javadoc</a> for the <code>ErrorHandlingDeserializer2</code> for more information.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When you use a <code>BatchMessageListener</code>, you must provide a <code>failedDeserializationFunction</code>.
Otherwise, the batch of records are not type safe.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use the <code>DefaultKafkaConsumerFactory</code> constructor that takes key and value <code>Deserializer</code> objects and wire in appropriate <code>ErrorHandlingDeserializer2</code> instances that you have configured with the proper delegates.
Alternatively, you can use consumer configuration properties (which are used by the <code>ErrorHandlingDeserializer</code>) to instantiate the delegates.
The property names are <code>ErrorHandlingDeserializer2.KEY_DESERIALIZER_CLASS</code> and <code>ErrorHandlingDeserializer2.VALUE_DESERIALIZER_CLASS</code>.
The property value can be a class or class name.
The following example shows how to set these properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">... // other props
props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer2.class);
props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer2.class);
props.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS, JsonDeserializer.class);
props.put(JsonDeserializer.KEY_DEFAULT_TYPE, "com.example.MyKey")
props.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class.getName());
props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.example.MyValue")
props.put(JsonDeserializer.TRUSTED_PACKAGES, "com.example")
return new DefaultKafkaConsumerFactory&lt;&gt;(props);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example uses a <code>failedDeserializationFunction</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class BadFoo extends Foo {

  private final byte[] failedDecode;

  public BadFoo(byte[] failedDecode) {
    this.failedDecode = failedDecode;
  }

  public byte[] getFailedDecode() {
    return this.failedDecode;
  }

}

public class FailedFooProvider implements BiFunction&lt;byte[], Headers, Foo&gt; {

  @Override
  public Foo apply(byte[] t, Headers u) {
    return new BadFoo(t);
  }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example uses the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer2.class);
consumerProps.put(ErrorHandlingDeserializer2.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
consumerProps.put(ErrorHandlingDeserializer2.VALUE_FUNCTION, FailedFooProvider.class);
...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="payload-conversion-with-batch"><a class="anchor" href="#payload-conversion-with-batch"></a>Payload Conversion with Batch Listeners</h5>
<div class="paragraph">
<p>Starting with version 1.3.2, you can also use a <code>StringJsonMessageConverter</code> or <code>BytesJsonMessageConverter</code> within a <code>BatchMessagingMessageConverter</code> to convert batch messages when you use a batch listener container factory.
See <a href="#serdes">Serialization, Deserialization, and Message Conversion</a> for more information.</p>
</div>
<div class="paragraph">
<p>By default, the type for the conversion is inferred from the listener argument.
If you configure the <code>(Bytes|String)JsonMessageConverter</code> with a <code>DefaultJackson2TypeMapper</code> that has its <code>TypePrecedence</code> set to <code>TYPE_ID</code> (instead of the default <code>INFERRED</code>), the converter uses the type information in headers (if present) instead.
This allows, for example, listener methods to be declared with interfaces instead of concrete classes.
Also, the type converter supports mapping, so the deserialization can be to a different type than the source (as long as the data is compatible).
This is also useful when you use <a href="#class-level-kafkalistener">class-level <code>@KafkaListener</code> instances</a> where the payload must have already been converted to determine which method to invoke.
The following example creates beans that use this method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    factory.setConsumerFactory(consumerFactory());
    factory.setBatchListener(true);
    factory.setMessageConverter(new BatchMessagingMessageConverter(converter()));
    return factory;
}

@Bean
public StringJsonMessageConverter converter() {
    return new StringJsonMessageConverter();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that, for this to work, the method signature for the conversion target must be a container object with a single generic parameter type, such as the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(topics = "blc1")
public void listen(List&lt;Foo&gt; foos, @Header(KafkaHeaders.OFFSET) List&lt;Long&gt; offsets) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that you can still access the batch headers.</p>
</div>
<div class="paragraph">
<p>If the batch converter has a record converter that supports it, you can also receive a list of messages where the payloads are converted according to the generic type.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(topics = "blc3", groupId = "blc3")
public void listen1(List&lt;Message&lt;Foo&gt;&gt; fooMessages) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conversionservice-customization"><a class="anchor" href="#conversionservice-customization"></a><code>ConversionService</code> Customization</h5>
<div class="paragraph">
<p>Starting with version 2.1.1, the <code>org.springframework.core.convert.ConversionService</code> used by the default <code>o.s.messaging.handler.annotation.support.MessageHandlerMethodFactory</code> to resolve parameters for the invocation of a listener method is supplied with all beans that implement any of the following interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.core.convert.converter.Converter</code></p>
</li>
<li>
<p><code>org.springframework.core.convert.converter.GenericConverter</code></p>
</li>
<li>
<p><code>org.springframework.format.Formatter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This lets you further customize listener deserialization without changing the default configuration for <code>ConsumerFactory</code> and <code>KafkaListenerContainerFactory</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Setting a custom <code>MessageHandlerMethodFactory</code> on the <code>KafkaListenerEndpointRegistrar</code> through a <code>KafkaListenerConfigurer</code> bean disables this feature.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers"><a class="anchor" href="#headers"></a>4.1.7. Message Headers</h4>
<div class="paragraph">
<p>The 0.11.0.0 client introduced support for headers in messages.
As of version 2.0, Spring for Apache Kafka now supports mapping these headers to and from <code>spring-messaging</code> <code>MessageHeaders</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Previous versions mapped <code>ConsumerRecord</code> and <code>ProducerRecord</code> to spring-messaging <code>Message&lt;?&gt;</code>, where the value property is mapped to and from the <code>payload</code> and other properties (<code>topic</code>, <code>partition</code>, and so on) were mapped to headers.
This is still the case, but additional (arbitrary) headers can now be mapped.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Apache Kafka headers have a simple API, shown in the following interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Header {

    String key();

    byte[] value();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>KafkaHeaderMapper</code> strategy is provided to map header entries between Kafka <code>Headers</code> and <code>MessageHeaders</code>.
Its interface definition is as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface KafkaHeaderMapper {

    void fromHeaders(MessageHeaders headers, Headers target);

    void toHeaders(Headers source, Map&lt;String, Object&gt; target);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultKafkaHeaderMapper</code> maps the key to the <code>MessageHeaders</code> header name and, in order to support rich header types for outbound messages, JSON conversion is performed.
A &#8220;special&#8221; header (with a key of <code>spring_json_header_types</code>) contains a JSON map of <code>&lt;key&gt;:&lt;type&gt;</code>.
This header is used on the inbound side to provide appropriate conversion of each header value to the original type.</p>
</div>
<div class="paragraph">
<p>On the inbound side, all Kafka <code>Header</code> instances are mapped to <code>MessageHeaders</code>.
On the outbound side, by default, all <code>MessageHeaders</code> are mapped, except <code>id</code>, <code>timestamp</code>, and the headers that map to <code>ConsumerRecord</code> properties.</p>
</div>
<div class="paragraph">
<p>You can specify which headers are to be mapped for outbound messages, by providing patterns to the mapper.
The following listing shows a number of example mappings:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public DefaultKafkaHeaderMapper() { <i class="conum" data-value="1"></i><b>(1)</b>
    ...
}

public DefaultKafkaHeaderMapper(ObjectMapper objectMapper) { <i class="conum" data-value="2"></i><b>(2)</b>
    ...
}

public DefaultKafkaHeaderMapper(String... patterns) { <i class="conum" data-value="3"></i><b>(3)</b>
    ...
}

public DefaultKafkaHeaderMapper(ObjectMapper objectMapper, String... patterns) { <i class="conum" data-value="4"></i><b>(4)</b>
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uses a default Jackson <code>ObjectMapper</code> and maps most headers, as discussed before the example.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Uses the provided Jackson <code>ObjectMapper</code> and maps most headers, as discussed before the example.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Uses a default Jackson <code>ObjectMapper</code> and maps headers according to the provided patterns.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Uses the provided Jackson <code>ObjectMapper</code> and maps headers according to the provided patterns.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Patterns are rather simple and can contain a leading wildcard (<code><strong></code>), a trailing wildcard, or both (for example, <code></strong>.cat.*</code>).
You can negate patterns with a leading <code>!</code>.
The first pattern that matches a header name (whether positive or negative) wins.</p>
</div>
<div class="paragraph">
<p>When you provide your own patterns, we recommend including <code>!id</code> and <code>!timestamp</code>, since these headers are read-only on the inbound side.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the mapper deserializes only classes in <code>java.lang</code> and <code>java.util</code>.
You can trust other (or all) packages by adding trusted packages with the <code>addTrustedPackages</code> method.
If you receive messages from untrusted sources, you may wish to add only those packages you trust.
To trust all packages, you can use <code>mapper.addTrustedPackages("*")</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Mapping <code>String</code> header values in a raw form is useful when communicating with systems that are not aware of the mapper&#8217;s JSON format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.2.5, you can specify that certain string-valued headers should not be mapped using JSON, but to/from a raw <code>byte[]</code>.
The <code>AbstractKafkaHeaderMapper</code> has new properties; <code>mapAllStringsOut</code> when set to true, all string-valued headers will be converted to <code>byte[]</code> using the <code>charset</code> property (default <code>UTF-8</code>).
In addition, there is a property <code>rawMappedHeaders</code>, which is a map of <code>header name : boolean</code>; if the map contains a header name, and the header contains a <code>String</code> value, it will be mapped as a raw <code>byte[]</code> using the charset.
This map is also used to map raw incoming <code>byte[]</code> headers to <code>String</code> using the charset if, and only if, the boolean in the map value is <code>true</code>.
If the boolean is <code>false</code>, or the header name is not in the map with a <code>true</code> value, the incoming header is simply mapped as the raw unmapped header.</p>
</div>
<div class="paragraph">
<p>The following test case illustrates this mechanism.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testSpecificStringConvert() {
    DefaultKafkaHeaderMapper mapper = new DefaultKafkaHeaderMapper();
    Map&lt;String, Boolean&gt; rawMappedHeaders = new HashMap&lt;&gt;();
    rawMappedHeaders.put("thisOnesAString", true);
    rawMappedHeaders.put("thisOnesBytes", false);
    mapper.setRawMappedHaeaders(rawMappedHeaders);
    Map&lt;String, Object&gt; headersMap = new HashMap&lt;&gt;();
    headersMap.put("thisOnesAString", "thing1");
    headersMap.put("thisOnesBytes", "thing2");
    headersMap.put("alwaysRaw", "thing3".getBytes());
    MessageHeaders headers = new MessageHeaders(headersMap);
    Headers target = new RecordHeaders();
    mapper.fromHeaders(headers, target);
    assertThat(target).containsExactlyInAnyOrder(
            new RecordHeader("thisOnesAString", "thing1".getBytes()),
            new RecordHeader("thisOnesBytes", "thing2".getBytes()),
            new RecordHeader("alwaysRaw", "thing3".getBytes()));
    headersMap.clear();
    mapper.toHeaders(target, headersMap);
    assertThat(headersMap).contains(
            entry("thisOnesAString", "thing1"),
            entry("thisOnesBytes", "thing2".getBytes()),
            entry("alwaysRaw", "thing3".getBytes()));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the <code>DefaultKafkaHeaderMapper</code> is used in the <code>MessagingMessageConverter</code> and <code>BatchMessagingMessageConverter</code>, as long as Jackson is on the class path.</p>
</div>
<div class="paragraph">
<p>With the batch converter, the converted headers are available in the <code>KafkaHeaders.BATCH_CONVERTED_HEADERS</code> as a <code>List&lt;Map&lt;String, Object&gt;&gt;</code> where the map in a position of the list corresponds to the data position in the payload.</p>
</div>
<div class="paragraph">
<p>If there is no converter (either because Jackson is not present or it is explicitly set to <code>null</code>), the headers from the consumer record are provided unconverted in the <code>KafkaHeaders.NATIVE_HEADERS</code> header.
This header is a <code>Headers</code> object (or a <code>List&lt;Headers&gt;</code> in the case of the batch converter), where the position in the list corresponds to the data position in the payload).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Certain types are not suitable for JSON serialization, and a simple <code>toString()</code> serialization might be preferred for these types.
The <code>DefaultKafkaHeaderMapper</code> has a method called <code>addToStringClasses()</code> that lets you supply the names of classes that should be treated this way for outbound mapping.
During inbound mapping, they are mapped as <code>String</code>.
By default, only <code>org.springframework.util.MimeType</code> and <code>org.springframework.http.MediaType</code> are mapped this way.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="tombstones"><a class="anchor" href="#tombstones"></a>4.1.8. Null Payloads and Log Compaction of 'Tombstone' Records</h4>
<div class="paragraph">
<p>When you use <a href="https://kafka.apache.org/documentation/#compaction">Log Compaction</a>, you can send and receive messages with <code>null</code> payloads to identify the deletion of a key.</p>
</div>
<div class="paragraph">
<p>You can also receive <code>null</code> values for other reasons, such as a <code>Deserializer</code> that might return <code>null</code> when it cannot deserialize a value.</p>
</div>
<div class="paragraph">
<p>To send a <code>null</code> payload by using the <code>KafkaTemplate</code>, you can pass null into the value argument of the <code>send()</code> methods.
One exception to this is the <code>send(Message&lt;?&gt; message)</code> variant.
Since <code>spring-messaging</code> <code>Message&lt;?&gt;</code> cannot have a <code>null</code> payload, you can use a special payload type called <code>KafkaNull</code>, and the framework sends <code>null</code>.
For convenience, the static <code>KafkaNull.INSTANCE</code> is provided.</p>
</div>
<div class="paragraph">
<p>When you use a message listener container, the received <code>ConsumerRecord</code> has a <code>null</code> <code>value()</code>.</p>
</div>
<div class="paragraph">
<p>To configure the <code>@KafkaListener</code> to handle <code>null</code> payloads, you must use the <code>@Payload</code> annotation with <code>required = false</code>.
If it is a tombstone message for a compacted log, you usually also need the key so that your application can determine which key was &#8220;deleted&#8221;.
The following example shows such a configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "deletableListener", topics = "myTopic")
public void listen(@Payload(required = false) String value, @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String key) {
    // value == null represents key deletion
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use a class-level <code>@KafkaListener</code> with multiple <code>@KafkaHandler</code> methods, some additional configuration is needed.
Specifically, you need a <code>@KafkaHandler</code> method with a <code>KafkaNull</code> payload.
The following example shows how to configure one:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@KafkaListener(id = "multi", topics = "myTopic")
static class MultiListenerBean {

    @KafkaHandler
    public void listen(String cat) {
        ...
    }

    @KafkaHandler
    public void listen(Integer hat) {
        ...
    }

    @KafkaHandler
    public void delete(@Payload(required = false) KafkaNull nul, @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) int key) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the argument is <code>null</code>, not <code>KafkaNull</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="annotation-error-handling"><a class="anchor" href="#annotation-error-handling"></a>4.1.9. Handling Exceptions</h4>
<div class="paragraph">
<p>This section describes how to handle various exceptions that may arise when you use Spring for Apache Kafka.</p>
</div>
<div class="sect4">
<h5 id="listener-error-handlers"><a class="anchor" href="#listener-error-handlers"></a>Listener Error Handlers</h5>
<div class="paragraph">
<p>Starting with version 2.0, the <code>@KafkaListener</code> annotation has a new attribute: <code>errorHandler</code>.</p>
</div>
<div class="paragraph">
<p>By default, this attribute is not configured.</p>
</div>
<div class="paragraph">
<p>You can use the <code>errorHandler</code> to provide the bean name of a <code>KafkaListenerErrorHandler</code> implementation.
This functional interface has one method, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface KafkaListenerErrorHandler {

    Object handleError(Message&lt;?&gt; message, ListenerExecutionFailedException exception) throws Exception;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You have access to the spring-messaging <code>Message&lt;?&gt;</code> object produced by the message converter and the exception that was thrown by the listener, which is wrapped in a <code>ListenerExecutionFailedException</code>.
The error handler can throw the original or a new exception, which is thrown to the container.
Anything returned by the error handler is ignored.</p>
</div>
<div class="paragraph">
<p>It has a sub-interface (<code>ConsumerAwareListenerErrorHandler</code>) that has access to the consumer object, through the following method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object handleError(Message&lt;?&gt; message, ListenerExecutionFailedException exception, Consumer&lt;?, ?&gt; consumer);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If your error handler implements this interface, you can, for example, adjust the offsets accordingly.
For example, to reset the offset to replay the failed message, you could do something like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConsumerAwareListenerErrorHandler listen3ErrorHandler() {
    return (m, e, c) -&gt; {
        this.listen3Exception = e;
        MessageHeaders headers = m.getHeaders();
        c.seek(new org.apache.kafka.common.TopicPartition(
                headers.get(KafkaHeaders.RECEIVED_TOPIC, String.class),
                headers.get(KafkaHeaders.RECEIVED_PARTITION_ID, Integer.class)),
                headers.get(KafkaHeaders.OFFSET, Long.class));
        return null;
    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, you could do something like the following for a batch listener:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConsumerAwareListenerErrorHandler listen10ErrorHandler() {
    return (m, e, c) -&gt; {
        this.listen10Exception = e;
        MessageHeaders headers = m.getHeaders();
        List&lt;String&gt; topics = headers.get(KafkaHeaders.RECEIVED_TOPIC, List.class);
        List&lt;Integer&gt; partitions = headers.get(KafkaHeaders.RECEIVED_PARTITION_ID, List.class);
        List&lt;Long&gt; offsets = headers.get(KafkaHeaders.OFFSET, List.class);
        Map&lt;TopicPartition, Long&gt; offsetsToReset = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; topics.size(); i++) {
            int index = i;
            offsetsToReset.compute(new TopicPartition(topics.get(i), partitions.get(i)),
                    (k, v) -&gt; v == null ? offsets.get(index) : Math.min(v, offsets.get(index)));
        }
        offsetsToReset.forEach((k, v) -&gt; c.seek(k, v));
        return null;
    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This resets each topic/partition in the batch to the lowest offset in the batch.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding two examples are simplistic implementations, and you would probably want more checking in the error handler.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="container-error-handlers"><a class="anchor" href="#container-error-handlers"></a>Container Error Handlers</h5>
<div class="paragraph">
<p>You can specify a global error handler to be used for all listeners in the container factory.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt;
        kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    ...
    factory.setErrorHandler(myErrorHandler);
    ...
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can set a global batch error handler:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt;
        kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory =
            new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
    ...
    factory.setBatchErrorHandler(myBatchErrorHandler);
    ...
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, if an annotated listener method throws an exception, it is thrown to the container, and the message is handled according to the container configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="consumer-aware-container-error-handlers"><a class="anchor" href="#consumer-aware-container-error-handlers"></a>Consumer-Aware Container Error Handlers</h5>
<div class="paragraph">
<p>The container-level error handlers (<code>ErrorHandler</code> and <code>BatchErrorHandler</code>) have sub-interfaces called <code>ConsumerAwareErrorHandler</code> and <code>ConsumerAwareBatchErrorHandler</code>.
The <code>handle</code> method of the <code>ConsumerAwareErrorHandler</code> has the following signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void handle(Exception thrownException, ConsumerRecord&lt;?, ?&gt; data, Consumer&lt;?, ?&gt; consumer);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>handle</code> method of the <code>ConsumerAwareBatchErrorHandler</code> has the following signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void handle(Exception thrownException, ConsumerRecords&lt;?, ?&gt; data, Consumer&lt;?, ?&gt; consumer);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similar to the <code>@KafkaListener</code> error handlers, you can reset the offsets as needed, based on the data that failed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the listener-level error handlers, however, you should set the <code>ackOnError</code> container property to false when making adjustments.
Otherwise, any pending acks are applied after your repositioning.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="seek-to-current"><a class="anchor" href="#seek-to-current"></a>Seek To Current Container Error Handlers</h5>
<div class="paragraph">
<p>If an <code>ErrorHandler</code> implements <code>RemainingRecordsErrorHandler</code>, the error handler is provided with the failed record and any unprocessed records retrieved by the previous <code>poll()</code>.
Those records are not passed to the listener after the handler exits.
The following listing shows the <code>RemainingRecordsErrorHandler</code> interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface RemainingRecordsErrorHandler extends ConsumerAwareErrorHandler {

    void handle(Exception thrownException, List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Consumer&lt;?, ?&gt; consumer);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This interface lets implementations seek all unprocessed topics and partitions so that the current record (and the others remaining) are retrieved by the next poll.
<code>SeekToCurrentErrorHandler</code> does exactly this.</p>
</div>
<div class="paragraph">
<p>The container commits any pending offset commits before calling the error handler.</p>
</div>
<div class="paragraph">
<p>To configure the listener container with this handler, add it to the <code>ContainerProperties</code>.</p>
</div>
<div class="paragraph">
<p>For example, with the <code>@KafkaListener</code> container factory, you can add <code>SeekToCurrentErrorHandler</code> as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() {
    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory();
    factory.setConsumerFactory(consumerFactory());
    factory.getContainerProperties().setAckOnError(false);
    factory.getContainerProperties().setAckMode(AckMode.RECORD);
    factory.setErrorHandler(new SeekToCurrentErrorHandler());
    return factory;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an example; if the <code>poll</code> returns six records (two from each partition 0, 1, 2) and the listener throws an exception on the fourth record, the container acknowledges the first three messages by committing their offsets.
The <code>SeekToCurrentErrorHandler</code> seeks to offset 1 for partition 1 and offset 0 for partition 2.
The next <code>poll()</code> returns the three unprocessed records.</p>
</div>
<div class="paragraph">
<p>If the <code>AckMode</code> was <code>BATCH</code>, the container commits the offsets for the first two partitions before calling the error handler.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the <code>SeekToCurrentErrorHandler</code> can now recover (skip) a record that keeps failing.
By default, after ten failures, the failed record is logged (at the <code>ERROR</code> level).
You can configure the handler with a custom recoverer (<code>BiConsumer</code>) and maximum failures.
Setting the <code>maxFailures</code> property to a negative number causes infinite retries.
The following example configures recovery after three tries:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SeekToCurrentErrorHandler errorHandler =
    new SeekToCurrentErrorHandler((record, exception) -&gt; {
        // recover after 3 failures - e.g. send to a dead-letter topic
    }, 3);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.2.4, when the container is configured with <code>AckMode.MANUAL_IMMEDIATE</code>, the error handler can be configured to commit the offset of recovered records; set the <code>commitRecovered</code> property to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#dead-letters">Publishing Dead-letter Records</a>.</p>
</div>
<div class="paragraph">
<p>When using transactions, similar functionality is provided by the <code>DefaultAfterRollbackProcessor</code>.
See <a href="#after-rollback">After-rollback Processor</a>.</p>
</div>
<div class="paragraph">
<p>The <code>SeekToCurrentBatchErrorHandler</code> seeks each partition to the first record in each partition in the batch, so the whole batch is replayed.
This error handler does not support recovery, because the framework cannot know which message in the batch is failing.</p>
</div>
<div class="paragraph">
<p>After seeking, an exception that wraps the <code>ListenerExecutionFailedException</code> is thrown.
This is to cause the transaction to roll back (if transactions are enabled).</p>
</div>
</div>
<div class="sect4">
<h5 id="container-stopping-error-handlers"><a class="anchor" href="#container-stopping-error-handlers"></a>Container Stopping Error Handlers</h5>
<div class="paragraph">
<p>The <code>ContainerStoppingErrorHandler</code> (used with record listeners) stops the container if the listener throws an exception.
When the <code>AckMode</code> is <code>RECORD</code>, offsets for already processed records are committed.
When the <code>AckMode</code> is any manual value, offsets for already acknowledged records are committed.
When the <code>AckMode</code> is <code>BATCH</code>, the entire batch is replayed when the container is restarted (unless transactions are enabled&#8201;&#8212;&#8201;in which case, only the unprocessed records are re-fetched).</p>
</div>
<div class="paragraph">
<p>The <code>ContainerStoppingBatchErrorHandler</code> (used with batch listeners) stops the container, and the entire batch is replayed when the container is restarted.</p>
</div>
<div class="paragraph">
<p>After the container stops, an exception that wraps the <code>ListenerExecutionFailedException</code> is thrown.
This is to cause the transaction to roll back (if transactions are enabled).</p>
</div>
</div>
<div class="sect4">
<h5 id="after-rollback"><a class="anchor" href="#after-rollback"></a>After-rollback Processor</h5>
<div class="paragraph">
<p>When using transactions, if the listener throws an exception (and an error handler, if present, throws an exception), the transaction is rolled back.
By default, any unprocessed records (including the failed record) are re-fetched on the next poll.
This is achieved by performing <code>seek</code> operations in the <code>DefaultAfterRollbackProcessor</code>.
With a batch listener, the entire batch of records is reprocessed (the container has no knowledge of which record in the batch failed).
To modify this behavior, you can configure the listener container with a custom <code>AfterRollbackProcessor</code>.
For example, with a record-based listener, you might want to keep track of the failed record and give up after some number of attempts, perhaps by publishing it to a dead-letter topic.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the <code>DefaultAfterRollbackProcessor</code> can now recover (skip) a record that keeps failing.
By default, after ten failures, the failed record is logged (at the <code>ERROR</code> level).
You can configure the processor with a custom recoverer (<code>BiConsumer</code>) and maximum failures.
Setting the <code>maxFailures</code> property to a negative number causes infinite retries.
The following example configures recovery after three tries:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AfterRollbackProcessor&lt;String, String&gt; processor =
    new DefaultAfterRollbackProcessor((record, exception) -&gt; {
        // recover after 3 failures - e.g. send to a dead-letter topic
    }, 3);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you do not use transactions, you can achieve similar functionality by configuring a <code>SeekToCurrentErrorHandler</code>.
See <a href="#seek-to-current">Seek To Current Container Error Handlers</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Recovery is not possible with a batch listener, since the framework has no knowledge about which record in the batch keeps failing.
In such cases, the application listener must handle a record that keeps failing.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See also <a href="#dead-letters">Publishing Dead-letter Records</a>.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2.5, the <code>DefaultAfterRollbackProcessor</code> can be invoked in a new transaction (started after the failed transaction rolls back).
Then, if you are using the <code>DeadLetterPublishingRecoverer</code> to publish a failed record, the processor will send the recovered record&#8217;s offset in the original topic/partition to the transaction.
To enable this feature, set the <code>processInTransaction</code> and <code>kafkaTemplate</code> properties on the <code>DefaultAfterRollbackProcessor</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="dead-letters"><a class="anchor" href="#dead-letters"></a>Publishing Dead-letter Records</h5>
<div class="paragraph">
<p>As <a href="#stateful-retry">discussed earlier</a>, you can configure the <code>SeekToCurrentErrorHandler</code> and <code>DefaultAfterRollbackProcessor</code> with a record recoverer when the maximum number of failures is reached for a record.
The framework provides the <code>DeadLetterPublishingRecoverer</code>, which publishes the failed message to another topic.
The recoverer requires a <code>KafkaTemplate&lt;Object, Object&gt;</code>, which is used to send the record.
You can also, optionally, configure it with a <code>BiFunction&lt;ConsumerRecord&lt;?, ?&gt;, Exception, TopicPartition&gt;</code>, which is called to resolve the destination topic and partition.
By default, the dead-letter record is sent to a topic named <code>&lt;originalTopic&gt;.DLT</code> (the original topic name suffixed with <code>.DLT</code>) and to the same partition as the original record.
Therefore, when you use the default resolver, the dead-letter topic must have at least as many partitions as the original topic.
If the returned <code>TopicPartition</code> has a negative partition, the partition is not set in the <code>ProducerRecord</code>, so the partition is selected by Kafka.
Starting with version 2.2.4, any <code>ListenerExecutionFailedException</code> (thrown, for example, when an exception is detected in a <code>@KafkaListener</code> method) is enhanced with the <code>groupId</code> property.
This allows the destination resolver to use this, in addition to the information in the <code>ConsumerRecord</code> to select the dead letter topic.</p>
</div>
<div class="paragraph">
<p>The following example shows how to wire a custom destination resolver:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DeadLetterPublishingRecoverer recoverer = new DeadLetterPublishingRecoverer(template,
        (r, e) -&gt; {
            if (e instanceof FooException) {
                return new TopicPartition(r.topic() + ".Foo.failures", r.partition());
            }
            else {
                return new TopicPartition(r.topic() + ".other.failures", r.partition());
            }
        });
ErrorHandler errorHandler = new SeekToCurrentErrorHandler(recoverer, 3);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The record sent to the dead-letter topic is enhanced with the following headers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KafkaHeaders.DLT_EXCEPTION_FQCN</code>: The Exception class name.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_EXCEPTION_STACKTRACE</code>: The Exception stack trace.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_EXCEPTION_MESSAGE</code>: The  Exception message.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_ORIGINAL_TOPIC</code>: The original topic.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_ORIGINAL_PARTITION</code>: The original partition.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_ORIGINAL_OFFSET</code>: The original offset.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_ORIGINAL_TIMESTAMP</code>: The original timestamp.</p>
</li>
<li>
<p><code>KafkaHeaders.DLT_ORIGINAL_TIMESTAMP_TYPE</code>: The original timestamp type.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kerberos"><a class="anchor" href="#kerberos"></a>4.1.10. Kerberos</h4>
<div class="paragraph">
<p>Starting with version 2.0, a <code>KafkaJaasLoginModuleInitializer</code> class has been added to assist with Kerberos configuration.
You can add this bean, with the desired configuration, to your application context.
The following example configures such a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaJaasLoginModuleInitializer jaasConfig() throws IOException {
    KafkaJaasLoginModuleInitializer jaasConfig = new KafkaJaasLoginModuleInitializer();
    jaasConfig.setControlFlag("REQUIRED");
    Map&lt;String, String&gt; options = new HashMap&lt;&gt;();
    options.put("useKeyTab", "true");
    options.put("storeKey", "true");
    options.put("keyTab", "/etc/security/keytabs/kafka_client.keytab");
    options.put("principal", "kafka-client-1@EXAMPLE.COM");
    jaasConfig.setOptions(options);
    return jaasConfig;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kafka-streams"><a class="anchor" href="#kafka-streams"></a>4.2. Kafka Streams Support</h3>
<div class="paragraph">
<p>Starting with version 1.1.4, Spring for Apache Kafka provides first-class support for <a href="https://kafka.apache.org/documentation/streams">Kafka Streams</a>.
To use it from a Spring application, the <code>kafka-streams</code> jar must be present on classpath.
It is an optional dependency of the <code>spring-kafka</code> project and is not downloaded transitively.</p>
</div>
<div class="sect3">
<h4 id="basics"><a class="anchor" href="#basics"></a>4.2.1. Basics</h4>
<div class="paragraph">
<p>The reference Apache Kafka Streams documentation suggests the following way of using the API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Use the builders to define the actual processing topology, e.g. to specify
// from which input topics to read, which stream operations (filter, map, etc.)
// should be called, and so on.

StreamsBuilder builder = ...;  // when using the Kafka Streams DSL

// Use the configuration to tell your application where the Kafka cluster is,
// which serializers/deserializers to use by default, to specify security settings,
// and so on.
StreamsConfig config = ...;

KafkaStreams streams = new KafkaStreams(builder, config);

// Start the Kafka Streams instance
streams.start();

// Stop the Kafka Streams instance
streams.close();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So, we have two main components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StreamsBuilder</code>: With an API to build <code>KStream</code> (or <code>KTable</code>) instances.</p>
</li>
<li>
<p><code>KafkaStreams</code>: To manage the lifecycle of those instances.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All <code>KStream</code> instances exposed to a <code>KafkaStreams</code> instance by a single <code>StreamsBuilder</code> are started and stopped at the same time, even if they have different logic.
In other words, all streams defined by a <code>StreamsBuilder</code> are tied with a single lifecycle control.
Once a <code>KafkaStreams</code> instance has been closed by <code>streams.close()</code>, it cannot be restarted.
Instead, a new <code>KafkaStreams</code> instance to restart stream processing must be created.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="spring-management"><a class="anchor" href="#spring-management"></a>4.2.2. Spring Management</h4>
<div class="paragraph">
<p>To simplify using Kafka Streams from the Spring application context perspective and use the lifecycle management through a container, the Spring for Apache Kafka introduces <code>StreamsBuilderFactoryBean</code>.
This is an <code>AbstractFactoryBean</code> implementation to expose a <code>StreamsBuilder</code> singleton instance as a bean.
The following example creates such a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public FactoryBean&lt;StreamsBuilderFactoryBean&gt; myKStreamBuilder(KafkaStreamsConfiguration streamsConfig) {
    return new StreamsBuilderFactoryBean(streamsConfig);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 2.2, the stream configuration is now provided as a <code>KafkaStreamsConfiguration</code> object rather than a <code>StreamsConfig</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>StreamsBuilderFactoryBean</code> also implements <code>SmartLifecycle</code> to manage the lifecycle of an internal <code>KafkaStreams</code> instance.
Similar to the Kafka Streams API, you must define the <code>KStream</code> instances before you start the <code>KafkaStreams</code>.
That also applies for the Spring API for Kafka Streams.
Therefore, when you use default <code>autoStartup = true</code> on the <code>StreamsBuilderFactoryBean</code>, you must declare <code>KStream</code> instances on the <code>StreamsBuilder</code> before the application context is refreshed.
For example, <code>KStream</code> can be a regular bean definition, while the Kafka Streams API is used without any impacts.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KStream&lt;?, ?&gt; kStream(StreamsBuilder kStreamBuilder) {
    KStream&lt;Integer, String&gt; stream = kStreamBuilder.stream(STREAMING_TOPIC1);
    // Fluent KStream API
    return stream;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you would like to control the lifecycle manually (for example, stopping and starting by some condition), you can reference the <code>StreamsBuilderFactoryBean</code> bean directly by using the factory bean (<code>&amp;</code>) <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-extension-factorybean">prefix</a>.
Since <code>StreamsBuilderFactoryBean</code> use its internal <code>KafkaStreams</code> instance, it is safe to stop and restart it again.
A new <code>KafkaStreams</code> is created on each <code>start()</code>.
You might also consider using different <code>StreamsBuilderFactoryBean</code> instances, if you would like to control the lifecycles for <code>KStream</code> instances separately.</p>
</div>
<div class="paragraph">
<p>You also can specify <code>KafkaStreams.StateListener</code>, <code>Thread.UncaughtExceptionHandler</code>, and <code>StateRestoreListener</code> options on the <code>StreamsBuilderFactoryBean</code>, which are delegated to the internal <code>KafkaStreams</code> instance.
Also, apart from setting those options indirectly on <code>StreamsBuilderFactoryBean</code>, starting with <em>version 2.1.5</em>, you can use a <code>KafkaStreamsCustomizer</code> callback interface to configure an inner <code>KafkaStreams</code> instance.
Note that <code>KafkaStreamsCustomizer</code> overrides the options provided by <code>StreamsBuilderFactoryBean</code>.
If you need to perform some <code>KafkaStreams</code> operations directly, you can access that internal <code>KafkaStreams</code> instance by using <code>StreamsBuilderFactoryBean.getKafkaStreams()</code>.
You can autowire <code>StreamsBuilderFactoryBean</code> bean by type, but you should be sure to use the full type in the bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public StreamsBuilderFactoryBean myKStreamBuilder(KafkaStreamsConfiguration streamsConfig) {
    return new StreamsBuilderFactoryBean(streamsConfig);
}
...
@Autowired
private StreamsBuilderFactoryBean myKStreamBuilderFactoryBean;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can add <code>@Qualifier</code> for injection by name if you use interface bean definition.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public FactoryBean&lt;StreamsBuilder&gt; myKStreamBuilder(KafkaStreamsConfiguration streamsConfig) {
    return new StreamsBuilderFactoryBean(streamsConfig);
}
...
@Autowired
@Qualifier("&amp;myKStreamBuilder")
private StreamsBuilderFactoryBean myKStreamBuilderFactoryBean;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="json-serialization-and-deserialization"><a class="anchor" href="#json-serialization-and-deserialization"></a>4.2.3. JSON Serialization and Deserialization</h4>
<div class="paragraph">
<p>For serializing and deserializing data when reading or writing to topics or state stores in JSON format, Spring Kafka provides a <code>JsonSerde</code> implementation that uses JSON, delegating to the <code>JsonSerializer</code> and <code>JsonDeserializer</code> described in <a href="#serdes">Serialization, Deserialization, and Message Conversion</a>.
The <code>JsonSerde</code> implementation provides the same configuration options through its constructor (target type or <code>ObjectMapper</code>).
In the following example, we use the <code>JsonSerde</code> to serialize and deserialize the <code>Cat</code> payload of a Kafka stream (the <code>JsonSerde</code> can be used in a similar fashion wherever an instance is required):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">stream.through(Serdes.Integer(), new JsonSerde&lt;&gt;(Cat.class), "cats");</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Since Kafka Streams do not support headers, the <code>addTypeInfo</code> property on the <code>JsonSerializer</code> is ignored.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-kafkastreamsbrancher"><a class="anchor" href="#using-kafkastreamsbrancher"></a>4.2.4. Using <code>KafkaStreamsBrancher</code></h4>
<div class="paragraph">
<p>The <code>KafkaStreamBrancher</code> class introduces a more convenient way to build conditional branches on top of <code>KStream</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following example that does not use <code>KafkaStreamBrancher</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">KStream&lt;String, String&gt;[] branches = builder.stream("source").branch(
      (key, value) -&gt; value.contains("A"),
      (key, value) -&gt; value.contains("B"),
      (key, value) -&gt; true
     );
branches[0].to("A");
branches[1].to("B");
branches[2].to("C");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example uses <code>KafkaStreamBrancher</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new KafkaStreamsBrancher&lt;String, String&gt;()
   .branch((key, value) -&gt; value.contains("A"), ks -&gt; ks.to("A"))
   .branch((key, value) -&gt; value.contains("B"), ks -&gt; ks.to("B"))
   //default branch should not necessarily be defined in the end of the chain!
   .defaultBranch(ks -&gt; ks.to("C"))
   .onTopOf(builder.stream("source"));
   //onTopOf method returns the provided stream so we can continue with method chaining</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="streams-config"><a class="anchor" href="#streams-config"></a>4.2.5. Configuration</h4>
<div class="paragraph">
<p>To configure the Kafka Streams environment, the <code>StreamsBuilderFactoryBean</code> requires a <code>KafkaStreamsConfiguration</code> instance.
See the Apache Kafka <a href="https://kafka.apache.org/0102/documentation/#streamsconfigs">documentation</a> for all possible options.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 2.2, the stream configuration is now provided as a <code>KafkaStreamsConfiguration</code> object, rather than as a <code>StreamsConfig</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To avoid boilerplate code for most cases, especially when you develop microservices, Spring for Apache Kafka provides the <code>@EnableKafkaStreams</code> annotation, which you should placed on a <code>@Configuration</code> class.
All you need is to declare a <code>KafkaStreamsConfiguration</code> bean named <code>defaultKafkaStreamsConfig</code>.
A <code>StreamsBuilder</code> bean, named <code>defaultKafkaStreamsBuilder</code>, is automatically declared in the application context.
You can declare and use any additional <code>StreamsBuilderFactoryBean</code> beans as well.</p>
</div>
<div class="paragraph">
<p>By default, when the factory bean is stopped, the <code>KafkaStreams.cleanUp()</code> method is called.
Starting with version 2.1.2, the factory bean has additional constructors, taking a <code>CleanupConfig</code> object that has properties to let you control whether the <code>cleanUp()</code> method is called during <code>start()</code> or <code>stop()</code> or neither.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafka-streams-example"><a class="anchor" href="#kafka-streams-example"></a>4.2.6. Kafka Streams Example</h4>
<div class="paragraph">
<p>The following example combines all the topics we have covered in this chapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableKafka
@EnableKafkaStreams
public static class KafkaStreamsConfig {

    @Bean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)
    public KafkaStreamsConfiguration kStreamsConfigs() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, "testStreams");
        props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.Integer().getClass().getName());
        props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());
        props.put(StreamsConfig.TIMESTAMP_EXTRACTOR_CLASS_CONFIG, WallclockTimestampExtractor.class.getName());
        return new KafkaStreamsConfiguration(props);
    }

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder kStreamBuilder) {
        KStream&lt;Integer, String&gt; stream = kStreamBuilder.stream("streamingTopic1");
        stream
                .mapValues(String::toUpperCase)
                .groupByKey()
                .reduce((String value1, String value2) -&gt; value1 + value2,
                		TimeWindows.of(1000),
                		"windowStore")
                .toStream()
                .map((windowedId, value) -&gt; new KeyValue&lt;&gt;(windowedId.key(), value))
                .filter((i, s) -&gt; s.length() &gt; 40)
                .to("streamingTopic2");

        stream.print();

        return stream;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing"><a class="anchor" href="#testing"></a>4.3. Testing Applications</h3>
<div class="paragraph">
<p>The <code>spring-kafka-test</code> jar contains some useful utilities to assist with testing your applications.</p>
</div>
<div class="sect3">
<h4 id="junit"><a class="anchor" href="#junit"></a>4.3.1. JUnit</h4>
<div class="paragraph">
<p><code>o.s.kafka.test.utils.KafkaTestUtils</code> provides some static methods to set up producer and consumer properties.
The following listing shows those method signatures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Set up test properties for an {@code &lt;Integer, String&gt;} consumer.
 * @param group the group id.
 * @param autoCommit the auto commit.
 * @param embeddedKafka a {@link EmbeddedKafkaBroker} instance.
 * @return the properties.
 */
public static Map&lt;String, Object&gt; consumerProps(String group, String autoCommit,
                                       EmbeddedKafkaBroker embeddedKafka) { ... }

/**
 * Set up test properties for an {@code &lt;Integer, String&gt;} producer.
 * @param embeddedKafka a {@link EmbeddedKafkaBroker} instance.
 * @return the properties.
 */
public static Map&lt;String, Object&gt; senderProps(EmbeddedKafkaBroker embeddedKafka) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A JUnit 4 <code>@Rule</code> wrapper for the <code>EmbeddedKafkaBroker</code> is provided to create an embedded Kafka and an embedded Zookeeper server.
(See <a href="#embedded-kafka-annotation">@EmbeddedKafka Annotation</a> for information about using <code>@EmbeddedKafka</code> with JUnit 5).
The following listing shows the signatures of those methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Create embedded Kafka brokers.
 * @param count the number of brokers.
 * @param controlledShutdown passed into TestUtils.createBrokerConfig.
 * @param topics the topics to create (2 partitions per).
 */
public EmbeddedKafkaRule(int count, boolean controlledShutdown, String... topics) { ... }

/**
 *
 * Create embedded Kafka brokers.
 * @param count the number of brokers.
 * @param controlledShutdown passed into TestUtils.createBrokerConfig.
 * @param partitions partitions per topic.
 * @param topics the topics to create.
 */
public EmbeddedKafkaRule(int count, boolean controlledShutdown, int partitions, String... topics) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>EmbeddedKafkaBroker</code> class has a utility method that lets you consume for all the topics it created.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; consumerProps = KafkaTestUtils.consumerProps("testT", "false", embeddedKafka);
DefaultKafkaConsumerFactory&lt;Integer, String&gt; cf = new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(
        consumerProps);
Consumer&lt;Integer, String&gt; consumer = cf.createConsumer();
embeddedKafka.consumeFromAllEmbeddedTopics(consumer);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>KafkaTestUtils</code> has some utility methods to fetch results from the consumer.
The following listing shows those method signatures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Poll the consumer, expecting a single record for the specified topic.
 * @param consumer the consumer.
 * @param topic the topic.
 * @return the record.
 * @throws org.junit.ComparisonFailure if exactly one record is not received.
 */
public static &lt;K, V&gt; ConsumerRecord&lt;K, V&gt; getSingleRecord(Consumer&lt;K, V&gt; consumer, String topic) { ... }

/**
 * Poll the consumer for records.
 * @param consumer the consumer.
 * @return the records.
 */
public static &lt;K, V&gt; ConsumerRecords&lt;K, V&gt; getRecords(Consumer&lt;K, V&gt; consumer) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>KafkaTestUtils</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
template.sendDefault(0, 2, "bar");
ConsumerRecord&lt;Integer, String&gt; received = KafkaTestUtils.getSingleRecord(consumer, "topic");
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the embedded Kafka and embedded Zookeeper server are started by the <code>EmbeddedKafkaBroker</code>, a system property named <code>spring.embedded.kafka.brokers</code> is set to the address of the Kafka brokers and a system property named <code>spring.embedded.zookeeper.connect</code> is set to the address of Zookeeper.
Convenient constants (<code>EmbeddedKafkaBroker.SPRING_EMBEDDED_KAFKA_BROKERS</code> and <code>EmbeddedKafkaBroker.SPRING_EMBEDDED_ZOOKEEPER_CONNECT</code>) are provided for this property.</p>
</div>
<div class="paragraph">
<p>With the <code>EmbeddedKafkaBroker.brokerProperties(Map&lt;String, String&gt;)</code>, you can provide additional properties for the Kafka servers.
See <a href="https://kafka.apache.org/documentation/#brokerconfigs">Kafka Config</a> for more information about possible broker properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-topics-2"><a class="anchor" href="#configuring-topics-2"></a>4.3.2. Configuring Topics</h4>
<div class="paragraph">
<p>The following example configuration creates topics called <code>cat</code> and <code>hat</code> with five partitions, a topic called <code>thing1</code> with 10 partitions, and a topic called <code>thing2</code> with 15 partitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyTests {

    @ClassRule
    private static EmbeddedKafkaRule embeddedKafka = new EmbeddedKafkaRule(1, false, 5, "cat", "hat");

    @Test
    public void test() {
        embeddedKafkaRule.getEmbeddedKafka()
              .addTopics(new NewTopic("thing1", 10, (short) 1), new NewTopic("thing2", 15, (short) 1));
        ...
      }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-same-brokers-for-multiple-test-classes"><a class="anchor" href="#using-the-same-brokers-for-multiple-test-classes"></a>4.3.3. Using the Same Brokers for Multiple Test Classes</h4>
<div class="paragraph">
<p>There is no built-in support for doing so, but you can use the same broker for multiple test classes with something similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class EmbeddedKafkaHolder {

    private static EmbeddedKafkaRule embeddedKafka = new EmbeddedKafkaRule(1, false);

    private static boolean started;

    public static EmbeddedKafkaRule getEmbeddedKafka() {
        if (!started) {
            try {
                embeddedKafka.before();
            }
            catch (Exception e) {
                throw new KafkaException(e);
            }
            started = true;
        }
        return embeddedKafka;
    }

    private EmbeddedKafkaHolder() {
        super();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then, in each test class, you can use something similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
    EmbeddedKafkaHolder.getEmbeddedKafka().addTopics(topic1, topic2);
}

private static EmbeddedKafkaRule embeddedKafka = EmbeddedKafkaHolder.getEmbeddedKafka();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The preceding example provides no mechanism for shutting down the brokers when all tests are complete.
This could be a problem if, say, you run your tests in a Gradle daemon.
You should not use this technique in such a situation, or you should use something to call <code>destroy()</code> on the <code>EmbeddedKafkaBroker</code> when your tests are complete.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="embedded-kafka-annotation"><a class="anchor" href="#embedded-kafka-annotation"></a>4.3.4. @EmbeddedKafka Annotation</h4>
<div class="paragraph">
<p>We generally recommend that you use the rule as a <code>@ClassRule</code> to avoid starting and stopping the broker between tests (and use a different topic for each test).
Starting with version 2.0, if you use Spring&#8217;s test application context caching, you can also declare a <code>EmbeddedKafkaBroker</code> bean, so a single broker can be used across multiple test classes.
For convenience, we provide a test class-level annotation called <code>@EmbeddedKafka</code> to register the <code>EmbeddedKafkaBroker</code> bean.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@DirtiesContext
@EmbeddedKafka(partitions = 1,
         topics = {
                 KafkaStreamsTests.STREAMING_TOPIC1,
                 KafkaStreamsTests.STREAMING_TOPIC2 })
public class KafkaStreamsTests {

    @Autowired
    private EmbeddedKafkaBroker embeddedKafka;

    @Test
    public void someTest() {
        Map&lt;String, Object&gt; consumerProps = KafkaTestUtils.consumerProps("testGroup", "true", this.embeddedKafka);
        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        ConsumerFactory&lt;Integer, String&gt; cf = new DefaultKafkaConsumerFactory&lt;&gt;(consumerProps);
        Consumer&lt;Integer, String&gt; consumer = cf.createConsumer();
        this.embeddedKafka.consumeFromAnEmbeddedTopic(consumer, KafkaStreamsTests.STREAMING_TOPIC2);
        ConsumerRecords&lt;Integer, String&gt; replies = KafkaTestUtils.getRecords(consumer);
        assertThat(replies.count()).isGreaterThanOrEqualTo(1);
    }

    @Configuration
    @EnableKafkaStreams
    public static class KafkaStreamsConfiguration {

        @Value("${" + EmbeddedKafkaBroker.SPRING_EMBEDDED_KAFKA_BROKERS + "}")
        private String brokerAddresses;

        @Bean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)
        public KafkaStreamsConfiguration kStreamsConfigs() {
            Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
            props.put(StreamsConfig.APPLICATION_ID_CONFIG, "testStreams");
            props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, this.brokerAddresses);
            return new KafkaStreamsConfiguration(props);
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 2.2.4, you can also use the <code>@EmbeddedKafka</code> annotation to specify the Kafka ports property.</p>
</div>
<div class="paragraph">
<p>The following example sets the <code>topics</code>, <code>brokerProperties</code>, and <code>brokerPropertiesLocation</code> attributes of <code>@EmbeddedKafka</code> support property placeholder resolutions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestPropertySource(locations = "classpath:/test.properties")
@EmbeddedKafka(topics = { "any-topic", "${kafka.topics.another-topic}" },
        brokerProperties = { "log.dir=${kafka.broker.logs-dir}",
                            "listeners=PLAINTEXT://localhost:${kafka.broker.port}",
                            "auto.create.topics.enable=${kafka.broker.topics-enable:true}" }
        brokerPropertiesLocation = "classpath:/broker.properties")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the property placeholders <code>${kafka.topics.another-topic}</code>, <code>${kafka.broker.logs-dir}</code>, and <code>${kafka.broker.port}</code> are resolved from the Spring <code>Environment</code>.
In addition, the broker properties are loaded from the <code>broker.properties</code> classpath resource specified by the <code>brokerPropertiesLocation</code>.
Property placeholders are resolved for the <code>brokerPropertiesLocation</code> URL and for any property placeholders found in the resource.
Properties defined by <code>brokerProperties</code> override properties found in <code>brokerPropertiesLocation</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>@EmbeddedKafka</code> annotation with JUnit 4 or JUnit 5.</p>
</div>
</div>
<div class="sect3">
<h4 id="embedded-broker-in-springboottest-annotations"><a class="anchor" href="#embedded-broker-in-springboottest-annotations"></a>4.3.5. Embedded Broker in <code>@SpringBootTest</code> Annotations</h4>
<div class="paragraph">
<p><a href="https://start.spring.io/">Spring Initializr</a> now automatically adds the <code>spring-kafka-test</code> dependency in test scope to the project configuration.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If your application uses the Kafka binder in <code>spring-cloud-stream</code> and if you want to use an embedded broker for tests, you must remove the <code>spring-cloud-stream-test-support</code> dependency, because it replaces the real binder with a test binder for test cases.
If you wish some tests to use the test binder and some to use the embedded broker, tests that use the real binder need to disable the test binder by excluding the binder auto configuration in the test class.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.autoconfigure.exclude="
    + "org.springframework.cloud.stream.test.binder.TestSupportBinderAutoConfiguration")
public class MyApplicationTests {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are several ways to use an embedded broker in a Spring Boot application test.</p>
</div>
<div class="paragraph">
<p>They include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#kafka-testing-junit4-class-rule">JUnit4 Class Rule</a></p>
</li>
<li>
<p><a href="#kafka-testing-embeddedkafka-annotation"><code>@EmbeddedKafka</code> Annotation or <code>EmbeddedKafkaBroker</code> Bean</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="kafka-testing-junit4-class-rule"><a class="anchor" href="#kafka-testing-junit4-class-rule"></a>JUnit4 Class Rule</h5>
<div class="paragraph">
<p>The following example shows how to use a JUnit4 class rule to create an embedded broker:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class MyApplicationTests {

    @ClassRule
    public static EmbeddedKafkaRule broker = new EmbeddedKafkaRule(1,
        false, "someTopic");

    @BeforeClass
    public static void setup() {
        System.setProperty("spring.kafka.bootstrap-servers",
                    broker.getEmbeddedKafka().getBrokersAsString());
    }

    @Autowired
    private KafkaTemplate&lt;String, String&gt; template;

    @Test
    public void test() {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kafka-testing-embeddedkafka-annotation"><a class="anchor" href="#kafka-testing-embeddedkafka-annotation"></a><code>@EmbeddedKafka</code> Annotation or <code>EmbeddedKafkaBroker</code> Bean</h5>
<div class="paragraph">
<p>The following example shows how to use an <code>@EmbeddedKafka</code> Annotation to create an embedded broker:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@EmbeddedKafka(topics = "someTopic")
public class MyApplicationTests {

    static {
        System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY,
                "spring.kafka.bootstrap-servers");
    }

    @Autowired
    private KafkaTemplate&lt;String, String&gt; template;

    @Test
    public void test() {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hamcrest-matchers"><a class="anchor" href="#hamcrest-matchers"></a>4.3.6. Hamcrest Matchers</h4>
<div class="paragraph">
<p>The <code>o.s.kafka.test.hamcrest.KafkaMatchers</code> provides the following matchers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * @param key the key
 * @param &lt;K&gt; the type.
 * @return a Matcher that matches the key in a consumer record.
 */
public static &lt;K&gt; Matcher&lt;ConsumerRecord&lt;K, ?&gt;&gt; hasKey(K key) { ... }

/**
 * @param value the value.
 * @param &lt;V&gt; the type.
 * @return a Matcher that matches the value in a consumer record.
 */
public static &lt;V&gt; Matcher&lt;ConsumerRecord&lt;?, V&gt;&gt; hasValue(V value) { ... }

/**
 * @param partition the partition.
 * @return a Matcher that matches the partition in a consumer record.
 */
public static Matcher&lt;ConsumerRecord&lt;?, ?&gt;&gt; hasPartition(int partition) { ... }

/**
 * Matcher testing the timestamp of a {@link ConsumerRecord} asssuming the topic has been set with
 * {@link org.apache.kafka.common.record.TimestampType#CREATE_TIME CreateTime}.
 *
 * @param ts timestamp of the consumer record.
 * @return a Matcher that matches the timestamp in a consumer record.
 */
public static Matcher&lt;ConsumerRecord&lt;?, ?&gt;&gt; hasTimestamp(long ts) {
  return hasTimestamp(TimestampType.CREATE_TIME, ts);
}

/**
 * Matcher testing the timestamp of a {@link ConsumerRecord}
 * @param type timestamp type of the record
 * @param ts timestamp of the consumer record.
 * @return a Matcher that matches the timestamp in a consumer record.
 */
public static Matcher&lt;ConsumerRecord&lt;?, ?&gt;&gt; hasTimestamp(TimestampType type, long ts) {
  return new ConsumerRecordTimestampMatcher(type, ts);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="assertj-conditions"><a class="anchor" href="#assertj-conditions"></a>4.3.7. AssertJ Conditions</h4>
<div class="paragraph">
<p>You can use the following AssertJ conditions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * @param key the key
 * @param &lt;K&gt; the type.
 * @return a Condition that matches the key in a consumer record.
 */
public static &lt;K&gt; Condition&lt;ConsumerRecord&lt;K, ?&gt;&gt; key(K key) { ... }

/**
 * @param value the value.
 * @param &lt;V&gt; the type.
 * @return a Condition that matches the value in a consumer record.
 */
public static &lt;V&gt; Condition&lt;ConsumerRecord&lt;?, V&gt;&gt; value(V value) { ... }

/**
 * @param partition the partition.
 * @return a Condition that matches the partition in a consumer record.
 */
public static Condition&lt;ConsumerRecord&lt;?, ?&gt;&gt; partition(int partition) { ... }

/**
 * @param value the timestamp.
 * @return a Condition that matches the timestamp value in a consumer record.
 */
public static Condition&lt;ConsumerRecord&lt;?, ?&gt;&gt; timestamp(long value) {
  return new ConsumerRecordTimestampCondition(TimestampType.CREATE_TIME, value);
}

/**
 * @param type the type of timestamp
 * @param value the timestamp.
 * @return a Condition that matches the timestamp value in a consumer record.
 */
public static Condition&lt;ConsumerRecord&lt;?, ?&gt;&gt; timestamp(TimestampType type, long value) {
  return new ConsumerRecordTimestampCondition(type, value);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example"><a class="anchor" href="#example"></a>4.3.8. Example</h4>
<div class="paragraph">
<p>The following example brings together most of the topics covered in this chapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class KafkaTemplateTests {

    private static final String TEMPLATE_TOPIC = "templateTopic";

    @ClassRule
    public static EmbeddedKafkaRule embeddedKafka = new EmbeddedKafkaRule(1, true, TEMPLATE_TOPIC);

    @Test
    public void testTemplate() throws Exception {
        Map&lt;String, Object&gt; consumerProps = KafkaTestUtils.consumerProps("testT", "false",
            embeddedKafka);
        DefaultKafkaConsumerFactory&lt;Integer, String&gt; cf =
                            new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(consumerProps);
        ContainerProperties containerProperties = new ContainerProperties(TEMPLATE_TOPIC);
        KafkaMessageListenerContainer&lt;Integer, String&gt; container =
                            new KafkaMessageListenerContainer&lt;&gt;(cf, containerProperties);
        final BlockingQueue&lt;ConsumerRecord&lt;Integer, String&gt;&gt; records = new LinkedBlockingQueue&lt;&gt;();
        container.setupMessageListener(new MessageListener&lt;Integer, String&gt;() {

            @Override
            public void onMessage(ConsumerRecord&lt;Integer, String&gt; record) {
                System.out.println(record);
                records.add(record);
            }

        });
        container.setBeanName("templateTests");
        container.start();
        ContainerTestUtils.waitForAssignment(container, embeddedKafka.getEmbeddedKafka().getPartitionsPerTopic());
        Map&lt;String, Object&gt; senderProps =
                            KafkaTestUtils.senderProps(embeddedKafka.getEmbeddedKafka().getBrokersAsString());
        ProducerFactory&lt;Integer, String&gt; pf =
                            new DefaultKafkaProducerFactory&lt;Integer, String&gt;(senderProps);
        KafkaTemplate&lt;Integer, String&gt; template = new KafkaTemplate&lt;&gt;(pf);
        template.setDefaultTopic(TEMPLATE_TOPIC);
        template.sendDefault("foo");
        assertThat(records.poll(10, TimeUnit.SECONDS), hasValue("foo"));
        template.sendDefault(0, 2, "bar");
        ConsumerRecord&lt;Integer, String&gt; received = records.poll(10, TimeUnit.SECONDS);
        assertThat(received, hasKey(2));
        assertThat(received, hasPartition(0));
        assertThat(received, hasValue("bar"));
        template.send(TEMPLATE_TOPIC, 0, 2, "baz");
        received = records.poll(10, TimeUnit.SECONDS);
        assertThat(received, hasKey(2));
        assertThat(received, hasPartition(0));
        assertThat(received, hasValue("baz"));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example uses the Hamcrest matchers.
With <code>AssertJ</code>, the final part looks like the following code:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(records.poll(10, TimeUnit.SECONDS)).has(value("foo"));
template.sendDefault(0, 2, "bar");
ConsumerRecord&lt;Integer, String&gt; received = records.poll(10, TimeUnit.SECONDS);
assertThat(received).has(key(2));
assertThat(received).has(partition(0));
assertThat(received).has(value("bar"));
template.send(TEMPLATE_TOPIC, 0, 2, "baz");
received = records.poll(10, TimeUnit.SECONDS);
assertThat(received).has(key(2));
assertThat(received).has(partition(0));
assertThat(received).has(value("baz"));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-integration"><a class="anchor" href="#spring-integration"></a>5. Spring Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference guide shows how to use the <code>spring-integration-kafka</code> module of Spring Integration.</p>
</div>
<div class="sect2">
<h3 id="si-kafka"><a class="anchor" href="#si-kafka"></a>5.1. Spring Integration for Apache Kafka</h3>
<div class="paragraph">
<p>This documentation pertains to versions 2.0.0 and above.
For documentation for earlier releases, see the <a href="https://github.com/spring-projects/spring-integration-kafka/blob/1.3.x/README.md">1.3.x README</a>.</p>
</div>
<div class="paragraph">
<p>Spring Integration Kafka is now based on the <a href="https://projects.spring.io/spring-kafka/">Spring for Apache Kafka project</a>.
It provides the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#si-outbound">Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#si-inbound">Message-driven Channel Adapter</a></p>
</li>
<li>
<p><a href="#si-outbound-gateway">Outbound Gateway</a></p>
</li>
<li>
<p><a href="#si-inbound-gateway">Inbound Gateway</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="si-outbound"><a class="anchor" href="#si-outbound"></a>5.1.1. Outbound Channel Adapter</h4>
<div class="paragraph">
<p>The Outbound channel adapter is used to publish messages from a Spring Integration channel to Kafka topics.
The channel is defined in the application context and then wired into the application that sends messages to Kafka.
Sender applications can publish to Kafka by using Spring Integration messages, which are internally converted to Kafka messages by the outbound channel adapter, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The payload of the Spring Integration message is used to populate the payload of the Kafka message.</p>
</li>
<li>
<p>By default, the <code>kafka_messageKey</code> header of the Spring Integration message is used to populate the key of the Kafka message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can customize the target topic and partition for publishing the message through the <code>kafka_topic</code> and <code>kafka_partitionId</code> headers, respectively.</p>
</div>
<div class="paragraph">
<p>In addition, the <code>&lt;int-kafka:outbound-channel-adapter&gt;</code> provides the ability to extract the key, target topic, and target partition by applying SpEL expressions on the outbound message.
To that end, it supports three mutually exclusive pairs of attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>topic</code> and <code>topic-expression</code></p>
</li>
<li>
<p><code>message-key</code> and <code>message-key-expression</code></p>
</li>
<li>
<p><code>partition-id</code> and <code>partition-id-expression</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These let you specify <code>topic</code>, <code>message-key</code>, and <code>partition-id</code>, respectively, as static values on the adapter or to dynamically evaluate their values at runtime against the request message.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>KafkaHeaders</code> interface (provided by <code>spring-kafka</code>) contains constants used for interacting with headers.
The <code>messageKey</code> and <code>topic</code> default headers now require a <code>kafka_</code> prefix.
When migrating from an earlier version that used the old headers, you need to specify <code>message-key-expression="headers['messageKey']"</code> and <code>topic-expression="headers['topic']"</code> on the <code>&lt;int-kafka:outbound-channel-adapter&gt;</code>.
Alternatively, you can change the headers upstream to the new headers from <code>KafkaHeaders</code> by using a <code>&lt;header-enricher&gt;</code> or a <code>MessageBuilder</code>.
If you use constant values, you can also configure them on the adapter by using <code>topic</code> and <code>message-key</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>NOTE : If the adapter is configured with a topic or message key (either with a constant or expression), those are used and the corresponding header is ignored.
If you wish the header to override the configuration, you need to configure it in an expression, such as the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">topic-expression="headers['topic'] != null ? headers['topic'] : 'myTopic'"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter requires a <code>KafkaTemplate</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure the Kafka outbound channel adapter with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-kafka:outbound-channel-adapter id="kafkaOutboundChannelAdapter"
                                    kafka-template="template"
                                    auto-startup="false"
                                    channel="inputToKafka"
                                    topic="foo"
                                    sync="false"
                                    message-key-expression="'bar'"
                                    send-failure-channel="failures"
                                    send-success-channel="successes"
                                    error-message-strategy="ems"
                                    partition-id-expression="2"&gt;
&lt;/int-kafka:outbound-channel-adapter&gt;

&lt;bean id="template" class="org.springframework.kafka.core.KafkaTemplate"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.kafka.core.DefaultKafkaProducerFactory"&gt;
            &lt;constructor-arg&gt;
                &lt;map&gt;
                    &lt;entry key="bootstrap.servers" value="localhost:9092" /&gt;
                    ... &lt;!-- more producer properties --&gt;
                &lt;/map&gt;
            &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter requires a <code>KafkaTemplate</code>, which, in turn, requires a suitably configured <code>KafkaProducerFactory</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure the Kafka outbound channel adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "toKafka")
public MessageHandler handler() throws Exception {
    KafkaProducerMessageHandler&lt;String, String&gt; handler =
            new KafkaProducerMessageHandler&lt;&gt;(kafkaTemplate());
    handler.setTopicExpression(new LiteralExpression("someTopic"));
    handler.setMessageKeyExpression(new LiteralExpression("someKey"));
    handler.setSuccessChannel(successes());
    handler.setFailureChannel(failures());
    return handler;
}

@Bean
public KafkaTemplate&lt;String, String&gt; kafkaTemplate() {
    return new KafkaTemplate&lt;&gt;(producerFactory());
}

@Bean
public ProducerFactory&lt;String, String&gt; producerFactory() {
    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, this.brokerAddress);
    // set more properties
    return new DefaultKafkaProducerFactory&lt;&gt;(props);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure the Kafka outbound channel adapter Spring Integration Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ProducerFactory&lt;Integer, String&gt; producerFactory() {
    return new DefaultKafkaProducerFactory&lt;&gt;(KafkaTestUtils.producerProps(embeddedKafka));
}

@Bean
public IntegrationFlow sendToKafkaFlow() {
    return f -&gt; f
            .&lt;String&gt;split(p -&gt; Stream.generate(() -&gt; p).limit(101).iterator(), null)
            .publishSubscribeChannel(c -&gt; c
                    .subscribe(sf -&gt; sf.handle(
                            kafkaMessageHandler(producerFactory(), TEST_TOPIC1)
                                    .timestampExpression("T(Long).valueOf('1487694048633')"),
                            e -&gt; e.id("kafkaProducer1")))
                    .subscribe(sf -&gt; sf.handle(
                            kafkaMessageHandler(producerFactory(), TEST_TOPIC2)
                                   .timestamp(m -&gt; 1487694048644L),
                            e -&gt; e.id("kafkaProducer2")))
            );
}

@Bean
public DefaultKafkaHeaderMapper mapper() {
    return new DefaultKafkaHeaderMapper();
}

private KafkaProducerMessageHandlerSpec&lt;Integer, String, ?&gt; kafkaMessageHandler(
        ProducerFactory&lt;Integer, String&gt; producerFactory, String topic) {
    return Kafka
            .outboundChannelAdapter(producerFactory)
            .messageKey(m -&gt; m
                    .getHeaders()
                    .get(IntegrationMessageHeaderAccessor.SEQUENCE_NUMBER))
            .headerMapper(mapper())
            .partitionId(m -&gt; 10)
            .topicExpression("headers[kafka_topic] ?: '" + topic + "'")
            .configureKafkaTemplate(t -&gt; t.id("kafkaTemplate:" + topic));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If a <code>send-failure-channel</code> (<code>sendFailureChannel</code>) is provided and a send failure (sync or async) is received, an <code>ErrorMessage</code> is sent to the channel.
The payload is a <code>KafkaSendFailureException</code> with <code>failedMessage</code>, <code>record</code> (the <code>ProducerRecord</code>) and <code>cause</code> properties.
You can override the <code>DefaultErrorMessageStrategy</code> by setting the <code>error-message-strategy</code> property.</p>
</div>
<div class="paragraph">
<p>If a <code>send-success-channel</code> (<code>sendSuccessChannel</code>) is provided, a message with a payload of type <code>org.apache.kafka.clients.producer.RecordMetadata</code> is sent after a successful send.</p>
</div>
</div>
<div class="sect3">
<h4 id="si-inbound"><a class="anchor" href="#si-inbound"></a>5.1.2. Message-driven Channel Adapter</h4>
<div class="paragraph">
<p>The <code>KafkaMessageDrivenChannelAdapter</code> (<code>&lt;int-kafka:message-driven-channel-adapter&gt;</code>) uses a <code>spring-kafka</code> <code>KafkaMessageListenerContainer</code> or <code>ConcurrentListenerContainer</code>.</p>
</div>
<div class="paragraph">
<p>Starting with spring-integration-kafka version 2.1, the <code>mode</code> attribute is available.
It can accept values of <code>record</code> or <code>batch</code> (default: <code>record</code>).
For <code>record</code> mode, each message payload is converted from a single <code>ConsumerRecord</code>.
For <code>batch</code> mode, the payload is a list of objects that are converted from all the <code>ConsumerRecord</code> instances returned by the consumer poll.
As with the batched <code>@KafkaListener</code>, the <code>KafkaHeaders.RECEIVED_MESSAGE_KEY</code>, <code>KafkaHeaders.RECEIVED_PARTITION_ID</code>, <code>KafkaHeaders.RECEIVED_TOPIC</code>, and <code>KafkaHeaders.OFFSET</code> headers are also lists, with positions corresponding to the position in the payload.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a message-driven channel adapter with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-kafka:message-driven-channel-adapter
        id="kafkaListener"
        listener-container="container1"
        auto-startup="false"
        phase="100"
        send-timeout="5000"
        mode="record"
        retry-template="template"
        recovery-callback="callback"
        error-message-strategy="ems"
        channel="someChannel"
        error-channel="errorChannel" /&gt;

&lt;bean id="container1" class="org.springframework.kafka.listener.KafkaMessageListenerContainer"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.kafka.core.DefaultKafkaConsumerFactory"&gt;
            &lt;constructor-arg&gt;
                &lt;map&gt;
                &lt;entry key="bootstrap.servers" value="localhost:9092" /&gt;
                ...
                &lt;/map&gt;
            &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.kafka.listener.config.ContainerProperties"&gt;
            &lt;constructor-arg name="topics" value="foo" /&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a message-driven channel adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaMessageDrivenChannelAdapter&lt;String, String&gt;
            adapter(KafkaMessageListenerContainer&lt;String, String&gt; container) {
    KafkaMessageDrivenChannelAdapter&lt;String, String&gt; kafkaMessageDrivenChannelAdapter =
            new KafkaMessageDrivenChannelAdapter&lt;&gt;(container, ListenerMode.record);
    kafkaMessageDrivenChannelAdapter.setOutputChannel(received());
    return kafkaMessageDrivenChannelAdapter;
}

@Bean
public KafkaMessageListenerContainer&lt;String, String&gt; container() throws Exception {
    ContainerProperties properties = new ContainerProperties(this.topic);
    // set more properties
    return new KafkaMessageListenerContainer&lt;&gt;(consumerFactory(), properties);
}

@Bean
public ConsumerFactory&lt;String, String&gt; consumerFactory() {
    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, this.brokerAddress);
    // set more properties
    return new DefaultKafkaConsumerFactory&lt;&gt;(props);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a message-driven channel adapter with the Spring Integration Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow topic1ListenerFromKafkaFlow() {
    return IntegrationFlows
            .from(Kafka.messageDrivenChannelAdapter(consumerFactory(),
                    KafkaMessageDrivenChannelAdapter.ListenerMode.record, TEST_TOPIC1)
                    .configureListenerContainer(c -&gt;
                            c.ackMode(AbstractMessageListenerContainer.AckMode.MANUAL)
                                    .id("topic1ListenerContainer"))
                    .recoveryCallback(new ErrorMessageSendingRecoverer(errorChannel(),
                            new RawRecordHeaderErrorMessageStrategy()))
                    .retryTemplate(new RetryTemplate())
                    .filterInRetry(true))
            .filter(Message.class, m -&gt;
                            m.getHeaders().get(KafkaHeaders.RECEIVED_MESSAGE_KEY, Integer.class) &lt; 101,
                    f -&gt; f.throwExceptionOnRejection(true))
            .&lt;String, String&gt;transform(String::toUpperCase)
            .channel(c -&gt; c.queue("listeningFromKafkaResults1"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Received messages have certain headers populated.
See the <a href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/KafkaHeaders.html"><code>KafkaHeaders</code> class</a> for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>Consumer</code> object (in the <code>kafka_consumer</code> header) is not thread-safe.
You must invoke its methods only on the thread that calls the listener within the adapter.
If you hand off the message to another thread, you must not call its methods.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a <code>retry-template</code> is provided, delivery failures are retried according to its retry policy.
An <code>error-channel</code> is not allowed in this case.
You can use the <code>recovery-callback</code> to handle the error when retries are exhausted.
In most cases, this is an <code>ErrorMessageSendingRecoverer</code> that sends the <code>ErrorMessage</code> to a channel.</p>
</div>
<div class="paragraph">
<p>When building an <code>ErrorMessage</code> (for use in the <code>error-channel</code> or <code>recovery-callback</code>), you can customize the error message by setting the <code>error-message-strategy</code> property.
By default, a <code>RawRecordHeaderErrorMessageStrategy</code> is used, to provide access to the converted message as well as the raw <code>ConsumerRecord</code>.</p>
</div>
<div class="paragraph">
<p>Starting with Spring for Apache Kafka version 2.2 (Spring Integration Kafka 3.1), you can also use the container factory that is used for <code>@KafkaListener</code> annotations to create <code>ConcurrentMessageListenerContainer</code> instances for other purposes.
See <a href="#container-factory">Container factory</a> for an example.</p>
</div>
<div class="paragraph">
<p>With the Java DSL, the container does not have to be configured as a <code>@Bean</code>, because the DSL registers the container as a bean.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow topic2ListenerFromKafkaFlow() {
    return IntegrationFlows
            .from(Kafka.messageDrivenChannelAdapter(kafkaListenerContainerFactory().createContainer(TEST_TOPIC2),
            KafkaMessageDrivenChannelAdapter.ListenerMode.record)
                .id("topic2Adapter"))
            ...
            get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that, in this case, the adapter is given an <code>id</code> (<code>topic2Adapter</code>).
The container is registered in the application context with a name of <code>topic2Adapter.container</code>.
If the adapter does not have an <code>id</code> property, the container&#8217;s bean name is the container&#8217;s fully qualified class name plus <code>#n</code>, where <code>n</code> is incremented for each container.</p>
</div>
</div>
<div class="sect3">
<h4 id="si-outbound-gateway"><a class="anchor" href="#si-outbound-gateway"></a>5.1.3. Outbound Gateway</h4>
<div class="paragraph">
<p>The outbound gateway is for request/reply operations.
It differs from most Spring Integration gateways in that the sending thread does not block in the gateway and the reply is processed on the reply listener container thread.
If your code invokes the gateway behind a synchronous <a href="https://docs.spring.io/spring-integration/reference/html/messaging-endpoints-chapter.html#gateway">Messaging Gateway</a>, the user thread blocks there until the reply is received (or a timeout occurs).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The gateway does not accept requests until the reply container has been assigned its topics and partitions.
It is suggested that you add a <code>ConsumerRebalanceListener</code> to the template&#8217;s reply container properties and wait for the <code>onPartitionsAssigned</code> call before sending messages to the gateway.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to configure a gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "kafkaRequests", outputChannel = "kafkaReplies")
public KafkaProducerMessageHandler&lt;String, String&gt; outGateway(
        ReplyingKafkaTemplate&lt;String, String, String&gt; kafkaTemplate) {
    return new KafkaProducerMessageHandler&lt;&gt;(kafkaTemplate);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the same class as the <a href="#si-outbound">outbound channel adapter</a> is used, the only difference being that the Kafka template passed into the constructor is a <code>ReplyingKafkaTemplate</code>.
See <a href="#replying-template">Using <code>ReplyingKafkaTemplate</code></a> for more information.</p>
</div>
<div class="paragraph">
<p>The outbound topic, partition, key, and so on are determined in the same way as the outbound adapter.
The reply topic is determined as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A message header named <code>KafkaHeaders.REPLY_TOPIC</code> (if present, it must have a <code>String</code> or <code>byte[]</code> value) is validated against the template&#8217;s reply container&#8217;s subscribed topics.</p>
</li>
<li>
<p>If the template&#8217;s <code>replyContainer</code> is subscribed to only one topic, it is used.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can also specify a <code>KafkaHeaders.REPLY_PARTITION</code> header to determine a specific partition to be used for replies.
Again, this is validated against the template&#8217;s reply container&#8217;s subscriptions.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure an outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow outboundGateFlow(
        ReplyingKafkaTemplate&lt;String, String, String&gt; kafkaTemplate) {
    return IntegrationFlows.from("kafkaRequests")
            .handle(Kafka.outboundGateway(kafkaTemplate))
            .channel("kafkaReplies")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can also use a configuration similar to the following bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow outboundGateFlow() {
    return IntegrationFlows.from("kafkaRequests")
            .handle(Kafka.outboundGateway(producerFactory(), replyContainer())
                .configureKafkaTemplate(t -&gt; t.replyTimeout(30_000)))
            .channel("kafkaReplies")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
XML configuration is not currently available for this component.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="si-inbound-gateway"><a class="anchor" href="#si-inbound-gateway"></a>5.1.4. Inbound Gateway</h4>
<div class="paragraph">
<p>The inbound gateway is for request/reply operations.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure an inbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaInboundGateway&lt;Integer, String, String&gt; inboundGateway(
        AbstractMessageListenerContainer&lt;Integer, String&gt;container,
        KafkaTemplate&lt;Integer, String&gt; replyTemplate) {

    KafkaInboundGateway&lt;Integer, String, String&gt; gateway =
        new KafkaInboundGateway&lt;&gt;(container, replyTemplate);
    gateway.setRequestChannel(requests);
    gateway.setReplyChannel(replies);
    gateway.setReplyTimeout(30_000);
    return gateway;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a simple upper case converter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow serverGateway(
        ConcurrentMessageListenerContainer&lt;Integer, String&gt; container,
        KafkaTemplate&lt;Integer, String&gt; replyTemplate) {
    return IntegrationFlows
            .from(Kafka.inboundGateway(container, template)
                .replyTimeout(30_000))
            .&lt;String, String&gt;transform(String::toUpperCase)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you could configure an upper-case converter by using code similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow serverGateway() {
    return IntegrationFlows
            .from(Kafka.inboundGateway(consumerFactory(), containerProperties(),
                    producerFactory())
                .replyTimeout(30_000))
            .&lt;String, String&gt;transform(String::toUpperCase)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
XML configuration is not currently available for this component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with Spring for Apache Kafka version 2.2 (Spring Integration Kafka 3.1), you can also use the container factory that is used for <code>@KafkaListener</code> annotations to create <code>ConcurrentMessageListenerContainer</code> instances for other purposes.
See <a href="#container-factory">Container factory</a> and <a href="#si-inbound">Message-driven Channel Adapter</a> for examples.</p>
</div>
</div>
<div class="sect3">
<h4 id="message-conversion"><a class="anchor" href="#message-conversion"></a>5.1.5. Message Conversion</h4>
<div class="paragraph">
<p>A <code>StringJsonMessageConverter</code> is provided.
See <a href="#serdes">Serialization, Deserialization, and Message Conversion</a> for more information.</p>
</div>
<div class="paragraph">
<p>When using this converter with a message-driven channel adapter, you can specify the type to which you want the incoming payload to be converted.
This is achieved by setting the <code>payload-type</code> attribute (<code>payloadType</code> property) on the adapter.
The following example shows how to do so in XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-kafka:message-driven-channel-adapter
        id="kafkaListener"
        listener-container="container1"
        auto-startup="false"
        phase="100"
        send-timeout="5000"
        channel="nullChannel"
        message-converter="messageConverter"
        payload-type="com.example.Foo"
        error-channel="errorChannel" /&gt;

&lt;bean id="messageConverter"
    class="org.springframework.kafka.support.converter.MessagingMessageConverter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to set the <code>payload-type</code> attribute (<code>payloadType</code> property) on the adapter in Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public KafkaMessageDrivenChannelAdapter&lt;String, String&gt;
            adapter(KafkaMessageListenerContainer&lt;String, String&gt; container) {
    KafkaMessageDrivenChannelAdapter&lt;String, String&gt; kafkaMessageDrivenChannelAdapter =
            new KafkaMessageDrivenChannelAdapter&lt;&gt;(container, ListenerMode.record);
    kafkaMessageDrivenChannelAdapter.setOutputChannel(received());
    kafkaMessageDrivenChannelAdapter.setMessageConverter(converter());
    kafkaMessageDrivenChannelAdapter.setPayloadType(Foo.class);
    return kafkaMessageDrivenChannelAdapter;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="si-tombstones"><a class="anchor" href="#si-tombstones"></a>5.1.6. Null Payloads and Log Compaction 'Tombstone' Records</h4>
<div class="paragraph">
<p>Spring Messaging <code>Message&lt;?&gt;</code> objects cannot have <code>null</code> payloads.
When you use the Kafka endpoints, <code>null</code> payloads (also known as tombstone records) are represented by a payload of type <code>KafkaNull</code>.
See <a href="#tombstones">Null Payloads and Log Compaction of 'Tombstone' Records</a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 3.1 of Spring Integration Kafka, such records can now be received by Spring Integration POJO methods with a true <code>null</code> value instead.
To do so, mark the parameter with <code>@Payload(required = false)</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "fromSomeKafkaInboundEndpoint")
public void in(@Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String key,
               @Payload(required = false) Customer customer) {
    // customer is null if a tombstone record
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="whats-new-in-spring-integration-for-apache-kafka"><a class="anchor" href="#whats-new-in-spring-integration-for-apache-kafka"></a>5.1.7. What&#8217;s New in Spring Integration for Apache Kafka</h4>
<div class="paragraph">
<p>See the <a href="https://projects.spring.io/spring-kafka/">Spring for Apache Kafka Project Page</a> for a matrix of compatible <code>spring-kafka</code> and <code>kafka-clients</code> versions.</p>
</div>
<div class="sect4">
<h5 id="2-1-x"><a class="anchor" href="#2-1-x"></a>2.1.x</h5>
<div class="paragraph">
<p>The 2.1.x branch introduced the following changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Update to <code>spring-kafka</code> 1.1.x, including support of batch payloads</p>
</li>
<li>
<p>Support <code>sync</code> outbound requests in XML configuration</p>
</li>
<li>
<p>Support <code>payload-type</code> for inbound channel adapters</p>
</li>
<li>
<p>Support for enhanced error handling for the inbound channel adapter (2.1.1)</p>
</li>
<li>
<p>Support for send success and failure messages (2.1.2)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="2-2-x"><a class="anchor" href="#2-2-x"></a>2.2.x</h5>
<div class="paragraph">
<p>The 2.2.x branch introduced the following changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Update to <code>spring-kafka</code> 1.2.x</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="2-3-x"><a class="anchor" href="#2-3-x"></a>2.3.x</h5>
<div class="paragraph">
<p>The 2.3.x branch introduced the following changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Update to <code>spring-kafka</code> 1.3.x, including support for transactions and header mapping provided by <code>kafka-clients</code> 0.11.0.0</p>
</li>
<li>
<p>Support for record timestamps</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="3-0-x"><a class="anchor" href="#3-0-x"></a>3.0.x</h5>
<div class="ulist">
<ul>
<li>
<p>Update to <code>spring-kafka</code> 2.1.x and <code>kafka-clients</code> 1.0.0</p>
</li>
<li>
<p>Support <code>ConsumerAwareMessageListener</code> (<code>Consumer</code> is available in a message header)</p>
</li>
<li>
<p>Update to Spring Integration 5.0 and Java 8</p>
</li>
<li>
<p>Moved Java DSL to the main project</p>
</li>
<li>
<p>Added inbound and outbound gateways (3.0.2)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="3-1-x"><a class="anchor" href="#3-1-x"></a>3.1.x</h5>
<div class="ulist">
<ul>
<li>
<p>Update to <code>spring-kafka</code> 2.2.x and <code>kafka-clients</code> 2.0.0</p>
</li>
<li>
<p>Support tombstones in EIP POJO Methods</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a>6. Other Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to this reference documentation, we recommend a number of other resources that may help you learn about Spring and Apache Kafka.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://kafka.apache.org/">Apache Kafka Project Home Page</a></p>
</li>
<li>
<p><a href="https://projects.spring.io/spring-kafka/">Spring for Apache Kafka Home Page</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-kafka">Spring for Apache Kafka GitHub Repository</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-integration-kafka">Spring Integration Kafka Extension GitHub Repository</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deps-for-21x"><a class="anchor" href="#deps-for-21x"></a>Appendix A: Override Dependencies to use the 2.1.x kafka-clients with an Embedded Broker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you use <code>spring-kafka-test</code> (version 2.2.x) with the 2.1.x <code>kafka-clients</code> jar, you need to override certain transitive dependencies, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
    &lt;version&gt;${spring.kafka.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;
    &lt;version&gt;${spring.kafka.version}&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
            &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;classifier&gt;test&lt;/classifier&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka_2.12&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka_2.12&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;classifier&gt;test&lt;/classifier&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that when switching to scala 2.12 (recommended for 2.1.x and higher), the 2.11 version must be excluded from spring-kafka-test.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="history"><a class="anchor" href="#history"></a>Appendix B: Change History</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="migration"><a class="anchor" href="#migration"></a>B.1. Changes between 2.0 and 2.1</h3>
<div class="sect3">
<h4 id="kafka-client-version-2"><a class="anchor" href="#kafka-client-version-2"></a>B.1.1. Kafka Client Version</h4>
<div class="paragraph">
<p>This version requires the 1.0.0 <code>kafka-clients</code> or higher.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 1.1.x client is supported with version 2.1.5, but you need to override dependencies as described in <a href="#deps-for-11x">[deps-for-11x]</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The 1.1.x client is supported natively in version 2.2.</p>
</div>
</div>
<div class="sect3">
<h4 id="json-improvements"><a class="anchor" href="#json-improvements"></a>B.1.2. JSON Improvements</h4>
<div class="paragraph">
<p>The <code>StringJsonMessageConverter</code> and <code>JsonSerializer</code> now add type information in <code>Headers</code>, letting the converter and <code>JsonDeserializer</code> create specific types on reception, based on the message itself rather than a fixed configured type.
See <a href="#serdes">Serialization, Deserialization, and Message Conversion</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="container-stopping-error-handlers-2"><a class="anchor" href="#container-stopping-error-handlers-2"></a>B.1.3. Container Stopping Error Handlers</h4>
<div class="paragraph">
<p>Container error handlers are now provided for both record and batch listeners that treat any exceptions thrown by the listener as fatal.
They stop the container.
See <a href="#annotation-error-handling">Handling Exceptions</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="pausing-and-resuming-containers"><a class="anchor" href="#pausing-and-resuming-containers"></a>B.1.4. Pausing and Resuming Containers</h4>
<div class="paragraph">
<p>The listener containers now have <code>pause()</code> and <code>resume()</code> methods (since version 2.1.3).
See <a href="#pause-resume">Pausing and Resuming Listener Containers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="stateful-retry-2"><a class="anchor" href="#stateful-retry-2"></a>B.1.5. Stateful Retry</h4>
<div class="paragraph">
<p>Starting with version 2.1.3, you can configure stateful retry.
See <a href="#stateful-retry">Stateful Retry</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="client-id"><a class="anchor" href="#client-id"></a>B.1.6. Client ID</h4>
<div class="paragraph">
<p>Starting with version 2.1.1, you can now set the <code>client.id</code> prefix on <code>@KafkaListener</code>.
Previously, to customize the client ID, you needed a separate consumer factory (and container factory) per listener.
The prefix is suffixed with <code>-n</code> to provide unique client IDs when you use concurrency.</p>
</div>
</div>
<div class="sect3">
<h4 id="logging-offset-commits"><a class="anchor" href="#logging-offset-commits"></a>B.1.7. Logging Offset Commits</h4>
<div class="paragraph">
<p>By default, logging of topic offset commits is performed with the <code>DEBUG</code> logging level.
Starting with version 2.1.2, a new property in <code>ContainerProperties</code> called <code>commitLogLevel</code> lets you specify the log level for these messages.
See <a href="#kafka-container">Using <code>KafkaMessageListenerContainer</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="default-kafkahandler"><a class="anchor" href="#default-kafkahandler"></a>B.1.8. Default @KafkaHandler</h4>
<div class="paragraph">
<p>Starting with version 2.1.3, you can designate one of the <code>@KafkaHandler</code> annotations on a class-level <code>@KafkaListener</code> as the default.
See <a href="#class-level-kafkalistener"><code>@KafkaListener</code> on a Class</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="replyingkafkatemplate"><a class="anchor" href="#replyingkafkatemplate"></a>B.1.9. ReplyingKafkaTemplate</h4>
<div class="paragraph">
<p>Starting with version 2.1.3, a subclass of <code>KafkaTemplate</code> is provided to support request/reply semantics.
See <a href="#replying-template">Using <code>ReplyingKafkaTemplate</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="chainedkafkatransactionmanager"><a class="anchor" href="#chainedkafkatransactionmanager"></a>B.1.10. ChainedKafkaTransactionManager</h4>
<div class="paragraph">
<p>Version 2.1.3 introduced the <code>ChainedKafkaTransactionManager</code>.
See <a href="#chained-transaction-manager">Using <code>ChainedKafkaTransactionManager</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="migration-guide-from-2-0"><a class="anchor" href="#migration-guide-from-2-0"></a>B.1.11. Migration Guide from 2.0</h4>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-kafka/wiki/Spring-for-Apache-Kafka-2.0-to-2.1-Migration-Guide">2.0 to 2.1 Migration</a> guide.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changes-between-1-3-and-2-0"><a class="anchor" href="#changes-between-1-3-and-2-0"></a>B.2. Changes Between 1.3 and 2.0</h3>
<div class="sect3">
<h4 id="spring-framework-and-java-versions"><a class="anchor" href="#spring-framework-and-java-versions"></a>B.2.1. Spring Framework and Java Versions</h4>
<div class="paragraph">
<p>The Spring for Apache Kafka project now requires Spring Framework 5.0 and Java 8.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafkalistener-changes-2"><a class="anchor" href="#kafkalistener-changes-2"></a>B.2.2. <code>@KafkaListener</code> Changes</h4>
<div class="paragraph">
<p>You can now annotate <code>@KafkaListener</code> methods (and classes and <code>@KafkaHandler</code> methods) with <code>@SendTo</code>.
If the method returns a result, it is forwarded to the specified topic.
See <a href="#annotation-send-to">Forwarding Listener Results using <code>@SendTo</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="message-listeners-2"><a class="anchor" href="#message-listeners-2"></a>B.2.3. Message Listeners</h4>
<div class="paragraph">
<p>Message listeners can now be aware of the <code>Consumer</code> object.
See <a href="#message-listeners">Message Listeners</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-consumerawarerebalancelistener"><a class="anchor" href="#using-consumerawarerebalancelistener"></a>B.2.4. Using <code>ConsumerAwareRebalanceListener</code></h4>
<div class="paragraph">
<p>Rebalance listeners can now access the <code>Consumer</code> object during rebalance notifications.
See <a href="#rebalance-listeners">Rebalancing Listeners</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changes-between-1-2-and-1-3"><a class="anchor" href="#changes-between-1-2-and-1-3"></a>B.3. Changes Between 1.2 and 1.3</h3>
<div class="sect3">
<h4 id="support-for-transactions"><a class="anchor" href="#support-for-transactions"></a>B.3.1. Support for Transactions</h4>
<div class="paragraph">
<p>The 0.11.0.0 client library added support for transactions.
The <code>KafkaTransactionManager</code> and other support for transactions have been added.
See <a href="#transactions">Transactions</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="support-for-headers"><a class="anchor" href="#support-for-headers"></a>B.3.2. Support for Headers</h4>
<div class="paragraph">
<p>The 0.11.0.0 client library added support for message headers.
These can now be mapped to and from <code>spring-messaging</code> <code>MessageHeaders</code>.
See <a href="#headers">Message Headers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-topics"><a class="anchor" href="#creating-topics"></a>B.3.3. Creating Topics</h4>
<div class="paragraph">
<p>The 0.11.0.0 client library provides an <code>AdminClient</code>, which you can use to create topics.
The <code>KafkaAdmin</code> uses this client to automatically add topics defined as <code>@Bean</code> instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="support-for-kafka-timestamps"><a class="anchor" href="#support-for-kafka-timestamps"></a>B.3.4. Support for Kafka Timestamps</h4>
<div class="paragraph">
<p><code>KafkaTemplate</code> now supports an API to add records with timestamps.
New <code>KafkaHeaders</code> have been introduced regarding <code>timestamp</code> support.
Also, new <code>KafkaConditions.timestamp()</code> and <code>KafkaMatchers.hasTimestamp()</code> testing utilities have been added.
See <a href="#kafka-template">Using <code>KafkaTemplate</code></a>, <a href="#kafka-listener-annotation"><code>@KafkaListener</code> Annotation</a>, and <a href="#testing">Testing Applications</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafkalistener-changes-3"><a class="anchor" href="#kafkalistener-changes-3"></a>B.3.5. <code>@KafkaListener</code> Changes</h4>
<div class="paragraph">
<p>You can now configure a <code>KafkaListenerErrorHandler</code> to handle exceptions.
See <a href="#annotation-error-handling">Handling Exceptions</a> for more information.</p>
</div>
<div class="paragraph">
<p>By default, the <code>@KafkaListener</code> <code>id</code> property is now used as the <code>group.id</code> property, overriding the property configured in the consumer factory (if present).
Further, you can explicitly configure the <code>groupId</code> on the annotation.
Previously, you would have needed a separate container factory (and consumer factory) to use different <code>group.id</code> values for listeners.
To restore the previous behavior of using the factory configured <code>group.id</code>, set the <code>idIsGroup</code> property on the annotation to <code>false</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddedkafka-annotation"><a class="anchor" href="#embeddedkafka-annotation"></a>B.3.6. <code>@EmbeddedKafka</code> Annotation</h4>
<div class="paragraph">
<p>For convenience, a test class-level <code>@EmbeddedKafka</code> annotation is provided, to register <code>KafkaEmbedded</code> as a bean.
See <a href="#testing">Testing Applications</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="kerberos-configuration"><a class="anchor" href="#kerberos-configuration"></a>B.3.7. Kerberos Configuration</h4>
<div class="paragraph">
<p>Support for configuring Kerberos is now provided.
See <a href="#kerberos">Kerberos</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changes-between-1-1-and-1-2"><a class="anchor" href="#changes-between-1-1-and-1-2"></a>B.4. Changes between 1.1 and 1.2</h3>
<div class="paragraph">
<p>This version uses the 0.10.2.x client.</p>
</div>
</div>
<div class="sect2">
<h3 id="changes-between-1-0-and-1-1"><a class="anchor" href="#changes-between-1-0-and-1-1"></a>B.5. Changes between 1.0 and 1.1</h3>
<div class="sect3">
<h4 id="kafka-client"><a class="anchor" href="#kafka-client"></a>B.5.1. Kafka Client</h4>
<div class="paragraph">
<p>This version uses the Apache Kafka 0.10.x.x client.</p>
</div>
</div>
<div class="sect3">
<h4 id="batch-listeners-2"><a class="anchor" href="#batch-listeners-2"></a>B.5.2. Batch Listeners</h4>
<div class="paragraph">
<p>Listeners can be configured to receive the entire batch of messages returned by the <code>consumer.poll()</code> operation, rather than one at a time.</p>
</div>
</div>
<div class="sect3">
<h4 id="null-payloads"><a class="anchor" href="#null-payloads"></a>B.5.3. Null Payloads</h4>
<div class="paragraph">
<p>Null payloads are used to &#8220;delete&#8221; keys when you use log compaction.</p>
</div>
</div>
<div class="sect3">
<h4 id="initial-offset"><a class="anchor" href="#initial-offset"></a>B.5.4. Initial Offset</h4>
<div class="paragraph">
<p>When explicitly assigning partitions, you can now configure the initial offset relative to the current position for the consumer group, rather than absolute or relative to the current end.</p>
</div>
</div>
<div class="sect3">
<h4 id="seek-2"><a class="anchor" href="#seek-2"></a>B.5.5. Seek</h4>
<div class="paragraph">
<p>You can now seek the position of each topic or partition.
You can use this to set the initial position during initialization when group management is in use and Kafka assigns the partitions.
You can also seek when an idle container is detected or at any arbitrary point in your application&#8217;s execution.
See <a href="#seek">Seeking to a Specific Offset</a> for more information.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.2.6.RELEASE<br>
Last updated 2019-05-10 18:08:56 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>