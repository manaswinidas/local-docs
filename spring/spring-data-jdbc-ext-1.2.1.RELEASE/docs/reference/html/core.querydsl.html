<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Querydsl Support (Deprecated)</title><link rel="stylesheet" href="css/manual-multipage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Spring Data JDBC Extensions Reference Documentation"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Core JDBC Extensions"><link rel="prev" href="core.support.html" title="1.&nbsp;Support classes that extend Spring features"><link rel="next" href="pt02.html" title="Part&nbsp;II.&nbsp;JDBC Extensions for the Oracle Database"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Querydsl Support (Deprecated)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="core.support.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Core JDBC Extensions</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="pt02.html">Next</a></td></tr></table><hr></div><div class="chapter" title="2.&nbsp;Querydsl Support (Deprecated)"><div class="titlepage"><div><div><h2 class="title"><a name="core.querydsl"></a>2.&nbsp;Querydsl Support (Deprecated)</h2></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Due to changes in Querydsl, the Spring JDBC Extensions support for 
        Querydsl is no longer compatible with more recent versions. 
        We are deprecating this support and recommend that users switch to use the 
        Querydsl project's Spring support and use the Querydsl APIs directly. See 
        <a class="ulink" href="https://github.com/querydsl/querydsl/tree/master/querydsl-sql-spring" target="_top">https://github.com/querydsl/querydsl/tree/master/querydsl-sql-spring</a>
    </p></td></tr></table></div><p>The Querydsl project provides a framework that let's you write
  type-safe queries in Java rather than constructing them using strings. This
  has several advantages like code completion in your IDE, domain types and
  properties can be accessed in a type-safe manner reducing the probability of
  query syntax errors during run-time. Querydsl has modules that support JPA,
  JDO, SQL, MongoDB and more. It is the SQL support that is used for the JDBC
  Extensions project. You can read more about Querydsl at their website <a class="ulink" href="http://www.querydsl.com" target="_top">http://www.querydsl.com</a>.</p><div class="section" title="2.1&nbsp;Introduction to Querydsl"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.intro"></a>2.1&nbsp;Introduction to Querydsl</h2></div></div></div><p>Before you can use the Spring support for Querydsl you need to
    configure your application to use the Querydsl SQL support. See the
    instruction in the Mysema <a class="ulink" href="http://blog.mysema.com/2011/01/querying-in-sql-with-querydsl.html" target="_top">blog
    post</a> on how this is done. Once you have generated your Querydsl
    query types then you can start using the Spring support as outlined
    bellow.</p></div><div class="section" title="2.2&nbsp;QueryDslJdbcTemplate"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.template"></a>2.2&nbsp;QueryDslJdbcTemplate</h2></div></div></div><p>The central class in the Querydsl support is the
    <code class="classname">QueryDslJdbcTemplate</code>. Just like the
    <code class="classname">NamedParameterJdbcTemplate</code> it wraps a regular
    <code class="classname">JdbcTemplate</code> that you can get access to by calling
    the <code class="classname">getJdbcOperations</code> method. One thing to note is
    that when you use the <code class="classname">QueryDslJdbcTemplate</code>, there
    is no need to specify the SQL dialect to be used since the template will
    auto-detect this when it is created.</p><p>You can create a QueryDslJdbcTemplate by passing in a JdbcTemplate
    or a DataSource in the constructor. Here is some example code showing
    this:</p><pre class="programlisting"><span class="hl-keyword">private</span> QueryDslJdbcTemplate template;

<i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.template = <span class="hl-keyword">new</span> QueryDslJdbcTemplate(dataSource);
}</pre><p>At this point the template is ready to be used and we give examples
    for various uses below.</p></div><div class="section" title="2.3&nbsp;Queries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.queries"></a>2.3&nbsp;Queries</h2></div></div></div><p>For queries you need to have a reference to the query type. For the
    examples in this document we define the query type as follows:</p><pre class="programlisting"><span class="hl-keyword">private</span> <span class="hl-keyword">final</span> QProduct qProduct = QProduct.product;</pre><p>Now we are ready to create the first query. Instead of directly
    creating an instance of <code class="classname">SQLQueryImpl</code> we ask the
    template for a managed instance.</p><pre class="programlisting">SQLQuery sqlQuery = template.newSqlQuery()</pre><p>The managed part here refers to the managing of the connection and
    the SQL dialect. The <code class="classname">QueryDslJdbcTemplate</code> will
    provide both of these. The dialect is set when the
    <code class="classname">SQLQuery</code> is created and the connection is provided
    when the <code class="classname">SQLQuery</code> is executed using the clone
    feature of the <code class="classname">SQLQuery</code> implementation
    class.</p><p>We continue to build this query providing from and where
    clauses:</p><pre class="programlisting">SQLQuery sqlQuery = template.newSqlQuery().from(qProduct)
        .where(qProduct.category.eq(categoryId));</pre><p>Here <em class="parameter"><code>categoryId</code></em> is a parameter that is passed
    in to the method.</p><p>The final step is to execute the query. Depending on how you want to
    map the results, there are two flavors of the query methods. You
    can</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>use the method taking a regular Spring
        <code class="classname">RowMapper</code> together with a projection in the
        form of a Querydsl <code class="classname">Expression</code>.</p></li></ul></div><p>or</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>use the method that takes a Querydsl class implementing
        <code class="classname">Expression</code> like an extension of the handy
        <code class="classname">MappingProjection</code>, a
        <code class="classname">QBean</code> implementation or a Querydsl query type
        combined with a Querydsl bean type to specify the mapping.</p></li></ul></div><p>Here is an example using the query created above together with a
    <code class="classname">MappingProjection</code> for mapping the query
    results:</p><pre class="programlisting"><span class="hl-keyword">public</span> List&lt;Product&gt; getProductListByCategory(<span class="hl-keyword">final</span> String categoryId)
        <span class="hl-keyword">throws</span> DataAccessException {

    SQLQuery sqlQuery = template.newSqlQuery().from(qProduct)
            .where(qProduct.category.eq(categoryId));

    <span class="hl-keyword">return</span> template.query(sqlQuery, <span class="hl-keyword">new</span> MappingProductProjection(qProduct);
}

<span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> MappingProductProjection <span class="hl-keyword">extends</span> MappingProjection&lt;Product&gt; {

    <span class="hl-keyword">public</span> MappingProductProjection(QProduct qProduct) {
        <span class="hl-keyword">super</span>(Product.<span class="hl-keyword">class</span>, qProduct.productid,
            qProduct.name, qProduct.descn, qProduct.category));
    }

    <i><span class="hl-annotation" style="color: gray">@Override</span></i>
    <span class="hl-keyword">protected</span> Product map(Tuple tuple) {
        Product product = <span class="hl-keyword">new</span> Product();

        product.setProductId(tuple.get(qProduct.productid));
        product.setName(tuple.get(qProduct.name));
        product.setDescription(tuple.get(qProduct.descn));
        product.setCategoryId(tuple.get(qProduct.category));

        <span class="hl-keyword">return</span> product;
    }
}</pre></div><div class="section" title="2.4&nbsp;Inserts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.inserts"></a>2.4&nbsp;Inserts</h2></div></div></div><p>For inserts we need to call the template's
    <code class="methodname">insert</code> method and implement an
    <code class="classname">SqlInsertCallback</code> to handle the mapping of data
    from the domain object values to the insert. Here is an example:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> insertProduct(<span class="hl-keyword">final</span> Product product) <span class="hl-keyword">throws</span> DataAccessException {
    template.insert(qProduct, <span class="hl-keyword">new</span> SqlInsertCallback() {
        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlInsertClause(SQLInsertClause sqlInsertClause) {
            <span class="hl-keyword">return</span> sqlInsertClause.columns(qProduct.productid, qProduct.name, 
                        qProduct.descn, qProduct.category)
                    .values(product.getProductId(), product.getName(), 
                        product.getDescription(), product.getCategoryId())
                    .execute();
        }
    });
}</pre><p></p></div><div class="section" title="2.5&nbsp;Updates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.updates"></a>2.5&nbsp;Updates</h2></div></div></div><p>Updates are similar to the inerts but we of course call the
    <code class="methodname">update</code> method and implement an
    <code class="classname">SqlUpdateCallback</code> to provide the where clause and
    handle the mapping of update parameter values.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateProduct(<span class="hl-keyword">final</span> Product product) <span class="hl-keyword">throws</span> DataAccessException {
    template.update(qProduct, <span class="hl-keyword">new</span> SqlUpdateCallback() {

        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlUpdateClause(SQLUpdateClause sqlUpdateClause) {
            <span class="hl-keyword">return</span> sqlUpdateClause.where(qProduct.productid.eq(product.getProductId()))
                    .set(qProduct.name, product.getName())
                    .set(qProduct.descn, product.getDescription())
                    .set(qProduct.category, product.getCategoryId())
                    .execute();
        }
    });
}</pre><p></p></div><div class="section" title="2.6&nbsp;Deletes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.deletes"></a>2.6&nbsp;Deletes</h2></div></div></div><p>Deletes are also very similar except we don't need to do any value
    mapping. We simply call the <code class="methodname">delete</code> method and
    implement an <code class="classname">SqlDeleteCallback</code> with a where
    clause.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> deleteProduct(<span class="hl-keyword">final</span> Product product) {
    template.delete(qProduct, <span class="hl-keyword">new</span> SqlDeleteCallback() {

        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlDeleteClause(SQLDeleteClause sqlDeleteClause) {
            <span class="hl-keyword">return</span> sqlDeleteClause.where(qProduct.productid.eq(product.getProductId()))
                    .execute();
        }
    });
}
</pre><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="core.support.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="pt02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Support classes that extend Spring features&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;II.&nbsp;JDBC Extensions for the Oracle Database</td></tr></table></div></body></html>