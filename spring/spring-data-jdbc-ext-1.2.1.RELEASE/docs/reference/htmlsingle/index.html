<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Data JDBC Extensions Reference Documentation</title><link rel="stylesheet" href="css/manual-singlepage.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Spring Data JDBC Extensions Reference Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Spring Data JDBC Extensions Reference Documentation</h1></div><div><div class="authorgroup"><h2>Authors</h2><span class="author"><span class="firstname">Thomas</span> <span class="surname">Risberg</span></span></div></div><div><p class="releaseinfo">1.2.1.RELEASE</p></div><div><p class="copyright">Copyright &copy; 2008-2015 The original authors</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d0e22"></a><p>
                Copies of this document may be made for your own use and for distribution
                to others, provided that you do not charge any fee for such copies and
                further provided that each copy contains this Copyright Notice, whether
                distributed in print or electronically.
            </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#d0e35">I. Core JDBC Extensions</a></span></dt><dd><dl><dt><span class="preface"><a href="#core.overview">Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#core.overview-whats-covered">1. Features provided</a></span></dt><dt><span class="section"><a href="#core.requires">2. Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core.support">1. Support classes that extend Spring features</a></span></dt><dd><dl><dt><span class="section"><a href="#core.support.onetomany">1.1. Mapping a one-to-many relationship</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core.querydsl">2. Querydsl Support (Deprecated)</a></span></dt><dd><dl><dt><span class="section"><a href="#core.querydsl.intro">2.1. Introduction to Querydsl</a></span></dt><dt><span class="section"><a href="#core.querydsl.template">2.2. QueryDslJdbcTemplate</a></span></dt><dt><span class="section"><a href="#core.querydsl.queries">2.3. Queries</a></span></dt><dt><span class="section"><a href="#core.querydsl.inserts">2.4. Inserts</a></span></dt><dt><span class="section"><a href="#core.querydsl.updates">2.5. Updates</a></span></dt><dt><span class="section"><a href="#core.querydsl.deletes">2.6. Deletes</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#d0e360">II. JDBC Extensions for the Oracle Database</a></span></dt><dd><dl><dt><span class="preface"><a href="#orcl.overview">Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.overview-whats-covered">1. Features provided</a></span></dt><dt><span class="section"><a href="#orcl.requires">2. Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orcl.datasource">3. Oracle Pooling DataSource</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.datasource.1">3.1. Configuration using the traditional &lt;bean&gt; element</a></span></dt><dt><span class="section"><a href="#orcl.datasource.2">3.2. Using the "orcl" namespace to configure the
    OracleDataSource</a></span></dt><dt><span class="section"><a href="#orcl.datasource.3">3.3. Using a properties file directly for connection properties</a></span></dt><dt><span class="section"><a href="#orcl.datasource.4">3.4. Additional connection and cache properties</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.datasource.4.1">3.4.1. Using the property file for additional connection
      properties</a></span></dt><dt><span class="section"><a href="#orcl.datasource.4.2">3.4.2. Using the property file for additional cache properties</a></span></dt><dt><span class="section"><a href="#orcl.datasource.4.3">3.4.3. Using "connection-properties" element for additional connection
      properties</a></span></dt><dt><span class="section"><a href="#orcl.datasource.4.4">3.4.4. Using "connection-cache-properties" element for additional cache
      properties</a></span></dt><dt><span class="section"><a href="#orcl.datasource.4.5">3.4.5. Using "username-connection-proxy" element for proxy
      connections</a></span></dt></dl></dd><dt><span class="section"><a href="#orcl.datasource.options">3.5. Summary of configuration options for the
    "pooling-data-source"</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orcl.failover">4. Fast Connection Failover</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.failover.config.datasource">4.1. DataSource Configuration</a></span></dt><dt><span class="section"><a href="#orcl.failover.config.aop">4.2. AOP Configuration for Fast Connection Failover Retry</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.failover.config.aop.advice">4.2.1. Configuration when defining transactions using a
      &lt;tx:advice&gt; and an &lt;aop:advisor&gt;</a></span></dt><dt><span class="section"><a href="#orcl.failover.config.aop.annotation">4.2.2. Configuration when defining transactions using @Transactional
      annotation</a></span></dt></dl></dd><dt><span class="section"><a href="#orcl.failover.config.interceptor">4.3. Configuration options for &lt;rac-failover-interceptor&gt;</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orcl.streamsaq">5. Oracle's Streams AQ (Advanced Queueing)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1208">5.1. Supported payload types</a></span></dt><dt><span class="section"><a href="#orcl.streamsaq.orcl_config">5.2. Configuration of the Connection Factory using the "orcl"
    namespace</a></span></dt><dt><span class="section"><a href="#orcl.streamsaq.tx_config">5.3. Configuring the Connection Factory to use the same local
    transaction as your data access code.</a></span></dt><dt><span class="section"><a href="#orcl.streamsaq.xmltype_config">5.4. Configuration when using a SYS.XMLType payload</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1446">5.4.1. Enqueuing XML messages</a></span></dt><dt><span class="section"><a href="#d0e1530">5.4.2. Dequeuing XML messages</a></span></dt></dl></dd><dt><span class="section"><a href="#orcl.streamsaq.adt_config">5.5. Configuration when using a custom ADT payload</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1592">5.5.1. Enqueuing ADT messages</a></span></dt><dt><span class="section"><a href="#d0e1662">5.5.2. Dequeuing ADT messages</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orcl.xmltypes">6. XML Types</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.xmltypes.1">6.1. Dependencies</a></span></dt><dt><span class="section"><a href="#orcl.xmltypes.2">6.2. Writing XML to an XMLTYPE column</a></span></dt><dt><span class="section"><a href="#orcl.xmltypes.3">6.3. Reading XML from an XMLTYPE column</a></span></dt><dt><span class="section"><a href="#orcl.xmltypes.4">6.4. Marshalling an object to an XMLTYPE column</a></span></dt><dt><span class="section"><a href="#orcl.xmltypes.5">6.5. Unmarshalling an object from an XMLTYPE column</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orcl.datatypes">7. Advanced Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.datatypes.struct">7.1. Using a STRUCT parameter</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2044">7.1.1. Using an SQLData implementation for a STRUCT IN parameter</a></span></dt><dt><span class="section"><a href="#d0e2166">7.1.2. Using SqlReturnSqlData with an SQLData implementation from a
      STRUCT OUT parameter</a></span></dt><dt><span class="section"><a href="#d0e2237">7.1.3. Setting STRUCT attribute values using SqlStructValue for an IN
      parameter</a></span></dt><dt><span class="section"><a href="#d0e2304">7.1.4. Using SqlReturnStruct to access STRUCT data from an OUT
      parameter</a></span></dt></dl></dd><dt><span class="section"><a href="#orcl.datatypes.array">7.2. Using an ARRAY parameter</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2395">7.2.1. Setting ARRAY values using SqlArrayValue for an IN
      parameter</a></span></dt><dt><span class="section"><a href="#d0e2456">7.2.2. Using SqlReturnArray to handle the ARRAY from an OUT
      parameter</a></span></dt></dl></dd><dt><span class="section"><a href="#orcl.datatypes.ref_cur">7.3. Handling a REF CURSOR</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2514">7.3.1. Retrieving data using a ParameterizedBeanPropertyRowMapper from a
      REF CURSOR</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orcl.connection">8. Custom DataSource Connection Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#orcl.connection.1">8.1. Configuration of a Proxy Authentication</a></span></dt><dt><span class="section"><a href="#orcl.connection.2">8.2. Configuration of a Custom DataSource Connection Preparer</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>The Spring Data JDBC Extensions project provides advanced JDBC
  features that extends the support provided by the "spring-jdbc" module in
  the Spring Framework project.</p><p>The bulk of the features in the Spring Data JDBC Extensions project is
  made up of code ported from the SpringSource project "Advanced Pack for
  Oracle Database" that was available for support subscription customers. We
  are now making this code available to all Spring users and any new
  developments will be made in the Spring Data JDBC Extensions project.</p><p>There is also support for using the Querydsl SQL module to provide
  type-safe query, insert, update and delete functionality.</p></div><div class="part" title="Part&nbsp;I.&nbsp;Core JDBC Extensions"><div class="titlepage"><div><div><h1 class="title"><a name="d0e35"></a>Part&nbsp;I.&nbsp;Core JDBC Extensions</h1></div></div></div><div class="partintro" title="Core JDBC Extensions"><div></div><p>
                This part of the reference documentation details the core extended JDBC support that can be used for any supported SQL database.
            </p></div><div class="preface" title="Overview"><div class="titlepage"><div><div><h2 class="title"><a name="core.overview"></a>Overview</h2></div></div></div><p>The JDBC support in the Spring Framework is extensive and covers the
  most commonly used features, but there are some new usage scenarios like
  type-safe queries that warrants some extension to be provided. The core part
  of the <span class="emphasis"><em>Spring Data JDBC Extensions</em></span> project provides
  this type of extension and it can be used together with any supported SQL
  database.</p><div class="section" title="1&nbsp;Features provided"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.overview-whats-covered"></a>1&nbsp;Features provided</h2></div></div></div><p>The following lists the various features that are covered. Each
    feature is documented in more detail in the following chapters</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
         Core support 

        <p class="remark"><i><span class="remark">The core support provides extensions to the Spring Framework
        JDBC support.</span></i></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
         Querydsl 

        <p class="remark"><i><span class="remark">The Querydsl project provides a way to work with many
        datastore in a type-safe manner. This includes support for working
        with SQL databases. We provide the "glue" that let's you easily work
        with Querydsl in a Spring based project.</span></i></p><p class="remark"><i><span class="remark">(As of Spring Data JDBC Extensions version 1.2.0 the Querydsl SQL support is deprecated)</span></i></p></li></ul></div></div><div class="section" title="2&nbsp;Requirements"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.requires"></a>2&nbsp;Requirements</h2></div></div></div><p>The requirements for using the features provided in the
    <code class="classname">core</code> module of the "Spring Data JDBC Extensions"
    project are listed below.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
         Java 6 or later 
        <p class="remark"><i><span class="remark">The minimum Java version is now 1.6.</span></i></p></li><li class="listitem">
         Spring Framework 3.0 
        <p class="remark"><i><span class="remark">All Spring Framework features that are needed are provided in
        Spring Framework version 3.0 or later.</span></i></p></li><li class="listitem">
         Apache Commons Logging 
        <p class="remark"><i><span class="remark">Apache Commons Logging is used by the Spring Framework but it
        can be replaced by the jcl-over-slf4j bridge provided by the SLF4J
        project.</span></i></p></li><li class="listitem">
         Querydsl 
        <p class="remark"><i><span class="remark">The Querydsl support requires the use of Querydsl SQL module
        version 3.0.0 or later.</span></i></p></li></ul></div></div></div><div class="chapter" title="1.&nbsp;Support classes that extend Spring features"><div class="titlepage"><div><div><h2 class="title"><a name="core.support"></a>1.&nbsp;Support classes that extend Spring features</h2></div></div></div><p>The Spring Framework projects JDBC support is excellent but every now
  and then there are some features that seem useful, but might not warrant
  inclusion in the framework project itself. The Spring Data JDBC Extensions
  project provides a home for these type of extensions.</p><div class="section" title="1.1&nbsp;Mapping a one-to-many relationship"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.support.onetomany"></a>1.1&nbsp;Mapping a one-to-many relationship</h2></div></div></div><p>We often have to map one-to-many relationships in our database
    projects. A customer can have many addresses, an order can contain many
    line items and so on. We are now providing a
    <code class="classname">ResultSetExtractor</code> implementation to deal with this
    common task.</p><p>Let&#8217;s look at the schema definition first:</p><pre class="programlisting">CREATE TABLE customer(
  id BIGINT IDENTITY PRIMARY KEY, 
  name VARCHAR(255));
CREATE TABLE address (
  id BIGINT IDENTITY PRIMARY KEY, 
  customer_id BIGINT CONSTRAINT address_customer_ref 
    FOREIGN KEY REFERENCES customer (id), 
  street VARCHAR(255), 
  city VARCHAR(255));
</pre><p>Two tables linked by a foreign key constraint. To map this we need
    two domain classes - <code class="classname">Customer</code> and
    <code class="classname">Address</code> where <code class="classname">Customer</code> has a
    Set of <code class="classname">Addresse</code>s.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Customer {

  <span class="hl-keyword">private</span> Integer id;

  <span class="hl-keyword">private</span> String name;

  <span class="hl-keyword">private</span> Set&lt;Address&gt; addresses = <span class="hl-keyword">new</span> HashSet&lt;Address&gt;();

  <span class="hl-keyword">public</span> Set&lt;Address&gt; getAddresses() {
    <span class="hl-keyword">return</span> addresses;
  }

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addAddress(Address address) {
    <span class="hl-keyword">this</span>.addresses.add(address);
  }

<span class="hl-comment">// other setters and getters</span>

}</pre><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Address {

  <span class="hl-keyword">private</span> Integer id;

  <span class="hl-keyword">private</span> String street;

  <span class="hl-keyword">private</span> String city;

<span class="hl-comment">// setters and getters</span>

}</pre><p>Executing the following query we would potentially get multiple rows
    returned for each customer. </p><pre class="programlisting">List&lt;Customer&gt; result = template.query(
  <span class="hl-string">"select customer.id, customer.name, address.id, "</span> +
    <span class="hl-string">"address.customer_id, address.street, address.city "</span> +
    <span class="hl-string">"from customer "</span> +
    <span class="hl-string">"left join address on customer.id = address.customer_id "</span> +
    <span class="hl-string">"order by customer.id"</span>,
  resultSetExtractor);
</pre><p>To be able to handle the multiple rows we create a new
    <code class="classname">CustomerAddressExtractor</code> that extends the abstract
    class <code class="classname">OneToManyResultSetExtractor</code>. We parameterize
    the <code class="classname">OneToManyResultSetExtractor</code> with the root class
    (<code class="classname">Customer</code>), the child class
    (<code class="classname">Address</code>), and the class for the primary and
    foreign key (<code class="classname">Integer</code>).</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomerAddressExtractor <span class="hl-keyword">extends</span>
    OneToManyResultSetExtractor&lt;Customer, Address, Integer&gt; {

  <span class="hl-keyword">public</span> CustomerAddressExtractor() {
    <span class="hl-keyword">super</span>(<span class="hl-keyword">new</span> CustomerMapper(), <span class="hl-keyword">new</span> AddressMapper());
  }

  <i><span class="hl-annotation" style="color: gray">@Override</span></i>
  <span class="hl-keyword">protected</span> Integer mapPrimaryKey(ResultSet rs) <span class="hl-keyword">throws</span> SQLException {
    <span class="hl-keyword">return</span> rs.getInt(<span class="hl-string">"customer.id"</span>);
  }

  <i><span class="hl-annotation" style="color: gray">@Override</span></i>
  <span class="hl-keyword">protected</span> Integer mapForeignKey(ResultSet rs) <span class="hl-keyword">throws</span> SQLException {
    <span class="hl-keyword">if</span> (rs.getObject(<span class="hl-string">"address.customer_id"</span>) == null) {
      <span class="hl-keyword">return</span> null;
    }
    <span class="hl-keyword">else</span> {
      <span class="hl-keyword">return</span> rs.getInt(<span class="hl-string">"address.customer_id"</span>);
    }
  }

  <i><span class="hl-annotation" style="color: gray">@Override</span></i>
  <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> addChild(Customer root, Address child) {
    root.addAddress(child);
  }
}
</pre><p>We need a way to match the primary key of the Customer with the
    foreign key of the Address so we provide mappings for these via the
    abstract methods <code class="methodname">mapPrimaryKey</code> and
    <code class="methodname">mapForeignKey</code>. We have to take into account that
    there might not be an address record for every customer so the foreign key
    could be <code class="literal">null</code>. We also need to add the mapped
    <code class="classname">Address</code> instances to the
    <code class="classname">Customer</code> instance. We do this by implementing the
    abstract method <code class="classname">addChild</code>. We simply call the
    <code class="methodname">addAddress</code> on the <code class="classname">Customer</code>
    class here.</p><p>Looking at the constructor of the CustomerAddressExtractor we see
    that we call the super constructor providing
    <code class="classname">RowMapper</code> implementations for the
    <code class="classname">Customer</code> and the <code class="classname">Address</code>
    classes. These are standard <code class="classname">RowMapper</code>s that we in
    this example provide as static inner classes.</p><pre class="programlisting"><span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> CustomerMapper <span class="hl-keyword">implements</span> RowMapper&lt;Customer&gt; {

  <span class="hl-keyword">public</span> Customer mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
    Customer c = <span class="hl-keyword">new</span> Customer();
    c.setId(rs.getInt(<span class="hl-string">"customer.id"</span>));
    c.setName(rs.getString(<span class="hl-string">"customer.name"</span>));
    <span class="hl-keyword">return</span> c;
  }
}
</pre><pre class="programlisting"><span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> AddressMapper <span class="hl-keyword">implements</span> RowMapper&lt;Address&gt; {

  <span class="hl-keyword">public</span> Address mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
    Address a = <span class="hl-keyword">new</span> Address();
    a.setId(rs.getInt(<span class="hl-string">"address.id"</span>));
    a.setStreet(rs.getString(<span class="hl-string">"address.street"</span>));
    a.setCity(rs.getString(<span class="hl-string">"address.city"</span>));
    <span class="hl-keyword">return</span> a;
  }
}
</pre><p>We now have a complete solution for this common problem.</p></div></div><div class="chapter" title="2.&nbsp;Querydsl Support (Deprecated)"><div class="titlepage"><div><div><h2 class="title"><a name="core.querydsl"></a>2.&nbsp;Querydsl Support (Deprecated)</h2></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Due to changes in Querydsl, the Spring JDBC Extensions support for 
        Querydsl is no longer compatible with more recent versions. 
        We are deprecating this support and recommend that users switch to use the 
        Querydsl project's Spring support and use the Querydsl APIs directly. See 
        <a class="ulink" href="https://github.com/querydsl/querydsl/tree/master/querydsl-sql-spring" target="_top">https://github.com/querydsl/querydsl/tree/master/querydsl-sql-spring</a>
    </p></td></tr></table></div><p>The Querydsl project provides a framework that let's you write
  type-safe queries in Java rather than constructing them using strings. This
  has several advantages like code completion in your IDE, domain types and
  properties can be accessed in a type-safe manner reducing the probability of
  query syntax errors during run-time. Querydsl has modules that support JPA,
  JDO, SQL, MongoDB and more. It is the SQL support that is used for the JDBC
  Extensions project. You can read more about Querydsl at their website <a class="ulink" href="http://www.querydsl.com" target="_top">http://www.querydsl.com</a>.</p><div class="section" title="2.1&nbsp;Introduction to Querydsl"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.intro"></a>2.1&nbsp;Introduction to Querydsl</h2></div></div></div><p>Before you can use the Spring support for Querydsl you need to
    configure your application to use the Querydsl SQL support. See the
    instruction in the Mysema <a class="ulink" href="http://blog.mysema.com/2011/01/querying-in-sql-with-querydsl.html" target="_top">blog
    post</a> on how this is done. Once you have generated your Querydsl
    query types then you can start using the Spring support as outlined
    bellow.</p></div><div class="section" title="2.2&nbsp;QueryDslJdbcTemplate"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.template"></a>2.2&nbsp;QueryDslJdbcTemplate</h2></div></div></div><p>The central class in the Querydsl support is the
    <code class="classname">QueryDslJdbcTemplate</code>. Just like the
    <code class="classname">NamedParameterJdbcTemplate</code> it wraps a regular
    <code class="classname">JdbcTemplate</code> that you can get access to by calling
    the <code class="classname">getJdbcOperations</code> method. One thing to note is
    that when you use the <code class="classname">QueryDslJdbcTemplate</code>, there
    is no need to specify the SQL dialect to be used since the template will
    auto-detect this when it is created.</p><p>You can create a QueryDslJdbcTemplate by passing in a JdbcTemplate
    or a DataSource in the constructor. Here is some example code showing
    this:</p><pre class="programlisting"><span class="hl-keyword">private</span> QueryDslJdbcTemplate template;

<i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.template = <span class="hl-keyword">new</span> QueryDslJdbcTemplate(dataSource);
}</pre><p>At this point the template is ready to be used and we give examples
    for various uses below.</p></div><div class="section" title="2.3&nbsp;Queries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.queries"></a>2.3&nbsp;Queries</h2></div></div></div><p>For queries you need to have a reference to the query type. For the
    examples in this document we define the query type as follows:</p><pre class="programlisting"><span class="hl-keyword">private</span> <span class="hl-keyword">final</span> QProduct qProduct = QProduct.product;</pre><p>Now we are ready to create the first query. Instead of directly
    creating an instance of <code class="classname">SQLQueryImpl</code> we ask the
    template for a managed instance.</p><pre class="programlisting">SQLQuery sqlQuery = template.newSqlQuery()</pre><p>The managed part here refers to the managing of the connection and
    the SQL dialect. The <code class="classname">QueryDslJdbcTemplate</code> will
    provide both of these. The dialect is set when the
    <code class="classname">SQLQuery</code> is created and the connection is provided
    when the <code class="classname">SQLQuery</code> is executed using the clone
    feature of the <code class="classname">SQLQuery</code> implementation
    class.</p><p>We continue to build this query providing from and where
    clauses:</p><pre class="programlisting">SQLQuery sqlQuery = template.newSqlQuery().from(qProduct)
        .where(qProduct.category.eq(categoryId));</pre><p>Here <em class="parameter"><code>categoryId</code></em> is a parameter that is passed
    in to the method.</p><p>The final step is to execute the query. Depending on how you want to
    map the results, there are two flavors of the query methods. You
    can</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>use the method taking a regular Spring
        <code class="classname">RowMapper</code> together with a projection in the
        form of a Querydsl <code class="classname">Expression</code>.</p></li></ul></div><p>or</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>use the method that takes a Querydsl class implementing
        <code class="classname">Expression</code> like an extension of the handy
        <code class="classname">MappingProjection</code>, a
        <code class="classname">QBean</code> implementation or a Querydsl query type
        combined with a Querydsl bean type to specify the mapping.</p></li></ul></div><p>Here is an example using the query created above together with a
    <code class="classname">MappingProjection</code> for mapping the query
    results:</p><pre class="programlisting"><span class="hl-keyword">public</span> List&lt;Product&gt; getProductListByCategory(<span class="hl-keyword">final</span> String categoryId)
        <span class="hl-keyword">throws</span> DataAccessException {

    SQLQuery sqlQuery = template.newSqlQuery().from(qProduct)
            .where(qProduct.category.eq(categoryId));

    <span class="hl-keyword">return</span> template.query(sqlQuery, <span class="hl-keyword">new</span> MappingProductProjection(qProduct);
}

<span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> MappingProductProjection <span class="hl-keyword">extends</span> MappingProjection&lt;Product&gt; {

    <span class="hl-keyword">public</span> MappingProductProjection(QProduct qProduct) {
        <span class="hl-keyword">super</span>(Product.<span class="hl-keyword">class</span>, qProduct.productid,
            qProduct.name, qProduct.descn, qProduct.category));
    }

    <i><span class="hl-annotation" style="color: gray">@Override</span></i>
    <span class="hl-keyword">protected</span> Product map(Tuple tuple) {
        Product product = <span class="hl-keyword">new</span> Product();

        product.setProductId(tuple.get(qProduct.productid));
        product.setName(tuple.get(qProduct.name));
        product.setDescription(tuple.get(qProduct.descn));
        product.setCategoryId(tuple.get(qProduct.category));

        <span class="hl-keyword">return</span> product;
    }
}</pre></div><div class="section" title="2.4&nbsp;Inserts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.inserts"></a>2.4&nbsp;Inserts</h2></div></div></div><p>For inserts we need to call the template's
    <code class="methodname">insert</code> method and implement an
    <code class="classname">SqlInsertCallback</code> to handle the mapping of data
    from the domain object values to the insert. Here is an example:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> insertProduct(<span class="hl-keyword">final</span> Product product) <span class="hl-keyword">throws</span> DataAccessException {
    template.insert(qProduct, <span class="hl-keyword">new</span> SqlInsertCallback() {
        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlInsertClause(SQLInsertClause sqlInsertClause) {
            <span class="hl-keyword">return</span> sqlInsertClause.columns(qProduct.productid, qProduct.name, 
                        qProduct.descn, qProduct.category)
                    .values(product.getProductId(), product.getName(), 
                        product.getDescription(), product.getCategoryId())
                    .execute();
        }
    });
}</pre><p></p></div><div class="section" title="2.5&nbsp;Updates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.updates"></a>2.5&nbsp;Updates</h2></div></div></div><p>Updates are similar to the inerts but we of course call the
    <code class="methodname">update</code> method and implement an
    <code class="classname">SqlUpdateCallback</code> to provide the where clause and
    handle the mapping of update parameter values.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateProduct(<span class="hl-keyword">final</span> Product product) <span class="hl-keyword">throws</span> DataAccessException {
    template.update(qProduct, <span class="hl-keyword">new</span> SqlUpdateCallback() {

        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlUpdateClause(SQLUpdateClause sqlUpdateClause) {
            <span class="hl-keyword">return</span> sqlUpdateClause.where(qProduct.productid.eq(product.getProductId()))
                    .set(qProduct.name, product.getName())
                    .set(qProduct.descn, product.getDescription())
                    .set(qProduct.category, product.getCategoryId())
                    .execute();
        }
    });
}</pre><p></p></div><div class="section" title="2.6&nbsp;Deletes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core.querydsl.deletes"></a>2.6&nbsp;Deletes</h2></div></div></div><p>Deletes are also very similar except we don't need to do any value
    mapping. We simply call the <code class="methodname">delete</code> method and
    implement an <code class="classname">SqlDeleteCallback</code> with a where
    clause.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> deleteProduct(<span class="hl-keyword">final</span> Product product) {
    template.delete(qProduct, <span class="hl-keyword">new</span> SqlDeleteCallback() {

        <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> doInSqlDeleteClause(SQLDeleteClause sqlDeleteClause) {
            <span class="hl-keyword">return</span> sqlDeleteClause.where(qProduct.productid.eq(product.getProductId()))
                    .execute();
        }
    });
}
</pre><p></p></div></div></div><div class="part" title="Part&nbsp;II.&nbsp;JDBC Extensions for the Oracle Database"><div class="titlepage"><div><div><h1 class="title"><a name="d0e360"></a>Part&nbsp;II.&nbsp;JDBC Extensions for the Oracle Database</h1></div></div></div><div class="partintro" title="JDBC Extensions for the Oracle Database"><div></div><p>
                This part of the reference documentation details the extended JDBC support provided for the Oracle database.
            </p></div><div class="preface" title="Overview"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.overview"></a>Overview</h2></div></div></div><p>The Oracle Database is a powerful relational database that continues
  to lead the market in several areas. It has advanced support for replication
  and clustering, powerful support for stored procedures and support for
  advanced data types and XML data types. Many of these features aren't
  directly supported by the JDBC standard and Oracle has developed several
  extensions to their JDBC implementation to make access to these features
  possible.</p><p>The <span class="emphasis"><em>Spring Data JDBC Extensions</em></span> project's support
  for the Oracle Database provides a simplified approach to gain access to
  these advanced features and at the same time provide this support in a
  fashion that is in line with the JDBC support provided by the Spring
  Framework and its JDBC abstraction.</p><div class="section" title="1&nbsp;Features provided"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.overview-whats-covered"></a>1&nbsp;Features provided</h2></div></div></div><p>The majority of features provided by the Oracle Database and their
    JDBC implementation are already well supported by the core Spring
    Framework. There are however some advanced features not covered by the
    JDBC specification that provide some interesting functionality. The Spring
    Data JDBC Extension project provides explicit support for some of these
    features and it also provides documentation and examples how to take
    advantage of some of Oracle's JDBC extensions using standard Spring
    Framework APIs.</p><p>The following lists the various features that are covered. Each
    feature is documented in more detail in the following chapters</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
        RAC "Fast Connection Failover"

        <p class="remark"><i><span class="remark">The RAC "Fast Connection Failover" provides the ability to
        have a Spring application transparently failover when a database node
        fails.</span></i></p></li><li class="listitem">
        Streams AQ (Advanced Queueing)

        <p class="remark"><i><span class="remark">The AQ support provides the option of using a single local
        transaction manager for both database and message access without
        resorting to expensive distributed 2-phase commit transaction
        management.</span></i></p></li><li class="listitem">
        XML Types

        <p class="remark"><i><span class="remark">Custom classes, examples and documentation on how to use
        Oracle JDBC extensions for their native XML Type.</span></i></p></li><li class="listitem">
        Advanced Data Types

        <p class="remark"><i><span class="remark">Custom classes, examples and documentation on how to use
        Oracle JDBC extensions for their advanced data types like STRUCT and
        ARRAY.</span></i></p></li><li class="listitem">
        Custom DataSource Connection Preparer

        <p class="remark"><i><span class="remark">This feature provides an API for customizing the connection
        environment with Oracle specific session settings etc.</span></i></p></li></ul></div></div><div class="section" title="2&nbsp;Requirements"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.requires"></a>2&nbsp;Requirements</h2></div></div></div><p>The requirements for using the features provided in the
    <code class="classname">oracle</code> module of the "Spring Data JDBC Extensions"
    project are listed below.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
         Java 6 or later 
        <p class="remark"><i><span class="remark">The minimum Java version is now 1.6.</span></i></p></li><li class="listitem">
         Spring Framework 3.0 
        <p class="remark"><i><span class="remark">All Spring Framework features that are needed are provided in
        Spring Framework version 3.0 or later.</span></i></p></li><li class="listitem">
        JDBC driver for Oracle 10g R2
        <p class="remark"><i><span class="remark">All features are supported using the Oracle JDBC driver
        10.2.0.2 or later. Using a recent 11gR2 or later driver is recommended.</span></i></p></li><li class="listitem">
         Apache Commons Logging 
        <p class="remark"><i><span class="remark">Apache Commons Logging is used by the Spring Framework but it
        can be replaced by the jcl-over-slf4j bridge provided by the SLF4J
        project.</span></i></p></li><li class="listitem">
        Spring Retry
        <p class="remark"><i><span class="remark">The Fast Connection Failover support requires using the Spring
        Retry project (https://github.com/spring-projects/spring-retry).</span></i></p></li></ul></div></div></div><div class="chapter" title="3.&nbsp;Oracle Pooling DataSource"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.datasource"></a>3.&nbsp;Oracle Pooling DataSource</h2></div></div></div><p>Oracle provides an advanced DataSource implementation that has some
  unique features. It provides connection pooling and it is required when
  using "Fast Connection Failover" for RAC.</p><div class="section" title="3.1&nbsp;Configuration using the traditional <bean&gt; element"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datasource.1"></a>3.1&nbsp;Configuration using the traditional &lt;bean&gt; element</h2></div></div></div><p>We'll start by looking at a very basic DataSource configuration
    using the traditional &lt;bean&gt; element.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
	   <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"oracle.jdbc.pool.OracleDataSource"</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span> <a name="datasource.class"></a><img src="images/callouts/1.png" alt="1" border="0">
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"URL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.url}"</span><span class="hl-tag"> /&gt;</span> <a name="datasource.url"></a><img src="images/callouts/2.png" alt="2" border="0">
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.username}"</span><span class="hl-tag">/&gt;</span> <a name="datasource.username"></a><img src="images/callouts/3.png" alt="3" border="0">
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.password}"</span><span class="hl-tag">/&gt;</span> <a name="datasource.password"></a><img src="images/callouts/4.png" alt="4" border="0">
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionCachingEnabled"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span> <a name="datasource.cache"></a><img src="images/callouts/5.png" alt="5" border="0">
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;context:property-placeholder</span> <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:jdbc.properties"</span><span class="hl-tag">/&gt;</span> <a name="datasource.propertyPlaceholder"></a><img src="images/callouts/6.png" alt="6" border="0">

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.class"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the <code class="classname">DataSource</code>
          implementation class as the
          <code class="classname">OracleDataSource</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.url"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We specify the URL using the <code class="classname">URL</code>
          property. Note that it is upper case in this implementation while it
          is lower case in most other <code class="classname">DataSource</code>
          implementations.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.username"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The user name is specified using the
          <code class="classname">user</code> property.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.password"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The password is specified using the
          <code class="classname">password</code> property.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.cache"><img src="images/callouts/5.png" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>The connection caching must be enabled explicitly using the
          <code class="classname">connectionCachingEnabled</code> property.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.propertyPlaceholder"><img src="images/callouts/6.png" alt="6" border="0"></a> </p></td><td valign="top" align="left"><p>The property place holders will be filled in using this
          <code class="classname">&lt;context:property-placeholder&gt;</code> element
          from the context namespace.</p></td></tr></table></div></div><div class="section" title="3.2&nbsp;Using the &#34;orcl&#34; namespace to configure the OracleDataSource"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datasource.2"></a>3.2&nbsp;Using the "orcl" namespace to configure the
    OracleDataSource</h2></div></div></div><p>The new "orcl" namespace contains a
    <code class="classname">pooling-data-source</code> element used for easy
    configuration of the <code class="classname">OracleDataSource</code>. We will show
    several ways this element can be used and we will start with a basic one
    that can replace the traditional &lt;bean&gt; element configuration used
    above.</p><p>When using the <code class="classname">pooling-data-source</code> element
    connection caching is enabled by default and must explicitly be turned off
    using the <code class="classname">connection-caching-enabled</code> attribute if
    you don't want to use this pooling support.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="bold"><strong>xmlns:orcl="http://www.springframework.org/schema/data/orcl"</strong></span> <a name="datasource2.ns"></a><img src="images/callouts/1.png" alt="1" border="0">
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       <span class="bold"><strong>http://www.springframework.org/schema/data/orcl <a name="datasource2.xsd"></a><img src="images/callouts/2.png" alt="2" border="0">
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"&gt;</strong></span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource"
        url="${jdbc.url}" username="${jdbc.username}" password="${jdbc.password}"/&gt;</strong></span> <a name="datasource2.properties"></a><img src="images/callouts/3.png" alt="3" border="0">

    <span class="hl-tag">&lt;context:property-placeholder</span> <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:jdbc.properties"</span><span class="hl-tag">/&gt;</span> <a name="datasource2.propertyPlaceholder"></a><img src="images/callouts/4.png" alt="4" border="0">

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource2.ns"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the reference to the
          <code class="classname">orcl</code> schema.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource2.xsd"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We also specify the location for the
          <code class="classname">orcl</code> schema.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource2.properties"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The properties needed to connect to the database in this
          example are <code class="classname">url</code>,
          <code class="classname">username</code> and <code class="classname">password</code>.
          The <code class="classname">url</code> property could also be specifiec as
          <code class="classname">URL</code> and the <code class="classname">username</code>
          property could be specifed as <code class="classname">user</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datasource2.propertyPlaceholder"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>Just as in the previous example, the property place holders
          will be filled in using this
          <code class="classname">&lt;context:property-placeholder&gt;</code> element
          from the context namespace.</p></td></tr></table></div></div><div class="section" title="3.3&nbsp;Using a properties file directly for connection properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datasource.3"></a>3.3&nbsp;Using a properties file directly for connection properties</h2></div></div></div><p>We used a <code class="classname">property-placeholder</code> in the
    previous example to provide connection properties. We can also read the
    properties directly from a properties file without using placeholders.
    This is done by using a <code class="classname">properties-location</code>
    attribute specifying the location of the properties file.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When you specify properties using a property file there are two
      basic properties, url and username, where you can use the Oracle
      property name or the name traditionally used by Spring developers. For
      url we also accept URL and for username we also accept user.</p></td></tr></table></div><p>We will use the following property file named
    <code class="filename">orcl.properties</code> and we will place it at the root of
    the classpath.</p><pre class="programlisting">url=jdbc:oracle:thin:@//maui:1521/xe
username=spring
password=spring</pre><p>Once we have this file in place we can reference it from our
    <code class="classname">pooling-data-source</code> entry and omit the property
    plceholder declarations for any properties provided in this file.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        properties-location="classpath:orcl.properties"/&gt;</strong></span> <a name="datasource3.properties"></a><img src="images/callouts/1.png" alt="1" border="0">

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource3.properties"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">pooling-datasource</code> with the
          <code class="classname">properties-location</code> specified. The
          <code class="classname">URL</code>, <code class="classname">user</code> and
          <code class="classname">password</code> properties will be read from the
          provided properties file.</p></td></tr></table></div><p>You can even remove the <code class="classname">properties-location</code>
    attribute as long as you use the default location and name which is a file
    named <code class="filename">orcl.properties</code> at the root of the
    classpath.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource"/&gt;</strong></span> <a name="datasource4.properties"></a><img src="images/callouts/1.png" alt="1" border="0">

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource4.properties"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">pooling-datasource</code> without
          properties or the <code class="classname">properties-location</code>
          specified. We are relying on the default properties file name and
          location.</p></td></tr></table></div></div><div class="section" title="3.4&nbsp;Additional connection and cache properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datasource.4"></a>3.4&nbsp;Additional connection and cache properties</h2></div></div></div><p>It's sometimes necessary to provide additional connection properties
    to control how the database access is configured. There are several ways
    you can provide these properties and they are outlined below.</p><div class="section" title="3.4.1&nbsp;Using the property file for additional connection properties"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.datasource.4.1"></a>3.4.1&nbsp;Using the property file for additional connection
      properties</h3></div></div></div><p>We can provide additional connection properties by ust adding them
      to the properties file we used in the example above.</p><pre class="programlisting">url=jdbc:oracle:thin:@//maui:1521/xe
username=spring
password=spring
processEscapes=false</pre><p>Any properties specified in addition to the standard URL/url,
      user/username and password will be used for configuring the
      <code class="classname">OracleDataSource</code>.</p><p>We can also use a prefix for the connection properties. This can
      be useful if the properties file contain other properties like
      connection cache properties. We will see how these additional properties
      are used later on.</p><pre class="programlisting">conn.url=jdbc:oracle:thin:@//maui:1521/xe
conn.username=spring
conn.password=spring
conn.processEscapes=false</pre><p>The prefix must be specified in the
      <code class="classname">pooling-data-source</code> element configuration. It is
      specified using the <code class="classname">connection-properties-prefix</code>
      attribute.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        connection-properties-prefix="conn" <a name="datasource.4.1.prefix"></a><img src="images/callouts/1.png" alt="1" border="0">
        properties-location="classpath:orcl.properties"/&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.4.1.prefix"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">connection-properties-prefix</code> is
            specified here.</p></td></tr></table></div></div><div class="section" title="3.4.2&nbsp;Using the property file for additional cache properties"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.datasource.4.2"></a>3.4.2&nbsp;Using the property file for additional cache properties</h3></div></div></div><p>We can also specify connection cache properties in the properties
      file. We must use a prefix for these connection cache properties to
      distinguish them from the regular connection properties. In this example
      we are using "cache" as the prefix.</p><pre class="programlisting">conn.url=jdbc:oracle:thin:@//maui:1521/xe
conn.username=spring
conn.password=spring
conn.processEscapes=false
cache.InitialLimit=10</pre><p>The connection cache prefix must be specified using the
      <code class="classname">connection-cache-properties-prefix</code>
      attribute.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        connection-properties-prefix="conn"
        connection-cache-properties-prefix="cache" <a name="datasource.4.2.prefix"></a><img src="images/callouts/1.png" alt="1" border="0">
        properties-location="classpath:orcl.properties"/&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.4.2.prefix"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The
            <code class="classname">connection-cache-properties-prefix</code> is
            specified here.</p></td></tr></table></div></div><div class="section" title="3.4.3&nbsp;Using &#34;connection-properties&#34; element for additional connection properties"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.datasource.4.3"></a>3.4.3&nbsp;Using "connection-properties" element for additional connection
      properties</h3></div></div></div><p>The connection properties can be specified using the
      <code class="classname">connection-properties</code> element.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If you specify a <code class="classname">connection-properties</code>
        element then any connection properties specified in a property file
        other than the basic url, username and password will not be
        used.</p></td></tr></table></div><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        properties-location="classpath:orcl.properties"&gt;
        &lt;orcl:connection-properties&gt;
            processEscapes=false <a name="datasource.4.3.prop"></a><img src="images/callouts/1.png" alt="1" border="0">
        &lt;/orcl:connection-properties&gt;
    &lt;/orcl:pooling-datasource&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.4.3.prop"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The connection properties are specified here.</p></td></tr></table></div></div><div class="section" title="3.4.4&nbsp;Using &#34;connection-cache-properties&#34; element for additional cache properties"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.datasource.4.4"></a>3.4.4&nbsp;Using "connection-cache-properties" element for additional cache
      properties</h3></div></div></div><p>The connection cache properties can be specified using the
      <code class="classname">connection-cache-properties</code> element.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If you specify a
        <code class="classname">connection-cache-properties</code> element then any
        connection cache properties specified in a property file will not be
        used.</p></td></tr></table></div><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        properties-location="classpath:orcl.properties"&gt;
        &lt;orcl:connection-properties&gt;
            processEscapes=false
        &lt;/orcl:connection-properties&gt;
        &lt;orcl:connection-cache-properties&gt;
            InitialLimit=10 <a name="datasrce.4.4.prop"></a><img src="images/callouts/1.png" alt="1" border="0">
        &lt;/orcl:connection-cache-properties&gt;
    &lt;/orcl:pooling-datasource&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasrce.4.4.prop"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The connection cache properties are specified here.</p></td></tr></table></div></div><div class="section" title="3.4.5&nbsp;Using &#34;username-connection-proxy&#34; element for proxy connections"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.datasource.4.5"></a>3.4.5&nbsp;Using "username-connection-proxy" element for proxy
      connections</h3></div></div></div><p>The Oracle JDBC driver provides proxy authentication. This means
      that you can configure a connection pool using a proxy user account with
      limited rights. Then during the connection process you would specify the
      actual username for the end user. This username must be configured to
      allow a proxy connection through the user proxy ("grant connect through
      proxyuser"). See <a class="xref" href="#">???</a> for more details on this
      usage.</p><p>Connection proxy authentication is configured using the
      <code class="classname">username-connection-proxy</code> element. You also need
      to provide a user name provider that implements the
      <code class="classname">ConnectionUsernameProvider</code> interface. This
      interface has a single method named <code class="classname">getUserName</code>
      that should return the username for the current end user to be connected
      via the proxy user.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        properties-location="classpath:orcl.properties"&gt;
        &lt;orcl:username-connection-proxy connection-context-provider="usernameProvider"/&gt; <a name="datasource.4.5.prop"></a><img src="images/callouts/1.png" alt="1" border="0">
    &lt;/orcl:pooling-datasource&gt;

    &lt;bean id="usernameProvider" class="org.springframework.data.jdbc.test.CurrentUsernameProvider"/&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.4.5.prop"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The connection proxy username provider is specified
            here.</p></td></tr></table></div></div></div><div class="section" title="3.5&nbsp;Summary of configuration options for the &#34;pooling-data-source&#34;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datasource.options"></a>3.5&nbsp;Summary of configuration options for the
    "pooling-data-source"</h2></div></div></div><p>The <code class="classname">pooling-data-source</code> element has the
    following attributes:</p><div class="table"><a name="pooling-data-source-settings"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;<code class="literal">&lt;pooling-data-source&gt;</code> attribute
        settings</b></p><div class="table-contents"><table summary="<pooling-data-source&gt; attribute&#xA;        settings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Attribute</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Required</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Default</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">url</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Yes</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The url to be used for connecting to the database. Can be
              provided in a property file. Alternate property name is
              <code class="literal">URL</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">username</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The user name used to connect. Can be provided in a
              property file. Alternate property name is
              <code class="literal">user</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">password</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The password used to connect. Can be provided in a
              property file.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">connection-caching-enabled</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">true</code></td><td style="border-bottom: 0.5pt solid ; ">Is connection caching enabled?</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">fast-connection-failover-enabled</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">false</code></td><td style="border-bottom: 0.5pt solid ; ">Is the fast connection failover feature enabled?</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">ONS-configuration</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The ONS configuration string.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">properties-location</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The location of a properties file containing key-value
              pairs for the connection and connection cache environment using
              a specific prefix to separate connection cache properties from
              connection properties (in standard Properties format, namely
              'key=value' pairs). If no location is specified a properties
              file located at <code class="literal">classpath:orcl.properties</code>
              will be used if found.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">connection-properties-prefix</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&nbsp;</td><td style="border-bottom: 0.5pt solid ; ">The prefix that is used for connection properties
              provided in the property file.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">connection-cache-properties-prefix</code></td><td style="border-right: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; ">&nbsp;</td><td style="">The prefix that is used for connection cache properties
              provided in the property file.</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>The <code class="classname">pooling-data-source</code> element has the
    following child elements:</p><div class="table"><a name="pooling-data-source-elements"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;<code class="literal">&lt;pooling-data-source&gt;</code> child
        elements</b></p><div class="table-contents"><table summary="<pooling-data-source&gt; child&#xA;        elements" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Element</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">connection-properties</code></td><td style="border-bottom: 0.5pt solid ; ">The newline-separated, key-value pairs for the connection
              properties (in standard Properties format, namely 'key=value'
              pairs)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">connection-cache-properties</code></td><td style="border-bottom: 0.5pt solid ; ">The newline-separated, key-value pairs for the
              connection-cache-properties (in standard Properties format,
              namely 'key=value' pairs)</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">username-connection-proxy</code></td><td style="">The configuration of a proxy authentication using a
              connection context provider</td></tr></tbody></table></div></div><p><br class="table-break"></p></div></div><div class="chapter" title="4.&nbsp;Fast Connection Failover"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.failover"></a>4.&nbsp;Fast Connection Failover</h2></div></div></div><p>Oracle's RAC (Real Application Clusters) is an option that supports
  deployment of a single database across a cluster of servers, providing fault
  tolerance from hardware failures or other outages. Since a single database
  is served by a number of nodes, any node failure can be detected and
  subsequent operations can be directed to other nodes in the cluster. This
  support is provided by the "Fast Connection Failover" feature (FCF). When
  the failover occurs the current transaction is rolled back and a new
  transaction has to be initiated.</p><p>Spring's FCF support detects the transaction failure and attempts to
  retry the entire transaction. If this retry is successful it means that the
  client of the failed application will be unaware of this failover and it
  will look like the transaction completed after a brief delay.</p><p>The configuration for the FCF support is a two step configuration.
  First you need to configure a <code class="classname">DataSource</code> for RAC and
  second you need to configure an AOP advisor with a failover interceptor to
  handle the retries.</p><div class="section" title="4.1&nbsp;DataSource Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.failover.config.datasource"></a>4.1&nbsp;DataSource Configuration</h2></div></div></div><p>We are going to need a DataSource that is capable of participating
    in a "Fast Connection Failover" scenario. The only one we have available
    is the <code class="classname">oracle.jdbc.pool.OracleDataSource</code>
    implementation that we will configure using the "orcl" namespace. This
    <code class="classname">DataSource</code> configured with some additional
    properties used for RAC.</p><p>We will be using the following property file to specify the username
    and password for the following example.</p><pre class="programlisting">username=spring
password=spring</pre><p>The url used in this example is a two node RAC configuration using
    the thin driver. It is probably too long to fit on the screen or on the
    page so if you would like to see the entire url it's listed in the callout
    notes.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="racDataSource"
        url="jdbc:oracle:thin:@(description=(address_list=
            (address=(host=rac1)(protocol=tcp)(port=1521))
            (address=(host=rac2)(protocol=tcp)(port=1521)))
            (connect_data=(service_name=racdb1)))"
        properties-location="classpath:orcl.properties"
        fast-connection-failover-enabled="true" <a name="rac.1.fcf"></a><img src="images/callouts/1.png" alt="1" border="0">
        ONS-configuration="rac1:6200,rac2:6200"/&gt;</strong></span> <a name="rac.1.ons"></a><img src="images/callouts/2.png" alt="2" border="0">

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> 
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"racDataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rac.1.fcf"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The fast connection failover is enabled here.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rac.1.ons"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The ONS (Oracle Notification Service) configuration is defined
          here since we are using the thin driver for this example.</p></td></tr></table></div></div><div class="section" title="4.2&nbsp;AOP Configuration for Fast Connection Failover Retry"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.failover.config.aop"></a>4.2&nbsp;AOP Configuration for Fast Connection Failover Retry</h2></div></div></div><p>In order for the Fast Connection Failover to be transparent to the
    end user you need to consider the overall impact of this failover. The
    original transaction will fail and another transaction will be started to
    retry the same operation. You need to consider any non-transactional side
    effects that the failed transaction might have caused. You also need to
    consider work done while the transaction is suspended. This could happen
    if a method with a transactional attribute of "REQUIRES_NEW" is executed
    within the original transaction.</p><p>Once you have considered any possible side effects, you can proceed
    to configure a RacFailoverInterceptor together with the AOP advisor and
    pointcut. The failover advisor must be before or at the same pointcut
    where the transaction advisor is applied. If the pointcuts for the
    failover advisor and the transaction advisor are at the same pointcut then
    the failover advisor must have a higher priority than the transaction
    advisor that it should wrap.</p><p>For the AOP advisor configuration we use the "aop" namespace and for
    the <code class="classname">RacFailoverInterceptor</code> we use the
    <code class="literal">rac-failover-interceptor</code> tag from the "orcl"
    namespace.</p><div class="section" title="4.2.1&nbsp;Configuration when defining transactions using a <tx:advice&gt; and an <aop:advisor&gt;"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.failover.config.aop.advice"></a>4.2.1&nbsp;Configuration when defining transactions using a
      &lt;tx:advice&gt; and an &lt;aop:advisor&gt;</h3></div></div></div><p>When using a <code class="classname">&lt;tx:advice&gt;</code> combined
      with an <code class="classname">&lt;aop:advisor&gt;</code> you simply add an
      additional <code class="classname">&lt;aop:advisor&gt;</code> for the RAC
      failover Interceptor referencing the
      <code class="classname">&lt;orcl:rac-failover-interceptor&gt;</code> element.
      You must make sure that the RAC failover interceptor comes before the
      transaction advice and you can do that by specifying the order attribute
      on the advisor for the RAC failover interceptor. Any advisor specified
      without an order automatically gets the lowest priority, so by
      specifying <code class="classname">order="1"</code> for the RAC failover
      interceptor we are assured this advice will come before the transaction
      advice.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
       <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;aop:config&gt;
        &lt;aop:advisor pointcut="execution(* *..PetStoreFacade.insertOrder(..))" <a name="fcf.1.aop.int"></a><img src="images/callouts/1.png" alt="1" border="0"> 
            advice-ref="racFailoverInterceptor" order="1"/&gt;
        &lt;aop:advisor pointcut="execution(* *..PetStoreFacade.*(..))" <a name="fcf.1.aop.tx"></a><img src="images/callouts/2.png" alt="2" border="0"> 
            advice-ref="txAdvice"/&gt;
    &lt;/aop:config&gt;</strong></span>

    <span class="bold"><strong>&lt;orcl:rac-failover-interceptor id="racFailoverInterceptor"/&gt;</strong></span> <a name="fcf.1.aop.adv"></a><img src="images/callouts/3.png" alt="3" border="0">

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">"txAdvice"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"insert*"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"update*"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">"*"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#fcf.1.aop.int"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The advisor defined for the RAC failover interceptor. This
            must have a higher order than the transaction advisor. We do use
            the same pointcut</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#fcf.1.aop.tx"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The standard transaction advice defined here.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#fcf.1.aop.adv"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The RAC failover interceptor is defined using the
            <code class="classname">rac-failover-interceptor</code> element of the
            "orcl" namespace.</p></td></tr></table></div></div><div class="section" title="4.2.2&nbsp;Configuration when defining transactions using @Transactional annotation"><div class="titlepage"><div><div><h3 class="title"><a name="orcl.failover.config.aop.annotation"></a>4.2.2&nbsp;Configuration when defining transactions using @Transactional
      annotation</h3></div></div></div><p>When using a &lt;tx:annotation-driven&gt; configuration you add
      <code class="classname">&lt;aop:config&gt;</code> entry with an
      <code class="classname">&lt;aop:advisor&gt;</code> element for the RAC failover
      Interceptor referencing the
      <code class="classname">&lt;orcl:rac-failover-interceptor&gt;</code> element.
      You must make sure that the RAC failover interceptor comes before the
      transaction advice and you can do that by specifying the order attribute
      on the advisor for the RAC failover interceptor. Any
      &lt;tx:annotation-driven&gt; specified without an order automatically
      gets the lowest priority, so by specifying
      <code class="classname">order="1"</code> for the RAC failover interceptor we are
      assured this advice will come before the transaction advice.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">"http://www.springframework.org/schema/aop"</span>
       <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;aop:config&gt;
        &lt;aop:advisor <a name="fcf.2.aop.adv"></a><img src="images/callouts/1.png" alt="1" border="0">
            pointcut="@annotation(org.springframework.transaction.annotation.Transactional)" 
            advice-ref="racFailoverInterceptor" order="1"/&gt;
    &lt;/aop:config&gt;</strong></span>

    <span class="bold"><strong>&lt;orcl:rac-failover-interceptor id="racFailoverInterceptor"/&gt;</strong></span> <a name="fcf.2.aop.int"></a><img src="images/callouts/2.png" alt="2" border="0">

    <span class="hl-tag">&lt;tx:annotation-driven/&gt;</span> <a name="fcf.2.aop.anno"></a><img src="images/callouts/3.png" alt="3" border="0">

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#fcf.1.aop.adv"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The advisor defined for the RAC failover interceptor. This
            must have a higher order than the transaction advisor. We use an
            <code class="classname">@annotation</code> pointcut referencing the
            <code class="classname">@Transactional</code> annotation.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#fcf.1.aop.int"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The RAC failover interceptor is defined using the
            <code class="classname">rac-failover-interceptor</code> element of the
            "orcl" namespace.</p></td></tr><tr><td width="5%" valign="top" align="left"><p>???</p></td><td valign="top" align="left"><p>The standard transaction annotation-driven element defined
            here.</p></td></tr></table></div></div></div><div class="section" title="4.3&nbsp;Configuration options for <rac-failover-interceptor&gt;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.failover.config.interceptor"></a>4.3&nbsp;Configuration options for &lt;rac-failover-interceptor&gt;</h2></div></div></div><p>There is a number of optional attributes you can use to configure
    the <code class="literal">rac-failover-interceptor</code>.</p><div class="table"><a name="failover-settings"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;<code class="literal">&lt;rac-failover-interceptor&gt;</code> attribute
      settings</b></p><div class="table-contents"><table summary="<rac-failover-interceptor&gt; attribute&#xA;      settings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Attribute</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Required</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Default</th><th style="border-bottom: 0.5pt solid ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">recoverable-error-codes</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">3113, 3114, 1033, 1034, 1089, 17002, 17008, 17410</td><td style="border-bottom: 0.5pt solid ; ">A comma separated list of integer error codes that will be
            used instead of the default set.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">max-number-of-retries</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">5</td><td style="border-bottom: 0.5pt solid ; ">The maximum number of times the retry will be
            performed.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">back-off-policy</code></td><td style="border-right: 0.5pt solid ; ">No</td><td style="border-right: 0.5pt solid ; "><code class="classname">NoBackOffPolicy</code></td><td style="">A specific back off policy to be used. This is a reference
            to a bean that implements <code class="classname">BackOffPolicy
            *</code></td></tr></tbody></table></div></div><br class="table-break"><p>*
    <code class="classname">org.springframework.batch.retry.backoff.BackOffPolicy</code></p></div></div><div class="chapter" title="5.&nbsp;Oracle's Streams AQ (Advanced Queueing)"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.streamsaq"></a>5.&nbsp;Oracle's Streams AQ (Advanced Queueing)</h2></div></div></div><p>Oracle Streams is a feature that enables the propagation and
  management of data, transactions and events in a data stream either within a
  database, or from one database to another. This can be used both for
  replication and for messaging purposes. The Advanced Queuing (AQ) feature
  provides the messaging support. This messaging support will integrate with
  the standard JMS API provided with Java. Since the AQ support runs in the
  database it is possible to use the same transaction for both messaging and
  database access. This eliminates the need for expensive 2-phase commit
  processing that would be necessary when integrating database access with a
  traditional JMS solution.</p><p>Most of the JMS support we discuss in this chapter is provided
  directly by the Spring Framework. See the <span class="emphasis"><em>Spring Framework
  Reference Documentation</em></span> for the details regarding this JMS
  support.</p><p>In addition to this standard support, The Advance Pack for Oracle
  Database provides easier configuration of a connection factory using the
  <code class="classname">&lt;orcl&gt;</code> namespace. It also provides support for
  some payload types not directly supported by the Spring JMS support like the
  <code class="classname">XMLType</code> and custom Advanced Data Types.</p><div class="section" title="5.1&nbsp;Supported payload types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1208"></a>5.1&nbsp;Supported payload types</h2></div></div></div><p>JMS and Oracle Streams AQ can support a variety of payloads. These
    payloads are stored in the database and need to be converted to a Java
    representation in order for our programs to manipulate them. The following
    table outlines what payloads are supported and the corresponding classes
    that will work with these payloads and that will be able to convert them
    to and from a Java representation.</p><div class="table"><a name="supported-payload-types"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;supported payload types</b></p><div class="table-contents"><table summary="supported payload types" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Payload Type</th><th style="border-bottom: 0.5pt solid ; ">Support Notes</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">SYS.AQ$_JMS_TEXT_MESSAGE,
              SYS.AQ$_JMS_MAP_MESSAGE, SYS.AQ$_JMS_OBJECT_MESSAGE,
              SYS.AQ$_JMS_BYTES_MESSAGE</code></td><td style="border-bottom: 0.5pt solid ; ">Directly supported by
              <code class="classname">SimpleMessageConverter</code> which is the
              default for the <code class="classname">JmsTemplate</code> and the
              <code class="classname">DefaultMessageListenerContainer</code>. When
              configuring a message listener container the
              <code class="classname">DefaultMessageListenerContainer</code> is the
              class that supports the Oracle AQ JMS features.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">SYS.XMLType</code></td><td style="border-bottom: 0.5pt solid ; ">This payload type requires a custom message listener
              container named
              <code class="classname">XmlMessageListenerContainer</code>. This
              listener container also needs a
              <code class="classname">MessageListenerAdapter</code> with an Oracle AQ
              XML specific message converter specified as
              <code class="classname">XmlMessageConverter</code>. See below for
              configuration details.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">custom Advanced Data Type (ADT) (CREATE TYPE xxx
              AS OBJECT)</code></td><td style="">This payload type requires a custom message listener
              container named
              <code class="classname">AdtMessageListenerContainer</code>. This
              listener container also can use a
              <code class="classname">MessageListenerAdapter</code> with a Oracle AQ
              ADT specific message converter specified as
              <code class="classname">MappingAdtMessageConverter</code>. This
              converter works with an implementation of the
              <code class="classname">DatumMapper</code> interface. See below for
              configuration details.</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="section" title="5.2&nbsp;Configuration of the Connection Factory using the &#34;orcl&#34; namespace"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.streamsaq.orcl_config"></a>5.2&nbsp;Configuration of the Connection Factory using the "orcl"
    namespace</h2></div></div></div><p>When you use the JmsTemplate together with the Oracle AQ JMS support
    you can use the <code class="classname">aq-jms-connection-factory</code> entry to
    provide a connection factory to the JmsTemplate.</p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="bold"><strong>xmlns:orcl="http://www.springframework.org/schema/data/orcl"</strong></span> <a name="streamsaq.config.ns"></a><img src="images/callouts/1.png" alt="1" border="0">
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       <span class="bold"><strong>http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"&gt;</strong></span> <a name="streamsaq.config.xsd"></a><img src="images/callouts/2.png" alt="2" border="0">

 
    <span class="bold"><strong>&lt;orcl:aq-jms-connection-factory id="connectionFactory" 
            data-source="dataSource"/&gt;</strong></span> <a name="streamsaq.config.factory"></a><img src="images/callouts/3.png" alt="3" border="0">

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.core.JmsTemplate"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionTransacted"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.ns"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the reference to the
          <code class="classname">orcl</code> schema.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xsd"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We also specify the location for the
          <code class="classname">orcl</code> schema.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.factory"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The connection factory is configured using a reference to the
          data source to be used.</p></td></tr></table></div><p>The configuration for a Message-Driven POJO with a
    <code class="classname">MessageListenerContainer</code> is very similar. You use
    the same type of connection factory configuration. This is passed in to
    the listener container configuration. Here is an example using the JMS
    namespace support.</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="bold"><strong>xmlns:orcl="http://www.springframework.org/schema/data/orcl" <a name="streamsaq.config2.ns"></a><img src="images/callouts/1.png" alt="1" border="0">
       xmlns:jms="http://www.springframework.org/schema/jms"</strong></span>
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       <span class="bold"><strong>http://www.springframework.org/schema/data/orcl <a name="streamsaq.config2.xsd"></a><img src="images/callouts/2.png" alt="2" border="0">
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd
       http://www.springframework.org/schema/jms
       http://www.springframework.org/schema/jms/spring-jms-3.0.xsd</strong></span>"&gt;

    <span class="hl-tag">&lt;context:annotation-config/&gt;</span>
    
    <span class="hl-tag">&lt;tx:annotation-driven/&gt;</span>
    
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageDelegate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"spring.test.MessageDelegate"</span><span class="hl-tag">/&gt;</span>
    
    <span class="bold"><strong>&lt;jms:listener-container connection-factory="connectionFactory" 
            transaction-manager="transactionManager"&gt;
        &lt;jms:listener destination="jmsadmin.jms_text_queue" 
                ref="messageDelegate" method="handleMessage"/&gt;
    &lt;/jms:listener-container&gt;</strong></span> <a name="streamsaq.config2.container"></a><img src="images/callouts/3.png" alt="3" border="0">
    
    <span class="bold"><strong>&lt;orcl:aq-jms-connection-factory id="connectionFactory" 
            data-source="dataSource"/&gt;</strong></span> <a name="streamsaq.config2.factory"></a><img src="images/callouts/4.png" alt="4" border="0">
    
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">...</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config2.ns"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the reference to the
          <code class="classname">orcl</code> and <code class="classname">jms</code>
          schemas.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config2.xsd"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We also specify the location for the
          <code class="classname">orcl</code> and <code class="classname">jms</code>
          schemas.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config2.factory"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The listener container is configured using a reference to the
          connection factory.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config2.factory"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The connection factory is configured using a reference to the
          data source to be used.</p></td></tr></table></div><p>See the next section for how to configure the transaction support
    and use a the same local transaction as the JDBC or ORM data
    access.</p></div><div class="section" title="5.3&nbsp;Configuring the Connection Factory to use the same local transaction as your data access code."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.streamsaq.tx_config"></a>5.3&nbsp;Configuring the Connection Factory to use the same local
    transaction as your data access code.</h2></div></div></div><p>The configurations in the previous section will take advantage of
    the transaction synchronization provided by Spring, but there will be two
    transactions. One transaction for the data access and one for the JMS
    messaging. They will be synchronized, so if the data access transaction
    commits then the messaging transaction will also commit while if the data
    access transaction roll back then the messaging transaction will also roll
    back.</p><p>There is always a chance that the commit for the messaging
    transaction could fail after the data access transaction has committed
    successfully. This is of course a problem that you would have to account
    for in your code by checking for duplicate delivery of a message.</p><p>A better solution is to configure both data access and the messaging
    to share a transaction. Most often this is done using JTA, and that works,
    but has some impact on performance. For JTA you need to use distributed
    transactions and XA capable resources designed for two-phase commits. This
    comes at an extra cost that we try to avoid if possible.</p><p>Another option is to have the data access and the messaging share a
    local data access transaction. This is possible since the Oracle AQ
    implementation consists of a set of tables and stored procedures running
    in the database accessed through a standard JDBC connection. If you use
    the same database for data access and messaging with AQ, then you can
    configure the connection factory to share the database connection and the
    local transaction. You configure this connection and transaction sharing
    by setting the attribute
    <code class="classname">use-local-data-source-transaction</code> to
    <code class="classname">true</code>.</p><pre class="programlisting">    <span class="hl-tag">&lt;orcl:aq-jms-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
        <span class="hl-attribute">use-local-data-source-transaction</span>=<span class="hl-value">"true"</span> <a name="streamsaq.sametx.attr"></a><img src="images/callouts/1.png" alt="1" border="0">
        data-source="dataSource"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.sametx.attr"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Setting the attribute
          <code class="classname">use-local-data-source-transaction</code>.</p></td></tr></table></div><p>Configuring the connection factory to share a local data source
    transaction with the data access code has some implications for JMS
    connection and session caching. You can still configure a
    MessageListenerContainer to cache the JMS connection since each JMS
    session will be created as it's needed inside a data source transaction.
    However, if you cache the JMS session, then the database connection for it
    is established when the container starts up and it will not be possible to
    have this cached JMS session participite in the local data source
    transaction.</p><p>In many application server environments the JDBC connection is
    wrapped in an implementation specific class that delegates to the
    underlying native JDBC connection. Oracle's AQ connection factory needs
    the native Oracle connection and will throw an "oracle.jms.AQjmsException:
    JMS-112: Connection is invalid" exception if the connection is wrapped by
    a foreign class. To solve this problem you can specify a
    <code class="classname">NativeJdbcExtractor</code> that can be used to unwrap the
    connection. Spring provides a number of implementations to match the
    application server environment. Here is an example for specifying a
    <code class="classname">NativeJdbcExtractor</code>.</p><pre class="programlisting">    <span class="hl-tag">&lt;orcl:aq-jms-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
        <span class="hl-attribute">use-local-data-source-transaction</span>=<span class="hl-value">"true"</span>
        <span class="hl-attribute">native-jdbc-extractor</span>=<span class="hl-value">"dbcpNativeJdbcExtractor"</span> <a name="streamsaq.config.nativejdbc"></a><img src="images/callouts/1.png" alt="1" border="0">
        data-source="dataSource" /&gt;

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dbcpNativeJdbcExtractor"</span> 
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dbcpDataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span> 
            <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.driverClassName}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.url}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.username}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.password}"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.nativejdbc"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the reference to the native JDBC
          extractor.</p></td></tr></table></div><p>For some use cases the default plain ConnectionFactory does not work and
	you need to explicitly use a QueueConnectionFactory or a TopicConnectionFactory.
	To support this requirement it is possible to specify this using the
	<code class="classname">connection-factory-type</code> attribute. The default is 
	<code class="classname">CONNECTION</code> but you can specify <code class="classname">QUEUE_CONNECTION</code>
	or <code class="classname">TOPIC_CONNECTION</code> instead. Here is an example for specifying the 
	connection factory type.</p><pre class="programlisting">    <span class="hl-tag">&lt;orcl:aq-jms-connection-factory</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionFactory"</span>
        <span class="hl-attribute">use-local-data-source-transaction</span>=<span class="hl-value">"true"</span>
        <span class="hl-attribute">connection-factory-type</span>=<span class="hl-value">"QUEUE_CONNECTION"</span> <a name="streamsaq.config.factoryType"></a><img src="images/callouts/1.png" alt="1" border="0">
        data-source="dataSource" /&gt;

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dbcpDataSource"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>
            <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.driverClassName}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.url}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.username}"</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${jdbc.password}"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.factoryType"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the type of connection factory to be
	      used.</p></td></tr></table></div></div><div class="section" title="5.4&nbsp;Configuration when using a SYS.XMLType payload"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.streamsaq.xmltype_config"></a>5.4&nbsp;Configuration when using a SYS.XMLType payload</h2></div></div></div><p>When you use a SYS.XMLType as payload there a few additional
    configuration settings are needed.</p><div class="section" title="5.4.1&nbsp;Enqueuing XML messages"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1446"></a>5.4.1&nbsp;Enqueuing XML messages</h3></div></div></div><p>When enqueuing messages the JmsTemplate can be configured with a
      message converter. This message converter should be of a type
      <code class="classname">XmlMessageConverter</code> configured with a specific
      <code class="classname">XmlTypeHandler</code> that you would like to use. The
      following handlers are available:</p><div class="table"><a name="xml-handlers"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;xml handlers</b></p><div class="table-contents"><table summary="xml handlers" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">XML Handler</th><th style="border-bottom: 0.5pt solid ; ">Usage</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">StringXmlTypeHandler</code></td><td style="border-bottom: 0.5pt solid ; ">Handles converting XMLTypes values to and from String
                representation.</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">DocumentXmlTypeHandler</code></td><td style="border-bottom: 0.5pt solid ; ">Handles converting XMLTypes values to and from Document
                representation.</td></tr><tr><td style="border-right: 0.5pt solid ; "><code class="literal">StreamXmlTypeHandler</code></td><td style="">Handles converting XMLTypes values to and from an
                InputStream.</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>
          </p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.core.JmsTemplate"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span> <a name="streamsaq.config.xmltype.enq.connfact"></a><img src="images/callouts/1.png" alt="1" border="0">
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageConverter"</span><a name="streamsaq.config.xmltype.enq.converter"></a><img src="images/callouts/2.png" alt="2" border="0">
           class="org.springframework.data.jdbc.jms.support.converter.oracle.XmlMessageConverter"&gt;
            <span class="hl-tag">&lt;constructor-arg&gt;</span>
                <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.support.oracle.StringXmlTypeHandler"</span><span class="hl-tag">/&gt;</span> <a name="streamsaq.config.xmltype.enq.handler"></a><img src="images/callouts/3.png" alt="3" border="0">
            <span class="hl-tag">&lt;/constructor-arg&gt;</span>
        <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.enq.connfact"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to the configured connection factory.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.enq.converter"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Declaration of an
              <code class="classname">XmlMessageConverter</code> to convert from
              <code class="classname">XMLType</code> to desired representation.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.enq.handler"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>Declaration of the specific
              <code class="classname">XmlTypeHandler</code> that should be used. In
              this case a <code class="classname">StringXmlTypeHandler</code>.</p></td></tr></table></div><p>
      </p><p>Once the JmsTemplate is configured the XML value can be sent using
      the <code class="classname">convertAndSend</code> method. In this example we are
      passing in a String containing the value.</p><pre class="programlisting">        String xmlval = <span class="hl-string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"</span> +
                <span class="hl-string">"&lt;product id=\"10\"&gt;\n"</span> +
                <span class="hl-string">" &lt;description&gt;Foo&lt;/description&gt;\n"</span> +
                <span class="hl-string">" &lt;price&gt;2.05&lt;/price&gt;\n"</span> +
                <span class="hl-string">"&lt;/product&gt;"</span>;

        jmsTemplate.convertAndSend(<span class="hl-string">"jmsadmin.jms_xml_queue"</span>, xmlval);</pre></div><div class="section" title="5.4.2&nbsp;Dequeuing XML messages"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1530"></a>5.4.2&nbsp;Dequeuing XML messages</h3></div></div></div><p>When you want to dequeue messages using a message listener
      container you need to configure an
      <code class="classname">XmlMessageListenerContainer</code> that can dequeue the
      messages and convert the <code class="classname">XMLType</code> payload.</p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageDelegate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.test.xml.MessageDelegate"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;jms:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span> <a name="streamsaq.config.xmltype.connfact"></a><img src="images/callouts/1.png" alt="1" border="0">
    transaction-manager="transactionManager"
    message-converter="messageConverter" 
    container-class="org.springframework.data.jdbc.jms.listener.oracle.XmlMessageListenerContainer"&gt; <a name="streamsaq.config.xmltype.class"></a><img src="images/callouts/2.png" alt="2" border="0">
    <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"jmsadmin.jms_xml_queue"</span> 
        <span class="hl-attribute">ref</span>=<span class="hl-value">"messageDelegate"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"handleMessage"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;/jms:listener&gt;</span>
<span class="hl-tag">&lt;/jms:listener-container&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageConverter"</span> <a name="streamsaq.config.xmltype.converter"></a><img src="images/callouts/3.png" alt="3" border="0">
   class="org.springframework.data.jdbc.jms.support.converter.oracle.XmlMessageConverter"&gt;
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.support.oracle.DocumentXmlTypeHandler"</span><span class="hl-tag">/&gt;</span> <a name="streamsaq.config.xmltype.handler"></a><img src="images/callouts/4.png" alt="4" border="0">
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.connfact"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to the configured connection factory.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.class"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Configuring the class to use for the container - this is a
            custom class <code class="classname">XmlMessageListenerContainer</code>
            that dequeues the Oracle XMLType messages.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.converter"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">XmlMessageConverter</code> is defined
            here.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.xmltype.handler"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">DocumentXmlTypeHandler</code> is used to
            retrieve XML value as a Document.</p></td></tr></table></div><p>Here is an example of the message delegate used in the above
      message listener container:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MessageDelegate {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> DomainService domainService;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handleMessage(Document xmlDoc) 
            <span class="hl-keyword">throws</span> MessageConversionException, JMSException {
        domainService.processXmlMessage(xmlDoc);
    }

}
</pre><p>As you can see the method that handles the message takes a
      <code class="classname">Document</code> as its parameter. The conversion from
      the XMLType to a Document representation is handled by the
      <code class="classname">MessageListenerAdapter</code> since we specified a
      message converter.</p></div></div><div class="section" title="5.5&nbsp;Configuration when using a custom ADT payload"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.streamsaq.adt_config"></a>5.5&nbsp;Configuration when using a custom ADT payload</h2></div></div></div><p>When you use a custom ADT as payload there are certain configuration
    settings that are needed. When creating the queue and its queue table you
    specify the custom type as the "queue_payload_type". This custom type is
    defined using a regular "CREATE TYPE" statement. In the code example that
    follow we have defined a PRODUCT type:</p><pre class="programlisting">create or replace TYPE PRODUCT_TYPE AS OBJECT
(
  id INTEGER,
  description VARCHAR(50),
  price DECIMAL(12,2)
);
</pre><div class="section" title="5.5.1&nbsp;Enqueuing ADT messages"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1592"></a>5.5.1&nbsp;Enqueuing ADT messages</h3></div></div></div><p>When enqueuing messages the JmsTemplate can be configured with a
      message converter. This message converter should be of a type
      <code class="classname">MappingAdtMessageConverter</code> configured with a
      specific <code class="classname">DatumMapper</code> that you would like to use.
      This <code class="classname">DatumMapper</code> can be a custom implementation
      or the provided <code class="classname">StructDatumMapper</code> that will map
      between bean properties and STRUCT attributes of the same name.</p><p>The <code class="classname">DatumMapper</code> interface has the following
      methods declared:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> DatumMapper {

    <span class="hl-keyword">public</span> Datum toDatum(Object object, Connection conn) <span class="hl-keyword">throws</span> SQLException;

    <span class="hl-keyword">public</span> Object fromDatum(Datum datum) <span class="hl-keyword">throws</span> SQLException;

}</pre><p>The <code class="classname">toDatum</code> method will be called with the
      Object to convert to a STRUCT as the first parameter and the current
      connection as the second. It's up to the mapping implementation to
      extract the object properties and to create the STRUCT. For the
      <code class="classname">fromDatum</code> method the STRUCT is passed in and the
      implementation is responsible for retrieving the attributes and
      constructing and instance of the required class.</p><p>
          </p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsTemplate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jms.core.JmsTemplate"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionFactory"</span><span class="hl-tag">/&gt;</span> <a name="streamsaq.config.adt.enq.connfact"></a><img src="images/callouts/1.png" alt="1" border="0">
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"messageConverter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageConverter"</span>
       <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.jms.support.converter.oracle.MappingAdtMessageConverter"</span><span class="hl-tag">&gt;</span><a name="streamsaq.config.adt.enq.converter"></a><img src="images/callouts/2.png" alt="2" border="0">
       <span class="hl-tag">&lt;constructor-arg&gt;</span>
         <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.jms.support.oracle.StructDatumMapper"</span><span class="hl-tag">&gt;</span> <a name="streamsaq.config.adt.enq.mapper"></a><img src="images/callouts/3.png" alt="3" border="0">
           <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"JMSADMIN.PRODUCT_TYPE"</span><span class="hl-tag">/&gt;</span>
           <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.springframework.data.jdbc.test.domain.Product"</span><span class="hl-tag">/&gt;</span>
         <span class="hl-tag">&lt;/bean&gt;</span>
       <span class="hl-tag">&lt;/constructor-arg&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.enq.connfact"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to the configured connection factory.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.enq.converter"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Declaration of an
              <code class="classname">MappingAdtMessageConverter</code> to convert
              from custom type to corresponding JavaBean.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.enq.mapper"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>Declaration of the specific
              <code class="classname">DatumMapper</code> that should be used. In this
              case the provided
              <code class="classname">StructDatumMapper</code>.</p></td></tr></table></div><p>
      </p><p>Once the JmsTemplate is configured the XML value can be sent using
      the <code class="classname">convertAndSend</code> method. In this example we are
      passing in a String containing the value.</p><pre class="programlisting">        Product product = <span class="hl-keyword">new</span> Product();
        product.setId(<span class="hl-number">22L</span>);
        product.setDescription(<span class="hl-string">"Foo"</span>);
        product.setPrice(<span class="hl-keyword">new</span> BigDecimal(<span class="hl-string">"42.95"</span>));

        jms.convertAndSend(<span class="hl-string">"jmsadmin.jms_product_queue"</span>, product);
</pre></div><div class="section" title="5.5.2&nbsp;Dequeuing ADT messages"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1662"></a>5.5.2&nbsp;Dequeuing ADT messages</h3></div></div></div><p>When you want to dequeue messages using a message listener
      container you need to configure an
      <code class="classname">AdtMessageListenerContainer</code> that can dequeue the
      messages and convert the ADT payload.</p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageDelegate"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.test.adt.MessageDelegate"</span><span class="hl-tag"> /&gt;</span>

<span class="hl-tag">&lt;jms:listener-container</span> <span class="hl-attribute">connection-factory</span>=<span class="hl-value">"connectionFactory"</span> <a name="streamsaq.config.adt.connfact"></a><img src="images/callouts/1.png" alt="1" border="0">
    transaction-manager="transactionManager"
    message-converter="messageConverter" 
    container-class="org.springframework.data.jdbc.jms.listener.oracle.AdtMessageListenerContainer"&gt; <a name="streamsaq.config.adt.class"></a><img src="images/callouts/2.png" alt="2" border="0">
  <span class="hl-tag">&lt;jms:listener</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"jmsadmin.jms_product_queue"</span> 
      <span class="hl-attribute">ref</span>=<span class="hl-value">"messageDelegate"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"handleMessage"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;/jms:listener&gt;</span>
<span class="hl-tag">&lt;/jms:listener-container&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageConverter"</span> 
   <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.jms.support.converter.oracle.MappingAdtMessageConverter"</span><span class="hl-tag">&gt;</span><a name="streamsaq.config.adt.converter"></a><img src="images/callouts/3.png" alt="3" border="0">
  <span class="hl-tag">&lt;constructor-arg&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.jms.support.oracle.StructDatumMapper"</span><span class="hl-tag">&gt;</span> <a name="streamsaq.config.adt.mapper"></a><img src="images/callouts/4.png" alt="4" border="0">
      <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"JMSADMIN.PRODUCT_TYPE"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.springframework.data.jdbc.test.domain.Product"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/constructor-arg&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.connfact"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to the configured connection factory.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.connfact"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Configuring the class to use for the container - this is a
            custom class
            <code class="classname">AdtMessageListenerContainer</code>
            that dequeues the ADT messages.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.converter"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">MappingAdtMessageConverter</code> is
            defined here.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#streamsaq.config.adt.mapper"><img src="images/callouts/4.png" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">StructDatumMapper</code> is used to map
            the attributes of the STRUCT retrieved for the ADT to properties
            of the bean class specified as the second constructor
            argument.</p></td></tr></table></div><p>Here is an example of the message delegate used in the above
      message listener container:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MessageDelegate {

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">private</span> DomainService domainService;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handleMessage(Product product) 
            <span class="hl-keyword">throws</span> MessageConversionException, JMSException {
        domainService.saveProduct(product);
    }

}
</pre><p>As you can see the method that handles the message takes a
      <code class="classname">Product</code> as its parameter. The conversion from the
      STRUCT to a Product is handled by the
      <code class="classname">MessageListenerAdapter</code> since we specified a
      message converter.</p></div></div></div><div class="chapter" title="6.&nbsp;XML Types"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.xmltypes"></a>6.&nbsp;XML Types</h2></div></div></div><p>Oracle has some advanced XML Type support built into the database. XML
  data stored in the database is accessible wia JDBC using some Oracle
  specific classes.</p><p>The JDBC framework provided with the Spring Framework supports most of
  this already via SqlTypeValue and SqlReturnType. There is however a need for
  documentation and examples which are specifically targeted for an Oracle
  environment so teams can take advantage of this support and have a reference
  for best practices for the use of these features in an Oracle/Spring
  environment.</p><div class="section" title="6.1&nbsp;Dependencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.xmltypes.1"></a>6.1&nbsp;Dependencies</h2></div></div></div><p>To use the Oracle XML support you need to use a couple of jar files
    available in the <em class="citetitle">Oracle XML Developers Kit</em> download
    available from Oracle. You need <code class="filename">xdb.jar</code> and also the
    <code class="filename">xmlparserv2.jar</code> since the XMLType depends on this
    parser library.</p><p>There is optional support for Spring's Object/XML Mapping (OXM) support.
    If you use this support then you would also need a dependency for the Spring 
    Framework OXM sub-project. The jar files needed is 
    <code class="filename">spring-oxm.jar</code>.</p><p>All samples in this chapter access a table named "xml_table". Here
    is the DDL to create this table:</p><pre class="programlisting">CREATE TABLE xml_table (
    id NUMBER(10),
    xml_text XMLTYPE,
    PRIMARY KEY (id));
</pre></div><div class="section" title="6.2&nbsp;Writing XML to an XMLTYPE column"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.xmltypes.2"></a>6.2&nbsp;Writing XML to an XMLTYPE column</h2></div></div></div><p>To write XML data to a table you need to pass in the XML using a
    custom <code class="classname">SqlTypeValue</code>. In this implementation you
    would be responsible for setting the parameter value for the XML column in
    accordance with the API provided by the database driver.</p><p>For Oracle we provide a database specific implementation of an
    <code class="classname">SqlXmlValue</code>, which is an extension of the
    <code class="classname">SqlTypeValue</code>, that is easier to use. It works
    together with an <code class="classname">SqlXmlHandler</code> and adds an
    abstraction layer on top of the database specific APIs provided by the
    database vendors. There is a new <code class="classname">SQLXML</code> datatype in
    JDBC 4.0 that provides an abstraction, but so far it is not widely
    implemented.</p><p>In this example we have an XML value that we pass in as the second
    parameter. This XML value can be in the form of a
    <code class="classname">String</code> or an
    <code class="classname">org.w3c.dom.Document</code>. We use an
    <code class="classname">SqlXmlHandler</code> instance to gain access to a new
    instance of the <code class="classname">SqlXmlValue</code>. For the Oracle support
    the implementation classes are <code class="classname">OracleXmlHandler</code> and
    <code class="classname">OracleXmlTypeValue</code> respectively.</p><pre class="programlisting">    simpleJdbcTemplate.update(
            "INSERT INTO xml_table (id, xml_text) VALUES (?, ?)",
            id,
            sqlXmlHandler.newSqlXmlValue(xml));<a name="xmltypes.sqlxml.in.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#xmltypes.sqlxml.in.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We instantiate a new <code class="classname">SqlXmlValue</code> that
          will handle setting the parameter value for the XML.</p></td></tr></table></div><p>The implementation of the SqlXmlHandler is chosen in the data access
    configuration file and should be injected into the DAO or Repository
    class.</p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sqlXmlHandler"</span> 
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.support.oracle.OracleXmlHandler"</span><span class="hl-tag">/&gt;</span>
</pre><p>Oracle's <code class="classname">XMLType</code> supports passing in an
    <code class="classname">java.io.InputStream</code> but since this is not supported
    by the JDBC 4.0 <code class="classname">SQLXML</code> datatype you will have to
    use the Oracle specific <code class="classname">OracleXmlTypeValue</code>
    directly.</p><pre class="programlisting">    simpleJdbcTemplate.update(
            <span class="hl-string">"INSERT INTO xml_table (id, xml_text) VALUES (?, ?)"</span>,
            id,
            <span class="hl-keyword">new</span> OracleXmlTypeValue(is));
</pre></div><div class="section" title="6.3&nbsp;Reading XML from an XMLTYPE column"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.xmltypes.3"></a>6.3&nbsp;Reading XML from an XMLTYPE column</h2></div></div></div><p>Running a query against a table with an XMLTYPE column requires a
    RowMapper that can handle retrieval of the XMLType and the corrsponding
    XML data. The <code class="classname">OracleXmlHandler</code> provides several
    methods that supports easy access to the XML data. It is typically used in
    a RowMapper.</p><pre class="programlisting">    String s = simpleJdbcTemplate.queryForObject(
            "SELECT xml_text FROM xml_table WHERE id = ?",
            new ParameterizedRowMapper&lt;String&gt;() {
                public String mapRow(ResultSet rs, int i) throws SQLException {
                    String s = sqlXmlHandler.getXmlAsString(rs, 1);<a name="xmltypes.sqlxml.out.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                    return s;
                }
            },
            id);
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#xmltypes.sqlxml.out.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We use the <code class="classname">OracleXmlHandler</code> to retreive
          the XML value as a String.</p></td></tr></table></div><p>The XML data can be retreived as a String, a java.io.InputStream, a
    java.io.Reader or a javax.xml.transform.Source.</p></div><div class="section" title="6.4&nbsp;Marshalling an object to an XMLTYPE column"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.xmltypes.4"></a>6.4&nbsp;Marshalling an object to an XMLTYPE column</h2></div></div></div><p>To map an object to XML and write this XML to a table you first need
    to use marshalling support available from the Spring Web Services project.
    Once the object data is marshalled to XML we can write the XML to a column
    in a database table. The latter part is very similar to the the XML
    support discussed above. We need to pass in the XML using a custom
    <code class="classname">SqlTypeValue</code>. In the object mapping implementation
    you would be responsible for marshalling the object to XML before setting
    the parameter value.</p><p>In this example we have an object that needs to be marshalled to
    XML. We are using a <code class="classname">Marshaller</code> provided by the
    Spring Web Services project. The marshaller is typically configured and
    then injected into the DAO or Repository. Here is an example configuration
    using the JAXB 2.0 support. In addition to JAXB 2.0, there is also support
    for JAXB 1.0, Castor, XML Beans, JiBX and XStream.</p><pre class="programlisting">    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"marshaller"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.oxm.jaxb.Jaxb2Marshaller"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classesToBeBound"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>org.springframework.data.jdbc.samples.Item<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
</pre><p>The JAXB 2.0 class that we are marshalling is a typical
    javaBean and it uses annotations for the meta data so there is no
    additional configuration needed.</p><pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.data.jdbc.samples;

<span class="hl-keyword">import</span> javax.xml.bind.annotation.*;
<span class="hl-keyword">import</span> java.math.BigDecimal;

<i><span class="hl-annotation" style="color: gray">@XmlRootElement(name = "item")</span></i>
<i><span class="hl-annotation" style="color: gray">@XmlType(propOrder = {"name", "price"})</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item{
    <span class="hl-keyword">private</span> Long id = <span class="hl-number">0L</span>;
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> BigDecimal price;

    <i><span class="hl-annotation" style="color: gray">@XmlAttribute(name="id")</span></i>
    <span class="hl-keyword">public</span> Long getId() {
        <span class="hl-keyword">return</span> id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(Long id) {
        <span class="hl-keyword">this</span>.id = id;
    }

    <i><span class="hl-annotation" style="color: gray">@XmlElement(name = "item-name")</span></i>
    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }

    <i><span class="hl-annotation" style="color: gray">@XmlElement(name = "price")</span></i>
    <span class="hl-keyword">public</span> BigDecimal getPrice() {
        <span class="hl-keyword">return</span> price;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice(BigDecimal price) {
        <span class="hl-keyword">this</span>.price = price;
    }


    <span class="hl-keyword">public</span> String toString() {
        <span class="hl-keyword">return</span> <span class="hl-string">"["</span> + id + <span class="hl-string">"] "</span> + name + <span class="hl-string">" "</span> + price;
    }
}
</pre><p>For Oracle we provide a database specific implementation of an
    <code class="classname">SqlXmlMarshallingValue</code>, which is an extension of
    the <code class="classname">SqlXmlValue</code>, that is easier to use. It works
    together with an <code class="classname">SqlXmlObjectMappingHandler</code> similar
    to the <code class="classname">SqlXmlHandler</code> that we used in the previous
    example. The object to be marshalled is passed in when the new instance of
    the <code class="classname">SqlXmlValue</code> is created.</p><p>For our dabase insert we pass in the marshalled value as the second
    parameter. The first parameter is the id of the object, and this will be
    use as the primary key for the row. We use an
    <code class="classname">SqlXmlHandler</code> instance to gain access to a new
    instance of the <code class="classname">SqlXmlMappingValue</code>. For the Oracle
    support the implementation classes are
    <code class="classname">OracleXmlObjectMappingHandler</code> and
    <code class="classname">OracleXmlMarshallingValue</code> respectively.</p><pre class="programlisting">    simpleJdbcTemplate.update(
            <span class="hl-string">"INSERT INTO xml_table (id, xml_text) VALUES (?, ?)"</span>,
            item.getId(),
            sqlXmlObjectMappingHandler
                    .newMarshallingSqlXmlValue(item));<a name="xmltypes.mapping.in.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#xmltypes.mapping.in.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We instantiate a new marshalling
          <code class="classname">SqlXmlValue</code> that will handle mapping the
          parameter object to XML using a marshaller.</p></td></tr></table></div><p>The implementation of the SqlXmlObjectMappingHandler is chosen in
    the data access configuration file and should be injected into the DAO or
    Repository class.</p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sqlXmlHandler"</span> 
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.support.oracle.OracleXmlObjectMappingHandler"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"marshaller"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"marshaller"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre></div><div class="section" title="6.5&nbsp;Unmarshalling an object from an XMLTYPE column"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.xmltypes.5"></a>6.5&nbsp;Unmarshalling an object from an XMLTYPE column</h2></div></div></div><p>Last piece we need is reading the XML from the database and have it
    unmarshalled to an Item object. We will perform this work in a
    <code class="classname">RowMapper</code> together with the
    <code class="classname">SqlXmlObjectMappingHandler</code>.</p><pre class="programlisting">    Item i = simpleJdbcTemplate.queryForObject(
            "SELECT xml_text FROM xml_table WHERE id = ?",
            new ParameterizedRowMapper&lt;Item&gt;() {
                public Item mapRow(ResultSet rs, int i) throws SQLException {
                    return (Item) sqlXmlObjectMappingHandler
                            .getXmlAsObject(rs, 1);<a name="xmltypes.mapping.out.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                }
            },
            id);
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#xmltypes.mapping.out.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We use the <code class="classname">SqlXmlObjectMappingHandler</code>
          to retreive the XML value and have it unmarshalled to an Item
          instance.</p></td></tr></table></div><p>The XML data is unsmarshalled using an
    <code class="classname">Unmarshaller</code> which in the JAXB 2.0 case is also
    implemented by the <code class="classname">Jaxb2Marshaller</code> class. It must
    be injected into the <code class="classname">unmarshaller</code> property of the
    SqlXmlObjectMappingHandler. Since marshalling and unmarshalling is
    performed by the same object we pass in the bean named
    <code class="classname">marshaller</code> for the
    <code class="classname">unmarshaller</code> property. </p><pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sqlXmlHandler"</span> 
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.support.oracle.OracleXmlObjectMappingHandler"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"unmarshaller"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"marshaller"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
</pre></div></div><div class="chapter" title="7.&nbsp;Advanced Data Types"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.datatypes"></a>7.&nbsp;Advanced Data Types</h2></div></div></div><p>The Oracle database and the PL/SQL language used for stored procedures
  in Oracle has built in support for some advanced data types. These data
  types can't easily be accessed using standard JDBC APIs, so it is necessary
  to rely on Oracle's JDBC extensions like ARRAY and STRUCT and the APIs that
  are used to access them.</p><p>The JDBC framework provided with the Spring Framework supports most of
  this already via <code class="classname">SqlTypeValue</code> and
  <code class="classname">SqlReturnType</code>. The
  <code class="classname">SqlTypeValue</code> interface is used to pass IN parameter
  values. This is easiest accomplished by extending the
  <code class="classname">AbstractSqlTypeValue</code> class. Here you need to
  implement the createTypeValue method. In this method you have access to the
  current connection, the <code class="classname">SqlType</code> and the type name for
  any custom processing that is necessary. When you retrieve advanced data
  types you need to implement the <code class="classname">SqlReturnType</code>
  interface and pass that implementation into the
  <code class="classname">SqlOutParameter</code> constructor. The
  <code class="classname">SqlReturnType</code> interface has one method named
  <code class="classname">getTypeValue</code> that must be implemented. Here you have
  access to the CallableStatement that is currently executing as well as the
  parameterIndex, the <code class="classname">SqlType</code> and the type name for
  customizing the processing.</p><p>When implementing these interfaces there is some boilerplate type code
  that is necessary and it makes your data access code look unnecessarily
  complex. That is the reason why we are providing a number of Oracle specific
  implementations that can handle the Oracle advanced types. The usage of
  these type handlers is documented in this chapter. These features are
  specifically targeted for an Oracle environment so teams can take advantage
  of this support and have a reference for best practices for the use of these
  features in an Oracle/Spring environment.</p><p>We will use the following simple table for all the examples in this
  chapter. This table is used to store some basic information about
  actors.</p><pre class="programlisting">CREATE TABLE actor (
    id NUMBER(10),
    name VARCHAR2(50),
    age NUMBER,
    PRIMARY KEY (id));</pre><div class="section" title="7.1&nbsp;Using a STRUCT parameter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datatypes.struct"></a>7.1&nbsp;Using a STRUCT parameter</h2></div></div></div><p>When your stored procedures has parameters that are declared using
    custom object types that aren't part of the standard JDBC types they are
    managed using JDBC <code class="classname">Struct</code> objects. When working
    with Oracle it's easier to work with Oracle's extension to
    <code class="classname">Struct</code> which is
    <code class="classname">oracle.sql.STRUCT</code>.</p><p>For the <code class="literal">STRUCT</code> examples we will use the following
    type declaration.</p><pre class="programlisting">CREATE OR REPLACE TYPE actor_type
    AS OBJECT (id NUMBER(10), name VARCHAR2(50), age NUMBER);</pre><p>The data contained in a STRUCT parameter can be accessed in two
    ways. Either using the <code class="classname">SQLData</code> interface which is
    part of the JDBC specification, or by using Oracle specific calls
    accessing the attributes directly. We will cover both methods.</p><p>Now we will look at the sample procedures used for this example.
    First one is the procedure we use to add the actor data.</p><pre class="programlisting">CREATE OR REPLACE PROCEDURE add_actor (in_actor IN actor_type)
AS
BEGIN
  INSERT into actor (id, name, age) VALUES(in_actor.id, in_actor.name, in_actor.age);
END;</pre><p>This procedure has one IN parameter (in_actor) of object type
    <code class="classname">actor_type</code>.</p><p>Next we show the procedure used to retrieve the actor data.</p><pre class="programlisting">CREATE OR REPLACE PROCEDURE get_actor (in_actor_id IN NUMBER, out_actor OUT actor_type)
AS
BEGIN
  SELECT actor_type(id, name, age) INTO out_actor FROM actor WHERE id = in_actor_id;
END;</pre><p>This procedure has two parameters, one IN parameter
    (<code class="classname">in_actor_id</code>) that is the id of the actor to
    retrieve and one OUT parameter (<code class="classname">out_actor</code>) of type
    <code class="classname">actor_type</code> to pass back the data retrieved.</p><p>The last piece we will cover here is the Java class that represents
    the type we are accessing. Here is the <code class="classname">Actor</code>
    implementation used in this example. It has the Java equivalent of the
    variables we defined for the type in the database. We also have setters
    and getters for all fields.</p><pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.data.jdbc.samples;

<span class="hl-keyword">import</span> java.sql.SQLData;
<span class="hl-keyword">import</span> java.sql.SQLException;
<span class="hl-keyword">import</span> java.sql.SQLInput;
<span class="hl-keyword">import</span> java.sql.SQLOutput;
<span class="hl-keyword">import</span> java.math.BigDecimal;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {

    <span class="hl-keyword">private</span> Long id;
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> age;


    <span class="hl-keyword">public</span> Long getId() {
        <span class="hl-keyword">return</span> id;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(Long id) {
        <span class="hl-keyword">this</span>.id = id;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getAge() {
        <span class="hl-keyword">return</span> age;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAge(<span class="hl-keyword">int</span> age) {
        <span class="hl-keyword">this</span>.age = age;
    }

    <span class="hl-keyword">public</span> String toString() {
    <span class="hl-keyword">return</span> <span class="hl-string">"Actor: ["</span> + id + <span class="hl-string">"] "</span> + name + <span class="hl-string">" "</span> + age;
    }

}
</pre><div class="section" title="7.1.1&nbsp;Using an SQLData implementation for a STRUCT IN parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2044"></a>7.1.1&nbsp;Using an SQLData implementation for a STRUCT IN parameter</h3></div></div></div><p>For the examples that use <code class="classname">SQLData</code> we first
      need a Java class that implements the SQLData interface. For this
      example we create an <code class="classname">SqlActor</code> class that extends
      the <code class="classname">Actor</code> class shown earlier and provides the
      <code class="classname">SQLData</code> implementation for our
      <code class="classname">ACTOR_TYPE</code>.</p><pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.data.jdbc.samples;

<span class="hl-keyword">import</span> java.sql.SQLData;
<span class="hl-keyword">import</span> java.sql.SQLException;
<span class="hl-keyword">import</span> java.sql.SQLInput;
<span class="hl-keyword">import</span> java.sql.SQLOutput;
<span class="hl-keyword">import</span> java.math.BigDecimal;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SqlActor <span class="hl-keyword">extends</span> Actor <span class="hl-keyword">implements</span> SQLData {

    <span class="hl-keyword">public</span> String getSQLTypeName() <span class="hl-keyword">throws</span> SQLException {
        <span class="hl-keyword">return</span> <span class="hl-string">"ACTOR_TYPE"</span>; <a name="datatypes.sqldata.returntype"></a><img src="images/callouts/1.png" alt="1" border="0">
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> readSQL(SQLInput sqlInput, String string) <span class="hl-keyword">throws</span> SQLException { <a name="datatypes.sqldata.readsql"></a><img src="images/callouts/2.png" alt="2" border="0">
        setId(Long.valueOf(sqlInput.readLong()));
        setName(sqlInput.readString());
        setAge(sqlInput.readInt());
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> writeSQL(SQLOutput sqlOutput) <span class="hl-keyword">throws</span> SQLException { <a name="datatypes.sqldata.writesql"></a><img src="images/callouts/3.png" alt="3" border="0">
        sqlOutput.writeLong(getId().longValue());
        sqlOutput.writeString(getName());
        sqlOutput.writeInt(getAge());
    }

}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.returntype"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the <code class="classname">ACTOR_TYPE</code>
            advanced data type as the type supported by this implementation.
            Note: Since Oracle's metadata is stored using all caps, unless the
            name was explicitly defined as mixed case using quotes, we define
            the type name here as all caps.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.readsql"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the implementation used to map data between
            the <code class="classname">ACTOR_TYPE</code> advanced data type and the
            <code class="classname">Actor</code> class during a read operation.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.writesql"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the implementation used to map data between
            the <code class="classname">Actor</code> class and the
            <code class="classname">ACTOR_TYPE</code> advanced data type during a
            write operation.</p></td></tr></table></div><p>As you can see, the <code class="classname">SQLData</code> implementation
      is fairly straightforward. We implemented the three methods required in
      the <code class="classname">SQLData</code> interface. These methods are
      getSQLTypeName, readSQL and writeSQL.</p><p>Now we can move on to actually call the stored procedure. First
      example is using the newer <code class="classname">SimpleJdbcCall</code> API but
      the <code class="classname">SqlParameter</code> would be the same if you used
      the classic <code class="classname">StoredProcedure</code> approach. We create
      the <code class="classname">SimpleJdbcCall</code> and in the
      <code class="classname">declareParameters</code> method call we pass in an
      <code class="classname">SqlParameter</code> that defines the parameter with the
      type as OracleTypes.STRUCT and a type name of ACTOR_TYPE to match what
      it is defined in the database. Note that the type name is defined here
      as all caps since that is how it is stored in the database metadata. Any
      type names declared here are case sensitive and must match what is
      actually stored in the database metadata.</p><pre class="programlisting">    <span class="hl-keyword">this</span>.addSqlActorCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"add_actor"</span>)
                .declareParameters(
                    <span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>)); <a name="datatypes.sqldata.in.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.in.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the <code class="classname">SqlParameter</code> with
            parameter name, the Oracle type and the type name as it is
            declared in the database.</p></td></tr></table></div><p>Next we look at the code that executes this
      <code class="classname">SimpleJdbcCall</code>.</p><pre class="programlisting">    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addSqlActor(<span class="hl-keyword">final</span> SqlActor actor) {
        Map in = Collections.singletonMap(<span class="hl-string">"in_actor"</span>, actor); <a name="datatypes.sqldata.in.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
        addSqlActorCall.execute(in);
    }
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.in.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We execute the call by passing in a
            <code class="classname">Map</code> containing any in parameters - in this
            case the actor object.</p></td></tr></table></div><p>What happens here is that the JDBC driver access the data in the
      passed in Actor instance via the <code class="classname">SQLData</code>
      interface and maps that data to the ACTOR_TYPE passed in to the stored
      procedure. There is no need to implement anything else since this is all
      handled by the JDBC layer.</p><p>Please note that since <code class="classname">SimpleJdbcCall</code> is
      relying on database metadata, the parameter names used for the input
      must match the names used when declaring the stored procedure. They are
      however not case sensitive, only the type names are case
      sensitive.</p><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> AddSqlActorProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> AddSqlActorProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"add_actor"</span>);
            declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>));
        }

        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute(Actor actor) {
            Map in = Collections.singletonMap(<span class="hl-string">"in_actor"</span>, actor);
            <span class="hl-keyword">this</span>.execute(in);
        }

    }
</pre></div><div class="section" title="7.1.2&nbsp;Using SqlReturnSqlData with an SQLData implementation from a STRUCT OUT parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2166"></a>7.1.2&nbsp;Using SqlReturnSqlData with an SQLData implementation from a
      STRUCT OUT parameter</h3></div></div></div><p>Now we will call the stored procedure that retrieves actor data.
      We are still using the newer <code class="classname">SimpleJdbcCall</code> API.
      We create the <code class="classname">SimpleJdbcCall</code> and in the
      <code class="classname">declareParameters</code> call we pass in an
      <code class="classname">SqlOutParameter</code> that uses an
      <code class="classname">SqlReturnType</code> to handle the configuration
      necessary for the mapping between the Oracle type and the Java type
      which is still the <code class="classname">SqlActor</code>. We also need to link
      between the <code class="classname">Actor</code> class and the
      <code class="classname">ACTOR_TYPE</code> since the JDBC driver is not aware of
      this relationship when we are reading data from the database. This is
      done by declaring a SqlReturnSqlData class and passing in the target
      class in the constructor.</p><pre class="programlisting">        <span class="hl-keyword">this</span>.getSqlActorCall =
                <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"get_actor"</span>)
                    .declareParameters(
                        <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>, <a name="datatypes.sqldata.out.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                            <span class="hl-keyword">new</span> SqlReturnSqlData(SqlActor.<span class="hl-keyword">class</span>)) <a name="datatypes.sqldata.out.call.2"></a><img src="images/callouts/2.png" alt="2" border="0">
                    );
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.out.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the parameter name and the Oracle type and the
            type name as it is declared in the database.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.out.call.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Here we define the <code class="classname">SqlReturnSqlData</code>
            and the desired target class.</p></td></tr></table></div><p>Next we look at the code that executes this
      <code class="classname">SimpleJdbcCall</code>.</p><pre class="programlisting">    <span class="hl-keyword">public</span> SqlActor getSqlActor(<span class="hl-keyword">int</span> id) {
        Map in = Collections.singletonMap(<span class="hl-string">"in_actor_id"</span>, id);
        <span class="hl-keyword">return</span> getSqlActorCall.executeObject(SqlActor.<span class="hl-keyword">class</span>, in); <a name="datatypes.sqldata.out.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
    }
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.sqldata.out.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We execute the call by passing in a
            <code class="classname">Map</code> containing any in parameters. The
            <code class="classname">execute</code>Object method returns an
            <code class="classname">SqlActor</code> containing the data returned by
            the stored procedure call.</p></td></tr></table></div><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> GetSqlActorProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> GetSqlActorProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"get_actor"</span>);
            declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor_id"</span>, Types.NUMERIC));
            declareParameter(
                <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>,
                    <span class="hl-keyword">new</span> SqlReturnSqlData(SqlActor.<span class="hl-keyword">class</span>))
            );
        }

        <span class="hl-keyword">public</span> SqlActor execute(Long id) {
            Map in = Collections.singletonMap(<span class="hl-string">"in_actor_id"</span>, id);
            Map out = <span class="hl-keyword">this</span>.execute(in);
            <span class="hl-keyword">return</span> (SqlActor) out.get(<span class="hl-string">"out_actor"</span>);
        }

    }
</pre></div><div class="section" title="7.1.3&nbsp;Setting STRUCT attribute values using SqlStructValue for an IN parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2237"></a>7.1.3&nbsp;Setting STRUCT attribute values using SqlStructValue for an IN
      parameter</h3></div></div></div><p>An alternate access technique is to use the
      <code class="classname">Struct</code> interface to access a generic collection
      of attributes representing the type. The
      <code class="classname">SqlStructValue</code> implementation will map properties
      in a JavaBean to the corresponding attributes of the STRUCT so there is
      no need to provide custom mapping code. The following example will
      perform the same operations as the previous example using this alternate
      technique.</p><p>The SimpleJdbcCall declaration for the "add_actor" call looks the
      same.</p><pre class="programlisting">    <span class="hl-keyword">this</span>.addActorCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"add_actor"</span>)
                .declareParameters(
                    <span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>)); <a name="datatypes.struct.in.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.in.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the <code class="classname">SqlParameter</code> with
            parameter name, the Oracle type and the type name as it is
            declared in the database.</p></td></tr></table></div><p>Next we'll look at the code used to execute this procedure call.
      The difference is in the execution and the mapping of attributes.
      Instead of relying on the <code class="classname">SqlActor</code> class to do
      the mapping, we create a <code class="classname">SqlStructValue</code> and pass
      in the <code class="classname">Actor</code> instance in the constructor. The
      <code class="classname">SqlStructValue</code> class will do the mapping between
      the bean properties of the Actor class and the attributes of the STRUCT.
      This <code class="classname">SqlStructValue</code> is then passed in as the data
      value in the input map for the execute call.</p><pre class="programlisting">    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addActor(<span class="hl-keyword">final</span> Actor actor) {
        Map in = Collections.singletonMap(<span class="hl-string">"in_actor"</span>, <span class="hl-keyword">new</span> SqlStructValue(actor)); <a name="datatypes.struct.in.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
        addActorCall.execute(in); <a name="datatypes.struct.in.exec.2"></a><img src="images/callouts/2.png" alt="2" border="0">
    }
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.in.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We create an <code class="classname">SqlStructValue</code> that will
            handle the type creation and mapping and add it to the
            <code class="classname">Map</code> containing the in parameters.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.in.exec.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We execute the call by passing in the input
            <code class="classname">Map</code>.</p></td></tr></table></div><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> AddActorProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> AddActorProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"add_actor"</span>);
            declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>));
        }

        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute(Actor actor) {
            Map in = Collections.singletonMap(<span class="hl-string">"in_actor"</span>, <span class="hl-keyword">new</span> SqlStructValue(actor));
            <span class="hl-keyword">this</span>.execute(in);
        }

    }
</pre></div><div class="section" title="7.1.4&nbsp;Using SqlReturnStruct to access STRUCT data from an OUT parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2304"></a>7.1.4&nbsp;Using SqlReturnStruct to access STRUCT data from an OUT
      parameter</h3></div></div></div><p>You can use the <code class="classname">SqlReturnStruct</code> class to
      map between the attributes of a <code class="classname">STRUCT</code> object and
      properties of a <code class="classname">JavaBean</code>. This is more convenient
      than providing this mapping yourself. This example will show how this
      can be done using an SqlOutParameter combined with the
      <code class="classname">SqlReturnStruct</code> class.</p><pre class="programlisting">    <span class="hl-keyword">this</span>.getActorCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"get_actor"</span>)
                .declareParameters(
                    <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>, <a name="datatypes.struct.out.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                            <span class="hl-keyword">new</span> SqlReturnStruct(Actor.<span class="hl-keyword">class</span>)) <a name="datatypes.struct.out.call.2"></a><img src="images/callouts/2.png" alt="2" border="0">
            );
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.out.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the <code class="classname">SqlParameter</code> with
            parameter name, the Oracle type and the type name as it is
            declared in the database.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.out.call.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">SqlReturnStruct</code> will retrieve the
            STRUCT and access the array of objects representing the attributes
            and then map them to the properties of the
            <code class="classname">JavaBean</code> instance provided n the
            constructor.</p></td></tr></table></div><p>Next we look at the code that executes this
      <code class="classname">SimpleJdbcCall</code>.</p><pre class="programlisting">    <span class="hl-keyword">public</span> Actor getActor(<span class="hl-keyword">int</span> id) {
        Map in = Collections.singletonMap(<span class="hl-string">"in_actor_id"</span>, id);
        <span class="hl-keyword">return</span> getActorCall.executeObject(Actor.<span class="hl-keyword">class</span>, in); <a name="datatypes.struct.out.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
    }
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.struct.out.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We execute the call by passing in a
            <code class="classname">Map</code> containing any in parameters. The
            <code class="classname">execute</code>Object method returns an
            <code class="classname">Actor</code> containing the data returned by the
            stored procedure call.</p></td></tr></table></div><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> GetActorProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> GetActorProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"get_actor"</span>);
            declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor_id"</span>, Types.NUMERIC));
            declareParameter(
                <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actor"</span>, OracleTypes.STRUCT, <span class="hl-string">"ACTOR_TYPE"</span>,
                        <span class="hl-keyword">new</span> SqlReturnStruct(Actor.<span class="hl-keyword">class</span>))
            );
        }

        <span class="hl-keyword">public</span> Actor execute(Long id) {
            Map in = Collections.singletonMap(<span class="hl-string">"in_actor_id"</span>, id);
            Map out = <span class="hl-keyword">this</span>.execute(in);
            <span class="hl-keyword">return</span> (Actor) out.get(<span class="hl-string">"out_actor"</span>);
        }

    }
</pre></div></div><div class="section" title="7.2&nbsp;Using an ARRAY parameter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datatypes.array"></a>7.2&nbsp;Using an ARRAY parameter</h2></div></div></div><p>Sometimes your stored procedures has parameters that are declared as
    arrays of some type. These arrays are managed using JDBC
    <code class="classname">Array</code> objects. When working with Oracle it's
    sometimes easier to work with Oracle's extension to
    <code class="classname">Array</code> which is
    <code class="classname">oracle.sql.ARRAY</code>.</p><p>For the <code class="literal">ARRAY</code> examples we will use the following
    type declarations.</p><pre class="programlisting">CREATE OR REPLACE TYPE actor_name_array 
    AS VARRAY(20) OF VARCHAR2(50);
CREATE OR REPLACE TYPE actor_id_array 
    AS VARRAY(20) OF NUMBER;
</pre><p>We will show how to access parameters using these declarations in
    two JDBC calls. The first one is a procedure call that deletes actor
    entries based on ids provided in an <code class="literal">actor_id_array</code>. The
    second example calls a function to retrieve an array of the names for all
    actors in the table.</p><div class="section" title="7.2.1&nbsp;Setting ARRAY values using SqlArrayValue for an IN parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2395"></a>7.2.1&nbsp;Setting ARRAY values using SqlArrayValue for an IN
      parameter</h3></div></div></div><p>We are using the SimpleJdbcCall for this example and when we
      configure this call its important to note that we can't rely on the
      database metadata. Whenever a collection type is used the metadata
      reported back from the JDBC driver contains entries bot for the
      collection type and for the type contained in the collection so it looks
      like there are additional parameters. Because of this it is best to turn
      off the metadata processing by calling
      the<code class="classname">withoutProcedureColumnMetaDataAccess</code>
      method.</p><p>This example calls a procedure that deletes actors based on the
      ids provided in an array. Here is the source for this procedure:</p><pre class="programlisting">CREATE OR REPLACE PROCEDURE delete_actors (in_actor_ids IN actor_id_array)
AS
BEGIN
  FOR i IN 1..in_actor_ids.count loop
    DELETE FROM actor WHERE id = in_actor_ids(i);
  END LOOP;
END;</pre><p>The declaration of the ARRAY parameter follows the same pattern as
      we used previously for the STRUCT parameters. We are simply providing
      the <code class="classname">OracleTypes.ARRAY</code> SQL type along with the
      type name as it is specified in the database metadata.</p><p>
          </p><pre class="programlisting">    <span class="hl-keyword">this</span>.deleteActorsCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"delete_actors"</span>)
                .withoutProcedureColumnMetaDataAccess()
                .declareParameters(
                    <span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor_ids"</span>, OracleTypes.ARRAY, <span class="hl-string">"ACTOR_ID_ARRAY"</span>)); <a name="datatypes.array.in.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.array.in.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the <code class="classname">SqlParameter</code> with
              parameter name, the Oracle type and the type name as it is
              declared in the database.</p></td></tr></table></div><p>
      Next we look at the code that executes this
      <code class="classname">SimpleJdbcCall</code>. For IN parameters the arrays are
      managed using an <code class="classname">SqlArrayValue</code> implementation
      that will handle the ArrayDescriptor creation and the mapping of the
      array to an oracle.sql.ARRAY instance.
          </p><pre class="programlisting">    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> deleteActors(<span class="hl-keyword">final</span> Long[] ids) {
        Map in = Collections.singletonMap(<span class="hl-string">"in_actor_ids"</span>, <span class="hl-keyword">new</span> SqlArrayValue(ids)); <a name="array.type.in.execute"></a><img src="images/callouts/1.png" alt="1" border="0">
        deleteActorsCall.execute(in);
    }
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#array.type.in.execute"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We declare an <code class="classname">SqlArrayValue</code>
              instance that will handle creating the
              <code class="classname">ArrayDesriptor</code> and the
              <code class="classname">ARRAY</code> to be passed in as the parameter
              value.</p></td></tr></table></div><p>
      </p><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> DeleteActorsProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> DeleteActorsProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"delete_actors"</span>);
            declareParameter(
                <span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">"in_actor_ids"</span>, OracleTypes.ARRAY, <span class="hl-string">"ACTOR_ID_ARRAY"</span>));
        }

        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute(Long[] ids) {
            Map in = Collections.singletonMap(<span class="hl-string">"in_actor_ids"</span>, <span class="hl-keyword">new</span> SqlArrayValue(ids));
            Map out = <span class="hl-keyword">this</span>.execute(in);
        }

    }
</pre></div><div class="section" title="7.2.2&nbsp;Using SqlReturnArray to handle the ARRAY from an OUT parameter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2456"></a>7.2.2&nbsp;Using SqlReturnArray to handle the ARRAY from an OUT
      parameter</h3></div></div></div><p>Now it is time to handle the OUT parameter scenario. Here it is an
      SqlOutParameter combined with an SqlReturnArray instance that is
      responsible for handling the
      <code class="classname">Array</code>.

          </p><pre class="programlisting">    <span class="hl-keyword">this</span>.getActorNamesCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withFunctionName(<span class="hl-string">"get_actor_names"</span>)
                .withoutProcedureColumnMetaDataAccess()
                .declareParameters(
                     <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"return"</span>, Types.ARRAY, <span class="hl-string">"ACTOR_NAME_ARRAY"</span>, <a name="datatypes.array.out.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                         <span class="hl-keyword">new</span> SqlReturnArray())); <a name="datatypes.array.out.call.2"></a><img src="images/callouts/2.png" alt="2" border="0">
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.array.out.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We declare an <code class="classname">SqlOutParameter</code> with
              parameter name, the Oracle type and the type name as it is
              declared in the database.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.array.out.call.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="classname">SqlReturnArray</code> accesses the
              ARRAY parameter using the JDBC calls and creates the
              <code class="classname">String</code> array that is the return value for
              this example.</p></td></tr></table></div><p>
      Next we look at the code that executes this
      <code class="classname">SimpleJdbcCall</code>.</p><p>

          </p><pre class="programlisting">    <span class="hl-keyword">public</span> String[] getActorNames() {
        Map in = Collections.emptyMap();
        <span class="hl-keyword">return</span> getActorNamesCall.executeFunction(String[].<span class="hl-keyword">class</span>, in); <a name="datatypes.array.out.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
    }
</pre><p>

          </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.array.out.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we just have to call executeFunction passing in the
              expected output class and an empty map since there are no IN
              parameters.</p></td></tr></table></div><p>
      </p><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> GetActorNamesProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> GetActorNamesProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"get_actor_names"</span>);
            setFunction(true);
            declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"return"</span>, Types.ARRAY, <span class="hl-string">"ACTOR_NAME_ARRAY"</span>,
                    <span class="hl-keyword">new</span> SqlReturnArray()));
        }

        <span class="hl-keyword">public</span> String[] execute() {
            Map in = Collections.emptyMap();
            Map out = <span class="hl-keyword">this</span>.execute(in);
            <span class="hl-keyword">return</span> (String[]) out.get(<span class="hl-string">"return"</span>);
        }

    }
</pre></div></div><div class="section" title="7.3&nbsp;Handling a REF CURSOR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.datatypes.ref_cur"></a>7.3&nbsp;Handling a REF CURSOR</h2></div></div></div><p>The Spring Framework already contains implementations that simplify
    the handling of REF CURSORS but we include an example here just to
    complete the coverage of the handling of Oracle specific advanced data
    types. The procedure we are calling is declared as follows:</p><pre class="programlisting">CREATE OR REPLACE PROCEDURE read_actors (out_actors_cur OUT sys_refcursor)
AS
BEGIN
  OPEN out_actors_cur FOR 'select * from actor';
END;</pre><div class="section" title="7.3.1&nbsp;Retrieving data using a ParameterizedBeanPropertyRowMapper from a REF CURSOR"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2514"></a>7.3.1&nbsp;Retrieving data using a ParameterizedBeanPropertyRowMapper from a
      REF CURSOR</h3></div></div></div><p>First we'll look at a <code class="classname">SimpleJdbcCall</code>
      implementation where we use the
      <code class="classname">returningResultSet</code> method to declare the
      <code class="classname">RowMapper</code> we want to use. We have an Actor class
      that is a JavaBean and the properties match the column names so we can
      use the ParameterizedBeanPropertyRowMapper to automatically map data
      from the <code class="classname">ResultSet</code> to the bean properties. Here
      is the code used to declare this
      <code class="classname">SimpleJdbcCall</code>:</p><pre class="programlisting">    <span class="hl-keyword">this</span>.readActorsCall =
            <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource).withProcedureName(<span class="hl-string">"read_actors"</span>)
                .returningResultSet(<span class="hl-string">"out_actors_cur"</span>, <a name="datatypes.refcur.out.call.1"></a><img src="images/callouts/1.png" alt="1" border="0">
                        ParameterizedBeanPropertyRowMapper.newInstance(Actor.<span class="hl-keyword">class</span>)); <a name="datatypes.refcur.out.call.2"></a><img src="images/callouts/2.png" alt="2" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.refcur.out.call.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We declare a <code class="classname">returningResultSet</code> with
            parameter name and the <code class="classname">RowMapper</code> we would
            like to use.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.refcur.out.call.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The
            <code class="classname">ParameterizedBeanPropertyRowMapper</code> accesses
            the <code class="classname">ResultSetMetaData</code> and maps the row
            columns to corresponding bean properties in the class specified as
            parameter to the <code class="classname">newInstace</code> method
            call.</p></td></tr></table></div><p>To execute this call we use the following code:</p><pre class="programlisting">    <span class="hl-keyword">public</span> List&lt;Actor&gt; getActors() {
        <span class="hl-keyword">return</span> readActorsCall.executeObject(List.<span class="hl-keyword">class</span>, Collections.emptyMap()); <a name="datatypes.refcur.out.exec.1"></a><img src="images/callouts/1.png" alt="1" border="0">
    }
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.refcur.out.exec.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we just have to call executeObject passing in the
            expected output class which is a <code class="classname">List</code> and
            an empty map since there are no IN parameters.</p></td></tr></table></div><p>When using the StoredProcedure class we would need to use an
      <code class="classname">SqlOutParameter</code> that accepts a
      <code class="classname">RowMapper</code>. Here is an example of an
      <code class="classname">SqlOutParameter</code> configured with a
      <code class="classname">ParameterizedBeanPropertyRowMapper</code>.</p><pre class="programlisting">        <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actors_cur"</span>, OracleTypes.CURSOR, 
                ParameterizedBeanPropertyRowMapper.newInstance(Actor.<span class="hl-keyword">class</span>)) <a name="datatypes.refcur.out.proc.1"></a><img src="images/callouts/1.png" alt="1" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datatypes.refcur.out.proc.1"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>Here we specify the parameter name and the SQL type which is
            <code class="classname">OracleTypes.CURSOR</code> and instantiate a
            <code class="classname">ParameterizedBeanPropertyRowMapper</code> to be
            used to map row data to the <code class="classname">Actor</code>
            class.</p></td></tr></table></div><p>If you prefer to use the classic StoredProcedure class then the
      equivalent configuration would look like this:</p><pre class="programlisting">    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> ReadActorsProc <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">public</span> ReadActorsProc(DataSource dataSource) {
            <span class="hl-keyword">super</span>(dataSource, <span class="hl-string">"read_actors"</span>);
            declareParameter(
                <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">"out_actors_cur"</span>, OracleTypes.CURSOR,
                        ParameterizedBeanPropertyRowMapper.newInstance(Actor.<span class="hl-keyword">class</span>))
            );

        }

        <span class="hl-keyword">public</span> List execute() {
            Map in = Collections.emptyMap();
            Map out = <span class="hl-keyword">this</span>.execute(in);
            <span class="hl-keyword">return</span> (List) out.get(<span class="hl-string">"out_actors_cur"</span>);
        }

    }
</pre></div></div></div><div class="chapter" title="8.&nbsp;Custom DataSource Connection Configurations"><div class="titlepage"><div><div><h2 class="title"><a name="orcl.connection"></a>8.&nbsp;Custom DataSource Connection Configurations</h2></div></div></div><div class="section" title="8.1&nbsp;Configuration of a Proxy Authentication"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.connection.1"></a>8.1&nbsp;Configuration of a Proxy Authentication</h2></div></div></div><p>The Oracle JDBC implementation provides access to Oracle's Proxy
    Authentication feature. The Proxy Authentication lets you configure a
    connection pool using a proxy user account with very limited rights. Then,
    during the connection process, you would specify the actual user name for
    the end user. This user name must be configured to allow a proxy
    connection through the user proxy ("grant connect through
    proxyuser").</p><p>This is valuable for web applications where you typically set up a
    data source with a shared database user. If this shared user is a proxy
    user account and you supply the actual end user name then the proxy
    authentication feature will make any database access this user performs to
    be performed with the end users actual database user account.</p><p>To use this feature you must provide an implementation of the
    <code class="classname">ConnectionUsernameProvider</code> interface. This
    interface has a single method named <code class="classname">getUserName</code>
    that should return the user name for the current end user to be connected
    via the proxy user. It's up to the application developer to provide the
    appropriate implementation. One type of implementation would be to
    retrieve the current principal or user name from the
    <code class="classname">SecurityContextHolder</code> provided when you use Spring
    Security.</p><p>An example of what this implementation could look like is:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CurrentUsernameProvider <span class="hl-keyword">implements</span> ConnectionUsernameProvider {

    <span class="hl-keyword">public</span> String getUserName() {
        Object principal = 
            SecurityContextHolder.getContext().getAuthentication().getPrincipal(); 
        <span class="hl-keyword">if</span> (principal <span class="hl-keyword">instanceof</span> UserDetails) { 
            <span class="hl-keyword">return</span> ((UserDetails)principal).getUsername(); 
        } <span class="hl-keyword">else</span> { 
            <span class="hl-keyword">return</span> principal.toString(); 
        }
    }

}
</pre><p>See the Spring Security reference manual for more detail regarding
    the use of the <code class="classname">SecurityContextHolder</code>. </p><p>Connection proxy authentication is configured using the
    <code class="classname">username-connection-proxy</code> element. You also need to
    provide a reference to the user name provider that implements the
    <code class="classname">ConnectionUsernameProvider</code> interface mentioned
    above. </p><pre class="programlisting"><span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
       <span class="hl-attribute">xmlns:orcl</span>=<span class="hl-value">"http://www.springframework.org/schema/data/orcl"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/data/orcl
       http://www.springframework.org/schema/data/orcl/spring-data-orcl-1.0.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="bold"><strong>&lt;orcl:pooling-datasource id="dataSource" 
        properties-location="classpath:orcl.properties"&gt;
        &lt;orcl:username-connection-proxy connection-context-provider="usernameProvider"/&gt; <a name="datasource.4.4.prop"></a><img src="images/callouts/1.png" alt="1" border="0">
    &lt;/orcl:pooling-datasource&gt;

    &lt;bean id="usernameProvider" 
      class="org.springframework.data.jdbc.test.CurrentUsernameProvider"/&gt;</strong></span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#datasource.4.4.prop"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The connection proxy user name provider is specified
          here.</p></td></tr></table></div><p>To set up the database proxy user and to grant the user accounts to
    participate in the proxy authentication you could use this SQL:
    </p><pre class="programlisting">-- create the new proxy user account
create user proxyuser identified by proxypasswd;
grant create session to proxyuser;
-- grant existing user to connect  through the proxy
alter user spring grant connect through proxyuser;
</pre><p>In your connection properties file (orcl.properties) you
    would need to provide the proxy user credentials:</p><pre class="programlisting">url=jdbc:oracle:thin:@//localhost:1521/xe
username=proxyuser
password=proxypasswd</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>We are currently only supporting proxy authentication using user
      name with no password authentication for the user connecting through the
      proxy. Support for other types of proxy connections will be provided in
      future releases.</p></td></tr></table></div></div><div class="section" title="8.2&nbsp;Configuration of a Custom DataSource Connection Preparer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orcl.connection.2"></a>8.2&nbsp;Configuration of a Custom DataSource Connection Preparer</h2></div></div></div><p>There are times when you want to prepare the database connection in
    certain ways that aren't easily supported using standard connection
    properties. One example would be to set certain session properties in the
    SYS_CONTEXT like MODULE or CLIENT_IDENTIFIER. This chapter explains how to
    use a <code class="classname">ConnectionPreparer</code> to accomplish this. The
    example will set the CLIENT_IDENTIFIER.</p><p>We will need to add a <code class="classname">ConnectionInterceptor</code>
    using AOP and then configure the
    <code class="classname">ConnectionInterceptor</code> with a
    <code class="classname">ConnectionPreparer</code> implementation that performs the
    necessary preparations. Lets first look at our custom
    <code class="classname">ClientIdentifierConnectionPreparer</code> that implements
    the <code class="classname">ConnectionPreparer</code> interface. There is only a
    single method named <code class="classname">prepare</code> that needs to be
    implemented. The prepared connection is the return value which gives you
    an opportunity to wrap the connection with a proxy class if needed.</p><pre class="programlisting"><span class="hl-keyword">package</span> org.springframework.data.jdbc.samples;

<span class="hl-keyword">import</span> org.springframework.data.jdbc.support.ConnectionPreparer;

<span class="hl-keyword">import</span> java.sql.CallableStatement;
<span class="hl-keyword">import</span> java.sql.Connection;
<span class="hl-keyword">import</span> java.sql.SQLException;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ClientIdentifierConnectionPreparer <span class="hl-keyword">implements</span> ConnectionPreparer {

    String prepSql = <span class="hl-string">"{ call DBMS_SESSION.SET_IDENTIFIER('SPRING') }"</span>; <a name="conn.prep.sql"></a><img src="images/callouts/1.png" alt="1" border="0">

    <span class="hl-keyword">public</span> Connection prepare(Connection conn) <span class="hl-keyword">throws</span> SQLException {
        CallableStatement cs = conn.prepareCall(prepSql); <a name="conn.prep.call"></a><img src="images/callouts/2.png" alt="2" border="0">
        cs.execute();
        cs.close();
        <span class="hl-keyword">return</span> conn;
    }

}
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.sql"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>We define the SQL needed to set the CLIENT_IDENTIFIER
          attribute.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.call"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>We prepare a <code class="classname">CallableStatement</code> and
          execute it.</p></td></tr></table></div><p>This example sets the CLIENT_IDENTIFIER to a fixed value, but you
    could implement a ConnectionPreparer that would use the current users
    login id. That way you can capture user login information even if your
    data source is configured with a shared user name.</p><p>The following application context entries show how this could be
    configured for your data source.</p><pre class="programlisting">    <span class="hl-tag">&lt;orcl:pooling-datasource</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <a name="conn.prep.ac.ds"></a><img src="images/callouts/1.png" alt="1" border="0">
        connection-properties-prefix="conn"
        properties-location="classpath:orcl.properties"/&gt;

    <span class="hl-tag">&lt;aop:config&gt;</span> <a name="conn.prep.ac.aop"></a><img src="images/callouts/2.png" alt="2" border="0">
        <span class="hl-tag">&lt;aop:advisor</span> 
            <span class="hl-attribute">pointcut</span>=<span class="hl-value">"execution(java.sql.Connection javax.sql.DataSource.getConnection(..))"</span> 
            <span class="hl-attribute">advice-ref</span>=<span class="hl-value">"testInterceptor"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testInterceptor"</span> 
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.aop.ConnectionInterceptor"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"connectionPreparer"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"connectionPreparer"</span><span class="hl-tag">/&gt;</span> <a name="conn.prep.ac.int"></a><img src="images/callouts/3.png" alt="3" border="0">
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"connectionPreparer"</span> 
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.jdbc.samples.ClientIdentifierConnectionPreparer"</span><span class="hl-tag">/&gt;</span> <a name="conn.prep.ac.prep"></a><img src="images/callouts/4.png" alt="4" border="0">
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.ac.ds"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The regular dataSource definition, no extra configuration
          needed here.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.ac.aop"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The AOP configuration defining the pointcut as the
          <code class="classname">getConnection</code> method.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.ac.int"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The interceptor that has its
          <code class="classname">connectionPreparer</code> property set to our custom
          <code class="classname">ClientIdentifierConnectionPreparer</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#conn.prep.ac.ds"><img src="images/callouts/1.png" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>A bean defining the custom
          <code class="classname">ClientIdentifierConnectionPreparer</code>.</p></td></tr></table></div><p>Every time a new connection is obtained the connection preparer will
    set the CLIENT_IDENTIFIER. During database processing the value it was set
    to can be accessed using a call to a standard Oracle function -
    "<code class="code">sys_context('USERENV', 'CLIENT_IDENTIFIER')</code>"</p></div></div></div></div></body></html>