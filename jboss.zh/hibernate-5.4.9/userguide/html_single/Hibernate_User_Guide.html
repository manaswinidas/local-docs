<html lang="zh-Hans" ><head></head><body class="article toc2 toc-left" >﻿
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Vlad Mihalcea, Steve Ebersole, Andrea Boriero, Gunnar Morling, Gail Badner, Chris Cranford, Emmanuel Bernard, Sanne Grinovero, Brett Meyer, Hardy Ferentschik, Gavin King, Christian Bauer, Max Rydahl Andersen, Karel Maesen, Radim Vansa, Louis Jacomet">
<title>HibernateORM 5.4.9。最终用户指南</title>
<link rel="stylesheet" href="./css/hibernate.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.1/jstree.min.js"></script>

<script src="js/toc.js"></script>

<link rel="stylesheet" href="css/jstree-style.css">
<link rel="stylesheet" href="css/jstree-toc.css">


<div id="header">
<h1>HibernateORM 5.4.9。最终用户指南</h1>
<div class="details">
<span id="author" class="author">Vlad Mihalcea，Steve Ebersole，Andrea Boriero，Gunnar Morling，Gail Badner，Chris Cranford，Emmanuel Bernard，Sanne Grinovero，Brett Meyer，Hardy Ferentschik，Gavin King，Christian Bauer，Max Rydahl Andersen，Karel Maesen，Radim Vansa，Louis Jacomet</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#preface">前言</a>
<ul class="sectlevel2">
<li><a href="#_get_involved">参与其中</a></li>
</ul>
</li>
<li><a href="#_system_requirements">系统要求</a>
<ul class="sectlevel2">
<li><a href="#_getting_started_guide">入门指南</a></li>
</ul>
</li>
<li><a href="#architecture">1。建筑</a>
<ul class="sectlevel2">
<li><a href="#architecture-overview">1.1。总览</a></li>
</ul>
</li>
<li><a href="#domain-model">2。领域模型</a>
<ul class="sectlevel2">
<li><a href="#mapping-types">2.1。映射类型</a>
<ul class="sectlevel3">
<li><a href="#categorization-value">2.1.1。值类型</a></li>
<li><a href="#categorization-entity">2.1.2。实体类型</a></li>
</ul>
</li>
<li><a href="#naming">2.2。命名策略</a>
<ul class="sectlevel3">
<li><a href="#ImplicitNamingStrategy">2.2.1。隐式命名策略</a></li>
<li><a href="#PhysicalNamingStrategy">2.2.2。物理命名策略</a></li>
</ul>
</li>
<li><a href="#basic">2.3。基本类型</a>
<ul class="sectlevel3">
<li><a href="#basic-provided">2.3.1。Hibernate提供的BasicType</a></li>
<li><a href="#basic-annotation">2.3.2。的<code>@Basic</code>注解</a></li>
<li><a href="#basic-column-annotation">2.3.3。的<code>@Column</code>注解</a></li>
<li><a href="#basic-registry">2.3.4。BasicTypeRegistry</a></li>
<li><a href="#basic-type-annotation">2.3.5。显式BasicType</a></li>
<li><a href="#basic-custom-type">2.3.6。自定义BasicType</a></li>
<li><a href="#basic-enums">2.3.7。映射枚举</a></li>
<li><a href="#basic-lob">2.3.8。映射LOB</a></li>
<li><a href="#basic-nationalized">2.3.9。映射国家字符数据</a></li>
<li><a href="#basic-uuid">2.3.10。映射UUID值</a></li>
<li><a href="#_uuid_as_binary">2.3.11。UUID为二进制</a></li>
<li><a href="#_uuid_as_var_char">2.3.12。UUID为（var）char</a></li>
<li><a href="#_postgresql_specific_uuid">2.3.13。PostgreSQL特定的UUID</a></li>
<li><a href="#_uuid_as_identifier">2.3.14。UUID作为标识符</a></li>
<li><a href="#basic-datetime">2.3.15。映射日期/时间值</a></li>
<li><a href="#basic-jpa-convert">2.3.16。JPA 2.1 AttributeConverters</a></li>
<li><a href="#mapping-quoted-identifiers">2.3.17。SQL带引号的标识符</a></li>
<li><a href="#mapping-generated">2.3.18。生成的属性</a></li>
<li><a href="#mapping-column-read-and-write">2.3.19。列转换器：读取和写入表达式</a></li>
<li><a href="#mapping-column-formula">2.3.20。<code>@Formula</code></a></li>
</ul>
</li>
<li><a href="#embeddables">2.4。可嵌入类型</a>
<ul class="sectlevel3">
<li><a href="#_component_embedded">2.4.1。组件/嵌入式</a></li>
<li><a href="#embeddable-multiple">2.4.2。多种可嵌入类型</a></li>
<li><a href="#embeddable-override">2.4.3。覆盖可嵌入类型</a></li>
<li><a href="#embeddable-multiple-namingstrategy">2.4.4。嵌入式和隐式命名策略</a></li>
<li><a href="#embeddable-collections">2.4.5。可嵌入类型的集合</a></li>
<li><a href="#embeddable-mapkey">2.4.6。可嵌入类型作为Map键</a></li>
<li><a href="#embeddable-identifier">2.4.7。可嵌入类型作为标识符</a></li>
<li><a href="#embeddable-Target">2.4.8。 <code>@Target</code>映射</a></li>
<li><a href="#embeddable-Parent">2.4.9。 <code>@Parent</code>映射</a></li>
</ul>
</li>
<li><a href="#entity">2.5。实体类型</a>
<ul class="sectlevel3">
<li><a href="#entity-pojo">2.5.1。POJO模型</a></li>
<li><a href="#entity-pojo-final">2.5.2。偏好非决赛类</a></li>
<li><a href="#entity-pojo-constructor">2.5.3。实现无参数构造函数</a></li>
<li><a href="#entity-pojo-accessors">2.5.4。声明持久性属性的获取器和设置器</a></li>
<li><a href="#entity-pojo-identifier">2.5.5。提供标识符属性</a></li>
<li><a href="#entity-pojo-mapping">2.5.6。映射实体</a></li>
<li><a href="#mapping-model-pojo-equalshashcode">2.5.7。实施中<code>equals()</code>和<code>hashCode()</code></a></li>
<li><a href="#entity-sql-query-mapping">2.5.8。将实体映射到SQL查询</a></li>
<li><a href="#entity-proxy">2.5.9。定义自定义实体代理</a></li>
<li><a href="#entity-tuplizer">2.5.10。使用@Tuplizer批注的动态实体代理</a></li>
<li><a href="#entity-persister">2.5.11。定义自定义实体持久性</a></li>
<li><a href="#access">2.5.12。访问策略</a></li>
</ul>
</li>
<li><a href="#identifiers">2.6。身份标识</a>
<ul class="sectlevel3">
<li><a href="#identifiers-simple">2.6.1。简单标识符</a></li>
<li><a href="#identifiers-composite">2.6.2。复合标识符</a></li>
<li><a href="#identifiers-composite-aggregated">2.6.3。具有的复合标识符<code>@EmbeddedId</code></a></li>
<li><a href="#identifiers-composite-nonaggregated">2.6.4。具有的复合标识符<code>@IdClass</code></a></li>
<li><a href="#identifiers-composite-associations">2.6.5。具有关联的复合标识符</a></li>
<li><a href="#identifiers-composite-generated">2.6.6。具有生成属性的复合标识符</a></li>
<li><a href="#identifiers-generators">2.6.7。生成的标识符值</a></li>
<li><a href="#identifiers-generators-auto">2.6.8。解释自动</a></li>
<li><a href="#identifiers-generators-sequence">2.6.9。使用序列</a></li>
<li><a href="#identifiers-generators-identity">2.6.10。使用IDENTITY列</a></li>
<li><a href="#identifiers-generators-table">2.6.11。使用表标识符生成器</a></li>
<li><a href="#identifiers-generators-uuid">2.6.12。使用UUID生成</a></li>
<li><a href="#identifiers-generators-optimizer">2.6.13。优化器</a></li>
<li><a href="#identifiers-generators-GenericGenerator">2.6.14。使用<code>@GenericGenerator</code></a></li>
<li><a href="#identifiers-derived">2.6.15。派生标识符</a></li>
<li><a href="#identifiers-rowid">2.6.16。@RowId</a></li>
</ul>
</li>
<li><a href="#associations">2.7。社团协会</a>
<ul class="sectlevel3">
<li><a href="#associations-many-to-one">2.7.1。<code>@ManyToOne</code></a></li>
<li><a href="#associations-one-to-many">2.7.2。<code>@OneToMany</code></a></li>
<li><a href="#associations-one-to-one">2.7.3。<code>@OneToOne</code></a></li>
<li><a href="#associations-many-to-many">2.7.4。<code>@ManyToMany</code></a></li>
<li><a href="#associations-not-found">2.7.5。 <code>@NotFound</code>关联映射</a></li>
<li><a href="#associations-any">2.7.6。 <code>@Any</code>映射</a></li>
<li><a href="#associations-JoinFormula">2.7.7。 <code>@JoinFormula</code>映射</a></li>
<li><a href="#associations-JoinColumnOrFormula">2.7.8。 <code>@JoinColumnOrFormula</code>映射</a></li>
</ul>
</li>
<li><a href="#collections">2.8。馆藏</a>
<ul class="sectlevel3">
<li><a href="#collections-synopsis">2.8.1。集合作为值类型</a></li>
<li><a href="#collections-value">2.8.2。值类型的集合</a></li>
<li><a href="#collections-entity">2.8.3。实体集合</a></li>
<li><a href="#collections-bag">2.8.4。包袋</a></li>
<li><a href="#collections-list">2.8.5。有序列表</a></li>
<li><a href="#collections-set">2.8.6。套装</a></li>
<li><a href="#collections-sorted-set">2.8.7。排序集</a></li>
<li><a href="#collections-map">2.8.8。地图</a></li>
<li><a href="#collections-array">2.8.9。数组</a></li>
<li><a href="#collections-array-binary">2.8.10。数组为二进制</a></li>
<li><a href="#collections-as-basic">2.8.11。集合作为基本值类型</a></li>
<li><a href="#collections-custom">2.8.12。自定义集合类型</a></li>
</ul>
</li>
<li><a href="#naturalid">2.9。自然身份证</a>
<ul class="sectlevel3">
<li><a href="#naturalid-mapping">2.9.1。自然ID映射</a></li>
<li><a href="#naturalid-api">2.9.2。自然ID API</a></li>
<li><a href="#naturalid-mutability-caching">2.9.3。自然ID-可变性和缓存</a></li>
</ul>
</li>
<li><a href="#dynamic-model">2.10。动态模型</a>
<ul class="sectlevel3">
<li><a href="#mapping-model-dynamic">2.10.1。动态映射模型</a></li>
</ul>
</li>
<li><a href="#entity-inheritance">2.11。遗产</a>
<ul class="sectlevel3">
<li><a href="#entity-inheritance-mapped-superclass">2.11.1。映射超类</a></li>
<li><a href="#entity-inheritance-single-table">2.11.2。单桌</a></li>
<li><a href="#entity-inheritance-joined-table">2.11.3。联接表</a></li>
<li><a href="#entity-inheritance-table-per-class">2.11.4。每班桌</a></li>
<li><a href="#entity-inheritance-polymorphism">2.11.5。隐式和显式多态</a></li>
</ul>
</li>
<li><a href="#entity-immutability">2.12。不变性</a>
<ul class="sectlevel3">
<li><a href="#_entity_immutability">2.12.1。实体不变性</a></li>
<li><a href="#_collection_immutability">2.12.2。集合不变性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#bootstrap">3。引导程序</a>
<ul class="sectlevel2">
<li><a href="#bootstrap-native">3.1。本机引导</a>
<ul class="sectlevel3">
<li><a href="#bootstrap-native-registry">3.1.1。建立服务注册表</a></li>
<li><a href="#bootstrap-event-listener-registration">3.1.2。事件监听器注册</a></li>
<li><a href="#bootstrap-native-metadata">3.1.3。建立元数据</a></li>
<li><a href="#bootstrap-native-SessionFactory">3.1.4。建立SessionFactory</a></li>
</ul>
</li>
<li><a href="#bootstrap-jpa">3.2。JPA引导</a>
<ul class="sectlevel3">
<li><a href="#bootstrap-jpa-compliant">3.2.1。符合JPA的自举</a></li>
<li><a href="#bootstrap-jpa-xml-files">3.2.2。外部化XML映射文件</a></li>
<li><a href="#bootstrap-jpa-metadata">3.2.3。配置<code>SessionFactory</code><code>Metadata</code>通过JPA引导程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#schema-generation">4。模式生成</a>
<ul class="sectlevel2">
<li><a href="#schema-generation-script-files">4.1。导入脚本文件</a></li>
<li><a href="#schema-generation-database-objects">4.2。数据库对象</a></li>
<li><a href="#schema-generation-database-checks">4.3。数据库级检查</a></li>
<li><a href="#schema-generation-column-default-value">4.4。数据库列的默认值</a></li>
<li><a href="#schema-generation-columns-unique-constraint">4.5。列唯一约束</a></li>
<li><a href="#schema-generation-columns-index">4.6。列索引</a></li>
</ul>
</li>
<li><a href="#pc">5，持久性上下文</a>
<ul class="sectlevel2">
<li><a href="#pc-unwrap">5.1。从JPA访问Hibernate API</a></li>
<li><a href="#BytecodeEnhancement">5.2。字节码增强</a>
<ul class="sectlevel3">
<li><a href="#BytecodeEnhancement-capabilities">5.2.1。能力</a></li>
<li><a href="#BytecodeEnhancement-enhancement">5.2.2。执行增强</a></li>
</ul>
</li>
<li><a href="#pc-persist">5.3。使实体持久化</a></li>
<li><a href="#pc-remove">5.4。删除（删除）实体</a></li>
<li><a href="#pc-get-reference">5.5。获取实体引用而不初始化其数据</a></li>
<li><a href="#pc-find">5.6。获取其数据已初始化的实体</a></li>
<li><a href="#pc-by-multiple-ids">5.7。通过其标识符获取多个实体</a></li>
<li><a href="#pc-find-natural-id">5.8。通过natural-id获取实体</a></li>
<li><a href="#pc-filtering">5.9。过滤实体和关联</a>
<ul class="sectlevel3">
<li><a href="#pc-where">5.9.1。<code>@Where</code></a></li>
<li><a href="#pc-where-join-table">5.9.2。<code>@WhereJoinTable</code></a></li>
<li><a href="#pc-filter">5.9.3。<code>@Filter</code></a></li>
<li><a href="#pc-filter-sql-fragment-alias">5.9.4。 <code>@Filter</code>与<code>@SqlFragmentAlias</code></a></li>
<li><a href="#pc-filter-join-table">5.9.5。<code>@FilterJoinTable</code></a></li>
</ul>
</li>
<li><a href="#pc-managed-state">5.10。修改管理/持久状态</a>
<ul class="sectlevel3">
<li><a href="#pc-managed-state-dynamic-update">5.10.1。动态更新</a></li>
</ul>
</li>
<li><a href="#pc-refresh">5.11。刷新实体状态</a>
<ul class="sectlevel3">
<li><a href="#pc-refresh-gotchas">5.11.1。刷新陷阱</a></li>
</ul>
</li>
<li><a href="#pc-detach">5.12。处理分离的数据</a>
<ul class="sectlevel3">
<li><a href="#pc-detach-reattach">5.12.1。重新附加分离的数据</a></li>
<li><a href="#pc-merge">5.12.2。合并分离的数据</a></li>
</ul>
</li>
<li><a href="#pc-contains">5.13。检查持久状态</a></li>
<li><a href="#_evicting_entities">5.14。驱逐实体</a></li>
<li><a href="#pc-cascade">5.15。级联实体状态转换</a>
<ul class="sectlevel3">
<li><a href="#pc-cascade-persist">5.15.1。<code>CascadeType.PERSIST</code></a></li>
<li><a href="#pc-cascade-merge">5.15.2。<code>CascadeType.MERGE</code></a></li>
<li><a href="#pc-cascade-remove">5.15.3。<code>CascadeType.REMOVE</code></a></li>
<li><a href="#pc-cascade-detach">5.15.4。<code>CascadeType.DETACH</code></a></li>
<li><a href="#pc-cascade-lock">5.15.5。<code>CascadeType.LOCK</code></a></li>
<li><a href="#pc-cascade-refresh">5.15.6。<code>CascadeType.REFRESH</code></a></li>
<li><a href="#pc-cascade-replicate">5.15.7。<code>CascadeType.REPLICATE</code></a></li>
<li><a href="#pc-cascade-on-delete">5.15.8。 <code>@OnDelete</code>级联</a></li>
</ul>
</li>
<li><a href="#pc-exception-handling">5.16。异常处理</a></li>
</ul>
</li>
<li><a href="#flushing">6。冲洗</a>
<ul class="sectlevel2">
<li><a href="#flushing-auto">6.1。 <code>AUTO</code>齐平</a>
<ul class="sectlevel3">
<li><a href="#_code_auto_code_flush_on_commit">6.1.1。 <code>AUTO</code>提交时刷新</a></li>
<li><a href="#_code_auto_code_flush_on_jpql_hql_query">6.1.2。 <code>AUTO</code>刷新JPQL / HQL查询</a></li>
<li><a href="#_code_auto_code_flush_on_native_sql_query">6.1.3。 <code>AUTO</code>在本机SQL查询上刷新</a></li>
</ul>
</li>
<li><a href="#flushing-commit">6.2。 <code>COMMIT</code>齐平</a></li>
<li><a href="#flushing-always">6.3。 <code>ALWAYS</code>齐平</a></li>
<li><a href="#flushing-manual">6.4。 <code>MANUAL</code>齐平</a></li>
<li><a href="#flushing-order">6.5。冲洗操作顺序</a></li>
</ul>
</li>
<li><a href="#database">7。数据库访问</a>
<ul class="sectlevel2">
<li><a href="#database-connectionprovider">7.1。连接提供者</a></li>
<li><a href="#database-connectionprovider-datasource">7.2。使用数据源</a></li>
<li><a href="#database-connectionprovider-driver">7.3。驱动程式设定</a></li>
<li><a href="#database-connectionprovider-c3p0">7.4。使用c3p0</a></li>
<li><a href="#database-connectionprovider-proxool">7.5。使用Proxool</a>
<ul class="sectlevel3">
<li><a href="#database-connectionprovider-proxool-existing">7.5.1。使用现有的Proxool池</a></li>
<li><a href="#database-connectionprovider-proxool-jaxp">7.5.2。通过XML配置Proxool</a></li>
<li><a href="#database-connectionprovider-proxool-properties">7.5.3。通过属性配置Proxool</a></li>
</ul>
</li>
<li><a href="#database-connectionprovider-hikari">7.6。使用HikariCP</a></li>
<li><a href="#database-connectionprovider-vibur">7.7。使用Vibur DBCP</a></li>
<li><a href="#database-connectionprovider-agroal">7.8。使用农业</a></li>
<li><a href="#database-connectionprovider-drivermanager">7.9。使用Hibernate的内置（且不受支持）池</a></li>
<li><a href="#database-connectionprovider-provided">7.10。用户提供的连接</a></li>
<li><a href="#database-connectionprovider-isolation">7.11。ConnectionProvider支持事务隔离设置</a></li>
<li><a href="#database-connection-handling">7.12。连接处理</a>
<ul class="sectlevel3">
<li><a href="#_transaction_type_and_connection_handling">7.12.1。事务类型和连接处理</a></li>
<li><a href="#_user_provided_connections">7.12.2。用户提供的连接</a></li>
</ul>
</li>
<li><a href="#database-dialect">7.13。数据库方言</a></li>
</ul>
</li>
<li><a href="#transactions">8。交易和并发控制</a>
<ul class="sectlevel2">
<li><a href="#transactions-physical">8.1。实物交易</a></li>
<li><a href="#transactions-physical-jtaplatform">8.2。JTA配置</a></li>
<li><a href="#transactions-api">8.3。Hibernate事务API</a></li>
<li><a href="#architecture-current-session">8.4。上下文会话</a></li>
<li><a href="#_transactional_patterns_and_anti_patterns">8.5。交易模式（和反模式）</a>
<ul class="sectlevel3">
<li><a href="#session-per-operation">8.5.1。每次操作会话反模式</a></li>
<li><a href="#session-per-request">8.5.2。每次请求会话模式</a></li>
<li><a href="#long-conversations">8.5.3。对话（应用程序级交易）</a></li>
<li><a href="#session-per-application">8.5.4。每次应用会话反模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jndi">9。日本国家发展研究院</a></li>
<li><a href="#locking">10。锁定</a>
<ul class="sectlevel2">
<li><a href="#locking-optimistic">10.1。乐观的</a>
<ul class="sectlevel3">
<li><a href="#locking-optimistic-mapping">10.1.1。映射乐观锁定</a></li>
</ul>
</li>
<li><a href="#locking-pessimistic">10.2。悲观</a></li>
<li><a href="#locking-LockMode">10.3。 <code>LockMode</code>和<code>LockModeType</code></a></li>
<li><a href="#locking-jpa-query-hints">10.4。JPA锁定查询提示</a></li>
<li><a href="#locking-buildLockRequest">10.5。的<code>buildLockRequest</code> API</a></li>
<li><a href="#locking-follow-on">10.6。跟随锁定</a></li>
</ul>
</li>
<li><a href="#fetching">11。正在取得</a>
<ul class="sectlevel2">
<li><a href="#fetching-basics">11.1。基础</a></li>
<li><a href="#fetching-direct-vs-query">11.2。直接获取与实体查询</a></li>
<li><a href="#fetching-strategies">11.3。应用提取策略</a></li>
<li><a href="#fetching-strategies-no-fetching">11.4。不取</a></li>
<li><a href="#fetching-strategies-dynamic-fetching">11.5。通过查询动态获取</a></li>
<li><a href="#fetching-strategies-dynamic-fetching-entity-graph">11.6。通过JPA实体图动态获取</a>
<ul class="sectlevel3">
<li><a href="#fetching-strategies-dynamic-fetching-entity-subgraph">11.6.1。JPA（关键）子图</a></li>
<li><a href="#fetching-strategies-dynamic-fetching-entity-subgraph-subtype">11.6.2。JPA SubGraph子类型</a></li>
<li><a href="#fetching-strategies-dynamic-fetching-entity-graph-parsing">11.6.3。通过文本表示创建和应用JPA图</a></li>
<li><a href="#fetching-strategies-dynamic-fetching-entity-graph-merging">11.6.4。将多个JPA实体图组合成一个</a></li>
</ul>
</li>
<li><a href="#fetching-strategies-dynamic-fetching-profile">11.7。通过Hibernate配置文件动态获取</a></li>
<li><a href="#fetching-batch">11.8。批量提取</a></li>
<li><a href="#fetching-fetch-annotation">11.9。的<code>@Fetch</code>注释映射</a></li>
<li><a href="#fetching-fetchmode-select">11.10。<code>FetchMode.SELECT</code></a></li>
<li><a href="#fetching-fetchmode-subselect">11.11。<code>FetchMode.SUBSELECT</code></a></li>
<li><a href="#fetching-fetchmode-join">11.12。<code>FetchMode.JOIN</code></a></li>
<li><a href="#fetching-LazyCollection">11.13。<code>@LazyCollection</code></a></li>
</ul>
</li>
<li><a href="#batch">12批处理</a>
<ul class="sectlevel2">
<li><a href="#batch-jdbcbatch">12.1。JDBC批处理</a></li>
<li><a href="#batch-session-batch">12.2。会话批处理</a>
<ul class="sectlevel3">
<li><a href="#batch-session-batch-insert">12.2.1。批量插入</a></li>
<li><a href="#batch-session-scroll">12.2.2。会话滚动</a></li>
<li><a href="#_statelesssession">12.2.3。无状态会话</a></li>
</ul>
</li>
<li><a href="#batch-bulk-hql">12.3。DML的Hibernate查询语言</a>
<ul class="sectlevel3">
<li><a href="#batch-bulk-hql-update-delete">12.3.1。HQL / JPQL用于更新和删除</a></li>
<li><a href="#_hql_syntax_for_insert">12.3.2。INSERT的HQL语法</a></li>
<li><a href="#batch-bulk-hql-strategies">12.3.3。大量ID策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#caching">13快取</a>
<ul class="sectlevel2">
<li><a href="#caching-config">13.1。配置二级缓存</a>
<ul class="sectlevel3">
<li><a href="#caching-config-provider">13.1.1。RegionFactory</a></li>
<li><a href="#caching-config-properties">13.1.2。缓存配置属性</a></li>
</ul>
</li>
<li><a href="#caching-mappings">13.2。配置二级缓存映射</a></li>
<li><a href="#caching-mappings-inheritance">13.3。实体继承和二级缓存映射</a></li>
<li><a href="#caching-entity">13.4。实体缓存</a></li>
<li><a href="#caching-collection">13.5。集合缓存</a></li>
<li><a href="#caching-query">13.6。查询缓存</a>
<ul class="sectlevel3">
<li><a href="#caching-query-region">13.6.1。查询缓存区域</a></li>
</ul>
</li>
<li><a href="#caching-management">13.7。管理缓存的数据</a>
<ul class="sectlevel3">
<li><a href="#caching-management-evict">13.7.1。逐出缓存项</a></li>
</ul>
</li>
<li><a href="#caching-statistics">13.8。缓存统计</a></li>
<li><a href="#caching-provider-jcache">13.9。缓存</a>
<ul class="sectlevel3">
<li><a href="#caching-provider-jcache-region-factory">13.9.1。RegionFactory</a></li>
<li><a href="#caching-provider-jcache-cache-manager">13.9.2。缓存<code>CacheManager</code></a></li>
<li><a href="#caching-provider-jcache-missing-cache-strategy">13.9.3。JCache缺少缓存策略</a></li>
</ul>
</li>
<li><a href="#caching-provider-ehcache">13.10。高速缓存</a>
<ul class="sectlevel3">
<li><a href="#caching-provider-ehcache-region-factory">13.10.1。RegionFactory</a></li>
<li><a href="#caching-provider-ehcache-missing-cache-strategy">13.10.2。Ehcache缺少缓存策略</a></li>
</ul>
</li>
<li><a href="#caching-provider-infinispan">13.11。Infinispan</a></li>
</ul>
</li>
<li><a href="#events">14。拦截器和事件</a>
<ul class="sectlevel2">
<li><a href="#events-interceptors">14.1。拦截器</a></li>
<li><a href="#events-events">14.2。本机事件系统</a></li>
<li><a href="#events-mixing-events-and-interceptors">14.3。混合事件和拦截器</a></li>
<li><a href="#events-declarative-security">14.4。Hibernate声明式安全</a></li>
<li><a href="#events-jpa-callbacks">14.5。JPA回调</a></li>
<li><a href="#events-default-listener">14.6。默认实体监听器</a>
<ul class="sectlevel3">
<li><a href="#events-exclude-default-listener">14.6.1。排除默认实体侦听器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hql">15HQL和JPQL</a>
<ul class="sectlevel2">
<li><a href="#hql-examples-domain-model">15.1。域模型示例</a></li>
<li><a href="#query-api">15.2。查询API</a>
<ul class="sectlevel3">
<li><a href="#jpql-api">15.2.1。JPA查询API</a></li>
<li><a href="#hql-api">15.2.2。Hibernate查询API</a></li>
<li><a href="#hql-api-scroll">15.2.3。查询滚动</a></li>
</ul>
</li>
<li><a href="#hql-case-sensitivity">15.3。区分大小写</a></li>
<li><a href="#hql-statement-types">15.4。报表类型</a></li>
<li><a href="#hql-select">15.5。选择语句</a></li>
<li><a href="#hql-update">15.6。更新语句</a></li>
<li><a href="#hql-delete">15.7。删除陈述</a></li>
<li><a href="#hql-insert">15.8。插入语句</a></li>
<li><a href="#hql-from-clause">15.9。的<code>FROM</code>条款</a></li>
<li><a href="#hql-identification-variables">15.10。识别变量</a></li>
<li><a href="#hql-root-reference">15.11。根实体引用</a></li>
<li><a href="#hql-explicit-join">15.12。显式联接</a></li>
<li><a href="#hql-implicit-join">15.13。隐式联接（路径表达式）</a></li>
<li><a href="#hql-distinct">15.14。不同</a>
<ul class="sectlevel3">
<li><a href="#hql-distinct-projection-query">15.14.1。将DISTINCT与SQL投影配合使用</a></li>
<li><a href="#hql-distinct-entity-query">15.14.2。结合使用DISTINCT和实体查询</a></li>
</ul>
</li>
<li><a href="#hql-collection-valued-associations">15.15。集合成员参考</a></li>
<li><a href="#hql-collection-qualification">15.16。特殊情况-限定路径表达式</a></li>
<li><a href="#hql-polymorphism">15.17。多态性</a></li>
<li><a href="#hql-expressions">15.18。表达方式</a></li>
<li><a href="#hql-identification-variable">15.19。识别变量</a></li>
<li><a href="#hql-path-expressions">15.20。路径表达式</a></li>
<li><a href="#hql-literals">15.21。文字</a></li>
<li><a href="#hql-numeric-arithmetic">15.22。算术</a></li>
<li><a href="#hql-concatenation">15.23。串联（操作）</a></li>
<li><a href="#hql-aggregate-functions">15.24。汇总功能</a></li>
<li><a href="#hql-exp-functions">15.25。标量函数</a></li>
<li><a href="#jpql-standardized-functions">15.26。JPQL标准化功能</a></li>
<li><a href="#hql-functions">15.27。HQL功能</a></li>
<li><a href="#hql-user-defined-functions">15.28。用户定义的功能</a>
<ul class="sectlevel3">
<li><a href="#hql-user-defined-functions-where-clause">15.28.1。WHERE子句中引用的用户定义函数</a></li>
<li><a href="#hql-user-defined-functions-select-clause">15.28.2。SELECT子句中引用的用户定义函数</a></li>
</ul>
</li>
<li><a href="#hql-collection-expressions">15.29。与集合相关的表达式</a></li>
<li><a href="#hql-entity-type-exp">15.30。实体类型</a></li>
<li><a href="#hql-case-expressions">15.31。案例表达</a></li>
<li><a href="#hql-simple-case-expressions">15.32。简单的CASE表达式</a></li>
<li><a href="#hql-searched-case-expressions">15.33。搜索的CASE表达式</a></li>
<li><a href="#hql-case-arithmetic-expressions">15.34。具有算术运算的CASE表达式</a></li>
<li><a href="#hql-nullif">15.35。NULLIF表达式</a></li>
<li><a href="#_coalesce_expressions">15.36。COALESCE表达式</a></li>
<li><a href="#hql-select-clause">15.37。的<code>SELECT</code>条款</a></li>
<li><a href="#hql-conditional-expressions">15.38。谓词</a></li>
<li><a href="#hql-relational-comparisons">15.39。关系比较</a></li>
<li><a href="#hql-null-predicate">15.40。无效谓词</a></li>
<li><a href="#hql-like-predicate">15.41。像谓词</a></li>
<li><a href="#hql-between-predicate">15.42。谓词之间</a></li>
<li><a href="#hql-in-predicate">15.43。谓语</a></li>
<li><a href="#hql-exists-predicate">15.44。存在谓词</a></li>
<li><a href="#hql-empty-collection-predicate">15.45。空集合谓词</a></li>
<li><a href="#hql-member-of-collection-predicate">15.46。集合成员谓词</a></li>
<li><a href="#hql-not-predicate">15.47。非谓词运算符</a></li>
<li><a href="#hql-and-predicate">15.48。AND谓词运算符</a></li>
<li><a href="#hql-or-predicate">15.49。或谓词运算符</a></li>
<li><a href="#hql-where-clause">15.50。的<code>WHERE</code>条款</a></li>
<li><a href="#hql-group-by">15.51。通过...分组</a></li>
<li><a href="#hql-order-by">15.52。排序依据</a></li>
<li><a href="#hql-read-only-entities">15.53。只读实体</a></li>
<li><a href="#hql-query-plan-cache">15.54。实体查询计划缓存</a></li>
</ul>
</li>
<li><a href="#criteria">16。标准</a>
<ul class="sectlevel2">
<li><a href="#criteria-typedquery">16.1。键入条件查询</a></li>
<li><a href="#criteria-typedquery-entity">16.2。选择一个实体</a></li>
<li><a href="#criteria-typedquery-expression">16.3。选择一个表达式</a></li>
<li><a href="#criteria-typedquery-multiselect">16.4。选择多个值</a></li>
<li><a href="#criteria-typedquery-wrapper">16.5。选择包装纸</a></li>
<li><a href="#criteria-tuple">16.6。元组条件查询</a></li>
<li><a href="#criteria-from">16.7。FROM子句</a></li>
<li><a href="#criteria-from-root">16.8。根源</a></li>
<li><a href="#criteria-from-join">16.9。加入</a></li>
<li><a href="#criteria-from-fetch">16.10。抓取</a></li>
<li><a href="#criteria-path">16.11。路径表达式</a></li>
<li><a href="#criteria-param">16.12。使用参数</a></li>
<li><a href="#criteria-group-by">16.13。使用分组依据</a></li>
</ul>
</li>
<li><a href="#sql">17。本机SQL查询</a>
<ul class="sectlevel2">
<li><a href="#sql-jpa-query">17.1。使用JPA创建本机查询</a></li>
<li><a href="#sql-scalar-query">17.2。标量查询</a></li>
<li><a href="#sql-entity-query">17.3。实体查询</a></li>
<li><a href="#sql-entity-associations-query">17.4。处理关联和集合</a></li>
<li><a href="#sql-multi-entity-query">17.5。返回多个实体</a></li>
<li><a href="#sql-alias-references">17.6。别名和属性参考</a></li>
<li><a href="#sql-dto-query">17.7。返回DTO（数据传输对象）</a></li>
<li><a href="#sql-inheritance-query">17.8。处理继承</a></li>
<li><a href="#sql-query-parameters">17.9。参量</a></li>
<li><a href="#sql-named-queries">17.10。命名SQL查询</a>
<ul class="sectlevel3">
<li><a href="#sql-scalar-named-queries">17.10.1。选择标量值的命名SQL查询</a></li>
<li><a href="#sql-entity-named-queries">17.10.2。命名SQL查询选择实体</a></li>
</ul>
</li>
<li><a href="#sql-global-catalog-schema">17.11。在本机SQL查询中解析全局编录和架构</a></li>
<li><a href="#sql-sp">17.12。使用存储过程进行查询</a></li>
<li><a href="#sql-sp-named-query">17.13。使用命名查询来调用存储过程</a></li>
<li><a href="#sql-crud">17.14。用于CRUD的自定义SQL（创建，读取，更新和删除）</a></li>
</ul>
</li>
<li><a href="#spatial">18岁空间空间</a>
<ul class="sectlevel2">
<li><a href="#spatial-overview">18.1。总览</a></li>
<li><a href="#spatial-configuration">18.2。组态</a>
<ul class="sectlevel3">
<li><a href="#spatial-configuration-dependency">18.2.1。相依性</a></li>
<li><a href="#spatial-configuration-dialect">18.2.2。方言</a></li>
</ul>
</li>
<li><a href="#spatial-types">18.3。种类</a></li>
</ul>
</li>
<li><a href="#multitenacy">19多租户</a>
<ul class="sectlevel2">
<li><a href="#multitenacy-intro">19.1。什么是多租户？</a></li>
<li><a href="#multitenacy-approaches">19.2。多租户数据方法</a>
<ul class="sectlevel3">
<li><a href="#multitenacy-separate-database">19.2.1。单独的数据库</a></li>
<li><a href="#multitenacy-separate-schema">19.2.2。单独的架构</a></li>
</ul>
</li>
<li><a href="#multitenacy-discriminator">19.3。分区（区分）数据</a></li>
<li><a href="#multitenacy-hibernate">19.4。Hibernate中的多租户</a>
<ul class="sectlevel3">
<li><a href="#multitenacy-hibernate-MultiTenantConnectionProvider">19.4.1。MultiTenantConnectionProvider</a></li>
<li><a href="#multitenacy-hibernate-CurrentTenantIdentifierResolver">19.4.2。CurrentTenantIdentifierResolver</a></li>
<li><a href="#multitenacy-hibernate-caching">19.4.3。快取</a></li>
<li><a href="#multitenacy-hibernate-session-configuration">19.4.4。多租户Hibernate会话配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#osgi">20OSGi</a>
<ul class="sectlevel2">
<li><a href="#_osgi_specification_and_environment">20.1。OSGi规范和环境</a></li>
<li><a href="#_hibernate_osgi">20.2。冬眠</a></li>
<li><a href="#_features_xml">20.3。 features.xml</a></li>
<li><a href="#_quickstarts_demos">20.4。快速入门/演示</a></li>
<li><a href="#osgi-managed-jpa">20.5。容器管理的JPA</a></li>
<li><a href="#_enterprise_osgi_jpa_container">20.6。企业OSGi JPA容器</a></li>
<li><a href="#_persistence_xml">20.7。 persistence.xml</a></li>
<li><a href="#_datasource">20.8。数据源</a></li>
<li><a href="#_bundle_package_imports">20.9。捆绑包导入</a></li>
<li><a href="#_obtaining_an_entitymanger">20.10。获取实体</a></li>
<li><a href="#osgi-unmanaged-jpa">20.11。非托管JPA</a></li>
<li><a href="#_persistence_xml_2">20.12。 persistence.xml</a></li>
<li><a href="#_bundle_package_imports_2">20.13。捆绑包导入</a></li>
<li><a href="#_obtaining_an_entitymangerfactory">20.14。获取EntityMangerFactory</a></li>
<li><a href="#osgi-unmanaged-native">20.15。非托管本地</a></li>
<li><a href="#_bundle_package_imports_3">20.16。捆绑包导入</a></li>
<li><a href="#_obtaining_a_sessionfactory">20.17。获取SessionFactory</a></li>
<li><a href="#_optional_modules">20.18。可选模块</a></li>
<li><a href="#_extension_points">20.19。延伸点</a></li>
<li><a href="#_caveats">20.20。注意事项</a></li>
</ul>
</li>
<li><a href="#envers">21Envers</a>
<ul class="sectlevel2">
<li><a href="#envers-basics">21.1。基本</a></li>
<li><a href="#envers-configuration">21.2。配置属性</a></li>
<li><a href="#envers-additional-mappings">21.3。其他映射注释</a></li>
<li><a href="#envers-audit-strategy">21.4。选择审核策略</a>
<ul class="sectlevel3">
<li><a href="#envers-audit-ValidityAuditStrategy">21.4.1。配置<code>ValidityAuditStrategy</code></a></li>
</ul>
</li>
<li><a href="#envers-revisionlog">21.5。修订日志</a></li>
<li><a href="#envers-tracking-modified-entities-revchanges">21.6。修订期间修改的跟踪实体名称</a></li>
<li><a href="#envers-tracking-properties-changes">21.7。在属性级别跟踪实体更改</a></li>
<li><a href="#envers-tracking-properties-changes-strategy">21.8。选择策略以跟踪属性级别更改</a></li>
<li><a href="#envers-queries">21.9。查询</a></li>
<li><a href="#entities-at-revision">21.10。在给定的版本中查询类的实体</a></li>
<li><a href="#entities-filtering">21.11。使用过滤条件查询实体</a></li>
<li><a href="#revisions-of-entity">21.12。查询修订，给定类的实体已更改</a></li>
<li><a href="#envers-tracking-properties-changes-queries">21.13。查询修改给定属性的实体修订</a></li>
<li><a href="#envers-tracking-obtain-properties-changed-queries">21.14。查询实体的修订版，包括已修改的属性名称</a></li>
<li><a href="#envers-tracking-modified-entities-queries">21.15。查询在给定版本中修改的实体类型</a></li>
<li><a href="#envers-querying-entity-relation-joins">21.16。使用实体关系联接查询实体</a></li>
<li><a href="#envers-querying-revision-entities">21.17。在不加载实体的情况下查询修订信息</a></li>
<li><a href="#envers-conditional-auditing">21.18。有条件的审计</a></li>
<li><a href="#envers-schema">21.19。了解Envers模式</a></li>
<li><a href="#envers-generateschema">21.20。使用Hibernate hbm2ddl工具生成Envers模式</a></li>
<li><a href="#envers-mappingexceptions">21.21。映射异常</a>
<ul class="sectlevel3">
<li><a href="#_what_isn_t_and_will_not_be_supported">21.21.1。什么是不支持</a></li>
<li><a href="#_what_isn_t_and_em_will_em_be_supported">21.21.2。什么不是， <em>将</em>支持</a></li>
</ul>
</li>
<li><a href="#_code_onetomany_code_with_code_joincolumn_code">21.22。 <code>@OneToMany</code>与<code>@JoinColumn</code></a></li>
<li><a href="#envers-partitioning">21.23。高级：审核表分区</a></li>
<li><a href="#envers-partitioning-benefits">21.24。审核表分区的好处</a></li>
<li><a href="#envers-partitioning-columns">21.25。适用于审计表分区的列</a></li>
<li><a href="#envers-partitioning-example">21.26。审计表分区示例</a></li>
<li><a href="#envers-partitioning-example-column">21.27。确定合适的分区列</a></li>
<li><a href="#envers-partitioning-example-scheme">21.28。确定合适的分区方案</a></li>
<li><a href="#envers-links">21.29。启用链接</a></li>
</ul>
</li>
<li><a href="#portability">22数据库可移植性注意事项</a>
<ul class="sectlevel2">
<li><a href="#portability-basics">22.1可移植性基础</a></li>
<li><a href="#portability-dialect">22.2。方言</a></li>
<li><a href="#portability-dialectresolver">22.3。方言解析</a></li>
<li><a href="#portability-idgen">22.4。标识符生成</a></li>
<li><a href="#portability-functions">22.5。数据库功能</a></li>
<li><a href="#portability-types">22.6。类型映射</a>
<ul class="sectlevel3">
<li><a href="#portability-types-lobs">22.6.1。BLOB / CLOB映射</a></li>
<li><a href="#portability-types-bool">22.6.2。布尔映射</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#statistics">23。统计</a>
<ul class="sectlevel2">
<li><a href="#statistics-methods">23.1。 org.hibernate.stat。统计方法</a>
<ul class="sectlevel3">
<li><a href="#statistics-general">23.1.1。一般统计方法</a></li>
<li><a href="#statistics-aggregates">23.1.2。汇总统计方法</a></li>
<li><a href="#statistics-session-factory">23.1.3。SessionFactory统计方法</a></li>
<li><a href="#statistics-session">23.1.4。会话统计方法</a></li>
<li><a href="#statistics-jdbc">23.1.5。JDBC统计方法</a></li>
<li><a href="#statistics-transaction">23.1.6。交易统计方法</a></li>
<li><a href="#statistics-concurrency-control">23.1.7。并发控制统计方法</a></li>
<li><a href="#statistics-entity">23.1.8。实体统计方法</a></li>
<li><a href="#statistics-collection">23.1.9。馆藏统计方法</a></li>
<li><a href="#statistics-query">23.1.10。查询统计方法</a></li>
<li><a href="#statistics-natural-id">23.1.11。自然ID统计方法</a></li>
<li><a href="#statistics-second-level-cache">23.1.12。二级缓存统计方法</a></li>
</ul>
</li>
<li><a href="#statistics-query-max-size">23.2。查询统计信息的最大大小</a></li>
<li><a href="#statistics-query-plan-cache">23.3。查询计划缓存统计信息</a>
<ul class="sectlevel3">
<li><a href="#statistics-query-plan-cache-global-level">23.3.1。查询计划缓存全局统计信息</a></li>
<li><a href="#statistics-query-plan-cache-query-level">23.3.2。查询计划缓存查询级统计</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configurations">24构型</a>
<ul class="sectlevel2">
<li><a href="#configurations-strategy">24.1。策略配置</a></li>
<li><a href="#configurations-general">24.2。常规配置</a></li>
<li><a href="#configurations-jpa-compliance">24.3。符合JPA</a></li>
<li><a href="#configurations-database-connection">24.4。数据库连接属性</a>
<ul class="sectlevel3">
<li><a href="#_hibernate_internal_connection_pool_options">24.4.1。Hibernate内部连接池选项</a></li>
</ul>
</li>
<li><a href="#configurations-c3p0">24.5。 c3p0属性</a></li>
<li><a href="#configurations-mapping">24.6。映射属性</a>
<ul class="sectlevel3">
<li><a href="#_table_qualifying_options">24.6.1。表资格选项</a></li>
<li><a href="#_identifier_options">24.6.2。标识符选项</a></li>
<li><a href="#_quoting_options">24.6.3。报价选项</a></li>
<li><a href="#_discriminator_options">24.6.4。鉴别器选项</a></li>
<li><a href="#_naming_strategies">24.6.5。命名策略</a></li>
<li><a href="#_metadata_scanning_options">24.6.6。元数据扫描选项</a></li>
<li><a href="#_jdbc_related_options">24.6.7。JDBC相关的选项</a></li>
<li><a href="#_bean_validation_options">24.6.8。Bean验证选项</a></li>
<li><a href="#_misc_options">24.6.9。杂项选项</a></li>
</ul>
</li>
<li><a href="#configurations-bytecode-enhancement">24.7。字节码增强属性</a></li>
<li><a href="#configurations-query">24.8。查询设定</a>
<ul class="sectlevel3">
<li><a href="#_multi_table_bulk_hql_operations">24.8.1。多表批量HQL操作</a></li>
</ul>
</li>
<li><a href="#configurations-batch">24.9。批处理属性</a>
<ul class="sectlevel3">
<li><a href="#configurations-database-fetch">24.9.1。获取属性</a></li>
</ul>
</li>
<li><a href="#configurations-logging">24.10。语句记录和统计</a>
<ul class="sectlevel3">
<li><a href="#_sql_statement_logging">24.10.1。SQL语句记录</a></li>
<li><a href="#_statistics_settings">24.10.2。统计设置</a></li>
</ul>
</li>
<li><a href="#configurations-cache">24.11。缓存属性</a></li>
<li><a href="#configurations-infinispan">24.12。Infinispan属性</a></li>
<li><a href="#configurations-transactions">24.13。交易属性</a></li>
<li><a href="#configurations-multi-tenancy">24.14。多租户设置</a></li>
<li><a href="#configurations-hbmddl">24.15。自动模式生成</a></li>
<li><a href="#configurations-exception-handling">24.16。异常处理</a></li>
<li><a href="#configurations-session-events">24.17。会议活动</a></li>
<li><a href="#configurations-jmx">24.18。JMX设置</a></li>
<li><a href="#configurations-jacc">24.19。JACC设置</a></li>
<li><a href="#configurations-classloader">24.20。ClassLoaders属性</a></li>
<li><a href="#configurations-bootstrap">24.21。引导程序属性</a></li>
<li><a href="#configurations-misc">24.22。杂项属性</a></li>
<li><a href="#configurations-envers">24.23。启用属性</a></li>
<li><a href="#configurations-spatial">24.24。空间特性</a></li>
<li><a href="#configurations-internal">24.25。内部性质</a></li>
</ul>
</li>
<li><a href="#annotations">25映射注释</a>
<ul class="sectlevel2">
<li><a href="#annotations-jpa">25.1。JPA批注</a>
<ul class="sectlevel3">
<li><a href="#annotations-jpa-access">25.1.1。<code>@Access</code></a></li>
<li><a href="#annotations-jpa-associationoverride">25.1.2。<code>@AssociationOverride</code></a></li>
<li><a href="#annotations-jpa-associationoverrides">25.1.3。<code>@AssociationOverrides</code></a></li>
<li><a href="#annotations-jpa-attributeoverride">25.1.4。<code>@AttributeOverride</code></a></li>
<li><a href="#annotations-jpa-attributeoverrides">25.1.5。<code>@AttributeOverrides</code></a></li>
<li><a href="#annotations-jpa-basic">25.1.6。<code>@Basic</code></a></li>
<li><a href="#annotations-jpa-cacheable">25.1.7。<code>@Cacheable</code></a></li>
<li><a href="#annotations-jpa-collectiontable">25.1.8。<code>@CollectionTable</code></a></li>
<li><a href="#annotations-jpa-column">25.1.9。<code>@Column</code></a></li>
<li><a href="#annotations-jpa-columnresult">25.1.10。<code>@ColumnResult</code></a></li>
<li><a href="#annotations-jpa-constructorresult">25.1.11。<code>@ConstructorResult</code></a></li>
<li><a href="#annotations-jpa-convert">25.1.12。<code>@Convert</code></a></li>
<li><a href="#annotations-jpa-converter">25.1.13。<code>@Converter</code></a></li>
<li><a href="#annotations-jpa-converts">25.1.14。<code>@Converts</code></a></li>
<li><a href="#annotations-jpa-discriminatorcolumn">15.1.15。<code>@DiscriminatorColumn</code></a></li>
<li><a href="#annotations-jpa-discriminatorvalue">25.1.16。<code>@DiscriminatorValue</code></a></li>
<li><a href="#annotations-jpa-elementcollection">25.1.17。<code>@ElementCollection</code></a></li>
<li><a href="#annotations-jpa-embeddable">25.1.18。<code>@Embeddable</code></a></li>
<li><a href="#annotations-jpa-embedded">25.1.19。<code>@Embedded</code></a></li>
<li><a href="#annotations-jpa-embeddedid">25.1.20。<code>@EmbeddedId</code></a></li>
<li><a href="#annotations-jpa-entity">25.1.21。<code>@Entity</code></a></li>
<li><a href="#annotations-jpa-entitylisteners">25.1.22。<code>@EntityListeners</code></a></li>
<li><a href="#annotations-jpa-entityresult">25.1.23。<code>@EntityResult</code></a></li>
<li><a href="#annotations-jpa-enumerated">25.1.24。<code>@Enumerated</code></a></li>
<li><a href="#annotations-jpa-excludedefaultlisteners">25.1.25。<code>@ExcludeDefaultListeners</code></a></li>
<li><a href="#annotations-jpa-excludesuperclasslisteners">25.1.26。<code>@ExcludeSuperclassListeners</code></a></li>
<li><a href="#annotations-jpa-fieldresult">25.1.27。<code>@FieldResult</code></a></li>
<li><a href="#annotations-jpa-foreignkey">25.1.28。<code>@ForeignKey</code></a></li>
<li><a href="#annotations-jpa-generatedvalue">25.1.29。<code>@GeneratedValue</code></a></li>
<li><a href="#annotations-jpa-id">25.1.30。<code>@Id</code></a></li>
<li><a href="#annotations-jpa-idclass">25.1.31。<code>@IdClass</code></a></li>
<li><a href="#annotations-jpa-index">25.1.32。<code>@Index</code></a></li>
<li><a href="#annotations-jpa-inheritance">25.1.33。<code>@Inheritance</code></a></li>
<li><a href="#annotations-jpa-joincolumn">25.1.34。<code>@JoinColumn</code></a></li>
<li><a href="#annotations-jpa-joincolumns">25.1.35。<code>@JoinColumns</code></a></li>
<li><a href="#annotations-jpa-jointable">25.1.36。<code>@JoinTable</code></a></li>
<li><a href="#annotations-jpa-lob">25.1.37。<code>@Lob</code></a></li>
<li><a href="#annotations-jpa-manytomany">25.1.38。<code>@ManyToMany</code></a></li>
<li><a href="#annotations-jpa-manytoone">25.1.39。<code>@ManyToOne</code></a></li>
<li><a href="#annotations-jpa-mapkey">25.1.40。<code>@MapKey</code></a></li>
<li><a href="#annotations-jpa-mapkeyclass">25.1.41。<code>@MapKeyClass</code></a></li>
<li><a href="#annotations-jpa-mapkeycolumn">25.1.42。<code>@MapKeyColumn</code></a></li>
<li><a href="#annotations-jpa-mapkeyenumerated">25.1.43。<code>@MapKeyEnumerated</code></a></li>
<li><a href="#annotations-jpa-mapkeyjoincolumn">25.1.44。<code>@MapKeyJoinColumn</code></a></li>
<li><a href="#annotations-jpa-mapkeyjoincolumns">25.1.45。<code>@MapKeyJoinColumns</code></a></li>
<li><a href="#annotations-jpa-mapkeytemporal">25.1.46。<code>@MapKeyTemporal</code></a></li>
<li><a href="#annotations-jpa-mappedsuperclass">25.1.47。<code>@MappedSuperclass</code></a></li>
<li><a href="#annotations-jpa-mapsid">25.1.48。<code>@MapsId</code></a></li>
<li><a href="#annotations-jpa-namedattributenode">25.1.49。<code>@NamedAttributeNode</code></a></li>
<li><a href="#annotations-jpa-namedentitygraph">25.1.50。<code>@NamedEntityGraph</code></a></li>
<li><a href="#annotations-jpa-namedentitygraphs">25.1.51。<code>@NamedEntityGraphs</code></a></li>
<li><a href="#annotations-jpa-namednativequeries">25.1.52。<code>@NamedNativeQueries</code></a></li>
<li><a href="#annotations-jpa-namednativequery">25.1.53。<code>@NamedNativeQuery</code></a></li>
<li><a href="#annotations-jpa-namedqueries">25.1.54。<code>@NamedQueries</code></a></li>
<li><a href="#annotations-jpa-namedquery">25.1.55。<code>@NamedQuery</code></a></li>
<li><a href="#annotations-jpa-namedstoredprocedurequeries">25.1.56。<code>@NamedStoredProcedureQueries</code></a></li>
<li><a href="#annotations-jpa-namedstoredprocedurequery">25.1.57。<code>@NamedStoredProcedureQuery</code></a></li>
<li><a href="#annotations-jpa-namedsubgraph">25.1.58。<code>@NamedSubgraph</code></a></li>
<li><a href="#annotations-jpa-onetomany">25.1.59。<code>@OneToMany</code></a></li>
<li><a href="#annotations-jpa-onetoone">25.1.60。<code>@OneToOne</code></a></li>
<li><a href="#annotations-jpa-orderby">25.1.61。<code>@OrderBy</code></a></li>
<li><a href="#annotations-jpa-ordercolumn">25.1.62。<code>@OrderColumn</code></a></li>
<li><a href="#annotations-jpa-persistencecontext">25.1.63。<code>@PersistenceContext</code></a></li>
<li><a href="#annotations-jpa-persistencecontexts">25.1.64。<code>@PersistenceContexts</code></a></li>
<li><a href="#annotations-jpa-persistenceproperty">25.1.65。<code>@PersistenceProperty</code></a></li>
<li><a href="#annotations-jpa-persistenceunit">25.1.66。<code>@PersistenceUnit</code></a></li>
<li><a href="#annotations-jpa-persistenceunits">25.1.67。<code>@PersistenceUnits</code></a></li>
<li><a href="#annotations-jpa-postload">25.1.68。<code>@PostLoad</code></a></li>
<li><a href="#annotations-jpa-postpersist">25.1.69。<code>@PostPersist</code></a></li>
<li><a href="#annotations-jpa-postremove">25.1.70。<code>@PostRemove</code></a></li>
<li><a href="#annotations-jpa-postupdate">25.1.71。<code>@PostUpdate</code></a></li>
<li><a href="#annotations-jpa-prepersist">25.1.72。<code>@PrePersist</code></a></li>
<li><a href="#annotations-jpa-preremove">25.1.73。<code>@PreRemove</code></a></li>
<li><a href="#annotations-jpa-preupdate">25.1.74。<code>@PreUpdate</code></a></li>
<li><a href="#annotations-jpa-primarykeyjoincolumn">25.1.75。<code>@PrimaryKeyJoinColumn</code></a></li>
<li><a href="#annotations-jpa-primarykeyjoincolumns">25.1.76。<code>@PrimaryKeyJoinColumns</code></a></li>
<li><a href="#annotations-jpa-queryhint">25.1.77。<code>@QueryHint</code></a></li>
<li><a href="#annotations-jpa-secondarytable">25.1.78。<code>@SecondaryTable</code></a></li>
<li><a href="#annotations-jpa-secondarytables">25.1.79。<code>@SecondaryTables</code></a></li>
<li><a href="#annotations-jpa-sequencegenerator">25.1.80。<code>@SequenceGenerator</code></a></li>
<li><a href="#annotations-jpa-sqlresultsetmapping">25.1.81。<code>@SqlResultSetMapping</code></a></li>
<li><a href="#annotations-jpa-sqlresultsetmappings">25.1.82。<code>@SqlResultSetMappings</code></a></li>
<li><a href="#annotations-jpa-storedprocedureparameter">25.1.83。<code>@StoredProcedureParameter</code></a></li>
<li><a href="#annotations-jpa-table">25.1.84。<code>@Table</code></a></li>
<li><a href="#annotations-jpa-tablegenerator">25.1.85。<code>@TableGenerator</code></a></li>
<li><a href="#annotations-jpa-temporal">25.1.86。<code>@Temporal</code></a></li>
<li><a href="#annotations-jpa-transient">25.1.87。<code>@Transient</code></a></li>
<li><a href="#annotations-jpa-uniqueconstraint">25.1.88。<code>@UniqueConstraint</code></a></li>
<li><a href="#annotations-jpa-version">25.1.89。<code>@Version</code></a></li>
</ul>
</li>
<li><a href="#annotations-hibernate">25.2。Hibernate注释</a>
<ul class="sectlevel3">
<li><a href="#annotations-hibernate-accesstype">25.2.1。<span class="line-through"><code>@AccessType</code></span></a></li>
<li><a href="#annotations-hibernate-any">25.2.2。<code>@Any</code></a></li>
<li><a href="#annotations-hibernate-anymetadef">25.2.3。<code>@AnyMetaDef</code></a></li>
<li><a href="#annotations-hibernate-anymetadefs">25.2.4。<code>@AnyMetaDefs</code></a></li>
<li><a href="#annotations-hibernate-attributeaccessor">25.2.5。<code>@AttributeAccessor</code></a></li>
<li><a href="#annotations-hibernate-batchsize">25.2.6。<code>@BatchSize</code></a></li>
<li><a href="#annotations-hibernate-cache">25.2.7。<code>@Cache</code></a></li>
<li><a href="#annotations-hibernate-cascade">25.2.8。<code>@Cascade</code></a></li>
<li><a href="#annotations-hibernate-check">25.2.9。<code>@Check</code></a></li>
<li><a href="#annotations-hibernate-collectionid">25.2.10。<code>@CollectionId</code></a></li>
<li><a href="#annotations-hibernate-collectiontype">25.2.11。<code>@CollectionType</code></a></li>
<li><a href="#annotations-hibernate-columndefault">25.2.12。<code>@ColumnDefault</code></a></li>
<li><a href="#annotations-hibernate-columns">25.2.13。<code>@Columns</code></a></li>
<li><a href="#annotations-hibernate-columntransformer">25.2.14。<code>@ColumnTransformer</code></a></li>
<li><a href="#annotations-hibernate-columntransformers">25.2.15。<code>@ColumnTransformers</code></a></li>
<li><a href="#annotations-hibernate-creationtimestamp">25.2.16。<code>@CreationTimestamp</code></a></li>
<li><a href="#annotations-hibernate-discriminatorformula">25.2.17。<code>@DiscriminatorFormula</code></a></li>
<li><a href="#annotations-hibernate-discriminatoroptions">25.2.18。<code>@DiscriminatorOptions</code></a></li>
<li><a href="#annotations-hibernate-dynamicinsert">25.2.19。<code>@DynamicInsert</code></a></li>
<li><a href="#annotations-hibernate-dynamicupdate">25.2.20。<code>@DynamicUpdate</code></a></li>
<li><a href="#annotations-hibernate-entity">25.2.21。<span class="line-through"><code>@Entity</code></span></a></li>
<li><a href="#annotations-hibernate-fetch">25.2.22。<code>@Fetch</code></a></li>
<li><a href="#annotations-hibernate-fetchprofile">25.2.23。<code>@FetchProfile</code></a></li>
<li><a href="#annotations-hibernate-fetchprofile-fetchoverride">25.2.24。<code>@FetchProfile.FetchOverride</code></a></li>
<li><a href="#annotations-hibernate-fetchprofiles">25.2.25。<code>@FetchProfiles</code></a></li>
<li><a href="#annotations-hibernate-filter">25.2.26。<code>@Filter</code></a></li>
<li><a href="#annotations-hibernate-filterdef">25.2.27。<code>@FilterDef</code></a></li>
<li><a href="#annotations-hibernate-filterdefs">25.2.28。<code>@FilterDefs</code></a></li>
<li><a href="#annotations-hibernate-filterjointable">25.2.29。<code>@FilterJoinTable</code></a></li>
<li><a href="#annotations-hibernate-filterjointables">25.2.30。<code>@FilterJoinTables</code></a></li>
<li><a href="#annotations-hibernate-filters">25.2.31。<code>@Filters</code></a></li>
<li><a href="#_span_class_line_through_code_foreignkey_code_span">25.2.32。<span class="line-through"><code>@ForeignKey</code></span></a></li>
<li><a href="#annotations-hibernate-formula">25.2.33。<code>@Formula</code></a></li>
<li><a href="#annotations-hibernate-generated">25.2.34。<code>@Generated</code></a></li>
<li><a href="#annotations-hibernate-generatortype">25.2.35。<code>@GeneratorType</code></a></li>
<li><a href="#annotations-hibernate-genericgenerator">25.2.36。<code>@GenericGenerator</code></a></li>
<li><a href="#annotations-hibernate-genericgenerators">25.2.37。<code>@GenericGenerators</code></a></li>
<li><a href="#annotations-hibernate-immutable">25.2.38。<code>@Immutable</code></a></li>
<li><a href="#annotations-hibernate-index">25.2.39。<span class="line-through"><code>@Index</code></span></a></li>
<li><a href="#annotations-hibernate-indexcolumn">25.2.40。<span class="line-through"><code>@IndexColumn</code></span></a></li>
<li><a href="#annotations-hibernate-joincolumnorformula">25.2.41。<code>@JoinColumnOrFormula</code></a></li>
<li><a href="#annotations-hibernate-joincolumnsorformulas">25.2.42。<code>@JoinColumnsOrFormulas</code></a></li>
<li><a href="#annotations-hibernate-joinformula">25.2.43。<code>@JoinFormula</code></a></li>
<li><a href="#annotations-hibernate-lazycollection">25.2.44。<code>@LazyCollection</code></a></li>
<li><a href="#annotations-hibernate-lazygroup">25.2.45。<code>@LazyGroup</code></a></li>
<li><a href="#annotations-hibernate-lazytoone">25.2.46。<code>@LazyToOne</code></a></li>
<li><a href="#annotations-hibernate-listindexbase">25.2.47。<code>@ListIndexBase</code></a></li>
<li><a href="#annotations-hibernate-loader">25.2.48。<code>@Loader</code></a></li>
<li><a href="#annotations-hibernate-manytoany">25.2.49。<code>@ManyToAny</code></a></li>
<li><a href="#annotations-hibernate-mapkeytype">25.2.50。<code>@MapKeyType</code></a></li>
<li><a href="#annotations-hibernate-metavalue">25.2.51。<code>@MetaValue</code></a></li>
<li><a href="#annotations-hibernate-namednativequeries">25.2.52。<code>@NamedNativeQueries</code></a></li>
<li><a href="#annotations-hibernate-namednativequery">25.2.53。<code>@NamedNativeQuery</code></a></li>
<li><a href="#annotations-hibernate-namedqueries">25.2.54。<code>@NamedQueries</code></a></li>
<li><a href="#annotations-hibernate-namedquery">25.2.55。<code>@NamedQuery</code></a></li>
<li><a href="#annotations-hibernate-nationalized">25.2.56。<code>@Nationalized</code></a></li>
<li><a href="#annotations-hibernate-naturalid">25.2.57。<code>@NaturalId</code></a></li>
<li><a href="#annotations-hibernate-naturalidcache">25.2.58。<code>@NaturalIdCache</code></a></li>
<li><a href="#annotations-hibernate-notfound">25.2.59。<code>@NotFound</code></a></li>
<li><a href="#annotations-hibernate-ondelete">25.2.60。<code>@OnDelete</code></a></li>
<li><a href="#annotations-hibernate-optimisticlock">25.2.61。<code>@OptimisticLock</code></a></li>
<li><a href="#annotations-hibernate-optimisticlocking">25.2.62。<code>@OptimisticLocking</code></a></li>
<li><a href="#annotations-hibernate-orderby">25.2.63。<code>@OrderBy</code></a></li>
<li><a href="#annotations-hibernate-paramdef">25.2.64。<code>@ParamDef</code></a></li>
<li><a href="#annotations-hibernate-parameter">25.2.65。<code>@Parameter</code></a></li>
<li><a href="#annotations-hibernate-parent">25.2.66。<code>@Parent</code></a></li>
<li><a href="#annotations-hibernate-persister">25.2.67。<code>@Persister</code></a></li>
<li><a href="#annotations-hibernate-polymorphism">25.2.68。<code>@Polymorphism</code></a></li>
<li><a href="#annotations-hibernate-proxy">25.2.69。<code>@Proxy</code></a></li>
<li><a href="#annotations-hibernate-rowid">25.2.70。<code>@RowId</code></a></li>
<li><a href="#annotations-hibernate-selectbeforeupdate">25.2.71。<code>@SelectBeforeUpdate</code></a></li>
<li><a href="#annotations-hibernate-sort">25.2.72。<span class="line-through"><code>@Sort</code></span></a></li>
<li><a href="#annotations-hibernate-sortcomparator">25.2.73。<code>@SortComparator</code></a></li>
<li><a href="#annotations-hibernate-sortnatural">25.2.74。<code>@SortNatural</code></a></li>
<li><a href="#annotations-hibernate-source">25.2.75。<code>@Source</code></a></li>
<li><a href="#annotations-hibernate-sqldelete">25.2.76。<code>@SQLDelete</code></a></li>
<li><a href="#annotations-hibernate-sqldeleteall">25.2.77。<code>@SQLDeleteAll</code></a></li>
<li><a href="#annotations-hibernate-sqlfragmentalias">25.2.78。<code>@SqlFragmentAlias</code></a></li>
<li><a href="#annotations-hibernate-sqlinsert">25.2.79。<code>@SQLInsert</code></a></li>
<li><a href="#annotations-hibernate-sqlupdate">25.2.80。<code>@SQLUpdate</code></a></li>
<li><a href="#annotations-hibernate-subselect">25.2.81。<code>@Subselect</code></a></li>
<li><a href="#annotations-hibernate-synchronize">25.2.82。<code>@Synchronize</code></a></li>
<li><a href="#annotations-hibernate-table">25.2.83。<code>@Table</code></a></li>
<li><a href="#annotations-hibernate-tables">25.2.84。<code>@Tables</code></a></li>
<li><a href="#annotations-hibernate-target">25.2.85。<code>@Target</code></a></li>
<li><a href="#annotations-hibernate-tuplizer">25.2.86。<code>@Tuplizer</code></a></li>
<li><a href="#annotations-hibernate-tuplizers">25.2.87。<code>@Tuplizers</code></a></li>
<li><a href="#annotations-hibernate-type">25.2.88。<code>@Type</code></a></li>
<li><a href="#annotations-hibernate-typedef">25.2.89。<code>@TypeDef</code></a></li>
<li><a href="#annotations-hibernate-typedefs">25.2.90。<code>@TypeDefs</code></a></li>
<li><a href="#annotations-hibernate-updatetimestamp">25.2.91。<code>@UpdateTimestamp</code></a></li>
<li><a href="#annotations-hibernate-valuegenerationtype">25.2.92。<code>@ValueGenerationType</code></a></li>
<li><a href="#annotations-hibernate-where">25.2.93。<code>@Where</code></a></li>
<li><a href="#annotations-hibernate-wherejointable">25.2.94。<code>@WhereJoinTable</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#best-practices">26性能调优和最佳实践</a>
<ul class="sectlevel2">
<li><a href="#best-practices-schema">26.1。模式管理</a></li>
<li><a href="#best-practices-logging">26.2。记录中</a></li>
<li><a href="#best-practices-jdbc-batching">26.3。JDBC批处理</a></li>
<li><a href="#best-practices-mapping">26.4。映射</a>
<ul class="sectlevel3">
<li><a href="#best-practices-mapping-identifiers">26.4.1。身份标识</a></li>
<li><a href="#best-practices-mapping-associations">26.4.2。社团协会</a></li>
</ul>
</li>
<li><a href="#best-practices-inheritance">26.5。遗产</a></li>
<li><a href="#best-practices-fetching">26.6。正在取得</a>
<ul class="sectlevel3">
<li><a href="#best-practices-fetching-associations">26.6.1。提取关联</a></li>
</ul>
</li>
<li><a href="#best-practices-caching">26.7。快取</a></li>
</ul>
</li>
<li><a href="#appendix-legacy-bootstrap">27。传统引导</a></li>
<li><a href="#_migration">28。移民</a></li>
<li><a href="#appendix-legacy-domain-model">29。传统域模型</a></li>
<li><a href="#appendix-legacy-criteria">30岁旧版Hibernate标准查询</a>
<ul class="sectlevel2">
<li><a href="#criteria-creating">30.1。创建一个<code>Criteria</code>实例</a></li>
<li><a href="#criteria-entity-name">30.2。JPA与Hibernate实体名称</a></li>
<li><a href="#criteria-narrowing">30.3。缩小结果集</a></li>
<li><a href="#criteria-ordering">30.4。排序结果</a></li>
<li><a href="#criteria-associations">30.5。社团协会</a></li>
<li><a href="#criteria-dynamicfetching">30.6。动态关联获取</a></li>
<li><a href="#criteria-components">30.7。组件</a></li>
<li><a href="#criteria-collections">30.8。馆藏</a></li>
<li><a href="#criteria-examples">30.9。查询示例</a></li>
<li><a href="#criteria-projection">30.10。投影，汇总和分组</a></li>
<li><a href="#criteria-detachedqueries">30.11。分离的查询和子查询</a></li>
<li><a href="#query-criteria-naturalid">30.12。通过自然标识符查询</a></li>
</ul>
</li>
<li><a href="#appendix-legacy-native-queries">31。旧版Hibernate原生查询</a>
<ul class="sectlevel2">
<li><a href="#legacy-sql-named-queries">31.1。旧式命名SQL查询</a></li>
<li><a href="#legacy-propertyresults">31.2。旧版返回属性，用于明确指定列/别名</a></li>
<li><a href="#legacy-sp_query">31.3。旧版存储过程用于查询</a></li>
<li><a href="#legacy-sql-limits-storedprocedures">31.4。使用存储过程的旧规则/限制</a></li>
<li><a href="#legacy-sql-cud">31.5。旧版自定义SQL，用于创建，更新和删除</a></li>
<li><a href="#legacy-sql-load">31.6。旧版自定义SQL进行加载</a></li>
</ul>
</li>
<li><a href="#_references">32。参考文献</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>同时使用面向对象的软件和关系数据库既麻烦又费时。由于对象和关系数据库中的数据表示方式之间存在范式不匹配，因此开发成本要高得多。Hibernate是一种用于Java环境的对象/关系映射解决方案。术语“ <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">对象/关系映射”</a>是指将数据从对象模型表示映射到关系数据模型表示的技术（反之亦然）。</p>
</div>
<div class="paragraph">
<p>Hibernate不仅负责从Java类到数据库表（以及从Java数据类型到SQL数据类型）的映射，而且还提供数据查询和检索功能。它可以显着减少开发时间，否则将花费在SQL和JDBC中的手动数据处理上。 Hibernate的设计目标是通过消除使用SQL和JDBC进行手工数据手工处理的需求，使开发人员摆脱95％的常见数据持久性相关编程任务。但是，与许多其他持久性解决方案不同，Hibernate不会向您隐藏SQL的强大功能，并保证您对关系技术和知识的投资一如既往地有效。</p>
</div>
<div class="paragraph">
<p>对于仅使用存储过程在数据库中实现业务逻辑的以数据为中心的应用程序，Hibernate可能不是最佳解决方案，它对于基于Java的中间层中的面向对象域模型和业务逻辑最有用。但是，Hibernate当然可以帮助您删除或封装特定于供应商的SQL代码，并将帮助完成将结果集从表格表示形式转换为对象图的常见任务。</p>
</div>
<div class="sect2">
<h3 id="_get_involved"><a class="anchor" href="#_get_involved"></a>参与其中</h3>
<div class="ulist">
<ul>
<li>
<p>使用Hibernate并报告发现的任何错误或问题。有关详细信息，请参见<a href="http://hibernate.org/issuetracker">问题跟踪器</a> 。</p>
</li>
<li>
<p>尝试解决一些错误或实施增强功能。再次，请参阅<a href="http://hibernate.org/issuetracker">问题跟踪器</a> 。</p>
</li>
<li>
<p>使用邮件列表，论坛，IRC或“ <a href="http://hibernate.org/community">社区”部分中</a>列出的其他方式与社区互动。</p>
</li>
<li>
<p>帮助改进或翻译本文档。如果您有兴趣，请在开发人员邮件列表上与我们联系。</p>
</li>
<li>
<p>传播这个词。让您的组织其他人了解Hibernate的好处。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_system_requirements"><a class="anchor" href="#_system_requirements"></a>系统要求</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate 5.2和更高版本至少需要Java 1.8和JDBC 4.2。</p>
</div>
<div class="paragraph">
<p>Hibernate 5.1和更早版本至少需要Java 1.6和JDBC 4.0。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从源代码构建Hibernate 5.1或更早版本时，由于JDK 1.6编译器中的错误，您需要Java 1.7。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="_getting_started_guide"><a class="anchor" href="#_getting_started_guide"></a>入门指南</h3>
<div class="paragraph">
<p>新用户可能需要首先阅读《 <a href="https://docs.jboss.org/hibernate/orm/5.4/quickstart/html_single/">Hibernate入门指南》</a>以获取基本信息和教程。还有一系列<a href="http://docs.jboss.org/hibernate/orm/5.4/topical/html_single/">主题指南，</a>可深入探讨各种主题。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然不需要使用Hibernate具有扎实的SQL背景，但肯定有很大帮助，因为所有这些都归结为SQL语句。对数据建模原理的理解可能甚至更为重要。您可能希望将这些资源视为一个良好的起点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Data_modeling">数据建模维基百科定义</a></p>
</li>
<li>
<p><a href="http://www.agiledata.org/essays/dataModeling101.html">数据建模101</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>了解事务处理的基本知识和设计模式（例如<em>工作单元</em> <a href="#PoEAA">PoEAA</a>或<em>应用程序事务处理）</em>也很重要。这些主题将在文档中进行讨论，但是事先理解当然会有所帮助。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a> 1。建筑</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="architecture-overview"><a class="anchor" href="#architecture-overview"></a> 1.1。总览</h3>
<div class="paragraph">
<p><span class="image"><img src="images/architecture/data_access_layers.svg" alt="数据访问层"></span></p>
</div>
<div class="paragraph">
<p>如上图所示，作为ORM解决方案，Hibernate有效地“位于” Java应用程序数据访问层和关系数据库之间。Java应用程序利用Hibernate API来加载，存储，查询等等其域数据。在这里，我们将介绍基本的Hibernate API。这将是一个简短的介绍；我们将在后面详细讨论这些合同。</p>
</div>
<div class="paragraph">
<p>作为JPA提供者，Hibernate实现Java Persistence API规范，并且JPA接口与Hibernate特定实现之间的关联可以在下图中显示：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/architecture/JPA_Hibernate.svg" alt="图片"></span></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SessionFactory（ <code>org.hibernate.SessionFactory</code> ）</dt>
<dd>
<p>应用程序域模型到数据库的映射的线程安全（且不可变）表示形式。充当工厂<code>org.hibernate.Session</code>实例。的<code>EntityManagerFactory</code>是相当于<code>SessionFactory</code>基本上，这两个融合为同一个<code>SessionFactory</code>实施。</p>
<div class="paragraph">
<p>一种<code>SessionFactory</code>创建起来非常昂贵，因此，对于任何给定的数据库，应用程序都应该只有一个关联的数据库<code>SessionFactory</code> 。的<code>SessionFactory</code>维护Hibernate在所有平台上使用的服务<code>Session(s)</code>例如二级缓存，连接池，交易系统集成等。</p>
</div>
</dd>
<dt class="hdlist1">会话（ <code>org.hibernate.Session</code> ）</dt>
<dd>
<p>单线程，短期对象从概念上建模“工作单元” <a href="#PoEAA">PoEAA</a> 。在JPA术语中， <code>Session</code>由一个<code>EntityManager</code> 。</p>
<div class="paragraph">
<p>幕后的冬眠<code>Session</code>包装JDBC <code>java.sql.Connection</code>并作为工厂<code>org.hibernate.Transaction</code>实例。它维护应用程序域模型的一般“可重复读取”持久性上下文（一级缓存）。</p>
</div>
</dd>
<dt class="hdlist1">交易（ <code>org.hibernate.Transaction</code> ）</dt>
<dd>
<p>应用程序用来划分单个物理事务边界的单线程，短期对象。
<code>EntityTransaction</code>是等效的JPA，并且都充当抽象API，以将应用程序与使用中的基础事务系统（JDBC或JTA）隔离开。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="domain-model"><a class="anchor" href="#domain-model"></a> 2。领域模型</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Domain_model">领域模型</a>一词来自数据建模领域。该模型最终描述了您正在处理的<a href="https://en.wikipedia.org/wiki/Problem_domain">问题域</a> 。有时您还会听到术语<em>持久类</em> 。</p>
</div>
<div class="paragraph">
<p>最终，应用程序领域模型是ORM中的中心角色。它们构成了您希望映射的类。如果这些类遵循普通旧Java对象（POJO）/ JavaBean编程模型，则Hibernate效果最佳。但是，这些规则都不是硬性要求。实际上，Hibernate对持久性对象的性质几乎不做任何假设。您可以通过其他方式（使用<code>java.util.Map</code>实例）。</p>
</div>
<div class="paragraph">
<p>从历史上看，使用Hibernate的应用程序会为此目的使用其专有的XML映射文件格式。随着JPA的到来，现在大多数信息都以注释（和/或标准化XML格式）可在ORM / JPA提供程序之间移植的方式进行定义。本章将重点介绍JPA映射。对于JPA不支持的Hibernate映射功能，我们将更喜欢Hibernate扩展注释。</p>
</div>
<div class="sect2">
<h3 id="mapping-types"><a class="anchor" href="#mapping-types"></a> 2.1。映射类型</h3>
<div class="paragraph">
<p>Hibernate理解应用程序数据的Java和JDBC表示形式。Hibernate <em>类型</em>的功能是从数据库读取数据或向数据库写入数据。在这种用法中，类型是<code>org.hibernate.type.Type</code>接口。这个Hibernate类型还描述了Java类型的各种行为方面，例如如何检查是否相等，如何克隆值等。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">单词<em>类型的</em>用法</div>
<div class="paragraph">
<p>Hibernate类型既不是Java类型也不是SQL数据类型。它提供有关将Java类型映射到SQL类型以及如何在关系数据库中持久化和获取给定Java类型的信息。</p>
</div>
<div class="paragraph">
<p>当您在Hibernate的讨论中遇到术语类型时，根据上下文，它可能是指Java类型，JDBC类型或Hibernate类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了帮助理解类型分类，让我们看一下我们希望映射的简单表和域模型。</p>
</div>
<div id="mapping-types-basic-example" class="exampleblock">
<div class="title">范例1。一个简单的表和域模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Contact (
    id integer not null,
    first varchar(255),
    last varchar(255),
    middle varchar(255),
    notes varchar(255),
    starred boolean not null,
    website varchar(255),
    primary key (id)
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Contact")
public static class Contact {

	@Id
	private Integer id;

	private Name name;

	private String notes;

	private URL website;

	private boolean starred;

	//Getters and setters are omitted for brevity
}

@Embeddable
public class Name {

	private String first;

	private String middle;

	private String last;

	// getters and setters omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从广义上讲，Hibernate将类型分为两类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#categorization-value">值类型</a></p>
</li>
<li>
<p><a href="#categorization-entity">实体类型</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="categorization-value"><a class="anchor" href="#categorization-value"></a> 2.1.1。值类型</h4>
<div class="paragraph">
<p>值类型是一条未定义其自身生命周期的数据。实际上，它由定义其生命周期的实体所有。</p>
</div>
<div class="paragraph">
<p>从另一种角度看，实体的所有状态完全由值类型组成。这些状态字段或JavaBean属性称为<em>持久属性</em> 。的持久属性<code>Contact</code>类是值类型。</p>
</div>
<div class="paragraph">
<p>值类型进一步分为三个子类别：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">基本类型</dt>
<dd>
<p>在映射<code>Contact</code>表中，除名称以外的所有属性都是基本类型。基本类型在<a href="#basic"><em>基本类型</em></a>中详细讨论</p>
</dd>
<dt class="hdlist1">可嵌入类型</dt>
<dd>
<p>name属性是可嵌入类型的示例，将在“ <a href="#embeddables"><em>可嵌入类型”</em></a>中详细讨论</p>
</dd>
<dt class="hdlist1">集合类型</dt>
<dd>
<p>尽管集合类型在值类型中是一个独特的类别，但在上述示例中未作介绍。集合类型将在<a href="#collections"><em>集合</em></a>中进一步讨论</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="categorization-entity"><a class="anchor" href="#categorization-entity"></a> 2.1.2。实体类型</h4>
<div class="paragraph">
<p>实体根据其唯一标识符的性质独立于其他对象而存在，而值则不存在。实体是域模型类，使用唯一标识符与数据库表中的行相关。由于需要唯一标识符，因此实体独立存在并定义自己的生命周期。的<code>Contact</code>类本身就是一个实体的例子。</p>
</div>
<div class="paragraph">
<p>在<a href="#entity"><em>Entity</em></a>中详细讨论了映射实体。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="naming"><a class="anchor" href="#naming"></a> 2.2。命名策略</h3>
<div class="paragraph">
<p>对象模型到关系数据库的映射的一部分是将名称从对象模型映射到相应的数据库名称。Hibernate将其视为两个阶段的过程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一步是从域模型映射中确定适当的逻辑名。逻辑名称可以由用户明确指定（使用<code>@Column</code>要么<code>@Table</code>例如），也可以由Hibernate通过<a href="#ImplicitNamingStrategy">ImplicitNamingStrategy</a>合同隐式确定。</p>
</li>
<li>
<p>其次是将此逻辑名称解析为<a href="#PhysicalNamingStrategy">PhysicalNamingStrategy</a>合同定义的物理名称。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">历史命名策略合约</div>
<div class="paragraph">
<p>Hibernate历史上只定义了一个<code>org.hibernate.cfg.NamingStrategy</code> 。那个单一的NamingStrategy合同实际上结合了单独的关注点，这些关注点现在分别建模为ImplicitNamingStrategy和PhysicalNamingStrategy。</p>
</div>
<div class="paragraph">
<p>而且，NamingStrategy合同通常不够灵活，无法正确地应用给定的命名“规则”，这是因为API缺乏决定信息，或者因为API的发展一直没有很好地定义。</p>
</div>
<div class="paragraph">
<p>由于这些限制， <code>org.hibernate.cfg.NamingStrategy</code>已被弃用，然后移除，改为使用ImplicitNamingStrategy和PhysicalNamingStrategy。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从根本上讲，每种命名策略背后的思想是使开发人员为映射域模型而必须提供的重复信息量最小化。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">JPA兼容性</div>
<div class="paragraph">
<p>JPA定义了有关隐式逻辑名称确定的固有规则。如果主要关注JPA提供程序的可移植性，或者您真的很喜欢JPA定义的隐式命名规则，请确保坚持使用ImplicitNamingStrategyJpaCompliantImpl（默认设置）</p>
</div>
<div class="paragraph">
<p>此外，JPA定义逻辑名称和物理名称之间没有分隔。根据JPA规范，逻辑名称<strong>是</strong>物理名称。如果JPA提供程序的可移植性很重要，则应用程序不应选择不指定PhysicalNamingStrategy。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="ImplicitNamingStrategy"><a class="anchor" href="#ImplicitNamingStrategy"></a> 2.2.1。隐式命名策略</h4>
<div class="paragraph">
<p>当实体未明确命名其映射到的数据库表时，我们需要隐式确定该表名。或者，当特定属性没有显式命名其映射到的数据库列时，我们需要隐式确定该列名称。有一些作用的例子<code>org.hibernate.boot.model.naming.ImplicitNamingStrategy</code>映射不提供显式名称时，可以使用合同确定逻辑名称。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/domain/naming/implicit_naming_strategy_diagram.svg" alt="隐式命名策略图"></span></p>
</div>
<div class="paragraph">
<p>Hibernate开箱即用地定义了多个ImplicitNamingStrategy实现。应用程序也可以免费使用插件自定义实现。</p>
</div>
<div class="paragraph">
<p>有多种方法可以指定要使用的ImplicitNamingStrategy。首先，应用程序可以使用<code>hibernate.implicit_naming_strategy</code>接受以下配置的配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>开箱即用的实现的预定义“短名称”</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>default</code></dt>
<dd>
<p>对于<code>org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl</code> -的别名<code>jpa</code></p>
</dd>
<dt class="hdlist1"><code>jpa</code></dt>
<dd>
<p>对于<code>org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl</code> -符合JPA 2.0的命名策略</p>
</dd>
<dt class="hdlist1"><code>legacy-hbm</code></dt>
<dd>
<p>对于<code>org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl</code> -符合原始的Hibernate NamingStrategy</p>
</dd>
<dt class="hdlist1"><code>legacy-jpa</code></dt>
<dd>
<p>对于<code>org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl</code> -符合为JPA 1.0开发的旧版NamingStrategy，遗憾的是，在很多方面都不清楚隐式命名规则</p>
</dd>
<dt class="hdlist1"><code>component-path</code></dt>
<dd>
<p>对于<code>org.hibernate.boot.model.naming.ImplicitNamingStrategyComponentPathImpl</code> -主要跟随<code>ImplicitNamingStrategyJpaCompliantImpl</code>规则，只是它使用完整的复合路径，而不是仅使用结尾属性部分</p>
</dd>
</dl>
</div>
</li>
<li>
<p>引用实现<code>org.hibernate.boot.model.naming.ImplicitNamingStrategy</code>合同</p>
</li>
<li>
<p>实现以下内容的类的FQN <code>org.hibernate.boot.model.naming.ImplicitNamingStrategy</code>合同</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其次，应用程序和集成可以利用<code>org.hibernate.boot.MetadataBuilder#applyImplicitNamingStrategy</code>指定要使用的ImplicitNamingStrategy。有关<a href="#bootstrap">引导</a>的更多详细信息，请参见引导。</p>
</div>
</div>
<div class="sect3">
<h4 id="PhysicalNamingStrategy"><a class="anchor" href="#PhysicalNamingStrategy"></a> 2.2.2。物理命名策略</h4>
<div class="paragraph">
<p>许多组织围绕数据库对象（表，列，外键等）的命名定义规则。PhysicalNamingStrategy的思想是帮助实现此类命名规则，而不必通过显式名称将其硬编码到映射中。</p>
</div>
<div class="paragraph">
<p>虽然ImplicitNamingStrategy的目的是确定一个名为<code>accountNumber</code>映射到逻辑列名<code>accountNumber</code>当未明确指定时，PhysicalNamingStrategy的目的是例如说应改为物理列名<code>acct_num</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的确， <code>acct_num</code>本可以使用<code>ImplicitNamingStrategy</code>在这种情况下。</p>
</div>
<div class="paragraph">
<p>但是这里的重点是关注点分离。的<code>PhysicalNamingStrategy</code>无论该属性是显式指定列名还是隐式确定列名，都将应用。的<code>ImplicitNamingStrategy</code>仅在未提供明确名称的情况下才会应用。因此，这完全取决于需求和意图。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认实现是简单地使用逻辑名作为物理名。但是，应用程序和集成可以定义此PhysicalNamingStrategy合同的自定义实现。这是一个名为Acme Corp的虚拟公司的物理命名策略示例，其命名标准为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>喜欢用下划线分隔的单词，而不是骆驼式的字母</p>
</li>
<li>
<p>用标准缩写替换某些单词</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例2示例PhysicalNamingStrategy实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.
 */
package org.hibernate.userguide.naming;

import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;

import org.hibernate.boot.model.naming.Identifier;
import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;

import org.apache.commons.lang3.StringUtils;

/**
 * An example PhysicalNamingStrategy that implements database object naming standards
 * for our fictitious company Acme Corp.
 * &lt;p/&gt;
 * In general Acme Corp prefers underscore-delimited words rather than camel casing.
 * &lt;p/&gt;
 * Additionally standards call for the replacement of certain words with abbreviations.
 *
 * @author Steve Ebersole
 */
public class AcmeCorpPhysicalNamingStrategy implements PhysicalNamingStrategy {
	private static final Map&lt;String,String&gt; ABBREVIATIONS = buildAbbreviationMap();

	@Override
	public Identifier toPhysicalCatalogName(Identifier name, JdbcEnvironment jdbcEnvironment) {
		// Acme naming standards do not apply to catalog names
		return name;
	}

	@Override
	public Identifier toPhysicalSchemaName(Identifier name, JdbcEnvironment jdbcEnvironment) {
		// Acme naming standards do not apply to schema names
		return name;
	}

	@Override
	public Identifier toPhysicalTableName(Identifier name, JdbcEnvironment jdbcEnvironment) {
		final List&lt;String&gt; parts = splitAndReplace( name.getText() );
		return jdbcEnvironment.getIdentifierHelper().toIdentifier(
				join( parts ),
				name.isQuoted()
		);
	}

	@Override
	public Identifier toPhysicalSequenceName(Identifier name, JdbcEnvironment jdbcEnvironment) {
		final LinkedList&lt;String&gt; parts = splitAndReplace( name.getText() );
		// Acme Corp says all sequences should end with _seq
		if ( !"seq".equalsIgnoreCase( parts.getLast() ) ) {
			parts.add( "seq" );
		}
		return jdbcEnvironment.getIdentifierHelper().toIdentifier(
				join( parts ),
				name.isQuoted()
		);
	}

	@Override
	public Identifier toPhysicalColumnName(Identifier name, JdbcEnvironment jdbcEnvironment) {
		final List&lt;String&gt; parts = splitAndReplace( name.getText() );
		return jdbcEnvironment.getIdentifierHelper().toIdentifier(
				join( parts ),
				name.isQuoted()
		);
	}

	private static Map&lt;String, String&gt; buildAbbreviationMap() {
		TreeMap&lt;String,String&gt; abbreviationMap = new TreeMap&lt;&gt; ( String.CASE_INSENSITIVE_ORDER );
		abbreviationMap.put( "account", "acct" );
		abbreviationMap.put( "number", "num" );
		return abbreviationMap;
	}

	private LinkedList&lt;String&gt; splitAndReplace(String name) {
		LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;();
		for ( String part : StringUtils.splitByCharacterTypeCamelCase( name ) ) {
			if ( part == null || part.trim().isEmpty() ) {
				// skip null and space
				continue;
			}
			part = applyAbbreviationReplacement( part );
			result.add( part.toLowerCase( Locale.ROOT ) );
		}
		return result;
	}

	private String applyAbbreviationReplacement(String word) {
		if ( ABBREVIATIONS.containsKey( word ) ) {
			return ABBREVIATIONS.get( word );
		}

		return word;
	}

	private String join(List&lt;String&gt; parts) {
		boolean firstPass = true;
		String separator = "";
		StringBuilder joined = new StringBuilder();
		for ( String part : parts ) {
			joined.append( separator ).append( part );
			if ( firstPass ) {
				firstPass = false;
				separator = "_";
			}
		}
		return joined.toString();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有多种方法可以指定要使用的PhysicalNamingStrategy。首先，应用程序可以使用<code>hibernate.physical_naming_strategy</code>接受以下配置的配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>引用实现<code>org.hibernate.boot.model.naming.PhysicalNamingStrategy</code>合同</p>
</li>
<li>
<p>实现以下内容的类的FQN <code>org.hibernate.boot.model.naming.PhysicalNamingStrategy</code>合同</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其次，应用程序和集成可以利用<code>org.hibernate.boot.MetadataBuilder#applyPhysicalNamingStrategy</code> 。有关<a href="#bootstrap">引导</a>的更多详细信息，请参见引导。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basic"><a class="anchor" href="#basic"></a> 2.3。基本类型</h3>
<div class="paragraph">
<p>基本值类型通常将单个数据库列映射到单个非聚合Java类型。Hibernate提供了许多内置的基本类型，它们遵循JDBC规范建议的自然映射。</p>
</div>
<div class="paragraph">
<p>在内部，Hibernate需要解析特定类型时使用基本类型的注册表。 <code>org.hibernate.type.Type</code> 。</p>
</div>
<div class="sect3">
<h4 id="basic-provided"><a class="anchor" href="#basic-provided"></a> 2.3.1。Hibernate提供的BasicType</h4>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表格1。标准基本类型</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hibernate类型（org.hibernate.type包）</th>
<th class="tableblock halign-left valign-top">JDBC类型</th>
<th class="tableblock halign-left valign-top">Java类型</th>
<th class="tableblock halign-left valign-top">BasicTypeRegistry密钥</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串，java.lang。串</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">物化球</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">materialized_clob</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">文字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">角色类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">焦炭</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符，java.lang。字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符，java.lang。字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">比特</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值，java.lang。布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值，java.lang。布尔型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NumericBooleanType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数，0为假，1为真</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值，java.lang。布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">numeric_boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR，'N'/'n'为假，'Y'/'y'为真。大写的值将写入数据库。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值，java.lang。布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes_no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TrueFalseType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR，'F'/'f'为假，'T'/'t'为真。大写的值将写入数据库。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值，java.lang。布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">天音</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节，java.lang。字节</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节，java.lang。字节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">简短的java.lang。短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">简短的java.lang。短</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int，java.lang。整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int，java.lang。整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">比金特</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">很长的java.lang。长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">很长的java.lang。长</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动，java.lang。浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动，java.lang。浮动</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双重类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double，java.lang。双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double，java.lang。双</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigIntegerType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.math。大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">big_integer，java.math。大整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimalType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.math。大十进制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">big_decimal，java.math.bigDecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。时间戳记</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳，java.sql。时间戳记</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间，java.sql。时间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期，java.sql。日期</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CalendarType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。日历</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日历，java.util。日历</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CalendarDateType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。日历</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">calendar_date</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CalendarTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。日历</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">calendar_time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">货币类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。货币</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">货币，java.util。货币</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">语言环境类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。语言环境</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">语言环境，java.utility.locale</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">时区类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR，使用TimeZone ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。时区</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时区，java.util。时区</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网址类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.net。网址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网址，java.net。网址</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR（FQN类）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类，java.lang。类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BlobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。斑点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blob，java.sql。斑点</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ClobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clob，java.sql。b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BinaryType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARBINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制，字节[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaterializedBlobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">materialized_blob</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">图像类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARBINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">图片</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WrapperBinaryType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARBINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。字节[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">wrapper-binary，Byte []，java.lang。字节[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharArrayType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符，字符[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharacterArrayType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。字符[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包装字符，Character []，java.lang。字符[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUIDBinaryType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uuid-binary，java.util。UUID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUIDCharType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHAR，也可以读取VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uuid-char</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgresUUIDType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过Types＃OTHER遵循PostgreSQL JDBC驱动程序定义的PostgreSQL UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util。UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pg-uuid</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SerializableType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARBINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang的实现者。可序列化</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与其他值类型不同，该类型的多个实例被注册。它在java.io下注册一次。可序列化，并在特定的java.io下注册。可序列化的实现类名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StringNVarcharType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NTextType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">龙瓦查</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NClobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.sql。NClob</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nclob，java.sql。NClob</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaterializedNClobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">materialized_nclob</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrimitiveCharacterArrayNClobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharacterNCharType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CharacterArrayNClobType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NCLOB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.lang。字符[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2。Java 8 BasicTypes</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hibernate类型（org.hibernate.type包）</th>
<th class="tableblock halign-left valign-top">JDBC类型</th>
<th class="tableblock halign-left valign-top">Java类型</th>
<th class="tableblock halign-left valign-top">BasicTypeRegistry密钥</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">持续时间类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">比金特</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。持续时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">持续时间，java.time。持续时间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">InstantType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。瞬间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">即时，java.time。瞬间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalDateTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。LocalDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalDateTime，java.time。LocalDateTime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalDateType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。本地日期</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalDate，java.time。本地日期</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。当地时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LocalTime，java.time。当地时间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OffsetDateTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。OffsetDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OffsetDateTime，java.time。OffsetDateTime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OffsetTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。偏移时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OffsetTime，java.time。偏移时间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZonedDateTimeType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time。ZonedDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZonedDateTime，java.time。ZonedDateTime</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表3。Hibernate空间基本类型</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hibernate类型（org.hibernate.spatial包）</th>
<th class="tableblock halign-left valign-top">JDBC类型</th>
<th class="tableblock halign-left valign-top">Java类型</th>
<th class="tableblock halign-left valign-top">BasicTypeRegistry密钥</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JTSGeometryType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取决于方言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.vividsolutions.jts.geom。几何</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jts_geometry或Geometry的类名称或其任何子类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GeolatteGeometryType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取决于方言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.geolatte.geom。几何</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geolatte_geometry或Geometry的类名称或其任何子类</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用Hibernate空间类型，您必须添加<code>hibernate-spatial</code>依赖于您的类路径<em>并</em>使用<code>org.hibernate.spatial.SpatialDialect</code>实施。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="#spatial">空间</a>一章。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这些映射由Hibernate内部的服务（称为<code>org.hibernate.type.BasicTypeRegistry</code> ，基本上维护着<code>org.hibernate.type.BasicType</code> （一种<code>org.hibernate.type.Type</code>专业化）实例（以名称为关键字）。这就是先前表中“ BasicTypeRegistry键”列的目的。</p>
</div>
</div>
<div class="sect3">
<h4 id="basic-annotation"><a class="anchor" href="#basic-annotation"></a> 2.3.2。的<code>@Basic</code>注解</h4>
<div class="paragraph">
<p>严格来说，基本类型用<code>javax.persistence.Basic</code>注解。一般来说， <code>@Basic</code>注释可以忽略，因为默认情况下是假定的。以下两个示例最终都是相同的。</p>
</div>
<div id="basic-annotation-explicit-example" class="exampleblock">
<div class="title">范例3。 <code>@Basic</code>明确声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public class Product {

	@Id
	@Basic
	private Integer id;

	@Basic
	private String sku;

	@Basic
	private String name;

	@Basic
	private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div id="basic-annotation-implicit-example" class="exampleblock">
<div class="title">示例4 <code>@Basic</code>被暗中暗示</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public class Product {

	@Id
	private Integer id;

	private String sku;

	private String name;

	private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA规范严格将可以标记为基本的Java类型限制在以下列表中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java基本类型（ <code>boolean</code> ， <code>int</code>等）</p>
</li>
<li>
<p>基本类型的包装器（ <code>java.lang.Boolean</code> ， <code>java.lang.Integer</code>等）</p>
</li>
<li>
<p><code>java.lang.String</code></p>
</li>
<li>
<p><code>java.math.BigInteger</code></p>
</li>
<li>
<p><code>java.math.BigDecimal</code></p>
</li>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
<li>
<p><code>byte[]</code>要么<code>Byte[]</code></p>
</li>
<li>
<p><code>char[]</code>要么<code>Character[]</code></p>
</li>
<li>
<p><code>enums</code></p>
</li>
<li>
<p>任何其他实现的类型<code>Serializable</code> （JPA的“支持” <code>Serializable</code>类型是直接将其状态序列化到数据库）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要提供程序的可移植性，则应仅遵循这些基本类型。</p>
</div>
<div class="paragraph">
<p>请注意，JPA 2.1引入了<code>javax.persistence.AttributeConverter</code>签订合同以减轻这些担忧。有关此主题的更多信息，请参见<a href="#basic-jpa-convert">JPA 2.1 AttributeConverters</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@Basic</code>注释定义2个属性。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>optional</code> -布尔值（默认为true）</dt>
<dd>
<p>定义此属性是否允许空值。JPA将其定义为“提示”，这实际上意味着特别需要它的效果。只要类型不是原始类型，Hibernate就会将此表示基础列应为<code>NULLABLE</code> 。</p>
</dd>
<dt class="hdlist1"><code>fetch</code> -FetchType（默认为EAGER）</dt>
<dd>
<p>定义该属性是应立即获取还是应延迟获取。JPA说，EAGER是提供者（Hibernate）的一项要求，即在提取所有者时应提取值，而LAZY只是暗示在访问属性时要提取值。除非您使用字节码增强功能，否则Hibernate对于基本类型将忽略此设置。有关获取和字节码增强的更多信息，请参见<a href="#BytecodeEnhancement">BytecodeEnhancement</a> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="basic-column-annotation"><a class="anchor" href="#basic-column-annotation"></a> 2.3.3。的<code>@Column</code>注解</h4>
<div class="paragraph">
<p>JPA定义了用于隐式确定表和列名称的规则。有关隐式命名的详细讨论，请参见<a href="#naming">Naming</a> 。</p>
</div>
<div class="paragraph">
<p>对于基本类型属性，隐式命名规则是列名称与属性名称相同。如果该隐式命名规则不符合您的要求，则可以显式告诉Hibernate（和其他提供程序）要使用的列名。</p>
</div>
<div id="basic-annotation-explicit-column-example" class="exampleblock">
<div class="title">示例5显式列命名</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public class Product {

	@Id
	private Integer id;

	private String sku;

	private String name;

	@Column( name = "NOTES" )
	private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里我们用<code>@Column</code>明确地映射<code>description</code>归因于<code>NOTES</code>列，而不是隐式列名<code>description</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>@Column</code>注释还定义了其他映射信息。有关详细信息，请参见其Javadocs。</p>
</div>
</div>
<div class="sect3">
<h4 id="basic-registry"><a class="anchor" href="#basic-registry"></a> 2.3.4。BasicTypeRegistry</h4>
<div class="paragraph">
<p>前面我们说过，Hibernate类型既不是Java类型，也不是SQL类型，但是它既可以理解两者，又可以在它们之间进行编组。但是，从前面的示例中看到基本的类型映射，Hibernate怎么知道使用它的<code>org.hibernate.type.StringType</code>用于映射<code>java.lang.String</code>属性或其<code>org.hibernate.type.IntegerType</code>用于映射<code>java.lang.Integer</code>属性？</p>
</div>
<div class="paragraph">
<p>答案在于Hibernate内部的一项名为<code>org.hibernate.type.BasicTypeRegistry</code> ，基本上维护着<code>org.hibernate.type.BasicType</code> （一种<code>org.hibernate.type.Type</code>专业化）实例（以名称为关键字）。</p>
</div>
<div class="paragraph">
<p>稍后我们将在<a href="#basic-type-annotation">Explicit BasicTypes</a>部分中看到，我们可以明确告诉Hibernate对特定属性使用哪个BasicType。但是首先，让我们探讨隐式分辨率的工作原理以及应用程序如何调整隐式分辨率。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>彻底的讨论<code>BasicTypeRegistry</code>并且所有不同的贡献类型的方式都超出了本文档的范围。</p>
</div>
<div class="paragraph">
<p>请参阅《 <a href="http://docs.jboss.org/hibernate/orm/5.4/integrationguide/html_single/Hibernate_Integration_Guide.html">集成指南》</a>以获取完整详细信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，采用我们之前在Product＃sku中看到的String属性。由于没有显式的类型映射，因此Hibernate会查找<code>BasicTypeRegistry</code>查找已注册的映射<code>java.lang.String</code> 。这可以追溯到我们在本章开始的表格中看到的“ BasicTypeRegistry键”列。</p>
</div>
<div class="paragraph">
<p>作为基准<code>BasicTypeRegistry</code> ，Hibernate遵循针对Java类型的JDBC推荐映射。JDBC建议将字符串映射到VARCHAR，这是<code>StringType</code>处理。这就是内部的基线映射<code>BasicTypeRegistry</code>用于字符串。</p>
</div>
<div class="paragraph">
<p>应用程序也可以扩展（添加新<code>BasicType</code>注册）或覆盖（替换现有的<code>BasicType</code>注册）使用<code>MetadataBuilder#applyBasicType</code>方法或<code>MetadataBuilder#applyTypes</code>引导过程中的方法。有关更多详细信息，请参见“ <a href="#basic-custom-type">自定义BasicTypes”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="basic-type-annotation"><a class="anchor" href="#basic-type-annotation"></a> 2.3.5。显式BasicType</h4>
<div class="paragraph">
<p>有时您希望对特定属性进行不同的处理。有时，Hibernate会隐式选择一个<code>BasicType</code>您不想要的（由于某种原因，您不想调整<code>BasicTypeRegistry</code> ）。</p>
</div>
<div class="paragraph">
<p>在这种情况下，您必须明确告知Hibernate <code>BasicType</code>通过使用<code>org.hibernate.annotations.Type</code>注解。</p>
</div>
<div id="basic-type-annotation-example" class="exampleblock">
<div class="title">范例6。使用<code>@org.hibernate.annotations.Type</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public class Product {

	@Id
	private Integer id;

	private String sku;

	@org.hibernate.annotations.Type( type = "nstring" )
	private String name;

	@org.hibernate.annotations.Type( type = "materialized_nclob" )
	private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这告诉Hibernate将字符串存储为国有化数据。这只是出于说明目的；有关指示民族化字符数据的更好方法，请参见<a href="#basic-nationalized">映射民族化字符数据</a>部分。</p>
</div>
<div class="paragraph">
<p>另外，该描述将作为LOB处理。同样，有关指示LOB的更好方法，请参见<a href="#basic-lob">映射LOB</a>部分。</p>
</div>
<div class="paragraph">
<p>的<code>org.hibernate.annotations.Type#type</code>属性可以命名以下任意一项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何的全限定名称<code>org.hibernate.type.Type</code>实作</p>
</li>
<li>
<p>已向其注册的任何密钥<code>BasicTypeRegistry</code></p>
</li>
<li>
<p>任何已知<em>类型定义</em>的名称</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="basic-custom-type"><a class="anchor" href="#basic-custom-type"></a> 2.3.6。自定义BasicType</h4>
<div class="paragraph">
<p>Hibernate使开发人员相对容易地创建自己的基本类型映射类型。例如，您可能要保留类型的属性<code>java.util.BigInteger</code>至<code>VARCHAR</code>列，或支持全新的类型。</p>
</div>
<div class="paragraph">
<p>开发自定义类型有两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实施<code>BasicType</code>并注册</p>
</li>
<li>
<p>实施<code>UserType</code>不需要类型注册</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明不同的方法，让我们考虑一个需要支持<code>java.util.BitSet</code>存储为VARCHAR的映射。</p>
</div>
<div class="sect4">
<h5 id="basic-custom-type-BasicType"><a class="anchor" href="#basic-custom-type-BasicType"></a>实施<code>BasicType</code></h5>
<div class="paragraph">
<p>第一种方法是直接实施<code>BasicType</code>接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为<code>BasicType</code>接口有很多方法可以实现，如果将值存储在单个数据库列中，则扩展<code>AbstractStandardBasicType</code>或者<code>AbstractSingleColumnStandardBasicType</code>Hibernate类。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>首先，我们需要扩展<code>AbstractSingleColumnStandardBasicType</code>像这样：</p>
</div>
<div id="basic-custom-type-BitSetType-example" class="exampleblock">
<div class="title">范例7。自订<code>BasicType</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BitSetType
        extends AbstractSingleColumnStandardBasicType&lt;BitSet&gt;
        implements DiscriminatorType&lt;BitSet&gt; {

    public static final BitSetType INSTANCE = new BitSetType();

    public BitSetType() {
        super( VarcharTypeDescriptor.INSTANCE, BitSetTypeDescriptor.INSTANCE );
    }

    @Override
    public BitSet stringToObject(String xml) throws Exception {
        return fromString( xml );
    }

    @Override
    public String objectToSQLString(BitSet value, Dialect dialect) throws Exception {
        return toString( value );
    }

    @Override
    public String getName() {
        return "bitset";
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>AbstractSingleColumnStandardBasicType</code>需要一个<code>sqlTypeDescriptor</code>和一个<code>javaTypeDescriptor</code> 。的<code>sqlTypeDescriptor</code>是<code>VarcharTypeDescriptor.INSTANCE</code>因为数据库列是VARCHAR。在Java方面，我们需要使用<code>BitSetTypeDescriptor</code>可以这样实现的实例：</p>
</div>
<div id="basic-custom-type-BitSetTypeDescriptor-example" class="exampleblock">
<div class="title">范例8。自订<code>AbstractTypeDescriptor</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BitSetTypeDescriptor extends AbstractTypeDescriptor&lt;BitSet&gt; {

    private static final String DELIMITER = ",";

    public static final BitSetTypeDescriptor INSTANCE = new BitSetTypeDescriptor();

    public BitSetTypeDescriptor() {
        super( BitSet.class );
    }

    @Override
    public String toString(BitSet value) {
        StringBuilder builder = new StringBuilder();
        for ( long token : value.toLongArray() ) {
            if ( builder.length() &gt; 0 ) {
                builder.append( DELIMITER );
            }
            builder.append( Long.toString( token, 2 ) );
        }
        return builder.toString();
    }

    @Override
    public BitSet fromString(String string) {
        if ( string == null || string.isEmpty() ) {
            return null;
        }
        String[] tokens = string.split( DELIMITER );
        long[] values = new long[tokens.length];

        for ( int i = 0; i &lt; tokens.length; i++ ) {
            values[i] = Long.valueOf( tokens[i], 2 );
        }
        return BitSet.valueOf( values );
    }

    @SuppressWarnings({"unchecked"})
    public &lt;X&gt; X unwrap(BitSet value, Class&lt;X&gt; type, WrapperOptions options) {
        if ( value == null ) {
            return null;
        }
        if ( BitSet.class.isAssignableFrom( type ) ) {
            return (X) value;
        }
        if ( String.class.isAssignableFrom( type ) ) {
            return (X) toString( value);
        }
        throw unknownUnwrap( type );
    }

    public &lt;X&gt; BitSet wrap(X value, WrapperOptions options) {
        if ( value == null ) {
            return null;
        }
        if ( String.class.isInstance( value ) ) {
            return fromString( (String) value );
        }
        if ( BitSet.class.isInstance( value ) ) {
            return (BitSet) value;
        }
        throw unknownWrap( value.getClass() );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>unwrap</code>传递一个<code>BitSet</code>作为一个<code>PreparedStatement</code>绑定参数，而<code>wrap</code>方法用于转换JDBC列值对象（例如<code>String</code>在我们的例子中）到实际的映射对象类型（例如<code>BitSet</code>在此示例中）。</p>
</div>
<div class="paragraph">
<p>的<code>BasicType</code>必须注册，并且可以在引导时完成：</p>
</div>
<div id="basic-custom-type-register-BasicType-example" class="exampleblock">
<div class="title">范例9。注册自定义<code>BasicType</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">configuration.registerTypeContributor( (typeContributions, serviceRegistry) -&gt; {
	typeContributions.contributeType( BitSetType.INSTANCE );
} );</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用<code>MetadataBuilder</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ServiceRegistry standardRegistry =
    new StandardServiceRegistryBuilder().build();

MetadataSources sources = new MetadataSources( standardRegistry );

MetadataBuilder metadataBuilder = sources.getMetadataBuilder();

metadataBuilder.applyBasicType( BitSetType.INSTANCE );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随着新<code>BitSetType</code>被注册为<code>bitset</code> ，实体映射如下所示：</p>
</div>
<div id="basic-custom-type-BitSetType-mapping-example" class="exampleblock">
<div class="title">示例10自订<code>BasicType</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Integer id;

	@Type( type = "bitset" )
	private BitSet bitSet;

	public Integer getId() {
		return id;
	}

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用<code>@TypeDef</code>并跳过注册阶段：</p>
</div>
<div id="basic-custom-type-BitSetTypeDef-mapping-example" class="exampleblock">
<div class="title">示例11使用<code>@TypeDef</code>注册自定义类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
@TypeDef(
	name = "bitset",
	defaultForType = BitSet.class,
	typeClass = BitSetType.class
)
public static class Product {

	@Id
	private Integer id;

	private BitSet bitSet;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>验证这个新<code>BasicType</code>实施，我们可以如下进行测试：</p>
</div>
<div id="basic-custom-type-BitSetType-persistence-example" class="exampleblock">
<div class="title">范例12。坚持风俗<code>BasicType</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">BitSet bitSet = BitSet.valueOf( new long[] {1, 2, 3} );

doInHibernate( this::sessionFactory, session -&gt; {
	Product product = new Product( );
	product.setId( 1 );
	product.setBitSet( bitSet );
	session.persist( product );
} );

doInHibernate( this::sessionFactory, session -&gt; {
	Product product = session.get( Product.class, 1 );
	assertEquals(bitSet, product.getBitSet());
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行此单元测试时，Hibernate生成以下SQL语句：</p>
</div>
<div id="basic-custom-type-BitSetType-persistence-sql-example" class="exampleblock">
<div class="title">范例13。坚持风俗<code>BasicType</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">DEBUG SQL:92 -
    insert
    into
        Product
        (bitSet, id)
    values
        (?, ?)

TRACE BasicBinder:65 - binding parameter [1] as [VARCHAR] - [{0, 65, 128, 129}]
TRACE BasicBinder:65 - binding parameter [2] as [INTEGER] - [1]

DEBUG SQL:92 -
    select
        bitsettype0_.id as id1_0_0_,
        bitsettype0_.bitSet as bitSet2_0_0_
    from
        Product bitsettype0_
    where
        bitsettype0_.id=?

TRACE BasicBinder:65 - binding parameter [1] as [INTEGER] - [1]
TRACE BasicExtractor:61 - extracted value ([bitSet2_0_0_] : [VARCHAR]) - [{0, 65, 128, 129}]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>BitSetType</code>负责<em>Java到SQL</em>和<em>SQL到Java的</em>类型转换。</p>
</div>
</div>
<div class="sect4">
<h5 id="basic-custom-type-UserType"><a class="anchor" href="#basic-custom-type-UserType"></a>实施<code>UserType</code></h5>
<div class="paragraph">
<p>第二种方法是实施<code>UserType</code>接口。</p>
</div>
<div id="basic-custom-type-BitSetUserType-example" class="exampleblock">
<div class="title">范例14。自订<code>UserType</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BitSetUserType implements UserType {

	public static final BitSetUserType INSTANCE = new BitSetUserType();

    private static final Logger log = Logger.getLogger( BitSetUserType.class );

    @Override
    public int[] sqlTypes() {
        return new int[] {StringType.INSTANCE.sqlType()};
    }

    @Override
    public Class returnedClass() {
        return BitSet.class;
    }

    @Override
    public boolean equals(Object x, Object y)
			throws HibernateException {
        return Objects.equals( x, y );
    }

    @Override
    public int hashCode(Object x)
			throws HibernateException {
        return Objects.hashCode( x );
    }

    @Override
    public Object nullSafeGet(
            ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)
            throws HibernateException, SQLException {
        String columnName = names[0];
        String columnValue = (String) rs.getObject( columnName );
        log.debugv("Result set column {0} value is {1}", columnName, columnValue);
        return columnValue == null ? null :
				BitSetTypeDescriptor.INSTANCE.fromString( columnValue );
    }

    @Override
    public void nullSafeSet(
            PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)
            throws HibernateException, SQLException {
        if ( value == null ) {
            log.debugv("Binding null to parameter {0} ",index);
            st.setNull( index, Types.VARCHAR );
        }
        else {
            String stringValue = BitSetTypeDescriptor.INSTANCE.toString( (BitSet) value );
            log.debugv("Binding {0} to parameter {1} ", stringValue, index);
            st.setString( index, stringValue );
        }
    }

    @Override
    public Object deepCopy(Object value)
			throws HibernateException {
        return value == null ? null :
            BitSet.valueOf( BitSet.class.cast( value ).toLongArray() );
    }

    @Override
    public boolean isMutable() {
        return true;
    }

    @Override
    public Serializable disassemble(Object value)
			throws HibernateException {
        return (BitSet) deepCopy( value );
    }

    @Override
    public Object assemble(Serializable cached, Object owner)
			throws HibernateException {
        return deepCopy( cached );
    }

    @Override
    public Object replace(Object original, Object target, Object owner)
			throws HibernateException {
        return deepCopy( original );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实体映射如下所示：</p>
</div>
<div id="basic-custom-type-BitSetUserType-mapping-example" class="exampleblock">
<div class="title">示例15自订<code>UserType</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Integer id;

	@Type( type = "bitset" )
	private BitSet bitSet;

	//Constructors, getters, and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中， <code>UserType</code>已根据<code>bitset</code>名称，操作如下：</p>
</div>
<div id="basic-custom-type-register-UserType-example" class="exampleblock">
<div class="title">示例16。注册自定义<code>UserType</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">configuration.registerTypeContributor( (typeContributions, serviceRegistry) -&gt; {
	typeContributions.contributeType( BitSetUserType.INSTANCE, "bitset");
} );</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用<code>MetadataBuilder</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ServiceRegistry standardRegistry =
    new StandardServiceRegistryBuilder().build();

MetadataSources sources = new MetadataSources( standardRegistry );

MetadataBuilder metadataBuilder = sources.getMetadataBuilder();

metadataBuilder.applyBasicType( BitSetUserType.INSTANCE, "bitset" );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>喜欢<code>BasicType</code> ，您也可以注册<code>UserType</code>使用简单的名称。</p>
</div>
<div class="paragraph">
<p>如果不注册名称， <code>UserType</code>映射需要完全分类的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Type( type = "org.hibernate.userguide.mapping.basic.BitSetUserType" )</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当针对<code>BitSetUserType</code>实体映射时，Hibernate执行以下SQL语句：</p>
</div>
<div id="basic-custom-type-BitSetUserType-persistence-sql-example" class="exampleblock">
<div class="title">示例17坚持风俗<code>BasicType</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">DEBUG SQL:92 -
    insert
    into
        Product
        (bitSet, id)
    values
        (?, ?)

DEBUG BitSetUserType:71 - Binding 1,10,11 to parameter 1
TRACE BasicBinder:65 - binding parameter [2] as [INTEGER] - [1]

DEBUG SQL:92 -
    select
        bitsetuser0_.id as id1_0_0_,
        bitsetuser0_.bitSet as bitSet2_0_0_
    from
        Product bitsetuser0_
    where
        bitsetuser0_.id=?

TRACE BasicBinder:65 - binding parameter [1] as [INTEGER] - [1]
DEBUG BitSetUserType:56 - Result set column bitSet2_0_0_ value is 1,10,11</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic-enums"><a class="anchor" href="#basic-enums"></a> 2.3.7。映射枚举</h4>
<div class="paragraph">
<p>Hibernate支持通过多种不同方式将Java枚举映射为基本值类型。</p>
</div>
<div class="sect4">
<h5 id="basic-enums-Enumerated"><a class="anchor" href="#basic-enums-Enumerated"></a><code>@Enumerated</code></h5>
<div class="paragraph">
<p>原始的JPA映射枚举方式是通过<code>@Enumerated</code>要么<code>@MapKeyEnumerated</code>对于地图键注释，根据以下原则工作：枚举值是根据由指示的2种策略之一进行存储的<code>javax.persistence.EnumType</code> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ORDINAL</code></dt>
<dd>
<p>根据枚举类中枚举值的序数位置存储，如<code>java.lang.Enum#ordinal</code></p>
</dd>
<dt class="hdlist1"><code>STRING</code></dt>
<dd>
<p>根据枚举值的名称存储，如<code>java.lang.Enum#name</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>假设以下列举：</p>
</div>
<div class="exampleblock">
<div class="title">示例18 <code>PhoneType</code>列举</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public enum PhoneType {
    LAND_LINE,
    MOBILE;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在ORDINAL示例中， <code>phone_type</code>列定义为（可为空）INTEGER类型，并将保持：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NULL</code></dt>
<dd>
<p>对于空值</p>
</dd>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>为了<code>LAND_LINE</code>枚举</p>
</dd>
<dt class="hdlist1"><code>1</code></dt>
<dd>
<p>为了<code>MOBILE</code>枚举</p>
</dd>
</dl>
</div>
<div id="basic-enums-Enumerated-ordinal-example" class="exampleblock">
<div class="title">示例19 <code>@Enumerated(ORDINAL)</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	@Column(name = "phone_number")
	private String number;

	@Enumerated(EnumType.ORDINAL)
	@Column(name = "phone_type")
	private PhoneType type;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>持久化该实体时，Hibernate生成以下SQL语句：</p>
</div>
<div id="basic-enums-Enumerated-ordinal-persistence-example" class="exampleblock">
<div class="title">示例20用<code>@Enumerated(ORDINAL)</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Phone phone = new Phone( );
phone.setId( 1L );
phone.setNumber( "123-456-78990" );
phone.setType( PhoneType.MOBILE );
entityManager.persist( phone );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Phone (phone_number, phone_type, id)
VALUES ('123-456-78990', 2, 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在STRING示例中， <code>phone_type</code>列被定义为（空）VARCHAR类型，并将保持：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NULL</code></dt>
<dd>
<p>对于空值</p>
</dd>
<dt class="hdlist1"><code>LAND_LINE</code></dt>
<dd>
<p>为了<code>LAND_LINE</code>枚举</p>
</dd>
<dt class="hdlist1"><code>MOBILE</code></dt>
<dd>
<p>为了<code>MOBILE</code>枚举</p>
</dd>
</dl>
</div>
<div id="basic-enums-Enumerated-string-example" class="exampleblock">
<div class="title">示例21 <code>@Enumerated(STRING)</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	@Column(name = "phone_number")
	private String number;

	@Enumerated(EnumType.STRING)
	@Column(name = "phone_type")
	private PhoneType type;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>坚持与<code>@Enumerated(ORDINAL)</code>例如，Hibernate生成以下SQL语句：</p>
</div>
<div id="basic-enums-Enumerated-string-persistence-example" class="exampleblock">
<div class="title">示例22用<code>@Enumerated(STRING)</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Phone (phone_number, phone_type, id)
VALUES ('123-456-78990', 'MOBILE', 1)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="basic-enums-attribute-converter"><a class="anchor" href="#basic-enums-attribute-converter"></a> AttributeConverter</h5>
<div class="paragraph">
<p>让我们考虑以下<code>Gender</code>枚举，使用<code>'M'</code>和<code>'F'</code>代码。</p>
</div>
<div id="basic-enums-converter-example" class="exampleblock">
<div class="title">示例23用自定义构造函数枚举</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public enum Gender {

    MALE( 'M' ),
    FEMALE( 'F' );

    private final char code;

    Gender(char code) {
        this.code = code;
    }

    public static Gender fromCode(char code) {
        if ( code == 'M' || code == 'm' ) {
            return MALE;
        }
        if ( code == 'F' || code == 'f' ) {
            return FEMALE;
        }
        throw new UnsupportedOperationException(
            "The code " + code + " is not supported!"
        );
    }

    public char getCode() {
        return code;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用JPA 2.1 AttributeConverter以符合JPA的方式映射枚举。</p>
</div>
<div id="basic-enums-attribute-converter-example" class="exampleblock">
<div class="title">示例24枚举与<code>AttributeConverter</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@Convert( converter = GenderConverter.class )
	public Gender gender;

	//Getters and setters are omitted for brevity

}

@Converter
public static class GenderConverter
		implements AttributeConverter&lt;Gender, Character&gt; {

	public Character convertToDatabaseColumn( Gender value ) {
		if ( value == null ) {
			return null;
		}

		return value.getCode();
	}

	public Gender convertToEntityAttribute( Character value ) {
		if ( value == null ) {
			return null;
		}

		return Gender.fromCode( value );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，性别列被定义为CHAR类型，并将保持：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NULL</code></dt>
<dd>
<p>对于空值</p>
</dd>
<dt class="hdlist1"><code>'M'</code></dt>
<dd>
<p>为了<code>MALE</code>枚举</p>
</dd>
<dt class="hdlist1"><code>'F'</code></dt>
<dd>
<p>为了<code>FEMALE</code>枚举</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关使用AttributeConverters的其他详细信息，请参见“ <a href="#basic-jpa-convert">JPA 2.1 AttributeConverters”</a>部分。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA明确禁止使用<code>AttributeConverter</code>属性标记为<code>@Enumerated</code> 。</p>
</div>
<div class="paragraph">
<p>因此，当使用<code>AttributeConverter</code>方法，请确保不要将属性标记为<code>@Enumerated</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="basic-attribute-converter-query-parameter"><a class="anchor" href="#basic-attribute-converter-query-parameter"></a>使用AttributeConverter实体属性作为查询参数</h6>
<div class="paragraph">
<p>假设您具有以下实体：</p>
</div>
<div id="basic-attribute-converter-query-parameter-entity-example" class="exampleblock">
<div class="title">示例25 <code>Photo</code>与实体<code>AttributeConverter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Photo")
public static class Photo {

	@Id
	private Integer id;

	private String name;

	@Convert(converter = CaptionConverter.class)
	private Caption caption;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>和<code>Caption</code>该类如下所示：</p>
</div>
<div id="basic-attribute-converter-query-parameter-object-example" class="exampleblock">
<div class="title">示例26。 <code>Caption</code> Java对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class Caption {

	private String text;

	public Caption(String text) {
		this.text = text;
	}

	public String getText() {
		return text;
	}

	public void setText(String text) {
		this.text = text;
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Caption caption = (Caption) o;
		return text != null ? text.equals( caption.text ) : caption.text == null;

	}

	@Override
	public int hashCode() {
		return text != null ? text.hashCode() : 0;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们有一个<code>AttributeConverter</code>处理<code>Caption</code> Java对象：</p>
</div>
<div id="basic-attribute-converter-query-parameter-converter-example" class="exampleblock">
<div class="title">示例27 <code>Caption</code> Java对象AttributeConverter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CaptionConverter
		implements AttributeConverter&lt;Caption, String&gt; {

	@Override
	public String convertToDatabaseColumn(Caption attribute) {
		return attribute.getText();
	}

	@Override
	public Caption convertToEntityAttribute(String dbData) {
		return new Caption( dbData );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>传统上，您只能使用dbData <code>Caption</code>表示，在我们的例子中是<code>String</code> ，当引用<code>caption</code>实体属性。</p>
</div>
<div id="basic-attribute-converter-query-parameter-converter-dbdata-example" class="exampleblock">
<div class="title">示例28。通过过滤<code>Caption</code>使用数据库数据表示的属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Photo photo = entityManager.createQuery(
	"select p " +
	"from Photo p " +
	"where upper(caption) = upper(:caption) ", Photo.class )
.setParameter( "caption", "Nicolae Grigorescu" )
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了使用Java对象<code>Caption</code>表示形式，您必须获取关联的Hibernate<code>Type</code> 。</p>
</div>
<div id="basic-attribute-converter-query-parameter-converter-object-example" class="exampleblock">
<div class="title">示例29。通过过滤<code>Caption</code>使用Java Object表示形式的属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SessionFactory sessionFactory = entityManager.getEntityManagerFactory()
		.unwrap( SessionFactory.class );

MetamodelImplementor metamodelImplementor = (MetamodelImplementor) sessionFactory.getMetamodel();

Type captionType = metamodelImplementor
		.entityPersister( Photo.class.getName() )
		.getPropertyType( "caption" );

Photo photo = (Photo) entityManager.createQuery(
	"select p " +
	"from Photo p " +
	"where upper(caption) = upper(:caption) ", Photo.class )
.unwrap( Query.class )
.setParameter( "caption", new Caption("Nicolae Grigorescu"), captionType)
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过关联的Hibernate<code>Type</code> ，您可以使用<code>Caption</code>绑定查询参数值时的对象。</p>
</div>
</div>
<div class="sect5">
<h6 id="basic-hbm-attribute-converter"><a class="anchor" href="#basic-hbm-attribute-converter"></a>使用HBM映射映射AttributeConverter</h6>
<div class="paragraph">
<p>使用HBM映射时，您仍然可以使用JPA <code>AttributeConverter</code>因为Hibernate通过<code>type</code>属性，如以下示例所示。</p>
</div>
<div class="paragraph">
<p>考虑一下我们有一个特定于应用程序的情况<code>Money</code>类型：</p>
</div>
<div id="basic-hbm-attribute-converter-mapping-money-example" class="exampleblock">
<div class="title">示例30特定于应用<code>Money</code>类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class Money {

    private long cents;

    public Money(long cents) {
        this.cents = cents;
    }

    public long getCents() {
        return cents;
    }

    public void setCents(long cents) {
        this.cents = cents;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们要使用<code>Money</code>映射时输入<code>Account</code>实体：</p>
</div>
<div id="basic-hbm-attribute-converter-mapping-account-example" class="exampleblock">
<div class="title">示例31。 <code>Account</code>实体使用<code>Money</code>类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class Account {

    private Long id;

    private String owner;

    private Money balance;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于Hibernate不知道如何持久保存<code>Money</code>类型，我们可以使用JPA <code>AttributeConverter</code>改变<code>Money</code>输入为<code>Long</code> 。为此，我们将使用以下内容<code>MoneyConverter</code>效用：</p>
</div>
<div id="basic-hbm-attribute-converter-mapping-moneyconverter-example" class="exampleblock">
<div class="title">示例32 <code>MoneyConverter</code>实施JPA <code>AttributeConverter</code>接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class MoneyConverter
        implements AttributeConverter&lt;Money, Long&gt; {

    @Override
    public Long convertToDatabaseColumn(Money attribute) {
        return attribute == null ? null : attribute.getCents();
    }

    @Override
    public Money convertToEntityAttribute(Long dbData) {
        return dbData == null ? null : new Money( dbData );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要映射<code>MoneyConverter</code>使用HBM配置文件，您需要使用<code>converted::</code>中的前缀<code>type</code>的属性<code>property</code>元件。</p>
</div>
<div id="basic-hbm-attribute-converter-mapping-xml-config-example" class="exampleblock">
<div class="title">例子33。HBM映射<code>AttributeConverter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.userguide.mapping.converter.hbm"&gt;
    &lt;class name="Account" table="account" &gt;
        &lt;id name="id"/&gt;

        &lt;property name="owner"/&gt;

        &lt;property name="balance"
            type="converted::org.hibernate.userguide.mapping.converter.hbm.MoneyConverter"/&gt;

    &lt;/class&gt;
&lt;/hibernate-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="basic-enums-custom-type"><a class="anchor" href="#basic-enums-custom-type"></a>自订类型</h5>
<div class="paragraph">
<p>您还可以使用Hibernate自定义类型映射来映射枚举。让我们再次回顾Gender枚举示例，这次使用自定义类型存储更标准化的<code>'M'</code>和<code>'F'</code>代码。</p>
</div>
<div id="basic-enums-custom-type-example" class="exampleblock">
<div class="title">示例34带有自定义类型示例的枚举映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@Type( type = "org.hibernate.userguide.mapping.basic.GenderType" )
	public Gender gender;

	//Getters and setters are omitted for brevity

}

public class GenderType extends AbstractSingleColumnStandardBasicType&lt;Gender&gt; {

    public static final GenderType INSTANCE = new GenderType();

    public GenderType() {
        super(
            CharTypeDescriptor.INSTANCE,
            GenderJavaTypeDescriptor.INSTANCE
        );
    }

    public String getName() {
        return "gender";
    }

    @Override
    protected boolean registerUnderJavaType() {
        return true;
    }
}

public class GenderJavaTypeDescriptor extends AbstractTypeDescriptor&lt;Gender&gt; {

    public static final GenderJavaTypeDescriptor INSTANCE =
        new GenderJavaTypeDescriptor();

    protected GenderJavaTypeDescriptor() {
        super( Gender.class );
    }

    public String toString(Gender value) {
        return value == null ? null : value.name();
    }

    public Gender fromString(String string) {
        return string == null ? null : Gender.valueOf( string );
    }

    public &lt;X&gt; X unwrap(Gender value, Class&lt;X&gt; type, WrapperOptions options) {
        return CharacterTypeDescriptor.INSTANCE.unwrap(
            value == null ? null : value.getCode(),
            type,
            options
        );
    }

    public &lt;X&gt; Gender wrap(X value, WrapperOptions options) {
        return Gender.fromCode(
            CharacterTypeDescriptor.INSTANCE.wrap( value, options )
        );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，gender列被定义为CHAR类型，并将保留：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NULL</code></dt>
<dd>
<p>对于空值</p>
</dd>
<dt class="hdlist1"><code>'M'</code></dt>
<dd>
<p>为了<code>MALE</code>枚举</p>
</dd>
<dt class="hdlist1"><code>'F'</code></dt>
<dd>
<p>为了<code>FEMALE</code>枚举</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关使用自定义类型的其他详细信息，请参见“ <a href="#basic-custom-type">自定义BasicTypes”</a>部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic-lob"><a class="anchor" href="#basic-lob"></a> 2.3.8。映射LOB</h4>
<div class="paragraph">
<p>映射LOB（数据库大对象）有2种形式，一种使用JDBC定位器类型，另一种用于实现LOB数据。</p>
</div>
<div class="paragraph">
<p>存在JDBC LOB定位器以允许有效访问LOB数据。它们允许JDBC驱动程序根据需要流式传输LOB数据的一部分，从而潜在地释放内存空间。但是，它们可能不自然地处理并且具有一定的局限性。例如，LOB定位器仅在获得它的交易期间有效。</p>
</div>
<div class="paragraph">
<p>物化LOB的想法是权衡潜在的效率（并非所有驱动程序都有效地处理LOB数据），以便使用熟悉的Java类型（例如， <code>String</code>要么<code>byte[]</code> ，以此类推。</p>
</div>
<div class="paragraph">
<p>物化处理内存中的整个LOB内容，而LOB定位器（理论上）允许根据需要将部分LOB内容流式传输到内存中。</p>
</div>
<div class="paragraph">
<p>JDBC LOB定位器类型包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.sql.Blob</code></p>
</li>
<li>
<p><code>java.sql.Clob</code></p>
</li>
<li>
<p><code>java.sql.NClob</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>映射这些LOB值的物化形式将使用更熟悉的Java类型，例如<code>String</code> ， <code>char[]</code> ， <code>byte[]</code>等等。 <em>更熟悉的折衷方案</em>通常是性能。</p>
</div>
<div class="sect4">
<h5 id="basic-clob"><a class="anchor" href="#basic-clob"></a>映射CLOB</h5>
<div class="paragraph">
<p>乍一看，假设我们有一个<code>CLOB</code>我们要映射的列（ <code>NCLOB</code>字符<code>LOB</code>数据将在“ <a href="#basic-nationalized">映射国家字符数据”</a>部分中介绍）。</p>
</div>
<div class="paragraph">
<p>考虑到我们有以下数据库表：</p>
</div>
<div id="basic-clob-sql-example" class="exampleblock">
<div class="title">示例35CLOB-SQL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Product (
  id INTEGER NOT NULL,
  name VARCHAR(255),
  warranty CLOB,
  PRIMARY KEY (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们首先使用<code>@Lob</code> JPA注释和<code>java.sql.Clob</code>类型：</p>
</div>
<div id="basic-clob-example" class="exampleblock">
<div class="title">示例36。 <code>CLOB</code>映射到<code>java.sql.Clob</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    private Clob warranty;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要保留这样的实体，您必须创建一个<code>Clob</code>使用<code>ClobProxy</code>Hibernate实用程序：</p>
</div>
<div id="basic-clob-persist-example" class="exampleblock">
<div class="title">示例37。坚持一个<code>java.sql.Clob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">String warranty = "My product warranty";

final Product product = new Product();
product.setId( 1 );
product.setName( "Mobile phone" );

product.setWarranty( ClobProxy.generateProxy( warranty ) );

entityManager.persist( product );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要检索<code>Clob</code>内容，您需要转换基础<code>java.io.Reader</code> ：</p>
</div>
<div id="basic-clob-find-example" class="exampleblock">
<div class="title">示例38。返回一个<code>java.sql.Clob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product product = entityManager.find( Product.class, productId );

try (Reader reader = product.getWarranty().getCharacterStream()) {
    assertEquals( "My product warranty", toString( reader ) );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还可以将物化形式映射到CLOB。这样，我们可以使用<code>String</code>或一个<code>char[]</code> 。</p>
</div>
<div id="basic-clob-string-example" class="exampleblock">
<div class="title">示例39。 <code>CLOB</code>映射到<code>String</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Integer id;

	private String name;

	@Lob
	private String warranty;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JDBC如何处理<code>LOB</code>数据因驱动程序而异，Hibernate会尝试代表您处理所有这些差异。</p>
</div>
<div class="paragraph">
<p>但是，某些驱动程序比较棘手（例如PostgreSQL），在这种情况下，您可能必须执行一些额外的步骤才能使LOB正常工作。此类讨论超出了本指南的范围。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们甚至可能希望将物化数据作为char数组（尽管这可能不是一个好主意）。</p>
</div>
<div id="basic-clob-char-array-example" class="exampleblock">
<div class="title">示例40CLOB-实现<code>char[]</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Integer id;

	private String name;

	@Lob
	private char[] warranty;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="basic-blob"><a class="anchor" href="#basic-blob"></a>映射BLOB</h5>
<div class="paragraph">
<p><code>BLOB</code>数据以类似的方式映射。</p>
</div>
<div class="paragraph">
<p>考虑到我们有以下数据库表：</p>
</div>
<div id="basic-blob-sql-example" class="exampleblock">
<div class="title">示例41。BLOB-SQL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Product (
    id INTEGER NOT NULL ,
    image blob ,
    name VARCHAR(255) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>首先使用JDBC进行映射<code>java.sql.Blob</code>类型。</p>
</div>
<div id="basic-blob-example" class="exampleblock">
<div class="title">示例42。 <code>BLOB</code>映射到<code>java.sql.Blob</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    private Blob image;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要保留这样的实体，您必须创建一个<code>Blob</code>使用<code>BlobProxy</code>Hibernate实用程序：</p>
</div>
<div id="basic-blob-persist-example" class="exampleblock">
<div class="title">例子43。坚持一个<code>java.sql.Blob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">byte[] image = new byte[] {1, 2, 3};

final Product product = new Product();
product.setId( 1 );
product.setName( "Mobile phone" );

product.setImage( BlobProxy.generateProxy( image ) );

entityManager.persist( product );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要检索<code>Blob</code>内容，您需要转换基础<code>java.io.InputStream</code> ：</p>
</div>
<div id="basic-blob-find-example" class="exampleblock">
<div class="title">例子44。返回一个<code>java.sql.Blob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product product = entityManager.find( Product.class, productId );

try (InputStream inputStream = product.getImage().getBinaryStream()) {
    assertArrayEquals(new byte[] {1, 2, 3}, toBytes( inputStream ) );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还可以将物化形式的BLOB映射（例如<code>byte[]</code> ）。</p>
</div>
<div id="basic-blob-byte-array-example" class="exampleblock">
<div class="title">示例45 <code>BLOB</code>映射到<code>byte[]</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    private byte[] image;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic-nationalized"><a class="anchor" href="#basic-nationalized"></a> 2.3.9。映射国家字符数据</h4>
<div class="paragraph">
<p>JDBC 4添加了显式处理国有化字符数据的功能。为此，它添加了特定的国有化字符数据类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NCHAR</code></p>
</li>
<li>
<p><code>NVARCHAR</code></p>
</li>
<li>
<p><code>LONGNVARCHAR</code></p>
</li>
<li>
<p><code>NCLOB</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑到我们有以下数据库表：</p>
</div>
<div id="basic-nationalized-sql-example" class="exampleblock">
<div class="title">示例46。 <code>NVARCHAR</code> -SQL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CREATE TABLE Product (
    id INTEGER NOT NULL ,
    name VARCHAR(255) ,
    warranty NVARCHAR(255) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了将特定属性映射到国家化的变体数据类型，Hibernate定义了<code>@Nationalized</code>注解。</p>
</div>
<div id="basic-nationalized-example" class="exampleblock">
<div class="title">示例47 <code>NVARCHAR</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Nationalized
    private String warranty;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就像<code>CLOB</code> ，Hibernate也可以处理<code>NCLOB</code> SQL数据类型：</p>
</div>
<div id="basic-nclob-sql-example" class="exampleblock">
<div class="title">示例48 <code>NCLOB</code> -SQL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CREATE TABLE Product (
    id INTEGER NOT NULL ,
    name VARCHAR(255) ,
    warranty nclob ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate可以映射<code>NCLOB</code>到一个<code>java.sql.NClob</code></p>
</div>
<div id="basic-nclob-example" class="exampleblock">
<div class="title">示例49。 <code>NCLOB</code>映射到<code>java.sql.NClob</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    @Nationalized
    // Clob also works, because NClob extends Clob.
    // The database type is still NCLOB either way and handled as such.
    private NClob warranty;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要保留这样的实体，您必须创建一个<code>NClob</code>使用<code>NClobProxy</code>Hibernate实用程序：</p>
</div>
<div id="basic-nclob-persist-example" class="exampleblock">
<div class="title">示例50坚持一个<code>java.sql.NClob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">String warranty = "My product warranty";

final Product product = new Product();
product.setId( 1 );
product.setName( "Mobile phone" );

product.setWarranty( NClobProxy.generateProxy( warranty ) );

entityManager.persist( product );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要检索<code>NClob</code>内容，您需要转换基础<code>java.io.Reader</code> ：</p>
</div>
<div id="basic-nclob-find-example" class="exampleblock">
<div class="title">例子51。返回一个<code>java.sql.NClob</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product product = entityManager.find( Product.class, productId );

try (Reader reader = product.getWarranty().getCharacterStream()) {
    assertEquals( "My product warranty", toString( reader ) );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以映射<code>NCLOB</code>以物化形式。这样，我们可以使用<code>String</code>或一个<code>char[]</code> 。</p>
</div>
<div id="basic-nclob-string-example" class="exampleblock">
<div class="title">示例52。 <code>NCLOB</code>映射到<code>String</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    @Nationalized
    private String warranty;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们甚至可能希望将物化数据作为char数组。</p>
</div>
<div id="basic-nclob-char-array-example" class="exampleblock">
<div class="title">示例53。NCLOB-实现<code>char[]</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

    @Id
    private Integer id;

    private String name;

    @Lob
    @Nationalized
    private char[] warranty;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您的应用程序和数据库使用国有化，则您可能希望启用国有化字符数据作为默认设置。</p>
</div>
<div class="paragraph">
<p>您可以通过<code>hibernate.use_nationalized_character_data</code>设置或致电<code>MetadataBuilder#enableGlobalNationalizedCharacterDataSupport</code>在引导过程中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="basic-uuid"><a class="anchor" href="#basic-uuid"></a> 2.3.10。映射UUID值</h4>
<div class="paragraph">
<p>Hibernate还允许您以多种方式映射UUID值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认的UUID映射是二进制映射，因为它使用了更有效的列存储。</p>
</div>
<div class="paragraph">
<p>但是，许多应用程序更喜欢基于字符的列存储的可读性。要切换默认映射，只需调用<code>MetadataBuilder.applyBasicType( UUIDCharType.INSTANCE, UUID.class.getName() )</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_uuid_as_binary"><a class="anchor" href="#_uuid_as_binary"></a> 2.3.11。UUID为二进制</h4>
<div class="paragraph">
<p>如前所述，UUID属性的默认映射。将UUID映射到<code>byte[]</code>使用<code>java.util.UUID#getMostSignificantBits</code>和<code>java.util.UUID#getLeastSignificantBits</code>并将其存储为<code>BINARY</code>数据。</p>
</div>
<div class="paragraph">
<p>之所以选择默认值，是因为从存储角度来看，它通常更有效。</p>
</div>
</div>
<div class="sect3">
<h4 id="_uuid_as_var_char"><a class="anchor" href="#_uuid_as_var_char"></a> 2.3.12。UUID为（var）char</h4>
<div class="paragraph">
<p>使用以下方式将UUID映射到字符串<code>java.util.UUID#toString</code>和<code>java.util.UUID#fromString</code>并将其存储为<code>CHAR</code>要么<code>VARCHAR</code>数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postgresql_specific_uuid"><a class="anchor" href="#_postgresql_specific_uuid"></a> 2.3.13。PostgreSQL特定的UUID</h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用PostgreSQL方言之一时，特定于PostgreSQL的UUIDHibernate类型将成为默认的UUID映射。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用PostgreSQL特定的UUID数据类型映射UUID。PostgreSQL JDBC驱动程序选择将其UUID类型映射到<code>OTHER</code>码。请注意，这可能会导致困难，因为驱动程序选择将许多不同的数据类型映射到<code>OTHER</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_uuid_as_identifier"><a class="anchor" href="#_uuid_as_identifier"></a> 2.3.14。UUID作为标识符</h4>
<div class="paragraph">
<p>Hibernate支持使用UUID值作为标识符，甚至可以代表用户生成它们。有关详细信息，请参见<a href="#identifiers"><em>标识符生成</em></a>器中有关生成器的讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="basic-datetime"><a class="anchor" href="#basic-datetime"></a> 2.3.15。映射日期/时间值</h4>
<div class="paragraph">
<p>Hibernate允许将各种Java日期/时间类映射为持久域模型实体属性。SQL标准定义了三种日期/时间类型：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">日期</dt>
<dd>
<p>通过存储年，月和日来表示日历日期。JDBC等效为<code>java.sql.Date</code></p>
</dd>
<dt class="hdlist1">时间</dt>
<dd>
<p>代表一天中的时间，并存储小时，分钟和秒。JDBC等效为<code>java.sql.Time</code></p>
</dd>
<dt class="hdlist1">时间戳</dt>
<dd>
<p>它存储DATE和TIME加上纳秒。JDBC等效为<code>java.sql.Timestamp</code></p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了避免依赖于<code>java.sql</code>包，通常使用<code>java.util</code>要么<code>java.time</code>日期/时间类别，而不是<code>java.sql.Timestamp</code>和<code>java.sql.Time</code>那些。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>而<code>java.sql</code>类定义与SQL日期/时间数据类型的直接关联， <code>java.util</code>要么<code>java.time</code>属性需要使用显式标记SQL类型关联<code>@Temporal</code>注解。这样一来<code>java.util.Date</code>或一个<code>java.util.Calendar</code>可以映射到任一SQL <code>DATE</code> ， <code>TIME</code>要么<code>TIMESTAMP</code>类型。</p>
</div>
<div class="paragraph">
<p>考虑以下实体：</p>
</div>
<div id="basic-datetime-temporal-date-example" class="exampleblock">
<div class="title">示例54 <code>java.util.Date</code>映射为<code>DATE</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "DateEvent")
public static class DateEvent {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`timestamp`")
	@Temporal(TemporalType.DATE)
	private Date timestamp;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>保留此类实体时：</p>
</div>
<div id="basic-datetime-temporal-date-persist-example" class="exampleblock">
<div class="title">例子55。坚持一个<code>java.util.Date</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">DateEvent dateEvent = new DateEvent( new Date() );
entityManager.persist( dateEvent );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate生成以下INSERT语句：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO DateEvent ( timestamp, id )
VALUES ( '2015-12-29', 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>仅年，月和日字段被保存到数据库中。</p>
</div>
<div class="paragraph">
<p>如果我们改变<code>@Temporal</code>输入<code>TIME</code> ：</p>
</div>
<div id="basic-datetime-temporal-time-example" class="exampleblock">
<div class="title">例子56。 <code>java.util.Date</code>映射为<code>TIME</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Column(name = "`timestamp`")
@Temporal(TemporalType.TIME)
private Date timestamp;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate将发出一个包含小时，分钟和秒的INSERT语句。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO DateEvent ( timestamp, id )
VALUES ( '16:51:58', 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>@Temporal</code>类型设置为<code>TIMESTAMP</code> ：</p>
</div>
<div id="basic-datetime-temporal-timestamp-example" class="exampleblock">
<div class="title">例子57。 <code>java.util.Date</code>映射为<code>TIMESTAMP</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Column(name = "`timestamp`")
@Temporal(TemporalType.TIMESTAMP)
private Date timestamp;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate将包括<code>DATE</code> ， <code>TIME</code>以及INSERT语句中的纳秒：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO DateEvent ( timestamp, id )
VALUES ( '2015-12-29 16:54:04.544', 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>就像<code>java.util.Date</code> ， <code>java.util.Calendar</code>需要<code>@Temporal</code>注解，以便知道要选择哪种JDBC数据类型： <code>DATE</code> ， <code>TIME</code>要么<code>TIMESTAMP</code> 。</p>
</div>
<div class="paragraph">
<p>如果<code>java.util.Date</code>标志着一个时间点， <code>java.util.Calendar</code>考虑默认时区。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="basic-datetime-java8"><a class="anchor" href="#basic-datetime-java8"></a>映射Java 8日期/时间值</h5>
<div class="paragraph">
<p>Java 8附带了新的Date / Time API，它支持即时日期，时间间隔，本地和分区的Date / Time不可变实例，这些实例捆绑在<code>java.time</code>包。</p>
</div>
<div class="paragraph">
<p>标准SQL日期/时间类型和受支持的Java 8日期/时间类类型之间的映射如下所示；</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">日期</dt>
<dd>
<p><code>java.time.LocalDate</code></p>
</dd>
<dt class="hdlist1">时间</dt>
<dd>
<p><code>java.time.LocalTime</code> ，<code>java.time.OffsetTime</code></p>
</dd>
<dt class="hdlist1">时间戳</dt>
<dd>
<p><code>java.time.Instant</code> ， <code>java.time.LocalDateTime</code> ， <code>java.time.OffsetDateTime</code>和<code>java.time.ZonedDateTime</code></p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于Java 8 Date / Time类与SQL类型之间的映射是隐式的，因此无需指定<code>@Temporal</code>注解。</p>
</div>
<div class="paragraph">
<p>设置在<code>java.time</code>类抛出以下异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.hibernate.AnnotationException: @Temporal should only be set on a java.util.Date or java.util.Calendar property</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="basic-datetime-time-zone"><a class="anchor" href="#basic-datetime-time-zone"></a>使用特定时区</h5>
<div class="paragraph">
<p>默认情况下，Hibernate将使用<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-"><code>PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)</code></a>要么<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-"><code>PreparedStatement.setTime(int parameterIndex, java.sql.Time x)</code></a>保存时<code>java.sql.Timestamp</code>或一个<code>java.sql.Time</code>属性。</p>
</div>
<div class="paragraph">
<p>如果未指定时区，则JDBC驱动程序将使用基础的JVM默认时区，如果在全球范围内使用该应用程序，则可能不适合。因此，每当从数据库中保存/加载数据时，通常都使用单个参考时区（例如UTC）。</p>
</div>
<div class="paragraph">
<p>一种替代方法是将所有JVM配置为使用参考时区：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">声明式地</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">java -Duser.timezone=UTC ...</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">以编程方式</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">TimeZone.setDefault( TimeZone.getTimeZone( "UTC" ) );</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>但是，如<a href="http://in.relation.to/2016/09/12/jdbc-time-zone-configuration-property/">本文所述</a> ，这并不总是可行的，尤其是对于前端节点。因此，Hibernate提供了<code>hibernate.jdbc.time_zone</code>可以配置的配置属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">声明性地，在<code>SessionFactory</code>水平</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">settings.put(
    AvailableSettings.JDBC_TIME_ZONE,
    TimeZone.getTimeZone( "UTC" )
);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">以编程方式<code>Session</code>基础</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Session session = sessionFactory()
    .withOptions()
    .jdbcTimeZone( TimeZone.getTimeZone( "UTC" ) )
    .openSession();</code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有了此配置属性后，Hibernate将调用<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-"><code>PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)</code></a>要么<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-java.util.Calendar-"><code>PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)</code></a> ，其中<code>java.util.Calendar</code>引用通过提供的时区<code>hibernate.jdbc.time_zone</code>属性。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic-jpa-convert"><a class="anchor" href="#basic-jpa-convert"></a> 2.3.16。JPA 2.1 AttributeConverters</h4>
<div class="paragraph">
<p>尽管Hibernate长期以来一直提供<a href="#basic-custom-type">自定义类型</a> ，但作为JPA 2.1提供程序，它也支持<code>AttributeConverter</code>也一样</p>
</div>
<div class="paragraph">
<p>自定义<code>AttributeConverter</code> ，应用程序开发人员可以将给定的JDBC类型映射到实体基本类型。</p>
</div>
<div class="paragraph">
<p>在以下示例中， <code>java.time.Period</code>将被映射到<code>VARCHAR</code>数据库列。</p>
</div>
<div id="basic-jpa-convert-period-string-converter-example" class="exampleblock">
<div class="title">示例58。 <code>java.time.Period</code>习俗<code>AttributeConverter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Converter
public class PeriodStringConverter
        implements AttributeConverter&lt;Period, String&gt; {

    @Override
    public String convertToDatabaseColumn(Period attribute) {
        return attribute.toString();
    }

    @Override
    public Period convertToEntityAttribute(String dbData) {
        return Period.parse( dbData );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用此自定义转换器， <code>@Convert</code>批注必须修饰实体属性。</p>
</div>
<div id="basic-jpa-convert-period-string-converter-mapping-example" class="exampleblock">
<div class="title">范例59。实体使用自定义<code>java.time.Period</code><code>AttributeConverter</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
public static class Event {

    @Id
    @GeneratedValue
    private Long id;

    @Convert(converter = PeriodStringConverter.class)
    @Column(columnDefinition = "")
    private Period span;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当持久化这样的实体时，Hibernate将基于<code>AttributeConverter</code>逻辑：</p>
</div>
<div id="basic-jpa-convert-period-string-converter-sql-example" class="exampleblock">
<div class="title">示例60使用自定义持久化实体<code>AttributeConverter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Event ( span, id )
VALUES ( 'P1Y2M3D', 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="basic-jpa-convert-type"><a class="anchor" href="#basic-jpa-convert-type"></a><code>AttributeConverter</code> Java和JDBC类型</h5>
<div class="paragraph">
<p>如果为转换的“数据库端”指定了Java类型（第二个<code>AttributeConverter</code>绑定参数）未知，Hibernate将回退到<code>java.io.Serializable</code>类型。</p>
</div>
<div class="paragraph">
<p>如果Hibernate不知道Java类型，您将遇到以下消息：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>HHH000481：遇到Java类型，我们无法为其找到JavaTypeDescriptor，并且似乎没有实现equals和/或hashCode。执行涉及此Java类型的相等/脏检查时，这可能导致严重的性能问题。考虑注册一个自定义JavaTypeDescriptor或至少实现equals / hashCode。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Java类型是否为“已知”意味着它在<code>JavaTypeDescriptorRegistry</code> 。默认情况下，Hibernate将许多JDK类型加载到<code>JavaTypeDescriptorRegistry</code> ，应用程序还可以扩展<code>JavaTypeDescriptorRegistry</code>通过添加新<code>JavaTypeDescriptor</code>条目。</p>
</div>
<div class="paragraph">
<p>这样，Hibernate也将知道如何在JDBC级别处理特定的Java对象类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="basic-jpa-convert-mutability"><a class="anchor" href="#basic-jpa-convert-mutability"></a> JPA 2.1 <code>AttributeConverter</code>可变性计划</h5>
<div class="paragraph">
<p>由JPA转换的基本类型<code>AttributeConverter</code>如果基础Java类型是不可变的，则为不可变；如果关联的属性类型也是可变的，则为可变。</p>
</div>
<div class="paragraph">
<p>因此，可变性由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/type/descriptor/java/JavaTypeDescriptor.html#getMutabilityPlan--"><code>JavaTypeDescriptor#getMutabilityPlan</code></a>关联的实体属性类型。</p>
</div>
<div class="sect5">
<h6 id="_immutable_types"><a class="anchor" href="#_immutable_types"></a>不变类型</h6>
<div class="paragraph">
<p>如果实体属性是<code>String</code> ，原始包装器（例如<code>Integer</code> ， <code>Long</code> ）枚举类型或任何其他不可变的类型<code>Object</code>类型，则只能通过将其重新分配为新值来更改实体属性值。</p>
</div>
<div class="paragraph">
<p>考虑到我们有相同的<code>Period</code>实体属性，如“ <a href="#basic-jpa-convert">JPA 2.1 AttributeConverters”</a>部分中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
public static class Event {

    @Id
    @GeneratedValue
    private Long id;

    @Convert(converter = PeriodStringConverter.class)
    @Column(columnDefinition = "")
    private Period span;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>改变的唯一方法<code>span</code>属性是将其重新分配为其他值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Event event = entityManager.createQuery( "from Event", Event.class ).getSingleResult();
event.setSpan(Period
    .ofYears( 3 )
    .plusMonths( 2 )
    .plusDays( 1 )
);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_mutable_types"><a class="anchor" href="#_mutable_types"></a>可变类型</h6>
<div class="paragraph">
<p>另一方面，请考虑以下示例，其中<code>Money</code>类型是可变的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class Money {

	private long cents;

	//Getters and setters are omitted for brevity
}

@Entity(name = "Account")
public static class Account {

	@Id
	private Long id;

	private String owner;

	@Convert(converter = MoneyConverter.class)
	private Money balance;

	//Getters and setters are omitted for brevity
}

public static class MoneyConverter
		implements AttributeConverter&lt;Money, Long&gt; {

	@Override
	public Long convertToDatabaseColumn(Money attribute) {
		return attribute == null ? null : attribute.getCents();
	}

	@Override
	public Money convertToEntityAttribute(Long dbData) {
		return dbData == null ? null : new Money( dbData );
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>易变的<code>Object</code>允许您修改其内部结构，并且Hibernate脏检查机制将更改传播到数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Account account = entityManager.find( Account.class, 1L );
account.getBalance().setCents( 150 * 100L );
entityManager.persist( account );</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然<code>AttributeConverter</code>类型可以是可变的，因此脏检查，深度复制和二级缓存可以正常工作，将它们视为不可变的（实际上是不可变的）更为有效。</p>
</div>
<div class="paragraph">
<p>因此，在可能的情况下，最好使用不可变类型而不是可变类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping-quoted-identifiers"><a class="anchor" href="#mapping-quoted-identifiers"></a> 2.3.17。SQL带引号的标识符</h4>
<div class="paragraph">
<p>您可以通过将表名或列名放在映射文档中的反引号中来强制Hibernate在生成的SQL中引用标识符。传统上，Hibernate使用反引号转义SQL保留关键字，而JPA则使用双引号。</p>
</div>
<div class="paragraph">
<p>一旦保留关键字被转义，Hibernate将为SQL使用正确的引号样式<code>Dialect</code> 。这通常是双引号，但是SQL Server使用方括号，而MySQL使用反引号。</p>
</div>
<div id="basic-quoting-example" class="exampleblock">
<div class="title">例子61。Hibernate旧版报价</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Long id;

	@Column(name = "`name`")
	private String name;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div id="basic-jpa-quoting-example" class="exampleblock">
<div class="title">例子62。JPA报价</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Long id;

	@Column(name = "\"name\"")
	private String name;

	@Column(name = "\"number\"")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为<code>name</code>和<code>number</code>是保留字， <code>Product</code>实体映射使用反引号引用这些列名称。</p>
</div>
<div class="paragraph">
<p>保存以下内容时<code>Product entity</code> ，Hibernate生成以下SQL插入语句：</p>
</div>
<div id="basic-quoting-persistence-example" class="exampleblock">
<div class="title">示例63。保留带引号的列名</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product product = new Product();
product.setId( 1L );
product.setName( "Mobile phone" );
product.setNumber( "123-456-7890" );
entityManager.persist( product );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Product ("name", "number", id)
VALUES ('Mobile phone', '123-456-7890', 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-global-quoted-identifiers"><a class="anchor" href="#mapping-global-quoted-identifiers"></a>全局报价</h5>
<div class="paragraph">
<p>Hibernate还可以使用以下配置属性引用所有标识符（例如，表，列）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property
    name="hibernate.globally_quoted_identifiers"
    value="true"
/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，我们不需要手动引用任何标识符：</p>
</div>
<div id="basic-auto-quoting-example" class="exampleblock">
<div class="title">示例64。JPA报价</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Long id;

	private String name;

	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当坚持一个<code>Product</code>实体，Hibernate将引用所有标识符，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO "Product" ("name", "number", "id")
VALUES ('Mobile phone', '123-456-7890', 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，表名和所有列均已被引用。</p>
</div>
<div class="paragraph">
<p>有关与报价相关的配置属性的更多信息，请同时查看“ <a href="#configurations-mapping">映射配置”</a>部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping-generated"><a class="anchor" href="#mapping-generated"></a> 2.3.18。生成的属性</h4>
<div class="paragraph">
<p>生成的属性是其值由数据库生成的属性。通常，Hibernate应用程序需要<code>refresh</code>包含数据库为其生成值的任何属性的对象。但是，将属性标记为已生成，可以使应用程序将此职责委派给Hibernate。当Hibernate对已定义生成属性的实体发出SQL INSERT或UPDATE时，它将立即发出选择以检索生成的值。</p>
</div>
<div class="paragraph">
<p>标记为已生成的属性还必须<em>不可插入</em>且<em>不可更新</em> 。只要<code>@Version</code>和<code>@Basic</code>类型可以标记为已生成。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NEVER</code> （默认）</dt>
<dd>
<p>给定的属性值不在数据库内生成。</p>
</dd>
<dt class="hdlist1"><code>INSERT</code></dt>
<dd>
<p>给定的属性值在插入时生成，但在后续更新中不会重新生成。诸如<em>creationTimestamp之</em>类的属性都属于此类。</p>
</dd>
<dt class="hdlist1"><code>ALWAYS</code></dt>
<dd>
<p>属性值是在插入和更新时生成的。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>要将属性标记为已生成，请使用特定于Hibernate的属性<code>@Generated</code>注解。</p>
</div>
<div class="sect4">
<h5 id="mapping-generated-Generated"><a class="anchor" href="#mapping-generated-Generated"></a><code>@Generated</code>注解</h5>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Generated.html"><code>@Generated</code></a>使用注释，以便在持久化或更新实体后，Hibernate可以获取当前已注释的属性。因此， <code>@Generated</code>批注接受<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenerationTime.html"><code>GenerationTime</code></a>枚举值。</p>
</div>
<div class="paragraph">
<p>考虑以下实体：</p>
</div>
<div id="mapping-generated-Generated-example" class="exampleblock">
<div class="title">示例65。 <code>@Generated</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	private String middleName1;

	private String middleName2;

	private String middleName3;

	private String middleName4;

	private String middleName5;

	@Generated( value = GenerationTime.ALWAYS )
	@Column(columnDefinition =
		"AS CONCAT(" +
		"	COALESCE(firstName, ''), " +
		"	COALESCE(' ' + middleName1, ''), " +
		"	COALESCE(' ' + middleName2, ''), " +
		"	COALESCE(' ' + middleName3, ''), " +
		"	COALESCE(' ' + middleName4, ''), " +
		"	COALESCE(' ' + middleName5, ''), " +
		"	COALESCE(' ' + lastName, '') " +
		")")
	private String fullName;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>Person</code>实体被保留，Hibernate将获取计算的<code>fullName</code>数据库中的列，该列连接名字，中间名和姓氏。</p>
</div>
<div id="mapping-generated-Generated-persist-example" class="exampleblock">
<div class="title">例子66。 <code>@Generated</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setFirstName( "John" );
person.setMiddleName1( "Flávio" );
person.setMiddleName2( "André" );
person.setMiddleName3( "Frederico" );
person.setMiddleName4( "Rúben" );
person.setMiddleName5( "Artur" );
person.setLastName( "Doe" );

entityManager.persist( person );
entityManager.flush();

assertEquals("John Flávio André Frederico Rúben Artur Doe", person.getFullName());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person
(
    firstName,
    lastName,
    middleName1,
    middleName2,
    middleName3,
    middleName4,
    middleName5,
    id
)
values
(?, ?, ?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [John]
-- binding parameter [2] as [VARCHAR] - [Doe]
-- binding parameter [3] as [VARCHAR] - [Flávio]
-- binding parameter [4] as [VARCHAR] - [André]
-- binding parameter [5] as [VARCHAR] - [Frederico]
-- binding parameter [6] as [VARCHAR] - [Rúben]
-- binding parameter [7] as [VARCHAR] - [Artur]
-- binding parameter [8] as [BIGINT]  - [1]

SELECT
    p.fullName as fullName3_0_
FROM
    Person p
WHERE
    p.id=?

-- binding parameter [1] as [BIGINT] - [1]
-- extracted value ([fullName3_0_] : [VARCHAR]) - [John Flávio André Frederico Rúben Artur Doe]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当<code>Person</code>实体已更新。Hibernate将获取计算的<code>fullName</code>修改实体后从数据库中选择列。</p>
</div>
<div id="mapping-generated-Generated-update-example" class="exampleblock">
<div class="title">例子67。 <code>@Generated</code>更新示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
person.setLastName( "Doe Jr" );

entityManager.flush();
assertEquals("John Flávio André Frederico Rúben Artur Doe Jr", person.getFullName());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE
    Person
SET
    firstName=?,
    lastName=?,
    middleName1=?,
    middleName2=?,
    middleName3=?,
    middleName4=?,
    middleName5=?
WHERE
    id=?

-- binding parameter [1] as [VARCHAR] - [John]
-- binding parameter [2] as [VARCHAR] - [Doe Jr]
-- binding parameter [3] as [VARCHAR] - [Flávio]
-- binding parameter [4] as [VARCHAR] - [André]
-- binding parameter [5] as [VARCHAR] - [Frederico]
-- binding parameter [6] as [VARCHAR] - [Rúben]
-- binding parameter [7] as [VARCHAR] - [Artur]
-- binding parameter [8] as [BIGINT]  - [1]

SELECT
    p.fullName as fullName3_0_
FROM
    Person p
WHERE
    p.id=?

-- binding parameter [1] as [BIGINT] - [1]
-- extracted value ([fullName3_0_] : [VARCHAR]) - [John Flávio André Frederico Rúben Artur Doe Jr]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-generated-GeneratorType"><a class="anchor" href="#mapping-generated-GeneratorType"></a><code>@GeneratorType</code>注解</h5>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GeneratorType.html"><code>@GeneratorType</code></a>使用注释，以便您可以提供一个自定义生成器来设置当前带注释的属性的值。</p>
</div>
<div class="paragraph">
<p>因此， <code>@GeneratorType</code>批注接受<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenerationTime.html"><code>GenerationTime</code></a>枚举值和自定义<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ValueGenerator.html"><code>ValueGenerator</code></a>类类型。</p>
</div>
<div class="paragraph">
<p>考虑以下实体：</p>
</div>
<div id="mapping-generated-GeneratorType-example" class="exampleblock">
<div class="title">示例68。 <code>@GeneratorType</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CurrentUser {

	public static final CurrentUser INSTANCE = new CurrentUser();

	private static final ThreadLocal&lt;String&gt; storage = new ThreadLocal&lt;&gt;();

	public void logIn(String user) {
		storage.set( user );
	}

	public void logOut() {
		storage.remove();
	}

	public String get() {
		return storage.get();
	}
}

public static class LoggedUserGenerator implements ValueGenerator&lt;String&gt; {

	@Override
	public String generateValue(
			Session session, Object owner) {
		return CurrentUser.INSTANCE.get();
	}
}

@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	@GeneratorType( type = LoggedUserGenerator.class, when = GenerationTime.INSERT)
	private String createdBy;

	@GeneratorType( type = LoggedUserGenerator.class, when = GenerationTime.ALWAYS)
	private String updatedBy;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>Person</code>实体持续存在，Hibernate将填充<code>createdBy</code>当前登录用户的列。</p>
</div>
<div id="mapping-generated-GeneratorType-persist-example" class="exampleblock">
<div class="title">示例69。 <code>@Generated</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CurrentUser.INSTANCE.logIn( "Alice" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {

	Person person = new Person();
	person.setId( 1L );
	person.setFirstName( "John" );
	person.setLastName( "Doe" );

	entityManager.persist( person );
} );

CurrentUser.INSTANCE.logOut();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person
(
    createdBy,
    firstName,
    lastName,
    updatedBy,
    id
)
VALUES
(?, ?, ?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Alice]
-- binding parameter [2] as [VARCHAR] - [John]
-- binding parameter [3] as [VARCHAR] - [Doe]
-- binding parameter [4] as [VARCHAR] - [Alice]
-- binding parameter [5] as [BIGINT]  - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当<code>Person</code>实体已更新。Hibernate将填充<code>updatedBy</code>当前登录用户的列。</p>
</div>
<div id="mapping-generated-GeneratorType-update-example" class="exampleblock">
<div class="title">示例70。 <code>@Generated</code>更新示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CurrentUser.INSTANCE.logIn( "Bob" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Person person = entityManager.find( Person.class, 1L );
	person.setFirstName( "Mr. John" );
} );

CurrentUser.INSTANCE.logOut();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE Person
SET
    createdBy = ?,
    firstName = ?,
    lastName = ?,
    updatedBy = ?
WHERE
    id = ?

-- binding parameter [1] as [VARCHAR] - [Alice]
-- binding parameter [2] as [VARCHAR] - [Mr. John]
-- binding parameter [3] as [VARCHAR] - [Doe]
-- binding parameter [4] as [VARCHAR] - [Bob]
-- binding parameter [5] as [BIGINT]  - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-generated-CreationTimestamp"><a class="anchor" href="#mapping-generated-CreationTimestamp"></a><code>@CreationTimestamp</code>注解</h5>
<div class="paragraph">
<p>的<code>@CreationTimestamp</code>当实体持久化时，注解指示Hibernate用JVM的当前时间戳值设置带注释的实体属性。</p>
</div>
<div class="paragraph">
<p>支持的属性类型为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
</ul>
</div>
<div id="mapping-generated-CreationTimestamp-example" class="exampleblock">
<div class="title">例子71。 <code>@CreationTimestamp</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
public static class Event {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`timestamp`")
	@CreationTimestamp
	private Date timestamp;

	//Constructors, getters, and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>Event</code>实体被持久化，Hibernate将填充基础<code>timestamp</code>当前JVM时间戳值的列：</p>
</div>
<div id="mapping-generated-CreationTimestamp-persist-example" class="exampleblock">
<div class="title">例子72。 <code>@CreationTimestamp</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Event dateEvent = new Event( );
entityManager.persist( dateEvent );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Event ("timestamp", id)
VALUES (?, ?)

-- binding parameter [1] as [TIMESTAMP] - [Tue Nov 15 16:24:20 EET 2016]
-- binding parameter [2] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-generated-UpdateTimestamp"><a class="anchor" href="#mapping-generated-UpdateTimestamp"></a><code>@UpdateTimestamp</code>注解</h5>
<div class="paragraph">
<p>的<code>@UpdateTimestamp</code>当实体持久化时，注解指示Hibernate用JVM的当前时间戳值设置带注释的实体属性。</p>
</div>
<div class="paragraph">
<p>支持的属性类型为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
</ul>
</div>
<div id="mapping-generated-UpdateTimestamp-example" class="exampleblock">
<div class="title">示例73。 <code>@UpdateTimestamp</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Bid")
public static class Bid {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "updated_on")
	@UpdateTimestamp
	private Date updatedOn;

	@Column(name = "updated_by")
	private String updatedBy;

	private Long cents;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>Bid</code>实体被持久化，Hibernate将填充基础<code>updated_on</code>当前JVM时间戳值的列：</p>
</div>
<div id="mapping-generated-UpdateTimestamp-persist-example" class="exampleblock">
<div class="title">示例74。 <code>@UpdateTimestamp</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Bid bid = new Bid();
bid.setUpdatedBy( "John Doe" );
bid.setCents( 150 * 100L );
entityManager.persist( bid );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Bid (cents, updated_by, updated_on, id)
VALUES (?, ?, ?, ?)

-- binding parameter [1] as [BIGINT]    - [15000]
-- binding parameter [2] as [VARCHAR]   - [John Doe]
-- binding parameter [3] as [TIMESTAMP] - [Tue Apr 18 17:21:46 EEST 2017]
-- binding parameter [4] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更新时<code>Bid</code>实体，Hibernate将修改<code>updated_on</code>当前JVM时间戳值的列：</p>
</div>
<div id="mapping-generated-UpdateTimestamp-update-example" class="exampleblock">
<div class="title">例子75。 <code>@UpdateTimestamp</code>更新示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Bid bid = entityManager.find( Bid.class, 1L );

bid.setUpdatedBy( "John Doe Jr." );
bid.setCents( 160 * 100L );
entityManager.persist( bid );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE Bid SET
    cents = ?,
    updated_by = ?,
    updated_on = ?
where
    id = ?

-- binding parameter [1] as [BIGINT]    - [16000]
-- binding parameter [2] as [VARCHAR]   - [John Doe Jr.]
-- binding parameter [3] as [TIMESTAMP] - [Tue Apr 18 17:49:24 EEST 2017]
-- binding parameter [4] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-generated-ValueGenerationType"><a class="anchor" href="#mapping-generated-ValueGenerationType"></a><code>@ValueGenerationType</code>元注释</h5>
<div class="paragraph">
<p>Hibernate 4.3引入了<code>@ValueGenerationType</code>元注释，这是一种声明生成的属性或自定义生成器的新方法。</p>
</div>
<div class="paragraph">
<p><code>@Generated</code>已经过改装以使用<code>@ValueGenerationType</code>元注释。但<code>@ValueGenerationType</code>暴露的功能比什么更多<code>@Generated</code>当前支持，并利用其中的某些功能，您只需连接一个新的生成器注释。</p>
</div>
<div class="paragraph">
<p>如以下示例所示， <code>@ValueGenerationType</code>声明用于标记需要特定生成策略的实体属性的自定义注释时，将使用meta-annotation。必须将实际的生成逻辑添加到实现<code>AnnotationValueGeneration</code>接口。</p>
</div>
<div class="sect5">
<h6 id="mapping-database-generated-value"><a class="anchor" href="#mapping-database-generated-value"></a>数据库生成的值</h6>
<div class="paragraph">
<p>例如，假设我们希望通过对标准ANSI SQL函数的调用来生成时间戳<code>current_timestamp</code> （而不是触发器或DEFAULT值）：</p>
</div>
<div id="mapping-database-generated-value-example" class="exampleblock">
<div class="title">例子76。一种<code>ValueGenerationType</code>映射以生成数据库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
public static class Event {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`timestamp`")
	@FunctionCreationTimestamp
	private Date timestamp;

	//Constructors, getters, and setters are omitted for brevity
}

@ValueGenerationType(generatedBy = FunctionCreationValueGeneration.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface FunctionCreationTimestamp {}

public static class FunctionCreationValueGeneration
		implements AnnotationValueGeneration&lt;FunctionCreationTimestamp&gt; {

	@Override
	public void initialize(FunctionCreationTimestamp annotation, Class&lt;?&gt; propertyType) {
	}

	/**
	 * Generate value on INSERT
	 * @return when to generate the value
	 */
	public GenerationTiming getGenerationTiming() {
		return GenerationTiming.INSERT;
	}

	/**
	 * Returns null because the value is generated by the database.
	 * @return null
	 */
	public ValueGenerator&lt;?&gt; getValueGenerator() {
		return null;
	}

	/**
	 * Returns true because the value is generated by the database.
	 * @return true
	 */
	public boolean referenceColumnInSql() {
		return true;
	}

	/**
	 * Returns the database-generated value
	 * @return database-generated value
	 */
	public String getDatabaseGeneratedReferencedColumnValue() {
		return "current_timestamp";
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当坚持<code>Event</code>实体，Hibernate生成以下SQL语句：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Event ("timestamp", id)
VALUES (current_timestamp, 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>current_timestamp</code>值用于分配<code>timestamp</code>列值。</p>
</div>
</div>
<div class="sect5">
<h6 id="mapping-in-memory-generated-value"><a class="anchor" href="#mapping-in-memory-generated-value"></a>内存中生成的值</h6>
<div class="paragraph">
<p>如果需要在内存中生成时间戳记值，则必须使用以下映射：</p>
</div>
<div id="mapping-in-memory-generated-value-example" class="exampleblock">
<div class="title">例子77。一种<code>ValueGenerationType</code>映射以实现内存中的价值生成</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
public static class Event {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`timestamp`")
	@FunctionCreationTimestamp
	private Date timestamp;

	//Constructors, getters, and setters are omitted for brevity
}

@ValueGenerationType(generatedBy = FunctionCreationValueGeneration.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface FunctionCreationTimestamp {}

public static class FunctionCreationValueGeneration
		implements AnnotationValueGeneration&lt;FunctionCreationTimestamp&gt; {

	@Override
	public void initialize(FunctionCreationTimestamp annotation, Class&lt;?&gt; propertyType) {
	}

	/**
	 * Generate value on INSERT
	 * @return when to generate the value
	 */
	public GenerationTiming getGenerationTiming() {
		return GenerationTiming.INSERT;
	}

	/**
	 * Returns the in-memory generated value
	 * @return {@code true}
	 */
	public ValueGenerator&lt;?&gt; getValueGenerator() {
		return (session, owner) -&gt; new Date( );
	}

	/**
	 * Returns false because the value is generated by the database.
	 * @return false
	 */
	public boolean referenceColumnInSql() {
		return false;
	}

	/**
	 * Returns null because the value is generated in-memory.
	 * @return null
	 */
	public String getDatabaseGeneratedReferencedColumnValue() {
		return null;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当坚持<code>Event</code>实体，Hibernate生成以下SQL语句：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Event ("timestamp", id)
VALUES ('Tue Mar 01 10:58:18 EET 2016', 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>new Date()</code>对象值用于分配<code>timestamp</code>列值。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping-column-read-and-write"><a class="anchor" href="#mapping-column-read-and-write"></a> 2.3.19。列转换器：读取和写入表达式</h4>
<div class="paragraph">
<p>Hibernate允许您自定义用于读取和写入映射到的列的值的SQL <code>@Basic</code>类型。例如，如果您的数据库提供了一组数据加密功能，则可以像下面的示例一样为各个列调用它们。</p>
</div>
<div id="mapping-column-read-and-write-example" class="exampleblock">
<div class="title">示例78。 <code>@ColumnTransformer</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Employee")
public static class Employee {

	@Id
	private Long id;

	@NaturalId
	private String username;

	@Column(name = "pswd")
	@ColumnTransformer(
		read = "decrypt( 'AES', '00', pswd  )",
		write = "encrypt('AES', '00', ?)"
	)
	private String password;

	private int accessLevel;

	@ManyToOne(fetch = FetchType.LAZY)
	private Department department;

	@ManyToMany(mappedBy = "employees")
	private List&lt;Project&gt; projects = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果属性使用多个列，则必须使用<code>forColumn</code>用于指定哪一列的属性<code>@ColumnTransformer</code>读写表达式是针对的。</p>
</div>
<div id="mapping-column-read-and-write-composite-type-example" class="exampleblock">
<div class="title">示例79。 <code>@ColumnTransformer</code><code>forColumn</code>属性用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Savings")
public static class Savings {

	@Id
	private Long id;

	@Type(type = "org.hibernate.userguide.mapping.basic.MonetaryAmountUserType")
	@Columns(columns = {
		@Column(name = "money"),
		@Column(name = "currency")
	})
	@ColumnTransformer(
		forColumn = "money",
		read = "money / 100",
		write = "? * 100"
	)
	private MonetaryAmount wallet;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只要在查询中引用了属性，Hibernate就会自动应用自定义表达式。此功能类似于派生属性<a href="#mapping-column-formula"><code>@Formula</code></a>有两个区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该属性由作为自动模式生成的一部分导出的一列或多列支持。</p>
</li>
<li>
<p>该属性是可读写的，而不是只读的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>write</code>表达式（如果指定）必须恰好包含一个'？'占位符。</p>
</div>
<div id="mapping-column-read-and-write-composite-type-persistence-example" class="exampleblock">
<div class="title">示例80。用<code>@ColumnTransformer</code>和复合类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Savings savings = new Savings( );
	savings.setId( 1L );
	savings.setWallet( new MonetaryAmount( BigDecimal.TEN, Currency.getInstance( Locale.US ) ) );
	entityManager.persist( savings );
} );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Savings savings = entityManager.find( Savings.class, 1L );
	assertEquals( 10, savings.getWallet().getAmount().intValue());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Savings (money, currency, id)
VALUES (10 * 100, 'USD', 1)

SELECT
    s.id as id1_0_0_,
    s.money / 100 as money2_0_0_,
    s.currency as currency3_0_0_
FROM
    Savings s
WHERE
    s.id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping-column-formula"><a class="anchor" href="#mapping-column-formula"></a> 2.3.20。<code>@Formula</code></h4>
<div class="paragraph">
<p>有时，您希望数据库为您执行一些计算，而不是在JVM中进行计算，您可能还会创建某种虚拟列。您可以使用SQL片段（也称为公式）来代替将属性映射到列中。这种属性是只读的（其值由您的公式片段计算）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您应该注意<code>@Formula</code>批注采用本机SQL子句，这可能会影响数据库的可移植性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="mapping-column-formula-example" class="exampleblock">
<div class="title">例子81。 <code>@Formula</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Account")
public static class Account {

	@Id
	private Long id;

	private Double credit;

	private Double rate;

	@Formula(value = "credit * rate")
	private Double interest;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>加载时<code>Account</code>实体，Hibernate将要计算<code>interest</code>使用已配置的属性<code>@Formula</code> ：</p>
</div>
<div id="mapping-column-formula-persistence-example" class="exampleblock">
<div class="title">示例82。用<code>@Formula</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Account account = new Account( );
	account.setId( 1L );
	account.setCredit( 5000d );
	account.setRate( 1.25 / 100 );
	entityManager.persist( account );
} );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Account account = entityManager.find( Account.class, 1L );
	assertEquals( Double.valueOf( 62.5d ), account.getInterest());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Account (credit, rate, id)
VALUES (5000.0, 0.0125, 1)

SELECT
    a.id as id1_0_0_,
    a.credit as credit2_0_0_,
    a.rate as rate3_0_0_,
    a.credit * a.rate as formula0_0_
FROM
    Account a
WHERE
    a.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由<code>@Formula</code>批注可以随您所需而复杂，甚至可以包括子选择。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="embeddables"><a class="anchor" href="#embeddables"></a> 2.4。可嵌入类型</h3>
<div class="paragraph">
<p>Hibernate历史上称这些组件。JPA称它们为可嵌入对象。无论哪种方式，概念都是相同的：价值构成。</p>
</div>
<div class="paragraph">
<p>例如，我们可能有一个<code>Publisher</code>组成的类<code>name</code>和<code>country</code>或<code>Location</code>组成的类<code>country</code>和<code>city</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title"><em>可嵌入</em>一词的用法</div>
<div class="paragraph">
<p>为了避免与标记给定可嵌入类型的注释产生任何混淆，该注释将进一步称为<code>@Embeddable</code> 。</p>
</div>
<div class="paragraph">
<p>在本章中，此后，为了简洁起见，可嵌入的类型也可被称为<em>嵌入</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="embeddable-type-mapping-example" class="exampleblock">
<div class="title">示例83。可嵌入类型的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Embeddable
public static class Publisher {

	private String name;

	private Location location;

	public Publisher(String name, Location location) {
		this.name = name;
		this.location = location;
	}

	private Publisher() {}

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class Location {

	private String country;

	private String city;

	public Location(String country, String city) {
		this.country = country;
		this.city = city;
	}

	private Location() {}

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可嵌入类型是值类型的另一种形式，其生命周期绑定到父实体类型，因此从其父类继承属性访问（有关属性访问的详细信息，请参阅<a href="#access-embeddable-types">访问策略</a> ）。</p>
</div>
<div class="paragraph">
<p>可嵌入类型可以由基本值以及关联组成，但需要注意的是，当用作集合元素时，它们不能自己定义集合。</p>
</div>
<div class="sect3">
<h4 id="_component_embedded"><a class="anchor" href="#_component_embedded"></a> 2.4.1。组件/嵌入式</h4>
<div class="paragraph">
<p>通常，可嵌入类型用于对多个基本类型映射进行分组，并在多个实体之间重用它们。</p>
</div>
<div id="simple-embeddable-type-mapping-example" class="exampleblock">
<div class="title">示例84。简单的可嵌入</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	private Publisher publisher;

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class Publisher {

	@Column(name = "publisher_name")
	private String name;

	@Column(name = "publisher_country")
	private String country;

	//Getters and setters, equals and hashCode methods omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table Book (
    id bigint not null,
    author varchar(255),
    publisher_country varchar(255),
    publisher_name varchar(255),
    title varchar(255),
    primary key (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA为使用可嵌入类型定义了两个术语： <code>@Embeddable</code>和<code>@Embedded</code> 。</p>
</div>
<div class="paragraph">
<p><code>@Embeddable</code>用于描述映射类型本身（例如<code>Publisher</code> ）。</p>
</div>
<div class="paragraph">
<p><code>@Embedded</code>用于引用给定的可嵌入类型（例如<code>book.publisher</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，可嵌入类型由<code>Publisher</code>类，父实体通过<code>book#publisher</code>对象组成。</p>
</div>
<div class="paragraph">
<p>组合值映射到与父表相同的表。组合是良好的面向对象数据建模（惯用Java）的一部分。实际上，该表也可以由以下实体类型映射。</p>
</div>
<div id="alternative-to-embeddable-type-mapping-example" class="exampleblock">
<div class="title">示例85。嵌入式类型组成的替代</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	@Column(name = "publisher_name")
	private String publisherName;

	@Column(name = "publisher_country")
	private String publisherCountry;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>组合形式当然更面向对象，并且在我们使用多个可嵌入类型时，这一点变得更加明显。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-multiple"><a class="anchor" href="#embeddable-multiple"></a> 2.4.2。多种可嵌入类型</h4>
<div class="paragraph">
<p>尽管从面向对象的角度来看，使用可嵌入类型要方便得多，但是此示例无法按原样工作。当同一父实体类型中多次包含同一可嵌入类型时，JPA规范要求明确设置关联的列名称。</p>
</div>
<div class="paragraph">
<p>此要求是由于如何将对象属性映射到数据库列。默认情况下，JPA希望数据库列与其关联的对象属性具有相同的名称。当包含多个可嵌入对象时，基于隐式基于名称的映射规则不再起作用，因为多个对象属性最终可能会映射到同一数据库列。</p>
</div>
<div class="paragraph">
<p>我们有一些解决方案。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-override"><a class="anchor" href="#embeddable-override"></a> 2.4.3。覆盖可嵌入类型</h4>
<div class="paragraph">
<p>JPA定义了<code>@AttributeOverride</code>注释来处理这种情况。这样，可以通过设置显式的基于名称的属性-列类型映射来解决映射冲突。</p>
</div>
<div class="paragraph">
<p>如果某个实体多次使用Embeddable类型，则需要使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AttributeOverride.html"><code>@AttributeOverride</code></a>和<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AssociationOverride.html"><code>@AssociationOverride</code></a>注释以覆盖Embeddable定义的默认列名称。</p>
</div>
<div class="paragraph">
<p>考虑到你有以下几点<code>Publisher</code>可嵌入的类型定义了<code>@ManyToOne</code>与...的关联<code>Country</code>实体：</p>
</div>
<div id="embeddable-type-association-mapping-example" class="exampleblock">
<div class="title">示例86。可嵌入类型<code>@ManyToOne</code>协会</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Embeddable
public static class Publisher {

	private String name;

	@ManyToOne(fetch = FetchType.LAZY)
	private Country country;

	//Getters and setters, equals and hashCode methods omitted for brevity

}

@Entity(name = "Country")
public static class Country {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	private String name;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table Country (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

alter table Country
    add constraint UK_p1n05aafu73sbm3ggsxqeditd
    unique (name)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，如果您有<code>Book</code>声明两个的实体<code>Publisher</code>电子书和平装本的可嵌入类型，您不能使用默认<code>Publisher</code>可嵌入的映射，因为两个可嵌入的列映射之间会有冲突。</p>
</div>
<div class="paragraph">
<p>因此， <code>Book</code>实体需要覆盖每个实体的可嵌入类型映射<code>Publisher</code>属性：</p>
</div>
<div id="embeddable-type-override-mapping-example" class="exampleblock">
<div class="title">例子87。覆盖可嵌入类型属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
@AttributeOverrides({
	@AttributeOverride(
		name = "ebookPublisher.name",
		column = @Column(name = "ebook_publisher_name")
	),
	@AttributeOverride(
		name = "paperBackPublisher.name",
		column = @Column(name = "paper_back_publisher_name")
	)
})
@AssociationOverrides({
	@AssociationOverride(
		name = "ebookPublisher.country",
		joinColumns = @JoinColumn(name = "ebook_publisher_country_id")
	),
	@AssociationOverride(
		name = "paperBackPublisher.country",
		joinColumns = @JoinColumn(name = "paper_back_publisher_country_id")
	)
})
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	private Publisher ebookPublisher;

	private Publisher paperBackPublisher;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table Book (
    id bigint not null,
    author varchar(255),
    ebook_publisher_name varchar(255),
    paper_back_publisher_name varchar(255),
    title varchar(255),
    ebook_publisher_country_id bigint,
    paper_back_publisher_country_id bigint,
    primary key (id)
)

alter table Book
    add constraint FKm39ibh5jstybnslaoojkbac2g
    foreign key (ebook_publisher_country_id)
    references Country

alter table Book
    add constraint FK7kqy9da323p7jw7wvqgs6aek7
    foreign key (paper_back_publisher_country_id)
    references Country</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-multiple-namingstrategy"><a class="anchor" href="#embeddable-multiple-namingstrategy"></a> 2.4.4。嵌入式和隐式命名策略</h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>ImplicitNamingStrategyComponentPathImpl</code>是特定于Hibernate的功能。关心JPA提供程序可移植性的用户应改为使用显式列命名<code>@AttributeOverride</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate的命名策略在详细介绍<a href="#naming">命名</a> 。但是，出于本讨论的目的，Hibernate能够以对于多种可嵌入类型都可以安全使用的方式解释隐式列名。</p>
</div>
<div id="embeddable-multiple-namingstrategy-entity-mapping" class="exampleblock">
<div class="title">例子88。隐式多个可嵌入类型映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	private Publisher ebookPublisher;

	private Publisher paperBackPublisher;

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class Publisher {

	private String name;

	@ManyToOne(fetch = FetchType.LAZY)
	private Country country;

	//Getters and setters, equals and hashCode methods omitted for brevity
}

@Entity(name = "Country")
public static class Country {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	private String name;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使其正常工作，您需要使用<code>ImplicitNamingStrategyComponentPathImpl</code>命名策略。</p>
</div>
<div id="embeddable-multiple-ImplicitNamingStrategyComponentPathImpl" class="exampleblock">
<div class="title">示例89。使用组件路径命名策略启用隐式可嵌入类型映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">metadataBuilder.applyImplicitNamingStrategy(
	ImplicitNamingStrategyComponentPathImpl.INSTANCE
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，隐式列命名中使用了属性的“路径”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table Book (
    id bigint not null,
    author varchar(255),
    ebookPublisher_name varchar(255),
    paperBackPublisher_name varchar(255),
    title varchar(255),
    ebookPublisher_country_id bigint,
    paperBackPublisher_country_id bigint,
    primary key (id)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以开发自己的命名策略来执行其他类型的隐式命名策略。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-collections"><a class="anchor" href="#embeddable-collections"></a> 2.4.5。可嵌入类型的集合</h4>
<div class="paragraph">
<p>可嵌入类型的集合是特定值的集合（因为可嵌入类型是值类型）。值集合中详细介绍了<a href="#collections-value">值类型的集合</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-mapkey"><a class="anchor" href="#embeddable-mapkey"></a> 2.4.6。可嵌入类型作为Map键</h4>
<div class="paragraph">
<p>嵌入类型也可以用作<code>Map</code>键。该主题在<a href="#collections-map">Map-key</a>中进行了详细转换。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-identifier"><a class="anchor" href="#embeddable-identifier"></a> 2.4.7。可嵌入类型作为标识符</h4>
<div class="paragraph">
<p>可嵌入类型也可以用作实体类型标识符。<a href="#identifiers-composite">复合标识符</a>中详细介绍了此用法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>用作集合条目，映射键或实体类型标识符的可嵌入类型不能包含其自己的集合映射。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-Target"><a class="anchor" href="#embeddable-Target"></a> 2.4.8。 <code>@Target</code>映射</h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Target.html"><code>@Target</code></a>批注用于指定通过接口映射的给定关联的实现类。的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ManyToOne.html"><code>@ManyToOne</code></a> ， <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OneToOne.html"><code>@OneToOne</code></a> ， <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OneToMany.html"><code>@OneToMany</code></a>和<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ManyToMany.html"><code>@ManyToMany</code></a>具有<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ManyToOne.html#targetEntity--"><code>targetEntity</code></a>属性，用于在将接口用于映射时指定实体关联的实际类。</p>
</div>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ElementCollection.html"><code>@ElementCollection</code></a>协会有一个<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ElementCollection.html#targetClass--"><code>targetClass</code></a>具有相同目的的属性。</p>
</div>
<div class="paragraph">
<p>但是，对于简单的可嵌入类型，没有这样的构造，因此您需要使用特定于Hibernate的<code>@Target</code>注解。</p>
</div>
<div id="embeddable-Target-example" class="exampleblock">
<div class="title">示例90。 <code>@Target</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface Coordinates {
	double x();
	double y();
}

@Embeddable
public static class GPS implements Coordinates {

	private double latitude;

	private double longitude;

	private GPS() {
	}

	public GPS(double latitude, double longitude) {
		this.latitude = latitude;
		this.longitude = longitude;
	}

	@Override
	public double x() {
		return latitude;
	}

	@Override
	public double y() {
		return longitude;
	}
}

@Entity(name = "City")
public static class City {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	@Embedded
	@Target( GPS.class )
	private Coordinates coordinates;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>coordinates</code>可嵌入类型被映射为<code>Coordinates</code>接口。但是，Hibernate需要知道实际的实现方式，即<code>GPS</code>在这种情况下，因此<code>@Target</code>批注用于提供此信息。</p>
</div>
<div class="paragraph">
<p>假设我们坚持以下<code>City</code>实体：</p>
</div>
<div id="embeddable-Target-persist-example" class="exampleblock">
<div class="title">例子91。 <code>@Target</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {

	City cluj = new City();
	cluj.setName( "Cluj" );
	cluj.setCoordinates( new GPS( 46.77120, 23.62360 ) );

	entityManager.persist( cluj );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>City</code>实体<code>coordinates</code>属性由<code>@Target</code>表达：</p>
</div>
<div id="embeddable-Target-fetching-example" class="exampleblock">
<div class="title">示例92。 <code>@Target</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {

	City cluj = entityManager.find( City.class, 1L );

	assertEquals( 46.77120, cluj.getCoordinates().x(), 0.00001 );
	assertEquals( 23.62360, cluj.getCoordinates().y(), 0.00001 );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    c.id as id1_0_0_,
    c.latitude as latitude2_0_0_,
    c.longitude as longitud3_0_0_,
    c.name as name4_0_0_
FROM
    City c
WHERE
    c.id = ?

-- binding parameter [1] as [BIGINT] - [1]

-- extracted value ([latitude2_0_0_] : [DOUBLE])  - [46.7712]
-- extracted value ([longitud3_0_0_] : [DOUBLE])  - [23.6236]
-- extracted value ([name4_0_0_]     : [VARCHAR]) - [Cluj]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此， <code>@Target</code>批注用于定义父子关联之间的自定义联接关联。</p>
</div>
</div>
<div class="sect3">
<h4 id="embeddable-Parent"><a class="anchor" href="#embeddable-Parent"></a> 2.4.9。 <code>@Parent</code>映射</h4>
<div class="paragraph">
<p>Hibernate专用<code>@Parent</code>批注允许您从可嵌入对象内部引用所有者实体。</p>
</div>
<div id="embeddable-Parent-example" class="exampleblock">
<div class="title">示例93。 <code>@Parent</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public static class GPS {

	private double latitude;

	private double longitude;

	@Parent
	private City city;

	//Getters and setters omitted for brevity

}

@Entity(name = "City")
public static class City {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	@Embedded
	@Target( GPS.class )
	private GPS coordinates;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设我们坚持以下<code>City</code>实体：</p>
</div>
<div id="embeddable-Parent-persist-example" class="exampleblock">
<div class="title">示例94。 <code>@Parent</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {

	City cluj = new City();
	cluj.setName( "Cluj" );
	cluj.setCoordinates( new GPS( 46.77120, 23.62360 ) );

	entityManager.persist( cluj );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>City</code>实体<code>city</code>可嵌入类型的属性充当对拥有父实体的反向引用：</p>
</div>
<div id="embeddable-Parent-fetching-example" class="exampleblock">
<div class="title">示例95。 <code>@Parent</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {

	City cluj = entityManager.find( City.class, 1L );

	assertSame( cluj, cluj.getCoordinates().getCity() );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此， <code>@Parent</code>批注用于定义可嵌入类型和拥有实体之间的关联。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entity"><a class="anchor" href="#entity"></a> 2.5。实体类型</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title"><em>实体</em>一词的用法</div>
<div class="paragraph">
<p>实体类型描述了实际的可持久域模型对象和数据库表行之间的映射。为了避免与标记给定实体类型的注释产生任何混淆，该注释将进一步称为<code>@Entity</code> 。</p>
</div>
<div class="paragraph">
<p>在本章及其后的整个章节中，实体类型将简称为<em>实体</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="entity-pojo"><a class="anchor" href="#entity-pojo"></a> 2.5.1。POJO模型</h4>
<div class="paragraph">
<p><em>JPA 2.1规范的</em>第<em>2.1</em>节<em>“实体类</em> ”定义了其对实体类的要求。希望在JPA提供程序之间保持可移植性的应用程序应遵守这些要求。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实体类别必须以<code>javax.persistence.Entity</code>注释（或在XML映射中这样表示）</p>
</li>
<li>
<p>实体类必须具有公共或受保护的无参数构造函数。它还可以定义其他构造函数。</p>
</li>
<li>
<p>实体类必须是顶级类。</p>
</li>
<li>
<p>枚举或接口不能指定为实体。</p>
</li>
<li>
<p>实体类不能是最终的。实体类的任何方法或持久实例变量都不得为最终的。</p>
</li>
<li>
<p>如果实体实例要作为分离对象远程使用，则实体类必须实现<code>Serializable</code>接口。</p>
</li>
<li>
<p>抽象类和具体类都可以是实体。实体可以扩展非实体类以及实体类，并且非实体类可以扩展实体类。</p>
</li>
<li>
<p>实体的持久状态由实例变量表示，实例变量可以对应于JavaBean样式的属性。实例变量只能由实体实例本身直接从实体的方法内部访问。客户只能通过实体的访问器方法（getter / setter方法）或其他业务方法来使用实体的状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，Hibernate的要求并不严格。与上面列表的区别包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实体类必须具有无参数构造函数，该构造函数可以是公共的，受保护的或程序包可见性。它还可以定义其他构造函数。</p>
</li>
<li>
<p>实体类<em>不必</em>是顶级类。</p>
</li>
<li>
<p>从技术上讲，Hibernate可以持久化最终类或具有最终持久性状态访问器（getter / setter）方法的类。但是，通常不是一个好主意，因为这样做将使Hibernate不能生成用于延迟加载实体的代理。</p>
</li>
<li>
<p>Hibernate并不限制应用程序开发人员公开实例变量并从实体类本身之外引用它们。然而，这种范例的有效性至多是有争议的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们详细了解每个需求。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-pojo-final"><a class="anchor" href="#entity-pojo-final"></a> 2.5.2。偏好非决赛类</h4>
<div class="paragraph">
<p>Hibernate的主要功能是可以通过运行时代理延迟加载某些实体实例变量（属性）。此功能取决于实体类是非最终类，还是取决于实现声明所有属性获取器/设置器的接口。您仍然可以使用Hibernate持久化未实现此类接口的最终类，但是您将无法使用代理来获取惰性关联，因此限制了性能调整的选项。出于同样的原因，您还应该避免将持久属性getter和setter声明为final。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从5.0开始，Hibernate提供了更健壮的字节码增强版本，作为处理延迟加载的另一种方法。Hibernate在5.0之前具有一些字节码重写功能，但是它们非常初级。有关获取和字节码增强的更多信息，请参见<a href="#BytecodeEnhancement">BytecodeEnhancement</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="entity-pojo-constructor"><a class="anchor" href="#entity-pojo-constructor"></a> 2.5.3。实现无参数构造函数</h4>
<div class="paragraph">
<p>实体类应具有无参数的构造函数。Hibernate和JPA都需要这样做。</p>
</div>
<div class="paragraph">
<p>JPA要求将此构造函数定义为public或protected。在大多数情况下，只要系统SecurityManager允许覆盖可见性设置，Hibernate都不在乎构造函数的可见性。也就是说，如果您希望利用运行时代理生成，则应至少使用包可见性来定义构造函数。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-pojo-accessors"><a class="anchor" href="#entity-pojo-accessors"></a> 2.5.4。声明持久性属性的获取器和设置器</h4>
<div class="paragraph">
<p>JPA规范要求这样做，否则，该模型将阻止直接从实体本身外部访问实体持久状态字段。</p>
</div>
<div class="paragraph">
<p>尽管Hibernate不需要它，但建议遵循JavaBean约定并为实体持久性属性定义getter和setter。尽管如此，您仍然可以告诉Hibernate直接访问实体字段。</p>
</div>
<div class="paragraph">
<p>无需将属性（无论是字段还是getter / setter）声明为公共属性。Hibernate可以处理以公共，受保护，程序包或私有可见性声明的属性。同样，如果要使用运行时代理生成进行延迟加载，则getter / setter方法应至少授予包可见性的访问权限。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-pojo-identifier"><a class="anchor" href="#entity-pojo-identifier"></a> 2.5.5。提供标识符属性</h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>历史上，提供标识符属性被认为是可选的。</p>
</div>
<div class="paragraph">
<p>但是，未在实体上定义标识符属性应视为已弃用的功能，该功能将在以后的版本中删除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>标识符属性不一定需要映射到物理上定义主键的列。但是，它应该映射到可以唯一标识每一行的列。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>我们建议您在持久性类上声明以统一名称命名的标识符属性，并使用包装器（即非原始）类型（例如<code>Long</code>要么<code>Integer</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的位置<code>@Id</code>批注标记<a href="#access">持久状态访问策略</a> 。</p>
</div>
<div id="entity-pojo-identifier-mapping-example" class="exampleblock">
<div class="title">例子96。标识符映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Id
private Long id;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate提供了多种标识符生成策略，有关此主题的更多信息，请参见“ <a href="#identifiers">标识符生成器”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-pojo-mapping"><a class="anchor" href="#entity-pojo-mapping"></a> 2.5.6。映射实体</h4>
<div class="paragraph">
<p>映射实体的主要部分是<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Entity.html"><code>javax.persistence.Entity</code></a>注解。</p>
</div>
<div class="paragraph">
<p>的<code>@Entity</code>注释仅定义<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Entity.html#name--"><code>name</code></a>属性，用于提供用于JPQL查询的特定实体名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果name属性<code>@Entity</code>缺少注释，实体类本身的非限定名称将用作实体名称</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为实体名称是由类的非限定名称给出的，所以即使实体类驻留在不同的包中，Hibernate也不允许注册具有相同名称的多个实体。</p>
</div>
<div class="paragraph">
<p>如果不加此限制，那么如果不合格的实体名称与一个以上的实体类相关联，则Hibernate将不知道在JPQL查询中引用了哪个实体类。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在以下示例中，实体名称（例如<code>Book</code> ）由实体类名称的非限定名称给出。</p>
</div>
<div id="entity-pojo-mapping-implicit-name-example" class="exampleblock">
<div class="title">示例97。 <code>@Entity</code>使用隐式名称进行映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，也可以如以下示例所示显式设置实体名称。</p>
</div>
<div id="entity-pojo-mapping-example" class="exampleblock">
<div class="title">例子98。 <code>@Entity</code>使用显式名称进行映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实体为数据库表建模。该标识符唯一地标识该表中的每一行。默认情况下，假定表的名称与实体的名称相同。要明确给出表名或指定有关表的其他信息，我们将使用<code>javax.persistence.Table</code>注解。</p>
</div>
<div id="entity-pojo-table-mapping-example" class="exampleblock">
<div class="title">示例99。简单<code>@Entity</code>与<code>@Table</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
@Table(
        catalog = "public",
        schema = "store",
        name = "book"
)
public static class Book {

    @Id
    private Long id;

    private String title;

    private String author;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-entity-table-catalog"><a class="anchor" href="#mapping-entity-table-catalog"></a>映射关联表的目录</h5>
<div class="paragraph">
<p>没有指定给定实体映射到的关联数据库表的目录，Hibernate将使用与当前数据库连接关联的默认目录。</p>
</div>
<div class="paragraph">
<p>但是，如果您的数据库托管多个目录，则可以使用来指定给定表所在的目录。 <code>catalog</code> JPA的属性<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Table.html"><code>@Table</code></a>注解。</p>
</div>
<div class="paragraph">
<p>假设我们正在使用MySQL，并且想要映射一个<code>Book</code>实体<code>book</code>表格位于<code>public</code>目录如下。</p>
</div>
<div id="mapping-post-table-catalog-mysql-example" class="exampleblock">
<div class="title">示例100的<code>post</code>表格位于<code>public</code>目录</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table public.book (
  id bigint not null,
  author varchar(255),
  title varchar(255),
  primary key (id)
) engine=InnoDB</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，要映射<code>Book</code>实体<code>book</code>中的表<code>public</code>我们可以使用的目录<code>catalog</code>的属性<code>@Table</code> JPA批注。</p>
</div>
<div id="mapping-entity-table-catalog-mysql-example" class="exampleblock">
<div class="title">示例101使用指定目录<code>@Table</code>注解</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
@Table(
	catalog = "public",
	name = "book"
)
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mapping-entity-table-schema"><a class="anchor" href="#mapping-entity-table-schema"></a>映射关联表的架构</h5>
<div class="paragraph">
<p>没有指定给定实体映射到的关联数据库表的架构，Hibernate将使用与当前数据库连接关联的默认架构。</p>
</div>
<div class="paragraph">
<p>但是，如果数据库支持架构，则可以使用来指定给定表所在的架构。 <code>schema</code> JPA的属性<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Table.html"><code>@Table</code></a>注解。</p>
</div>
<div class="paragraph">
<p>假设我们使用的是PostgreSQL，并且想要映射一个<code>Book</code>实体<code>book</code>表格位于<code>library</code>如下所示的模式。</p>
</div>
<div id="mapping-post-table-schema-postgresql-example" class="exampleblock">
<div class="title">例子102。的<code>post</code>表格位于<code>library</code>图式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table library.book (
  id int8 not null,
  author varchar(255),
  title varchar(255),
  primary key (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，要映射<code>Book</code>实体<code>book</code>中的表<code>library</code>模式，我们可以使用<code>schema</code>的属性<code>@Table</code> JPA批注。</p>
</div>
<div id="mapping-entity-table-catalog-mysql-example" class="exampleblock">
<div class="title">示例103使用以下命令指定数据库模式<code>@Table</code>注解</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
@Table(
	schema = "library",
	name = "book"
)
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>schema</code>的属性<code>@Table</code>仅当基础数据库支持架构（例如PostgreSQL）时，注释才有效。</p>
</div>
<div class="paragraph">
<p>因此，如果您使用的是MySQL或MariaDB，但它们本身不支持架构（方案只是目录的别名），则需要使用<code>catalog</code>属性，而不是<code>schema</code>一。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping-model-pojo-equalshashcode"><a class="anchor" href="#mapping-model-pojo-equalshashcode"></a> 2.5.7。实施中<code>equals()</code>和<code>hashCode()</code></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节中的许多讨论都针对实体与Hibernate Session的关系，无论该实体是托管的，临时的还是分离的。如果您不熟悉这些主题，请在“ <a href="#pc">持久性上下文”</a>一章中进行说明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>是否实施<code>equals()</code>和<code>hashCode()</code>当涉及到ORM时，您的域模型中的方法，更不用说如何实现它们了，是一个非常棘手的讨论。</p>
</div>
<div class="paragraph">
<p>实际上只有一种绝对情况：充当标识符的类必须基于id值实现equals / hashCode。通常，这与用作复合标识符的用户定义类有关。除了这个非常具体的用例之外，我们将在下面讨论其他几个用例，您可能要考虑完全不实施equals / hashCode。</p>
</div>
<div class="paragraph">
<p>那有什么大惊小怪的？通常，大多数Java对象都提供内置的<code>equals()</code>和<code>hashCode()</code>基于对象的身份，因此每个新对象都会与其他所有对象不同。这通常是普通Java编程中想要的。但是，从概念上讲，当您开始考虑某个类的多个实例表示同一数据的可能性时，这种情况就开始崩溃。</p>
</div>
<div class="paragraph">
<p>实际上，在处理来自数据库的数据时确实如此。每次我们加载特定<code>Person</code>从数据库中，我们自然会得到一个唯一的实例。但是，Hibernate会努力确保在给定时间内不会发生这种情况<code>Session</code> 。实际上，Hibernate保证了特定会话范围内的持久身份（数据库行）和Java身份相等。所以如果我们问一个Hibernate<code>Session</code>多次加载该特定Person，我们实际上将返回同一<em>实例</em> ：</p>
</div>
<div id="entity-pojo-identity-scope-example" class="exampleblock">
<div class="title">例子104。身份范围</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book1 = entityManager.find( Book.class, 1L );
Book book2 = entityManager.find( Book.class, 1L );

assertTrue( book1 == book2 );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑我们有一个<code>Library</code>父实体，其中包含<code>java.util.Set</code>的<code>Book</code>实体：</p>
</div>
<div id="entity-pojo-set-mapping-example" class="paragraph">
<p>库实体映射</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Library")
public static class Library {

	@Id
	private Long id;

	private String name;

	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "book_id")
	private Set&lt;Book&gt; books = new HashSet&lt;&gt;();

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div id="entity-pojo-set-identity-scope-example" class="exampleblock">
<div class="title">例子105。使用会话范围的身份设置用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Library library = entityManager.find( Library.class, 1L );

Book book1 = entityManager.find( Book.class, 1L );
Book book2 = entityManager.find( Book.class, 1L );

library.getBooks().add( book1 );
library.getBooks().add( book2 );

assertEquals( 1, library.getBooks().size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，当我们混合从不同Session加载的实例时，语义会发生变化：</p>
</div>
<div id="entity-pojo-multi-session-identity-scope-example" class="exampleblock">
<div class="title">例子106。混合会议</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book1 = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	return entityManager.find( Book.class, 1L );
} );

Book book2 = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	return entityManager.find( Book.class, 1L );
} );

assertFalse( book1 == book2 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Set&lt;Book&gt; books = new HashSet&lt;&gt;();

	books.add( book1 );
	books.add( book2 );

	assertEquals( 2, books.size() );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>具体而言，最后一个示例中的结果将取决于<code>Book</code>类实现了equals / hashCode，如果实现，则如何实现。</p>
</div>
<div class="paragraph">
<p>如果<code>Book</code>类没有覆盖默认的equals / hashCode，则这两个<code>Book</code>对象引用将不相等，因为它们的引用是不同的。</p>
</div>
<div class="paragraph">
<p>考虑另一种情况：</p>
</div>
<div id="entity-pojo-transient-set-identity-scope-example" class="exampleblock">
<div class="title">例子107。带有瞬态实体的集合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Library library = entityManager.find( Library.class, 1L );

Book book1 = new Book();
book1.setId( 100L );
book1.setTitle( "High-Performance Java Persistence" );

Book book2 = new Book();
book2.setId( 101L );
book2.setTitle( "Java Persistence with Hibernate" );

library.getBooks().add( book1 );
library.getBooks().add( book2 );

assertEquals( 2, library.getBooks().size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您要处理会话外部的实体（无论它们是临时实体还是分离实体），尤其是在Java集合中使用它们时，则应考虑实现equals / hashCode。</p>
</div>
<div class="paragraph">
<p>一种常见的初始方法是使用实体的标识符属性作为equals / hashCode计算的基础：</p>
</div>
<div id="entity-pojo-naive-equals-hashcode-example" class="exampleblock">
<div class="title">示例108。天真的equals / hashCode实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Library")
public static class Library {

	@Id
	private Long id;

	private String name;

	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "book_id")
	private Set&lt;Book&gt; books = new HashSet&lt;&gt;();

	//Getters and setters are omitted for brevity
}

@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Book book = (Book) o;
		return Objects.equals( id, book.id );
	}

	@Override
	public int hashCode() {
		return Objects.hash( id );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>事实证明，当添加的瞬时实例时，这仍然会中断<code>Book</code>到在上一个示例中看到的集合：</p>
</div>
<div id="entity-pojo-naive-equals-hashcode-persist-example" class="exampleblock">
<div class="title">示例109具有Sets和朴素的equals / hashCode的自动生成的标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book1 = new Book();
book1.setTitle( "High-Performance Java Persistence" );

Book book2 = new Book();
book2.setTitle( "Java Persistence with Hibernate" );

Library library = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Library _library = entityManager.find( Library.class, 1L );

	_library.getBooks().add( book1 );
	_library.getBooks().add( book2 );

	return _library;
} );

assertFalse( library.getBooks().contains( book1 ) );
assertFalse( library.getBooks().contains( book2 ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里的问题是生成的标识符的使用与<code>Set</code> ，以及equals / hashCode实现。
<code>Set</code>表示当对象是对象的一部分时，对象的equals / hashCode值不应更改<code>Set</code> 。但这正是此处发生的情况，因为equals / hasCode基于（生成的）id，该ID在提交JPA事务之前尚未设置。</p>
</div>
<div class="paragraph">
<p>注意，使用生成的标识符时，这只是一个问题。如果您使用的是分配的标识符，这将是没有问题的，假设在添加标识符之前已分配了标识符值<code>Set</code> 。</p>
</div>
<div class="paragraph">
<p>另一种选择是强制将标识符生成并设置，然后再添加到<code>Set</code> ：</p>
</div>
<div id="entity-pojo-naive-equals-hashcode-persist-force-flush-example" class="exampleblock">
<div class="title">例子110。在添加到集之前强制刷新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book1 = new Book();
book1.setTitle( "High-Performance Java Persistence" );

Book book2 = new Book();
book2.setTitle( "Java Persistence with Hibernate" );

Library library = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Library _library = entityManager.find( Library.class, 1L );

	entityManager.persist( book1 );
	entityManager.persist( book2 );
	entityManager.flush();

	_library.getBooks().add( book1 );
	_library.getBooks().add( book2 );

	return _library;
} );

assertTrue( library.getBooks().contains( book1 ) );
assertTrue( library.getBooks().contains( book2 ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但这通常是不可行的。</p>
</div>
<div class="paragraph">
<p>最终的方法是使用“更好”的equals / hashCode实现，并使用自然ID或业务密钥。</p>
</div>
<div id="entity-pojo-natural-id-equals-hashcode-example" class="exampleblock">
<div class="title">例子111。自然ID等于/哈希码</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Library")
public static class Library {

	@Id
	private Long id;

	private String name;

	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name = "book_id")
	private Set&lt;Book&gt; books = new HashSet&lt;&gt;();

	//Getters and setters are omitted for brevity
}

@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	@NaturalId
	private String isbn;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Book book = (Book) o;
		return Objects.equals( isbn, book.isbn );
	}

	@Override
	public int hashCode() {
		return Objects.hash( isbn );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，当添加一个<code>Book</code>到<code>Library</code><code>Set</code> ，您可以检索<code>Book</code>即使坚持下来：</p>
</div>
<div id="entity-pojo-natural-id-equals-hashcode-persist-example" class="exampleblock">
<div class="title">例子112。自然ID等于/ hashCode保持示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book1 = new Book();
book1.setTitle( "High-Performance Java Persistence" );
book1.setIsbn( "978-9730228236" );

Library library = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Library _library = entityManager.find( Library.class, 1L );

	_library.getBooks().add( book1 );

	return _library;
} );

assertTrue( library.getBooks().contains( book1 ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，equals / hashCode问题并不简单，也没有一种“一刀切”的解决方案。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管使用自然ID最适合<code>equals</code>和<code>hashCode</code> ，有时您只有提供唯一约束的实体标识符。</p>
</div>
<div class="paragraph">
<p>可以使用实体标识符进行相等性检查，但是需要一种变通方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您需要为<code>hashCode</code>因此在刷新实体前后，哈希码值不会改变。</p>
</li>
<li>
<p>您只需要比较非瞬态实体的实体标识符相等性。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关映射标识符的详细信息，请参见“ <a href="#identifiers">标识符”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-sql-query-mapping"><a class="anchor" href="#entity-sql-query-mapping"></a> 2.5.8。将实体映射到SQL查询</h4>
<div class="paragraph">
<p>您可以使用将实体映射到SQL查询<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Subselect.html"><code>@Subselect</code></a>注解。</p>
</div>
<div id="mapping-Subselect-example" class="exampleblock">
<div class="title">示例113。 <code>@Subselect</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Client")
@Table(name = "client")
public static class Client {

	@Id
	private Long id;

	@Column(name = "first_name")
	private String firstName;

	@Column(name = "last_name")
	private String lastName;

	//Getters and setters omitted for brevity

}

@Entity(name = "Account")
@Table(name = "account")
public static class Account {

	@Id
	private Long id;

	@ManyToOne
	private Client client;

	private String description;

	//Getters and setters omitted for brevity

}

@Entity(name = "AccountTransaction")
@Table(name = "account_transaction")
public static class AccountTransaction {

	@Id
	@GeneratedValue
	private Long id;

	@ManyToOne
	private Account account;

	private Integer cents;

	private String description;

	//Getters and setters omitted for brevity

}

@Entity(name = "AccountSummary")
@Subselect(
	"select " +
	"	a.id as id, " +
	"	concat(concat(c.first_name, ' '), c.last_name) as clientName, " +
	"	sum(at.cents) as balance " +
	"from account a " +
	"join client c on c.id = a.client_id " +
	"join account_transaction at on a.id = at.account_id " +
	"group by a.id, concat(concat(c.first_name, ' '), c.last_name)"
)
@Synchronize( {"client", "account", "account_transaction"} )
public static class AccountSummary {

	@Id
	private Long id;

	private String clientName;

	private int balance;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>Account</code>实体不会保留任何余额，因为每个帐户操作都已注册为<code>AccountTransaction</code> 。找到<code>Account</code>余额，我们需要查询<code>AccountSummary</code>与共享相同的标识符<code>Account</code>实体。</p>
</div>
<div class="paragraph">
<p>然而<code>AccountSummary</code>不是映射到物理表，而是映射到SQL查询。</p>
</div>
<div class="paragraph">
<p>所以，如果我们有以下<code>AccountTransaction</code>记录， <code>AccountSummary</code>余额将与此中的适当金额相匹配<code>Account</code> 。</p>
</div>
<div id="mapping-Subselect-entity-find-example" class="exampleblock">
<div class="title">示例114。寻找一个<code>@Subselect</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Client client = new Client();
	client.setId( 1L );
	client.setFirstName( "John" );
	client.setLastName( "Doe" );
	entityManager.persist( client );

	Account account = new Account();
	account.setId( 1L );
	account.setClient( client );
	account.setDescription( "Checking account" );
	entityManager.persist( account );

	AccountTransaction transaction = new AccountTransaction();
	transaction.setAccount( account );
	transaction.setDescription( "Salary" );
	transaction.setCents( 100 * 7000 );
	entityManager.persist( transaction );

	AccountSummary summary = entityManager.createQuery(
		"select s " +
		"from AccountSummary s " +
		"where s.id = :id", AccountSummary.class)
	.setParameter( "id", account.getId() )
	.getSingleResult();

	assertEquals( "John Doe", summary.getClientName() );
	assertEquals( 100 * 7000, summary.getBalance() );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们添加一个新的<code>AccountTransaction</code>实体并刷新<code>AccountSummary</code>实体，余额会相应更新：</p>
</div>
<div id="mapping-Subselect-refresh-find-example" class="exampleblock">
<div class="title">示例115。刷新一个<code>@Subselect</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	AccountSummary summary = entityManager.find( AccountSummary.class, 1L );
	assertEquals( "John Doe", summary.getClientName() );
	assertEquals( 100 * 7000, summary.getBalance() );

	AccountTransaction transaction = new AccountTransaction();
	transaction.setAccount( entityManager.getReference( Account.class, 1L ) );
	transaction.setDescription( "Shopping" );
	transaction.setCents( -100 * 2200 );
	entityManager.persist( transaction );
	entityManager.flush();

	entityManager.refresh( summary );
	assertEquals( 100 * 4800, summary.getBalance() );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的目标<code>@Synchronize</code>中的注释<code>AccountSummary</code>实体映射是为了指示Hibernate基础数据库需要哪些数据库表<code>@Subselect</code> SQL查询。这是因为与JPQL和HQL查询不同，Hibernate无法解析基础本机SQL查询。</p>
</div>
<div class="paragraph">
<p>随着<code>@Synchronize</code>执行HQL或JPQL（从<code>AccountSummary</code>实体，如果有待处理，Hibernate将触发持久性上下文刷新<code>Account</code> ， <code>Client</code>要么<code>AccountTransaction</code>实体状态转换。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="entity-proxy"><a class="anchor" href="#entity-proxy"></a> 2.5.9。定义自定义实体代理</h4>
<div class="paragraph">
<p>默认情况下，当需要使用代理而不是实际的Pojo时，Hibernate将使用Bytecode操作库，例如<a href="http://jboss-javassist.github.io/javassist/">Javassist</a>或<a href="http://bytebuddy.net/">Byte Buddy</a> 。</p>
</div>
<div class="paragraph">
<p>但是，如果实体类是最终类，则Javassist将不会创建代理，即使您仅需要代理引用，也将获得Pojo。在这种情况下，您可以代理此特定实体实现的接口，如以下示例所示。</p>
</div>
<div id="entity-proxy-interface-mapping" class="exampleblock">
<div class="title">示例116。最终实体类实现了<code>Identifiable</code>接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface Identifiable {

	Long getId();

	void setId(Long id);
}

@Entity( name = "Book" )
@Proxy(proxyClass = Identifiable.class)
public static final class Book implements Identifiable {

	@Id
	private Long id;

	private String title;

	private String author;

	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	//Other getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Proxy.html"><code>@Proxy</code></a>注解用于为当前带注释的实体指定自定义代理实现。</p>
</div>
<div class="paragraph">
<p>加载时<code>Book</code>实体代理，Hibernate将代理<code>Identifiable</code>接口，如以下示例所示：</p>
</div>
<div id="entity-proxy-persist-mapping" class="exampleblock">
<div class="title">示例117代理实现<code>Identifiable</code>接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">doInHibernate( this::sessionFactory, session -&gt; {
	Book book = new Book();
	book.setId( 1L );
	book.setTitle( "High-Performance Java Persistence" );
	book.setAuthor( "Vlad Mihalcea" );

	session.persist( book );
} );

doInHibernate( this::sessionFactory, session -&gt; {
	Identifiable book = session.getReference( Book.class, 1L );

	assertTrue(
		"Loaded entity is not an instance of the proxy interface",
		book instanceof Identifiable
	);
	assertFalse(
		"Proxy class was not created",
		book instanceof Book
	);
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">insert
into
    Book
    (author, title, id)
values
    (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Vlad Mihalcea]
-- binding parameter [2] as [VARCHAR] - [High-Performance Java Persistence]
-- binding parameter [3] as [BIGINT]  - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您在相关的SQL代码段中所见，Hibernate不会发出任何SQL SELECT查询，因为可以构造代理而不需要获取实际的实体Pojo。</p>
</div>
</div>
<div class="sect3">
<h4 id="entity-tuplizer"><a class="anchor" href="#entity-tuplizer"></a> 2.5.10。使用@Tuplizer批注的动态实体代理</h4>
<div class="paragraph">
<p>您可以使用来将您的实体映射为动态代理<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Tuplizer.html"><code>@Tuplizer</code></a>注解。</p>
</div>
<div class="paragraph">
<p>在以下实体映射中，可嵌入对象和实体都被映射为接口，而不是Pojos。</p>
</div>
<div id="entity-tuplizer-entity-mapping" class="exampleblock">
<div class="title">例子118。动态实体代理映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Tuplizer(impl = DynamicEntityTuplizer.class)
public interface Cuisine {

    @Id
    @GeneratedValue
    Long getId();
    void setId(Long id);

    String getName();
    void setName(String name);

    @Tuplizer(impl = DynamicEmbeddableTuplizer.class)
    Country getCountry();
    void setCountry(Country country);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Embeddable
public interface Country {

    @Column(name = "CountryName")
    String getName();

    void setName(String name);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@Tuplizer</code>指示Hibernate使用<code>DynamicEntityTuplizer</code>和<code>DynamicEmbeddableTuplizer</code>处理关联的实体和可嵌入对象类型。</p>
</div>
<div class="paragraph">
<p>这俩<code>Cuisine</code>实体与<code>Country</code>可嵌入类型将被实例化为Java动态代理，如下所示<code>DynamicInstantiator</code>例：</p>
</div>
<div id="entity-tuplizer-instantiator" class="exampleblock">
<div class="title">示例119。实例化实体和可嵌入对象作为动态代理</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class DynamicEntityTuplizer extends PojoEntityTuplizer {

    public DynamicEntityTuplizer(
            EntityMetamodel entityMetamodel,
            PersistentClass mappedEntity) {
        super( entityMetamodel, mappedEntity );
    }

    @Override
    protected Instantiator buildInstantiator(
            EntityMetamodel entityMetamodel,
            PersistentClass persistentClass) {
        return new DynamicInstantiator(
            persistentClass.getClassName()
        );
    }

    @Override
    protected ProxyFactory buildProxyFactory(
            PersistentClass persistentClass,
            Getter idGetter,
            Setter idSetter) {
        return super.buildProxyFactory(
            persistentClass, idGetter,
            idSetter
        );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class DynamicEmbeddableTuplizer
        extends PojoComponentTuplizer {

    public DynamicEmbeddableTuplizer(Component embeddable) {
        super( embeddable );
    }

    protected Instantiator buildInstantiator(Component embeddable) {
        return new DynamicInstantiator(
            embeddable.getComponentClassName()
        );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class DynamicInstantiator
        implements Instantiator {

    private final Class targetClass;

    public DynamicInstantiator(String targetClassName) {
        try {
            this.targetClass = Class.forName( targetClassName );
        }
        catch (ClassNotFoundException e) {
            throw new HibernateException( e );
        }
    }

    public Object instantiate(Serializable id) {
        return ProxyHelper.newProxy( targetClass, id );
    }

    public Object instantiate() {
        return instantiate( null );
    }

    public boolean isInstance(Object object) {
        try {
            return targetClass.isInstance( object );
        }
        catch( Throwable t ) {
            throw new HibernateException(
                "could not get handle to entity as interface : " + t
            );
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class ProxyHelper {

    public static &lt;T&gt; T newProxy(Class&lt;T&gt; targetClass, Serializable id) {
        return ( T ) Proxy.newProxyInstance(
            targetClass.getClassLoader(),
            new Class[] {
                targetClass
            },
            new DataProxyHandler(
                targetClass.getName(),
                id
            )
        );
    }

    public static String extractEntityName(Object object) {
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler(
                object
            );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = (DataProxyHandler) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public final class DataProxyHandler implements InvocationHandler {

    private String entityName;

    private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();

    public DataProxyHandler(String entityName, Serializable id) {
        this.entityName = entityName;
        data.put( "Id", id );
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String methodName = method.getName();
        if ( methodName.startsWith( "set" ) ) {
            String propertyName = methodName.substring( 3 );
            data.put( propertyName, args[0] );
        }
        else if ( methodName.startsWith( "get" ) ) {
            String propertyName = methodName.substring( 3 );
            return data.get( propertyName );
        }
        else if ( "toString".equals( methodName ) ) {
            return entityName + "#" + data.get( "Id" );
        }
        else if ( "hashCode".equals( methodName ) ) {
            return this.hashCode();
        }
        return null;
    }

    public String getEntityName() {
        return entityName;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随着<code>DynamicInstantiator</code>到位，我们可以像Pojo实体一样使用动态代理实体。</p>
</div>
<div id="entity-tuplizer-dynamic-proxy-example" class="exampleblock">
<div class="title">例子120。持久存在实体和可嵌入对象作为动态代理</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Cuisine _cuisine = doInHibernateSessionBuilder(
		() -&gt; sessionFactory()
				.withOptions()
				.interceptor( new EntityNameInterceptor() ),
		session -&gt; {
	Cuisine cuisine = ProxyHelper.newProxy( Cuisine.class, null );
	cuisine.setName( "Française" );

	Country country = ProxyHelper.newProxy( Country.class, null );
	country.setName( "France" );

	cuisine.setCountry( country );
	session.persist( cuisine );

	return cuisine;
} );

doInHibernateSessionBuilder(
		() -&gt; sessionFactory()
				.withOptions()
				.interceptor( new EntityNameInterceptor() ),
		session -&gt; {
	Cuisine cuisine = session.get( Cuisine.class, _cuisine.getId() );

	assertEquals( "Française", cuisine.getName() );
	assertEquals( "France", cuisine.getCountry().getName() );
} );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entity-persister"><a class="anchor" href="#entity-persister"></a> 2.5.11。定义自定义实体持久性</h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Persister.html"><code>@Persister</code></a>批注用于指定自定义实体或集合持久性。</p>
</div>
<div class="paragraph">
<p>对于实体，自定义持久程序必须实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/entity/EntityPersister.html"><code>EntityPersister</code></a>接口。</p>
</div>
<div class="paragraph">
<p>对于集合，自定义持久性必须实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/collection/CollectionPersister.html"><code>CollectionPersister</code></a>接口。</p>
</div>
<div id="entity-persister-mapping" class="exampleblock">
<div class="title">示例121。实体持久性映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Persister( impl = EntityPersister.class )
public class Author {

    @Id
    public Integer id;

    @OneToMany( mappedBy = "author" )
    @Persister( impl = CollectionPersister.class )
    public Set&lt;Book&gt; books = new HashSet&lt;&gt;();

    //Getters and setters omitted for brevity

    public void addBook(Book book) {
        this.books.add( book );
        book.setAuthor( this );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Persister( impl = EntityPersister.class )
public class Book {

    @Id
    public Integer id;

    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    public Author author;

    //Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过提供自己的<code>EntityPersister</code>和<code>CollectionPersister</code>实现中，您可以控制实体和集合如何持久保存到数据库中。</p>
</div>
</div>
<div class="sect3">
<h4 id="access"><a class="anchor" href="#access"></a> 2.5.12。访问策略</h4>
<div class="paragraph">
<p>作为JPA提供者，Hibernate可以同时检查实体属性（实例字段）或访问器（实例属性）。默认情况下， <code>@Id</code>注释提供默认的访问策略。当放在一个字段上时，Hibernate将假定基于字段的访问。当放置在标识符getter上时，Hibernate将使用基于属性的访问。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了避免诸如<a href="https://hibernate.atlassian.net/browse/HCANN-63">HCANN-63之类的</a>问题<a href="https://hibernate.atlassian.net/browse/HCANN-63">-HQL中以至少两个大写字符开头的属性名称具有奇怪的功能</a> ，关于命名属性，应注意<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/Introspector.html#decapitalize(java.lang.String)">Java Bean规范</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可嵌入类型从其父实体继承访问策略。</p>
</div>
<div class="sect4">
<h5 id="field-based-access"><a class="anchor" href="#field-based-access"></a>基于现场的访问</h5>
<div id="access-field-mapping-example" class="exampleblock">
<div class="title">例子122。基于现场的访问</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用基于字段的访问时，添加其他实体级别的方法更加灵活，因为Hibernate不会考虑持久性状态的那些部分。要将某个字段排除在实体持久状态的一部分之外，必须将该字段标记为<code>@Transient</code>注解。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用基于字段的访问的另一个优点是，某些实体属性可以从实体外部隐藏。</p>
</div>
<div class="paragraph">
<p>这种属性的一个例子是实体<code>@Version</code>字段，通常不需要数据访问层进行操作。</p>
</div>
<div class="paragraph">
<p>使用基于字段的访问，我们可以简单地忽略此版本字段的getter和setter，并且Hibernate仍然可以利用开放式并发控制机制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="property-based-access"><a class="anchor" href="#property-based-access"></a>基于属性的访问</h5>
<div id="access-property-mapping-example" class="exampleblock">
<div class="title">示例123基于属性的访问</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	private Long id;

	private String title;

	private String author;

	@Id
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getAuthor() {
		return author;
	}

	public void setAuthor(String author) {
		this.author = author;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当使用基于属性的访问时，Hibernate使用访问器来读取和写入实体状态。必须添加到实体的所有其他方法（例如，用于同步双向一对多关联的两端的辅助方法）都必须标记为<code>@Transient</code>注解。</p>
</div>
</div>
<div class="sect4">
<h5 id="_overriding_the_default_access_strategy"><a class="anchor" href="#_overriding_the_default_access_strategy"></a>覆盖默认访问策略</h5>
<div class="paragraph">
<p>可以使用JPA覆盖默认的访问策略机制<code>@Access</code>注解。在以下示例中， <code>@Version</code>像其余实体属性一样，属性是通过其字段而不是其获取方法访问的。</p>
</div>
<div id="access-property-override-mapping-example" class="exampleblock">
<div class="title">例子124。覆盖访问策略</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	private Long id;

	private String title;

	private String author;

	@Access( AccessType.FIELD )
	@Version
	private int version;

	@Id
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getAuthor() {
		return author;
	}

	public void setAuthor(String author) {
		this.author = author;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="access-embeddable-types"><a class="anchor" href="#access-embeddable-types"></a>嵌入式类型和访问策略</h5>
<div class="paragraph">
<p>由于可嵌入对象由它们自己的实体管理，因此访问策略也从该实体继承。这适用于简单的可嵌入类型以及可嵌入对象的集合。</p>
</div>
<div class="paragraph">
<p>可嵌入类型可以推翻默认的隐式访问策略（从拥有的实体继承）。在以下示例中，无论拥有实体选择哪种访问策略，可嵌入对象都使用基于属性的访问：</p>
</div>
<div id="access-embeddable-mapping-example" class="exampleblock">
<div class="title">示例125可嵌入独家访问策略</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Embeddable
@Access( AccessType.PROPERTY )
public static class Author {

	private String firstName;

	private String lastName;

	public Author() {
	}

	public Author(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>拥有实体可以使用基于字段的访问，而可嵌入实体可以使用基于属性的访问，因为它已明确选择：</p>
</div>
<div id="access-embedded-mapping-example" class="exampleblock">
<div class="title">示例126包含单个可嵌入类型的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	@Embedded
	private Author author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这也适用于可嵌入类型的收集：</p>
</div>
<div id="access-element-collection-mapping-example" class="exampleblock">
<div class="title">例子127。实体，包括可嵌入类型的集合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	@ElementCollection
	@CollectionTable(
		name = "book_author",
		joinColumns = @JoinColumn(name = "book_id")
	)
	private List&lt;Author&gt; authors = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="identifiers"><a class="anchor" href="#identifiers"></a> 2.6。身份标识</h3>
<div class="paragraph">
<p>标识符为实体的主键建模。它们用于唯一地标识每个特定实体。</p>
</div>
<div class="paragraph">
<p>Hibernate和JPA都对相应的数据库列进行以下假设：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>UNIQUE</code></dt>
<dd>
<p>这些值必须唯一地标识每一行。</p>
</dd>
<dt class="hdlist1"><code>NOT NULL</code></dt>
<dd>
<p>该值不能为空。对于复合ID，任何部分都不能为null。</p>
</dd>
<dt class="hdlist1"><code>IMMUTABLE</code></dt>
<dd>
<p>这些值一旦插入，就无法更改。这是更一般的指南，而不是因意见而异的硬性规定。JPA定义了将标识符属性的值更改为未定义的行为；Hibernate根本不支持。如果您选择的PK的值将被更新，Hibernate建议将可变值映射为自然ID，并为PK使用替代ID。请参阅<a href="#naturalid">自然ID</a> 。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从技术上讲，标识符不必映射到物理上定义为表主键的列。他们只需要映射到唯一标识每一行的列即可。但是，本文档将继续互换使用术语标识符和主键。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个实体都必须定义一个标识符。对于实体继承层次结构，必须仅在作为层次结构根的实体上定义标识符。</p>
</div>
<div class="paragraph">
<p>标识符可以是简单的（单个值）或复合的（多个值）。</p>
</div>
<div class="sect3">
<h4 id="identifiers-simple"><a class="anchor" href="#identifiers-simple"></a> 2.6.1。简单标识符</h4>
<div class="paragraph">
<p>简单标识符映射到单个基本属性，并使用<code>javax.persistence.Id</code>注解。</p>
</div>
<div class="paragraph">
<p>根据JPA，只能将以下类型用作标识符属性类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何Java基本类型</p>
</li>
<li>
<p>任何原始包装器类型</p>
</li>
<li>
<p><code>java.lang.String</code></p>
</li>
<li>
<p><code>java.util.Date</code> （TemporalType＃DATE）</p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.math.BigDecimal</code></p>
</li>
<li>
<p><code>java.math.BigInteger</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此列表之外的用于标识符属性的任何类型都将不可移植。</p>
</div>
<div class="sect4">
<h5 id="identifiers-simple-assigned"><a class="anchor" href="#identifiers-simple-assigned"></a>分配的标识符</h5>
<div class="paragraph">
<p>如上面的示例所示，可以分配简单标识符的值。对分配的标识符值的期望是应用程序在调用保存/持久化之前分配（在实体属性上设置它们）。</p>
</div>
<div id="identifiers-simple-assigned-mapping-example" class="exampleblock">
<div class="title">示例128。简单分配的实体标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="identifiers-simple-generated"><a class="anchor" href="#identifiers-simple-generated"></a>生成的标识符</h5>
<div class="paragraph">
<p>可以生成简单标识符的值。为了表示生成了一个标识符属性，用注释它<code>javax.persistence.GeneratedValue</code></p>
</div>
<div id="identifiers-simple-generated-mapping-example" class="exampleblock">
<div class="title">示例129简单生成的标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另外，对于上面的类型限制列表，JPA表示，如果使用生成的标识符值（请参见下文），则仅可移植地支持整数类型（short，int，long）。</p>
</div>
<div class="paragraph">
<p>对于生成的标识符值的期望是，当保存/持久化发生时，Hibernate将生成该值。</p>
</div>
<div class="paragraph">
<p>标识符值生成策略将在“ <a href="#identifiers-generators">生成的标识符值”</a>部分中详细讨论。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-composite"><a class="anchor" href="#identifiers-composite"></a> 2.6.2。复合标识符</h4>
<div class="paragraph">
<p>复合标识符对应于一个或多个持久属性。这是JPA规范定义的管理组合标识符的规则。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>复合标识符必须由“主键类”表示。可以使用<code>javax.persistence.EmbeddedId</code>注释（请参阅<a href="#identifiers-composite-aggregated">带有<code>@EmbeddedId</code></a> ），或使用<code>javax.persistence.IdClass</code>注释（请参阅<a href="#identifiers-composite-nonaggregated">带有<code>@IdClass</code></a> ）。</p>
</li>
<li>
<p>主键类必须是公共的，并且必须具有公共的无参数构造函数。</p>
</li>
<li>
<p>主键类必须可序列化。</p>
</li>
<li>
<p>主键类必须定义equals和hashCode方法，该方法与主键映射到的基础数据库类型的相等性一致。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>组合标识符必须由“主键类”表示的限制（例如<code>@EmbeddedId</code>要么<code>@IdClass</code> ）仅适用于JPA。</p>
</div>
<div class="paragraph">
<p>Hibernate确实允许通过多个来定义复合标识符而无需“主键类” <code>@Id</code>属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>组成构图的属性可以是基本的，复合的， <code>@ManyToOne</code> 。特别要注意的是，集合和一对一是绝对不合适的。</p>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-composite-aggregated"><a class="anchor" href="#identifiers-composite-aggregated"></a> 2.6.3。具有的复合标识符<code>@EmbeddedId</code></h4>
<div class="paragraph">
<p>使用EmbeddedId对组合标识符进行建模仅意味着将可嵌入对象定义为组成该标识符的一个或多个属性的组合，然后在实体上公开该可嵌入类型的属性。</p>
</div>
<div id="identifiers-basic-embeddedid-mapping-example" class="exampleblock">
<div class="title">例子130。基本的<code>@EmbeddedId</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "SystemUser")
public static class SystemUser {

	@EmbeddedId
	private PK pk;

	private String name;

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class PK implements Serializable {

	private String subsystem;

	private String username;

	public PK(String subsystem, String username) {
		this.subsystem = subsystem;
		this.username = username;
	}

	private PK() {
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		PK pk = (PK) o;
		return Objects.equals( subsystem, pk.subsystem ) &amp;&amp;
				Objects.equals( username, pk.username );
	}

	@Override
	public int hashCode() {
		return Objects.hash( subsystem, username );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所述，EmbeddedIds甚至可以包含<code>@ManyToOne</code>属性：</p>
</div>
<div id="identifiers-basic-embeddedid-manytoone-mapping-example" class="exampleblock">
<div class="title">示例131 <code>@EmbeddedId</code>与<code>@ManyToOne</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "SystemUser")
public static class SystemUser {

	@EmbeddedId
	private PK pk;

	private String name;

	//Getters and setters are omitted for brevity
}

@Entity(name = "Subsystem")
public static class Subsystem {

	@Id
	private String id;

	private String description;

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class PK implements Serializable {

	@ManyToOne(fetch = FetchType.LAZY)
	private Subsystem subsystem;

	private String username;

	public PK(Subsystem subsystem, String username) {
		this.subsystem = subsystem;
		this.username = username;
	}

	private PK() {
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		PK pk = (PK) o;
		return Objects.equals( subsystem, pk.subsystem ) &amp;&amp;
				Objects.equals( username, pk.username );
	}

	@Override
	public int hashCode() {
		return Objects.hash( subsystem, username );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate支持直接建模<code>@ManyToOne</code>主键类中的关联，是否<code>@EmbeddedId</code>要么<code>@IdClass</code> 。</p>
</div>
<div class="paragraph">
<p>但是，JPA规范并不可移植地支持该功能。用JPA术语，将使用“派生的标识符”。有关更多详细信息，请参见<a href="#identifiers-derived">派生标识符</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-composite-nonaggregated"><a class="anchor" href="#identifiers-composite-nonaggregated"></a> 2.6.4。具有的复合标识符<code>@IdClass</code></h4>
<div class="paragraph">
<p>使用IdClass对复合标识符进行建模与使用EmbeddedId的区别在于，实体定义了组成合成的每个单独属性。IdClass只是充当“影子”。</p>
</div>
<div id="identifiers-basic-idclass-mapping-example" class="exampleblock">
<div class="title">示例132基本的<code>@IdClass</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "SystemUser")
@IdClass( PK.class )
public static class SystemUser {

	@Id
	private String subsystem;

	@Id
	private String username;

	private String name;

	public PK getId() {
		return new PK(
			subsystem,
			username
		);
	}

	public void setId(PK id) {
		this.subsystem = id.getSubsystem();
		this.username = id.getUsername();
	}

	//Getters and setters are omitted for brevity
}

public static class PK implements Serializable {

	private String subsystem;

	private String username;

	public PK(String subsystem, String username) {
		this.subsystem = subsystem;
		this.username = username;
	}

	private PK() {
	}

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		PK pk = (PK) o;
		return Objects.equals( subsystem, pk.subsystem ) &amp;&amp;
				Objects.equals( username, pk.username );
	}

	@Override
	public int hashCode() {
		return Objects.hash( subsystem, username );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>非聚合的复合标识符还可以包含ManyToOne属性，正如我们在聚合的标识符中看到的那样（仍然是非便携式的）。</p>
</div>
<div id="identifiers-basic-idclass-manytoone-mapping-example" class="exampleblock">
<div class="title">示例133IdClass与<code>@ManyToOne</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "SystemUser")
@IdClass( PK.class )
public static class SystemUser {

	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	private Subsystem subsystem;

	@Id
	private String username;

	private String name;

	//Getters and setters are omitted for brevity
}

@Entity(name = "Subsystem")
public static class Subsystem {

	@Id
	private String id;

	private String description;

	//Getters and setters are omitted for brevity
}

public static class PK implements Serializable {

	private Subsystem subsystem;

	private String username;

	public PK(Subsystem subsystem, String username) {
		this.subsystem = subsystem;
		this.username = username;
	}

	private PK() {
	}

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用非聚合的复合标识符，Hibernate还支持复合值的“部分”生成。</p>
</div>
<div id="identifiers-basic-idclass-generatedvalue-mapping-example" class="exampleblock">
<div class="title">实施例134。 <code>@IdClass</code>使用部分标识符生成<code>@GeneratedValue</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "SystemUser")
@IdClass( PK.class )
public static class SystemUser {

	@Id
	private String subsystem;

	@Id
	private String username;

	@Id
	@GeneratedValue
	private Integer registrationId;

	private String name;

	public PK getId() {
		return new PK(
			subsystem,
			username,
			registrationId
		);
	}

	public void setId(PK id) {
		this.subsystem = id.getSubsystem();
		this.username = id.getUsername();
		this.registrationId = id.getRegistrationId();
	}

	//Getters and setters are omitted for brevity
}

public static class PK implements Serializable {

	private String subsystem;

	private String username;

	private Integer registrationId;

	public PK(String subsystem, String username) {
		this.subsystem = subsystem;
		this.username = username;
	}

	public PK(String subsystem, String username, Integer registrationId) {
		this.subsystem = subsystem;
		this.username = username;
		this.registrationId = registrationId;
	}

	private PK() {
	}

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		PK pk = (PK) o;
		return Objects.equals( subsystem, pk.subsystem ) &amp;&amp;
				Objects.equals( username, pk.username ) &amp;&amp;
				Objects.equals( registrationId, pk.registrationId );
	}

	@Override
	public int hashCode() {
		return Objects.hash( subsystem, username, registrationId );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于SpecJ委员会对JPA规范进行了高度质疑的解释，因此存在允许在组合标识符中自动生成值的功能。</p>
</div>
<div class="paragraph">
<p>Hibernate并不认为JPA定义了对此的支持，而是添加了该功能只是为了在SpecJ基准测试中可用。从JPA角度来看，此功能的使用可能是可移植的，也可能不是。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-composite-associations"><a class="anchor" href="#identifiers-composite-associations"></a> 2.6.5。具有关联的复合标识符</h4>
<div class="paragraph">
<p>Hibernate允许在实体关联之外定义复合标识符。在以下示例中， <code>PersonAddress</code>实体标识符由两个组成<code>@ManyToOne</code>协会。</p>
</div>
<div id="identifiers-composite-id-mapping-example" class="exampleblock">
<div class="title">示例135具有关联的复合标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book implements Serializable {

	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	private Author author;

	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	private Publisher publisher;

	@Id
	private String title;

	public Book(Author author, Publisher publisher, String title) {
		this.author = author;
		this.publisher = publisher;
		this.title = title;
	}

	private Book() {
	}

	//Getters and setters are omitted for brevity


	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Book book = (Book) o;
		return Objects.equals( author, book.author ) &amp;&amp;
				Objects.equals( publisher, book.publisher ) &amp;&amp;
				Objects.equals( title, book.title );
	}

	@Override
	public int hashCode() {
		return Objects.hash( author, publisher, title );
	}
}

@Entity(name = "Author")
public static class Author implements Serializable {

	@Id
	private String name;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Author author = (Author) o;
		return Objects.equals( name, author.name );
	}

	@Override
	public int hashCode() {
		return Objects.hash( name );
	}
}

@Entity(name = "Publisher")
public static class Publisher implements Serializable {

	@Id
	private String name;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Publisher publisher = (Publisher) o;
		return Objects.equals( name, publisher.name );
	}

	@Override
	public int hashCode() {
		return Objects.hash( name );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管映射比使用<code>@EmbeddedId</code>或<code>@IdClass</code> ，实体实例与实际标识符之间没有分隔。要查询该实体，必须将实体本身的实例提供给持久性上下文。</p>
</div>
<div id="identifiers-composite-id-fetching-example" class="exampleblock">
<div class="title">实施例136。使用复合标识符获取</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager.find( Book.class, new Book(
	author,
	publisher,
	"High-Performance Java Persistence"
) );

assertEquals( "Vlad Mihalcea", book.getAuthor().getName() );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-composite-generated"><a class="anchor" href="#identifiers-composite-generated"></a> 2.6.6。具有生成属性的复合标识符</h4>
<div class="paragraph">
<p>使用组合标识符时，底层标识符属性必须由用户手动分配。</p>
</div>
<div class="paragraph">
<p>不支持将自动生成的属性用于生成构成复合标识符的基础属性的值。</p>
</div>
<div class="paragraph">
<p>因此，您不能使用“ <a href="#mapping-generated">生成的属性”部分</a>所述的任何自动属性生成器，例如<code>@Generated</code> ， <code>@CreationTimestamp</code>要么<code>@ValueGenerationType</code>或数据库生成的值。</p>
</div>
<div class="paragraph">
<p>但是，仍然可以在构造复合标识符之前生成标识符属性，如以下示例所示。</p>
</div>
<div class="paragraph">
<p>假设我们有以下<code>EventId</code>复合标识符和<code>Event</code>使用上述复合标识符的实体。</p>
</div>
<div id="identifiers-composite-generated-mapping-example" class="exampleblock">
<div class="title">实施例137。事件实体和EventId复合标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
class Event {

    @Id
    private EventId id;

    @Column(name = "event_key")
    private String key;

    @Column(name = "event_value")
    private String value;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Embeddable
class EventId implements Serializable {

	private Integer category;

	private Timestamp createdOn;

	//Getters and setters are omitted for brevity
	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		EventId that = (EventId) o;
		return Objects.equals( category, that.category ) &amp;&amp;
				Objects.equals( createdOn, that.createdOn );
	}

	@Override
	public int hashCode() {
		return Objects.hash( category, createdOn );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="identifiers-composite-generated-in-memory"><a class="anchor" href="#identifiers-composite-generated-in-memory"></a>内存中生成的复合标识符属性</h5>
<div class="paragraph">
<p>如果要在内存中生成复合标识符属性，则需要执行以下操作：</p>
</div>
<div id="identifiers-composite-generated-in-memory-example" class="exampleblock">
<div class="title">实施例138。内存中生成的复合标识符属性示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">EventId id = new EventId();
id.setCategory( 1 );
id.setCreatedOn( new Timestamp( System.currentTimeMillis() ) );

Event event = new Event();
event.setId( id );
event.setKey( "Temperature" );
event.setValue( "9" );

entityManager.persist( event );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意<code>createdOn</code>的属性<code>EventId</code>复合标识符是由数据访问代码生成的，并在持久存储标识符之前分配给标识符<code>Event</code>实体。</p>
</div>
</div>
<div class="sect4">
<h5 id="identifiers-composite-generated-database"><a class="anchor" href="#identifiers-composite-generated-database"></a>数据库生成的复合标识符属性</h5>
<div class="paragraph">
<p>如果要使用数据库函数或存储过程生成复合标识符属性，则可以按照以下示例所示进行操作。</p>
</div>
<div id="identifiers-composite-generated-database-example" class="exampleblock">
<div class="title">示例139数据库生成的复合标识符属性示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Timestamp currentTimestamp = (Timestamp) entityManager
.createNativeQuery(
	"SELECT CURRENT_TIMESTAMP" )
.getSingleResult();

EventId id = new EventId();
id.setCategory( 1 );
id.setCreatedOn( currentTimestamp );

Event event = new Event();
event.setId( id );
event.setKey( "Temperature" );
event.setValue( "9" );

entityManager.persist( event );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意<code>createdOn</code>的属性<code>EventId</code>复合标识符是通过调用<code>CURRENT_TIMESTAMP</code>数据库功能，并且在持久保存<code>Event</code>实体。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators"><a class="anchor" href="#identifiers-generators"></a> 2.6.7。生成的标识符值</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还可以自动生成非标识符属性的值。有关更多详细信息，请参见“ <a href="#mapping-generated">生成的属性”</a>部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate支持跨多种不同类型的标识符值生成。请记住，JPA仅针对整数类型可移植地定义标识符值的生成。</p>
</div>
<div class="paragraph">
<p>标识符值的生成使用<code>javax.persistence.GeneratedValue</code>注解。这里最重要的信息是<code>javax.persistence.GenerationType</code>指示如何生成值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面的讨论假定该应用程序正在使用Hibernate的“新生成器映射”，如<code>hibernate.id.new_generator_mappings</code>设置或<code>MetadataBuilder.enableNewIdentifierGeneratorSupport</code>引导过程中的方法。</p>
</div>
<div class="paragraph">
<p>从Hibernate 5开始，将其设置为<code>true</code>默认。在应用中<code>hibernate.id.new_generator_mappings</code>配置设置为<code>false</code>这里讨论的分辨率将有很大的不同。此处的其余讨论假定已启用此设置（ <code>true</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在Hibernate 5.3中，如果刷新模式不相等，则Hibernate尝试延迟实体的插入。 <code>AUTO</code> 。对于使用过的实体，这有点问题<code>IDENTITY</code>要么<code>SEQUENCE</code>生成的标识符，这些标识符也以某种形式与同一笔交易中的另一个实体相关联。</p>
</div>
<div class="paragraph">
<p>+在Hibernate 5.4中，Hibernate尝试使用算法来确定插入是否应该延迟或是否需要立即插入的算法来解决该问题。我们只想在合理的非常特殊的用例中恢复5.3之前的行为。</p>
</div>
<div class="paragraph">
<p>+实体映射有时可能很复杂，并且可能忽略了一个极端情况。Hibernate提供了一种在出现问题时完全禁用5.3行为的方法<code>DelayedPostInsertIdentifier</code> 。要启用旧版行为，请设置<code>hibernate.id.disable_delayed_identity_inserts=true</code> 。</p>
</div>
<div class="paragraph">
<p>+此配置选项旨在充当<em>临时</em>修复程序，并弥合整个Hibernate 5.x版本中此行为的更改之间的差距。如果映射需要此配置设置，请打开JIRA并报告映射，以便可以检查算法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>AUTO</code> （默认）</dt>
<dd>
<p>指示持久性提供程序（Hibernate）应选择适当的生成策略。请参见<a href="#identifiers-generators-auto">解释AUTO</a> 。</p>
</dd>
<dt class="hdlist1"><code>IDENTITY</code></dt>
<dd>
<p>指示数据库IDENTITY列将用于生成主键值。请参阅<a href="#identifiers-generators-identity">使用IDENTITY列</a> 。</p>
</dd>
<dt class="hdlist1"><code>SEQUENCE</code></dt>
<dd>
<p>指示应使用数据库序列来获取主键值。请参阅<a href="#identifiers-generators-sequence">使用序列</a> 。</p>
</dd>
<dt class="hdlist1"><code>TABLE</code></dt>
<dd>
<p>指示应使用数据库表获取主键值。请参阅<a href="#identifiers-generators-table">使用表标识符生成器</a> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-auto"><a class="anchor" href="#identifiers-generators-auto"></a> 2.6.8。解释自动</h4>
<div class="paragraph">
<p>持久性提供程序如何解释AUTO生成类型取决于提供程序。</p>
</div>
<div class="paragraph">
<p>默认行为是查看标识符属性的Java类型。</p>
</div>
<div class="paragraph">
<p>如果标识符类型为UUID，则Hibernate将使用<a href="#identifiers-generators-uuid">UUID标识符</a> 。</p>
</div>
<div class="paragraph">
<p>如果标识符类型为数字（例如， <code>Long</code> ， <code>Integer</code> ），那么Hibernate将使用<code>IdGeneratorStrategyInterpreter</code>解决标识符生成器策略。的<code>IdGeneratorStrategyInterpreter</code>有两个实现：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>FallbackInterpreter</code></dt>
<dd>
<p>这是Hibernate 5.0以来的默认策略。对于较旧的版本，可通过<a href="#configurations-mapping"><code>hibernate.id.new_generator_mappings</code></a>配置属性。使用这种策略时， <code>AUTO</code>总是决心<code>SequenceStyleGenerator</code> 。如果基础数据库支持序列，则使用SEQUENCE生成器。否则，将改为使用TABLE生成器。</p>
</dd>
<dt class="hdlist1"><code>LegacyFallbackInterpreter</code></dt>
<dd>
<p>这是Hibernate 5.0之前的版本或在<a href="#configurations-mapping"><code>hibernate.id.new_generator_mappings</code></a>配置属性为false。遗留策略图<code>AUTO</code>到<code>native</code>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html#getNativeIdentifierGeneratorStrategy--">Dialect＃getNativeIdentifierGeneratorStrategy</a>解析实际标识符生成器的生成器策略（例如， <code>identity</code>要么<code>sequence</code> ）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-sequence"><a class="anchor" href="#identifiers-generators-sequence"></a> 2.6.9。使用序列</h4>
<div class="paragraph">
<p>为了实现基于数据库序列的标识符值生成，Hibernate利用了它的<code>org.hibernate.id.enhanced.SequenceStyleGenerator</code> id生成器。重要的是要注意，SequenceStyleGenerator能够通过切换到表作为基础支持来处理不支持序列的数据库。这使Hibernate在数据库之间具有很大程度的可移植性，同时仍保持一致的ID生成行为（相对于说在SEQUENCE和IDENTITY之间进行选择）。此后备存储对用户完全透明。</p>
</div>
<div class="paragraph">
<p>配置此生成器的首选（便携式）方法是使用JPA定义的<code>javax.persistence.SequenceGenerator</code>注解。</p>
</div>
<div class="paragraph">
<p>最简单的形式是简单地请求序列生成。 Hibernate将使用单个隐式命名的序列（ <code>hibernate_sequence</code> ）的所有未命名的定义。</p>
</div>
<div id="identifiers-generators-sequence-unnamed" class="exampleblock">
<div class="title">例子140。未命名序列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.SEQUENCE
	)
	private Long id;

	@Column(name = "product_name")
	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用<code>javax.persistence.SequenceGenerator</code> ，您可以指定特定的数据库序列名称。</p>
</div>
<div id="identifiers-generators-sequence-named" class="exampleblock">
<div class="title">实施例141。命名序列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.SEQUENCE,
		generator = "sequence-generator"
	)
	@SequenceGenerator(
		name = "sequence-generator",
		sequenceName = "product_sequence"
	)
	private Long id;

	@Column(name = "product_name")
	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>javax.persistence.SequenceGenerator</code>注释还允许您指定其他配置。</p>
</div>
<div id="identifiers-generators-sequence-configured" class="exampleblock">
<div class="title">实施例142。配置顺序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.SEQUENCE,
		generator = "sequence-generator"
	)
	@SequenceGenerator(
		name = "sequence-generator",
		sequenceName = "product_sequence",
		allocationSize = 5
	)
	private Long id;

	@Column(name = "product_name")
	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-identity"><a class="anchor" href="#identifiers-generators-identity"></a> 2.6.10。使用IDENTITY列</h4>
<div class="paragraph">
<p>为了实现基于IDENTITY列的标识符值生成，Hibernate利用它的<code>org.hibernate.id.IdentityGenerator</code> id生成器，它希望通过INSERT将标识符生成到表中。IdentityGenerator了解可以检索INSERT生成的值的3种不同方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果Hibernate认为JDBC环境支持<code>java.sql.Statement#getGeneratedKeys</code> ，那么该方法将用于提取IDENTITY生成的键。</p>
</li>
<li>
<p>否则，如果<code>Dialect#supportsInsertSelectIdentity</code>如果报告为true，则Hibernate将使用方言特定的INSERT + SELECT语句语法。</p>
</li>
<li>
<p>否则，Hibernate将期望数据库支持某种形式的查询，该查询通过单独的SQL命令来请求最近插入的IDENTITY值，如<code>Dialect#getIdentitySelectString</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>重要的是要认识到，使用IDENTITY列会产生一种运行时行为，其中<strong>必须</strong>在知道标识符值之前物理插入实体行。</p>
</div>
<div class="paragraph">
<p>这会弄乱扩展的持久性上下文（长时间的对话）。由于运行时的强加/不一致，Hibernate建议使用其他形式的标识符值生成（例如SEQUENCE）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>选择IDENTITY生成还有另一个重要的运行时影响：Hibernate将无法使用IDENTITY生成为实体批处理INSERT语句。</p>
</div>
<div class="paragraph">
<p>这的重要性取决于特定于应用程序的用例。如果应用程序通常不使用IDENTITY生成器创建给定实体类型的许多新实例，则此限制将变得不那么重要，因为无论如何批处理都不会很有帮助。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-table"><a class="anchor" href="#identifiers-generators-table"></a> 2.6.11。使用表标识符生成器</h4>
<div class="paragraph">
<p>Hibernate基于Hibernate实现了基于表的标识符生成<code>org.hibernate.id.enhanced.TableGenerator</code>它定义了一个表，该表能够为任意数量的实体保存多个命名值段。</p>
</div>
<div class="paragraph">
<p>基本思想是给定的表生成器表（ <code>hibernate_sequences</code> （例如）可以包含标识符生成值的多个段。</p>
</div>
<div id="identifiers-generators-table-unnamed-mapping-example" class="exampleblock">
<div class="title">示例143。未命名表生成器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.TABLE
	)
	private Long id;

	@Column(name = "product_name")
	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table hibernate_sequences (
    sequence_name varchar2(255 char) not null,
    next_val number(19,0),
    primary key (sequence_name)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果未给出表名，则Hibernate假定隐式名称为<code>hibernate_sequences</code> 。</p>
</div>
<div class="paragraph">
<p>另外，因为没有<code>javax.persistence.TableGenerator#pkColumnValue</code>指定后，Hibernate将使用默认细分（ <code>sequence_name='default'</code> ）从hibernate_sequences表中。</p>
</div>
<div class="paragraph">
<p>但是，您可以使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/TableGenerator.html"><code>@TableGenerator</code></a>注解。</p>
</div>
<div id="identifiers-generators-table-configured-mapping-example" class="exampleblock">
<div class="title">实施例144。配置表生成器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.TABLE,
		generator = "table-generator"
	)
	@TableGenerator(
		name =  "table-generator",
		table = "table_identifier",
		pkColumnName = "table_name",
		valueColumnName = "product_id",
		allocationSize = 5
	)
	private Long id;

	@Column(name = "product_name")
	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table table_identifier (
    table_name varchar2(255 char) not null,
    product_id number(19,0),
    primary key (table_name)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当插入3 <code>Product</code>实体，Hibernate生成以下语句：</p>
</div>
<div id="identifiers-generators-table-configured-persist-example" class="exampleblock">
<div class="title">示例145配置表生成器持久化示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">for ( long i = 1; i &lt;= 3; i++ ) {
	Product product = new Product();
	product.setName( String.format( "Product %d", i ) );
	entityManager.persist( product );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">select
    tbl.product_id
from
    table_identifier tbl
where
    tbl.table_name = ?
for update

-- binding parameter [1] - [Product]

insert
into
    table_identifier
    (table_name, product_id)
values
    (?, ?)

-- binding parameter [1] - [Product]
-- binding parameter [2] - [1]

update
    table_identifier
set
    product_id= ?
where
    product_id= ?
    and table_name= ?

-- binding parameter [1] - [6]
-- binding parameter [2] - [1]

select
    tbl.product_id
from
    table_identifier tbl
where
    tbl.table_name= ? for update

update
    table_identifier
set
    product_id= ?
where
    product_id= ?
    and table_name= ?

-- binding parameter [1] - [11]
-- binding parameter [2] - [6]

insert
into
    Product
    (product_name, id)
values
    (?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 1]
-- binding parameter [2] as [BIGINT]  - [1]

insert
into
    Product
    (product_name, id)
values
    (?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 2]
-- binding parameter [2] as [BIGINT]  - [2]

insert
into
    Product
    (product_name, id)
values
    (?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 3]
-- binding parameter [2] as [BIGINT]  - [3]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-uuid"><a class="anchor" href="#identifiers-generators-uuid"></a> 2.6.12。使用UUID生成</h4>
<div class="paragraph">
<p>如上所述，Hibernate支持UUID标识符值生成。这通过其支持<code>org.hibernate.id.UUIDGenerator</code> id生成器。</p>
</div>
<div class="paragraph">
<p><code>UUIDGenerator</code>支持精确生成UUID的可插拔策略。这些策略由<code>org.hibernate.id.UUIDGenerationStrategy</code>合同。默认策略是根据IETF RFC 4122的版本4（随机）策略。Hibernate确实附带了一种替代策略，它是RFC 4122版本1（基于时间）策略（使用IP地址而不是mac地址）。</p>
</div>
<div id="identifiers-generators-uuid-mapping-example" class="exampleblock">
<div class="title">例子146。隐式使用随机UUID策略</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue
	private UUID id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要指定替代的生成策略，我们必须通过以下方式定义一些配置<code>@GenericGenerator</code> 。在这里，我们选择名为RFC 4122版本1的策略<code>org.hibernate.id.uuid.CustomVersionOneStrategy</code> 。</p>
</div>
<div id="identifiers-generators-custom-uuid-mapping-example" class="exampleblock">
<div class="title">示例147隐式使用随机UUID策略</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	@GeneratedValue( generator = "custom-uuid" )
	@GenericGenerator(
		name = "custom-uuid",
		strategy = "org.hibernate.id.UUIDGenerator",
		parameters = {
			@Parameter(
				name = "uuid_gen_strategy_class",
				value = "org.hibernate.id.uuid.CustomVersionOneStrategy"
			)
		}
	)
	private UUID id;

	private String title;

	private String author;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-optimizer"><a class="anchor" href="#identifiers-generators-optimizer"></a> 2.6.13。优化器</h4>
<div class="paragraph">
<p>从数据库结构中单独获取标识符值的大多数Hibernate生成器都支持可插拔优化器的使用。优化器可帮助管理Hibernate与数据库对话以生成标识符值的次数。例如，在没有将优化器应用于序列生成器的情况下，每次应用程序要求Hibernate生成标识符时，它都需要从数据库中获取下一个序列值。但是，如果我们可以最大程度地减少与数据库通信的次数，则应用程序将能够表现更好。实际上，这就是这些优化器的作用。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">没有</dt>
<dd>
<p>没有执行优化。每当生成器需要标识符值时，我们都会与数据库进行通信。</p>
</dd>
<dt class="hdlist1">池子</dt>
<dd>
<p>pool-lo优化器的工作原理是将增量值编码到数据库表/序列结构中。在序列项中，这意味着序列以大于1的增量大小定义。</p>
<div class="paragraph">
<p>例如，考虑定义为<code>create sequence m_sequence start with 1 increment by 20</code> 。每次我们要求它提供下一个值时，此序列实质上定义了一个20个可用id值的“池”。pool-lo优化器将下一个值解释为该池的低端。</p>
</div>
<div class="paragraph">
<p>因此，当我们第一次要求它的下一个值时，我们将得到1。然后，我们假定有效池将是1到20之间的值。</p>
</div>
<div class="paragraph">
<p>下一次调用该序列将得到21，它将21-40定义为有效范围。等等。名称的“ lo”部分表示来自数据库表/序列的值被解释为池lo（w）的末尾。</p>
</div>
</dd>
<dt class="hdlist1">汇集</dt>
<dd>
<p>与pooled-lo一样，只是在这里表/序列中的值被解释为值池的高端。</p>
</dd>
<dt class="hdlist1">你好遗留的光环</dt>
<dd>
<p>定义一个自定义算法，用于基于表或序列中的单个值生成值池。</p>
<div class="paragraph">
<p>不建议使用这些优化器。它们在这里维护（并提到）仅供先前使用这些策略的旧应用程序使用。</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>应用程序还可以实施和使用自己的优化器策略，如<code>org.hibernate.id.enhanced.Optimizer</code>合同。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-generators-GenericGenerator"><a class="anchor" href="#identifiers-generators-GenericGenerator"></a> 2.6.14。使用<code>@GenericGenerator</code></h4>
<div class="paragraph">
<p><code>@GenericGenerator</code>允许集成任何Hibernate <code>org.hibernate.id.IdentifierGenerator</code>实施，包括此处讨论的任何特定实施和任何自定义实施。</p>
</div>
<div class="paragraph">
<p>要使用池式或池式优化器，实体映射必须使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenericGenerator.html"><code>@GenericGenerator</code></a>注解：</p>
</div>
<div id="identifiers-generators-pooled-lo-optimizer-mapping-example" class="exampleblock">
<div class="title">实施例148。Pool-lo优化器映射使用<code>@GenericGenerator</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	@GeneratedValue(
		strategy = GenerationType.SEQUENCE,
		generator = "product_generator"
	)
	@GenericGenerator(
		name = "product_generator",
		strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
		parameters = {
			@Parameter(name = "sequence_name", value = "product_sequence"),
			@Parameter(name = "initial_value", value = "1"),
			@Parameter(name = "increment_size", value = "3"),
			@Parameter(name = "optimizer", value = "pooled-lo")
		}
	)
	private Long id;

	@Column(name = "p_name")
	private String name;

	@Column(name = "p_number")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当保存5 <code>Person</code>实体，并在每3个实体之后刷新持久化上下文：</p>
</div>
<div id="identifiers-generators-pooled-lo-optimizer-persist-example" class="exampleblock">
<div class="title">示例149Pool-lo优化器映射使用<code>@GenericGenerator</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">for ( long i = 1; i &lt;= 5; i++ ) {
	if(i % 3 == 0) {
		entityManager.flush();
	}
	Product product = new Product();
	product.setName( String.format( "Product %d", i ) );
	product.setNumber( String.format( "P_100_%d", i ) );
	entityManager.persist( product );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CALL NEXT VALUE FOR product_sequence

INSERT INTO Product (p_name, p_number, id)
VALUES (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 1]
-- binding parameter [2] as [VARCHAR] - [P_100_1]
-- binding parameter [3] as [BIGINT]  - [1]

INSERT INTO Product (p_name, p_number, id)
VALUES (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 2]
-- binding parameter [2] as [VARCHAR] - [P_100_2]
-- binding parameter [3] as [BIGINT]  - [2]

CALL NEXT VALUE FOR product_sequence

INSERT INTO Product (p_name, p_number, id)
VALUES (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 3]
-- binding parameter [2] as [VARCHAR] - [P_100_3]
-- binding parameter [3] as [BIGINT]  - [3]

INSERT INTO Product (p_name, p_number, id)
VALUES (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 4]
-- binding parameter [2] as [VARCHAR] - [P_100_4]
-- binding parameter [3] as [BIGINT]  - [4]

INSERT INTO Product (p_name, p_number, id)
VALUES (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Product 5]
-- binding parameter [2] as [VARCHAR] - [P_100_5]
-- binding parameter [3] as [BIGINT]  - [5]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从生成的SQL语句列表中可以看到，只需一个数据库序列调用就可以插入3个实体。这样，池优化器和池优化器可减少数据库往返的次数，从而减少总体事务响应时间。</p>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-derived"><a class="anchor" href="#identifiers-derived"></a> 2.6.15。派生标识符</h4>
<div class="paragraph">
<p>JPA 2.0增加了对派生标识符的支持，允许实体从多对一或一对一关联中借用该标识符。</p>
</div>
<div id="identifiers-derived-mapsid" class="exampleblock">
<div class="title">示例150带有的派生标识符<code>@MapsId</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person  {

	@Id
	private Long id;

	@NaturalId
	private String registrationNumber;

	public Person() {}

	public Person(String registrationNumber) {
		this.registrationNumber = registrationNumber;
	}

	//Getters and setters are omitted for brevity
}

@Entity(name = "PersonDetails")
public static class PersonDetails  {

	@Id
	private Long id;

	private String nickName;

	@OneToOne
	@MapsId
	private Person person;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>PersonDetails</code>实体使用<code>id</code>列，用于实体标识符和与该对象的一对一关联<code>Person</code>实体。的价值<code>PersonDetails</code>实体标识符是从其父标识符“派生”的<code>Person</code>实体。</p>
</div>
<div id="identifiers-derived-mapsid-persist-example" class="exampleblock">
<div class="title">示例151带有的派生标识符<code>@MapsId</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Person person = new Person( "ABC-123" );
	person.setId( 1L );
	entityManager.persist( person );

	PersonDetails personDetails = new PersonDetails();
	personDetails.setNickName( "John Doe" );
	personDetails.setPerson( person );

	entityManager.persist( personDetails );
} );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	PersonDetails personDetails = entityManager.find( PersonDetails.class, 1L );

	assertEquals("John Doe", personDetails.getNickName());
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@MapsId</code>批注还可以引用来自<code>@EmbeddedId</code>标识符也是如此。</p>
</div>
<div class="paragraph">
<p>前面的示例也可以使用<code>@PrimaryKeyJoinColumn</code> 。</p>
</div>
<div id="identifiers-derived-primarykeyjoincolumn" class="exampleblock">
<div class="title">示例152派生标识符<code>@PrimaryKeyJoinColumn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person  {

	@Id
	private Long id;

	@NaturalId
	private String registrationNumber;

	public Person() {}

	public Person(String registrationNumber) {
		this.registrationNumber = registrationNumber;
	}

	//Getters and setters are omitted for brevity
}

@Entity(name = "PersonDetails")
public static class PersonDetails  {

	@Id
	private Long id;

	private String nickName;

	@OneToOne
	@PrimaryKeyJoinColumn
	private Person person;

	public void setPerson(Person person) {
		this.person = person;
		this.id = person.getId();
	}

	//Other getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不像<code>@MapsId</code> ，应用程序开发人员负责确保实体标识符和多对一（或一对一）关联是同步的，如您在<code>PersonDetails#setPerson</code>方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="identifiers-rowid"><a class="anchor" href="#identifiers-rowid"></a> 2.6.16。@RowId</h4>
<div class="paragraph">
<p>如果您使用<code>@RowId</code>注释和基础数据库支持通过ROWID（例如Oracle）提取记录，然后Hibernate可以使用<code>ROWID</code>用于CRUD操作的伪列。</p>
</div>
<div id="identifiers-rowid-mapping" class="exampleblock">
<div class="title">示例153。 <code>@RowId</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
@RowId("ROWID")
public static class Product {

	@Id
	private Long id;

	@Column(name = "`name`")
	private String name;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，在获取实体并对其进行修改时，Hibernate使用<code>ROWID</code> UPDATE SQL语句的伪列。</p>
</div>
<div id="identifiers-rowid-example" class="exampleblock">
<div class="title">示例154 <code>@RowId</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product product = entityManager.find( Product.class, 1L );

product.setName( "Smart phone" );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    p.id as id1_0_0_,
    p."name" as name2_0_0_,
    p."number" as number3_0_0_,
    p.ROWID as rowid_0_
FROM
    Product p
WHERE
    p.id = ?

-- binding parameter [1] as [BIGINT] - [1]

-- extracted value ([name2_0_0_] : [VARCHAR]) - [Mobile phone]
-- extracted value ([number3_0_0_] : [VARCHAR]) - [123-456-7890]
-- extracted ROWID value: AAAwkBAAEAAACP3AAA

UPDATE
    Product
SET
    "name" = ?,
    "number" = ?
WHERE
    ROWID = ?

-- binding parameter [1] as [VARCHAR] - [Smart phone]
-- binding parameter [2] as [VARCHAR] - [123-456-7890]
-- binding parameter [3] as ROWID     - [AAAwkBAAEAAACP3AAA]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="associations"><a class="anchor" href="#associations"></a> 2.7。社团协会</h3>
<div class="paragraph">
<p>关联描述基于数据库连接语义的两个或多个实体如何形成关系。</p>
</div>
<div class="sect3">
<h4 id="associations-many-to-one"><a class="anchor" href="#associations-many-to-one"></a> 2.7.1。<code>@ManyToOne</code></h4>
<div class="paragraph">
<p><code>@ManyToOne</code>是最常见的关联，在关系数据库中也具有直接等效项（例如，外键），因此它在子实体和父实体之间建立关系。</p>
</div>
<div id="associations-many-to-one-example" class="exampleblock">
<div class="title">示例155 <code>@ManyToOne</code>协会</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	//Getters and setters are omitted for brevity

}

@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`number`")
	private String number;

	@ManyToOne
	@JoinColumn(name = "person_id",
			foreignKey = @ForeignKey(name = "PERSON_ID_FK")
	)
	private Person person;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    person_id BIGINT ,
    PRIMARY KEY ( id )
 )

ALTER TABLE Phone
ADD CONSTRAINT PERSON_ID_FK
FOREIGN KEY (person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每个实体都有其自己的生命周期。一旦<code>@ManyToOne</code>设置了关联后，Hibernate将设置关联的数据库外键列。</p>
</div>
<div id="associations-many-to-one-lifecycle-example" class="exampleblock">
<div class="title">例子156。 <code>@ManyToOne</code>关联生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person();
entityManager.persist( person );

Phone phone = new Phone( "123-456-7890" );
phone.setPerson( person );
entityManager.persist( phone );

entityManager.flush();
phone.setPerson( null );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person ( id )
VALUES ( 1 )

INSERT INTO Phone ( number, person_id, id )
VALUES ( '123-456-7890', 1, 2 )

UPDATE Phone
SET    number = '123-456-7890',
       person_id = NULL
WHERE  id = 2</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-one-to-many"><a class="anchor" href="#associations-one-to-many"></a> 2.7.2。<code>@OneToMany</code></h4>
<div class="paragraph">
<p>的<code>@OneToMany</code>关联将父实体与一个或多个子实体链接在一起。如果<code>@OneToMany</code>没有镜像<code>@ManyToOne</code>在孩子方面， <code>@OneToMany</code>关联是单向的。如果有<code>@ManyToOne</code>在孩子方面， <code>@OneToMany</code>关联是双向的，应用程序开发人员可以从两端导航这种关系。</p>
</div>
<div class="sect4">
<h5 id="associations-one-to-many-unidirectional"><a class="anchor" href="#associations-one-to-many-unidirectional"></a>单向<code>@OneToMany</code></h5>
<div class="paragraph">
<p>使用单向时<code>@OneToMany</code>关联时，Hibernate诉诸于使用两个连接实体之间的链接表。</p>
</div>
<div id="associations-one-to-many-unidirectional-example" class="exampleblock">
<div class="title">示例157单向<code>@OneToMany</code>协会</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person_Phone (
    Person_id BIGINT NOT NULL ,
    phones_id BIGINT NOT NULL
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    PRIMARY KEY ( id )
)

ALTER TABLE Person_Phone
ADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf
UNIQUE (phones_id)

ALTER TABLE Person_Phone
ADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391
FOREIGN KEY (phones_id) REFERENCES Phone

ALTER TABLE Person_Phone
ADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2
FOREIGN KEY (Person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@OneToMany</code>根据定义，关联是父关联，即使它是单向或双向的。只有关联的父级才有意义将其实体状态转换级联到子级。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="associations-one-to-many-unidirectional-lifecycle-example" class="exampleblock">
<div class="title">例子158。级联<code>@OneToMany</code>协会</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person();
Phone phone1 = new Phone( "123-456-7890" );
Phone phone2 = new Phone( "321-654-0987" );

person.getPhones().add( phone1 );
person.getPhones().add( phone2 );
entityManager.persist( person );
entityManager.flush();

person.getPhones().remove( phone1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person
       ( id )
VALUES ( 1 )

INSERT INTO Phone
       ( number, id )
VALUES ( '123-456-7890', 2 )

INSERT INTO Phone
       ( number, id )
VALUES ( '321-654-0987', 3 )

INSERT INTO Person_Phone
       ( Person_id, phones_id )
VALUES ( 1, 2 )

INSERT INTO Person_Phone
       ( Person_id, phones_id )
VALUES ( 1, 3 )

DELETE FROM Person_Phone
WHERE  Person_id = 1

INSERT INTO Person_Phone
       ( Person_id, phones_id )
VALUES ( 1, 3 )

DELETE FROM Phone
WHERE  id = 2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当坚持<code>Person</code>实体，级联会将持久化操作传播到基础<code>Phone</code>孩子们也是。移除后<code>Phone</code>从phone集合中，关联行从链接表中删除，并且<code>orphanRemoval</code>属性将触发<code>Phone</code>以及移除。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在删除子实体时，单向关联不是很有效。在上面的示例中，刷新持久性上下文后，Hibernate从链接表中删除所有数据库行（例如<code>Person_Phone</code> ）与父级关联的<code>Person</code>实体，然后重新插入仍在<code>@OneToMany</code>采集。</p>
</div>
<div class="paragraph">
<p>另一方面，双向<code>@OneToMany</code>关联效率更高，因为子实体控制着关联。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="associations-one-to-many-bidirectional"><a class="anchor" href="#associations-one-to-many-bidirectional"></a>双向的<code>@OneToMany</code></h5>
<div class="paragraph">
<p>双向的<code>@OneToMany</code>关联还需要一个<code>@ManyToOne</code>在孩子方面的联想。尽管域模型公开了两个方面来导航此关联，但在后台，关系数据库只有一个用于此关系的外键。</p>
</div>
<div class="paragraph">
<p>每个双向关联都必须仅具有一个拥有侧（子侧），另一侧称为<em>反向</em> （或<em>反向）。</em> <code>mappedBy</code> ）侧。</p>
</div>
<div id="associations-one-to-many-bidirectional-example" class="exampleblock">
<div class="title">例子159。 <code>@OneToMany</code>关联映射<code>@ManyToOne</code>侧</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "person", cascade = CascadeType.ALL, orphanRemoval = true)
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addPhone(Phone phone) {
		phones.add( phone );
		phone.setPerson( this );
	}

	public void removePhone(Phone phone) {
		phones.remove( phone );
		phone.setPerson( null );
	}
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	@Column(name = "`number`", unique = true)
	private String number;

	@ManyToOne
	private Person person;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    person_id BIGINT ,
    PRIMARY KEY ( id )
)

ALTER TABLE Phone
ADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6
UNIQUE (number)

ALTER TABLE Phone
ADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg
FOREIGN KEY (person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每当形成双向关联时，应用程序开发人员都必须确保双方始终保持同步。</p>
</div>
<div class="paragraph">
<p>的<code>addPhone()</code>和<code>removePhone()</code>是在添加或删除子元素时同步两端的实用程序方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因为<code>Phone</code>班上有一个<code>@NaturalId</code>列（电话号码是唯一的）， <code>equals()</code>和<code>hashCode()</code>可以利用此属性，因此<code>removePhone()</code>逻辑简化为<code>remove()</code>爪哇<code>Collection</code>方法。</p>
</div>
<div id="associations-one-to-many-bidirectional-lifecycle-example" class="exampleblock">
<div class="title">例子160。双向的<code>@OneToMany</code>与主人<code>@ManyToOne</code>副生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person();
Phone phone1 = new Phone( "123-456-7890" );
Phone phone2 = new Phone( "321-654-0987" );

person.addPhone( phone1 );
person.addPhone( phone2 );
entityManager.persist( person );
entityManager.flush();

person.removePhone( phone1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person
       ( id )
VALUES ( 1 )

INSERT INTO Phone
       ( "number", person_id, id )
VALUES ( '123-456-7890', 1, 2 )

INSERT INTO Phone
       ( "number", person_id, id )
VALUES ( '321-654-0987', 1, 3 )

DELETE FROM Phone
WHERE  id = 2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>不像单向<code>@OneToMany</code> ，双向关联在管理集合持久性状态时效率更高。每次删除元素都只需要进行一次更新（其中外键列设置为<code>NULL</code> ），并且，如果子实体生命周期绑定到其拥有的父实体，以致子实体在没有其父实体的情况下无法存在，那么我们可以使用<code>orphan-removal</code>属性和取消关联子级也会在实际的子表行上触发一条delete语句。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-one-to-one"><a class="anchor" href="#associations-one-to-one"></a> 2.7.3。<code>@OneToOne</code></h4>
<div class="paragraph">
<p>的<code>@OneToOne</code>关联可以是单向或双向的。单向关联遵循关系数据库外键语义，客户端拥有该关系。双向关联的特征是<code>mappedBy</code><code>@OneToOne</code>父母也一样</p>
</div>
<div class="sect4">
<h5 id="associations-one-to-one-unidirectional"><a class="anchor" href="#associations-one-to-one-unidirectional"></a>单向<code>@OneToOne</code></h5>
<div id="associations-one-to-one-unidirectional-example" class="exampleblock">
<div class="title">示例161单向<code>@OneToOne</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`number`")
	private String number;

	@OneToOne
	@JoinColumn(name = "details_id")
	private PhoneDetails details;

	//Getters and setters are omitted for brevity

}

@Entity(name = "PhoneDetails")
public static class PhoneDetails {

	@Id
	@GeneratedValue
	private Long id;

	private String provider;

	private String technology;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    details_id BIGINT ,
    PRIMARY KEY ( id )
)

CREATE TABLE PhoneDetails (
    id BIGINT NOT NULL ,
    provider VARCHAR(255) ,
    technology VARCHAR(255) ,
    PRIMARY KEY ( id )
)

ALTER TABLE Phone
ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7
FOREIGN KEY (details_id) REFERENCES PhoneDetails</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从关系数据库的角度来看，基础架构与单向架构相同<code>@ManyToOne</code>关联，因为客户端根据外键列控制关系。</p>
</div>
<div class="paragraph">
<p>但是，考虑到<code>Phone</code>作为客户端， <code>PhoneDetails</code>作为父方，因为没有电话，细节就不存在。如果将<code>Phone</code>是父方，因此将外键推入<code>PhoneDetails</code>表。此映射需要双向<code>@OneToOne</code>在以下示例中可以看到关联：</p>
</div>
</div>
<div class="sect4">
<h5 id="associations-one-to-one-bidirectional"><a class="anchor" href="#associations-one-to-one-bidirectional"></a>双向的<code>@OneToOne</code></h5>
<div id="associations-one-to-one-bidirectional-example" class="exampleblock">
<div class="title">实施例162。双向的<code>@OneToOne</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`number`")
	private String number;

	@OneToOne(
		mappedBy = "phone",
		cascade = CascadeType.ALL,
		orphanRemoval = true,
		fetch = FetchType.LAZY
	)
	private PhoneDetails details;

	//Getters and setters are omitted for brevity

	public void addDetails(PhoneDetails details) {
		details.setPhone( this );
		this.details = details;
	}

	public void removeDetails() {
		if ( details != null ) {
			details.setPhone( null );
			this.details = null;
		}
	}
}

@Entity(name = "PhoneDetails")
public static class PhoneDetails {

	@Id
	@GeneratedValue
	private Long id;

	private String provider;

	private String technology;

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "phone_id")
	private Phone phone;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE PhoneDetails (
    id BIGINT NOT NULL ,
    provider VARCHAR(255) ,
    technology VARCHAR(255) ,
    phone_id BIGINT ,
    PRIMARY KEY ( id )
)

ALTER TABLE PhoneDetails
ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p
FOREIGN KEY (phone_id) REFERENCES Phone</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次， <code>PhoneDetails</code>拥有关联，并且像任何双向关联一样，父端可以通过级联将其生命周期传播到子端。</p>
</div>
<div id="associations-one-to-one-bidirectional-lifecycle-example" class="exampleblock">
<div class="title">示例163。双向的<code>@OneToOne</code>生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Phone phone = new Phone( "123-456-7890" );
PhoneDetails details = new PhoneDetails( "T-Mobile", "GSM" );

phone.addDetails( details );
entityManager.persist( phone );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Phone ( number, id )
VALUES ( '123-456-7890', 1 )

INSERT INTO PhoneDetails ( phone_id, provider, technology, id )
VALUES ( 1, 'T-Mobile', 'GSM', 2 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用双向时<code>@OneToOne</code>关联时，Hibernate在获取子端时会强制执行唯一约束。如果同一个父母有多个子女，则Hibernate会抛出一个<code>org.hibernate.exception.ConstraintViolationException</code> 。继续上一个示例，添加另一个<code>PhoneDetails</code> ，Hibernate会在重新加载<code>Phone</code>宾语。</p>
</div>
<div id="associations-one-to-one-bidirectional-constraint-example" class="exampleblock">
<div class="title">示例164。双向的<code>@OneToOne</code>唯一约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">PhoneDetails otherDetails = new PhoneDetails( "T-Mobile", "CDMA" );
otherDetails.setPhone( phone );
entityManager.persist( otherDetails );
entityManager.flush();
entityManager.clear();

//throws javax.persistence.PersistenceException: org.hibernate.HibernateException: More than one row with the given identifier was found: 1
phone = entityManager.find( Phone.class, phone.getId() );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="associations-one-to-one-bidirectional-lazy"><a class="anchor" href="#associations-one-to-one-bidirectional-lazy"></a>双向的<code>@OneToOne</code>懒惰的联想</h6>
<div class="paragraph">
<p>尽管您可能会注释要懒惰获取的父端关联，但是Hibernate无法接受该请求，因为它不知道关联是否为<code>null</code>或不。</p>
</div>
<div class="paragraph">
<p>找出子方是否有关联记录的唯一方法是使用辅助查询来获取子关联。因为这可能导致N + 1查询问题，所以单向使用效率更高<code>@OneToOne</code>与...的关联<code>@MapsId</code>注释到位。</p>
</div>
<div class="paragraph">
<p>但是，如果您确实需要使用双向关联，并且想要确保始终会延迟获取它，那么您需要启用延迟状态初始化字节码增强功能并使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyToOne.html"><code>@LazyToOne</code></a>注释也是如此。</p>
</div>
<div id="associations-one-to-one-bidirectional-lazy-example" class="exampleblock">
<div class="title">示例165双向的<code>@OneToOne</code>懒惰的父母一方协会</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`number`")
	private String number;

	@OneToOne(
		mappedBy = "phone",
		cascade = CascadeType.ALL,
		orphanRemoval = true,
		fetch = FetchType.LAZY
	)
	@LazyToOne( LazyToOneOption.NO_PROXY )
	private PhoneDetails details;

	//Getters and setters are omitted for brevity

	public void addDetails(PhoneDetails details) {
		details.setPhone( this );
		this.details = details;
	}

	public void removeDetails() {
		if ( details != null ) {
			details.setPhone( null );
			this.details = null;
		}
	}
}

@Entity(name = "PhoneDetails")
public static class PhoneDetails {

	@Id
	@GeneratedValue
	private Long id;

	private String provider;

	private String technology;

	@OneToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "phone_id")
	private Phone phone;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关如何启用字节码增强的更多信息，请参见“ <a href="#BytecodeEnhancement">字节</a>码增强” <a href="#BytecodeEnhancement">一章</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-many-to-many"><a class="anchor" href="#associations-many-to-many"></a> 2.7.4。<code>@ManyToMany</code></h4>
<div class="paragraph">
<p>的<code>@ManyToMany</code>关联需要连接两个实体的链接表。如<code>@OneToMany</code>协会， <code>@ManyToMany</code>可以是单向或双向的。</p>
</div>
<div class="sect4">
<h5 id="associations-many-to-many-unidirectional"><a class="anchor" href="#associations-many-to-many-unidirectional"></a>单向<code>@ManyToMany</code></h5>
<div id="associations-many-to-many-unidirectional-example" class="exampleblock">
<div class="title">例子166。单向<code>@ManyToMany</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
	private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Address")
public static class Address {

	@Id
	@GeneratedValue
	private Long id;

	private String street;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Address (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    street VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person_Address (
    Person_id BIGINT NOT NULL ,
    addresses_id BIGINT NOT NULL
)

ALTER TABLE Person_Address
ADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u
FOREIGN KEY (addresses_id) REFERENCES Address

ALTER TABLE Person_Address
ADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti
FOREIGN KEY (Person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就像单向<code>@OneToMany</code>关联时，链接表由拥有方控制。</p>
</div>
<div class="paragraph">
<p>当实体从<code>@ManyToMany</code>集合，Hibernate只需删除链接表中的加入记录。不幸的是，此操作需要删除与给定父级关联的所有条目，并重新创建当前正在运行的持久性上下文中列出的条目。</p>
</div>
<div id="associations-many-to-many-unidirectional-lifecycle-example" class="exampleblock">
<div class="title">例子167。单向<code>@ManyToMany</code>生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person1 = new Person();
Person person2 = new Person();

Address address1 = new Address( "12th Avenue", "12A" );
Address address2 = new Address( "18th Avenue", "18B" );

person1.getAddresses().add( address1 );
person1.getAddresses().add( address2 );

person2.getAddresses().add( address1 );

entityManager.persist( person1 );
entityManager.persist( person2 );

entityManager.flush();

person1.getAddresses().remove( address1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person ( id )
VALUES ( 1 )

INSERT INTO Address ( number, street, id )
VALUES ( '12A', '12th Avenue', 2 )

INSERT INTO Address ( number, street, id )
VALUES ( '18B', '18th Avenue', 3 )

INSERT INTO Person ( id )
VALUES ( 4 )

INSERT INTO Person_Address ( Person_id, addresses_id )
VALUES ( 1, 2 )
INSERT INTO Person_Address ( Person_id, addresses_id )
VALUES ( 1, 3 )
INSERT INTO Person_Address ( Person_id, addresses_id )
VALUES ( 4, 2 )

DELETE FROM Person_Address
WHERE  Person_id = 1

INSERT INTO Person_Address ( Person_id, addresses_id )
VALUES ( 1, 3 )</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于<code>@ManyToMany</code>协会， <code>REMOVE</code>实体状态转换没有必要进行级联，因为它会传播到链接表之外。由于另一端可能会被父端的其他实体引用，因此自动删除可能会以<code>ConstraintViolationException</code> 。</p>
</div>
<div class="paragraph">
<p>例如，如果<code>@ManyToMany(cascade = CascadeType.ALL)</code>被定义并且第一个人将被删除，Hibernate将引发异常，因为另一个人仍与要删除的地址相关联。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person1 = entityManager.find(Person.class, personId);
entityManager.remove(person1);

Caused by: javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: could not execute statement
Caused by: org.hibernate.exception.ConstraintViolationException: could not execute statement
Caused by: java.sql.SQLIntegrityConstraintViolationException: integrity constraint violation: foreign key no action; FKM7J0BNABH2YR0PE99IL1D066U table: PERSON_ADDRESS</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过简单地删除父端，Hibernate可以安全地删除关联的链接记录，如下面的示例所示：</p>
</div>
<div id="associations-many-to-many-unidirectional-remove-example" class="exampleblock">
<div class="title">实施例168。单向<code>@ManyToMany</code>实体移除</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person1 = entityManager.find( Person.class, personId );
entityManager.remove( person1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">DELETE FROM Person_Address
WHERE  Person_id = 1

DELETE FROM Person
WHERE  id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="associations-many-to-many-bidirectional"><a class="anchor" href="#associations-many-to-many-bidirectional"></a>双向的<code>@ManyToMany</code></h5>
<div class="paragraph">
<p>双向的<code>@ManyToMany</code>协会拥有和拥有<code>mappedBy</code>侧。为了保持双方之间的同步，优良作法是提供用于添加或删除子实体的辅助方法。</p>
</div>
<div id="associations-many-to-many-bidirectional-example" class="exampleblock">
<div class="title">示例169双向的<code>@ManyToMany</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	private String registrationNumber;

	@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
	private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addAddress(Address address) {
		addresses.add( address );
		address.getOwners().add( this );
	}

	public void removeAddress(Address address) {
		addresses.remove( address );
		address.getOwners().remove( this );
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Person person = (Person) o;
		return Objects.equals( registrationNumber, person.registrationNumber );
	}

	@Override
	public int hashCode() {
		return Objects.hash( registrationNumber );
	}
}

@Entity(name = "Address")
public static class Address {

	@Id
	@GeneratedValue
	private Long id;

	private String street;

	@Column(name = "`number`")
	private String number;

	private String postalCode;

	@ManyToMany(mappedBy = "addresses")
	private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Address address = (Address) o;
		return Objects.equals( street, address.street ) &amp;&amp;
				Objects.equals( number, address.number ) &amp;&amp;
				Objects.equals( postalCode, address.postalCode );
	}

	@Override
	public int hashCode() {
		return Objects.hash( street, number, postalCode );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Address (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    postalCode VARCHAR(255) ,
    street VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person (
    id BIGINT NOT NULL ,
    registrationNumber VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person_Address (
    owners_id BIGINT NOT NULL ,
    addresses_id BIGINT NOT NULL
)

ALTER TABLE Person
ADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f
UNIQUE (registrationNumber)

ALTER TABLE Person_Address
ADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u
FOREIGN KEY (addresses_id) REFERENCES Address

ALTER TABLE Person_Address
ADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup
FOREIGN KEY (owners_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有了辅助方法，就可以简化同步管理，如以下示例所示：</p>
</div>
<div id="associations-many-to-many-bidirectional-lifecycle-example" class="exampleblock">
<div class="title">例子170。双向的<code>@ManyToMany</code>生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person1 = new Person( "ABC-123" );
Person person2 = new Person( "DEF-456" );

Address address1 = new Address( "12th Avenue", "12A", "4005A" );
Address address2 = new Address( "18th Avenue", "18B", "4007B" );

person1.addAddress( address1 );
person1.addAddress( address2 );

person2.addAddress( address1 );

entityManager.persist( person1 );
entityManager.persist( person2 );

entityManager.flush();

person1.removeAddress( address1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person ( registrationNumber, id )
VALUES ( 'ABC-123', 1 )

INSERT INTO Address ( number, postalCode, street, id )
VALUES ( '12A', '4005A', '12th Avenue', 2 )

INSERT INTO Address ( number, postalCode, street, id )
VALUES ( '18B', '4007B', '18th Avenue', 3 )

INSERT INTO Person ( registrationNumber, id )
VALUES ( 'DEF-456', 4 )

INSERT INTO Person_Address ( owners_id, addresses_id )
VALUES ( 1, 2 )

INSERT INTO Person_Address ( owners_id, addresses_id )
VALUES ( 1, 3 )

INSERT INTO Person_Address ( owners_id, addresses_id )
VALUES ( 4, 2 )

DELETE FROM Person_Address
WHERE  owners_id = 1

INSERT INTO Person_Address ( owners_id, addresses_id )
VALUES ( 1, 3 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果是双向的<code>@OneToMany</code>删除或更改子元素的顺序时，关联的效果更好， <code>@ManyToMany</code>这种关系无法从这种优化中受益，因为外键端不受控制。为了克服此限制，必须直接公开链接表，并且<code>@ManyToMany</code>关联分为两个双向<code>@OneToMany</code>关系。</p>
</div>
</div>
<div class="sect4">
<h5 id="associations-many-to-many-bidirectional-with-link-entity"><a class="anchor" href="#associations-many-to-many-bidirectional-with-link-entity"></a>带有链接实体的双向多对多</h5>
<div class="paragraph">
<p>最自然<code>@ManyToMany</code>关联遵循数据库架构所采用的相同逻辑，并且链接表具有关联的实体，该实体控制需要连接的双方的关系。</p>
</div>
<div id="associations-many-to-many-bidirectional-with-link-entity-example" class="exampleblock">
<div class="title">示例171具有链接实体的双向多对多</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person implements Serializable {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	private String registrationNumber;

	@OneToMany(
		mappedBy = "person",
		cascade = CascadeType.ALL,
		orphanRemoval = true
	)
	private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addAddress(Address address) {
		PersonAddress personAddress = new PersonAddress( this, address );
		addresses.add( personAddress );
		address.getOwners().add( personAddress );
	}

	public void removeAddress(Address address) {
		PersonAddress personAddress = new PersonAddress( this, address );
		address.getOwners().remove( personAddress );
		addresses.remove( personAddress );
		personAddress.setPerson( null );
		personAddress.setAddress( null );
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Person person = (Person) o;
		return Objects.equals( registrationNumber, person.registrationNumber );
	}

	@Override
	public int hashCode() {
		return Objects.hash( registrationNumber );
	}
}

@Entity(name = "PersonAddress")
public static class PersonAddress implements Serializable {

	@Id
	@ManyToOne
	private Person person;

	@Id
	@ManyToOne
	private Address address;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		PersonAddress that = (PersonAddress) o;
		return Objects.equals( person, that.person ) &amp;&amp;
				Objects.equals( address, that.address );
	}

	@Override
	public int hashCode() {
		return Objects.hash( person, address );
	}
}

@Entity(name = "Address")
public static class Address implements Serializable {

	@Id
	@GeneratedValue
	private Long id;

	private String street;

	@Column(name = "`number`")
	private String number;

	private String postalCode;

	@OneToMany(
		mappedBy = "address",
		cascade = CascadeType.ALL,
		orphanRemoval = true
	)
	private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Address address = (Address) o;
		return Objects.equals( street, address.street ) &amp;&amp;
				Objects.equals( number, address.number ) &amp;&amp;
				Objects.equals( postalCode, address.postalCode );
	}

	@Override
	public int hashCode() {
		return Objects.hash( street, number, postalCode );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Address (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    postalCode VARCHAR(255) ,
    street VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person (
    id BIGINT NOT NULL ,
    registrationNumber VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE PersonAddress (
    person_id BIGINT NOT NULL ,
    address_id BIGINT NOT NULL ,
    PRIMARY KEY ( person_id, address_id )
)

ALTER TABLE Person
ADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f
UNIQUE (registrationNumber)

ALTER TABLE PersonAddress
ADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq
FOREIGN KEY (person_id) REFERENCES Person

ALTER TABLE PersonAddress
ADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk
FOREIGN KEY (address_id) REFERENCES Address</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这俩<code>Person</code>和<code>Address</code>有一个<code>mappedBy</code><code>@OneToMany</code>一边，而<code>PersonAddress</code>拥有<code>person</code>和<code>address</code><code>@ManyToOne</code>协会。因为此映射是由两个双向关联构成的，所以辅助方法更加相关。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>前述示例对链接实体使用了特定于Hibernate的映射，因为JPA不允许从多个对象中构建复合标识符<code>@ManyToOne</code>协会。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="#identifiers-composite-associations">具有关联</a>的<a href="#identifiers-composite-associations">复合标识符</a>部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与先前的双向相比，实体状态转换得到了更好的管理<code>@ManyToMany</code>案件。</p>
</div>
<div id="associations-many-to-many-bidirectional-with-link-entity-lifecycle-example" class="exampleblock">
<div class="title">示例172具有链接实体生命周期的双向多对多</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person1 = new Person( "ABC-123" );
Person person2 = new Person( "DEF-456" );

Address address1 = new Address( "12th Avenue", "12A", "4005A" );
Address address2 = new Address( "18th Avenue", "18B", "4007B" );

entityManager.persist( person1 );
entityManager.persist( person2 );

entityManager.persist( address1 );
entityManager.persist( address2 );

person1.addAddress( address1 );
person1.addAddress( address2 );

person2.addAddress( address1 );

entityManager.flush();

log.info( "Removing address" );
person1.removeAddress( address1 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT  INTO Person ( registrationNumber, id )
VALUES  ( 'ABC-123', 1 )

INSERT  INTO Person ( registrationNumber, id )
VALUES  ( 'DEF-456', 2 )

INSERT  INTO Address ( number, postalCode, street, id )
VALUES  ( '12A', '4005A', '12th Avenue', 3 )

INSERT  INTO Address ( number, postalCode, street, id )
VALUES  ( '18B', '4007B', '18th Avenue', 4 )

INSERT  INTO PersonAddress ( person_id, address_id )
VALUES  ( 1, 3 )

INSERT  INTO PersonAddress ( person_id, address_id )
VALUES  ( 1, 4 )

INSERT  INTO PersonAddress ( person_id, address_id )
VALUES  ( 2, 3 )

DELETE  FROM PersonAddress
WHERE   person_id = 1 AND address_id = 3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>仅执行一条delete语句，因为这次关联由<code>@ManyToOne</code>只需监视底层外键关系的状态即可触发正确的DML语句。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-not-found"><a class="anchor" href="#associations-not-found"></a> 2.7.5。 <code>@NotFound</code>关联映射</h4>
<div class="paragraph">
<p>当处理不是由外键强制执行的关联时，如果子记录无法引用父实体，则可能会出现不一致的情况。</p>
</div>
<div class="paragraph">
<p>默认情况下，每当子关联引用不存在的父记录时，Hibernate都会进行投诉。但是，您可以配置此行为，以便Hibernate可以忽略此类异常，而只需分配<code>null</code>作为引用的父对象。</p>
</div>
<div class="paragraph">
<p>要忽略不存在的父实体引用，即使不建议这样做，也可以使用注释<code>org.hibernate.annotation.NotFound</code>值为的注释<code>org.hibernate.annotations.NotFoundAction.IGNORE</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@ManyToOne</code>和<code>@OneToOne</code>带有注释的关联<code>@NotFound(action = NotFoundAction.IGNORE)</code>总是渴望获得，即使<code>fetch</code>策略设置为<code>FetchType.LAZY</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下<code>City</code>和<code>Person</code>实体映射：</p>
</div>
<div id="associations-not-found-domain-model-example" class="exampleblock">
<div class="title">例子173。 <code>@NotFound</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Table( name = "Person" )
public static class Person {

	@Id
	private Long id;

	private String name;

	private String cityName;

	@ManyToOne
	@NotFound ( action = NotFoundAction.IGNORE )
	@JoinColumn(
		name = "cityName",
		referencedColumnName = "name",
		insertable = false,
		updatable = false
	)
	private City city;

	//Getters and setters are omitted for brevity

}

@Entity
@Table( name = "City" )
public static class City implements Serializable {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们的数据库中包含以下实体：</p>
</div>
<div id="associations-not-found-persist-example" class="exampleblock">
<div class="title">示例174 <code>@NotFound</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">City _NewYork = new City();
_NewYork.setName( "New York" );
entityManager.persist( _NewYork );

Person person = new Person();
person.setId( 1L );
person.setName( "John Doe" );
person.setCityName( "New York" );
entityManager.persist( person );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>加载时<code>Person</code>实体，Hibernate能够找到相关的<code>City</code>上级实体：</p>
</div>
<div id="associations-not-found-find-example" class="exampleblock">
<div class="title">示例175 <code>@NotFound</code>查找现有实体示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
assertEquals( "New York", person.getCity().getName() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，如果我们更改<code>cityName</code>归因于不存在的城市：</p>
</div>
<div id="associations-not-found-non-existing-persist-example" class="exampleblock">
<div class="title">实施例176。 <code>@NotFound</code>更改为不存在的城市示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.setCityName( "Atlantis" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate不会抛出任何异常，它将分配一个值<code>null</code>对于不存在的<code>City</code>实体参考：</p>
</div>
<div id="associations-not-found-non-existing-find-example" class="exampleblock">
<div class="title">示例177 <code>@NotFound</code>查找不存在的城市示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );

assertEquals( "Atlantis", person.getCityName() );
assertNull( null, person.getCity() );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-any"><a class="anchor" href="#associations-any"></a> 2.7.6。 <code>@Any</code>映射</h4>
<div class="paragraph">
<p>的<code>@Any</code>映射对于模拟单向很有用<code>@ManyToOne</code>可能存在多个目标实体时的关联。</p>
</div>
<div class="paragraph">
<p>因为<code>@Any</code>映射定义了来自多个表的类的多态关联，此关联类型需要FK列，该列提供关联的父标识符和关联的实体类型的元数据信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这不是映射多态关联的通常方法，您仅应在特殊情况下使用此方法（例如，审核日志，用户会话数据等）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@Any</code>注释描述了保存元数据信息的列。要链接元数据信息的值和实际的实体类型， <code>@AnyDef</code>和<code>@AnyDefs</code>使用注释。的<code>metaType</code>属性允许应用程序指定一个自定义类型，该类型将数据库列值映射到持久性类，这些持久性类具有由以下类型指定的标识符属性： <code>idType</code> 。您必须根据的值指定映射<code>metaType</code>类名。</p>
</div>
<div class="paragraph">
<p>对于下一个示例，请考虑以下内容<code>Property</code>类层次结构：</p>
</div>
<div id="associations-any-property-example" class="exampleblock">
<div class="title">示例178 <code>Property</code>类层次</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface Property&lt;T&gt; {

    String getName();

    T getValue();
}


@Entity
@Table(name="integer_property")
public class IntegerProperty implements Property&lt;Integer&gt; {

    @Id
    private Long id;

    @Column(name = "`name`")
    private String name;

    @Column(name = "`value`")
    private Integer value;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Integer getValue() {
        return value;
    }

    //Getters and setters omitted for brevity
}


@Entity
@Table(name="string_property")
public class StringProperty implements Property&lt;String&gt; {

    @Id
    private Long id;

    @Column(name = "`name`")
    private String name;

    @Column(name = "`value`")
    private String value;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getValue() {
        return value;
    }

    //Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>PropertyHolder</code>可以引用任何此类属性，并且，因为每个<code>Property</code>属于一个单独的表， <code>@Any</code>因此，需要注释。</p>
</div>
<div id="associations-any-example" class="exampleblock">
<div class="title">示例179。 <code>@Any</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Table( name = "property_holder" )
public class PropertyHolder {

    @Id
    private Long id;

    @Any(
        metaDef = "PropertyMetaDef",
        metaColumn = @Column( name = "property_type" )
    )
    @JoinColumn( name = "property_id" )
    private Property property;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CREATE TABLE property_holder (
    id BIGINT NOT NULL,
    property_type VARCHAR(255),
    property_id BIGINT,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，有两列用于引用<code>Property</code>实例： <code>property_id</code>和<code>property_type</code> 。的<code>property_id</code>用于匹配<code>id</code>任一列<code>string_property</code>要么<code>integer_property</code>表，而<code>property_type</code>用于匹配<code>string_property</code>或者<code>integer_property</code>表。</p>
</div>
<div class="paragraph">
<p>表解析映射由<code>metaDef</code>引用一个<code>@AnyMetaDef</code>映射。</p>
</div>
<div class="paragraph">
<p>的<code>package-info.java</code>包含<code>@AnyMetaDef</code>映射：</p>
</div>
<div id="associations-any-meta-def-example" class="exampleblock">
<div class="title">例子180。 <code>@Any</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@AnyMetaDef( name= "PropertyMetaDef", metaType = "string", idType = "long",
    metaValues = {
            @MetaValue(value = "S", targetEntity = StringProperty.class),
            @MetaValue(value = "I", targetEntity = IntegerProperty.class)
        }
    )
package org.hibernate.userguide.associations.any;

import org.hibernate.annotations.AnyMetaDef;
import org.hibernate.annotations.MetaValue;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然<code>@AnyMetaDef</code>映射可以直接设置在<code>@Any</code>批注，在类或包级别配置它是一个好习惯，特别是如果您需要将其重复用于多个<code>@Any</code>映射。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>看到<code>@Any</code>注解的实际效果，请考虑以下示例。</p>
</div>
<div class="paragraph">
<p>如果我们坚持<code>IntegerProperty</code>以及ASA <code>StringProperty</code>实体，并将其关联<code>StringProperty</code>具有一个的实体<code>PropertyHolder</code> ，Hibernate将生成以下SQL查询：</p>
</div>
<div id="associations-any-persist-example" class="exampleblock">
<div class="title">实施例181。 <code>@Any</code>映射持久化示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IntegerProperty ageProperty = new IntegerProperty();
ageProperty.setId( 1L );
ageProperty.setName( "age" );
ageProperty.setValue( 23 );

session.persist( ageProperty );

StringProperty nameProperty = new StringProperty();
nameProperty.setId( 1L );
nameProperty.setName( "name" );
nameProperty.setValue( "John Doe" );

session.persist( nameProperty );

PropertyHolder namePropertyHolder = new PropertyHolder();
namePropertyHolder.setId( 1L );
namePropertyHolder.setProperty( nameProperty );

session.persist( namePropertyHolder );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO integer_property
       ( "name", "value", id )
VALUES ( 'age', 23, 1 )

INSERT INTO string_property
       ( "name", "value", id )
VALUES ( 'name', 'John Doe', 1 )

INSERT INTO property_holder
       ( property_type, property_id, id )
VALUES ( 'S', 1, 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>PropertyHolder</code>实体并导航其<code>property</code>关联，Hibernate将获取关联的<code>StringProperty</code>像这样的实体：</p>
</div>
<div id="associations-any-query-example" class="exampleblock">
<div class="title">示例182 <code>@Any</code>映射查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">PropertyHolder propertyHolder = session.get( PropertyHolder.class, 1L );

assertEquals("name", propertyHolder.getProperty().getName());
assertEquals("John Doe", propertyHolder.getProperty().getValue());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT ph.id AS id1_1_0_,
       ph.property_type AS property2_1_0_,
       ph.property_id AS property3_1_0_
FROM   property_holder ph
WHERE  ph.id = 1


SELECT sp.id AS id1_2_0_,
       sp."name" AS name2_2_0_,
       sp."value" AS value3_2_0_
FROM   string_property sp
WHERE  sp.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="associations-many-to-any"><a class="anchor" href="#associations-many-to-any"></a><code>@ManyToAny</code>映射</h5>
<div class="paragraph">
<p>而<code>@Any</code>映射对于模拟<code>@ManyToOne</code>关联时可以有多个目标实体，以模拟<code>@OneToMany</code>协会<code>@ManyToAny</code>必须使用注释。</p>
</div>
<div class="paragraph">
<p>在以下示例中， <code>PropertyRepository</code>实体有一个<code>Property</code>实体。</p>
</div>
<div class="paragraph">
<p>的<code>repository_properties</code>链接表保存了之间的关联<code>PropertyRepository</code>和<code>Property</code>实体。</p>
</div>
<div id="associations-many-to-any-example" class="exampleblock">
<div class="title">示例183 <code>@ManyToAny</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Table( name = "property_repository" )
public class PropertyRepository {

    @Id
    private Long id;

    @ManyToAny(
        metaDef = "PropertyMetaDef",
        metaColumn = @Column( name = "property_type" )
    )
    @Cascade( { org.hibernate.annotations.CascadeType.ALL })
    @JoinTable(name = "repository_properties",
        joinColumns = @JoinColumn(name = "repository_id"),
        inverseJoinColumns = @JoinColumn(name = "property_id")
    )
    private List&lt;Property&lt;?&gt;&gt; properties = new ArrayList&lt;&gt;(  );

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CREATE TABLE property_repository (
    id BIGINT NOT NULL,
    PRIMARY KEY ( id )
)

CREATE TABLE repository_properties (
    repository_id BIGINT NOT NULL,
    property_type VARCHAR(255),
    property_id BIGINT NOT NULL
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>看到<code>@ManyToAny</code>注解的实际效果，请考虑以下示例。</p>
</div>
<div class="paragraph">
<p>如果我们坚持<code>IntegerProperty</code>以及ASA <code>StringProperty</code>实体，并将它们与一个<code>PropertyRepository</code>父实体，Hibernate将生成以下SQL查询：</p>
</div>
<div id="associations-many-to-any-persist-example" class="exampleblock">
<div class="title">实施例184。 <code>@ManyToAny</code>映射持久化示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IntegerProperty ageProperty = new IntegerProperty();
ageProperty.setId( 1L );
ageProperty.setName( "age" );
ageProperty.setValue( 23 );

session.persist( ageProperty );

StringProperty nameProperty = new StringProperty();
nameProperty.setId( 1L );
nameProperty.setName( "name" );
nameProperty.setValue( "John Doe" );

session.persist( nameProperty );

PropertyRepository propertyRepository = new PropertyRepository();
propertyRepository.setId( 1L );

propertyRepository.getProperties().add( ageProperty );
propertyRepository.getProperties().add( nameProperty );

session.persist( propertyRepository );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO integer_property
       ( "name", "value", id )
VALUES ( 'age', 23, 1 )

INSERT INTO string_property
       ( "name", "value", id )
VALUES ( 'name', 'John Doe', 1 )

INSERT INTO property_repository ( id )
VALUES ( 1 )

INSERT INTO repository_properties
    ( repository_id , property_type , property_id )
VALUES
    ( 1 , 'I' , 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>PropertyRepository</code>实体并导航其<code>properties</code>关联，Hibernate将获取关联的<code>IntegerProperty</code>和<code>StringProperty</code>像这样的实体：</p>
</div>
<div id="associations-many-to-any-query-example" class="exampleblock">
<div class="title">示例185 <code>@ManyToAny</code>映射查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">PropertyRepository propertyRepository = session.get( PropertyRepository.class, 1L );

assertEquals(2, propertyRepository.getProperties().size());

for(Property property : propertyRepository.getProperties()) {
    assertNotNull( property.getValue() );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT pr.id AS id1_1_0_
FROM   property_repository pr
WHERE  pr.id = 1

SELECT ip.id AS id1_0_0_ ,
       ip."name" AS name2_0_0_ ,
       ip."value" AS value3_0_0_
FROM   integer_property ip
WHERE  ip.id = 1

SELECT sp.id AS id1_3_0_ ,
       sp."name" AS name2_3_0_ ,
       sp."value" AS value3_3_0_
FROM   string_property sp
WHERE  sp.id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associations-JoinFormula"><a class="anchor" href="#associations-JoinFormula"></a> 2.7.7。 <code>@JoinFormula</code>映射</h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/JoinFormula.html"><code>@JoinFormula</code></a>批注用于自定义子外键和父行主键之间的联接。</p>
</div>
<div id="associations-JoinFormula-example" class="exampleblock">
<div class="title">示例186。 <code>@JoinFormula</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "User")
@Table(name = "users")
public static class User {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	private String phoneNumber;

	@ManyToOne
	@JoinFormula( "REGEXP_REPLACE(phoneNumber, '\\+(\\d+)-.*', '\\1')::int" )
	private Country country;

	//Getters and setters omitted for brevity

}

@Entity(name = "Country")
@Table(name = "countries")
public static class Country {

	@Id
	private Integer id;

	private String name;

	//Getters and setters, equals and hashCode methods omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CREATE TABLE countries (
    id int4 NOT NULL,
    name VARCHAR(255),
    PRIMARY KEY ( id )
)

CREATE TABLE users (
    id int8 NOT NULL,
    firstName VARCHAR(255),
    lastName VARCHAR(255),
    phoneNumber VARCHAR(255),
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>country</code>协会<code>User</code>实体通过由提供的国家/地区标识符映射<code>phoneNumber</code>属性。</p>
</div>
<div class="paragraph">
<p>考虑到我们具有以下实体：</p>
</div>
<div id="associations-JoinFormula-persistence-example" class="exampleblock">
<div class="title">示例187。 <code>@JoinFormula</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Country US = new Country();
US.setId( 1 );
US.setName( "United States" );

Country Romania = new Country();
Romania.setId( 40 );
Romania.setName( "Romania" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	entityManager.persist( US );
	entityManager.persist( Romania );
} );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	User user1 = new User( );
	user1.setId( 1L );
	user1.setFirstName( "John" );
	user1.setLastName( "Doe" );
	user1.setPhoneNumber( "+1-234-5678" );
	entityManager.persist( user1 );

	User user2 = new User( );
	user2.setId( 2L );
	user2.setFirstName( "Vlad" );
	user2.setLastName( "Mihalcea" );
	user2.setPhoneNumber( "+40-123-4567" );
	entityManager.persist( user2 );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>User</code>实体， <code>country</code>属性由<code>@JoinFormula</code>表达：</p>
</div>
<div id="associations-JoinFormula-fetching-example" class="exampleblock">
<div class="title">实施例188。 <code>@JoinFormula</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	log.info( "Fetch User entities" );

	User john = entityManager.find( User.class, 1L );
	assertEquals( US, john.getCountry());

	User vlad = entityManager.find( User.class, 2L );
	assertEquals( Romania, vlad.getCountry());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">-- Fetch User entities

SELECT
    u.id as id1_1_0_,
    u.firstName as firstNam2_1_0_,
    u.lastName as lastName3_1_0_,
    u.phoneNumber as phoneNum4_1_0_,
    REGEXP_REPLACE(u.phoneNumber, '\+(\d+)-.*', '\1')::int as formula1_0_,
    c.id as id1_0_1_,
    c.name as name2_0_1_
FROM
    users u
LEFT OUTER JOIN
    countries c
        ON REGEXP_REPLACE(u.phoneNumber, '\+(\d+)-.*', '\1')::int = c.id
WHERE
    u.id=?

-- binding parameter [1] as [BIGINT] - [1]

SELECT
    u.id as id1_1_0_,
    u.firstName as firstNam2_1_0_,
    u.lastName as lastName3_1_0_,
    u.phoneNumber as phoneNum4_1_0_,
    REGEXP_REPLACE(u.phoneNumber, '\+(\d+)-.*', '\1')::int as formula1_0_,
    c.id as id1_0_1_,
    c.name as name2_0_1_
FROM
    users u
LEFT OUTER JOIN
    countries c
        ON REGEXP_REPLACE(u.phoneNumber, '\+(\d+)-.*', '\1')::int = c.id
WHERE
    u.id=?

-- binding parameter [1] as [BIGINT] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此， <code>@JoinFormula</code>批注用于定义父子关联之间的自定义联接关联。</p>
</div>
</div>
<div class="sect3">
<h4 id="associations-JoinColumnOrFormula"><a class="anchor" href="#associations-JoinColumnOrFormula"></a> 2.7.8。 <code>@JoinColumnOrFormula</code>映射</h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/JoinColumnOrFormula.html"><code>@JoinColumnOrFormula</code></a>当我们需要考虑列值以及<code>@JoinFormula</code> 。</p>
</div>
<div id="associations-JoinColumnOrFormula-example" class="exampleblock">
<div class="title">示例189 <code>@JoinColumnOrFormula</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "User")
@Table(name = "users")
public static class User {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	private String language;

	@ManyToOne
	@JoinColumnOrFormula( column =
		@JoinColumn(
			name = "language",
			referencedColumnName = "primaryLanguage",
			insertable = false,
			updatable = false
		)
	)
	@JoinColumnOrFormula( formula =
		@JoinFormula(
			value = "true",
			referencedColumnName = "is_default"
		)
	)
	private Country country;

	//Getters and setters omitted for brevity

}

@Entity(name = "Country")
@Table(name = "countries")
public static class Country implements Serializable {

	@Id
	private Integer id;

	private String name;

	private String primaryLanguage;

	@Column(name = "is_default")
	private boolean _default;

	//Getters and setters, equals and hashCode methods omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CREATE TABLE countries (
    id INTEGER NOT NULL,
    is_default boolean,
    name VARCHAR(255),
    primaryLanguage VARCHAR(255),
    PRIMARY KEY ( id )
)

CREATE TABLE users (
    id BIGINT NOT NULL,
    firstName VARCHAR(255),
    language VARCHAR(255),
    lastName VARCHAR(255),
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>country</code>协会<code>User</code>实体是由<code>language</code>属性值和相关的<code>Country</code><code>is_default</code>列值。</p>
</div>
<div class="paragraph">
<p>考虑到我们具有以下实体：</p>
</div>
<div id="associations-JoinColumnOrFormula-persistence-example" class="exampleblock">
<div class="title">示例190 <code>@JoinColumnOrFormula</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Country US = new Country();
US.setId( 1 );
US.setDefault( true );
US.setPrimaryLanguage( "English" );
US.setName( "United States" );

Country Romania = new Country();
Romania.setId( 40 );
Romania.setDefault( true );
Romania.setName( "Romania" );
Romania.setPrimaryLanguage( "Romanian" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	entityManager.persist( US );
	entityManager.persist( Romania );
} );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	User user1 = new User( );
	user1.setId( 1L );
	user1.setFirstName( "John" );
	user1.setLastName( "Doe" );
	user1.setLanguage( "English" );
	entityManager.persist( user1 );

	User user2 = new User( );
	user2.setId( 2L );
	user2.setFirstName( "Vlad" );
	user2.setLastName( "Mihalcea" );
	user2.setLanguage( "Romanian" );
	entityManager.persist( user2 );

} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>User</code>实体， <code>country</code>属性由<code>@JoinColumnOrFormula</code>表达：</p>
</div>
<div id="associations-JoinColumnOrFormula-fetching-example" class="exampleblock">
<div class="title">例子191。 <code>@JoinColumnOrFormula</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	log.info( "Fetch User entities" );

	User john = entityManager.find( User.class, 1L );
	assertEquals( US, john.getCountry());

	User vlad = entityManager.find( User.class, 2L );
	assertEquals( Romania, vlad.getCountry());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    u.id as id1_1_0_,
    u.language as language3_1_0_,
    u.firstName as firstNam2_1_0_,
    u.lastName as lastName4_1_0_,
    1 as formula1_0_,
    c.id as id1_0_1_,
    c.is_default as is_defau2_0_1_,
    c.name as name3_0_1_,
    c.primaryLanguage as primaryL4_0_1_
FROM
    users u
LEFT OUTER JOIN
    countries c
        ON u.language = c.primaryLanguage
        AND 1 = c.is_default
WHERE
    u.id = ?

-- binding parameter [1] as [BIGINT] - [1]

SELECT
    u.id as id1_1_0_,
    u.language as language3_1_0_,
    u.firstName as firstNam2_1_0_,
    u.lastName as lastName4_1_0_,
    1 as formula1_0_,
    c.id as id1_0_1_,
    c.is_default as is_defau2_0_1_,
    c.name as name3_0_1_,
    c.primaryLanguage as primaryL4_0_1_
FROM
    users u
LEFT OUTER JOIN
    countries c
        ON u.language = c.primaryLanguage
        AND 1 = c.is_default
WHERE
    u.id = ?

-- binding parameter [1] as [BIGINT] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此， <code>@JoinColumnOrFormula</code>批注用于定义父子关联之间的自定义联接关联。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="collections"><a class="anchor" href="#collections"></a> 2.8。馆藏</h3>
<div class="paragraph">
<p>当然，Hibernate也允许持久化集合。这些持久性集合几乎可以包含任何其他Hibernate类型，包括基本类型，自定义类型，可嵌入对象以及对其他实体的引用。在这种情况下，值语义和引用语义之间的区别非常重要。集合中的对象可能使用<em>值</em>语义（其生命周期完全取决于集合所有者）来处理，或者它可能是对具有其自身生命周期的另一个实体的引用。在后一种情况下，仅将两个对象之间的<em>链接</em>视为集合所保持的状态。</p>
</div>
<div class="paragraph">
<p>即使集合是由可嵌入类型定义的，集合的所有者也始终是实体。集合在类型之间形成一对多的关联，因此可以有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>值类型集合</p>
</li>
<li>
<p>可嵌入类型集合</p>
</li>
<li>
<p>实体集合</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hibernate使用自己的集合实现，这些实现丰富了延迟加载，缓存或状态更改检测语义。因此，必须将持久性集合声明为接口类型。实际的界面可能是<code>java.util.Collection</code> ， <code>java.util.List</code> ， <code>java.util.Set</code> ， <code>java.util.Map</code> ， <code>java.util.SortedSet</code> ， <code>java.util.SortedMap</code>甚至其他对象类型（这意味着您必须编写一个实现<code>org.hibernate.usertype.UserCollectionType</code> ）。</p>
</div>
<div class="paragraph">
<p>如下例所示，使用接口类型而不是实体映射中声明的集合实现很重要。</p>
</div>
<div id="collections-collection-proxy-example" class="exampleblock">
<div class="title">示例192Hibernate使用自己的集合实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@ElementCollection
	private List&lt;String&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

Person person = entityManager.find( Person.class, 1L );
//Throws java.lang.ClassCastException: org.hibernate.collection.internal.PersistentBag cannot be cast to java.util.ArrayList
ArrayList&lt;String&gt; phones = (ArrayList&lt;String&gt;) person.getPhones();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用适当的Java Collections Framework接口而不是特定的实现来定义集合非常重要。</p>
</div>
<div class="paragraph">
<p>从理论上讲，这只是遵循良好的设计原则。从实际的角度来看，Hibernate（像其他持久性提供程序一样）将使用它们自己的集合实现，这些实现符合Java Collections Framework接口。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate注入的持久性集合的行为类似于<code>ArrayList</code> ， <code>HashSet</code> ， <code>TreeSet</code> ， <code>HashMap</code>要么<code>TreeMap</code> ，具体取决于接口类型。</p>
</div>
<div class="sect3">
<h4 id="collections-synopsis"><a class="anchor" href="#collections-synopsis"></a> 2.8.1。集合作为值类型</h4>
<div class="paragraph">
<p>值和可嵌入类型集合的行为与基本类型相似，因为它们在由持久性对象引用时会自动保留，而在未引用时会自动删除。如果将集合从一个持久对象传递到另一个持久对象，则其元素可能会从一个表移动到另一个表。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>两个实体不能共享对同一集合实例的引用。集合值的属性不支持空值语义，因为Hibernate不会区分空集合引用和空集合。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="collections-value"><a class="anchor" href="#collections-value"></a> 2.8.2。值类型的集合</h4>
<div class="paragraph">
<p>值类型的集合包括基本类型和可嵌入类型。集合不能嵌套，并且在集合中使用时，不允许可嵌入类型定义其他集合。</p>
</div>
<div class="paragraph">
<p>对于值类型的集合，JPA 2.0定义了<code>@ElementCollection</code>注解。值类型集合的生命周期完全由其拥有的实体控制。</p>
</div>
<div class="paragraph">
<p>考虑到前面的示例映射，在清除电话集合时，Hibernate会删除所有关联的电话。将新元素添加到值类型集合时，Hibernate会发出新的insert语句。</p>
</div>
<div id="collections-value-type-collection-lifecycle-example" class="exampleblock">
<div class="title">示例193。值类型收集生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.getPhones().clear();
person.getPhones().add( "123-456-7890" );
person.getPhones().add( "456-000-1234" );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">DELETE FROM Person_phones WHERE   Person_id = 1

INSERT INTO Person_phones ( Person_id, phones )
VALUES ( 1, '123-456-7890' )

INSERT INTO Person_phones  (Person_id, phones)
VALUES  ( 1, '456-000-1234' )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果删除所有元素或添加新元素非常简单，则删除某个条目实际上需要从头开始重建整个集合。</p>
</div>
<div id="collections-value-type-collection-remove-example" class="exampleblock">
<div class="title">示例194。删除集合元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.getPhones().remove( 0 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">DELETE FROM Person_phones WHERE Person_id = 1

INSERT INTO Person_phones ( Person_id, phones )
VALUES ( 1, '456-000-1234' )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果需要删除许多元素并将其重新插入数据库表中，则取决于元素的数量，此行为可能无效。解决方法是使用<code>@OrderColumn</code> ，尽管效率不如使用实际链接表主键时的效率，但可以提高删除操作的效率。</p>
</div>
<div id="collections-value-type-collection-order-column-remove-example" class="exampleblock">
<div class="title">示例195使用订单列删除集合元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@ElementCollection
@OrderColumn(name = "order_id")
private List&lt;String&gt; phones = new ArrayList&lt;&gt;();

person.getPhones().remove( 0 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">DELETE FROM Person_phones
WHERE  Person_id = 1
       AND order_id = 1

UPDATE Person_phones
SET    phones = '456-000-1234'
WHERE  Person_id = 1
       AND order_id = 0</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@OrderColumn</code>从集合的尾部删除时，column的效果最佳，因为它只需要一个delete语句。从集合的头部或中间删除需要删除多余的元素，并更新其余元素以保留元素顺序。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可嵌入类型集合的行为与值类型集合相同。将可嵌入对象添加到集合中会触发关联的插入语句，并且从集合中删除元素将生成删除语句。</p>
</div>
<div id="collections-embeddable-type-collection-lifecycle-example" class="exampleblock">
<div class="title">例子196。可嵌入类型集合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@ElementCollection
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Embeddable
public static class Phone {

	private String type;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}

person.getPhones().add( new Phone( "landline", "028-234-9876" ) );
person.getPhones().add( new Phone( "mobile", "072-122-9876" ) );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person_phones ( Person_id, number, type )
VALUES ( 1, '028-234-9876', 'landline' )

INSERT INTO Person_phones ( Person_id, number, type )
VALUES ( 1, '072-122-9876', 'mobile' )</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-entity"><a class="anchor" href="#collections-entity"></a> 2.8.3。实体集合</h4>
<div class="paragraph">
<p>如果值类型集合只能在所有者实体和多个基本或可嵌入类型之间形成一对多关联，则实体集合可以表示<a href="#associations-one-to-many">@OneToMany</a>和<a href="#associations-many-to-many">@ManyToMany</a>关联。</p>
</div>
<div class="paragraph">
<p>从关系数据库的角度来看，关联是由外键方（子方）定义的。对于值类型集合，只有实体可以控制关联（父级），但是对于实体集合，关联的两侧都由持久性上下文管理。</p>
</div>
<div class="paragraph">
<p>因此，实体集合可以设计为两个主要类别：单向和双向关联。单向关联与值类型集合非常相似，因为只有父级控制此关系。双向关联更加棘手，因为即使双方始终需要保持同步，也只有一方负责管理关联。双向关联具有<em>拥有</em>方和<em>反方（mappedBy）</em> 。</p>
</div>
<div class="paragraph">
<p>对实体集合进行分类的另一种方法是通过基础集合类型，因此我们可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包袋</p>
</li>
<li>
<p>索引列表</p>
</li>
<li>
<p>套</p>
</li>
<li>
<p>排序集</p>
</li>
<li>
<p>地图</p>
</li>
<li>
<p>排序的地图</p>
</li>
<li>
<p>数组</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在以下各节中，我们将介绍所有这些集合类型，并讨论单向和双向关联。</p>
</div>
</div>
<div class="sect3">
<h4 id="collections-bag"><a class="anchor" href="#collections-bag"></a> 2.8.4。包袋</h4>
<div class="paragraph">
<p>袋是无序列表，我们可以有单向袋或双向袋。</p>
</div>
<div class="sect4">
<h5 id="collections-unidirectional-bag"><a class="anchor" href="#collections-unidirectional-bag"></a>单向袋</h5>
<div class="paragraph">
<p>单向袋使用单个<code>@OneToMany</code>关联的父级上的注释。在后台，Hibernate需要一个关联表来管理父子关系，如下面的示例所示：</p>
</div>
<div id="collections-unidirectional-bag-example" class="exampleblock">
<div class="title">实施例197。单向袋</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	private String type;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Person_Phone (
    Person_id BIGINT NOT NULL ,
    phones_id BIGINT NOT NULL
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    type VARCHAR(255) ,
    PRIMARY KEY ( id )
)

ALTER TABLE Person_Phone
ADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf
UNIQUE (phones_id)

ALTER TABLE Person_Phone
ADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391
FOREIGN KEY (phones_id) REFERENCES Phone

ALTER TABLE Person_Phone
ADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2
FOREIGN KEY (Person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于父级和子级都是实体，因此持久性上下文分别管理每个实体。</p>
</div>
<div class="paragraph">
<p>级联机制使您可以将实体状态从父实体传播到其子实体。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过用<code>CascadeType.ALL</code>属性，单向关联生命周期变得非常类似于值类型集合的生命周期。</p>
</div>
<div id="collections-unidirectional-bag-lifecycle-example" class="exampleblock">
<div class="title">实施例198。单向袋的生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person( 1L );
person.getPhones().add( new Phone( 1L, "landline", "028-234-9876" ) );
person.getPhones().add( new Phone( 2L, "mobile", "072-122-9876" ) );
entityManager.persist( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person ( id )
VALUES ( 1 )

INSERT INTO Phone ( number, type, id )
VALUES ( '028-234-9876', 'landline', 1 )

INSERT INTO Phone ( number, type, id )
VALUES ( '072-122-9876', 'mobile', 2 )

INSERT INTO Person_Phone ( Person_id, phones_id )
VALUES ( 1, 1 )

INSERT INTO Person_Phone ( Person_id, phones_id )
VALUES ( 1, 2 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，父实体持久化之后，子实体也将持久化。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>就像值类型集合一样，单向袋在修改集合结构（删除或重新组合元素）时效率不高。</p>
</div>
<div class="paragraph">
<p>由于父方不能唯一地标识每个子项，因此Hibernate删除与父实体关联的所有链接表行，并重新添加在当前集合状态下找到的其余行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="collections-bidirectional-bag"><a class="anchor" href="#collections-bidirectional-bag"></a>双向袋</h5>
<div class="paragraph">
<p>双向袋是最常见的实体集合类型。的<code>@ManyToOne</code>一侧是双向袋关联的拥有侧，而<code>@OneToMany</code>被<em>逆</em>侧，被标以<code>mappedBy</code>属性。</p>
</div>
<div id="collections-bidirectional-bag-example" class="exampleblock">
<div class="title">示例199。双向袋</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addPhone(Phone phone) {
		phones.add( phone );
		phone.setPerson( this );
	}

	public void removePhone(Phone phone) {
		phones.remove( phone );
		phone.setPerson( null );
	}
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	private String type;

	@Column(name = "`number`", unique = true)
	@NaturalId
	private String number;

	@ManyToOne
	private Person person;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL, PRIMARY KEY (id)
)

CREATE TABLE Phone (
    id BIGINT NOT NULL,
    number VARCHAR(255),
    type VARCHAR(255),
    person_id BIGINT,
    PRIMARY KEY (id)
)

ALTER TABLE Phone
ADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6
UNIQUE (number)

ALTER TABLE Phone
ADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg
FOREIGN KEy (person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div id="collections-bidirectional-bag-lifecycle-example" class="exampleblock">
<div class="title">示例200双向袋的生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.addPhone( new Phone( 1L, "landline", "028-234-9876" ) );
person.addPhone( new Phone( 2L, "mobile", "072-122-9876" ) );
entityManager.flush();
person.removePhone( person.getPhones().get( 0 ) );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Phone (number, person_id, type, id)
VALUES ( '028-234-9876', 1, 'landline', 1 )

INSERT INTO Phone (number, person_id, type, id)
VALUES ( '072-122-9876', 1, 'mobile', 2 )

UPDATE Phone
SET person_id = NULL, type = 'landline' where id = 1</code></pre>
</div>
</div>
</div>
</div>
<div id="collections-bidirectional-bag-orphan-removal-example" class="exampleblock">
<div class="title">示例201。双向袋，带孤儿</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL, orphanRemoval = true)
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">DELETE FROM Phone WHERE id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当重新运行上一个示例时，子级将被删除，因为父级在取消关联子级实体引用时会传播该删除。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-list"><a class="anchor" href="#collections-list"></a> 2.8.5。有序列表</h4>
<div class="paragraph">
<p>尽管他们使用<code>List</code>在Java方面的接口上，包不保留元素顺序。要保留收集元素的顺序，有两种可能性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@OrderBy</code></dt>
<dd>
<p>使用子实体属性在检索时对集合进行排序</p>
</dd>
<dt class="hdlist1"><code>@OrderColumn</code></dt>
<dd>
<p>集合使用集合链接表中的专用订单列</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="collections-unidirectional-ordered-list"><a class="anchor" href="#collections-unidirectional-ordered-list"></a>单向有序列表</h5>
<div class="paragraph">
<p>使用时<code>@OrderBy</code>注释，映射如下所示：</p>
</div>
<div id="collections-unidirectional-ordered-list-order-by-example" class="exampleblock">
<div class="title">示例202。单向<code>@OrderBy</code>清单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	@OrderBy("number")
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	private String type;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>数据库映射与“ <a href="#collections-unidirectional-bag">单向袋”</a>示例相同，因此不再重复。在获取集合时，Hibernate生成以下选择语句：</p>
</div>
<div id="collections-unidirectional-ordered-list-order-by-select-example" class="exampleblock">
<div class="title">示例203。单向<code>@OrderBy</code>列表选择语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">SELECT
   phones0_.Person_id AS Person_i1_1_0_,
   phones0_.phones_id AS phones_i2_1_0_,
   unidirecti1_.id AS id1_2_1_,
   unidirecti1_."number" AS number2_2_1_,
   unidirecti1_.type AS type3_2_1_
FROM
   Person_Phone phones0_
INNER JOIN
   Phone unidirecti1_ ON phones0_.phones_id=unidirecti1_.id
WHERE
   phones0_.Person_id = 1
ORDER BY
   unidirecti1_."number"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>子表列用于对列表元素进行排序。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@OrderBy</code>注释可以采用多个实体属性，并且每个属性也可以采用排序方向（例如<code>@OrderBy("name ASC, type DESC")</code> ）。</p>
</div>
<div class="paragraph">
<p>如果未指定属性（例如<code>@OrderBy</code> ），子实体表的主键用于排序。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另一个订购选项是使用<code>@OrderColumn</code>注解：</p>
</div>
<div id="collections-unidirectional-ordered-list-order-column-example" class="exampleblock">
<div class="title">例子204。单向<code>@OrderColumn</code>清单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(cascade = CascadeType.ALL)
@OrderColumn(name = "order_id")
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person_Phone (
    Person_id BIGINT NOT NULL ,
    phones_id BIGINT NOT NULL ,
    order_id INTEGER NOT NULL ,
    PRIMARY KEY ( Person_id, order_id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，链接表将<code>order_id</code>列并使用它来实现收集元素的顺序。提取列表时，将执行以下选择查询：</p>
</div>
<div id="collections-unidirectional-ordered-list-order-column-select-example" class="exampleblock">
<div class="title">范例205。单向<code>@OrderColumn</code>列表选择语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">select
   phones0_.Person_id as Person_i1_1_0_,
   phones0_.phones_id as phones_i2_1_0_,
   phones0_.order_id as order_id3_0_,
   unidirecti1_.id as id1_2_1_,
   unidirecti1_.number as number2_2_1_,
   unidirecti1_.type as type3_2_1_
from
   Person_Phone phones0_
inner join
   Phone unidirecti1_
      on phones0_.phones_id=unidirecti1_.id
where
   phones0_.Person_id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随着<code>order_id</code>从数据库中获取列表后，Hibernate可以在内存中对列表进行排序。</p>
</div>
</div>
<div class="sect4">
<h5 id="collections-bidirectional-ordered-list"><a class="anchor" href="#collections-bidirectional-ordered-list"></a>双向有序列表</h5>
<div class="paragraph">
<p>该映射与“ <a href="#collections-bidirectional-bag">双向袋”</a>示例相似，只是父端将使用以下任一注解<code>@OrderBy</code>要么<code>@OrderColumn</code> 。</p>
</div>
<div id="collections-bidirectional-ordered-list-order-by-example" class="exampleblock">
<div class="title">例子206。双向的<code>@OrderBy</code>清单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@OrderBy("number")
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就像单向<code>@OrderBy</code>列出<code>number</code>列用于在SQL级别上对语句进行排序。</p>
</div>
<div class="paragraph">
<p>使用时<code>@OrderColumn</code>注释， <code>order_id</code>列将被嵌入到子表中：</p>
</div>
<div id="collections-bidirectional-ordered-list-order-column-example" class="exampleblock">
<div class="title">示例207双向的<code>@OrderColumn</code>清单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@OrderColumn(name = "order_id")
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    type VARCHAR(255) ,
    person_id BIGINT ,
    order_id INTEGER ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取集合时，Hibernate将使用获取的有序列对元素进行排序。 <code>@OrderColumn</code>映射。</p>
</div>
</div>
<div class="sect4">
<h5 id="collections-customizing-ordered-list-ordinal"><a class="anchor" href="#collections-customizing-ordered-list-ordinal"></a>自定义有序列表顺序</h5>
<div class="paragraph">
<p>您可以使用以下命令自定义基础有序列表的顺序<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ListIndexBase.html"><code>@ListIndexBase</code></a>注解。</p>
</div>
<div id="collections-customizing-ordered-list-ordinal-mapping-example" class="exampleblock">
<div class="title">实施例208。 <code>@ListIndexBase</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@OrderColumn(name = "order_id")
@ListIndexBase(100)
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当插入两个<code>Phone</code>记录，Hibernate这次将从100开始启动List索引。</p>
</div>
<div id="collections-customizing-ordered-list-ordinal-persist-example" class="exampleblock">
<div class="title">范例209。 <code>@ListIndexBase</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person( 1L );
entityManager.persist( person );
person.addPhone( new Phone( 1L, "landline", "028-234-9876" ) );
person.addPhone( new Phone( 2L, "mobile", "072-122-9876" ) );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Phone("number", person_id, type, id)
VALUES ('028-234-9876', 1, 'landline', 1)

INSERT INTO Phone("number", person_id, type, id)
VALUES ('072-122-9876', 1, 'mobile', 2)

UPDATE Phone
SET order_id = 100
WHERE id = 1

UPDATE Phone
SET order_id = 101
WHERE id = 2</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections-customizing-ordered-by-sql-clause"><a class="anchor" href="#collections-customizing-ordered-by-sql-clause"></a>自定义ORDER BY SQL子句</h5>
<div class="paragraph">
<p>而JPA <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OrderBy.html"><code>@OrderBy</code></a>注释允许您指定在获取当前带注释的集合（特定于Hibernate）时用于排序的实体属性<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OrderBy.html"><code>@OrderBy</code></a>注解用于指定<strong>SQL</strong>子句。</p>
</div>
<div class="paragraph">
<p>在以下示例中， <code>@OrderBy</code>注释使用<code>CHAR_LENGTH</code> SQL函数命令<code>Article</code>实体的字符数<code>name</code>属性。</p>
</div>
<div id="collections-customizing-ordered-by-sql-clause-mapping-example" class="exampleblock">
<div class="title">例子210。 <code>@OrderBy</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@OneToMany(
		mappedBy = "person",
		cascade = CascadeType.ALL
	)
	@org.hibernate.annotations.OrderBy(
		clause = "CHAR_LENGTH(name) DESC"
	)
	private List&lt;Article&gt; articles = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity
}

@Entity(name = "Article")
public static class Article {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	private String content;

	@ManyToOne(fetch = FetchType.LAZY)
	private Person person;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>articles</code>集合，Hibernate使用映射提供的ORDER BY SQL子句：</p>
</div>
<div id="collections-customizing-ordered-by-sql-clause-fetching-example" class="exampleblock">
<div class="title">示例211 <code>@OrderBy</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
assertEquals(
	"High-Performance Hibernate",
	person.getArticles().get( 0 ).getName()
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">select
    a.person_id as person_i4_0_0_,
    a.id as id1_0_0_,
    a.content as content2_0_1_,
    a.name as name3_0_1_,
    a.person_id as person_i4_0_1_
from
    Article a
where
    a.person_id = ?
order by
    CHAR_LENGTH(a.name) desc</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-set"><a class="anchor" href="#collections-set"></a> 2.8.6。套装</h4>
<div class="paragraph">
<p>集合是不允许重复输入的集合，Hibernate支持无序的集合<code>Set</code>和自然顺序<code>SortedSet</code> 。</p>
</div>
<div class="sect4">
<h5 id="collections-unidirectional-set"><a class="anchor" href="#collections-unidirectional-set"></a>单向集</h5>
<div class="paragraph">
<p>单向集使用链接表来保存父子关联，并且实体映射如下所示：</p>
</div>
<div id="collections-unidirectional-set-example" class="exampleblock">
<div class="title">例子212。单向集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	private Set&lt;Phone&gt; phones = new HashSet&lt;&gt;();

	//Getters and setters are omitted for brevity
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	private String type;

	@NaturalId
	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>单向设置生命周期与<a href="#collections-unidirectional-bag">单向袋</a>类似，因此可以省略。唯一的区别是<code>Set</code>不允许重复，但是此约束由Java对象协定而不是数据库映射强制执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用Set时，为子实体提供适当的equals / hashCode实现非常重要。</p>
</div>
<div class="paragraph">
<p>在没有自定义的equals / hashCode实现逻辑的情况下，Hibernate将使用默认的基于Java参考的对象相等性，当混合分离对象实例和托管对象实例时，这可能会导致意外结果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="collections-bidirectional-set"><a class="anchor" href="#collections-bidirectional-set"></a>双向套</h5>
<div class="paragraph">
<p>就像双向包一样，双向集不使用链接表，并且子表具有引用父表主键的外键。生命周期就像双向包装袋一样，除了重复袋被过滤掉。</p>
</div>
<div id="collections-bidirectional-set-example" class="exampleblock">
<div class="title">例子213。双向集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
	private Set&lt;Phone&gt; phones = new HashSet&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addPhone(Phone phone) {
		phones.add( phone );
		phone.setPerson( this );
	}

	public void removePhone(Phone phone) {
		phones.remove( phone );
		phone.setPerson( null );
	}
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	private String type;

	@Column(name = "`number`", unique = true)
	@NaturalId
	private String number;

	@ManyToOne
	private Person person;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-sorted-set"><a class="anchor" href="#collections-sorted-set"></a> 2.8.7。排序集</h4>
<div class="paragraph">
<p>对于排序集，实体映射必须使用<code>SortedSet</code>接口。根据<code>SortedSet</code>合同，所有要素必须执行<code>Comparable</code>接口，并因此提供排序逻辑。</p>
</div>
<div class="sect4">
<h5 id="collections-unidirectional-sorted-set"><a class="anchor" href="#collections-unidirectional-sorted-set"></a>单向排序集</h5>
<div class="paragraph">
<p>一种<code>SortedSet</code>依赖于child元素给定的自然排序顺序<code>Comparable</code>实现逻辑必须用<code>@SortNatural</code>Hibernate注释。</p>
</div>
<div id="collections-unidirectional-sorted-set-natural-comparator-example" class="exampleblock">
<div class="title">例子214。单向自然排序集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	@SortNatural
	private SortedSet&lt;Phone&gt; phones = new TreeSet&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Phone")
public static class Phone implements Comparable&lt;Phone&gt; {

	@Id
	private Long id;

	private String type;

	@NaturalId
	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

	@Override
	public int compareTo(Phone o) {
		return number.compareTo( o.getNumber() );
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生命周期和数据库映射与“ <a href="#collections-unidirectional-bag">单向”包</a>相同，因此有意省略了它们。</p>
</div>
<div class="paragraph">
<p>为了提供自定义的排序逻辑，Hibernate还提供了一个<code>@SortComparator</code>注解：</p>
</div>
<div id="collections-unidirectional-sorted-set-custom-comparator-example" class="exampleblock">
<div class="title">实施例215。单向自定义比较器排序集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	@SortComparator(ReverseComparator.class)
	private SortedSet&lt;Phone&gt; phones = new TreeSet&lt;&gt;();

	//Getters and setters are omitted for brevity

}

public static class ReverseComparator implements Comparator&lt;Phone&gt; {

	@Override
	public int compare(Phone o1, Phone o2) {
		return o2.compareTo( o1 );
	}
}

@Entity(name = "Phone")
public static class Phone implements Comparable&lt;Phone&gt; {

	@Id
	private Long id;

	private String type;

	@NaturalId
	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

	@Override
	public int compareTo(Phone o) {
		return number.compareTo( o.getNumber() );
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections-bidirectional-sorted-set"><a class="anchor" href="#collections-bidirectional-sorted-set"></a>双向排序集</h5>
<div class="paragraph">
<p>的<code>@SortNatural</code>和<code>@SortComparator</code>双向排序集也是如此：</p>
</div>
<div id="collections-bidirectional-sorted-set-example" class="exampleblock">
<div class="title">例子216。双向自然排序集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@SortNatural
private SortedSet&lt;Phone&gt; phones = new TreeSet&lt;&gt;();

@SortComparator(ReverseComparator.class)
private SortedSet&lt;Phone&gt; phones = new TreeSet&lt;&gt;();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-map"><a class="anchor" href="#collections-map"></a> 2.8.8。地图</h4>
<div class="paragraph">
<p>一种<code>java.util.Map</code>是三元关联，因为它需要一个父实体，一个映射键和一个值。取决于映射，实体可以是映射键或映射值。Hibernate允许使用以下映射键：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MapKeyColumn</code></dt>
<dd>
<p>对于值类型映射，映射键是链接表中的一列，用于定义分组逻辑</p>
</dd>
<dt class="hdlist1"><code>MapKey</code></dt>
<dd>
<p>映射键是存储为映射条目值的实体的主键或其他属性</p>
</dd>
<dt class="hdlist1"><code>MapKeyEnumerated</code></dt>
<dd>
<p>映射键是<code>Enum</code>目标子实体的</p>
</dd>
<dt class="hdlist1"><code>MapKeyTemporal</code></dt>
<dd>
<p>映射键是一个<code>Date</code>或一个<code>Calendar</code>目标子实体的</p>
</dd>
<dt class="hdlist1"><code>MapKeyJoinColumn</code></dt>
<dd>
<p>映射键是在子实体中映射为关联的实体，该实体存储为映射条目键</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="collections-map-value-type"><a class="anchor" href="#collections-map-value-type"></a>值类型图</h5>
<div class="paragraph">
<p>值类型的映射必须使用<code>@ElementCollection</code>注释，就像值类型列表，袋子或集合一样。</p>
</div>
<div id="collections-map-value-type-entity-key-example" class="exampleblock">
<div class="title">示例217以实体作为映射键的值类型映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public enum PhoneType {
	LAND_LINE,
	MOBILE
}

@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@Temporal(TemporalType.TIMESTAMP)
	@ElementCollection
	@CollectionTable(name = "phone_register")
	@Column(name = "since")
	private Map&lt;Phone, Date&gt; phoneRegister = new HashMap&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Embeddable
public static class Phone {

	private PhoneType type;

	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE phone_register (
    Person_id BIGINT NOT NULL ,
    since TIMESTAMP ,
    number VARCHAR(255) NOT NULL ,
    type INTEGER NOT NULL ,
    PRIMARY KEY ( Person_id, number, type )
)

ALTER TABLE phone_register
ADD CONSTRAINT FKrmcsa34hr68of2rq8qf526mlk
FOREIGN KEY (Person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将条目添加到映射将生成以下SQL语句：</p>
</div>
<div id="collections-map-value-type-entity-key-add-example" class="exampleblock">
<div class="title">实施例218。添加值类型映射条目</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.getPhoneRegister().put(
	new Phone( PhoneType.LAND_LINE, "028-234-9876" ), new Date()
);
person.getPhoneRegister().put(
	new Phone( PhoneType.MOBILE, "072-122-9876" ), new Date()
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO phone_register (Person_id, number, type, since)
VALUES (1, '072-122-9876', 1, '2015-12-15 17:16:45.311')

INSERT INTO phone_register (Person_id, number, type, since)
VALUES (1, '028-234-9876', 0, '2015-12-15 17:16:45.311')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections-map-custom-key-type"><a class="anchor" href="#collections-map-custom-key-type"></a>具有自定义键类型的地图</h5>
<div class="paragraph">
<p>Hibernate定义了<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/MapKeyType.html"><code>@MapKeyType</code></a>您可以用来自定义注释的注释<code>Map</code>密钥类型。</p>
</div>
<div class="paragraph">
<p>考虑到数据库中有以下表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table person (
    id int8 not null,
    primary key (id)
)

create table call_register (
    person_id int8 not null,
    phone_number int4,
    call_timestamp_epoch int8 not null,
    primary key (person_id, call_timestamp_epoch)
)

alter table if exists call_register
    add constraint FKsn58spsregnjyn8xt61qkxsub
    foreign key (person_id)
    references person</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>call_register</code>记录每个的通话记录<code>person</code> 。的<code>call_timestamp_epoch</code>列将电话时间戳记存储为自Unix时代以来的Unix时间戳记。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@MapKeyColumn</code>批注用于定义按住键的表列，而<code>@Column</code>映射给出了<code>java.util.Map</code>问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于我们要按其关联映射所有呼叫<code>java.util.Date</code> ，而不是按照自epoch以来的时间戳记（即一个数字）而言，实体映射如下所示：</p>
</div>
<div id="collections-map-custom-key-type-mapping-example" class="exampleblock">
<div class="title">示例219 <code>@MapKeyType</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Table(name = "person")
public static class Person {

	@Id
	private Long id;

	@ElementCollection
	@CollectionTable(
		name = "call_register",
		joinColumns = @JoinColumn(name = "person_id")
	)
	@MapKeyType(
		@Type(
			type = "org.hibernate.userguide.collections.type.TimestampEpochType"
		)
	)
	@MapKeyColumn( name = "call_timestamp_epoch" )
	@Column(name = "phone_number")
	private Map&lt;Date, Integer&gt; callRegister = new HashMap&lt;&gt;();

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相关的<code>TimestampEpochType</code>看起来如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public class TimestampEpochType
        extends AbstractSingleColumnStandardBasicType&lt;Date&gt;
        implements VersionType&lt;Date&gt;, LiteralType&lt;Date&gt; {

    public static final TimestampEpochType INSTANCE = new TimestampEpochType();

    public TimestampEpochType() {
        super(
            BigIntTypeDescriptor.INSTANCE,
            JdbcTimestampTypeDescriptor.INSTANCE
        );
    }

    @Override
    public String getName() {
        return "epoch";
    }

    @Override
    public Date next(
        Date current,
        SharedSessionContractImplementor session) {
        return seed( session );
    }

    @Override
    public Date seed(
        SharedSessionContractImplementor session) {
        return new Timestamp( System.currentTimeMillis() );
    }

    @Override
    public Comparator&lt;Date&gt; getComparator() {
        return getJavaTypeDescriptor().getComparator();
    }

    @Override
    public String objectToSQLString(
        Date value,
        Dialect dialect) throws Exception {
        final Timestamp ts = Timestamp.class.isInstance( value )
            ? ( Timestamp ) value
            : new Timestamp( value.getTime() );
        return StringType.INSTANCE.objectToSQLString(
            ts.toString(), dialect
        );
    }

    @Override
    public Date fromStringValue(
        String xml) throws HibernateException {
        return fromString( xml );
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>TimestampEpochType</code>允许我们将自纪元以来的Unix时间戳映射到<code>java.util.Date</code> 。但是，如果没有<code>@MapKeyType</code> Hibernate批注，将无法自定义<code>Map</code>密钥类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="collections-map-key-class"><a class="anchor" href="#collections-map-key-class"></a>以接口类型为键的地图</h5>
<div class="paragraph">
<p>考虑到你有以下几点<code>PhoneNumber</code>与由<code>MobilePhone</code>类类型：</p>
</div>
<div id="collections-map-key-class-type-mapping-example" class="exampleblock">
<div class="title">示例220 <code>PhoneNumber</code>界面和<code>MobilePhone</code>班级类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface PhoneNumber {

	String get();
}

@Embeddable
public static class MobilePhone
		implements PhoneNumber {

	static PhoneNumber fromString(String phoneNumber) {
		String[] tokens = phoneNumber.split( "-" );
		if ( tokens.length != 3 ) {
			throw new IllegalArgumentException( "invalid phone number: " + phoneNumber );
		}
		int i = 0;
		return new MobilePhone(
			tokens[i++],
			tokens[i++],
			tokens[i]
		);
	}

	private MobilePhone() {
	}

	public MobilePhone(
			String countryCode,
			String operatorCode,
			String subscriberCode) {
		this.countryCode = countryCode;
		this.operatorCode = operatorCode;
		this.subscriberCode = subscriberCode;
	}

	@Column(name = "country_code")
	private String countryCode;

	@Column(name = "operator_code")
	private String operatorCode;

	@Column(name = "subscriber_code")
	private String subscriberCode;

	@Override
	public String get() {
		return String.format(
			"%s-%s-%s",
			countryCode,
			operatorCode,
			subscriberCode
		);
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		MobilePhone that = (MobilePhone) o;
		return Objects.equals( countryCode, that.countryCode ) &amp;&amp;
				Objects.equals( operatorCode, that.operatorCode ) &amp;&amp;
				Objects.equals( subscriberCode, that.subscriberCode );
	}

	@Override
	public int hashCode() {
		return Objects.hash( countryCode, operatorCode, subscriberCode );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您想使用<code>PhoneNumber</code>作为一个界面<code>java.util.Map</code>钥匙，那么您需要提供<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyClass.html"><code>@MapKeyClass</code></a>注释也是如此。</p>
</div>
<div id="collections-map-key-class-mapping-example" class="exampleblock">
<div class="title">示例221 <code>@MapKeyClass</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Table(name = "person")
public static class Person {

	@Id
	private Long id;

	@ElementCollection
	@CollectionTable(
		name = "call_register",
		joinColumns = @JoinColumn(name = "person_id")
	)
	@MapKeyColumn( name = "call_timestamp_epoch" )
	@MapKeyClass( MobilePhone.class )
	@Column(name = "call_register")
	private Map&lt;PhoneNumber, Integer&gt; callRegister = new HashMap&lt;&gt;();

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">create table person (
    id bigint not null,
    primary key (id)
)

create table call_register (
    person_id bigint not null,
    call_register integer,
    country_code varchar(255) not null,
    operator_code varchar(255) not null,
    subscriber_code varchar(255) not null,
    primary key (person_id, country_code, operator_code, subscriber_code)
)

alter table call_register
    add constraint FKqyj2at6ik010jqckeaw23jtv2
    foreign key (person_id)
    references person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>插入<code>Person</code>与一个<code>callRegister</code>包含2 <code>MobilePhone</code>参考，Hibernate生成以下SQL语句：</p>
</div>
<div id="collections-map-key-class-persist-example" class="exampleblock">
<div class="title">示例222 <code>@MapKeyClass</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = new Person();
person.setId( 1L );
person.getCallRegister().put( new MobilePhone( "01", "234", "567" ), 101 );
person.getCallRegister().put( new MobilePhone( "01", "234", "789" ), 102 );

entityManager.persist( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">insert into person (id) values (?)

-- binding parameter [1] as [BIGINT] - [1]

insert into call_register(
    person_id,
    country_code,
    operator_code,
    subscriber_code,
    call_register
)
values
    (?, ?, ?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [VARCHAR] - [01]
-- binding parameter [3] as [VARCHAR] - [234]
-- binding parameter [4] as [VARCHAR] - [789]
-- binding parameter [5] as [INTEGER] - [102]

insert into call_register(
    person_id,
    country_code,
    operator_code,
    subscriber_code,
    call_register
)
values
    (?, ?, ?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [VARCHAR] - [01]
-- binding parameter [3] as [VARCHAR] - [234]
-- binding parameter [4] as [VARCHAR] - [567]
-- binding parameter [5] as [INTEGER] - [101]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取一个<code>Person</code>并访问<code>callRegister</code><code>Map</code> ，Hibernate生成以下SQL语句：</p>
</div>
<div id="collections-map-key-class-fetch-example" class="exampleblock">
<div class="title">示例223。 <code>@MapKeyClass</code>获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
assertEquals( 2, person.getCallRegister().size() );

assertEquals(
	Integer.valueOf( 101 ),
	person.getCallRegister().get( MobilePhone.fromString( "01-234-567" ) )
);

assertEquals(
	Integer.valueOf( 102 ),
	person.getCallRegister().get( MobilePhone.fromString( "01-234-789" ) )
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">select
    cr.person_id as person_i1_0_0_,
    cr.call_register as call_reg2_0_0_,
    cr.country_code as country_3_0_,
    cr.operator_code as operator4_0_,
    cr.subscriber_code as subscrib5_0_
from
    call_register cr
where
    cr.person_id = ?

-- binding parameter [1] as [BIGINT] - [1]

-- extracted value ([person_i1_0_0_] : [BIGINT])  - [1]
-- extracted value ([call_reg2_0_0_] : [INTEGER]) - [101]
-- extracted value ([country_3_0_]   : [VARCHAR]) - [01]
-- extracted value ([operator4_0_]   : [VARCHAR]) - [234]
-- extracted value ([subscrib5_0_]   : [VARCHAR]) - [567]

-- extracted value ([person_i1_0_0_] : [BIGINT])  - [1]
-- extracted value ([call_reg2_0_0_] : [INTEGER]) - [102]
-- extracted value ([country_3_0_]   : [VARCHAR]) - [01]
-- extracted value ([operator4_0_]   : [VARCHAR]) - [234]
-- extracted value ([subscrib5_0_]   : [VARCHAR]) - [789]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections-map-unidirectional"><a class="anchor" href="#collections-map-unidirectional"></a>单向地图</h5>
<div class="paragraph">
<p>单向映射仅从父侧公开父子关联。</p>
</div>
<div class="paragraph">
<p>以下示例显示了单向地图，该地图还使用了<code>@MapKeyTemporal</code>注解。映射键是一个时间戳，它是从子实体表中获取的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@MapKey</code>批注用于定义实体属性，该属性用作<code>java.util.Map</code>问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="collections-map-unidirectional-example" class="exampleblock">
<div class="title">示例224单向地图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public enum PhoneType {
	LAND_LINE,
	MOBILE
}

@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
	@JoinTable(
		name = "phone_register",
		joinColumns = @JoinColumn(name = "phone_id"),
		inverseJoinColumns = @JoinColumn(name = "person_id"))
	@MapKey(name = "since")
	@MapKeyTemporal(TemporalType.TIMESTAMP)
	private Map&lt;Date, Phone&gt; phoneRegister = new HashMap&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addPhone(Phone phone) {
		phoneRegister.put( phone.getSince(), phone );
	}
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	private PhoneType type;

	@Column(name = "`number`")
	private String number;

	private Date since;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    since TIMESTAMP ,
    type INTEGER ,
    PRIMARY KEY ( id )
)

CREATE TABLE phone_register (
    phone_id BIGINT NOT NULL ,
    person_id BIGINT NOT NULL ,
    PRIMARY KEY ( phone_id, person_id )
)

ALTER TABLE phone_register
ADD CONSTRAINT FKc3jajlx41lw6clbygbw8wm65w
FOREIGN KEY (person_id) REFERENCES Phone

ALTER TABLE phone_register
ADD CONSTRAINT FK6npoomh1rp660o1b55py9ndw4
FOREIGN KEY (phone_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections-map-bidirectional"><a class="anchor" href="#collections-map-bidirectional"></a>双向地图</h5>
<div class="paragraph">
<p>像大多数双向关联一样，这种关系由子方拥有，而父方是反向方，并且可以将其自身的状态转换传播给子实体。</p>
</div>
<div class="paragraph">
<p>在以下示例中，您可以看到<code>@MapKeyEnumerated</code>被用来<code>Phone</code>枚举成为映射键。</p>
</div>
<div id="collections-map-bidirectional-example" class="exampleblock">
<div class="title">示例225双向地图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(mappedBy = "person", cascade = CascadeType.ALL, orphanRemoval = true)
	@MapKey(name = "type")
	@MapKeyEnumerated
	private Map&lt;PhoneType, Phone&gt; phoneRegister = new HashMap&lt;&gt;();

	//Getters and setters are omitted for brevity

	public void addPhone(Phone phone) {
		phone.setPerson( this );
		phoneRegister.put( phone.getType(), phone );
	}
}

@Entity(name = "Phone")
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	private PhoneType type;

	@Column(name = "`number`")
	private String number;

	private Date since;

	@ManyToOne
	private Person person;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    since TIMESTAMP ,
    type INTEGER ,
    person_id BIGINT ,
    PRIMARY KEY ( id )
)

ALTER TABLE Phone
ADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg
FOREIGN KEY (person_id) REFERENCES Person</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collections-array"><a class="anchor" href="#collections-array"></a> 2.8.9。数组</h4>
<div class="paragraph">
<p>在讨论数组时，重要的是要理解SQL数组类型与作为应用程序域模型的一部分映射的Java数组之间的区别。</p>
</div>
<div class="paragraph">
<p>并非所有数据库都实现SQL-99 ARRAY类型，因此，Hibernate不支持本机数据库数组类型。</p>
</div>
<div class="paragraph">
<p>Hibernate确实支持Java域模型中的数组映射-在概念上与映射List相同。但是，重要的是要意识到，Hibernate无法为实体数组提供延迟加载，因此，强烈建议使用List而不是数组来映射实体的“集合”。</p>
</div>
</div>
<div class="sect3">
<h4 id="collections-array-binary"><a class="anchor" href="#collections-array-binary"></a> 2.8.10。数组为二进制</h4>
<div class="paragraph">
<p>默认情况下，Hibernate将选择一个BINARY类型，如当前所支持的那样。 <code>Dialect</code> 。</p>
</div>
<div id="collections-array-binary-example" class="exampleblock">
<div class="title">范例226。数组存储为二进制</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String[] phones;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Person (
    id BIGINT NOT NULL ,
    phones VARBINARY(255) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要映射数组，例如<code>String[]</code>要么<code>int[]</code>特定于数据库的数组类型（如PostgreSQL） <code>integer[]</code>要么<code>text[]</code> ，您需要编写一个自定义的Hibernate类型。</p>
</div>
<div class="paragraph">
<p>请查看<a href="https://vladmihalcea.com/how-to-map-java-and-sql-arrays-with-jpa-and-hibernate/">本文</a> ，以获取有关如何编写此类自定义Hibernate Type的示例。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="collections-as-basic"><a class="anchor" href="#collections-as-basic"></a> 2.8.11。集合作为基本值类型</h4>
<div class="paragraph">
<p>注意前面的所有示例如何将collection属性显式标记为<code>ElementCollection</code> ， <code>OneToMany</code>要么<code>ManyToMany</code> 。没有这样标记的集合需要自定义的Hibernate <code>Type</code>并且收集元素必须存储在单个数据库列中。</p>
</div>
<div class="paragraph">
<p>有时这是有益的。考虑一个用例，例如<code>VARCHAR</code>代表分隔的字符串列表/字符串集的列。</p>
</div>
<div id="collections-comma-delimited-collection-example" class="exampleblock">
<div class="title">示例227以逗号分隔的集合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@Type(type = "comma_delimited_strings")
	private List&lt;String&gt; phones = new ArrayList&lt;&gt;();

	public List&lt;String&gt; getPhones() {
		return phones;
	}
}

public class CommaDelimitedStringsJavaTypeDescriptor extends AbstractTypeDescriptor&lt;List&gt; {

    public static final String DELIMITER = ",";

    public CommaDelimitedStringsJavaTypeDescriptor() {
        super(
            List.class,
            new MutableMutabilityPlan&lt;List&gt;() {
                @Override
                protected List deepCopyNotNull(List value) {
                    return new ArrayList( value );
                }
            }
        );
    }

    @Override
    public String toString(List value) {
        return ( (List&lt;String&gt;) value ).stream().collect( Collectors.joining( DELIMITER ) );
    }

    @Override
    public List fromString(String string) {
        List&lt;String&gt; values = new ArrayList&lt;&gt;();
        Collections.addAll( values, string.split( DELIMITER ) );
        return values;
    }

    @Override
    public &lt;X&gt; X unwrap(List value, Class&lt;X&gt; type, WrapperOptions options) {
        return (X) toString( value );
    }

    @Override
    public &lt;X&gt; List wrap(X value, WrapperOptions options) {
        return fromString( (String) value );
    }
}

public class CommaDelimitedStringsType extends AbstractSingleColumnStandardBasicType&lt;List&gt; {

    public CommaDelimitedStringsType() {
        super(
            VarcharTypeDescriptor.INSTANCE,
            new CommaDelimitedStringsJavaTypeDescriptor()
        );
    }

    @Override
    public String getName() {
        return "comma_delimited_strings";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>开发人员可以像今天到目前为止讨论的任何其他集合一样使用逗号分隔的集合，并且Hibernate将负责类型转换部分。集合本身的行为类似于任何其他基本值类型，因为其生命周期绑定到其所有者实体。</p>
</div>
<div id="collections-comma-delimited-collection-lifecycle-example" class="exampleblock">
<div class="title">示例228逗号分隔的收集生命周期</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">person.phones.add( "027-123-4567" );
person.phones.add( "028-234-9876" );
session.flush();
person.getPhones().remove( 0 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Person ( phones, id )
VALUES ( '027-123-4567,028-234-9876', 1 )

UPDATE Person
SET    phones = '028-234-9876'
WHERE  id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关开发自定义值类型映射的更多详细信息，请参见《 Hibernate集成指南》。</p>
</div>
</div>
<div class="sect3">
<h4 id="collections-custom"><a class="anchor" href="#collections-custom"></a> 2.8.12。自定义集合类型</h4>
<div class="paragraph">
<p>如果您希望使用其他收集类型， <code>List</code> ， <code>Set</code>要么<code>Map</code> ， 喜欢<code>Queue</code>例如，您必须使用自定义集合类型，如以下示例所示：</p>
</div>
<div id="collections-custom-collection-mapping-example" class="exampleblock">
<div class="title">示例229。自定义集合映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	@OneToMany(cascade = CascadeType.ALL)
	@CollectionType( type = "org.hibernate.userguide.collections.type.QueueType")
	private Collection&lt;Phone&gt; phones = new LinkedList&lt;&gt;();

	//Constructors are omitted for brevity

	public Queue&lt;Phone&gt; getPhones() {
		return (Queue&lt;Phone&gt;) phones;
	}
}

@Entity(name = "Phone")
public static class Phone implements Comparable&lt;Phone&gt; {

	@Id
	private Long id;

	private String type;

	@NaturalId
	@Column(name = "`number`")
	private String number;

	//Getters and setters are omitted for brevity

	@Override
	public int compareTo(Phone o) {
		return number.compareTo( o.getNumber() );
	}

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Phone phone = (Phone) o;
		return Objects.equals( number, phone.number );
	}

	@Override
	public int hashCode() {
		return Objects.hash( number );
	}
}

public class QueueType implements UserCollectionType {

    @Override
    public PersistentCollection instantiate(
            SharedSessionContractImplementor session,
            CollectionPersister persister) throws HibernateException {
        return new PersistentQueue( session );
    }

    @Override
    public PersistentCollection wrap(
            SharedSessionContractImplementor session,
            Object collection) {
        return new PersistentQueue( session, (List) collection );
    }

    @Override
    public Iterator getElementsIterator(Object collection) {
        return ( (Queue) collection ).iterator();
    }

    @Override
    public boolean contains(Object collection, Object entity) {
        return ( (Queue) collection ).contains( entity );
    }

    @Override
    public Object indexOf(Object collection, Object entity) {
        int i = ( (List) collection ).indexOf( entity );
        return ( i &lt; 0 ) ? null : i;
    }

    @Override
    public Object replaceElements(
            Object original,
            Object target,
            CollectionPersister persister,
            Object owner,
            Map copyCache,
            SharedSessionContractImplementor session)
            throws HibernateException {
        Queue result = (Queue) target;
        result.clear();
        result.addAll( (Queue) original );
        return result;
    }

    @Override
    public Object instantiate(int anticipatedSize) {
        return new LinkedList&lt;&gt;();
    }

}

public class PersistentQueue extends PersistentBag implements Queue {

    public PersistentQueue(SharedSessionContractImplementor session) {
        super( session );
    }

    public PersistentQueue(SharedSessionContractImplementor session, List list) {
        super( session, list );
    }

    @Override
    public boolean offer(Object o) {
        return add(o);
    }

    @Override
    public Object remove() {
        return poll();
    }

    @Override
    public Object poll() {
        int size = size();
        if(size &gt; 0) {
            Object first = get(0);
            remove( 0 );
            return first;
        }
        throw new NoSuchElementException();
    }

    @Override
    public Object element() {
        return peek();
    }

    @Override
    public Object peek() {
        return size() &gt; 0 ? get( 0 ) : null;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>之所以<code>Queue</code>接口不用于实体属性是因为Hibernate仅允许以下类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.List</code></p>
</li>
<li>
<p><code>java.util.Set</code></p>
</li>
<li>
<p><code>java.util.Map</code></p>
</li>
<li>
<p><code>java.util.SortedSet</code></p>
</li>
<li>
<p><code>java.util.SortedMap</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，自定义收集类型仍然可以自定义，只要基本类型是上述持久性类型之一即可。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这样， <code>Phone</code>集合可以用作<code>java.util.Queue</code> ：</p>
</div>
<div id="collections-custom-collection-example" class="exampleblock">
<div class="title">例子230。自定义集合示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
Queue&lt;Phone&gt; phones = person.getPhones();
Phone head = phones.peek();
assertSame(head, phones.poll());
assertEquals( 1, phones.size() );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="naturalid"><a class="anchor" href="#naturalid"></a> 2.9。自然身份证</h3>
<div class="paragraph">
<p>自然ID代表领域模型唯一标识符，在现实世界中也具有意义。即使自然ID不能提供良好的主键（通常首选代理键），将其告知Hibernate仍然很有用。稍后我们将看到，Hibernate提供了一个专用，高效的API，用于通过其自然ID加载实体，就像它通过其标识符（PK）来加载实体一样。</p>
</div>
<div class="sect3">
<h4 id="naturalid-mapping"><a class="anchor" href="#naturalid-mapping"></a> 2.9.1。自然ID映射</h4>
<div class="paragraph">
<p>自然ID是根据一个或多个持久属性定义的。</p>
</div>
<div id="naturalid-simple-basic-attribute-mapping-example" class="exampleblock">
<div class="title">示例231使用单个基本属性的自然ID</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	@NaturalId
	private String isbn;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div id="naturalid-single-embedded-attribute-mapping-example" class="exampleblock">
<div class="title">示例232。使用单个嵌入式属性的自然ID</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	@NaturalId
	@Embedded
	private Isbn isbn;

	//Getters and setters are omitted for brevity
}

@Embeddable
public static class Isbn implements Serializable {

	private String isbn10;

	private String isbn13;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Isbn isbn = (Isbn) o;
		return Objects.equals( isbn10, isbn.isbn10 ) &amp;&amp;
				Objects.equals( isbn13, isbn.isbn13 );
	}

	@Override
	public int hashCode() {
		return Objects.hash( isbn10, isbn13 );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div id="naturalid-multiple-attribute-mapping-example" class="exampleblock">
<div class="title">示例233。使用多个持久属性的自然ID</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	@NaturalId
	private String productNumber;

	@NaturalId
	@ManyToOne(fetch = FetchType.LAZY)
	private Publisher publisher;

	//Getters and setters are omitted for brevity
}

@Entity(name = "Publisher")
public static class Publisher implements Serializable {

	@Id
	private Long id;

	private String name;

	//Getters and setters are omitted for brevity

	@Override
	public boolean equals(Object o) {
		if ( this == o ) {
			return true;
		}
		if ( o == null || getClass() != o.getClass() ) {
			return false;
		}
		Publisher publisher = (Publisher) o;
		return Objects.equals( id, publisher.id ) &amp;&amp;
				Objects.equals( name, publisher.name );
	}

	@Override
	public int hashCode() {
		return Objects.hash( id, name );
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="naturalid-api"><a class="anchor" href="#naturalid-api"></a> 2.9.2。自然ID API</h4>
<div class="paragraph">
<p>如前所述，Hibernate提供了一个API，用于通过关联的自然ID加载实体。这由<code>org.hibernate.NaturalIdLoadAccess</code>通过Session＃byNaturalId获得的合同。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果实体未定义自然ID，则尝试通过其自然ID加载实体将引发异常。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="naturalid-load-access-example" class="exampleblock">
<div class="title">示例234使用NaturalIdLoadAccess</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager
	.unwrap(Session.class)
	.byNaturalId( Book.class )
	.using( "isbn", "978-9730228236" )
	.load();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager
	.unwrap(Session.class)
	.byNaturalId( Book.class )
	.using(
		"isbn",
		new Isbn(
			"973022823X",
			"978-9730228236"
		) )
	.load();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager
	.unwrap(Session.class)
	.byNaturalId( Book.class )
	.using("productNumber", "973022823X")
	.using("publisher", publisher)
	.load();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>NaturalIdLoadAccess提供了两种不同的方法来获取实体：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>load()</code></dt>
<dd>
<p>获取对实体的引用，确保实体状态已初始化</p>
</dd>
<dt class="hdlist1"><code>getReference()</code></dt>
<dd>
<p>获取对该实体的引用。状态可以初始化也可以不初始化。如果该实体已经与当前正在运行的Session相关联，则返回该引用（已加载或未加载）。如果该实体未在当前会话中加载并且该实体支持代理生成，那么将生成并返回未初始化的代理，否则从数据库加载该实体并返回。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>NaturalIdLoadAccess</code>允许通过自然ID加载实体，同时应用悲观锁。有关锁定的更多详细信息，请参见“ <a href="#locking">锁定”</a>一章。</p>
</div>
<div class="paragraph">
<p>我们将讨论NaturalIdLoadAccess（ <code>setSynchronizationEnabled()</code> <a href="#naturalid-mutability-caching">自然ID的可变性和缓存</a> 。</p>
</div>
<div class="paragraph">
<p>因为<code>Company</code>和<code>PostalCarrier</code>实体定义“简单”的自然ID，我们可以按以下方式加载它们：</p>
</div>
<div id="naturalid-simple-load-access-example" class="exampleblock">
<div class="title">示例235通过简单的自然ID加载</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager
	.unwrap(Session.class)
	.bySimpleNaturalId( Book.class )
	.load( "978-9730228236" );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = entityManager
	.unwrap(Session.class)
	.bySimpleNaturalId( Book.class )
	.load(
		new Isbn(
			"973022823X",
			"978-9730228236"
		)
	);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里我们看到了<code>org.hibernate.SimpleNaturalIdLoadAccess</code>通过`Session＃bySimpleNaturalId（）获得的合同。</p>
</div>
<div class="paragraph">
<p><code>SimpleNaturalIdLoadAccess</code>类似于<code>NaturalIdLoadAccess</code>除了它没有定义using方法之外。相反，由于这些<em>简单的</em>自然ID仅基于一个属性定义，因此我们可以直接将相应的自然ID属性值直接传递给<code>load()</code>和<code>getReference()</code>方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果实体未定义自然ID，或者自然ID并非“简单”类型，则将在此处引发异常。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="naturalid-mutability-caching"><a class="anchor" href="#naturalid-mutability-caching"></a> 2.9.3。自然ID-可变性和缓存</h4>
<div class="paragraph">
<p>自然ID可能是可变的或不可变的。默认情况下<code>@NaturalId</code>注释标记了一个不变的自然id属性。不变的自然ID永远不会改变其值。</p>
</div>
<div class="paragraph">
<p>如果自然ID属性的值发生变化， <code>@NaturalId(mutable=true)</code>应该改为使用。</p>
</div>
<div id="naturalid-mutable-mapping-example" class="exampleblock">
<div class="title">示例236。可变的自然ID映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Author")
public static class Author {

	@Id
	private Long id;

	private String name;

	@NaturalId(mutable = true)
	private String email;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在会话中，Hibernate维护从自然id值到实体标识符（PK）值的映射。如果自然id值更改，则此映射可能会过时，直到发生刷新。</p>
</div>
<div class="paragraph">
<p>为了解决这种情况，Hibernate将尝试发现任何此类未决的更改，并在<code>load()</code>要么<code>getReference()</code>方法被执行。需要明确的是：这仅与可变的自然ID有关。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此<em>发现和调整</em>会对性能产生影响。如果确定没有任何可变的自然ID已与当前<code>Session</code>已更改，您可以通过致电禁用此检查<code>setSynchronizationEnabled(false)</code> （默认为<code>true</code> ）。这将迫使Hibernate绕过对可变自然ID的检查。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="naturalid-mutable-synchronized-example" class="exampleblock">
<div class="title">示例237可变自然ID同步用例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Author author = entityManager
	.unwrap(Session.class)
	.bySimpleNaturalId( Author.class )
	.load( "john@acme.com" );

author.setEmail( "john.doe@acme.com" );

assertNull(
	entityManager
		.unwrap(Session.class)
		.bySimpleNaturalId( Author.class )
		.setSynchronizationEnabled( false )
		.load( "john.doe@acme.com" )
);

assertSame( author,
	entityManager
		.unwrap(Session.class)
		.bySimpleNaturalId( Author.class )
		.setSynchronizationEnabled( true )
		.load( "john.doe@acme.com" )
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果启用了第二级缓存，不仅可以在Session中缓存此NaturalId-to-PK分辨率，还可以将其缓存在第二级缓存中。</p>
</div>
<div id="naturalid-caching" class="exampleblock">
<div class="title">例子238。自然ID缓存</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Book")
@NaturalIdCache
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	@NaturalId
	private String isbn;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-model"><a class="anchor" href="#dynamic-model"></a> 2.10。动态模型</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA只承认实体模型映射，因此，如果您担心JPA提供程序的可移植性，最好坚持使用严格的POJO模型。另一方面，Hibernate可以同时使用POJO实体和动态实体模型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="mapping-model-dynamic"><a class="anchor" href="#mapping-model-dynamic"></a> 2.10.1。动态映射模型</h4>
<div class="paragraph">
<p>持久性实体不一定必须表示为POJO / JavaBean类。Hibernate还支持动态模型（使用<code>Map</code>的<code>Maps</code>在运行时）。使用这种方法，您不必编写持久性类，而只需编写映射文件。</p>
</div>
<div class="paragraph">
<p>给定实体在给定SessionFactory中只有一个实体模式。这是对先前版本的更改，以前的版本允许为实体定义多个实体模式并选择要加载的模式。实体模式现在可以在域模型中混合；动态实体可以引用POJO实体，反之亦然。</p>
</div>
<div id="mapping-model-dynamic-example" class="exampleblock">
<div class="title">示例239动态域模型Hibernate映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping&gt;
    &lt;class entity-name="Book"&gt;
        &lt;id name="isbn" column="isbn" length="32" type="string"/&gt;

        &lt;property name="title" not-null="true" length="50" type="string"/&gt;

        &lt;property name="author" not-null="true" length="50" type="string"/&gt;

    &lt;/class&gt;
&lt;/hibernate-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>定义实体映射后，需要指示Hibernate使用动态映射模式：</p>
</div>
<div id="mapping-model-dynamic-setting-example" class="exampleblock">
<div class="title">例子240。动态域模型Hibernate映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">settings.put( "hibernate.default_entity_mode", "dynamic-map" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您要保存以下内容时<code>Book</code>动态实体，Hibernate将生成以下SQL语句：</p>
</div>
<div id="mapping-model-dynamic-persist-example" class="exampleblock">
<div class="title">示例241坚持动态实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Map&lt;String, String&gt; book = new HashMap&lt;&gt;();
book.put( "isbn", "978-9730228236" );
book.put( "title", "High-Performance Java Persistence" );
book.put( "author", "Vlad Mihalcea" );

entityManager
	.unwrap(Session.class)
	.save( "Book", book );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">insert
into
    Book
    (title, author, isbn)
values
    (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [High-Performance Java Persistence]
-- binding parameter [2] as [VARCHAR] - [Vlad Mihalcea]
-- binding parameter [3] as [VARCHAR] - [978-9730228236]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>动态模型的主要优点是无需实体类实现即可快速进行原型开发。主要的缺点是您会丢失编译时类型检查，并且可能会在运行时处理许多异常。但是，由于使用了Hibernate映射，因此可以轻松地对数据库模式进行规范化和完善，从而允许稍后在顶部添加适当的域模型实现。</p>
</div>
<div class="paragraph">
<p>有趣的是，动态模型也适用于某些集成用例。例如，Envers广泛使用动态模型来表示历史数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entity-inheritance"><a class="anchor" href="#entity-inheritance"></a> 2.11。遗产</h3>
<div class="paragraph">
<p>尽管关系数据库系统不提供对继承的支持，但是Hibernate提供了几种策略来将这种面向对象的特征利用到域模型实体上：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">映射超类</dt>
<dd>
<p>继承仅在域模型中实现，而没有在数据库模式中反映出来。参见<a href="#entity-inheritance-mapped-superclass">MappedSuperclass</a> 。</p>
</dd>
<dt class="hdlist1">单桌</dt>
<dd>
<p>域模型类层次结构被具体化为一个表，该表包含属于不同类类型的实体。请参阅<a href="#entity-inheritance-single-table">单表</a> 。</p>
</dd>
<dt class="hdlist1">联接表</dt>
<dd>
<p>基类和所有子类都有自己的数据库表，而获取子类实体也需要与父表联接。请参见连接<a href="#entity-inheritance-joined-table">表</a> 。</p>
</dd>
<dt class="hdlist1">每班桌</dt>
<dd>
<p>每个子类都有自己的表，其中包含子类和基类属性。请参阅<a href="#entity-inheritance-table-per-class">每个班级的表格</a> 。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="entity-inheritance-mapped-superclass"><a class="anchor" href="#entity-inheritance-mapped-superclass"></a> 2.11.1。映射超类</h4>
<div class="paragraph">
<p>在以下域模型类层次结构中， <code>DebitAccount</code>和一个<code>CreditAccount</code>分享相同<code>Account</code>基类。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/domain/inheritance/inheritance_class_diagram.svg" alt="继承类图"></span></p>
</div>
<div class="paragraph">
<p>使用时<code>MappedSuperclass</code> ，则继承仅在域模型中可见，并且每个数据库表都包含基类和子类属性。</p>
</div>
<div id="entity-inheritance-mapped-superclass-example" class="exampleblock">
<div class="title">示例242。 <code>@MappedSuperclass</code>遗产</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE DebitAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)

CREATE TABLE CreditAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为<code>@MappedSuperclass</code>继承模型未在数据库级别进行镜像，因此无法使用引用了<code>@MappedSuperclass</code>当通过基类获取持久对象时。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="entity-inheritance-single-table"><a class="anchor" href="#entity-inheritance-single-table"></a> 2.11.2。单桌</h4>
<div class="paragraph">
<p>单个表继承策略将所有子类仅映射到一个数据库表。每个子类声明其自己的持久性属性。假定版本和id属性是从根类继承的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>省略明确的继承策略时（例如<code>@Inheritance</code> ）, JPA will choose the <code>SINGLE_TABLE</code> strategy by default.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="entity-inheritance-single-table-example" class="exampleblock">
<div class="title">Example 243. Single Table inheritance</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Account (
    DTYPE VARCHAR(31) NOT NULL ,
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each subclass in a hierarchy must define a unique discriminator value, which is used to differentiate between rows belonging to separate subclass types.
If this is not specified, the <code>DTYPE</code> column is used as a discriminator, storing the associated subclass name.</p>
</div>
<div id="entity-inheritance-single-table-persist-example" class="exampleblock">
<div class="title">Example 244. Single Table inheritance discriminator column</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DebitAccount debitAccount = new DebitAccount();
debitAccount.setId( 1L );
debitAccount.setOwner( "John Doe" );
debitAccount.setBalance( BigDecimal.valueOf( 100 ) );
debitAccount.setInterestRate( BigDecimal.valueOf( 1.5d ) );
debitAccount.setOverdraftFee( BigDecimal.valueOf( 25 ) );

CreditAccount creditAccount = new CreditAccount();
creditAccount.setId( 2L );
creditAccount.setOwner( "John Doe" );
creditAccount.setBalance( BigDecimal.valueOf( 1000 ) );
creditAccount.setInterestRate( BigDecimal.valueOf( 1.9d ) );
creditAccount.setCreditLimit( BigDecimal.valueOf( 5000 ) );

entityManager.persist( debitAccount );
entityManager.persist( creditAccount );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Account (balance, interestRate, owner, overdraftFee, DTYPE, id)
VALUES (100, 1.5, 'John Doe', 25, 'DebitAccount', 1)

INSERT INTO Account (balance, interestRate, owner, creditLimit, DTYPE, id)
VALUES (1000, 1.9, 'John Doe', 5000, 'CreditAccount', 2)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using polymorphic queries, only a single table is required to be scanned to fetch all associated subclass instances.</p>
</div>
<div id="entity-inheritance-single-table-query-example" class="exampleblock">
<div class="title">Example 245. Single Table polymorphic query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Account&gt; accounts = entityManager
	.createQuery( "select a from Account a" )
	.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">SELECT  singletabl0_.id AS id2_0_ ,
        singletabl0_.balance AS balance3_0_ ,
        singletabl0_.interestRate AS interest4_0_ ,
        singletabl0_.owner AS owner5_0_ ,
        singletabl0_.overdraftFee AS overdraf6_0_ ,
        singletabl0_.creditLimit AS creditLi7_0_ ,
        singletabl0_.DTYPE AS DTYPE1_0_
FROM    Account singletabl0_</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Among all other inheritance alternatives, the single table strategy performs the best since it requires access to one table only.
Because all subclass columns are stored in a single table, it’s not possible to use NOT NULL constraints anymore, so integrity checks must be moved either into the data access layer or enforced through <code>CHECK</code> or <code>TRIGGER</code> constraints.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="entity-inheritance-discriminator"><a class="anchor" href="#entity-inheritance-discriminator"></a>Discriminator</h5>
<div class="paragraph">
<p>The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row.
Hibernate Core supports the following restricted set of types as discriminator column: <code>String</code>, <code>char</code>, <code>int</code>, <code>byte</code>, <code>short</code>, <code>boolean</code>(including <code>yes_no</code>, <code>true_false</code>).</p>
</div>
<div class="paragraph">
<p>Use the <code>@DiscriminatorColumn</code> to define the discriminator column as well as the discriminator type.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The enum <code>DiscriminatorType</code> used in <code>javax.persistence.DiscriminatorColumn</code> only contains the values <code>STRING</code>, <code>CHAR</code> and <code>INTEGER</code> which means that not all Hibernate supported types are available via the <code>@DiscriminatorColumn</code> annotation.您也可以使用<code>@DiscriminatorFormula</code>在SQL中表示虚拟鉴别符列。当可以从表的一列或多列中提取鉴别值时，这特别有用。都<code>@DiscriminatorColumn</code>和<code>@DiscriminatorFormula</code>将在根实体上设置（每个持久化层次一次）。</p>
</div>
<div class="paragraph">
<p><code>@org.hibernate.annotations.DiscriminatorOptions</code>允许有选择地指定特定于Hibernate的鉴别器选项，这些选项在JPA中未标准化。可用的选项是<code>force</code>和<code>insert</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>force</code>如果表中包含未映射到持久化类的带有<em>额外</em>鉴别符值的行，则此属性很有用。例如，在使用旧数据库时可能会发生这种情况。如果<code>force</code>被设定为<code>true</code> ，即使检索根类的所有实例，Hibernate也会在SELECT查询中指定允许的鉴别符值。</p>
</div>
<div class="paragraph">
<p>第二种选择<code>insert</code> ，告诉Hibernate在SQL INSERT中是否包括区分符列。通常，该列应该是INSERT语句的一部分，但是如果您的区分符列也是映射的复合标识符的一部分，则必须将此选项设置为<code>false</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>曾经有一个<code>@org.hibernate.annotations.ForceDiscriminator</code>在3.6版中已弃用并在以后删除的注释。使用<code>@DiscriminatorOptions</code>代替。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="entity-inheritance-discriminator-formula"><a class="anchor" href="#entity-inheritance-discriminator-formula"></a>判别式</h6>
<div class="paragraph">
<p>假设其中鉴别器基于检查特定列的传统数据库架构，我们可以利用特定于Hibernate的优势<code>@DiscriminatorFormula</code>注释并映射继承模型，如下所示：</p>
</div>
<div id="entity-inheritance-single-table-discriminator-formula-example" class="exampleblock">
<div class="title">示例246单表鉴别符公式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorFormula(
	"case when debitKey is not null " +
	"then 'Debit' " +
	"else ( " +
	"   case when creditKey is not null " +
	"   then 'Credit' " +
	"   else 'Unknown' " +
	"   end ) " +
	"end "
)
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
@DiscriminatorValue(value = "Debit")
public static class DebitAccount extends Account {

	private String debitKey;

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
@DiscriminatorValue(value = "Credit")
public static class CreditAccount extends Account {

	private String creditKey;

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Account (
    id int8 NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    debitKey VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    creditKey VARCHAR(255) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@DiscriminatorFormula</code>定义一个可用于标识特定子类类型的自定义SQL子句。的<code>@DiscriminatorValue</code>定义之间的映射关系<code>@DiscriminatorFormula</code>和继承子类类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="entity-inheritance-discriminator-implicit"><a class="anchor" href="#entity-inheritance-discriminator-implicit"></a>隐式鉴别值</h6>
<div class="paragraph">
<p>除了分配给每个子类类型的常规区分符值外， <code>@DiscriminatorValue</code>可以采用两个附加值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>null</code></dt>
<dd>
<p>如果基础鉴别符列为空，则<code>null</code>鉴别符映射将被使用。</p>
</dd>
<dt class="hdlist1"><code>not null</code></dt>
<dd>
<p>如果基础鉴别符列具有未显式映射到任何实体的非空值，则<code>not-null</code>使用鉴别符映射。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>要了解这两个值的工作原理，请考虑以下实体映射：</p>
</div>
<div id="entity-inheritance-single-table-discriminator-value-example" class="exampleblock">
<div class="title">例子247。@DiscriminatorValue <code>null</code>和<code>not-null</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorValue( "null" )
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
@DiscriminatorValue( "Debit" )
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
@DiscriminatorValue( "Credit" )
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}

@Entity(name = "OtherAccount")
@DiscriminatorValue( "not null" )
public static class OtherAccount extends Account {

	private boolean active;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>Account</code>班上有一个<code>@DiscriminatorValue( "null" )</code>映射，意味着任何<code>account</code>不包含任何鉴别符值的行将被映射到<code>Account</code>基类实体。的<code>DebitAccount</code>和<code>CreditAccount</code>实体使用显式标识符值。的<code>OtherAccount</code>实体用作通用帐户类型，因为它会映射其标识符列未显式分配给当前继承树中任何其他实体的任何数据库行。</p>
</div>
<div class="paragraph">
<p>要可视化其工作方式，请考虑以下示例：</p>
</div>
<div id="entity-inheritance-single-table-discriminator-value-persist-example" class="exampleblock">
<div class="title">示例248。@DiscriminatorValue <code>null</code>和<code>not-null</code>实体持久性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DebitAccount debitAccount = new DebitAccount();
debitAccount.setId( 1L );
debitAccount.setOwner( "John Doe" );
debitAccount.setBalance( BigDecimal.valueOf( 100 ) );
debitAccount.setInterestRate( BigDecimal.valueOf( 1.5d ) );
debitAccount.setOverdraftFee( BigDecimal.valueOf( 25 ) );

CreditAccount creditAccount = new CreditAccount();
creditAccount.setId( 2L );
creditAccount.setOwner( "John Doe" );
creditAccount.setBalance( BigDecimal.valueOf( 1000 ) );
creditAccount.setInterestRate( BigDecimal.valueOf( 1.9d ) );
creditAccount.setCreditLimit( BigDecimal.valueOf( 5000 ) );

Account account = new Account();
account.setId( 3L );
account.setOwner( "John Doe" );
account.setBalance( BigDecimal.valueOf( 1000 ) );
account.setInterestRate( BigDecimal.valueOf( 1.9d ) );

entityManager.persist( debitAccount );
entityManager.persist( creditAccount );
entityManager.persist( account );

entityManager.unwrap( Session.class ).doWork( connection -&gt; {
	try(Statement statement = connection.createStatement()) {
		statement.executeUpdate(
			"insert into Account (DTYPE, active, balance, interestRate, owner, id) " +
			"values ('Other', true, 25, 0.5, 'Vlad', 4)"
		);
	}
} );

Map&lt;Long, Account&gt; accounts = entityManager.createQuery(
	"select a from Account a", Account.class )
.getResultList()
.stream()
.collect( Collectors.toMap( Account::getId, Function.identity()));

assertEquals(4, accounts.size());
assertEquals( DebitAccount.class, accounts.get( 1L ).getClass() );
assertEquals( CreditAccount.class, accounts.get( 2L ).getClass() );
assertEquals( Account.class, accounts.get( 3L ).getClass() );
assertEquals( OtherAccount.class, accounts.get( 4L ).getClass() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">INSERT INTO Account (balance, interestRate, owner, overdraftFee, DTYPE, id)
VALUES (100, 1.5, 'John Doe', 25, 'Debit', 1)

INSERT INTO Account (balance, interestRate, owner, overdraftFee, DTYPE, id)
VALUES (1000, 1.9, 'John Doe', 5000, 'Credit', 2)

INSERT INTO Account (balance, interestRate, owner, id)
VALUES (1000, 1.9, 'John Doe', 3)

INSERT INTO Account (DTYPE, active, balance, interestRate, owner, id)
VALUES ('Other', true, 25, 0.5, 'Vlad', 4)

SELECT a.id as id2_0_,
       a.balance as balance3_0_,
       a.interestRate as interest4_0_,
       a.owner as owner5_0_,
       a.overdraftFee as overdraf6_0_,
       a.creditLimit as creditLi7_0_,
       a.active as active8_0_,
       a.DTYPE as DTYPE1_0_
FROM   Account a</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>Account</code>实体行的值为<code>NULL</code>在里面<code>DTYPE</code>鉴别列，而<code>OtherAccount</code>实体已保存为<code>DTYPE</code>的栏值<code>other</code>没有明确的映射。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entity-inheritance-joined-table"><a class="anchor" href="#entity-inheritance-joined-table"></a> 2.11.3。联接表</h4>
<div class="paragraph">
<p>每个子类也可以映射到其自己的表。这也称为<em>每个子表</em>映射策略。通过与超类的表联接来检索继承的状态。</p>
</div>
<div class="paragraph">
<p>此映射策略不需要区分符列。但是，每个子类都必须声明一个包含对象标识符的表列。</p>
</div>
<div id="entity-inheritance-joined-table-example" class="exampleblock">
<div class="title">示例249。联接表</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.JOINED)
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Account (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE CreditAccount (
    creditLimit NUMERIC(19, 2) ,
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

CREATE TABLE DebitAccount (
    overdraftFee NUMERIC(19, 2) ,
    id BIGINT NOT NULL ,
    PRIMARY KEY ( id )
)

ALTER TABLE CreditAccount
ADD CONSTRAINT FKihw8h3j1k0w31cnyu7jcl7n7n
FOREIGN KEY (id) REFERENCES Account

ALTER TABLE DebitAccount
ADD CONSTRAINT FKia914478noepymc468kiaivqm
FOREIGN KEY (id) REFERENCES Account</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的主键<code>CreditAccount</code>和<code>DebitAccount</code>表也是超类表主键的外键，由<code>@PrimaryKeyJoinColumns</code> 。</p>
</div>
<div class="paragraph">
<p>表名仍默认为非限定的类名。另外，如果<code>@PrimaryKeyJoinColumn</code>如果未设置，则假定主键/外键列与超类的主表的主键列具有相同的名称。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="entity-inheritance-joined-table-primary-key-join-column-example" class="exampleblock">
<div class="title">示例250。与连接表<code>@PrimaryKeyJoinColumn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.JOINED)
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
@PrimaryKeyJoinColumn(name = "account_id")
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
@PrimaryKeyJoinColumn(name = "account_id")
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE CreditAccount (
    creditLimit NUMERIC(19, 2) ,
    account_id BIGINT NOT NULL ,
    PRIMARY KEY ( account_id )
)

CREATE TABLE DebitAccount (
    overdraftFee NUMERIC(19, 2) ,
    account_id BIGINT NOT NULL ,
    PRIMARY KEY ( account_id )
)

ALTER TABLE CreditAccount
ADD CONSTRAINT FK8ulmk1wgs5x7igo370jt0q005
FOREIGN KEY (account_id) REFERENCES Account

ALTER TABLE DebitAccount
ADD CONSTRAINT FK7wjufa570onoidv4omkkru06j
FOREIGN KEY (account_id) REFERENCES Account</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用多态查询时，必须将基类表与所有子类表连接在一起，以获取每个关联的子类实例。</p>
</div>
<div id="entity-inheritance-joined-table-query-example" class="exampleblock">
<div class="title">示例251。连接表多态查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Account&gt; accounts = entityManager
	.createQuery( "select a from Account a" )
	.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">SELECT jointablet0_.id AS id1_0_ ,
       jointablet0_.balance AS balance2_0_ ,
       jointablet0_.interestRate AS interest3_0_ ,
       jointablet0_.owner AS owner4_0_ ,
       jointablet0_1_.overdraftFee AS overdraf1_2_ ,
       jointablet0_2_.creditLimit AS creditLi1_1_ ,
       CASE WHEN jointablet0_1_.id IS NOT NULL THEN 1
            WHEN jointablet0_2_.id IS NOT NULL THEN 2
            WHEN jointablet0_.id IS NOT NULL THEN 0
       END AS clazz_
FROM   Account jointablet0_
       LEFT OUTER JOIN DebitAccount jointablet0_1_ ON jointablet0_.id = jointablet0_1_.id
       LEFT OUTER JOIN CreditAccount jointablet0_2_ ON jointablet0_.id = jointablet0_2_.id</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>联接的表继承多态查询可以使用多个JOINS，这可能会在获取大量实体时影响性能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="entity-inheritance-table-per-class"><a class="anchor" href="#entity-inheritance-table-per-class"></a> 2.11.4。每班桌</h4>
<div class="paragraph">
<p>第三种选择是仅将继承层次结构的具体类映射到表。这称为每具体表类策略。每个表定义了类的所有持久状态，包括继承状态。</p>
</div>
<div class="paragraph">
<p>在Hibernate中，没有必要显式映射此类继承层次结构。您可以将每个类映射为单独的实体根。但是，如果您希望使用多态关联（例如，与层次结构超类的关联），则需要使用并集子类映射。</p>
</div>
<div id="entity-inheritance-table-per-class-example" class="exampleblock">
<div class="title">示例252。每班桌</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public static class Account {

	@Id
	private Long id;

	private String owner;

	private BigDecimal balance;

	private BigDecimal interestRate;

	//Getters and setters are omitted for brevity

}

@Entity(name = "DebitAccount")
public static class DebitAccount extends Account {

	private BigDecimal overdraftFee;

	//Getters and setters are omitted for brevity

}

@Entity(name = "CreditAccount")
public static class CreditAccount extends Account {

	private BigDecimal creditLimit;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">CREATE TABLE Account (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    PRIMARY KEY ( id )
)

CREATE TABLE CreditAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)

CREATE TABLE DebitAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用多态查询时，还需要UNION来获取基类表以及所有子类表。</p>
</div>
<div class="exampleblock">
<div class="title">范例253。每类表多态查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Account&gt; accounts = entityManager
	.createQuery( "select a from Account a" )
	.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">SELECT tablepercl0_.id AS id1_0_ ,
       tablepercl0_.balance AS balance2_0_ ,
       tablepercl0_.interestRate AS interest3_0_ ,
       tablepercl0_.owner AS owner4_0_ ,
       tablepercl0_.overdraftFee AS overdraf1_2_ ,
       tablepercl0_.creditLimit AS creditLi1_1_ ,
       tablepercl0_.clazz_ AS clazz_
FROM (
    SELECT    id ,
             balance ,
             interestRate ,
             owner ,
             CAST(NULL AS INT) AS overdraftFee ,
             CAST(NULL AS INT) AS creditLimit ,
             0 AS clazz_
    FROM     Account
    UNION ALL
    SELECT   id ,
             balance ,
             interestRate ,
             owner ,
             overdraftFee ,
             CAST(NULL AS INT) AS creditLimit ,
             1 AS clazz_
    FROM     DebitAccount
    UNION ALL
    SELECT   id ,
             balance ,
             interestRate ,
             owner ,
             CAST(NULL AS INT) AS overdraftFee ,
             creditLimit ,
             2 AS clazz_
    FROM     CreditAccount
) tablepercl0_</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>多态查询需要多个UNION查询，因此请注意大型类层次结构对性能的影响。</p>
</div>
<div class="paragraph">
<p>不幸的是，并非所有数据库系统都支持UNION ALL，在这种情况下，将使用UNION代替UNION ALL。</p>
</div>
<div class="paragraph">
<p>以下Hibernate方言支持UNION ALL：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractHANADialect</code></p>
</li>
<li>
<p><code>AbstractTransactSQLDialect</code></p>
</li>
<li>
<p><code>CUBRIDDialect</code></p>
</li>
<li>
<p><code>DB2Dialect</code></p>
</li>
<li>
<p><code>H2Dialect</code></p>
</li>
<li>
<p><code>HSQLDialect</code></p>
</li>
<li>
<p><code>Ingres9Dialect</code></p>
</li>
<li>
<p><code>MySQL5Dialect</code></p>
</li>
<li>
<p><code>Oracle8iDialect</code></p>
</li>
<li>
<p><code>Oracle9Dialect</code></p>
</li>
<li>
<p><code>PostgreSQL81Dialect</code></p>
</li>
<li>
<p><code>RDMSOS2200Dialect</code></p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="entity-inheritance-polymorphism"><a class="anchor" href="#entity-inheritance-polymorphism"></a> 2.11.5。隐式和显式多态</h4>
<div class="paragraph">
<p>默认情况下，当查询基类实体时，多态查询将获取属于该基类型的所有子类。</p>
</div>
<div class="paragraph">
<p>但是，您甚至可以查询<strong>不属于JPA实体继承模型的接口或基类</strong> 。</p>
</div>
<div class="paragraph">
<p>例如，考虑以下<code>DomainModelEntity</code>接口：</p>
</div>
<div id="entity-inheritance-polymorphism-interface-example" class="exampleblock">
<div class="title">示例254域模型实体接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface DomainModelEntity&lt;ID&gt; {

    ID getId();

    Integer getVersion();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们有两个实体映射， <code>Book</code>和一个<code>Blog</code>和<code>Blog</code>实体与<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Polymorphism.html"><code>@Polymorphism</code></a>注释并采取<code>PolymorphismType.EXPLICIT</code>设置：</p>
</div>
<div id="entity-inheritance-polymorphism-mapping-example" class="exampleblock">
<div class="title">示例255。 <code>@Polymorphism</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Event")
public static class Book implements DomainModelEntity&lt;Long&gt; {

	@Id
	private Long id;

	@Version
	private Integer version;

	private String title;

	private String author;

	//Getter and setters omitted for brevity
}

@Entity(name = "Blog")
@Polymorphism(type = PolymorphismType.EXPLICIT)
public static class Blog implements DomainModelEntity&lt;Long&gt; {

	@Id
	private Long id;

	@Version
	private Integer version;

	private String site;

	//Getter and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们的系统中有以下实体对象：</p>
</div>
<div id="entity-inheritance-polymorphism-persist-example" class="exampleblock">
<div class="title">示例256域模型实体对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Book book = new Book();
book.setId( 1L );
book.setAuthor( "Vlad Mihalcea" );
book.setTitle( "High-Performance Java Persistence" );
entityManager.persist( book );

Blog blog = new Blog();
blog.setId( 1L );
blog.setSite( "vladmihalcea.com" );
entityManager.persist( blog );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以查询<code>DomainModelEntity</code>接口，并且Hibernate将仅获取与之映射的实体<code>@Polymorphism(type = PolymorphismType.IMPLICIT)</code>或根本不使用<code>@Polymorphism</code>注释（暗示IMPLICIT行为）：</p>
</div>
<div id="entity-inheritance-polymorphism-fetch-example" class="exampleblock">
<div class="title">示例257。使用非映射基类多态性获取域模型实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;DomainModelEntity&gt; accounts = entityManager
.createQuery(
	"select e " +
	"from org.hibernate.userguide.inheritance.polymorphism.DomainModelEntity e" )
.getResultList();

assertEquals(1, accounts.size());
assertTrue( accounts.get( 0 ) instanceof Book );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此，只有<code>Book</code>自从<code>Blog</code>实体标有<code>@Polymorphism(type = PolymorphismType.EXPLICIT)</code>注解，指示Hibernate在对未映射的基类执行多态查询时跳过它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entity-immutability"><a class="anchor" href="#entity-immutability"></a> 2.12。不变性</h3>
<div class="paragraph">
<p>可以为实体和集合指定不变性。</p>
</div>
<div class="sect3">
<h4 id="_entity_immutability"><a class="anchor" href="#_entity_immutability"></a> 2.12.1。实体不变性</h4>
<div class="paragraph">
<p>如果特定实体是不可变的，则优良作法是将其标记为<code>@Immutable</code>注解。</p>
</div>
<div class="exampleblock">
<div class="title">范例258。不变的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Event")
@Immutable
public static class Event {

	@Id
	private Long id;

	private Date createdOn;

	private String message;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在内部，Hibernate将执行一些优化，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>减少内存占用空间，因为脏检查机制无需保持脱水状态</p>
</li>
<li>
<p>由于不可变实体可以跳过脏检查过程，因此可以加快持久性上下文刷新阶段的速度</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下实体保留在数据库中：</p>
</div>
<div class="exampleblock">
<div class="title">示例259持久不变的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Event event = new Event();
	event.setId( 1L );
	event.setCreatedOn( new Date( ) );
	event.setMessage( "Hibernate User Guide rocks!" );

	entityManager.persist( event );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>加载实体并尝试更改其状态时，Hibernate将跳过任何修改，因此没有SQL <code>UPDATE</code>语句被执行。</p>
</div>
<div class="exampleblock">
<div class="title">示例260不可变实体忽略任何更新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Event event = entityManager.find( Event.class, 1L );
	log.info( "Change event message" );
	event.setMessage( "Hibernate User Guide" );
} );
doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Event event = entityManager.find( Event.class, 1L );
	assertEquals("Hibernate User Guide rocks!", event.getMessage());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT e.id AS id1_0_0_,
       e.createdOn AS createdO2_0_0_,
       e.message AS message3_0_0_
FROM   event e
WHERE  e.id = 1

-- Change event message

SELECT e.id AS id1_0_0_,
       e.createdOn AS createdO2_0_0_,
       e.message AS message3_0_0_
FROM   event e
WHERE  e.id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_collection_immutability"><a class="anchor" href="#_collection_immutability"></a> 2.12.2。集合不变性</h4>
<div class="paragraph">
<p>就像实体一样，集合也可以用<code>@Immutable</code>注解。</p>
</div>
<div class="paragraph">
<p>考虑以下实体映射：</p>
</div>
<div class="exampleblock">
<div class="title">示例261不变的收藏</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Batch")
public static class Batch {

	@Id
	private Long id;

	private String name;

	@OneToMany(cascade = CascadeType.ALL)
	@Immutable
	private List&lt;Event&gt; events = new ArrayList&lt;&gt;( );

	//Getters and setters are omitted for brevity

}

@Entity(name = "Event")
@Immutable
public static class Event {

	@Id
	private Long id;

	private Date createdOn;

	private String message;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，不仅<code>Event</code>实体是不可变的，但是<code>Event</code>集合存储于<code>Batch</code>父实体。一旦创建了不可变集合，就永远不能对其进行修改。</p>
</div>
<div class="exampleblock">
<div class="title">示例262坚持不变的收藏</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Batch batch = new Batch();
	batch.setId( 1L );
	batch.setName( "Change request" );

	Event event1 = new Event();
	event1.setId( 1L );
	event1.setCreatedOn( new Date( ) );
	event1.setMessage( "Update Hibernate User Guide" );

	Event event2 = new Event();
	event2.setId( 2L );
	event2.setCreatedOn( new Date( ) );
	event2.setMessage( "Update Hibernate Getting Started Guide" );

	batch.getEvents().add( event1 );
	batch.getEvents().add( event2 );

	entityManager.persist( batch );
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>Batch</code>实体是可变的。只有<code>events</code>收集是一成不变的。</p>
</div>
<div class="paragraph">
<p>例如，我们仍然可以修改实体名称：</p>
</div>
<div class="exampleblock">
<div class="title">示例263更改可变实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Batch batch = entityManager.find( Batch.class, 1L );
	log.info( "Change batch name" );
	batch.setName( "Proposed change request" );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT b.id AS id1_0_0_,
       b.name AS name2_0_0_
FROM   Batch b
WHERE  b.id = 1

-- Change batch name

UPDATE batch
SET    name = 'Proposed change request'
WHERE  id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，当尝试修改<code>events</code>采集：</p>
</div>
<div class="exampleblock">
<div class="title">示例264不可变的集合无法修改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try {
	doInJPA( this::entityManagerFactory, entityManager -&gt; {
		Batch batch = entityManager.find( Batch.class, 1L );
		batch.getEvents().clear();
	} );
}
catch ( Exception e ) {
	log.error( "Immutable collections cannot be modified" );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">javax.persistence.RollbackException: Error while committing the transaction

Caused by: javax.persistence.PersistenceException: org.hibernate.HibernateException:

Caused by: org.hibernate.HibernateException: changed an immutable collection instance: [
    org.hibernate.userguide.immutability.CollectionImmutabilityTest$Batch.events#1
]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然不可变实体的更改被简单地丢弃，但修改不可变集合将最终导致<code>HibernateException</code>被抛出。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bootstrap"><a class="anchor" href="#bootstrap"></a> 3。引导程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>org.hibernate.boot.spi.metadatabuilder贡献者；</p>
</div>
<div class="paragraph">
<p>引导程序是指初始化和启动软件组件。在Hibernate中，我们专门讨论构建完整功能的过程<code>SessionFactory</code>实例或<code>EntityManagerFactory</code>例如，对于JPA。每个过程都非常不同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在引导过程中，您可能需要自定义Hibernate行为，因此请确保同时选中“ <a href="#configurations">配置”</a>部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="bootstrap-native"><a class="anchor" href="#bootstrap-native"></a> 3.1。本机引导</h3>
<div class="paragraph">
<p>本节讨论引导Hibernate的过程<code>SessionFactory</code> 。具体来说，它解决了5.0中重新设计的自举API。有关旧版自举API的讨论，请参见<a href="#appendix-legacy-bootstrap">旧版自举</a></p>
</div>
<div class="sect3">
<h4 id="bootstrap-native-registry"><a class="anchor" href="#bootstrap-native-registry"></a> 3.1.1。建立服务注册表</h4>
<div class="paragraph">
<p>本机引导的第一步是构建一个<code>ServiceRegistry</code>在引导过程中和运行时保持Hibernate所需的服务。</p>
</div>
<div class="paragraph">
<p>实际上，我们关心建立两个不同的ServiceRegistries。首先是<code>org.hibernate.boot.registry.BootstrapServiceRegistry</code> 。的<code>BootstrapServiceRegistry</code>用于保留Hibernate在引导和运行时所需的服务。这归结为3种服务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.boot.registry.classloading.spi.ClassLoaderService</code></dt>
<dd>
<p>它控制Hibernate如何与`ClassLoader`s交互</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.integrator.spi.IntegratorService</code></dt>
<dd>
<p>控制着管理和发现<code>org.hibernate.integrator.spi.Integrator</code>实例。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.boot.registry.selector.spi.StrategySelector</code></dt>
<dd>
<p>它控制了Hibernate如何解决各种战略合同的实现。这是一项非常强大的服务，但是对其的完整讨论不在本指南的范围之内。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您对这些方面的Hibernate默认行为感到满意， <code>BootstrapServiceRegistry</code>服务（通常是这种情况，尤其是在独立环境中），则无需显式构建<code>BootstrapServiceRegistry</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您想更改<code>BootstrapServiceRegistry</code>是内置的，即通过<code>org.hibernate.boot.registry.BootstrapServiceRegistryBuilder:</code></p>
</div>
<div id="bootstrap-bootstrap-native-registry-BootstrapServiceRegistry-example" class="exampleblock">
<div class="title">示例265控制性<code>BootstrapServiceRegistry</code>建造</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">BootstrapServiceRegistryBuilder bootstrapRegistryBuilder =
    new BootstrapServiceRegistryBuilder();
// add a custom ClassLoader
bootstrapRegistryBuilder.applyClassLoader( customClassLoader );
// manually add an Integrator
bootstrapRegistryBuilder.applyIntegrator( customIntegrator );

BootstrapServiceRegistry bootstrapRegistry = bootstrapRegistryBuilder.build();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的服务<code>BootstrapServiceRegistry</code>不能扩展（添加到）或覆盖（替换）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第二个ServiceRegistry是<code>org.hibernate.boot.registry.StandardServiceRegistry</code> 。您几乎总是需要配置<code>StandardServiceRegistry</code> ，这是通过<code>org.hibernate.boot.registry.StandardServiceRegistryBuilder</code> ：</p>
</div>
<div id="bootstrap-bootstrap-native-registry-StandardServiceRegistryBuilder-example" class="exampleblock">
<div class="title">实施例266。建立一个<code>BootstrapServiceRegistryBuilder</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// An example using an implicitly built BootstrapServiceRegistry
StandardServiceRegistryBuilder standardRegistryBuilder =
    new StandardServiceRegistryBuilder();

// An example using an explicitly built BootstrapServiceRegistry
BootstrapServiceRegistry bootstrapRegistry =
    new BootstrapServiceRegistryBuilder().build();

StandardServiceRegistryBuilder standardRegistryBuilder =
    new StandardServiceRegistryBuilder( bootstrapRegistry );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>StandardServiceRegistry</code>还可以通过StandardServiceRegistryBuilder API进行高度配置。见<code>StandardServiceRegistryBuilder</code> <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/registry/StandardServiceRegistryBuilder.html">Javadocs</a>以获得更多详细信息。</p>
</div>
<div class="paragraph">
<p>一些感兴趣的特定方法：</p>
</div>
<div id="bootstrap-bootstrap-native-registry-MetadataSources-example" class="exampleblock">
<div class="title">示例267。配置一个<code>MetadataSources</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ServiceRegistry standardRegistry =
        new StandardServiceRegistryBuilder().build();

MetadataSources sources = new MetadataSources( standardRegistry );

// alternatively, we can build the MetadataSources without passing
// a service registry, in which case it will build a default
// BootstrapServiceRegistry to use.  But the approach shown
// above is preferred
// MetadataSources sources = new MetadataSources();

// add a class using JPA/Hibernate annotations for mapping
sources.addAnnotatedClass( MyEntity.class );

// add the name of a class using JPA/Hibernate annotations for mapping.
// differs from above in that accessing the Class is deferred which is
// important if using runtime bytecode-enhancement
sources.addAnnotatedClassName( "org.hibernate.example.Customer" );

// Read package-level metadata.
sources.addPackage( "hibernate.example" );

// Read package-level metadata.
sources.addPackage( MyEntity.class.getPackage() );

// Adds the named hbm.xml resource as a source: which performs the
// classpath lookup and parses the XML
sources.addResource( "org/hibernate/example/Order.hbm.xml" );

// Adds the named JPA orm.xml resource as a source: which performs the
// classpath lookup and parses the XML
sources.addResource( "org/hibernate/example/Product.orm.xml" );

// Read all mapping documents from a directory tree.
// Assumes that any file named *.hbm.xml is a mapping document.
sources.addDirectory( new File( ".") );

// Read mappings from a particular XML file
sources.addFile( new File( "./mapping.xml") );

// Read all mappings from a jar file.
// Assumes that any file named *.hbm.xml is a mapping document.
sources.addJar( new File( "./entities.jar") );

// Read a mapping as an application resource using the convention that a class named foo.bar.MyEntity is
// mapped by a file named foo/bar/MyEntity.hbm.xml which can be resolved as a classpath resource.
sources.addClass( MyEntity.class );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bootstrap-event-listener-registration"><a class="anchor" href="#bootstrap-event-listener-registration"></a> 3.1.2。事件监听器注册</h4>
<div class="paragraph">
<p>的主要用例<code>org.hibernate.integrator.spi.Integrator</code>目前正在注册事件监听器并提供服务（请参见<code>org.hibernate.integrator.spi.ServiceContributingIntegrator</code> ）。在5.0版本中，我们计划对其进行扩展，以允许更改描述对象模型和关系模型之间映射的元模型。</p>
</div>
<div id="bootstrap-event-listener-registration-example" class="exampleblock">
<div class="title">示例268。配置事件监听器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class MyIntegrator implements org.hibernate.integrator.spi.Integrator {

    @Override
    public void integrate(
            Metadata metadata,
            SessionFactoryImplementor sessionFactory,
            SessionFactoryServiceRegistry serviceRegistry) {

        // As you might expect, an EventListenerRegistry is the thing with which event
        // listeners are registered
        // It is a service so we look it up using the service registry
        final EventListenerRegistry eventListenerRegistry =
            serviceRegistry.getService( EventListenerRegistry.class );

        // If you wish to have custom determination and handling of "duplicate" listeners,
        // you would have to add an implementation of the
        // org.hibernate.event.service.spi.DuplicationStrategy contract like this
        eventListenerRegistry.addDuplicationStrategy( new CustomDuplicationStrategy() );

        // EventListenerRegistry defines 3 ways to register listeners:

        // 1) This form overrides any existing registrations with
        eventListenerRegistry.setListeners( EventType.AUTO_FLUSH,
                                            DefaultAutoFlushEventListener.class );

        // 2) This form adds the specified listener(s) to the beginning of the listener chain
        eventListenerRegistry.prependListeners( EventType.PERSIST,
                                                DefaultPersistEventListener.class );

        // 3) This form adds the specified listener(s) to the end of the listener chain
        eventListenerRegistry.appendListeners( EventType.MERGE,
                                               DefaultMergeEventListener.class );
    }

    @Override
    public void disintegrate(
            SessionFactoryImplementor sessionFactory,
            SessionFactoryServiceRegistry serviceRegistry) {

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bootstrap-native-metadata"><a class="anchor" href="#bootstrap-native-metadata"></a> 3.1.3。建立元数据</h4>
<div class="paragraph">
<p>本机引导的第二步是构建一个<code>org.hibernate.boot.Metadata</code>包含已解析的应用程序域模型表示形式及其到数据库的映射的对象。我们显然需要构建解析表示形式的第一件事是要解析的源信息（带注释的类， <code>hbm.xml</code>文件， <code>orm.xml</code>文件）。这是目的<code>org.hibernate.boot.MetadataSources</code> ：</p>
</div>
<div class="paragraph">
<p><code>MetadataSources</code>还有许多其他方法，请浏览其API和<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/MetadataSources.html">Javadocs</a>以获取更多信息。另外，所有方法<code>MetadataSources</code>提供流利的电话链接：</p>
</div>
<div id="bootstrap-native-metadata-source-example" class="exampleblock">
<div class="title">示例269配置一个<code>MetadataSources</code>与方法链接</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ServiceRegistry standardRegistry =
        new StandardServiceRegistryBuilder().build();

MetadataSources sources = new MetadataSources( standardRegistry )
    .addAnnotatedClass( MyEntity.class )
    .addAnnotatedClassName( "org.hibernate.example.Customer" )
    .addResource( "org/hibernate/example/Order.hbm.xml" )
    .addResource( "org/hibernate/example/Product.orm.xml" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>定义了映射信息的来源后，我们需要构建<code>Metadata</code>宾语。如果您对建立元数据的默认行为没意见，那么您只需调用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/MetadataSources.html#buildMetadata--"><code>buildMetadata</code></a>的方法<code>MetadataSources</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意， <code>ServiceRegistry</code>可以在此引导过程中的许多点传递。建议的方法是建立一个<code>StandardServiceRegistry</code>自己，并传递给<code>MetadataSources</code>构造函数。从那里， <code>MetadataBuilder</code> ， <code>Metadata</code> ， <code>SessionFactoryBuilder</code>和<code>SessionFactory</code>都一样<code>StandardServiceRegistry</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，如果您希望调整建造过程<code>Metadata</code>从<code>MetadataSources</code> ，则需要使用<code>MetadataBuilder</code>通过获取<code>MetadataSources#getMetadataBuilder</code> 。
<code>MetadataBuilder</code>允许对<code>Metadata</code>建设过程。有关完整的详细信息，请参见其<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/MetadataBuilder.html">Javadocs</a> 。</p>
</div>
<div id="bootstrap-native-metadata-builder-example" class="exampleblock">
<div class="title">示例270通过构建元数据<code>MetadataBuilder</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ServiceRegistry standardRegistry =
    new StandardServiceRegistryBuilder().build();

MetadataSources sources = new MetadataSources( standardRegistry );

MetadataBuilder metadataBuilder = sources.getMetadataBuilder();

// Use the JPA-compliant implicit naming strategy
metadataBuilder.applyImplicitNamingStrategy(
    ImplicitNamingStrategyJpaCompliantImpl.INSTANCE );

// specify the schema name to use for tables, etc when none is explicitly specified
metadataBuilder.applyImplicitSchemaName( "my_default_schema" );

// specify a custom Attribute Converter
metadataBuilder.applyAttributeConverter( myAttributeConverter );

Metadata metadata = metadataBuilder.build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bootstrap-native-SessionFactory"><a class="anchor" href="#bootstrap-native-SessionFactory"></a> 3.1.4。建立SessionFactory</h4>
<div class="paragraph">
<p>本机引导的最后一步是构建<code>SessionFactory</code>本身。就像上面讨论的一样，如果您可以接受建立<code>SessionFactory</code>从一个<code>Metadata</code>参考，您只需调用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/Metadata.html#buildSessionFactory--"><code>buildSessionFactory</code></a>上的方法<code>Metadata</code>宾语。</p>
</div>
<div class="paragraph">
<p>但是，如果您要调整该构建过程，则需要使用<code>SessionFactoryBuilder</code>通过[ <code>Metadata#getSessionFactoryBuilder</code> 。再次，请参阅其<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/Metadata.html#getSessionFactoryBuilder--">Javadocs</a>了解更多详细信息。</p>
</div>
<div id="bootstrap-native-SessionFactory-example" class="exampleblock">
<div class="title">示例271本机引导-将所有内容放在一起</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()
    .configure( "org/hibernate/example/hibernate.cfg.xml" )
    .build();

Metadata metadata = new MetadataSources( standardRegistry )
    .addAnnotatedClass( MyEntity.class )
    .addAnnotatedClassName( "org.hibernate.example.Customer" )
    .addResource( "org/hibernate/example/Order.hbm.xml" )
    .addResource( "org/hibernate/example/Product.orm.xml" )
    .getMetadataBuilder()
    .applyImplicitNamingStrategy( ImplicitNamingStrategyJpaCompliantImpl.INSTANCE )
    .build();

SessionFactory sessionFactory = metadata.getSessionFactoryBuilder()
    .applyBeanManager( getBeanManager() )
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>自举API非常灵活，但是在大多数情况下，将其视为3个步骤的流程是最有意义的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>建立<code>StandardServiceRegistry</code></p>
</li>
<li>
<p>建立<code>Metadata</code></p>
</li>
<li>
<p>使用那两个来建立<code>SessionFactory</code></p>
</li>
</ol>
</div>
<div id="bootstrap-native-SessionFactoryBuilder-example" class="exampleblock">
<div class="title">示例272建造<code>SessionFactory</code>通过<code>SessionFactoryBuilder</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()
        .configure( "org/hibernate/example/hibernate.cfg.xml" )
        .build();

Metadata metadata = new MetadataSources( standardRegistry )
    .addAnnotatedClass( MyEntity.class )
    .addAnnotatedClassName( "org.hibernate.example.Customer" )
    .addResource( "org/hibernate/example/Order.hbm.xml" )
    .addResource( "org/hibernate/example/Product.orm.xml" )
    .getMetadataBuilder()
    .applyImplicitNamingStrategy( ImplicitNamingStrategyJpaCompliantImpl.INSTANCE )
    .build();

SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();

// Supply a SessionFactory-level Interceptor
sessionFactoryBuilder.applyInterceptor( new CustomSessionFactoryInterceptor() );

// Add a custom observer
sessionFactoryBuilder.addSessionFactoryObservers( new CustomSessionFactoryObserver() );

// Apply a CDI BeanManager ( for JPA event listeners )
sessionFactoryBuilder.applyBeanManager( getBeanManager() );

SessionFactory sessionFactory = sessionFactoryBuilder.build();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bootstrap-jpa"><a class="anchor" href="#bootstrap-jpa"></a> 3.2。JPA引导</h3>
<div class="paragraph">
<p>将Hibernate作为JPA提供程序进行引导可以通过符合JPA规范的方式或使用专有的引导方法来完成。标准化方法在某些环境中有一些限制，但是除了这些限制外， <strong>强烈</strong>建议您使用JPA标准化的引导程序。</p>
</div>
<div class="sect3">
<h4 id="bootstrap-jpa-compliant"><a class="anchor" href="#bootstrap-jpa-compliant"></a> 3.2.1。符合JPA的自举</h4>
<div class="paragraph">
<p>在JPA中，我们最终有兴趣自举一个<code>javax.persistence.EntityManagerFactory</code>实例。JPA规范定义了两种主要的标准化引导程序方法，具体取决于应用程序打算如何访问该程序。 <code>javax.persistence.EntityManager</code>来自的实例<code>EntityManagerFactory</code> 。</p>
</div>
<div class="paragraph">
<p>对于这两种方法，它使用术语<em>EE</em>和<em>SE</em> ，但是这些术语在这种情况下极具误导性。JPA规范所谓的EE引导意味着存在容器（EE，OSGi等），该容器将代表应用程序管理和注入持久性上下文。它所谓的SE自举是其他所有内容。在本指南中，我们将使用术语容器引导和应用程序引导。</p>
</div>
<div class="paragraph">
<p>对于合规的容器引导，容器将构建一个<code>EntityManagerFactory</code>对于在<code>META-INF/persistence.xml</code>配置文件，并通过<code>javax.persistence.PersistenceUnit</code>批注或通过JNDI查找。</p>
</div>
<div id="bootstrap-jpa-compliant-PersistenceUnit-example" class="exampleblock">
<div class="title">示例273注入默认<code>EntityManagerFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@PersistenceUnit
private EntityManagerFactory emf;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，如果您有多个持久性单元（例如，多个<code>persistence.xml</code>配置文件），您可以注入特定的<code>EntityManagerFactory</code>按单位名称：</p>
</div>
<div id="bootstrap-jpa-compliant-PersistenceUnit-configurable-example" class="exampleblock">
<div class="title">实施例274。注入特定<code>EntityManagerFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@PersistenceUnit(
    unitName = "CRM"
)
private EntityManagerFactory entityManagerFactory;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>META-INF/persistence.xml</code>文件外观如下：</p>
</div>
<div id="bootstrap-jpa-compliant-persistence-xml-example" class="exampleblock">
<div class="title">示例275META-INF / persistence.xml配置文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">&lt;persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
             http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1"&gt;

    &lt;persistence-unit name="CRM"&gt;
        &lt;description&gt;
            Persistence unit for Hibernate User Guide
        &lt;/description&gt;

        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;

        &lt;class&gt;org.hibernate.documentation.userguide.Document&lt;/class&gt;

        &lt;properties&gt;
            &lt;property name="javax.persistence.jdbc.driver"
                      value="org.h2.Driver" /&gt;

            &lt;property name="javax.persistence.jdbc.url"
                      value="jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE" /&gt;

            &lt;property name="javax.persistence.jdbc.user"
                      value="sa" /&gt;

            &lt;property name="javax.persistence.jdbc.password"
                      value="" /&gt;

            &lt;property name="hibernate.show_sql"
                      value="true" /&gt;

            &lt;property name="hibernate.hbm2ddl.auto"
                      value="update" /&gt;
        &lt;/properties&gt;

    &lt;/persistence-unit&gt;

&lt;/persistence&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于合规的应用程序引导，而不是通过容器构建<code>EntityManagerFactory</code>对于应用程序，应用程序将构建<code>EntityManagerFactory</code>本身使用<code>javax.persistence.Persistence</code>引导程序类。该应用程序创建一个<code>EntityManagerFactory</code>通过调用<code>createEntityManagerFactory</code>方法：</p>
</div>
<div id="bootstrap-jpa-compliant-EntityManagerFactory-example" class="exampleblock">
<div class="title">示例276。应用程序自举<code>EntityManagerFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// Create an EMF for our CRM persistence-unit.
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "CRM" );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您不想提供<code>persistence.xml</code>配置文件，JPA允许您在一个文件中提供所有配置选项<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/spi/PersistenceUnitInfo.html"><code>PersistenceUnitInfo</code></a>实施和电话<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/HibernatePersistenceProvider.html#createContainerEntityManagerFactory-javax.persistence.spi.PersistenceUnitInfo-java.util.Map-"><code>HibernatePersistenceProvider.html#createContainerEntityManagerFactory</code></a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要注入默认的持久性上下文，您可以使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceContext.html"><code>@PersistenceContext</code></a>注解。</p>
</div>
<div id="bootstrap-jpa-compliant-PersistenceContext-example" class="exampleblock">
<div class="title">实施例277。注入默认<code>EntityManager</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@PersistenceContext
private EntityManager em;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要注入特定的持久性上下文，可以使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceContext.html"><code>@PersistenceContext</code></a>注释，甚至可以通过<code>EntityManager</code>特定于属性<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceProperty.html"><code>@PersistenceProperty</code></a>注解。</p>
</div>
<div id="bootstrap-jpa-compliant-PersistenceContext-configurable-example" class="exampleblock">
<div class="title">示例278注入可配置<code>EntityManager</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@PersistenceContext(
    unitName = "CRM",
    properties = {
        @PersistenceProperty(
            name="org.hibernate.flushMode",
            value= "MANUAL"
        )
    }
)
private EntityManager entityManager;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您想要有关访问和使用的更多详细信息<code>EntityManager</code>实例，JPA 2.1规范的第7.6和7.7节涵盖了容器管理的和应用程序管理的<code>EntityManagers</code> ， 分别。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="bootstrap-jpa-xml-files"><a class="anchor" href="#bootstrap-jpa-xml-files"></a> 3.2.2。外部化XML映射文件</h4>
<div class="paragraph">
<p>JPA提供了两个映射选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>注解</p>
</li>
<li>
<p>XML映射</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管注释更为常见，但在某些项目中首选XML映射。您甚至可以混合使用注释和XML映射，以便可以使用可以轻松更改而无需重新编译项目源代码的XML配置覆盖注释映射。这是可能的，因为如果存在两个冲突的映射，则XML映射优先于其注释副本。</p>
</div>
<div class="paragraph">
<p>JPA规范要求XML映射位于类路径上：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>一个对象/关系映射XML文件，名为<code>orm.xml</code>可以在<code>META-INF</code>持久性单元根目录中的目录或<code>META-INF</code>所引用的任何jar文件的目录<code>persistence.xml</code> 。</p>
</div>
<div class="paragraph">
<p>替代地或另外，持久性单元元素的映射文件元素可以引用一个或多个映射文件。这些映射文件可能存在于类路径上的任何位置。</p>
</div>
</blockquote>
<div class="attribution">— JPA 2.1规范的第8.2.1.6.2节</div>
</div>
<div class="paragraph">
<p>因此，映射文件可以驻留在应用程序jar工件中，或者可以将它们存储在外部文件夹位置，并且知道该位置包括在类路径中。</p>
</div>
<div class="paragraph">
<p>Hibernate在这方面更为宽大，因此您甚至可以在应用程序配置的类路径之外使用任何外部位置。</p>
</div>
<div id="bootstrap-jpa-compliant-persistence-xml-external-mappings-example" class="exampleblock">
<div class="title">示例279用于外部XML映射的META-INF / persistence.xml配置文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">&lt;persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
             http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1"&gt;

    &lt;persistence-unit name="CRM"&gt;
        &lt;description&gt;
            Persistence unit for Hibernate User Guide
        &lt;/description&gt;

        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;

        &lt;mapping-file&gt;file:///etc/opt/app/mappings/orm.xml&lt;/mapping-file&gt;

        &lt;properties&gt;
            &lt;property name="javax.persistence.jdbc.driver"
                      value="org.h2.Driver" /&gt;

            &lt;property name="javax.persistence.jdbc.url"
                      value="jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE" /&gt;

            &lt;property name="javax.persistence.jdbc.user"
                      value="sa" /&gt;

            &lt;property name="javax.persistence.jdbc.password"
                      value="" /&gt;

            &lt;property name="hibernate.show_sql"
                      value="true" /&gt;

            &lt;property name="hibernate.hbm2ddl.auto"
                      value="update" /&gt;
        &lt;/properties&gt;

    &lt;/persistence-unit&gt;

&lt;/persistence&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在里面<code>persistence.xml</code>上面的配置文件<code>orm.xml</code>包含所有JPA实体映射的XML文件位于<code>/etc/opt/app/mappings/</code>夹。</p>
</div>
</div>
<div class="sect3">
<h4 id="bootstrap-jpa-metadata"><a class="anchor" href="#bootstrap-jpa-metadata"></a> 3.2.3。配置<code>SessionFactory</code><code>Metadata</code>通过JPA引导程序</h4>
<div class="paragraph">
<p>如前所述，Hibernate本机引导机制允许您自定义各种配置，这些配置是通过<code>Metadata</code>宾语。</p>
</div>
<div class="paragraph">
<p>使用Hibernate作为JPA提供程序时， <code>EntityManagerFactory</code>有一个后盾<code>SessionFactory</code> 。因此，您可能仍要使用<code>Metadata</code>对象通过各种设置，这些设置是无法通过标准的Hibernate <a href="#appendices/Configurations.adoc">配置设置提供的</a> 。</p>
</div>
<div class="paragraph">
<p>因此，您可以使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/spi/MetadataBuilderContributor.html"><code>MetadataBuilderContributor</code></a>在以下示例中可以看到该类。</p>
</div>
<div id="bootstrap-jpa-compliant-MetadataBuilderContributor-example" class="exampleblock">
<div class="title">示例280实施<code>MetadataBuilderContributor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class SqlFunctionMetadataBuilderContributor
        implements MetadataBuilderContributor {

    @Override
    public void contribute(MetadataBuilder metadataBuilder) {
        metadataBuilder.applySqlFunction(
            "instr", new StandardSQLFunction( "instr", StandardBasicTypes.STRING )
        );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上<code>MetadataBuilderContributor</code>用于注册一个<code>SqlFuction</code>当前运行的Hibernate状态未定义<code>Dialect</code> ，但是我们需要在JPQL查询中引用。</p>
</div>
<div class="paragraph">
<p>通过访问<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/MetadataBuilder.html"><code>MetadataBuilder</code></a>基础使用的类<code>SessionFactory</code> ，JPA引导程序变得与Hibernate本机引导程序机制一样灵活。</p>
</div>
<div class="paragraph">
<p>然后，您可以通过自定义<code>MetadataBuilderContributor</code>通过<code>hibernate.metadata_builder_contributor</code>配置属性，如<a href="#configurations-bootstrap">配置章节中所述</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schema-generation"><a class="anchor" href="#schema-generation"></a> 4。模式生成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate允许您从实体映射生成数据库。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管自动模式生成对于测试和原型设计非常有用，但是在生产环境中，使用增量迁移脚本来管理模式更加灵活。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>传统上，从实体映射生成模式的过程称为<code>HBM2DDL</code> 。要获取Hibernate本地和JPA特定配置属性的列表，请考虑阅读“ <a href="#configurations-hbmddl">配置”</a>部分。</p>
</div>
<div class="paragraph">
<p>考虑以下域模型：</p>
</div>
<div id="schema-generation-domain-model-example" class="exampleblock">
<div class="title">示例281模式生成域模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Customer")
public class Customer {

	@Id
	private Integer id;

	private String name;

	@Basic( fetch = FetchType.LAZY )
	private UUID accountsPayableXrefId;

	@Lob
	@Basic( fetch = FetchType.LAZY )
	@LazyGroup( "lobs" )
	private Blob image;

	//Getters and setters are omitted for brevity

}

@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@OneToMany(mappedBy = "author")
	private List&lt;Book&gt; books = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	@NaturalId
	private String isbn;

	@ManyToOne
	private Person author;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>hibernate.hbm2ddl.auto</code>配置设置为<code>create</code> ，Hibernate将生成以下数据库架构：</p>
</div>
<div id="sql-schema-generation-domain-model-example" class="exampleblock">
<div class="title">实施例282。自动生成的数据库架构</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer (
    id integer not null,
    accountsPayableXrefId binary,
    image blob,
    name varchar(255),
    primary key (id)
)

create table Book (
    id bigint not null,
    isbn varchar(255),
    title varchar(255),
    author_id bigint,
    primary key (id)
)

create table Person (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

alter table Book
    add constraint UK_u31e1frmjp9mxf8k8tmp990i unique (isbn)

alter table Book
    add constraint FKrxrgiajod1le3gii8whx2doie
    foreign key (author_id)
    references Person</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-script-files"><a class="anchor" href="#schema-generation-script-files"></a> 4.1。导入脚本文件</h3>
<div class="paragraph">
<p>要自定义模式生成过程， <code>hibernate.hbm2ddl.import_files</code>配置属性必须用于提供Hibernate在以下情况下可以使用的其他脚本文件： <code>SessionFactory</code>开始。</p>
</div>
<div class="paragraph">
<p>例如，考虑以下<code>schema-generation.sql</code>导入文件：</p>
</div>
<div id="schema-generation-import-file-example" class="exampleblock">
<div class="title">示例283模式生成导入文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">create sequence book_sequence start with 1 increment by 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们将Hibernate配置为导入上面的脚本：</p>
</div>
<div id="schema-generation-import-file-configuration-example" class="exampleblock">
<div class="title">示例284。启用查询缓存</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.hbm2ddl.import_files"
    value="schema-generation.sql" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>模式自动生成后，Hibernate将执行脚本文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-database-objects"><a class="anchor" href="#schema-generation-database-objects"></a> 4.2。数据库对象</h3>
<div class="paragraph">
<p>Hibernate允许您通过HBM自定义模式生成过程<code>database-object</code>元件。</p>
</div>
<div class="paragraph">
<p>考虑以下HBM映射：</p>
</div>
<div id="schema-generation-database-object-example" class="exampleblock">
<div class="title">示例285。模式生成HBM数据库对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd" &gt;

&lt;hibernate-mapping&gt;
    &lt;database-object&gt;
        &lt;create&gt;
            CREATE OR REPLACE FUNCTION sp_count_books(
                IN authorId bigint,
                OUT bookCount bigint)
                RETURNS bigint AS
            $BODY$
                BEGIN
                    SELECT COUNT(*) INTO bookCount
                    FROM book
                    WHERE author_id = authorId;
                END;
            $BODY$
            LANGUAGE plpgsql;
        &lt;/create&gt;
        &lt;drop&gt;&lt;/drop&gt;
        &lt;dialect-scope name="org.hibernate.dialect.PostgreSQL95Dialect" /&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>SessionFactory</code>被引导，Hibernate将执行<code>database-object</code> ，因此创建了<code>sp_count_books</code>功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-database-checks"><a class="anchor" href="#schema-generation-database-checks"></a> 4.3。数据库级检查</h3>
<div class="paragraph">
<p>Hibernate提供了<code>@Check</code>批注，以便您可以指定一个任意的SQL CHECK约束，该约束可以如下定义：</p>
</div>
<div id="schema-generation-database-checks-example" class="exampleblock">
<div class="title">示例286数据库检查实体映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Book")
@Check( constraints = "CASE WHEN isbn IS NOT NULL THEN LENGTH(isbn) = 13 ELSE true END")
public static class Book {

	@Id
	private Long id;

	private String title;

	@NaturalId
	private String isbn;

	private Double price;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，如果您尝试添加一个<code>Book</code>有一个实体<code>isbn</code>长度不是13个字符的属性， <code>ConstraintViolationException</code>将被抛出。</p>
</div>
<div id="stag::schema-generation-database-checks-persist-example" class="exampleblock">
<div class="title">示例287数据库检查失败示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = new Book();
book.setId( 1L );
book.setPrice( 49.99d );
book.setTitle( "High-Performance Java Persistence" );
book.setIsbn( "11-11-2016" );

entityManager.persist( book );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT  INTO Book (isbn, price, title, id)
VALUES  ('11-11-2016', 49.99, 'High-Performance Java Persistence', 1)

-- WARN SqlExceptionHelper:129 - SQL Error: 0, SQLState: 23514
-- ERROR SqlExceptionHelper:131 - ERROR: new row for relation "book" violates check constraint "book_isbn_check"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-column-default-value"><a class="anchor" href="#schema-generation-column-default-value"></a> 4.4。数据库列的默认值</h3>
<div class="paragraph">
<p>使用Hibernate，您可以使用以下命令为给定的数据库列指定默认值： <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ColumnDefault.html"><code>@ColumnDefault</code></a>注解。</p>
</div>
<div id="schema-generation-column-default-value-mapping-example" class="exampleblock">
<div class="title">示例288 <code>@ColumnDefault</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
@DynamicInsert
public static class Person {

    @Id
    private Long id;

    @ColumnDefault("'N/A'")
    private String name;

    @ColumnDefault("-1")
    private Long clientId;

    //Getter and setters omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CREATE TABLE Person (
  id BIGINT NOT NULL,
  clientId BIGINT DEFAULT -1,
  name VARCHAR(255) DEFAULT 'N/A',
  PRIMARY KEY (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的映射中， <code>name</code>和<code>clientId</code>表列将使用<code>DEFAULT</code>值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>Person</code>上面的实体带有注释<code>@DynamicInsert</code>注释，以便<code>INSERT</code>语句不包含任何不包含值的实体属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这样，当省略<code>name</code>和<code>clientId</code>属性，数据库将根据其默认值进行设置。</p>
</div>
<div id="schema-generation-column-default-value-persist-example" class="exampleblock">
<div class="title">示例289 <code>@ColumnDefault</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
    Person person = new Person();
    person.setId( 1L );
    entityManager.persist( person );
} );
doInJPA( this::entityManagerFactory, entityManager -&gt; {
    Person person = entityManager.find( Person.class, 1L );
    assertEquals( "N/A", person.getName() );
    assertEquals( Long.valueOf( -1L ), person.getClientId() );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person (id) VALUES (?)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-columns-unique-constraint"><a class="anchor" href="#schema-generation-columns-unique-constraint"></a> 4.5。列唯一约束</h3>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/UniqueConstraint.html"><code>@UniqueConstraint</code></a>注释用于为与当前带注释的实体相关联的主表或辅助表指定唯一的约束，该约束将由自动模式生成器包括。</p>
</div>
<div class="paragraph">
<p>考虑以下实体映射，Hibernate在创建数据库模式时会生成唯一约束DDL：</p>
</div>
<div id="schema-generation-columns-unique-constraint-mapping-example" class="exampleblock">
<div class="title">示例290 <code>@UniqueConstraint</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Table(
    name = "book",
    uniqueConstraints =  @UniqueConstraint(
        name = "uk_book_title_author",
        columnNames = {
            "title",
            "author_id"
        }
    )
)
public static class Book {

    @Id
    @GeneratedValue
    private Long id;

    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
        name = "author_id",
        foreignKey = @ForeignKey(name = "fk_book_author_id")
    )
    private Author author;

    //Getter and setters omitted for brevity
}

@Entity
@Table(name = "author")
public static class Author {

    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    //Getter and setters omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table author (
    id bigint not null,
    first_name varchar(255),
    last_name varchar(255),
    primary key (id)
)

create table book (
    id bigint not null,
    title varchar(255),
    author_id bigint,
    primary key (id)
)

alter table book
   add constraint uk_book_title_author
   unique (title, author_id)

alter table book
   add constraint fk_book_author_id
   foreign key (author_id)
   references author</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随着<code>uk_book_title_author</code>由于存在独特的约束条件，因此不再可以添加两个具有相同标题和同一作者的书籍。</p>
</div>
<div id="schema-generation-columns-unique-constraint-persist-example" class="exampleblock">
<div class="title">示例291 <code>@UniqueConstraintTest</code>坚持的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">     Author _author = doInJPA( this::entityManagerFactory, entityManager -&gt; {
         Author author = new Author();
         author.setFirstName( "Vlad" );
         author.setLastName( "Mihalcea" );
         entityManager.persist( author );

         Book book = new Book();
         book.setTitle( "High-Performance Java Persistence" );
         book.setAuthor( author );
         entityManager.persist( book );

         return author;
     } );

     try {
         doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Book book = new Book();
	book.setTitle( "High-Performance Java Persistence" );
	book.setAuthor( _author );
	entityManager.persist( book );
} );
     }
     catch (Exception expected) {
         assertNotNull( ExceptionUtil.findCause( expected, ConstraintViolationException.class ) );
     }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    author
    (first_name, last_name, id)
values
    (?, ?, ?)

-- binding parameter [1] as [VARCHAR] - [Vlad]
-- binding parameter [2] as [VARCHAR] - [Mihalcea]
-- binding parameter [3] as [BIGINT]  - [1]

insert
into
    book
    (author_id, title, id)
values
    (?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [VARCHAR] - [High-Performance Java Persistence]
-- binding parameter [3] as [BIGINT]  - [2]

insert
into
    book
    (author_id, title, id)
values
    (?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [VARCHAR] - [High-Performance Java Persistence]
-- binding parameter [3] as [BIGINT]  - [3]

-- SQL Error: 23505, SQLState: 23505
-- Unique index or primary key violation: "UK_BOOK_TITLE_AUTHOR_INDEX_1 ON PUBLIC.BOOK(TITLE, AUTHOR_ID) VALUES ( /* key:1 */ 3, 'High-Performance Java Persistence', 1)";</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于唯一约束冲突，第二条INSERT语句失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="schema-generation-columns-index"><a class="anchor" href="#schema-generation-columns-index"></a> 4.6。列索引</h3>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Index.html"><code>@Index</code></a>自动模式生成工具使用注释来创建数据库索引。</p>
</div>
<div class="paragraph">
<p>考虑以下实体映射，Hibernate在创建数据库模式时会生成索引：</p>
</div>
<div id="schema-generation-columns-index-mapping-example" class="exampleblock">
<div class="title">示例292 <code>@Index</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Table(
    name = "author",
    indexes =  @Index(
        name = "idx_author_first_last_name",
        columnList = "first_name, last_name",
        unique = false
    )
)
public static class Author {

    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    //Getter and setters omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table author (
    id bigint not null,
    first_name varchar(255),
    last_name varchar(255),
    primary key (id)
)

create index idx_author_first_last_name
    on author (first_name, last_name)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pc"><a class="anchor" href="#pc"></a> 5，持久性上下文</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这俩<code>org.hibernate.Session</code> API和<code>javax.persistence.EntityManager</code> API表示用于处理持久性数据的上下文。这个概念叫做<code>persistence context</code> 。持久性数据具有与持久性上下文和基础数据库有关的状态。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>transient</code></dt>
<dd>
<p>该实体刚刚被实例化，并且与持久性上下文无关。它在数据库中没有持久性表示形式，并且通常没有分配标识符值（除非使用了<em>分配的</em>生成器）。</p>
</dd>
<dt class="hdlist1"><code>managed</code> ， 要么<code>persistent</code></dt>
<dd>
<p>该实体具有关联的标识符，并且与持久性上下文关联。它实际上可能存在或可能不存在于数据库中。</p>
</dd>
<dt class="hdlist1"><code>detached</code></dt>
<dd>
<p>实体具有关联的标识符，但不再与持久性上下文关联（通常是因为持久性上下文已关闭或实例已从上下文中退出）</p>
</dd>
<dt class="hdlist1"><code>removed</code></dt>
<dd>
<p>该实体具有关联的标识符，并且与持久性上下文关联，但是，已计划将其从数据库中删除。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>许多<code>org.hibernate.Session</code>和<code>javax.persistence.EntityManager</code>方法处理这些状态之间的移动实体。</p>
</div>
<div class="sect2">
<h3 id="pc-unwrap"><a class="anchor" href="#pc-unwrap"></a> 5.1。从JPA访问Hibernate API</h3>
<div class="paragraph">
<p>JPA定义了一种非常有用的方法，以允许应用程序访问基础提供程序的API。</p>
</div>
<div id="pc-unwrap-example" class="exampleblock">
<div class="title">示例293从JPA访问Hibernate API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap( Session.class );
SessionImplementor sessionImplementor = entityManager.unwrap( SessionImplementor.class );

SessionFactory sessionFactory = entityManager.getEntityManagerFactory().unwrap( SessionFactory.class );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="BytecodeEnhancement"><a class="anchor" href="#BytecodeEnhancement"></a> 5.2。字节码增强</h3>
<div class="paragraph">
<p>Hibernate“长大了”根本不支持字节码增强。当时，Hibernate仅支持基于代理的延迟加载，并且始终使用基于差异的脏计算。Hibernate 3.x首次尝试了Hibernate中的字节码增强支持。我们将这些最初的尝试（直至5.0）完全视为一次孵化。从5.0开始对字节码增强的支持就是我们在这里讨论的内容。</p>
</div>
<div class="sect3">
<h4 id="BytecodeEnhancement-capabilities"><a class="anchor" href="#BytecodeEnhancement-capabilities"></a> 5.2.1。能力</h4>
<div class="paragraph">
<p>Hibernate支持增强应用程序Java域模型，以将各种与持久性相关的功能直接添加到类中。</p>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-lazy-loading"><a class="anchor" href="#BytecodeEnhancement-lazy-loading"></a>延迟属性加载</h5>
<div class="paragraph">
<p>将其视为部分加载支持。从本质上讲，您可以告诉Hibernate从数据库中获取实体时，仅应加载实体的一部分，以及何时应加载其他部分。请注意，这与基于代理的延迟加载思想非常不同，后者是以实体为中心的，在这种情况下，根据需要立即加载实体的状态。通过字节码增强，可以根据需要加载单个属性或属性组。</p>
</div>
<div class="paragraph">
<p>可以将惰性属性指定为一起加载，这称为“惰性组”。默认情况下，所有奇异属性都是单个组的一部分，这意味着当访问一个惰性奇异属性时，将加载所有惰性奇异属性。默认情况下，惰性复数属性本身都是惰性组。此行为可以通过以下方式明确控制<code>@org.hibernate.annotations.LazyGroup</code>注解。</p>
</div>
<div id="BytecodeEnhancement-lazy-loading-example" class="exampleblock">
<div class="title">实施例294。 <code>@LazyGroup</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Customer {

	@Id
	private Integer id;

	private String name;

	@Basic( fetch = FetchType.LAZY )
	private UUID accountsPayableXrefId;

	@Lob
	@Basic( fetch = FetchType.LAZY )
	@LazyGroup( "lobs" )
	private Blob image;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们有2个惰性属性： <code>accountsPayableXrefId</code>和<code>image</code> 。每个都是不同提取组的一部分（accountsPayableXrefId是默认提取组的一部分），这意味着访问<code>accountsPayableXrefId</code>不会强制加载<code>image</code>属性，反之亦然。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>作为希望的临时遗留保留，当前要求所有惰性单数关联（多对一和一对一）也包括<code>@LazyToOne(LazyToOneOption.NO_PROXY)</code> 。计划是稍后放宽该要求。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-dirty-tracking"><a class="anchor" href="#BytecodeEnhancement-dirty-tracking"></a>在线脏跟踪</h5>
<div class="paragraph">
<p>从历史上看，Hibernate仅支持基于差异的脏计算来确定持久性上下文中的哪些实体已更改。从本质上讲，这意味着Hibernate将跟踪关于数据库的实体的最后一个已知状态（通常是最后一次读取或写入）。然后，作为刷新持久性上下文的一部分，Hibernate将遍历与持久性上下文关联的每个实体，并对照“最后已知的数据库状态”检查其当前状态。到目前为止，这是进行脏检查的最彻底方法，因为它考虑了可以更改其内部状态的数据类型（ <code>java.util.Date</code>是最典型的例子）。但是，在具有大量关联实体的持久性上下文中，它也可能是抑制性能的方法。</p>
</div>
<div class="paragraph">
<p>如果您的应用程序不需要关心“内部状态更改数据类型”用例，则字节码增强的脏跟踪可能是值得考虑的替代方法，尤其是在性能方面。在这种方法中，Hibernate将操纵您的类的字节码以直接向实体添加“脏污跟踪”，从而使实体本身可以跟踪其属性中的哪些已更改。在刷新期间，Hibernate会询问您的实体已更改的内容，而不必执行状态差异计算。</p>
</div>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-dirty-tracking-bidirectional"><a class="anchor" href="#BytecodeEnhancement-dirty-tracking-bidirectional"></a>双向关联管理</h5>
<div class="paragraph">
<p>Hibernate努力使您的应用程序尽可能接近“正常Java使用率”（惯用Java）。考虑具有普通法则的域模型<code>Person</code> / <code>Book</code>双向关联：</p>
</div>
<div id="BytecodeEnhancement-dirty-tracking-bidirectional-example" class="exampleblock">
<div class="title">示例295双向关联</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@OneToMany(mappedBy = "author")
	private List&lt;Book&gt; books = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}

@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	@NaturalId
	private String isbn;

	@ManyToOne
	private Person author;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div id="BytecodeEnhancement-dirty-tracking-bidirectional-incorrect-usage-example" class="exampleblock">
<div class="title">实施例296。正常Java使用率不正确</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setName( "John Doe" );

Book book = new Book();
person.getBooks().add( book );
try {
	book.getAuthor().getName();
}
catch (NullPointerException expected) {
	// This blows up ( NPE ) in normal Java usage
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这在正常的Java使用中会爆炸。正确的常规Java用法是：</p>
</div>
<div id="BytecodeEnhancement-dirty-tracking-bidirectional-correct-usage-example" class="exampleblock">
<div class="title">示例297。正确使用Java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setName( "John Doe" );

Book book = new Book();
person.getBooks().add( book );
book.setAuthor( person );

book.getAuthor().getName();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>字节码增强的双向关联管理通过操纵双向关联的“另一侧”来管理第一个示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-dirty-tracking-optimizations"><a class="anchor" href="#BytecodeEnhancement-dirty-tracking-optimizations"></a>内部绩效优化</h5>
<div class="paragraph">
<p>此外，我们使用增强过程来添加一些其他代码，这些代码使我们能够优化持久性上下文的某些性能特征。不深入讨论Hibernate内部原理，就很难讨论这些内容。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="BytecodeEnhancement-enhancement"><a class="anchor" href="#BytecodeEnhancement-enhancement"></a> 5.2.2。执行增强</h4>
<div class="sect4">
<h5 id="BytecodeEnhancement-enhancement-runtime"><a class="anchor" href="#BytecodeEnhancement-enhancement-runtime"></a>运行时增强</h5>
<div class="paragraph">
<p>当前，仅在遵循JPA定义的SPI进行类转换的托管JPA环境中支持域模型的运行时增强。</p>
</div>
<div class="paragraph">
<p>即使这样，默认情况下也会禁用此支持。要启用运行时增强，请指定以下配置属性之一：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableDirtyTracking</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用脏跟踪功能。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableLazyInitialization</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用延迟加载功能。这样，即使是基本类型（例如<code>@Basic(fetch = FetchType.LAZY</code> ））可以延迟获取。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableAssociationManagement</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用关联管理功能，当仅更改一侧时，该功能会自动同步双向关联。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>另外，目前，只有带注释的类支持运行时增强。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-enhancement-gradle"><a class="anchor" href="#BytecodeEnhancement-enhancement-gradle"></a> Gradle插件</h5>
<div class="paragraph">
<p>Hibernate提供了一个Gradle插件，当它们作为Gradle构建的一部分进行编译时，它能够提供域模型的构建时增强。要使用该插件，项目首先需要应用它：</p>
</div>
<div class="exampleblock">
<div class="title">实施例298。应用Gradle插件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-gradle" data-lang="gradle">ext {
    hibernateVersion = 'hibernate-version-you-want'
}

buildscript {
    dependencies {
        classpath "org.hibernate:hibernate-gradle-plugin:$hibernateVersion"
    }
}

hibernate {
    enhance {
        // any configuration goes here
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可用的配置通过已注册的Gradle DSL扩展公开：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">enableLazyInitialization</dt>
<dd>
<p>是否应该对延迟属性加载进行增强。</p>
</dd>
<dt class="hdlist1">enableDirtyTracking</dt>
<dd>
<p>是否应该对自脏跟踪进行增强。</p>
</dd>
<dt class="hdlist1">enableAssociationManagement</dt>
<dd>
<p>是否应进行双向关联管理的增强。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>所有3个配置设置的默认值为<code>false</code></p>
</div>
<div class="paragraph">
<p>的<code>enhance { }</code>为了增强功能，块是必需的。默认情况下禁用增强功能，以准备插件中的附加功能（hbm2ddl等）。</p>
</div>
</div>
<div class="sect4">
<h5 id="BytecodeEnhancement-enhancement-maven"><a class="anchor" href="#BytecodeEnhancement-enhancement-maven"></a> Maven插件</h5>
<div class="paragraph">
<p>Hibernate提供了一个Maven插件，能够在将域模型作为Maven构建的一部分进行编译时提供构建时增强。有关配置设置的详细信息，请参见<a href="#BytecodeEnhancement-enhancement-gradle">Gradle插件</a>上的部分。同样，这3个的默认值为<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>Maven插件支持一种附加的配置设置：failOnError，它控制发生错误时的情况。默认行为是使构建失败，但是可以将其设置为仅发出警告。</p>
</div>
<div class="exampleblock">
<div class="title">示例299应用Maven插件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        [...]
        &lt;plugin&gt;
            &lt;groupId&gt;org.hibernate.orm.tooling&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-enhance-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;$currentHibernateVersion&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;configuration&gt;
                        &lt;failOnError&gt;true&lt;/failOnError&gt;
                        &lt;enableLazyInitialization&gt;true&lt;/enableLazyInitialization&gt;
                        &lt;enableDirtyTracking&gt;true&lt;/enableDirtyTracking&gt;
                        &lt;enableAssociationManagement&gt;true&lt;/enableAssociationManagement&gt;
                    &lt;/configuration&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;enhance&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        [...]
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-persist"><a class="anchor" href="#pc-persist"></a> 5.3。使实体持久化</h3>
<div class="paragraph">
<p>一旦创建了新的实体实例（使用标准<code>new</code>运算符）它在<code>new</code>州。您可以通过将其关联到任一<code>org.hibernate.Session</code>要么<code>javax.persistence.EntityManager</code> 。</p>
</div>
<div id="pc-persist-jpa-example" class="exampleblock">
<div class="title">示例300使用JPA使实体持久化</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setName("John Doe");

entityManager.persist( person );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-persist-native-example" class="exampleblock">
<div class="title">示例301使用Hibernate API使实体持久化</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setName("John Doe");

session.save( person );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>org.hibernate.Session</code>也有一个名为persist的方法，该方法遵循JPA规范中为persist方法定义的确切语义。就是这个<code>org.hibernate.Session</code>Hibernate方式<code>javax.persistence.EntityManager</code>实现代表。</p>
</div>
<div class="paragraph">
<p>如果<code>DomesticCat</code>实体类型具有生成的标识符，该值在调用保存或持久性时与实例相关联。如果没有自动生成标识符，则在调用save或persist方法之前，必须在实例上设置手动分配的（通常是自然的）键值。</p>
</div>
</div>
<div class="sect2">
<h3 id="pc-remove"><a class="anchor" href="#pc-remove"></a> 5.4。删除（删除）实体</h3>
<div class="paragraph">
<p>实体也可以删除。</p>
</div>
<div id="pc-remove-jpa-example" class="exampleblock">
<div class="title">示例302使用JPA删除实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager.remove( person );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-remove-native-example" class="exampleblock">
<div class="title">示例303使用Hibernate API删除实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">session.delete( person );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate本身可以处理处于分离状态的删除实体。但是，JPA不允许这种行为。</p>
</div>
<div class="paragraph">
<p>这里的含义是将实体实例传递给<code>org.hibernate.Session</code> delete方法可以处于托管状态或分离状态，而传递给<code>javax.persistence.EntityManager</code>必须处于托管状态。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="pc-get-reference"><a class="anchor" href="#pc-get-reference"></a> 5.5。获取实体引用而不初始化其数据</h3>
<div class="paragraph">
<p>有时称为延迟加载，在无需加载其数据的情况下获取对实体的引用的能力非常重要。最常见的情况是需要在一个实体和另一个现有实体之间创建关联。</p>
</div>
<div id="pc-get-reference-jpa-example" class="exampleblock">
<div class="title">示例304在不使用JPA初始化其数据的情况下获取实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = new Book();
book.setAuthor( entityManager.getReference( Person.class, personId ) );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-get-reference-native-example" class="exampleblock">
<div class="title">示例305在不使用Hibernate API初始化其数据的情况下获取实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = new Book();
book.setId( 1L );
book.setIsbn( "123-456-7890" );
entityManager.persist( book );
book.setAuthor( session.load( Person.class, personId ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的假设是，通常通过使用运行时代理将实体定义为允许延迟加载。在这两种情况下，如果在应用程序尝试以任何需要访问其数据的方式来使用返回的代理时，如果给定实体未引用实际的数据库状态，则会在以后引发异常。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除非声明实体类<code>final</code> ，代理扩展了实体类。如果实体类是<code>final</code> ，代理将改为实现一个接口。见<a href="#entity-proxy"><code>@Proxy</code>映射</a>部分以获取更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="pc-find"><a class="anchor" href="#pc-find"></a> 5.6。获取其数据已初始化的实体</h3>
<div class="paragraph">
<p>想要与数据一起获得实体也是很普遍的（例如，当我们需要在UI中显示实体时）。</p>
</div>
<div id="pc-find-jpa-example" class="exampleblock">
<div class="title">示例306使用JPA初始化的数据获取实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, personId );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-find-native-example" class="exampleblock">
<div class="title">示例307使用Hibernate API初始化的数据获取实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.get( Person.class, personId );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-find-by-id-native-example" class="exampleblock">
<div class="title">示例308获取实体引用，并使用数据初始化其数据<code>byId()</code>HibernateAPI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，如果都找不到匹配的数据库行，则返回null。</p>
</div>
<div class="paragraph">
<p>可以返回Java 8 <code>Optional</code>以及：</p>
</div>
<div id="tag::pc-find-optional-by-id-native-example" class="exampleblock">
<div class="title">实施例309。获取可选实体引用，其数据使用<code>byId()</code>HibernateAPI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Optional&lt;Person&gt; optionalPerson = session.byId( Person.class ).loadOptional( personId );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-by-multiple-ids"><a class="anchor" href="#pc-by-multiple-ids"></a> 5.7。通过其标识符获取多个实体</h3>
<div class="paragraph">
<p>如果您想通过提供其标识符来加载多个实体，请调用<code>EntityManager#find</code>多次使用该方法不仅不方便，而且效率低下。</p>
</div>
<div class="paragraph">
<p>尽管JPA标准不支持一次检索多个实体（除了运行JPQL或Criteria API查询），但Hibernate通过以下方式提供了此功能： <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#byMultipleIds-java.lang.Class-"><code>byMultipleIds</code></a>Hibernate<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#byMultipleIds-java.lang.Class-">方法</a> <code>Session</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>byMultipleIds</code>方法返回一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/MultiIdentifierLoadAccess.html"><code>MultiIdentifierLoadAccess</code></a>您可以用来自定义多加载请求。</p>
</div>
<div class="paragraph">
<p>的<code>MultiIdentifierLoadAccess</code>界面提供了几种方法，可用于更改多负载调用的行为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>enableOrderedReturn(boolean enabled)</code></dt>
<dd>
<p>此设置控制是否返回<code>List</code>相对于传入ID进行排序和定位。如果启用（默认），则返回<code>List</code>相对于传入ID进行排序和定位。换句话说， <code>multiLoad([2,1,3])</code>将返回<code>[Entity#2, Entity#1, Entity#3]</code> 。</p>
<div class="paragraph">
<p>在此方面，根据此“有序退货”设置，在处理未知实体方面存在重要区别。如果启用，则将null插入<code>List</code>在适当的位置。如果禁用，则不将空值放入返回列表中。</p>
</div>
<div class="paragraph">
<p>换句话说，返回的有序列表的使用者将需要能够处理空元素。</p>
</div>
</dd>
<dt class="hdlist1"><code>enableSessionCheck(boolean enabled)</code></dt>
<dd>
<p>此设置默认情况下处于禁用状态，它告诉Hibernate检查一级缓存（aka <code>Session</code>或Persistence Context），如果该实体已找到并已经由Hibernate管理， <code>Session</code> ，缓存的实体将添加到返回的实体中<code>List</code> ，因此跳过了通过多负载查询获取它的操作。</p>
</dd>
<dt class="hdlist1"><code>enableReturnOfDeletedEntities(boolean enabled)</code></dt>
<dd>
<p>如果允许多加载操作返回当前持久性上下文删除的实体，则此设置指示Hibernate。删除的实体是已传递给此实体的实体<code>Session.delete</code>要么<code>Session.remove</code>方法，但是<code>Session</code>尚未刷新，这意味着关联的行尚未在数据库表中删除。</p>
<div class="paragraph">
<p>默认行为是在返回中将它们作为null处理（请参见<code>enableOrderedReturn</code> ）。启用后，结果集将包含已删除的实体。禁用时（这是默认行为），删除的实体不包括在返回的<code>List</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code>with(LockOptions lockOptions)</code></dt>
<dd>
<p>此设置允许您通过给定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/LockOptions.html"><code>LockOptions</code></a>模式以进行多负载查询。</p>
</dd>
<dt class="hdlist1"><code>with(CacheMode cacheMode)</code></dt>
<dd>
<p>此设置允许您通过给定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/CacheMode.html"><code>CacheMode</code></a>策略，以便我们可以从二级缓存中加载实体，因此跳过了通过多重加载查询获取的缓存实体。</p>
</dd>
<dt class="hdlist1"><code>withBatchSize(int batchSize)</code></dt>
<dd>
<p>此设置允许您指定用于加载实体的批处理大小（例如，一次加载多少个）。</p>
<div class="paragraph">
<p>默认设置是使用由<code>Dialect.getDefaultBatchLoadSizingStrategy()</code>方法。</p>
</div>
<div class="paragraph">
<p>此处的任何大于1的值都将覆盖该默认行为。</p>
</div>
</dd>
<dt class="hdlist1"><code>with(RootGraph<T> graph)</code></dt>
<dd>
<p>的<code>RootGraph</code>是JPA的Hibernate扩展<code>EntityGraph</code>合同，并且此方法允许您通过特定的<code>RootGraph</code>到多加载查询，以便它可以获取当前加载实体的其他关系。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>现在，假设我们有3 <code>Person</code>数据库中的实体，我们可以通过一个调用来加载所有实体，如以下示例所示：</p>
</div>
<div id="tag::pc-by-multiple-ids-example" class="exampleblock">
<div class="title">例子310。使用加载多个实体<code>byMultipleIds()</code>HibernateAPI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap( Session.class );

List&lt;Person&gt; persons = session
		.byMultipleIds( Person.class )
		.multiLoad( 1L, 2L, 3L );

assertEquals( 3, persons.size() );

List&lt;Person&gt; samePersons = session
		.byMultipleIds( Person.class )
		.enableSessionCheck( true )
		.multiLoad( 1L, 2L, 3L );

assertEquals( persons, samePersons );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT p.id AS id1_0_0_,
       p.name AS name2_0_0_
FROM   Person p
WHERE  p.id IN ( 1, 2, 3 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，由于第二个调用使用了SQL SELECT语句，因此仅执行了一条<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/MultiIdentifierLoadAccess.html#enableSessionCheck-boolean-"><code>enableSessionCheck</code></a>的方法<code>MultiIdentifierLoadAccess</code>指示Hibernate跳过当前持久性上下文中已加载的实体。</p>
</div>
<div class="paragraph">
<p>如果实体在当前的持久性上下文中不可用，但可以从二级缓存中加载，则可以使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/MultiIdentifierLoadAccess.html#with-org.hibernate.CacheMode-"><code>with(CacheMode)</code></a>的方法<code>MultiIdentifierLoadAccess</code>宾语。</p>
</div>
<div id="tag::pc-by-multiple-ids-second-level-cache-example" class="exampleblock">
<div class="title">实施例311。从二级缓存加载多个实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SessionFactory sessionFactory = entityManagerFactory().unwrap( SessionFactory.class );
Statistics statistics = sessionFactory.getStatistics();

sessionFactory.getCache().evictAll();
statistics.clear();
sqlStatementInterceptor.clear();

assertEquals( 0, statistics.getQueryExecutionCount() );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Session session = entityManager.unwrap( Session.class );

	List&lt;Person&gt; persons = session
		.byMultipleIds( Person.class )
		.multiLoad( 1L, 2L, 3L );

	assertEquals( 3, persons.size() );
} );

assertEquals( 0, statistics.getSecondLevelCacheHitCount() );
assertEquals( 3, statistics.getSecondLevelCachePutCount() );
assertEquals( 1, sqlStatementInterceptor.getSqlQueries().size() );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Session session = entityManager.unwrap( Session.class );
	sqlStatementInterceptor.clear();

	List&lt;Person&gt; persons = session.byMultipleIds( Person.class )
		.with( CacheMode.NORMAL )
		.multiLoad( 1L, 2L, 3L );

	assertEquals( 3, persons.size() );

} );

assertEquals( 3, statistics.getSecondLevelCacheHitCount() );
assertEquals( 0, sqlStatementInterceptor.getSqlQueries().size() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们首先确保清除二级缓存，以说明多负载查询会将返回的实体放入二级缓存中。</p>
</div>
<div class="paragraph">
<p>执行完第一个<code>byMultipleIds</code>调用，Hibernate将获取请求的实体，如<code>getSecondLevelCachePutCount</code>方法调用中，确实将3个实体添加到共享缓存中。</p>
</div>
<div class="paragraph">
<p>之后，执行第二次<code>byMultipleIds</code>在新的Hibernate中要求相同的实体<code>Session</code> ，我们将<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/CacheMode.html#NORMAL"><code>CacheMode.NORMAL</code></a>二级缓存模式，以便实体将从二级缓存中返回。</p>
</div>
<div class="paragraph">
<p>的<code>getSecondLevelCacheHitCount</code>这次统计信息方法返回3，因为这3个实体是从二级缓存中加载的，并且如<code>sqlStatementInterceptor.getSqlQueries()</code> ，这次没有执行多负载SELECT语句。</p>
</div>
</div>
<div class="sect2">
<h3 id="pc-find-natural-id"><a class="anchor" href="#pc-find-natural-id"></a> 5.8。通过natural-id获取实体</h3>
<div class="paragraph">
<p>除了允许通过其标识符加载实体之外，Hibernate还允许应用程序通过声明的自然标识符加载实体。</p>
</div>
<div id="pc-find-by-natural-id-entity-example" class="exampleblock">
<div class="title">示例312自然ID映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	@NaturalId
	private String isbn;

	@ManyToOne
	private Person author;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当使用自然标识符加载方法时，我们还可以选择获取实体或仅检索对其的引用。</p>
</div>
<div id="pc-find-by-simple-natural-id-example" class="exampleblock">
<div class="title">示例313。通过简单的natural-id获取实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = session.bySimpleNaturalId( Book.class ).getReference( isbn );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-find-by-natural-id-example" class="exampleblock">
<div class="title">实施例314。通过natural-id加载实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = session
	.byNaturalId( Book.class )
	.using( "isbn", isbn )
	.load( );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以使用Java 8 <code>Optional</code>通过其自然ID加载实体：</p>
</div>
<div id="pc-find-optional-by-simple-natural-id-example" class="exampleblock">
<div class="title">示例315通过natural-id加载可选实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Optional&lt;Book&gt; optionalBook = session
	.byNaturalId( Book.class )
	.using( "isbn", isbn )
	.loadOptional( );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate提供了一个一致的API，用于通过标识符或自然ID访问持久数据。这些中的每一个都定义了相同的两种数据访问方法：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getReference</dt>
<dd>
<p>应该在假定标识符存在的情况下使用，不存在将是实际错误。永远不要用来测试存在。这是因为，如果数据尚未与会话关联，而不是访问数据库，则此方法将更喜欢创建并返回代理。使用此方法的典型用例是创建基于外键的关联。</p>
</dd>
<dt class="hdlist1">加载</dt>
<dd>
<p>将返回与给定标识符值关联的持久数据，如果该标识符不存在，则返回null。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这两种方法均定义了一个接受<code>org.hibernate.LockOptions</code>论点。锁定在单独的<a href="#locking">章节中</a>讨论。</p>
</div>
</div>
<div class="sect2">
<h3 id="pc-filtering"><a class="anchor" href="#pc-filtering"></a> 5.9。过滤实体和关联</h3>
<div class="paragraph">
<p>如果要过滤实体或实体关联，Hibernate提供了两个选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">静态（例如<code>@Where</code>和<code>@WhereJoinTable</code> ）</dt>
<dd>
<p>它们是在映射时定义的，无法在运行时更改。</p>
</dd>
<dt class="hdlist1">动态（例如<code>@Filter</code>和<code>@FilterJoinTable</code> ）</dt>
<dd>
<p>在运行时应用和配置。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="pc-where"><a class="anchor" href="#pc-where"></a> 5.9.1。<code>@Where</code></h4>
<div class="paragraph">
<p>有时，您想使用自定义SQL条件过滤掉实体或集合。这可以通过使用<code>@Where</code>批注，可以应用于实体和集合。</p>
</div>
<div id="pc-where-example" class="exampleblock">
<div class="title">实施例316。 <code>@Where</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public enum AccountType {
	DEBIT,
	CREDIT
}

@Entity(name = "Client")
public static class Client {

	@Id
	private Long id;

	private String name;

	@Where( clause = "account_type = 'DEBIT'")
	@OneToMany(mappedBy = "client")
	private List&lt;Account&gt; debitAccounts = new ArrayList&lt;&gt;( );

	@Where( clause = "account_type = 'CREDIT'")
	@OneToMany(mappedBy = "client")
	private List&lt;Account&gt; creditAccounts = new ArrayList&lt;&gt;( );

	//Getters and setters omitted for brevity

}

@Entity(name = "Account")
@Where( clause = "active = true" )
public static class Account {

	@Id
	private Long id;

	@ManyToOne
	private Client client;

	@Column(name = "account_type")
	@Enumerated(EnumType.STRING)
	private AccountType type;

	private Double amount;

	private Double rate;

	private boolean active;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果数据库包含以下实体：</p>
</div>
<div id="pc-where-persistence-example" class="exampleblock">
<div class="title">示例317。持久化和获取带有<code>@Where</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {

	Client client = new Client();
	client.setId( 1L );
	client.setName( "John Doe" );
	entityManager.persist( client );

	Account account1 = new Account( );
	account1.setId( 1L );
	account1.setType( AccountType.CREDIT );
	account1.setAmount( 5000d );
	account1.setRate( 1.25 / 100 );
	account1.setActive( true );
	account1.setClient( client );
	client.getCreditAccounts().add( account1 );
	entityManager.persist( account1 );

	Account account2 = new Account( );
	account2.setId( 2L );
	account2.setType( AccountType.DEBIT );
	account2.setAmount( 0d );
	account2.setRate( 1.05 / 100 );
	account2.setActive( false );
	account2.setClient( client );
	client.getDebitAccounts().add( account2 );
	entityManager.persist( account2 );

	Account account3 = new Account( );
	account3.setType( AccountType.DEBIT );
	account3.setId( 3L );
	account3.setAmount( 250d );
	account3.setRate( 1.05 / 100 );
	account3.setActive( true );
	account3.setClient( client );
	client.getDebitAccounts().add( account3 );
	entityManager.persist( account3 );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Client (name, id)
VALUES ('John Doe', 1)

INSERT INTO Account (active, amount, client_id, rate, account_type, id)
VALUES (true, 5000.0, 1, 0.0125, 'CREDIT', 1)

INSERT INTO Account (active, amount, client_id, rate, account_type, id)
VALUES (false, 0.0, 1, 0.0105, 'DEBIT', 2)

INSERT INTO Account (active, amount, client_id, rate, account_type, id)
VALUES (true, 250.0, 1, 0.0105, 'DEBIT', 3)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行时<code>Account</code>实体查询，Hibernate将过滤掉所有不活动的记录。</p>
</div>
<div id="pc-where-entity-query-example" class="exampleblock">
<div class="title">实施例318。查询实体与<code>@Where</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	List&lt;Account&gt; accounts = entityManager.createQuery(
		"select a from Account a", Account.class)
	.getResultList();
	assertEquals( 2, accounts.size());
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    a.id as id1_0_,
    a.active as active2_0_,
    a.amount as amount3_0_,
    a.client_id as client_i6_0_,
    a.rate as rate4_0_,
    a.account_type as account_5_0_
FROM
    Account a
WHERE ( a.active = true )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>debitAccounts</code>或者<code>creditAccounts</code>集合，Hibernate将应用<code>@Where</code>子句对关联子实体的过滤条件。</p>
</div>
<div id="pc-where-collection-query-example" class="exampleblock">
<div class="title">示例319遍历与映射的集合<code>@Where</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Client client = entityManager.find( Client.class, 1L );
	assertEquals( 1, client.getCreditAccounts().size() );
	assertEquals( 1, client.getDebitAccounts().size() );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    c.client_id as client_i6_0_0_,
    c.id as id1_0_0_,
    c.id as id1_0_1_,
    c.active as active2_0_1_,
    c.amount as amount3_0_1_,
    c.client_id as client_i6_0_1_,
    c.rate as rate4_0_1_,
    c.account_type as account_5_0_1_
FROM
    Account c
WHERE ( c.active = true and c.account_type = 'CREDIT' ) AND c.client_id = 1

SELECT
    d.client_id as client_i6_0_0_,
    d.id as id1_0_0_,
    d.id as id1_0_1_,
    d.active as active2_0_1_,
    d.amount as amount3_0_1_,
    d.client_id as client_i6_0_1_,
    d.rate as rate4_0_1_,
    d.account_type as account_5_0_1_
FROM
    Account d
WHERE ( d.active = true and d.account_type = 'DEBIT' ) AND d.client_id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-where-join-table"><a class="anchor" href="#pc-where-join-table"></a> 5.9.2。<code>@WhereJoinTable</code></h4>
<div class="paragraph">
<p>就像<code>@Where</code>注解， <code>@WhereJoinTable</code>用于使用联接表（例如@ManyToMany关联）过滤出集合。</p>
</div>
<div id="pc-where-join-table-example" class="exampleblock">
<div class="title">例子320。 <code>@WhereJoinTable</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Book")
public static class Book {

	@Id
	private Long id;

	private String title;

	private String author;

	@ManyToMany
	@JoinTable(
		name = "Book_Reader",
		joinColumns = @JoinColumn(name = "book_id"),
		inverseJoinColumns = @JoinColumn(name = "reader_id")
	)
	@WhereJoinTable( clause = "created_on &gt; DATEADD( 'DAY', -7, CURRENT_TIMESTAMP() )")
	private List&lt;Reader&gt; currentWeekReaders = new ArrayList&lt;&gt;( );

	//Getters and setters omitted for brevity

}

@Entity(name = "Reader")
public static class Reader {

	@Id
	private Long id;

	private String name;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Book (
    id bigint not null,
    author varchar(255),
    title varchar(255),
    primary key (id)
)

create table Book_Reader (
    book_id bigint not null,
    reader_id bigint not null
)

create table Reader (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

alter table Book_Reader
    add constraint FKsscixgaa5f8lphs9bjdtpf9g
    foreign key (reader_id)
    references Reader

alter table Book_Reader
    add constraint FKoyrwu9tnwlukd1616qhck21ra
    foreign key (book_id)
    references Book

alter table Book_Reader
    add created_on timestamp
    default current_timestamp</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，当前星期<code>Reader</code>实体包含在<code>currentWeekReaders</code>使用的集合<code>@WhereJoinTable</code>注释，以根据提供的SQL子句过滤联接的表行。</p>
</div>
<div class="paragraph">
<p>考虑到以下两个<code>Book_Reader</code>条目添加到我们的系统中：</p>
</div>
<div id="pc-where-join-table-persist-example" class="exampleblock">
<div class="title">例子321。 <code>@WhereJoinTable</code>测试数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = new Book();
book.setId( 1L );
book.setTitle( "High-Performance Java Persistence" );
book.setAuthor( "Vad Mihalcea" );
entityManager.persist( book );

Reader reader1 = new Reader();
reader1.setId( 1L );
reader1.setName( "John Doe" );
entityManager.persist( reader1 );

Reader reader2 = new Reader();
reader2.setId( 2L );
reader2.setName( "John Doe Jr." );
entityManager.persist( reader2 );

statement.executeUpdate(
	"INSERT INTO Book_Reader " +
	"	(book_id, reader_id) " +
	"VALUES " +
	"	(1, 1) "
);
statement.executeUpdate(
	"INSERT INTO Book_Reader " +
	"	(book_id, reader_id, created_on) " +
	"VALUES " +
	"	(1, 2, DATEADD( 'DAY', -10, CURRENT_TIMESTAMP() )) "
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>currentWeekReaders</code>集合，Hibernate将找到一个条目：</p>
</div>
<div id="pc-where-join-table-fetch-example" class="exampleblock">
<div class="title">示例322。 <code>@WhereJoinTable</code>获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = entityManager.find( Book.class, 1L );
assertEquals( 1, book.getCurrentWeekReaders().size() );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-filter"><a class="anchor" href="#pc-filter"></a> 5.9.3。<code>@Filter</code></h4>
<div class="paragraph">
<p>的<code>@Filter</code>注释是使用自定义SQL条件过滤掉实体或集合的另一种方法。不像<code>@Where</code>注解， <code>@Filter</code>允许您在运行时参数化filter子句。</p>
</div>
<div class="paragraph">
<p>现在，考虑到以下几点<code>Account</code>实体：</p>
</div>
<div id="pc-filter-account-example" class="exampleblock">
<div class="title">示例323 <code>@Filter</code>映射实体级别的用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Account")
@FilterDef(
    name="activeAccount",
    parameters = @ParamDef(
        name="active",
        type="boolean"
    )
)
@Filter(
    name="activeAccount",
    condition="active_status = :active"
)
public static class Account {

    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Client client;

    @Column(name = "account_type")
    @Enumerated(EnumType.STRING)
    private AccountType type;

    private Double amount;

    private Double rate;

    @Column(name = "active_status")
    private boolean active;

    //Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意<code>active</code>属性映射到<code>active_status</code>柱。</p>
</div>
<div class="paragraph">
<p>完成此映射是为了向您显示<code>@Filter</code> condition使用SQL条件而不是JPQL过滤谓词。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如前所述，我们也可以应用<code>@Filter</code>集合的注释，如<code>Client</code>实体：</p>
</div>
<div id="pc-filter-client-example" class="exampleblock">
<div class="title">示例324 <code>@Filter</code>映射集合级别的用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Client")
public static class Client {

    @Id
    private Long id;

    private String name;

    @OneToMany(
        mappedBy = "client",
        cascade = CascadeType.ALL
    )
    @Filter(
        name="activeAccount",
        condition="active_status = :active"
    )
    private List&lt;Account&gt; accounts = new ArrayList&lt;&gt;( );

    //Getters and setters omitted for brevity

    public void addAccount(Account account) {
        account.setClient( this );
        this.accounts.add( account );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们坚持一个<code>Client</code>与三个相关<code>Account</code>实体，Hibernate将执行以下SQL语句：</p>
</div>
<div id="pc-filter-persistence-example" class="exampleblock">
<div class="title">示例325持久化和获取带有<code>@Filter</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Client client = new Client()
.setId( 1L )
.setName( "John Doe" );

client.addAccount(
    new Account()
    .setId( 1L )
    .setType( AccountType.CREDIT )
    .setAmount( 5000d )
    .setRate( 1.25 / 100 )
    .setActive( true )
);

client.addAccount(
    new Account()
    .setId( 2L )
    .setType( AccountType.DEBIT )
    .setAmount( 0d )
    .setRate( 1.05 / 100 )
    .setActive( false )
);

client.addAccount(
    new Account()
    .setType( AccountType.DEBIT )
    .setId( 3L )
    .setAmount( 250d )
    .setRate( 1.05 / 100 )
    .setActive( true )
);

entityManager.persist( client );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Client (name, id)
VALUES ('John Doe', 1)

INSERT INTO Account (active_status, amount, client_id, rate, account_type, id)
VALUES (true, 5000.0, 1, 0.0125, 'CREDIT', 1)

INSERT INTO Account (active_status, amount, client_id, rate, account_type, id)
VALUES (false, 0.0, 1, 0.0105, 'DEBIT', 2)

INSERT INTO Account (active_status, amount, client_id, rate, account_type, id)
VALUES (true, 250.0, 1, 0.0105, 'DEBIT', 3)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，在没有显式启用过滤器的情况下，Hibernate将获取所有<code>Account</code>实体。</p>
</div>
<div id="pc-no-filter-entity-query-example" class="exampleblock">
<div class="title">示例326查询实体映射而不激活<code>@Filter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Account&gt; accounts = entityManager.createQuery(
    "select a from Account a", Account.class)
.getResultList();

assertEquals( 3, accounts.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    a.id as id1_0_,
    a.active_status as active2_0_,
    a.amount as amount3_0_,
    a.client_id as client_i6_0_,
    a.rate as rate4_0_,
    a.account_type as account_5_0_
FROM
    Account a</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果启用了过滤器，并且提供了过滤器参数值，则Hibernate会将过滤条件应用于关联的<code>Account</code>实体。</p>
</div>
<div id="pc-filter-entity-query-example" class="exampleblock">
<div class="title">示例327查询实体与<code>@Filter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager
    .unwrap( Session.class )
    .enableFilter( "activeAccount" )
    .setParameter( "active", true);

List&lt;Account&gt; accounts = entityManager.createQuery(
    "select a from Account a", Account.class)
.getResultList();

assertEquals( 2, accounts.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    a.id as id1_0_,
    a.active_status as active2_0_,
    a.amount as amount3_0_,
    a.client_id as client_i6_0_,
    a.rate as rate4_0_,
    a.account_type as account_5_0_
FROM
    Account a
WHERE
    a.active_status = true</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>过滤器适用于实体查询，但不适用于直接提取。</p>
</div>
<div class="paragraph">
<p>因此，在以下示例中，从持久性上下文中获取实体时不考虑过滤器。</p>
</div>
<div id="pc-filter-entity-example" class="listingblock">
<div class="title">提取映射到的实体<code>@Filter</code></div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager
    .unwrap( Session.class )
    .enableFilter( "activeAccount" )
    .setParameter( "active", true);

Account account = entityManager.find( Account.class, 2L );

assertFalse( account.isActive() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    a.id as id1_0_0_,
    a.active_status as active2_0_0_,
    a.amount as amount3_0_0_,
    a.client_id as client_i6_0_0_,
    a.rate as rate4_0_0_,
    a.account_type as account_5_0_0_,
    c.id as id1_1_1_,
    c.name as name2_1_1_
FROM
    Account a
WHERE
    a.id = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面的示例中可以看到，与实体查询相反，过滤器不会阻止实体的加载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>就像实体查询一样，也可以过滤集合，但前提是必须在当前运行的Hibernate上显式启用过滤器<code>Session</code> 。</p>
</div>
<div id="pc-no-filter-collection-query-example" class="exampleblock">
<div class="title">示例328遍历集合而不激活<code>@Filter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Client client = entityManager.find( Client.class, 1L );

assertEquals( 3, client.getAccounts().size() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    c.id as id1_1_0_,
    c.name as name2_1_0_
FROM
    Client c
WHERE
    c.id = 1

SELECT
    a.id as id1_0_,
    a.active_status as active2_0_,
    a.amount as amount3_0_,
    a.client_id as client_i6_0_,
    a.rate as rate4_0_,
    a.account_type as account_5_0_
FROM
    Account a
WHERE
    a.client_id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>激活时<code>@Filter</code>并获取<code>accounts</code> Hibernate将集合条件应用于关联的集合条目。</p>
</div>
<div id="pc-filter-collection-query-example" class="exampleblock">
<div class="title">示例329遍历与映射的集合<code>@Filter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager
    .unwrap( Session.class )
    .enableFilter( "activeAccount" )
    .setParameter( "active", true);

Client client = entityManager.find( Client.class, 1L );

assertEquals( 2, client.getAccounts().size() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    c.id as id1_1_0_,
    c.name as name2_1_0_
FROM
    Client c
WHERE
    c.id = 1

SELECT
    a.id as id1_0_,
    a.active_status as active2_0_,
    a.amount as amount3_0_,
    a.client_id as client_i6_0_,
    a.rate as rate4_0_,
    a.account_type as account_5_0_
FROM
    Account a
WHERE
    accounts0_.active_status = true
    and a.client_id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>主要优点<code>@Filter</code>在<code>@Where</code>子句是可以在运行时自定义过滤条件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不可能将<code>@Filter</code>和<code>@Cache</code>集合注释。此限制是由于确保一致性，并且由于过滤信息未存储在二级缓存中。</p>
</div>
<div class="paragraph">
<p>如果允许对当前筛选的集合进行缓存，则二级缓存将仅存储整个集合的一部分。此后，即使未显式激活会话级过滤器，其他所有会话也将从缓存中获取过滤的集合。</p>
</div>
<div class="paragraph">
<p>因此，第二级集合缓存仅限于存储整个集合，而不是子集。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="pc-filter-sql-fragment-alias"><a class="anchor" href="#pc-filter-sql-fragment-alias"></a> 5.9.4。 <code>@Filter</code>与<code>@SqlFragmentAlias</code></h4>
<div class="paragraph">
<p>使用时<code>@Filter</code>注释并使用映射到多个数据库表的实体，您将需要使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SqlFragmentAlias.html"><code>@SqlFragmentAlias</code></a>注释是否<code>@Filter</code>定义在多个表中使用谓词的条件。</p>
</div>
<div id="pc-filter-sql-fragment-alias-example" class="exampleblock">
<div class="title">例子330。 <code>@SqlFragmentAlias</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Account")
@Table(name = "account")
@SecondaryTable(
	name = "account_details"
)
@SQLDelete(
	sql = "UPDATE account_details SET deleted = true WHERE id = ? "
)
@FilterDef(
	name="activeAccount",
	parameters = @ParamDef(
		name="active",
		type="boolean"
	)
)
@Filter(
	name="activeAccount",
	condition="{a}.active = :active and {ad}.deleted = false",
	aliases = {
		@SqlFragmentAlias( alias = "a", table= "account"),
		@SqlFragmentAlias( alias = "ad", table= "account_details"),
	}
)
public static class Account {

	@Id
	private Long id;

	private Double amount;

	private Double rate;

	private boolean active;

	@Column(table = "account_details")
	private boolean deleted;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当获取<code>Account</code>实体并激活过滤器，Hibernate将对过滤器谓词应用正确的表别名：</p>
</div>
<div id="pc-filter-sql-fragment-alias-query-example" class="exampleblock">
<div class="title">示例331获取使用过滤的集合<code>@SqlFragmentAlias</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager
	.unwrap( Session.class )
	.enableFilter( "activeAccount" )
	.setParameter( "active", true);

List&lt;Account&gt; accounts = entityManager.createQuery(
	"select a from Account a", Account.class)
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    filtersqlf0_.id as id1_0_,
    filtersqlf0_.active as active2_0_,
    filtersqlf0_.amount as amount3_0_,
    filtersqlf0_.rate as rate4_0_,
    filtersqlf0_1_.deleted as deleted1_1_
from
    account filtersqlf0_
left outer join
    account_details filtersqlf0_1_
        on filtersqlf0_.id=filtersqlf0_1_.id
where
    filtersqlf0_.active = ?
    and filtersqlf0_1_.deleted = false

-- binding parameter [1] as [BOOLEAN] - [true]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-filter-join-table"><a class="anchor" href="#pc-filter-join-table"></a> 5.9.5。<code>@FilterJoinTable</code></h4>
<div class="paragraph">
<p>使用时<code>@Filter</code>使用集合进行批注时，将针对子条目（实体或可嵌入对象）进行过滤。但是，如果在父实体和子实体之间有一个链接表，则需要使用<code>@FilterJoinTable</code>根据联接表中包含的某些列过滤子条目。</p>
</div>
<div class="paragraph">
<p>的<code>@FilterJoinTable</code>因此，注释可以应用于单向<code>@OneToMany</code>集合，如以下映射所示：</p>
</div>
<div id="pc-filter-join-table-example" class="exampleblock">
<div class="title">示例332 <code>@FilterJoinTable</code>映射用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Client")
@FilterDef(
    name="firstAccounts",
    parameters=@ParamDef(
        name="maxOrderId",
        type="int"
    )
)
@Filter(
    name="firstAccounts",
    condition="order_id &lt;= :maxOrderId"
)
public static class Client {

    @Id
    private Long id;

    private String name;

    @OneToMany(cascade = CascadeType.ALL)
    @OrderColumn(name = "order_id")
    @FilterJoinTable(
        name="firstAccounts",
        condition="order_id &lt;= :maxOrderId"
    )
    private List&lt;Account&gt; accounts = new ArrayList&lt;&gt;( );

    //Getters and setters omitted for brevity

    public void addAccount(Account account) {
        this.accounts.add( account );
    }
}

@Entity(name = "Account")
public static class Account {

    @Id
    private Long id;

    @Column(name = "account_type")
    @Enumerated(EnumType.STRING)
    private AccountType type;

    private Double amount;

    private Double rate;

    //Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>firstAccounts</code>过滤器将使我们仅获得<code>Account</code>具有<code>order_id</code> （它告诉每个条目在<code>accounts</code>集合）小于给定的数字（例如<code>maxOrderId</code> ）。</p>
</div>
<div class="paragraph">
<p>假设我们的数据库包含以下实体：</p>
</div>
<div id="pc-filter-join-table-persistence-example" class="exampleblock">
<div class="title">示例333持久化和获取带有<code>@FilterJoinTable</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Client client = new Client()
.setId( 1L )
.setName( "John Doe" );

client.addAccount(
    new Account()
    .setId( 1L )
    .setType( AccountType.CREDIT )
    .setAmount( 5000d )
    .setRate( 1.25 / 100 )
);

client.addAccount(
    new Account()
    .setId( 2L )
    .setType( AccountType.DEBIT )
    .setAmount( 0d )
    .setRate( 1.05 / 100 )
);

client.addAccount(
    new Account()
    .setType( AccountType.DEBIT )
    .setId( 3L )
    .setAmount( 250d )
    .setRate( 1.05 / 100 )
);

entityManager.persist( client );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Client (name, id)
VALUES ('John Doe', 1)

INSERT INTO Account (amount, client_id, rate, account_type, id)
VALUES (5000.0, 1, 0.0125, 'CREDIT', 1)

INSERT INTO Account (amount, client_id, rate, account_type, id)
VALUES (0.0, 1, 0.0105, 'DEBIT', 2)

INSERT INTO Account (amount, client_id, rate, account_type, id)
VALUES (250.0, 1, 0.0105, 'DEBIT', 3)

INSERT INTO Client_Account (Client_id, order_id, accounts_id)
VALUES (1, 0, 1)

INSERT INTO Client_Account (Client_id, order_id, accounts_id)
VALUES (1, 0, 1)

INSERT INTO Client_Account (Client_id, order_id, accounts_id)
VALUES (1, 1, 2)

INSERT INTO Client_Account (Client_id, order_id, accounts_id)
VALUES (1, 2, 3)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>仅当在当前运行的Hibernate上启用了关联的过滤器时，才可以过滤集合<code>Session</code> 。</p>
</div>
<div id="pc-no-filter-join-table-collection-query-example" class="exampleblock">
<div class="title">示例334遍历与映射的集合<code>@FilterJoinTable</code>没有启用过滤器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Client client = entityManager.find( Client.class, 1L );

assertEquals( 3, client.getAccounts().size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    ca.Client_id as Client_i1_2_0_,
    ca.accounts_id as accounts2_2_0_,
    ca.order_id as order_id3_0_,
    a.id as id1_0_1_,
    a.amount as amount3_0_1_,
    a.rate as rate4_0_1_,
    a.account_type as account_5_0_1_
FROM
    Client_Account ca
INNER JOIN
    Account a
ON  ca.accounts_id=a.id
WHERE
    ca.Client_id = ?

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们启用过滤器并设置<code>maxOrderId</code>至<code>1</code>当获取<code>accounts</code>集合，Hibernate将应用<code>@FilterJoinTable</code>子句过滤条件，我们将得到<code>2</code><code>Account</code>实体， <code>order_id</code>的值<code>0</code>和<code>1</code> 。</p>
</div>
<div id="pc-filter-join-table-collection-query-example" class="exampleblock">
<div class="title">示例335遍历与映射的集合<code>@FilterJoinTable</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Client client = entityManager.find( Client.class, 1L );

entityManager
    .unwrap( Session.class )
    .enableFilter( "firstAccounts" )
    .setParameter( "maxOrderId", 1);

assertEquals( 2, client.getAccounts().size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    ca.Client_id as Client_i1_2_0_,
    ca.accounts_id as accounts2_2_0_,
    ca.order_id as order_id3_0_,
    a.id as id1_0_1_,
    a.amount as amount3_0_1_,
    a.rate as rate4_0_1_,
    a.account_type as account_5_0_1_
FROM
    Client_Account ca
INNER JOIN
    Account a
ON  ca.accounts_id=a.id
WHERE
    ca.order_id &lt;= ?
    AND ca.Client_id = ?

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-managed-state"><a class="anchor" href="#pc-managed-state"></a> 5.10。修改管理/持久状态</h3>
<div class="paragraph">
<p>处于托管/持久状态的实体可以由应用程序处理，并且刷新持久化上下文时，将自动检测并持久化任何更改。无需调用特定方法即可使您的修改持久化。</p>
</div>
<div id="pc-managed-state-jpa-example" class="exampleblock">
<div class="title">示例336使用JPA修改托管状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, personId );
person.setName("John Doe");
entityManager.flush();</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-managed-state-native-example" class="exampleblock">
<div class="title">示例337使用Hibernate API修改托管状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );
person.setName("John Doe");
session.flush();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，修改实体时，将在更新过程中设置除标识符以外的所有列。</p>
</div>
<div class="paragraph">
<p>因此，考虑到您有以下几点<code>Product</code>实体映射：</p>
</div>
<div id="pc-managed-state-update-mapping-example" class="exampleblock">
<div class="title">示例338 <code>Product</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
public static class Product {

	@Id
	private Long id;

	@Column
	private String name;

	@Column
	private String description;

	@Column(name = "price_cents")
	private Integer priceCents;

	@Column
	private Integer quantity;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果坚持以下内容<code>Product</code>实体：</p>
</div>
<div id="pc-managed-state-update-persist-example" class="exampleblock">
<div class="title">示例339坚持一个<code>Product</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Product book = new Product();
book.setId( 1L );
book.setName( "High-Performance Java Persistence" );
book.setDescription( "Get the most out of your persistence layer" );
book.setPriceCents( 29_99 );
book.setQuantity( 10_000 );

entityManager.persist( book );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您修改<code>Product</code>实体，Hibernate生成以下SQL UPDATE语句：</p>
</div>
<div id="pc-managed-state-update-example" class="exampleblock">
<div class="title">示例340修改<code>Product</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Product book = entityManager.find( Product.class, 1L );
	book.setPriceCents( 24_99 );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE
    Product
SET
    description = ?,
    name = ?,
    price_cents = ?,
    quantity = ?
WHERE
    id = ?

-- binding parameter [1] as [VARCHAR] - [Get the most out of your persistence layer]
-- binding parameter [2] as [VARCHAR] - [High-Performance Java Persistence]
-- binding parameter [3] as [INTEGER] - [2499]
-- binding parameter [4] as [INTEGER] - [10000]
-- binding parameter [5] as [BIGINT]  - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>包含所有列的默认UPDATE语句有两个优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它使您可以更好地从JDBC语句缓存中受益。</p>
</li>
<li>
<p>即使多个实体修改了不同的属性，它也允许您启用批量更新。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，在SQL UPDATE语句中包括所有列也有一个缺点。如果您有多个索引，即使您实际上并未修改所有列值，数据库也可能会冗余地更新这些索引。</p>
</div>
<div class="paragraph">
<p>要解决此问题，可以使用动态更新。</p>
</div>
<div class="sect3">
<h4 id="pc-managed-state-dynamic-update"><a class="anchor" href="#pc-managed-state-dynamic-update"></a> 5.10.1。动态更新</h4>
<div class="paragraph">
<p>要启用动态更新，您需要使用<code>@DynamicUpdate</code>注解：</p>
</div>
<div id="pc-managed-state-dynamic-update-mapping-example" class="exampleblock">
<div class="title">示例341 <code>Product</code>实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Product")
@DynamicUpdate
public static class Product {

	@Id
	private Long id;

	@Column
	private String name;

	@Column
	private String description;

	@Column(name = "price_cents")
	private Integer priceCents;

	@Column
	private Integer quantity;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，当重新运行先前的测试用例时，Hibernate生成以下SQL UPDATE语句：</p>
</div>
<div id="pc-managed-state-dynamic-update-example" class="exampleblock">
<div class="title">示例342修改<code>Product</code>具有动态更新的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE
    Product
SET
    price_cents = ?
WHERE
    id = ?

-- binding parameter [1] as [INTEGER] - [2499]
-- binding parameter [2] as [BIGINT]  - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过动态更新，您可以仅设置在关联实体中修改的列。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-refresh"><a class="anchor" href="#pc-refresh"></a> 5.11。刷新实体状态</h3>
<div class="paragraph">
<p>您可以随时重新加载实体实例及其集合。</p>
</div>
<div id="pc-refresh-jpa-example" class="exampleblock">
<div class="title">例子343。使用JPA刷新实体状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, personId );

entityManager.createQuery( "update Person set name = UPPER(name)" ).executeUpdate();

entityManager.refresh( person );
assertEquals("JOHN DOE", person.getName() );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-refresh-native-example" class="exampleblock">
<div class="title">示例344使用Hibernate API刷新实体状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );

session.doWork( connection -&gt; {
	try(Statement statement = connection.createStatement()) {
		statement.executeUpdate( "UPDATE Person SET name = UPPER(name)" );
	}
} );

session.refresh( person );
assertEquals("JOHN DOE", person.getName() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种有用的情况是，已知自读取数据以来数据库状态已更改。刷新允许将当前数据库状态提取到实体实例和持久性上下文中。</p>
</div>
<div class="paragraph">
<p>可能有用的另一种情况是，使用数据库触发器来初始化实体的某些属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除非您指定，否则仅刷新实体实例及其值类型集合<code>REFRESH</code>作为任何关联的层叠样式。但是，请注意，Hibernate可以通过其生成的属性概念自动处理此问题。请参阅对非标识符<a href="#mapping-generated">生成的属性</a>的讨论。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传统上，Hibernate允许刷新分离的实体。不幸的是，JPA禁止这种做法，并指定<code>IllegalArgumentException</code>应该扔掉。</p>
</div>
<div class="paragraph">
<p>因此，引导Hibernate时<code>SessionFactory</code>使用本机API，将保留旧式的分离实体刷新行为。另一方面，通过JPA引导Hibernate时<code>EntityManagerFactory</code>构建过程中，默认情况下不允许刷新分离的实体。</p>
</div>
<div class="paragraph">
<p>但是，可以通过以下方式覆盖此默认行为： <code>hibernate.allow_refresh_detached_entity</code>配置属性。如果将此属性显式设置为<code>true</code> ，那么即使使用JPA引导程序机制，也可以刷新分离的实体，因此绕过了JPA规范限制。</p>
</div>
<div class="paragraph">
<p>有关的更多信息<code>hibernate.allow_refresh_detached_entity</code>配置属性，也请查看“ <a href="#misc">配置”</a>部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="pc-refresh-gotchas"><a class="anchor" href="#pc-refresh-gotchas"></a> 5.11.1。刷新陷阱</h4>
<div class="paragraph">
<p>的<code>refresh</code>实体状态转换旨在根据关联数据库记录中当前包含的信息来覆盖实体属性。</p>
</div>
<div class="paragraph">
<p>但是，将刷新操作级联到任何临时实体时必须非常小心。</p>
</div>
<div class="paragraph">
<p>例如，考虑以下示例：</p>
</div>
<div id="pc-refresh-child-entity-jpa-example" class="exampleblock">
<div class="title">示例345刷新实体状态陷阱</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try {
	Person person = entityManager.find( Person.class, personId );

	Book book = new Book();
	book.setId( 100L );
	book.setTitle( "Hibernate User Guide" );
	book.setAuthor( person );
	person.getBooks().add( book );

	entityManager.refresh( person );
}
catch ( EntityNotFoundException expected ) {
	log.info( "Beware when cascading the refresh associations to transient entities!" );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上述示例中， <code>EntityNotFoundException</code>抛出是因为<code>Book</code>实体仍处于过渡状态。当刷新动作从<code>Person</code>实体，Hibernate将无法找到<code>Book</code>数据库中的实体。</p>
</div>
<div class="paragraph">
<p>因此，在将刷新操作与瞬态子实体对象混合使用时，应格外小心。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-detach"><a class="anchor" href="#pc-detach"></a> 5.12。处理分离的数据</h3>
<div class="paragraph">
<p>分离是在任何持久性上下文范围之外使用数据的过程。数据以多种方式分离。关闭持久性上下文后，与之关联的所有数据都将被分离。清除持久性上下文具有相同的效果。从持久性上下文中逐出特定实体会使它脱离。最后，序列化将使反序列化的表格分离（原始实例仍在管理中）。</p>
</div>
<div class="paragraph">
<p>分离的数据仍然可以操作，但是，持久性上下文将不再自动了解这些修改，并且应用程序将需要进行干预以使更改再次持久化。</p>
</div>
<div class="sect3">
<h4 id="pc-detach-reattach"><a class="anchor" href="#pc-detach-reattach"></a> 5.12.1。重新附加分离的数据</h4>
<div class="paragraph">
<p>重新连接是获取处于分离状态的传入实体实例，并将其与当前持久性上下文重新关联的过程。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA不支持重新附加分离的数据。这只能通过Hibernate获得<code>org.hibernate.Session</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="pc-detach-reattach-lock-example" class="exampleblock">
<div class="title">实施例346。使用以下方式重新附加分离的实体<code>lock</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );
//Clear the Session so the person entity becomes detached
session.clear();
person.setName( "Mr. John Doe" );

session.lock( person, LockMode.NONE );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-detach-reattach-saveOrUpdate-example" class="exampleblock">
<div class="title">示例347使用以下方式重新附加分离的实体<code>saveOrUpdate</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );
//Clear the Session so the person entity becomes detached
session.clear();
person.setName( "Mr. John Doe" );

session.saveOrUpdate( person );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>方法名称<code>update</code>这里有点误导。这并不意味着<code>SQL</code><code>UPDATE</code>立即执行。但是，这确实意味着<code>SQL</code><code>UPDATE</code>刷新持久性上下文时将执行此操作，因为Hibernate不知道要与之进行比较的先前状态。如果实体与<code>select-before-update</code> ，Hibernate将从数据库中获取当前状态，并查看是否需要更新。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果实体是分离的， <code>update</code>和<code>saveOrUpdate</code>操作完全相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="pc-merge"><a class="anchor" href="#pc-merge"></a> 5.12.2。合并分离的数据</h4>
<div class="paragraph">
<p>合并是获取处于分离状态的传入实体实例并将其数据复制到新的托管实例上的过程。</p>
</div>
<div class="paragraph">
<p>尽管其本身并不完全正确，但以下示例是对<code>merge</code>操作内部。</p>
</div>
<div id="pc-merge-visualize-example" class="exampleblock">
<div class="title">示例348。可视化合并</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public Person merge(Person detached) {
	Person newReference = session.byId( Person.class ).load( detached.getId() );
	newReference.setName( detached.getName() );
	return newReference;
}</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-merge-jpa-example" class="exampleblock">
<div class="title">示例349。将独立实体与JPA合并</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, personId );
//Clear the EntityManager so the person entity becomes detached
entityManager.clear();
person.setName( "Mr. John Doe" );

person = entityManager.merge( person );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-merge-native-example" class="exampleblock">
<div class="title">示例350使用Hibernate API合并独立实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.byId( Person.class ).load( personId );
//Clear the Session so the person entity becomes detached
session.clear();
person.setName( "Mr. John Doe" );

person = (Person) session.merge( person );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pc-merge-gotchas"><a class="anchor" href="#pc-merge-gotchas"></a>合并陷阱</h5>
<div class="paragraph">
<p>例如，Hibernate抛出<code>IllegalStateException</code>合并参考2个独立子实体的父实体时<code>child1</code>和<code>child2</code> （从不同的会话获得），以及<code>child1</code>和<code>child2</code>代表相同的持久性实体， <code>Child</code> 。</p>
</div>
<div class="paragraph">
<p>一个新的配置属性， <code>hibernate.event.merge.entity_copy_observer</code> ，控制合并时检测到同一持久性实体（“实体副本”）的多种表示形式时，Hibernate将如何响应。</p>
</div>
<div class="paragraph">
<p>可能的值为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">禁止（默认）</dt>
<dd>
<p>抛出<code>IllegalStateException</code>如果检测到实体副本</p>
</dd>
<dt class="hdlist1">允许</dt>
<dd>
<p>对检测到的每个实体副本执行合并操作</p>
</dd>
<dt class="hdlist1">日志</dt>
<dd>
<p>（仅提供用于测试）对检测到的每个实体副本执行合并操作，并记录有关实体副本的信息。此设置要求启用调试日志记录<code>org.hibernate.event.internal.EntityCopyAllowedLoggedObserver</code> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>另外，应用程序可以通过提供以下实现来自定义行为<code>org.hibernate.event.spi.EntityCopyObserver</code>和设置<code>hibernate.event.merge.entity_copy_observer</code>类名。当此属性设置为<code>allow</code>要么<code>log</code> ，Hibernate将在级联合并操作时合并检测到的每个实体副本。在合并每个实体副本的过程中，Hibernate将从每个实体副本到其关联的级联合并操作<code>cascade=CascadeType.MERGE</code>要么<code>CascadeType.ALL</code> 。合并另一个实体副本时，由于合并一个实体副本而导致的实体状态将被覆盖。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为级联顺序是不确定的，所以实体副本的合并顺序是不确定的。结果，如果实体副本中的属性值不一致，则最终的实体状态将不确定，并且除最后一个合并的实体外，所有实体副本中的数据都将丢失。因此， <strong>最后一位作家获胜</strong> 。</p>
</div>
<div class="paragraph">
<p>如果一个实体副本将合并操作级联为一个（或包含）新实体的关联，则该新实体将被合并（即持久存在，并且合并操作将根据其映射而级联为其关联），即使那样当Hibernate合并其关联具有不同值的不同表示形式时，相同的关联最终将被覆盖。</p>
</div>
<div class="paragraph">
<p>如果关联与<code>orphanRemoval = true</code> ，则不会删除新实体，因为如果孤立的实体是新实体，则orphanRemoval的语义不适用。</p>
</div>
<div class="paragraph">
<p>当同一持久性实体的表示对于一个集合具有不同的值时，存在一些已知的问题。有关更多详细信息，请参见<a href="https://hibernate.atlassian.net/browse/HHH-9239">HHH-9239</a>和<a href="https://hibernate.atlassian.net/browse/HHH-9240">HHH-9240</a> 。这些问题可能会导致数据丢失或损坏。</p>
</div>
<div class="paragraph">
<p>通过设置<code>hibernate.event.merge.entity_copy_observer</code>配置属性为<code>allow</code>要么<code>log</code> ，Hibernate将允许合并任何类型的实体的实体副本。</p>
</div>
<div class="paragraph">
<p>排除包含关键数据的特定实体类或关联的唯一方法是提供自定义实现<code>org.hibernate.event.spi.EntityCopyObserver</code>具有所需的行为和设置<code>hibernate.event.merge.entity_copy_observer</code>类名。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate提供有限的DEBUG日志记录功能，可以帮助确定找到其实体副本的实体类。通过设置<code>hibernate.event.merge.entity_copy_observer</code>至<code>log</code>并启用调试日志<code>org.hibernate.event.internal.EntityCopyAllowedLoggedObserver</code> ，则每次应用程序调用时都会记录以下内容<code>EntityManager.merge( entity )</code>要么<br>
<code>Session.merge( entity )</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>检测到的相同持久性实体的多种表示形式的次数（按实体名称汇总）；</p>
</li>
<li>
<p>实体名称和ID的详细信息，包括在要合并的每个表示形式上调用toString（）的输出以及合并结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>应该检查日志以确定是否检测到包含关键数据的实体的多种表示形式。如果是这样，则应修改该应用程序，以便只有一个表示形式，并自定义实现<code>org.hibernate.event.spi.EntityCopyObserver</code>应该提供以禁止为具有关键数据的实体提供实体副本。</p>
</div>
<div class="paragraph">
<p>建议使用乐观锁定来检测不同表示是否来自同一持久性实体的不同版本。如果它们不是同一版本，则Hibernate将抛出JPA <code>OptimisticLockException</code>或本地人<code>StaleObjectStateException</code>取决于您的引导策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-contains"><a class="anchor" href="#pc-contains"></a> 5.13。检查持久状态</h3>
<div class="paragraph">
<p>应用程序可以验证与持久性上下文有关的实体和集合的状态。</p>
</div>
<div id="pc-contains-jpa-example" class="exampleblock">
<div class="title">示例351使用JPA验证托管状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">boolean contained = entityManager.contains( person );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-contains-native-example" class="exampleblock">
<div class="title">示例352使用Hibernate API验证托管状态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">boolean contained = session.contains( person );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-verify-lazy-jpa-example" class="exampleblock">
<div class="title">示例353使用JPA验证懒惰</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">PersistenceUnitUtil persistenceUnitUtil = entityManager.getEntityManagerFactory().getPersistenceUnitUtil();

boolean personInitialized = persistenceUnitUtil.isLoaded( person );

boolean personBooksInitialized = persistenceUnitUtil.isLoaded( person.getBooks() );

boolean personNameInitialized = persistenceUnitUtil.isLoaded( person, "name" );</code></pre>
</div>
</div>
</div>
</div>
<div id="pc-verify-lazy-native-example" class="exampleblock">
<div class="title">示例354使用Hibernate API验证惰性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">boolean personInitialized = Hibernate.isInitialized( person );

boolean personBooksInitialized = Hibernate.isInitialized( person.getBooks() );

boolean personNameInitialized = Hibernate.isPropertyInitialized( person, "name" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在JPA中，可以使用以下方法来检查懒惰<code>javax.persistence.PersistenceUtil</code>模式（建议尽可能使用）。</p>
</div>
<div id="pc-verify-lazy-jpa-alternative-example" class="exampleblock">
<div class="title">示例355JPA的替代方法是验证懒惰</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">PersistenceUtil persistenceUnitUtil = Persistence.getPersistenceUtil();

boolean personInitialized = persistenceUnitUtil.isLoaded( person );

boolean personBooksInitialized = persistenceUnitUtil.isLoaded( person.getBooks() );

boolean personNameInitialized = persistenceUnitUtil.isLoaded( person, "name" );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_evicting_entities"><a class="anchor" href="#_evicting_entities"></a> 5.14。驱逐实体</h3>
<div class="paragraph">
<p>当。。。的时候<code>flush()</code>方法被调用时，实体的状态与数据库同步。如果您不希望这种同步发生，或者您正在处理大量对象并且需要有效地管理内存，则<code>evict()</code>方法可用于从一级缓存中删除对象及其集合。</p>
</div>
<div id="caching-management-jpa-detach-example" class="exampleblock">
<div class="title">示例356从实体中分离实体<code>EntityManager</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">for(Person person : entityManager.createQuery("select p from Person p", Person.class)
		.getResultList()) {
	dtos.add(toDTO(person));
	entityManager.detach( person );
}</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-management-native-evict-example" class="exampleblock">
<div class="title">示例357从Hibernate中逐出实体<code>Session</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap( Session.class );
for(Person person : (List&lt;Person&gt;) session.createQuery("select p from Person p").list()) {
	dtos.add(toDTO(person));
	session.evict( person );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要从当前持久性上下文中分离所有实体， <code>EntityManager</code>和冬眠<code>Session</code>定义一个<code>clear()</code>方法。</p>
</div>
<div id="caching-management-clear-example" class="exampleblock">
<div class="title">示例358。清除持久性上下文</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager.clear();

session.clear();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要验证当前是否将实体实例附加到正在运行的持久性上下文，两个<code>EntityManager</code>和冬眠<code>Session</code>定义一个<code>contains(Object entity)</code>方法。</p>
</div>
<div id="caching-management-contains-example" class="exampleblock">
<div class="title">示例359。验证实体是否包含在持久性上下文中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager.contains( person );

session.contains( person );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-cascade"><a class="anchor" href="#pc-cascade"></a> 5.15。级联实体状态转换</h3>
<div class="paragraph">
<p>JPA允许您将状态转换从父实体传播到子实体。为此，JPA <code>javax.persistence.CascadeType</code>定义了各种层叠类型：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ALL</code></dt>
<dd>
<p>级联所有实体状态转换</p>
</dd>
<dt class="hdlist1"><code>PERSIST</code></dt>
<dd>
<p>级联实体持久操作。</p>
</dd>
<dt class="hdlist1"><code>MERGE</code></dt>
<dd>
<p>级联实体合并操作。</p>
</dd>
<dt class="hdlist1"><code>REMOVE</code></dt>
<dd>
<p>级联实体删除操作。</p>
</dd>
<dt class="hdlist1"><code>REFRESH</code></dt>
<dd>
<p>级联实体刷新操作。</p>
</dd>
<dt class="hdlist1"><code>DETACH</code></dt>
<dd>
<p>级联实体分离操作。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此外， <code>CascadeType.ALL</code>将传播由Hibernate定义的任何特定于Hibernate的操作<code>org.hibernate.annotations.CascadeType</code>枚举：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SAVE_UPDATE</code></dt>
<dd>
<p>级联实体saveOrUpdate操作。</p>
</dd>
<dt class="hdlist1"><code>REPLICATE</code></dt>
<dd>
<p>级联实体复制操作。</p>
</dd>
<dt class="hdlist1"><code>LOCK</code></dt>
<dd>
<p>级联实体锁定操作。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下示例将使用以下实体说明上述某些层叠操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Person {

    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL)
    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

    //Getters and setters are omitted for brevity

    public void addPhone(Phone phone) {
        this.phones.add( phone );
        phone.setOwner( this );
    }
}


@Entity
public class Phone {

    @Id
    private Long id;

    @Column(name = "`number`")
    private String number;

    @ManyToOne(fetch = FetchType.LAZY)
    private Person owner;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-persist"><a class="anchor" href="#pc-cascade-persist"></a> 5.15.1。<code>CascadeType.PERSIST</code></h4>
<div class="paragraph">
<p>的<code>CascadeType.PERSIST</code>允许我们与父实体一起保留子实体。</p>
</div>
<div id="pc-cascade-persist-example" class="exampleblock">
<div class="title">示例360 <code>CascadeType.PERSIST</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setName( "John Doe" );

Phone phone = new Phone();
phone.setId( 1L );
phone.setNumber( "123-456-7890" );

person.addPhone( phone );

entityManager.persist( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person ( name, id )
VALUES ( 'John Doe', 1 )

INSERT INTO Phone ( `number`, person_id, id )
VALUE ( '123-456-7890', 1, 1 )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使只是<code>Person</code>父实体已被持久化，Hibernate已设法将持久化操作与相关联的级联<code>Phone</code>子实体也是如此。</p>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-merge"><a class="anchor" href="#pc-cascade-merge"></a> 5.15.2。<code>CascadeType.MERGE</code></h4>
<div class="paragraph">
<p>的<code>CascadeType.MERGE</code>允许我们将子实体与父实体合并。</p>
</div>
<div id="pc-cascade-merge-example" class="exampleblock">
<div class="title">示例361。 <code>CascadeType.MERGE</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Phone phone = entityManager.find( Phone.class, 1L );
Person person = phone.getOwner();

person.setName( "John Doe Jr." );
phone.setNumber( "987-654-3210" );

entityManager.clear();

entityManager.merge( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    p.id as id1_0_1_,
    p.name as name2_0_1_,
    ph.owner_id as owner_id3_1_3_,
    ph.id as id1_1_3_,
    ph.id as id1_1_0_,
    ph."number" as number2_1_0_,
    ph.owner_id as owner_id3_1_0_
FROM
    Person p
LEFT OUTER JOIN
    Phone ph
        on p.id=ph.owner_id
WHERE
    p.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在合并期间，实体的当前状态被复制到刚从数据库中获取的实体版本上。这就是为什么Hibernate执行SELECT语句同时获取两个<code>Person</code>实体及其子代。</p>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-remove"><a class="anchor" href="#pc-cascade-remove"></a> 5.15.3。<code>CascadeType.REMOVE</code></h4>
<div class="paragraph">
<p>的<code>CascadeType.REMOVE</code>允许我们与父实体一起删除子实体。传统上，Hibernate将此操作称为删除，这就是为什么<code>org.hibernate.annotations.CascadeType</code>提供一个<code>DELETE</code>级联选项。然而， <code>CascadeType.REMOVE</code>和<code>org.hibernate.annotations.CascadeType.DELETE</code>都是一样的</p>
</div>
<div id="pc-cascade-remove-example" class="exampleblock">
<div class="title">示例362 <code>CascadeType.REMOVE</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );

entityManager.remove( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">DELETE FROM Phone WHERE id = 1

DELETE FROM Person WHERE id = 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-detach"><a class="anchor" href="#pc-cascade-detach"></a> 5.15.4。<code>CascadeType.DETACH</code></h4>
<div class="paragraph">
<p><code>CascadeType.DETACH</code>用于将分离操作从父实体传播到子实体。</p>
</div>
<div id="pc-cascade-detach-example" class="exampleblock">
<div class="title">示例363 <code>CascadeType.DETACH</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
assertEquals( 1, person.getPhones().size() );
Phone phone = person.getPhones().get( 0 );

assertTrue( entityManager.contains( person ));
assertTrue( entityManager.contains( phone ));

entityManager.detach( person );

assertFalse( entityManager.contains( person ));
assertFalse( entityManager.contains( phone ));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-lock"><a class="anchor" href="#pc-cascade-lock"></a> 5.15.5。<code>CascadeType.LOCK</code></h4>
<div class="paragraph">
<p>虽然不直观<code>CascadeType.LOCK</code>不会将锁定请求从父实体传播到其子实体。这种用例需要使用<code>PessimisticLockScope.EXTENDED</code>的价值<code>javax.persistence.lock.scope</code>属性。</p>
</div>
<div class="paragraph">
<p>然而， <code>CascadeType.LOCK</code>允许我们将父实体及其子代重新附加到当前正在运行的持久性上下文。</p>
</div>
<div id="pc-cascade-lock-example" class="exampleblock">
<div class="title">示例364 <code>CascadeType.LOCK</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
assertEquals( 1, person.getPhones().size() );
Phone phone = person.getPhones().get( 0 );

assertTrue( entityManager.contains( person ) );
assertTrue( entityManager.contains( phone ) );

entityManager.detach( person );

assertFalse( entityManager.contains( person ) );
assertFalse( entityManager.contains( phone ) );

entityManager.unwrap( Session.class )
		.buildLockRequest( new LockOptions( LockMode.NONE ) )
		.lock( person );

assertTrue( entityManager.contains( person ) );
assertTrue( entityManager.contains( phone ) );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-refresh"><a class="anchor" href="#pc-cascade-refresh"></a> 5.15.6。<code>CascadeType.REFRESH</code></h4>
<div class="paragraph">
<p>的<code>CascadeType.REFRESH</code>用于将刷新操作从父实体传播到子实体。刷新操作将丢弃当前实体状态，并将使用从数据库加载的状态来覆盖它。</p>
</div>
<div id="pc-cascade-refresh-example" class="exampleblock">
<div class="title">示例365 <code>CascadeType.REFRESH</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
Phone phone = person.getPhones().get( 0 );

person.setName( "John Doe Jr." );
phone.setNumber( "987-654-3210" );

entityManager.refresh( person );

assertEquals( "John Doe", person.getName() );
assertEquals( "123-456-7890", phone.getNumber() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    p.id as id1_0_1_,
    p.name as name2_0_1_,
    ph.owner_id as owner_id3_1_3_,
    ph.id as id1_1_3_,
    ph.id as id1_1_0_,
    ph."number" as number2_1_0_,
    ph.owner_id as owner_id3_1_0_
FROM
    Person p
LEFT OUTER JOIN
    Phone ph
        ON p.id=ph.owner_id
WHERE
    p.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上述示例中，您可以看到<code>Person</code>和<code>Phone</code>即使我们仅在父实体上调用此操作，实体也会刷新。</p>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-replicate"><a class="anchor" href="#pc-cascade-replicate"></a> 5.15.7。<code>CascadeType.REPLICATE</code></h4>
<div class="paragraph">
<p>的<code>CascadeType.REPLICATE</code>是要复制父实体和子实体。复制操作使您可以同步来自不同数据源的实体。</p>
</div>
<div id="pc-cascade-replicate-example" class="exampleblock">
<div class="title">范例366。 <code>CascadeType.REPLICATE</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setName( "John Doe Sr." );

Phone phone = new Phone();
phone.setId( 1L );
phone.setNumber( "(01) 123-456-7890" );
person.addPhone( phone );

entityManager.unwrap( Session.class ).replicate( person, ReplicationMode.OVERWRITE );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    id
FROM
    Person
WHERE
    id = 1

SELECT
    id
FROM
    Phone
WHERE
    id = 1

UPDATE
    Person
SET
    name = 'John Doe Sr.'
WHERE
    id = 1

UPDATE
    Phone
SET
    "number" = '(01) 123-456-7890',
    owner_id = 1
WHERE
    id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如所生成的SQL语句所示， <code>Person</code>和<code>Phone</code>实体被复制到基础数据库行。</p>
</div>
</div>
<div class="sect3">
<h4 id="pc-cascade-on-delete"><a class="anchor" href="#pc-cascade-on-delete"></a> 5.15.8。 <code>@OnDelete</code>级联</h4>
<div class="paragraph">
<p>当先前的层叠类型传播实体状态转换时， <code>@OnDelete</code>级联是DDL级别的FK功能，无论何时删除父行，都可以删除子记录。</p>
</div>
<div class="paragraph">
<p>因此，当注释<code>@ManyToOne</code>与...相关<code>@OnDelete( action = OnDeleteAction.CASCADE )</code> ，自动模式生成器会将ON DELETE CASCADE SQL指令应用于外键声明，如以下示例所示。</p>
</div>
<div id="pc-cascade-on-delete-mapping-example" class="exampleblock">
<div class="title">示例367 <code>@OnDelete</code><code>@ManyToOne</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	@Column(name = "`number`")
	private String number;

	@ManyToOne(fetch = FetchType.LAZY)
	@OnDelete( action = OnDeleteAction.CASCADE )
	private Person owner;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Person (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

create table Phone (
    id bigint not null,
    "number" varchar(255),
    owner_id bigint,
    primary key (id)
)

alter table Phone
    add constraint FK82m836qc1ss2niru7eogfndhl
    foreign key (owner_id)
    references Person
    on delete cascade</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，您只需删除<code>Person</code>实体，以及相关联<code>Phone</code>实体将通过外键级联自动删除。</p>
</div>
<div id="pc-cascade-on-delete-example" class="exampleblock">
<div class="title">示例368。 <code>@OnDelete</code><code>@ManyToOne</code>删除范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
entityManager.remove( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">delete from Person where id = ?

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@OnDelete</code>注释也可以放在集合上，如以下示例所示。</p>
</div>
<div id="pc-cascade-on-delete-collection-mapping-example" class="exampleblock">
<div class="title">示例369 <code>@OnDelete</code><code>@OneToMany</code>映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String name;

	@OneToMany(mappedBy = "owner", cascade = CascadeType.ALL)
	@OnDelete(action = OnDeleteAction.CASCADE)
	private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	@Column(name = "`number`")
	private String number;

	@ManyToOne(fetch = FetchType.LAZY)
	private Person owner;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当删除<code>Person</code>实体，所有关联的<code>Phone</code>子实体通过外键级联删除，即使<code>@OneToMany</code>集合正在使用<code>CascadeType.ALL</code>属性。</p>
</div>
<div id="pc-cascade-on-delete-collection-example" class="exampleblock">
<div class="title">示例370 <code>@OnDelete</code><code>@ManyToOne</code>删除范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
entityManager.remove( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">delete from Person where id = ?

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>没有<code>@OnDelete</code>注释， <code>@OneToMany</code>协会依靠<code>cascade</code>属性以传播<code>remove</code>实体状态从父实体到子实体的过渡。但是，当<code>@OnDelete</code>注释到位，Hibernate阻止子实体<code>DELETE</code>刷新持久化上下文时从执行语句。</p>
</div>
<div class="paragraph">
<p>这样，只有父实体被删除，所有关联的子记录都被数据库引擎删除，而不是通过<code>DELETE</code>陈述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pc-exception-handling"><a class="anchor" href="#pc-exception-handling"></a> 5.16。异常处理</h3>
<div class="paragraph">
<p>如果JPA <code>EntityManager</code>或特定于Hibernate的<code>Session</code>引发异常，包括任何JDBC <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/SQLException.html"><code>SQLException</code></a> ，您必须立即回滚数据库事务并关闭当前<code>EntityManager</code>要么<code>Session</code> 。</p>
</div>
<div class="paragraph">
<p>JPA的某些方法<code>EntityManager</code>或Hibernate<code>Session</code>不会使持久性上下文保持一致状态。根据经验，Hibernate抛出的异常不能被视为可恢复的。通过调用以下命令确保会话关闭<code>close()</code>最终块中的方法。</p>
</div>
<div class="paragraph">
<p>回滚数据库事务不会使您的业务对象回到事务开始时的状态。这意味着数据库状态和业务对象将不同步。通常，这不是问题，因为异常是不可恢复的，并且无论如何您都必须在回滚后重新开始。</p>
</div>
<div class="paragraph">
<p>JPA <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceException.html"><code>PersistenceException</code></a>或者<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/HibernateException.html"><code>HibernateException</code></a>包装可能在Hibernate持久层中发生的大多数错误。</p>
</div>
<div class="paragraph">
<p>这俩<code>PersistenceException</code>和<code>HibernateException</code>是运行时异常，因为在我们看来，我们不应强迫应用程序开发人员在底层捕获不可恢复的异常。在大多数系统中，未经检查和致命的异常是在方法调用堆栈的前几个帧之一（即在更高层中）中处理的，或者向应用程序用户显示错误消息，或者采取了其他适当的措施。请注意，Hibernate可能还会引发其他未经检查的异常，这些异常不是<code>HibernateException</code> 。这些也不可恢复，应采取适当的措施。</p>
</div>
<div class="paragraph">
<p>Hibernate包装JDBC <code>SQLException</code>与数据库互动时抛出的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/JDBCException.html"><code>JDBCException</code></a> 。实际上，Hibernate会尝试将异常转换为以下更有意义的子类<code>JDBCException</code> 。底层<code>SQLException</code>随时可以通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/JDBCException.html#getSQLException--"><code>JDBCException.getSQLException()</code></a> 。Hibernate转换<code>SQLException</code>使用适当的JDBCException子类<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/exception/spi/SQLExceptionConverter.html"><code>SQLExceptionConverter</code></a>附加到当前<code>SessionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>SQLExceptionConverter</code>由配置的Hibernate定义<code>Dialect</code>通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html#buildSQLExceptionConversionDelegate--"><code>buildSQLExceptionConversionDelegate</code></a>被几个特定于数据库的方法覆盖<code>Dialects</code> 。</p>
</div>
<div class="paragraph">
<p>但是，也可以插入自定义实现。见<a href="#configurations-exception-handling"><code>hibernate.jdbc.sql_exception_converter</code></a>配置属性以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>标准<code>JDBCException</code>子类型为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ConstraintViolationException</dt>
<dd>
<p>表示某种形式的完整性约束违规。</p>
</dd>
<dt class="hdlist1">DataException</dt>
<dd>
<p>表示针对给定数据对有效SQL语句进行评估会导致某些非法操作，类型不匹配，截断或基数不正确。</p>
</dd>
<dt class="hdlist1">GenericJDBCException</dt>
<dd>
<p>不属于任何其他类别的一般性例外。</p>
</dd>
<dt class="hdlist1">JDBCConnectionException</dt>
<dd>
<p>表示基础JDBC通信错误。</p>
</dd>
<dt class="hdlist1">LockAcquisitionException</dt>
<dd>
<p>表示获取执行请求的操作所需的锁定级别的错误。</p>
</dd>
<dt class="hdlist1">LockTimeoutException</dt>
<dd>
<p>表示锁获取请求已超时。</p>
</dd>
<dt class="hdlist1">PessimisticLockException</dt>
<dd>
<p>表示锁获取请求失败。</p>
</dd>
<dt class="hdlist1">QueryTimeoutException</dt>
<dd>
<p>指示当前正在执行的查询已超时。</p>
</dd>
<dt class="hdlist1">SQLGrammarException</dt>
<dd>
<p>表示发出的SQL的语法或语法问题。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Hibernate 5.2开始，Hibernate <code>Session</code>扩展JPA <code>EntityManager</code> 。因此，当<code>SessionFactory</code>是通过Hibernate的本机引导程序构建的， <code>HibernateException</code>要么<code>SQLException</code>可以包装在JPA中<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceException.html"><code>PersistenceException</code></a>当被扔<code>Session</code>实现的方法<code>EntityManager</code>方法（例如<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#merge-java.lang.Object-">Session.merge（Object object）</a> ， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#flush--">Session.flush（）</a> ）。</p>
</div>
<div class="paragraph">
<p>如果你的<code>SessionFactory</code>是通过Hibernate的本机引导程序构建的，并且您不希望将Hibernate异常包装在JPA中<code>PersistenceException</code> ，您需要设置<code>hibernate.native_exception_handling_51_compliance</code>配置属性为<code>true</code> 。见<a href="#configurations-exception-handling"><code>hibernate.native_exception_handling_51_compliance</code></a>配置属性以获取更多详细信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="flushing"><a class="anchor" href="#flushing"></a> 6。冲洗</h2>
<div class="sectionbody">
<div class="paragraph">
<p>刷新是将持久性上下文的状态与基础数据库同步的过程。的<code>EntityManager</code>和冬眠<code>Session</code>公开一组方法，应用程序开发人员可以通过这些方法来更改实体的持久状态。</p>
</div>
<div class="paragraph">
<p>持久性上下文充当事务后写式高速缓存，对任何实体状态更改进行排队。像任何后写式高速缓存一样，更改首先会在内存中应用，并在刷新期间与数据库同步。刷新操作会获取每个实体状态更改，并将其转换为<code>INSERT</code> ， <code>UPDATE</code>要么<code>DELETE</code>声明。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于DML语句组合在一起，因此Hibernate可以透明地应用批处理。有关更多信息，请参见“ <a href="#batch">批处理”一章</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>冲洗策略由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#getFlushMode--"><code>flushMode</code></a>当前运行的Hibernate状态<code>Session</code> 。尽管JPA仅定义了两种冲洗策略（ <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/FlushModeType.html#AUTO"><code>AUTO</code></a>和<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/FlushModeType.html#COMMIT"><code>COMMIT</code></a> ），Hibernate的刷新类型范围更广：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">总是</dt>
<dd>
<p>冲洗<code>Session</code>在每次查询之前。</p>
</dd>
<dt class="hdlist1">汽车</dt>
<dd>
<p>这是默认模式，它将刷新<code>Session</code>仅在必要时。</p>
</dd>
<dt class="hdlist1">承诺</dt>
<dd>
<p>的<code>Session</code>尝试将冲洗延迟到当前<code>Transaction</code>已提交，尽管它也可能过早刷新。</p>
</dd>
<dt class="hdlist1">手册</dt>
<dd>
<p>的<code>Session</code>刷新被委托给必须调用的应用程序<code>Session.flush()</code>显式地应用持久化上下文更改。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="flushing-auto"><a class="anchor" href="#flushing-auto"></a> 6.1。 <code>AUTO</code>齐平</h3>
<div class="paragraph">
<p>默认情况下，Hibernate使用<code>AUTO</code>刷新模式，在以下情况下触发刷新：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在提交之前<code>Transaction</code></p>
</li>
<li>
<p>在执行与排队的实体操作重叠的JPQL / HQL查询之前</p>
</li>
<li>
<p>在执行任何没有注册同步的本机SQL查询之前</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_code_auto_code_flush_on_commit"><a class="anchor" href="#_code_auto_code_flush_on_commit"></a> 6.1.1。 <code>AUTO</code>提交时刷新</h4>
<div class="paragraph">
<p>在以下示例中，实体被持久保存，然后事务被提交。</p>
</div>
<div id="flushing-auto-flush-commit-example" class="exampleblock">
<div class="title">示例371提交时自动刷新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager = entityManagerFactory().createEntityManager();
txn = entityManager.getTransaction();
txn.begin();

Person person = new Person( "John Doe" );
entityManager.persist( person );
log.info( "Entity is in persisted state" );

txn.commit();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">--INFO: Entity is in persisted state
INSERT INTO Person (name, id) VALUES ('John Doe', 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate在插入实体之前记录消息，因为刷新仅在事务提交期间发生。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这对于<code>SEQUENCE</code>和<code>TABLE</code>标识符生成器。的<code>IDENTITY</code>生成器必须在调用后立即执行插入<code>persist()</code> 。有关更多详细信息，请参见<a href="#identifiers"><em>标识符生成</em></a>器中有关生成器的讨论。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_code_auto_code_flush_on_jpql_hql_query"><a class="anchor" href="#_code_auto_code_flush_on_jpql_hql_query"></a> 6.1.2。 <code>AUTO</code>刷新JPQL / HQL查询</h4>
<div class="paragraph">
<p>执行实体查询时，也可能触发刷新。</p>
</div>
<div id="flushing-auto-flush-jpql-example" class="exampleblock">
<div class="title">示例372在JPQL / HQL上自动冲洗</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person( "John Doe" );
entityManager.persist( person );
entityManager.createQuery( "select p from Advertisement p" ).getResultList();
entityManager.createQuery( "select p from Person p" ).getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT a.id AS id1_0_ ,
       a.title AS title2_0_
FROM   Advertisement a

INSERT INTO Person (name, id) VALUES ('John Doe', 1)

SELECT p.id AS id1_1_ ,
       p.name AS name2_1_
FROM   Person p</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>之所以<code>Advertisement</code>实体查询没有触发刷新是因为<code>Advertisement</code>和<code>Person</code>表格：</p>
</div>
<div id="flushing-auto-flush-jpql-entity-example" class="exampleblock">
<div class="title">示例373JPQL / HQL实体上的自动刷新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	//Getters and setters are omitted for brevity

}

@Entity(name = "Advertisement")
public static class Advertisement {

	@Id
	@GeneratedValue
	private Long id;

	private String title;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询一个<code>Person</code>实体，则在执行实体查询之前触发刷新。</p>
</div>
<div id="flushing-auto-flush-jpql-overlap-example" class="exampleblock">
<div class="title">示例374在JPQL / HQL上自动冲洗</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person( "John Doe" );
entityManager.persist( person );
entityManager.createQuery( "select p from Person p" ).getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person (name, id) VALUES ('John Doe', 1)

SELECT p.id AS id1_1_ ,
       p.name AS name2_1_
FROM   Person p</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，刷新是由JPQL查询触发的，因为待处理实体持久执行的操作与正在执行的查询重叠。</p>
</div>
</div>
<div class="sect3">
<h4 id="_code_auto_code_flush_on_native_sql_query"><a class="anchor" href="#_code_auto_code_flush_on_native_sql_query"></a> 6.1.3。 <code>AUTO</code>在本机SQL查询上刷新</h4>
<div class="paragraph">
<p>执行本机SQL查询时，使用<code>EntityManager</code> API。</p>
</div>
<div id="flushing-auto-flush-sql-example" class="exampleblock">
<div class="title">示例375使用本机SQL自动刷新<code>EntityManager</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertTrue(((Number) entityManager
		.createNativeQuery( "select count(*) from Person")
		.getSingleResult()).intValue() == 0 );

Person person = new Person( "John Doe" );
entityManager.persist( person );

assertTrue(((Number) entityManager
		.createNativeQuery( "select count(*) from Person")
		.getSingleResult()).intValue() == 1 );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您是在本地启动Hibernate的，而不是通过JPA启动的，默认情况下， <code>Session</code>执行本地查询时，API将自动触发刷新。</p>
</div>
<div id="flushing-auto-flush-sql-native-example" class="exampleblock">
<div class="title">示例376。使用本机SQL自动刷新<code>Session</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertTrue(((Number) session
		.createNativeQuery( "select count(*) from Person")
		.getSingleResult()).intValue() == 0 );

Person person = new Person( "John Doe" );
session.persist( person );

assertTrue(((Number) session
		.createNativeQuery( "select count(*) from Person")
		.uniqueResult()).intValue() == 0 );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>冲洗<code>Session</code> ，查询必须使用同步：</p>
</div>
<div id="flushing-auto-flush-sql-synchronization-example" class="exampleblock">
<div class="title">示例377。使用本机SQL自动刷新<code>Session</code>同步化</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertTrue(((Number) entityManager
		.createNativeQuery( "select count(*) from Person")
		.getSingleResult()).intValue() == 0 );

Person person = new Person( "John Doe" );
entityManager.persist( person );
Session session = entityManager.unwrap( Session.class );

assertTrue(((Number) session
		.createNativeQuery( "select count(*) from Person")
		.addSynchronizedEntityClass( Person.class )
		.uniqueResult()).intValue() == 1 );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flushing-commit"><a class="anchor" href="#flushing-commit"></a> 6.2。 <code>COMMIT</code>齐平</h3>
<div class="paragraph">
<p>JPA还定义了COMMIT刷新模式，其描述如下：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>如果<code>FlushModeType.COMMIT</code>设置为时，未指定在持久性上下文中对实体进行的更新对查询的影响。</p>
</div>
</blockquote>
<div class="attribution">— JPA 2.1规范的第3.10.8节</div>
</div>
<div class="paragraph">
<p>执行JPQL查询时，仅在提交当前正在运行的事务时才刷新持久性上下文。</p>
</div>
<div id="flushing-commit-flush-jpql-example" class="exampleblock">
<div class="title">示例378 <code>COMMIT</code>在JPQL上冲洗</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person("John Doe");
entityManager.persist(person);

entityManager.createQuery("select p from Advertisement p")
    .setFlushMode( FlushModeType.COMMIT)
    .getResultList();

entityManager.createQuery("select p from Person p")
    .setFlushMode( FlushModeType.COMMIT)
    .getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT a.id AS id1_0_ ,
       a.title AS title2_0_
FROM   Advertisement a

SELECT p.id AS id1_1_ ,
       p.name AS name2_1_
FROM   Person p

INSERT INTO Person (name, id) VALUES ('John Doe', 1)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于JPA并未对延迟刷新施加严格的规则，因此在执行本机SQL查询时，将刷新持久性上下文。</p>
</div>
<div id="flushing-commit-flush-sql-example" class="exampleblock">
<div class="title">示例379 <code>COMMIT</code>在SQL上刷新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person("John Doe");
entityManager.persist(person);

assertTrue(((Number) entityManager
    .createNativeQuery("select count(*) from Person")
    .getSingleResult()).intValue() == 1);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person (name, id) VALUES ('John Doe', 1)

SELECT COUNT(*) FROM Person</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flushing-always"><a class="anchor" href="#flushing-always"></a> 6.3。 <code>ALWAYS</code>齐平</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>ALWAYS</code>仅适用于本机<code>Session</code> API。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>ALWAYS</code>刷新模式会触发持久性上下文刷新，即使在针对<code>Session</code> API。</p>
</div>
<div id="flushing-always-flush-sql-example" class="exampleblock">
<div class="title">示例380 <code>COMMIT</code>在SQL上刷新</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person("John Doe");
entityManager.persist(person);

Session session = entityManager.unwrap( Session.class);
assertTrue(((Number) session
        .createNativeQuery("select count(*) from Person")
        .setFlushMode( FlushMode.ALWAYS)
        .uniqueResult()).intValue() == 1);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person (name, id) VALUES ('John Doe', 1)

SELECT COUNT(*) FROM Person</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flushing-manual"><a class="anchor" href="#flushing-manual"></a> 6.4。 <code>MANUAL</code>齐平</h3>
<div class="paragraph">
<p>这俩<code>EntityManager</code>和冬眠<code>Session</code>定义一个<code>flush()</code>调用时触发手动刷新的方法。Hibernate还提供了一个<code>MANUAL</code>刷新模式，因此持久性上下文只能手动刷新。</p>
</div>
<div id="flushing-manual-flush-example" class="exampleblock">
<div class="title">示例381 <code>MANUAL</code>潮红</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person("John Doe");
entityManager.persist(person);

Session session = entityManager.unwrap( Session.class);
session.setHibernateFlushMode( FlushMode.MANUAL );

assertTrue(((Number) entityManager
    .createQuery("select count(id) from Person")
    .getSingleResult()).intValue() == 0);

assertTrue(((Number) session
    .createNativeQuery("select count(*) from Person")
    .uniqueResult()).intValue() == 0);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT COUNT(p.id) AS col_0_0_
FROM   Person p

SELECT COUNT(*)
FROM   Person</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>INSERT</code>由于没有持久性上下文，因此没有执行该语句，因为没有手动<code>flush()</code>呼叫。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>MANUAL</code>使用多请求逻辑事务时，刷新模式很有用，并且只有最后一个请求才应刷新持久性上下文。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="flushing-order"><a class="anchor" href="#flushing-order"></a> 6.5。冲洗操作顺序</h3>
<div class="paragraph">
<p>从数据库的角度来看，可以使用<code>INSERT</code> ， <code>UPDATE</code>或一个<code>DELETE</code>声明。由于实体状态更改会自动转换为SQL语句，因此重要的是要知道哪些实体操作与给定的SQL语句相关联。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>INSERT</code></dt>
<dd>
<p>的<code>INSERT</code>语句是由<code>EntityInsertAction</code>要么<code>EntityIdentityInsertAction</code> 。这些动作是由<code>persist</code>明确地或通过级联<code>PersistEvent</code>从父实体到子实体。</p>
</dd>
<dt class="hdlist1"><code>DELETE</code></dt>
<dd>
<p>的<code>DELETE</code>语句是由<code>EntityDeleteAction</code>要么<code>OrphanRemovalAction</code> 。</p>
</dd>
<dt class="hdlist1"><code>UPDATE</code></dt>
<dd>
<p>的<code>UPDATE</code>语句由生成<code>EntityUpdateAction</code>在刷新期间，如果管理实体已标记为已修改。脏检查机制负责确定自从首次加载管理实体以来是否对其进行了修改。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Hibernate不会按照其关联的实体状态操作的顺序执行SQL语句。</p>
</div>
<div class="paragraph">
<p>为了直观地了解其工作原理，请考虑以下示例：</p>
</div>
<div id="flushing-order-example" class="exampleblock">
<div class="title">示例382冲洗操作顺序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L);
entityManager.remove(person);

Person newPerson = new Person( );
newPerson.setId( 2L );
newPerson.setName( "John Doe" );
entityManager.persist( newPerson );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">INSERT INTO Person (name, id)
VALUES ('John Doe', 2L)

DELETE FROM Person WHERE id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使我们删除了第一个实体，然后保留一个新实体，Hibernate仍将执行<code>DELETE</code>之后的声明<code>INSERT</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>SQL语句的执行顺序由<code>ActionQueue</code>而不是按照先前已定义实体状态操作的顺序。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>ActionQueue</code>按以下顺序执行所有操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>OrphanRemovalAction</code></p>
</li>
<li>
<p><code>EntityInsertAction</code>要么<code>EntityIdentityInsertAction</code></p>
</li>
<li>
<p><code>EntityUpdateAction</code></p>
</li>
<li>
<p><code>CollectionRemoveAction</code></p>
</li>
<li>
<p><code>CollectionUpdateAction</code></p>
</li>
<li>
<p><code>CollectionRecreateAction</code></p>
</li>
<li>
<p><code>EntityDeleteAction</code></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database"><a class="anchor" href="#database"></a> 7。数据库访问</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="database-connectionprovider"><a class="anchor" href="#database-connectionprovider"></a> 7.1。连接提供者</h3>
<div class="paragraph">
<p>作为ORM工具，您可能需要告诉Hibernate的最重要的事情就是如何连接到数据库，以便它可以代表您的应用程序进行连接。这最终是功能<code>org.hibernate.engine.jdbc.connections.spi.ConnectionProvider</code>接口。Hibernate提供了该接口的一些现成的实现。
<code>ConnectionProvider</code>也是一个扩展点，因此您还可以使用第三方的自定义实现或自己编写。的<code>ConnectionProvider</code>使用方式由<code>hibernate.connection.provider_class</code>设置。见<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/cfg/AvailableSettings.html#CONNECTION_PROVIDER"><code>org.hibernate.cfg.AvailableSettings#CONNECTION_PROVIDER</code></a></p>
</div>
<div class="paragraph">
<p>一般而言，应用程序不必配置<code>ConnectionProvider</code>如果使用的是Hibernate提供的实现之一，则必须明确指定。Hibernate将在内部确定哪个<code>ConnectionProvider</code>根据以下算法使用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果<code>hibernate.connection.provider_class</code>被设置，它具有优先权</p>
</li>
<li>
<p>否则，如果<code>hibernate.connection.datasource</code>设置→ <a href="#database-connectionprovider-datasource">使用数据源</a></p>
</li>
<li>
<p>否则，如果有前缀<code>hibernate.c3p0.</code>设置→ <a href="#database-connectionprovider-c3p0">使用c3p0</a></p>
</li>
<li>
<p>否则，如果有前缀<code>hibernate.proxool.</code>设置→ <a href="#database-connectionprovider-proxool">使用Proxool</a></p>
</li>
<li>
<p>否则，如果有前缀<code>hibernate.hikari.</code>设置→ <a href="#database-connectionprovider-hikari">使用HikariCP</a></p>
</li>
<li>
<p>否则，如果有前缀<code>hibernate.vibur.</code>设置→ <a href="#database-connectionprovider-vibur">使用Vibur DBCP</a></p>
</li>
<li>
<p>否则，如果有前缀<code>hibernate.agroal.</code>设置→ <a href="#database-connectionprovider-agroal">使用农业</a></p>
</li>
<li>
<p>否则，如果<code>hibernate.connection.url</code>已设置→ <a href="#database-connectionprovider-drivermanager">使用Hibernate的内置（且不受支持）池</a></p>
</li>
<li>
<p>else→ <a href="#database-connectionprovider-provided">用户提供的连接</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-datasource"><a class="anchor" href="#database-connectionprovider-datasource"></a> 7.2。使用数据源</h3>
<div class="paragraph">
<p>Hibernate可以与<code>javax.sql.DataSource</code>用于获取JDBC连接。应用程序将告诉Hibernate <code>DataSource</code>通过（必填） <code>hibernate.connection.datasource</code>设置，可以指定JNDI名称，也可以引用实际的<code>DataSource</code>实例。对于给出了JNDI名称的情况，请务必阅读<a href="#jndi">JNDI</a></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于JPA应用程序，请注意<code>hibernate.connection.datasource</code>对应于<code>javax.persistence.jtaDataSource</code>要么<code>javax.persistence.nonJtaDataSource</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>DataSource</code><code>ConnectionProvider</code>也（可选）接受<code>hibernate.connection.username</code>和<code>hibernate.connection.password</code> 。如果指定， <a href="https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html#getConnection-java.lang.String-java.lang.String-"><code>DataSource#getConnection(String username, String password)</code></a>将会被使用。否则，将使用no-arg形式。</p>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-driver"><a class="anchor" href="#database-connectionprovider-driver"></a> 7.3。驱动程式设定</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.connection.driver_class</code></dt>
<dd>
<p>要使用的JDBC Driver类的名称</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.url</code></dt>
<dd>
<p>JDBC连接网址</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.*</code></dt>
<dd>
<p>所有此类设置名称（ <a href="#configurations-database-connection">预定义</a>名称除外）将具有<code>hibernate.connection.</code>前缀剥离。其余名称和原始值将作为JDBC连接属性传递给驱动程序</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">并非所有属性都适用于所有情况。例如，如果您要提供数据源， <code>hibernate.connection.driver_class</code>设置将不被使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-c3p0"><a class="anchor" href="#database-connectionprovider-c3p0"></a> 7.4。使用c3p0</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用c3p0集成，应用程序必须包含<code>hibernate-c3p0</code>类路径上的模块jar（及其依赖项）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate还为应用程序使用<a href="http://www.mchange.com/projects/c3p0/">c3p0</a>连接池提供支持。启用c3p0支持后，除了“ <a href="#database-connectionprovider-driver">驱动程序配置”中</a>介绍的常规设置外，还会识别许多c3p0特定的配置设置。</p>
</div>
<div class="paragraph">
<p>连接的事务隔离由管理<code>ConnectionProvider</code>本身。请参阅<a href="#database-connectionprovider-isolation">ConnectionProvider支持以了解事务隔离设置</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.c3p0.min_size</code>要么<code>c3p0.minPoolSize</code></dt>
<dd>
<p>c3p0池的最小大小。参见<a href="http://www.mchange.com/projects/c3p0/#minPoolSize">c3p0 minPoolSize</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.max_size</code>要么<code>c3p0.maxPoolSize</code></dt>
<dd>
<p>c3p0池的最大大小。参见<a href="http://www.mchange.com/projects/c3p0/#maxPoolSize">c3p0 maxPoolSize</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.timeout</code>要么<code>c3p0.maxIdleTime</code></dt>
<dd>
<p>连接空闲时间。参见<a href="http://www.mchange.com/projects/c3p0/#maxIdleTime">c3p0 maxIdleTime</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.max_statements</code>要么<code>c3p0.maxStatements</code></dt>
<dd>
<p>控制c3p0 PreparedStatement缓存大小（如果使用）。参见<a href="http://www.mchange.com/projects/c3p0/#maxStatements">c3p0 maxStatements</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.acquire_increment</code>要么<code>c3p0.acquireIncrement</code></dt>
<dd>
<p>池耗尽时应获取的连接数c3p0。参见<a href="http://www.mchange.com/projects/c3p0/#acquireIncrement">c3p0 acquisitionIncrement</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.idle_test_period</code>要么<code>c3p0.idleConnectionTestPeriod</code></dt>
<dd>
<p>验证c3p0池连接之前的空闲时间。参见<a href="http://www.mchange.com/projects/c3p0/#idleConnectionTestPeriod">c3p0 idleConnectionTestPeriod</a></p>
</dd>
<dt class="hdlist1"><code>hibernate.c3p0.initialPoolSize</code></dt>
<dd>
<p>初始c3p0池大小。如果未指定，则默认为使用最小池大小。参见<a href="http://www.mchange.com/projects/c3p0/#initialPoolSize">c3p0 initialPoolSize</a></p>
</dd>
<dt class="hdlist1">其他带有前缀的设置<code>hibernate.c3p0.</code></dt>
<dd>
<p>将有<code>hibernate.</code>部分被剥离并传递给c3p0。</p>
</dd>
<dt class="hdlist1">其他带有前缀的设置<code>c3p0.</code></dt>
<dd>
<p>照原样传递给c3p0。请参阅<a href="http://www.mchange.com/projects/c3p0/#configuration">c3p0配置</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-proxool"><a class="anchor" href="#database-connectionprovider-proxool"></a> 7.5。使用Proxool</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用Proxool集成，应用程序必须包含<code>hibernate-proxool</code>类路径上的模块jar（及其依赖项）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate还为应用程序使用<a href="http://proxool.sourceforge.net/">Proxool</a>连接池提供支持。</p>
</div>
<div class="paragraph">
<p>连接的事务隔离由管理<code>ConnectionProvider</code>本身。请参阅<a href="#database-connectionprovider-isolation">ConnectionProvider支持以了解事务隔离设置</a> 。</p>
</div>
<div class="sect3">
<h4 id="database-connectionprovider-proxool-existing"><a class="anchor" href="#database-connectionprovider-proxool-existing"></a> 7.5.1。使用现有的Proxool池</h4>
<div class="paragraph">
<p>由控制<code>hibernate.proxool.existing_pool</code>设置。如果设置为true，则此ConnectionProvider将按别名使用已存在的Proxool池，如<code>hibernate.proxool.pool_alias</code>设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="database-connectionprovider-proxool-jaxp"><a class="anchor" href="#database-connectionprovider-proxool-jaxp"></a> 7.5.2。通过XML配置Proxool</h4>
<div class="paragraph">
<p>的<code>hibernate.proxool.xml</code>设置将Proxool配置XML文件命名为要作为类路径资源加载并由Proxool的JAXPConfigurator加载。请参阅<a href="http://proxool.sourceforge.net/configure.html">proxool配置</a> 。
<code>hibernate.proxool.pool_alias</code>必须设置以指示要使用哪个池。</p>
</div>
</div>
<div class="sect3">
<h4 id="database-connectionprovider-proxool-properties"><a class="anchor" href="#database-connectionprovider-proxool-properties"></a> 7.5.3。通过属性配置Proxool</h4>
<div class="paragraph">
<p>的<code>hibernate.proxool.properties</code>设置将Proxool配置属性文件命名为要作为类路径资源加载并由Proxool加载<code>PropertyConfigurator</code> 。请参阅<a href="http://proxool.sourceforge.net/configure.html">proxool配置</a> 。
<code>hibernate.proxool.pool_alias</code>必须设置以指示要使用哪个池。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-hikari"><a class="anchor" href="#database-connectionprovider-hikari"></a> 7.6。使用HikariCP</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用HikariCP进行此集成，应用程序必须包含<code>hibernate-hikari</code>类路径上的模块jar（及其依赖项）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate还为应用程序使用<a href="http://brettwooldridge.github.io/HikariCP/">Hikari</a>连接池提供支持。</p>
</div>
<div class="paragraph">
<p>在Hibernate中将所有Hikari设置设为前缀为<code>hibernate.hikari.</code>和这个<code>ConnectionProvider</code>会接他们并传递给光另外，这个<code>ConnectionProvider</code>将选取以下特定于Hibernate的属性，并将它们映射到相应的Hikari属性（任何<code>hibernate.hikari.</code>带前缀的优先级）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.connection.driver_class</code></dt>
<dd>
<p>映射到光的<code>driverClassName</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.url</code></dt>
<dd>
<p>映射到光的<code>jdbcUrl</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.username</code></dt>
<dd>
<p>映射到光的<code>username</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.password</code></dt>
<dd>
<p>映射到光的<code>password</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.isolation</code></dt>
<dd>
<p>映射到光的<code>transactionIsolation</code>设置。请参阅<a href="#database-connectionprovider-isolation">ConnectionProvider支持以了解事务隔离设置</a> 。请注意，Hikari仅支持JDBC标准隔离级别（显然）。</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.autocommit</code></dt>
<dd>
<p>映射到光的<code>autoCommit</code>设置</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-vibur"><a class="anchor" href="#database-connectionprovider-vibur"></a> 7.7。使用Vibur DBCP</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用Vibur DBCP集成，应用程序必须包括<code>hibernate-vibur</code>类路径上的模块jar（及其依赖项）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate还为应用程序使用<a href="http://www.vibur.org/">Vibur DBCP</a>连接池提供支持。</p>
</div>
<div class="paragraph">
<p>在Hibernate中设置所有Vibur设置，前缀为<code>hibernate.vibur.</code>和这个<code>ConnectionProvider</code>将它们捡起来并传递给Vibur DBCP。另外，这个<code>ConnectionProvider</code>将选取以下特定于Hibernate的属性，并将它们映射到相应的Vibur属性（任何<code>hibernate.vibur.</code>带前缀的优先级）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.connection.driver_class</code></dt>
<dd>
<p>映射到Vibur的<code>driverClassName</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.url</code></dt>
<dd>
<p>映射到Vibur的<code>jdbcUrl</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.username</code></dt>
<dd>
<p>映射到Vibur的<code>username</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.password</code></dt>
<dd>
<p>映射到Vibur的<code>password</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.isolation</code></dt>
<dd>
<p>映射到Vibur的<code>defaultTransactionIsolationValue</code>设置。请参阅<a href="#database-connectionprovider-isolation">ConnectionProvider支持以了解事务隔离设置</a> 。</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.autocommit</code></dt>
<dd>
<p>映射到Vibur的<code>defaultAutoCommit</code>设置</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-agroal"><a class="anchor" href="#database-connectionprovider-agroal"></a> 7.8。使用农业</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用Agroal集成，应用程序必须包含<code>hibernate-agroal</code>类路径上的模块jar（及其依赖项）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate还为应用程序使用<a href="http://agroal.github.io/">Agroal</a>连接池提供支持。</p>
</div>
<div class="paragraph">
<p>在Hibernate中设置所有以开头的农业设置<code>hibernate.agroal.</code>和这个<code>ConnectionProvider</code>将它们接起来并传递给Agroal连接池。另外，这个<code>ConnectionProvider</code>将选择以下特定于Hibernate的属性并将其映射到相应的Agroal属性（任何<code>hibernate.agroal.</code>带前缀的优先级）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.connection.driver_class</code></dt>
<dd>
<p>映射到Agroal的<code>driverClassName</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.url</code></dt>
<dd>
<p>映射到Agroal的<code>jdbcUrl</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.username</code></dt>
<dd>
<p>映射到Agroal的<code>principal</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.password</code></dt>
<dd>
<p>映射到Agroal的<code>credential</code>设置</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.isolation</code></dt>
<dd>
<p>映射到Agroal的<code>jdbcTransactionIsolation</code>设置。请参阅<a href="#database-connectionprovider-isolation">ConnectionProvider支持以了解事务隔离设置</a> 。</p>
</dd>
<dt class="hdlist1"><code>hibernate.connection.autocommit</code></dt>
<dd>
<p>映射到Agroal的<code>autoCommit</code>设置</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-drivermanager"><a class="anchor" href="#database-connectionprovider-drivermanager"></a> 7.9。使用Hibernate的内置（且不受支持）池</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>内置连接池不支持在生产系统中使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本部分仅出于完整性考虑。</p>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-provided"><a class="anchor" href="#database-connectionprovider-provided"></a> 7.10。用户提供的连接</h3>
<div class="paragraph">
<p>打开会话时，只需将要使用的连接传递给会话，就可以使用Hibernate。不鼓励使用此方法，此处不再讨论。</p>
</div>
</div>
<div class="sect2">
<h3 id="database-connectionprovider-isolation"><a class="anchor" href="#database-connectionprovider-isolation"></a> 7.11。ConnectionProvider支持事务隔离设置</h3>
<div class="paragraph">
<p>所有提供的ConnectionProvider实现，除了<code>DataSourceConnectionProvider</code> ，支持对所有事务进行一致的事务隔离设置<code>Connections</code>从基础池中获取。的价值<code>hibernate.connection.isolation</code>可以用以下三种格式之一指定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDBC级别接受的整数值</p>
</li>
<li>
<p>的名称<code>java.sql.Connection</code>常量字段，表示您要使用的隔离。例如， <code>TRANSACTION_REPEATABLE_READ</code>对于<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html#TRANSACTION_REPEATABLE_READ"><code>java.sql.Connection#TRANSACTION_REPEATABLE_READ</code></a> 。并非仅JDBC标准隔离级别支持此功能，特定于特定JDBC驱动程序的隔离级别不支持此功能。</p>
</li>
<li>
<p>java.sql的简称。连接常数字段，不带<code>TRANSACTION_</code>字首。例如， <code>REPEATABLE_READ</code>对于<a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html#TRANSACTION_REPEATABLE_READ"><code>java.sql.Connection#TRANSACTION_REPEATABLE_READ</code></a> 。同样，仅JDBC标准隔离级别支持此功能，而特定JDBC驱动程序特定的隔离级别不支持此功能。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="database-connection-handling"><a class="anchor" href="#database-connection-handling"></a> 7.12。连接处理</h3>
<div class="paragraph">
<p>连接处理模式由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/jdbc/spi/PhysicalConnectionHandlingMode.html"><code>PhysicalConnectionHandlingMode</code></a>枚举提供以下策略：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>IMMEDIATE_ACQUISITION_AND_HOLD</code></dt>
<dd>
<p>的<code>Connection</code>将尽快被收购<code>Session</code>打开并保持直到<code>Session</code>已经关了。</p>
</dd>
<dt class="hdlist1"><code>DELAYED_ACQUISITION_AND_HOLD</code></dt>
<dd>
<p>的<code>Connection</code>将在需要时立即获取，然后保留到<code>Session</code>已经关了。</p>
</dd>
<dt class="hdlist1"><code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code></dt>
<dd>
<p>的<code>Connection</code>将在需要时立即获取，并在每个语句执行后释放。</p>
</dd>
<dt class="hdlist1"><code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION</code></dt>
<dd>
<p>的<code>Connection</code>将在需要时立即获取，并在每次交易完成后释放。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果您不想使用默认的连接处理模式，则可以通过<code>hibernate.connection.handling_mode</code>配置属性。有关更多详细信息，请查看“ <a href="#configurations-database-connection">数据库连接属性”</a>部分。</p>
</div>
<div class="sect3">
<h4 id="_transaction_type_and_connection_handling"><a class="anchor" href="#_transaction_type_and_connection_handling"></a> 7.12.1。事务类型和连接处理</h4>
<div class="paragraph">
<p>默认情况下，连接处理模式由基础事务协调器指定。有两种交易类型： <code>RESOURCE_LOCAL</code> （其中涉及一个数据库<code>Connection</code>交易是通过<code>commit</code>和<code>rollback</code><code>Connection</code>方法）和<code>JTA</code> （可能涉及数据库连接，JMS队列等多个资源）。</p>
</div>
<div class="sect4">
<h5 id="_resource_local_transaction_connection_handling"><a class="anchor" href="#_resource_local_transaction_connection_handling"></a> RESOURCE_LOCAL事务连接处理</h5>
<div class="paragraph">
<p>对于<code>RESOURCE_LOCAL</code>交易，连接处理方式为<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION</code>意味着在需要时获取数据库连接，并在提交或回滚当前正在运行的事务后释放数据库连接。</p>
</div>
<div class="paragraph">
<p>但是，因为Hibernate需要确保在JDBC上禁用了默认的自动提交模式。 <code>Connection</code>开始新交易时， <code>Connection</code>获取并自动提交模式设置为<code>false</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您正在使用连接池<code>DataSource</code>已经为每个池禁用了自动提交模式<code>Connection</code> ，您应该设置<code>hibernate.connection.provider_disables_autocommit</code>至<code>true</code>实际上，数据库连接的获取将延迟到Hibernate需要执行第一个SQL语句之前。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_jta_transaction_connection_handling"><a class="anchor" href="#_jta_transaction_connection_handling"></a> JTA事务连接处理</h5>
<div class="paragraph">
<p>对于<code>JTA</code>交易，连接处理方式为<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code>意味着在需要时获取数据库连接，并在每个语句执行后释放数据库连接。</p>
</div>
<div class="paragraph">
<p>语句执行后释放数据库连接的原因是因为当方法调用从一个EJB转移到另一个EJB时，某些Java EE应用程序服务器报告连接泄漏。但是，即使JDBC <code>Connection</code>被释放到游泳池， <code>Connection</code>仍分配给当前执行中的<code>Thread</code> ，因此在当前正在运行的事务中执行后续语句时，相同<code>Connection</code>对象引用将从池中获取。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在事务从外部EJB传播到内部EJB的过程中，Java EE应用程序服务器或JTA事务管理器支持从一个EJB切换到另一个EJB，并且没有报告连接泄漏误报，那么您应该考虑切换到<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION</code>通过<code>hibernate.connection.handling_mode</code>配置属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_user_provided_connections"><a class="anchor" href="#_user_provided_connections"></a> 7.12.2。用户提供的连接</h4>
<div class="paragraph">
<p>如果当前<code>Session</code>是使用创建的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/SessionBuilder.html"><code>SessionBuilder</code></a>和一个JDBC <code>Connection</code>是通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/SessionBuilder.html#connection-java.sql.Connection-"><code>SessionBuilder#connection</code></a>方法，然后由用户提供<code>Connection</code>将被使用，并且连接处理模式将是<code>IMMEDIATE_ACQUISITION_AND_HOLD</code> 。</p>
</div>
<div class="paragraph">
<p>因此，对于用户提供的连接，将立即获取并保持连接，直到当前<code>Session</code>是关闭的，不受JPA或Hibernate事务上下文的影响。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="database-dialect"><a class="anchor" href="#database-dialect"></a> 7.13。数据库方言</h3>
<div class="paragraph">
<p>尽管SQL是相对标准化的，但是每个数据库供应商都使用ANSI SQL定义的语法的子集和超集。这称为数据库的方言。Hibernate通过其语言处理这些方言的变体<code>org.hibernate.dialect.Dialect</code>类和每个数据库供应商的各种子类。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，Hibernate将能够通过在引导过程中询问JDBC连接的一些问题来确定要使用的适当方言。有关Hibernate确定要使用的适当方言的能力（以及影响该分辨率的能力）的信息，请参见<a href="#portability-dialectresolver">方言分辨率</a> 。</p>
</div>
<div class="paragraph">
<p>如果由于某种原因无法确定正确的方言，或者您想使用自定义方言，则需要设置<code>hibernate.dialect</code>设置。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表4。提供的方言</caption>
<colgroup>
<col style="width:28%">
<col style="width:72%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方言（简称）</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">快取71</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Caché数据库2007.1版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持CUBRID数据库8.3版。可能适用于更高版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持DB2数据库8.2版。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB297</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持9.7版的DB2数据库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2390</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持OS / 390的DB2通用数据库，也称为DB2 / 390。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2400</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持iSeries的DB2通用数据库，也称为DB2 / 400。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">德比十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持10.5版的Derby数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">德比十六</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Derby数据库10.6版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">德比十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Derby数据库10.7版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">火鸟</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Firebird数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FrontBase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Frontbase数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持H2数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HANA专栏商店</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持SAP HANA数据库列存储。这是SAP HANA数据库的推荐方言。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HANARowStore</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持SAP HANA数据库行存储</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持HSQL（HyperSQL）数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Informix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Informix数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">英格利斯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Ingres数据库9.2版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingres9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Ingres数据库9.3版。可能适用于较新的版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingres10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Ingres数据库版本10。可能适用于较新的版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">基地间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Interbase数据库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDataStore</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持JDataStore数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">麦科伊</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持McKoi数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mimer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Mimer数据库9.2.1版。可能适用于较新的版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL5的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持MySQL数据库5.x版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL5InnoDB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">导出表时，支持MySQL数据库5.x版，最好使用InnoDB存储引擎。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL57InnoDB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">导出表时，支持MySQL数据库5.7版，最好使用InnoDB存储引擎。可能适用于较新的版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">玛丽亚数据库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持MariaDB数据库。可能适用于较新的版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">玛丽亚DB53</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持5.3和更高版本的MariaDB数据库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">甲骨文8i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Oracle数据库8i版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">甲骨文9i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Oracle数据库9i版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">甲骨文10g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Oracle数据库10g版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">点库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Pointbase数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgresPlus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Postgres Plus数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL81</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持PostgrSQL数据库版本8.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL82</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持PostgreSQL数据库8.2版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持PostgreSQL数据库版本9。可能适用于更高版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">进展</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持进度数据库9.1C版。可能适用于较新的版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAP数据库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持SAPDB / MAXDB数据库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对SQL Server 2000数据库的支持</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQLServer2005</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持SQL Server 2005数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQLServer2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持SQL Server 2008数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sybase11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Sybase数据库，最高版本为11.9.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SybaseAnywhere</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Sybase Anywhere数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SybaseASE15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Sybase Adaptive Server Enterprise数据库版本15</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SybaseASE157</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Sybase Adaptive Server Enterprise数据库15.7版。可能适用于较新的版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Teradata</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持Teradata数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TimesTen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持TimesTen数据库5.1版。可能适用于较新的版本</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transactions"><a class="anchor" href="#transactions"></a> 8。交易和并发控制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>重要的是要理解，术语“事务”在持久性和对象/关系映射方面具有许多不同但相关的含义。在大多数用例中，这些定义是一致的，但并非总是如此。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可能是指与数据库的物理事务。</p>
</li>
<li>
<p>可能是指与持久性上下文相关的事务的逻辑概念。</p>
</li>
<li>
<p>可能引用原型模式定义的工作单元的应用程序概念。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该文档在很大程度上将事务的物理和逻辑概念视为同一对象。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="transactions-physical"><a class="anchor" href="#transactions-physical"></a> 8.1。实物交易</h3>
<div class="paragraph">
<p>Hibernate使用JDBC API进行持久化。在Java的世界中，有两种定义良好的机制来处理JDBC中的事务：JDBC本身和JTA。 Hibernate支持与事务集成和允许应用程序管理物理事务的两种机制。</p>
</div>
<div class="paragraph">
<p>每笔交易处理<code>Session</code>由<code>org.hibernate.resource.transaction.spi.TransactionCoordinator</code>合同，由<code>org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder</code>服务。
<code>TransactionCoordinatorBuilder</code>代表一种处理交易的策略，而TransactionCoordinator代表该策略与会话相关的一个实例。哪一个<code>TransactionCoordinatorBuilder</code>使用的实现由<code>hibernate.transaction.coordinator_class</code>设置。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>jdbc</code> （非JPA应用程序的默认设置）</dt>
<dd>
<p>通过调用来管理交易<code>java.sql.Connection</code></p>
</dd>
<dt class="hdlist1"><code>jta</code></dt>
<dd>
<p>通过JTA管理交易。请参阅<a href="#bootstrap-jpa-compliant">Java EE引导</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果JPA应用程序未提供以下设置<code>hibernate.transaction.coordinator_class</code> ，Hibernate将根据持久性单元的事务类型自动构建适当的事务协调器。</p>
</div>
<div class="paragraph">
<p>如果非JPA应用程序未提供以下设置<code>hibernate.transaction.coordinator_class</code> ，Hibernate将使用<code>jdbc</code>作为默认值。如果应用程序实际使用基于JTA的事务，则此默认值将导致问题。使用基于JTA的事务的非JPA应用程序应明确设置<code>hibernate.transaction.coordinator_class=jta</code>或提供风俗习惯<code>org.hibernate.resource.transaction.TransactionCoordinatorBuilder</code>建立一个<code>org.hibernate.resource.transaction.TransactionCoordinator</code>可以与基于JTA的事务正确协调。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关实现自定义的详细信息<code>TransactionCoordinatorBuilder</code>或只是更好地了解其工作原理，请参阅《 <a href="http://docs.jboss.org/hibernate/orm/5.4/integrationguide/html_single/Hibernate_Integration_Guide.html">集成指南》</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate直接使用JDBC连接和JTA资源，而无需添加任何其他锁定行为。Hibernate不会将对象锁定在内存中。使用Hibernate时，数据库事务的隔离级别定义的行为不会更改。冬眠<code>Session</code>充当事务作用域缓存，提供可重复读取以通过标识符查找和导致加载实体的查询。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了减少数据库中的锁争用，物理数据库事务需要尽可能短。</p>
</div>
<div class="paragraph">
<p>长时间运行的数据库事务会阻止您的应用程序扩展到高度并行的负载。不要在最终用户级别的工作期间使数据库事务保持打开状态，而应在最终用户级别的工作完成后将其打开。</p>
</div>
<div class="paragraph">
<p>这个概念称为<code>transactional write-behind</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="transactions-physical-jtaplatform"><a class="anchor" href="#transactions-physical-jtaplatform"></a> 8.2。JTA配置</h3>
<div class="paragraph">
<p>与JTA系统的交互在单个名为<code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</code>公开了对<code>javax.transaction.TransactionManager</code>和<code>javax.transaction.UserTransaction</code>该系统，以及公开注册的能力<code>javax.transaction.Synchronization</code>实例，检查交易状态等。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常， <code>JtaPlatform</code>将需要访问JNDI才能解决JTA <code>TransactionManager</code> ， <code>UserTransaction</code>等等。有关配置对JNDI的访问的详细信息，请参见<a href="#jndi">JNDI章节</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate试图发现<code>JtaPlatform</code>它应该通过使用另一个名为<code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformResolver</code> 。如果该解决方案无效，或者您希望提供自定义实现，则需要指定<code>hibernate.transaction.jta.platform</code>设置。Hibernate提供了许多实现<code>JtaPlatform</code>合同，所有简称：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Atomikos</code></dt>
<dd>
<p><code>JtaPlatform</code>对于Atomikos。</p>
</dd>
<dt class="hdlist1"><code>Borland</code></dt>
<dd>
<p><code>JtaPlatform</code>适用于Borland Enterprise Server。</p>
</dd>
<dt class="hdlist1"><code>Bitronix</code></dt>
<dd>
<p><code>JtaPlatform</code>对于Bitronix。</p>
</dd>
<dt class="hdlist1"><code>JBossAS</code></dt>
<dd>
<p><code>JtaPlatform</code>在JBoss / WildFly Application Server中使用时，用于Arjuna / JBossTransactions / Narayana。</p>
</dd>
<dt class="hdlist1"><code>JBossTS</code></dt>
<dd>
<p><code>JtaPlatform</code>独立使用时，用于Arjuna / JBossTransactions / Narayana。</p>
</dd>
<dt class="hdlist1"><code>JOnAS</code></dt>
<dd>
<p><code>JtaPlatform</code>在JOnAS中使用时用于JOTM。</p>
</dd>
<dt class="hdlist1"><code>JOTM</code></dt>
<dd>
<p><code>JtaPlatform</code>独立使用时，适用于JOTM。</p>
</dd>
<dt class="hdlist1"><code>JRun4</code></dt>
<dd>
<p><code>JtaPlatform</code> JRun 4应用程序服务器。</p>
</dd>
<dt class="hdlist1"><code>OC4J</code></dt>
<dd>
<p><code>JtaPlatform</code>用于Oracle的OC4J容器。</p>
</dd>
<dt class="hdlist1"><code>Orion</code></dt>
<dd>
<p><code>JtaPlatform</code>适用于Orion应用服务器。</p>
</dd>
<dt class="hdlist1"><code>Resin</code></dt>
<dd>
<p><code>JtaPlatform</code>用于树脂应用服务器。</p>
</dd>
<dt class="hdlist1"><code>SapNetWeaver</code></dt>
<dd>
<p><code>JtaPlatform</code>用于SAP NetWeaver应用服务器。</p>
</dd>
<dt class="hdlist1"><code>SunOne</code></dt>
<dd>
<p><code>JtaPlatform</code>用于SunOne应用服务器。</p>
</dd>
<dt class="hdlist1"><code>Weblogic</code></dt>
<dd>
<p><code>JtaPlatform</code>用于Weblogic应用服务器。</p>
</dd>
<dt class="hdlist1"><code>WebSphere</code></dt>
<dd>
<p><code>JtaPlatform</code>适用于旧版本的WebSphere Application Server。</p>
</dd>
<dt class="hdlist1"><code>WebSphereExtended</code></dt>
<dd>
<p><code>JtaPlatform</code>适用于较新版本的WebSphere Application Server。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="transactions-api"><a class="anchor" href="#transactions-api"></a> 8.3。Hibernate事务API</h3>
<div class="paragraph">
<p>Hibernate提供了一个API，可帮助将应用程序与所使用的基础物理事务系统中的差异区分开。根据配置<code>TransactionCoordinatorBuilder</code> ，当应用程序使用此事务处理API时，Hibernate只会做正确的事情。这使您的应用程序和组件可以更方便地移动到不同的环境中。</p>
</div>
<div class="paragraph">
<p>要使用此API，您需要获取<code>org.hibernate.Transaction</code>从会议。 <code>Transaction</code>允许您期望的所有正常操作： <code>begin</code> ， <code>commit</code>和<code>rollback</code> ，甚至还公开了一些很酷的方法，例如：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>markRollbackOnly</code></dt>
<dd>
<p>在JTA和JDBC中均可使用</p>
</dd>
<dt class="hdlist1"><code>getTimeout</code>和<code>setTimeout</code></dt>
<dd>
<p>在JTA和JDBC中都可以再次使用</p>
</dd>
<dt class="hdlist1"><code>registerSynchronization</code></dt>
<dd>
<p>这样，即使在非JTA环境中，也可以注册JTA同步。实际上，在JTA和JDBC环境中，这些<code>Synchronizations</code>由Hibernate本地保存。在JTA环境中，Hibernate只会注册一个<code>Synchronization</code>与<code>TransactionManager</code>以避免订购问题。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此外，它还公开了一个getStatus方法，该方法返回一个<code>org.hibernate.resource.transaction.spi.TransactionStatus</code>枚举。如果需要，此方法将与基础交易系统进行检查，因此应注意使其使用最少。在某些JTA设置中，它可能会对性能产生重大影响。</p>
</div>
<div class="paragraph">
<p>让我们看一下在各种环境中使用Transaction API的情况。</p>
</div>
<div id="transactions-api-jdbc-example" class="exampleblock">
<div class="title">示例383在JDBC中使用事务API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
		// "jdbc" is the default, but for explicitness
		.applySetting( AvailableSettings.TRANSACTION_COORDINATOR_STRATEGY, "jdbc" )
		.build();

Metadata metadata = new MetadataSources( serviceRegistry )
		.addAnnotatedClass( Customer.class )
		.getMetadataBuilder()
		.build();

SessionFactory sessionFactory = metadata.getSessionFactoryBuilder()
		.build();

Session session = sessionFactory.openSession();
try {
	// calls Connection#setAutoCommit( false ) to
	// signal start of transaction
	session.getTransaction().begin();

	session.createQuery( "UPDATE customer set NAME = 'Sir. '||NAME" )
			.executeUpdate();

	// calls Connection#commit(), if an error
	// happens we attempt a rollback
	session.getTransaction().commit();
}
catch ( Exception e ) {
	// we may need to rollback depending on
	// where the exception happened
	if ( session.getTransaction().getStatus() == TransactionStatus.ACTIVE
			|| session.getTransaction().getStatus() == TransactionStatus.MARKED_ROLLBACK ) {
		session.getTransaction().rollback();
	}
	// handle the underlying error
}
finally {
	session.close();
	sessionFactory.close();
}</code></pre>
</div>
</div>
</div>
</div>
<div id="transactions-api-cmt-example" class="exampleblock">
<div class="title">实施例384。在JTA（CMT）中使用交易API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
		// "jdbc" is the default, but for explicitness
		.applySetting( AvailableSettings.TRANSACTION_COORDINATOR_STRATEGY, "jta" )
		.build();

Metadata metadata = new MetadataSources( serviceRegistry )
		.addAnnotatedClass( Customer.class )
		.getMetadataBuilder()
		.build();

SessionFactory sessionFactory = metadata.getSessionFactoryBuilder()
		.build();

// Note: depending on the JtaPlatform used and some optional settings,
// the underlying transactions here will be controlled through either
// the JTA TransactionManager or UserTransaction

Session session = sessionFactory.openSession();
try {
	// Since we are in CMT, a JTA transaction would
	// already have been started.  This call essentially
	// no-ops
	session.getTransaction().begin();

	Number customerCount = (Number) session.createQuery( "select count(c) from Customer c" ).uniqueResult();

	// Since we did not start the transaction ( CMT ),
	// we also will not end it.  This call essentially
	// no-ops in terms of transaction handling.
	session.getTransaction().commit();
}
catch ( Exception e ) {
	// again, the rollback call here would no-op (aside from
	// marking the underlying CMT transaction for rollback only).
	if ( session.getTransaction().getStatus() == TransactionStatus.ACTIVE
			|| session.getTransaction().getStatus() == TransactionStatus.MARKED_ROLLBACK ) {
		session.getTransaction().rollback();
	}
	// handle the underlying error
}
finally {
	session.close();
	sessionFactory.close();
}</code></pre>
</div>
</div>
</div>
</div>
<div id="transactions-api-bmt-example" class="exampleblock">
<div class="title">示例385在JTA（BMT）中使用交易API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
		// "jdbc" is the default, but for explicitness
		.applySetting( AvailableSettings.TRANSACTION_COORDINATOR_STRATEGY, "jta" )
		.build();

Metadata metadata = new MetadataSources( serviceRegistry )
		.addAnnotatedClass( Customer.class )
		.getMetadataBuilder()
		.build();

SessionFactory sessionFactory = metadata.getSessionFactoryBuilder()
		.build();

// Note: depending on the JtaPlatform used and some optional settings,
// the underlying transactions here will be controlled through either
// the JTA TransactionManager or UserTransaction

Session session = sessionFactory.openSession();
try {
	// Assuming a JTA transaction is not already active,
	// this call the TM/UT begin method.  If a JTA
	// transaction is already active, we remember that
	// the Transaction associated with the Session did
	// not "initiate" the JTA transaction and will later
	// nop-op the commit and rollback calls...
	session.getTransaction().begin();

	session.persist( new Customer(  ) );
	Customer customer = (Customer) session.createQuery( "select c from Customer c" ).uniqueResult();

	// calls TM/UT commit method, assuming we are initiator.
	session.getTransaction().commit();
}
catch ( Exception e ) {
	// we may need to rollback depending on
	// where the exception happened
	if ( session.getTransaction().getStatus() == TransactionStatus.ACTIVE
			|| session.getTransaction().getStatus() == TransactionStatus.MARKED_ROLLBACK ) {
		// calls TM/UT commit method, assuming we are initiator;
		// otherwise marks the JTA transaction for rollback only
		session.getTransaction().rollback();
	}
	// handle the underlying error
}
finally {
	session.close();
	sessionFactory.close();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在CMT情况下，我们确实可以省略所有的Transaction调用。但是这些示例的目的是表明Transaction API确实确实将您的代码与基础事务机制隔离了。实际上，如果您删除了注释和引导程序提供的单个配置设置，则所有3个示例中的代码都完全相同。换句话说，我们可以在3个事务环境中的任何一个中按原样开发该代码并将其删除。</p>
</div>
<div class="paragraph">
<p>事务API努力使体验在所有环境中保持一致。为此，通常存在差异时会遵循JTA规范（例如，在提交失败时自动尝试回滚）。</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-current-session"><a class="anchor" href="#architecture-current-session"></a> 8.4。上下文会话</h3>
<div class="paragraph">
<p>使用Hibernate的大多数应用程序都需要某种形式的<em>上下文</em>会话，其中给定会话在给定上下文的整个范围内都有效。但是，在不同的应用程序中，构成上下文的定义通常是不同的。不同的上下文为当前的概念定义了不同的范围。在3.0版之前使用Hibernate的应用程序倾向于利用本地开发的任何一种<code>ThreadLocal</code>基于上下文的会话，如帮助程序类<code>HibernateUtil</code> ，或利用第三方框架（例如Spring或Pico）提供了基于代理/拦截的上下文会话。</p>
</div>
<div class="paragraph">
<p>从3.0.1版开始，Hibernate添加了<code>SessionFactory.getCurrentSession()</code>方法。最初，此假定用法<code>JTA</code>交易，其中<code>JTA</code>事务定义了当前会话的范围和上下文。鉴于众多独立产品的成熟度<code>JTA TransactionManager</code>实现，大多数（如果不是全部）应用程序应使用<code>JTA</code>事务管理，无论是否将它们部署到<code>J2EE</code>容器。基于此， <code>JTA</code>基于上下文的会话就是您所需要使用的全部。</p>
</div>
<div class="paragraph">
<p>但是，从3.1版开始，后面的处理<code>SessionFactory.getCurrentSession()</code>现在是可插拔的。为此，一个新的扩展接口， <code>org.hibernate.context.spi.CurrentSessionContext</code> ，以及新的配置参数， <code>hibernate.current_session_context_class</code>已添加，以允许定义当前会话的范围和上下文具有可插入性。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/context/spi/CurrentSessionContext.html">Javadocs</a> <code>org.hibernate.context.spi.CurrentSessionContext</code>界面以详细讨论其合同。它定义了一个方法， <code>currentSession()</code> ，由该实现负责跟踪当前的上下文会话。Hibernate开箱即用，带有此接口的三种实现：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.context.internal.JTASessionContext</code></dt>
<dd>
<p>当前会话由以下人员跟踪和确定范围： <code>JTA</code>交易。这里的处理与旧的仅JTA的方法完全相同。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.context.internal.ThreadLocalSessionContext</code></dt>
<dd>
<p>当前会话由执行线程跟踪。有关更多详细信息，请参见<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/context/internal/ThreadLocalSessionContext.html">Javadocs</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.context.internal.ManagedSessionContext</code></dt>
<dd>
<p>当前会话由执行线程跟踪。但是，您有责任绑定和解除绑定<code>Session</code>在此类上具有静态方法的实例；它不会打开，冲洗或关闭<code>Session</code> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>通常，此参数的值只是命名要使用的实现类。但是，对于三个现成的实现，有三个对应的简称： <em>jta</em> ， <em>thread</em>和<em>managed</em> 。</p>
</div>
<div class="paragraph">
<p>前两个实现提供<em>一个会话-一个数据库事务</em>编程模型。这也称为“ <em>每请求会话数”</em> 。 Hibernate会话的开始和结束由数据库事务的持续时间定义。如果在没有JTA的纯Java SE中使用程序化事务划分，则建议使用Hibernate <code>Transaction</code>用于从代码中隐藏基础交易系统的API。如果使用JTA，则可以利用JTA接口来划分事务。如果在支持CMT的EJB容器中执行，则声明式定义事务边界，并且代码中不需要任何事务或会话划分操作。有关更多信息和代码示例，请参阅<a href="#transactions">事务和并发控制</a> 。</p>
</div>
<div class="paragraph">
<p>的<code>hibernate.current_session_context_class</code>配置参数定义了哪个<code>org.hibernate.context.spi.CurrentSessionContext</code>应该使用实现。为了向后兼容，如果未设置此配置参数，而是<code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</code>配置后，Hibernate将使用<code>org.hibernate.context.internal.JTASessionContext</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_transactional_patterns_and_anti_patterns"><a class="anchor" href="#_transactional_patterns_and_anti_patterns"></a> 8.5。交易模式（和反模式）</h3>
<div class="sect3">
<h4 id="session-per-operation"><a class="anchor" href="#session-per-operation"></a> 8.5.1。每次操作会话反模式</h4>
<div class="paragraph">
<p>这是打开和关闭广告的反模式<code>Session</code>对于单个线程中的每个数据库调用。就数据库事务而言，它也是一种反模式。将数据库调用分组为计划的顺序。同样，不要在应用程序中的每个SQL语句之后自动提交。Hibernate禁用或希望应用程序服务器立即禁用自动提交模式。数据库事务绝不是可选的。与数据库的所有通信都必须由事务封装。避免自动提交行为来读取数据，因为许多小事务的执行效果不佳于一个明确定义的工作单元，并且更难以维护和扩展。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用自动提交不会绕过数据库事务。</p>
</div>
<div class="paragraph">
<p>相反，在自动提交模式下，JDBC驱动程序仅在隐式事务调用中执行每个调用。就像您的应用程序在每个JDBC调用之后都调用了commit一样。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="session-per-request"><a class="anchor" href="#session-per-request"></a> 8.5.2。每次请求会话模式</h4>
<div class="paragraph">
<p>这是最常见的交易模式。这里的术语“请求”涉及对来自客户端/用户的一系列请求做出反应的系统的概念。Web应用程序是此类系统的主要示例，尽管当然不是唯一的一种。在开始处理此类请求时，应用程序打开一个Hibernate Session，启动一个事务，执行所有与数据相关的工作，结束该事务并关闭Session。模式的症结在于交易与会话之间的一对一关系。</p>
</div>
<div class="paragraph">
<p>在此模式下，存在一种定义当前会话的通用技术，以简化通过此会话的需要。 <code>Session</code>可能需要访问它的所有应用程序组件。Hibernate通过以下方式为该技术提供支持： <code>getCurrentSession</code>的方法<code>SessionFactory</code> 。<em>当前</em>会话的概念必须具有一个范围，该范围定义了<em>current</em>概念有效的范围。这是目的<code>org.hibernate.context.spi.CurrentSessionContext</code>合同。</p>
</div>
<div class="paragraph">
<p>有2个可靠的定义范围：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先是JTA事务，因为它允许回调挂钩知道结束时间，这使Hibernate有机会关闭<code>Session</code>并清理。这由<code>org.hibernate.context.internal.JTASessionContext</code>实施<code>org.hibernate.context.spi.CurrentSessionContext</code>合同。使用此实现， <code>Session</code>将在第一次开放<code>getCurrentSession</code>在该交易中被称为。</p>
</li>
<li>
<p>其次是这个应用程序请求周期本身。这最好用<code>org.hibernate.context.internal.ManagedSessionContext</code>实施<code>org.hibernate.context.spi.CurrentSessionContext</code>合同。在这里，外部组件负责管理<em>当前</em>会话的生命周期和范围。在这种范围的开始， <code>ManagedSessionContext#bind()</code>该方法称为传递<code>Session</code> 。最后，它的<code>unbind()</code>方法被调用。此类<em>外部组件的</em>一些常见示例包括：</p>
<div class="ulist">
<ul>
<li>
<p><code>javax.servlet.Filter</code>实作</p>
</li>
<li>
<p>带有切入点的AOP拦截器的服务方法</p>
</li>
<li>
<p>代理/拦截容器</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>getCurrentSession()</code>在JTA环境中，该方法有一个缺点。如果您使用它， <code>after_statement</code>默认情况下也使用连接释放模式。由于JTA规范的限制，Hibernate无法自动清除所有未关闭的文件<code>ScrollableResults</code>要么<code>Iterator</code>实例返回<code>scroll()</code>要么<code>iterate()</code> 。通过调用释放基础数据库游标<code>ScrollableResults#close()</code>要么<code>Hibernate.close(Iterator)</code>明确地从finally块开始。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="long-conversations"><a class="anchor" href="#long-conversations"></a> 8.5.3。对话（应用程序级交易）</h4>
<div class="paragraph">
<p>每次请求会话模式不是设计工作单元的唯一有效方法。许多业务流程需要与用户进行一系列与数据库访问交错的交互。在Web和企业应用程序中，数据库事务跨越用户交互是不可接受的。考虑以下示例：</p>
</div>
<div class="paragraph">
<p>对话框的第一个屏幕打开。用户看到的数据被加载到特定的<code>Session</code>和数据库事务。用户可以自由修改对象。</p>
</div>
<div class="paragraph">
<p>用户在编辑五分钟后使用UI元素保存其工作。修改被持久化。用户还希望在编辑会话期间对数据具有独占访问权限。</p>
</div>
<div class="paragraph">
<p>即使我们在这里有多个数据库访问权限，从用户的角度来看，这一系列步骤也代表了一个工作单元。有多种方法可以在您的应用程序中实现此目的。</p>
</div>
<div class="paragraph">
<p>最初的天真的实现可能会使<code>Session</code>并且在用户编辑时打开数据库事务，并使用数据库级别的锁来防止其他用户修改相同的数据并保证隔离性和原子性。这是一种反模式，因为锁争用是瓶颈，将来会阻止可伸缩性。</p>
</div>
<div class="paragraph">
<p>几个数据库事务用于实现对话。在这种情况下，保持业务流程的隔离成为应用程序层的部分责任。单个对话通常跨越几个数据库事务。如果这些数据库事务中只有一个（通常是最后一个）存储更新的数据，则这些多个数据库访问只能是整体的原子访问。所有其他人仅读取数据。接收此数据的一种常用方法是通过一个跨越多个请求/响应周期的向导式对话框。Hibernate包含一些使其易于实现的功能。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动版本控制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate可以为您执行自动乐观并发控制。它可以自动检测（在对话结束时）用户思考期间是否发生了并发修改。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分离的物体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果您决定使用按请求的会话模式，则在用户思考期间，所有加载的实例将处于分离状态。Hibernate允许您重新附加对象并保留修改。该模式称为每个请求与分离对象的会话。自动版本控制用于隔离并发修改。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">扩展的<code>Session</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">冬眠<code>Session</code>提交数据库事务后，可以从基础JDBC连接断开连接，并在发生新的客户端请求时重新连接。这种模式称为“每次会话会话”，无需重新连接。自动版本控制用于隔离并发修改，并且<code>Session</code>将不允许自动刷新，而只能显式刷新。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>每个带有分离对象的请求会话和每个会话会话各有利弊。</p>
</div>
</div>
<div class="sect3">
<h4 id="session-per-application"><a class="anchor" href="#session-per-application"></a> 8.5.4。每次应用会话反模式</h4>
<div class="paragraph">
<p><em>每个应用程序会话</em>也被认为是反模式。冬眠<code>Session</code> ，例如JPA <code>EntityManager</code> ，不是线程安全的对象，而是旨在一次限制在单个线程中。如果<code>Session</code>在多个线程之间共享时，会出现竞争状况以及可见性问题，因此请注意这一点。</p>
</div>
<div class="paragraph">
<p>Hibernate引发的异常意味着您必须回滚数据库事务并关闭<code>Session</code>立即。如果你的<code>Session</code>绑定到该应用程序，则必须停止该应用程序。回滚数据库事务不会使您的业务对象回到事务开始时的状态。这意味着数据库状态和业务对象将不同步。通常，这不是问题，因为异常是不可恢复的，并且无论如何您都必须在回滚后重新开始。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="#pc-exception-handling"><em>异常处理</em></a>一章。</p>
</div>
<div class="paragraph">
<p>的<code>Session</code>缓存处于持久状态的所有对象（由Hibernate监视并检查其是否为脏状态）。如果您长时间将其保持打开状态或只是加载过多数据，它将无限增长，直到您获得<code>OutOfMemoryException</code> 。一种解决方法是致电<code>clear()</code>和<code>evict()</code>管理<code>Session</code>高速缓存，但是如果需要海量数据操作，则应考虑使用存储过程。<a href="#batch">批处理一章</a>中显示了一些解决方案。保持<code>Session</code>在用户会话期间打开也意味着过时数据的可能性更高。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jndi"><a class="anchor" href="#jndi"></a> 9。日本国家发展研究院</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate确实可以代表应用程序与JNDI进行交互。通常，它在应用程序执行以下操作时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>已要求SessionFactory绑定到JNDI</p>
</li>
<li>
<p>已指定要通过JNDI名称使用的数据源</p>
</li>
<li>
<p>正在使用JTA交易， <code>JtaPlatform</code>需要进行JNDI查找<code>TransactionManager</code> ， <code>UserTransaction</code>等</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有这些JNDI调用都通过单个服务进行路由，该服务的角色是<code>org.hibernate.engine.jndi.spi.JndiService</code> 。标准<code>JndiService</code>接受许多配置设置</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.jndi.class</code></dt>
<dd>
<p>命名javax.naming。要使用的InitialContext实现类。看到<a href="https://docs.oracle.com/javase/8/docs/api/javax/naming/Context.html#INITIAL_CONTEXT_FACTORY"><code>javax.naming.Context#INITIAL_CONTEXT_FACTORY</code></a></p>
</dd>
<dt class="hdlist1"><code>hibernate.jndi.url</code></dt>
<dd>
<p>命名JNDI InitialContext连接URL。看到<a href="https://docs.oracle.com/javase/8/docs/api/javax/naming/Context.html#PROVIDER_URL"><code>javax.naming.Context.PROVIDER_URL</code></a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>其他带有前缀的设置<code>hibernate.jndi.</code>将被收集并传递给JNDI提供者。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>标准<code>JndiService</code>假定所有JNDI调用都相对于同一调用<code>InitialContext</code> 。如果您的应用程序出于任何原因使用多个命名服务器，则需要自定义<code>JndiService</code>实施以处理这些细节。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="locking"><a class="anchor" href="#locking"></a> 10。锁定</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在关系数据库中，锁定是指为防止数据在读取时间和使用时间之间发生更改而采取的操作。</p>
</div>
<div class="paragraph">
<p>您的锁定策略可以是乐观的也可以是悲观的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">乐观的</dt>
<dd>
<p><a href="http://en.wikipedia.org/wiki/Optimistic_locking">乐观锁定</a>假定多个事务可以完成而不会互相影响，因此事务可以继续进行而不会锁定它们影响的数据资源。在提交之前，每个事务都将验证没有其他事务已修改其数据。如果检查显示有冲突的修改，则提交的事务将回滚。</p>
</dd>
<dt class="hdlist1">悲观</dt>
<dd>
<p>悲观锁定假定并发事务会相互冲突，并要求在读取资源后将其锁定，并且仅在应用程序使用完数据后将其解锁。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Hibernate提供了在应用程序中实现两种锁定类型的机制。</p>
</div>
<div class="sect2">
<h3 id="locking-optimistic"><a class="anchor" href="#locking-optimistic"></a> 10.1。乐观的</h3>
<div class="paragraph">
<p>当您的应用程序使用长事务或跨越多个数据库事务的对话时，您可以存储版本控制数据，这样，如果两个对话更新了同一实体，则最后一次提交更改将被告知冲突，并且不会覆盖其他对话的工作。这种方法可以保证一定的隔离性，但是可以很好地扩展，并且在<em>有时经常读写的</em>情况下特别有效。</p>
</div>
<div class="paragraph">
<p>Hibernate提供了两种用于存储版本控制信息的机制：专用版本号或时间戳。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于分离的实例，version或timestamp属性永远不能为null。Hibernate会将任何具有空版本或时间戳的实例检测为瞬态，而与您指定的其他未保存值策略无关。声明可为空的版本或时间戳属性是避免在Hibernate中进行传递重新连接时出现问题的一种简便方法，特别是在使用分配的标识符或组合键的情况下尤其有用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="locking-optimistic-mapping"><a class="anchor" href="#locking-optimistic-mapping"></a> 10.1.1。映射乐观锁定</h4>
<div class="paragraph">
<p>JPA基于版本（顺序数字）或时间戳策略定义了对乐观锁定的支持。要启用这种乐观锁定样式，只需添加<code>javax.persistence.Version</code>到定义乐观锁定值的持久属性。根据JPA，这些属性的有效类型限于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int</code>要么<code>Integer</code></p>
</li>
<li>
<p><code>short</code>要么<code>Short</code></p>
</li>
<li>
<p><code>long</code>要么<code>Long</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，Hibernate甚至允许您使用Java 8日期/时间类型，例如<code>Instant</code> 。</p>
</div>
<div id="locking-optimistic-version-example" class="exampleblock">
<div class="title">示例386 <code>@Version</code>注释映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`name`")
	private String name;

	@Version
	private long version;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`name`")
	private String name;

	@Version
	private Timestamp version;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	@Column(name = "`name`")
	private String name;

	@Version
	private Instant version;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="locking-optimistic-version-number"><a class="anchor" href="#locking-optimistic-version-number"></a>专用版本号</h5>
<div class="paragraph">
<p>用于乐观锁定的版本号机制是通过<code>@Version</code>注解。</p>
</div>
<div id="locking-optimistic-version-number-example" class="exampleblock">
<div class="title">示例387@Version批注</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Version
private long version;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，版本属性被映射到<code>version</code>列，然后实体管理器就可以使用它来检测冲突的更新，并防止丢失丢失的更新，否则这些更新会被最后一次提交胜出策略所覆盖。</p>
</div>
<div class="paragraph">
<p>版本列可以是任何类型，只要您定义并实现适当的<code>UserVersionType</code> 。</p>
</div>
<div class="paragraph">
<p>禁止您的应用程序更改Hibernate设置的版本号。要人为增加版本号，请参阅文档以获取属性<code>LockModeType.OPTIMISTIC_FORCE_INCREMENT</code>要么<code>LockModeType.PESSIMISTIC_FORCE_INCREMENT</code>查阅Hibernate Entity Manager参考文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果版本号是由数据库生成的，例如触发器，请使用注释<code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS)</code>在version属性上。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="locking-optimistic-timestamp"><a class="anchor" href="#locking-optimistic-timestamp"></a>时间戳记</h5>
<div class="paragraph">
<p>与版本号相比，时间戳是最不可靠的乐观锁定方式，但应用程序也可以将其用于其他目的。如果您使用<code>@Version</code>上的注释<code>Date</code>要么<code>Calendar</code>财产种类。</p>
</div>
<div id="locking-optimistic-version-timestamp-example" class="exampleblock">
<div class="title">示例388使用时间戳进行乐观锁定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Version
private Date version;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate可以通过读取您为数据库或JVM指定的值来检索时间戳值。 <code>@org.hibernate.annotations.Source</code>注解。该值可以是<code>org.hibernate.annotations.SourceType.DB</code>要么<code>org.hibernate.annotations.SourceType.VM</code> 。默认行为是使用数据库，如果根本不指定注释，也将使用它。</p>
</div>
<div class="paragraph">
<p>如果您使用时间戳记，也可以由数据库而不是Hibernate生成时间戳。 <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS)</code>或者<code>@Source</code>注解。</p>
</div>
<div id="locking-optimistic-version-timestamp-source-mapping-example" class="exampleblock">
<div class="title">示例389数据库生成的版本时间戳映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	@Version
	@Source(value = SourceType.DB)
	private Date version;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当坚持<code>Person</code>实体，Hibernate调用特定于数据库的当前时间戳检索函数：</p>
</div>
<div id="locking-optimistic-version-timestamp-source-persist-example" class="exampleblock">
<div class="title">示例390数据库生成的版本时间戳示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = new Person();
person.setId( 1L );
person.setFirstName( "John" );
person.setLastName( "Doe" );
assertNull( person.getVersion() );

entityManager.persist( person );
assertNotNull( person.getVersion() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">CALL current_timestamp()

INSERT INTO
    Person
    (firstName, lastName, version, id)
VALUES
    (?, ?, ?, ?)

-- binding parameter [1] as [VARCHAR]   - [John]
-- binding parameter [2] as [VARCHAR]   - [Doe]
-- binding parameter [3] as [TIMESTAMP] - [2017-05-18 12:03:03.808]
-- binding parameter [4] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="locking-optimistic-exclude-attribute"><a class="anchor" href="#locking-optimistic-exclude-attribute"></a>排除属性</h5>
<div class="paragraph">
<p>默认情况下，每次实体属性修改都会触发版本增加。如果有一个不应该增加实体版本的实体属性，则需要使用Hibernate对其进行注释。 <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLock.html"><code>@OptimisticLock</code></a>注释，如以下示例所示。</p>
</div>
<div id="locking-optimistic-exclude-attribute-mapping-example" class="exampleblock">
<div class="title">示例391@OptimisticLock映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
public static class Phone {

	@Id
	private Long id;

	@Column(name = "`number`")
	private String number;

	@OptimisticLock( excluded = true )
	private long callCount;

	@Version
	private Long version;

	//Getters and setters are omitted for brevity

	public void incrementCallCount() {
		this.callCount++;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，如果一个线程修改了<code>Phone</code>数字，而第二个线程递增<code>callCount</code>属性，两个并发事务不会冲突，如以下示例所示。</p>
</div>
<div id="locking-optimistic-exclude-attribute-example" class="exampleblock">
<div class="title">示例392@OptimisticLock排除属性示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Phone phone = entityManager.find( Phone.class, 1L );
	phone.setNumber( "+123-456-7890" );

	doInJPA( this::entityManagerFactory, _entityManager -&gt; {
		Phone _phone = _entityManager.find( Phone.class, 1L );
		_phone.incrementCallCount();

		log.info( "Bob changes the Phone call count" );
	} );

	log.info( "Alice changes the Phone number" );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">-- Bob changes the Phone call count

update
    Phone
set
    callCount = 1,
    "number" = '123-456-7890',
    version = 0
where
    id = 1
    and version = 0

-- Alice changes the Phone number

update
    Phone
set
    callCount = 0,
    "number" = '+123-456-7890',
    version = 1
where
    id = 1
    and version = 0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当Bob更改<code>Phone</code>实体<code>callCount</code> ，则不会增加实体版本。这就是为什么自从实体版本仍然为0以来，爱丽丝的UPDATE成功的原因，即使鲍勃自从爱丽丝加载记录以来就更改了该记录。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管Bob和Alice之间没有冲突，但Alice的UPDATE会覆盖Bob的更改。 <code>callCount</code>属性。</p>
</div>
<div class="paragraph">
<p>因此，仅当您可以容纳排除的实体属性上丢失的更新时，才应使用此功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="locking-optimistic-versionless"><a class="anchor" href="#locking-optimistic-versionless"></a>无版本乐观锁定</h5>
<div class="paragraph">
<p>虽然默认<code>@Version</code>属性乐观锁定机制在许多情况下就足够了，有时，您需要依靠数据库的实际行列值来防止<strong>更新丢失</strong> 。</p>
</div>
<div class="paragraph">
<p>Hibernate支持一种乐观锁定形式，该形式不需要专用的“版本属性”。这对于与建模旧模式一起使用也很有用。</p>
</div>
<div class="paragraph">
<p>这样的想法是，您可以让Hibernate使用实体的所有属性或仅使用已更改的属性来执行“版本检查”。这是通过使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLocking.html"><code>@OptimisticLocking</code></a>定义单个类型属性的注释<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLockType.html"><code>org.hibernate.annotations.OptimisticLockType</code></a> 。</p>
</div>
<div class="paragraph">
<p>有4种可用的OptimisticLockType：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>NONE</code></dt>
<dd>
<p>即使存在<code>@Version</code>存在注释</p>
</dd>
<dt class="hdlist1"><code>VERSION</code> （默认）</dt>
<dd>
<p>执行基于<code>@Version</code>如上所述</p>
</dd>
<dt class="hdlist1"><code>ALL</code></dt>
<dd>
<p>对UPDATE / DELETE SQL语句扩展的WHERE子句限制的一部分，它基于<em>所有</em>字段执行乐观锁定</p>
</dd>
<dt class="hdlist1"><code>DIRTY</code></dt>
<dd>
<p>作为UPDATE / DELETE SQL语句的扩展WHERE子句限制的一部分，根据<em>脏</em>字段执行乐观锁定</p>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="locking-optimistic-versionless-all"><a class="anchor" href="#locking-optimistic-versionless-all"></a>使用无版本乐观锁定<code>OptimisticLockType.ALL</code></h6>
<div id="locking-optimistic-lock-type-all-example" class="exampleblock">
<div class="title">示例393。 <code>OptimisticLockType.ALL</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
@OptimisticLocking(type = OptimisticLockType.ALL)
@DynamicUpdate
public static class Person {

	@Id
	private Long id;

	@Column(name = "`name`")
	private String name;

	private String country;

	private String city;

	@Column(name = "created_on")
	private Timestamp createdOn;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您需要修改<code>Person</code>上面的实体：</p>
</div>
<div id="locking-optimistic-lock-type-all-update-example" class="exampleblock">
<div class="title">示例394。 <code>OptimisticLockType.ALL</code>更新示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
person.setCity( "Washington D.C." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE
    Person
SET
    city=?
WHERE
    id=?
    AND city=?
    AND country=?
    AND created_on=?
    AND "name"=?

-- binding parameter [1] as [VARCHAR] - [Washington D.C.]
-- binding parameter [2] as [BIGINT] - [1]
-- binding parameter [3] as [VARCHAR] - [New York]
-- binding parameter [4] as [VARCHAR] - [US]
-- binding parameter [5] as [TIMESTAMP] - [2016-11-16 16:05:12.876]
-- binding parameter [6] as [VARCHAR] - [John Doe]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，相关数据库行的所有列都在<code>WHERE</code>条款。如果在加载行后更改了任何列，则不会有任何匹配项，并且<code>StaleStateException</code>或<code>OptimisticLockException</code>将被抛出。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用时<code>OptimisticLockType.ALL</code> ，您还应该使用<code>@DynamicUpdate</code>因为<code>UPDATE</code>语句必须考虑所有实体属性值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="locking-optimistic-versionless-dirty"><a class="anchor" href="#locking-optimistic-versionless-dirty"></a>使用无版本乐观锁定<code>OptimisticLockType.DIRTY</code></h6>
<div class="paragraph">
<p>的<code>OptimisticLockType.DIRTY</code>不同于<code>OptimisticLockType.ALL</code>因为它仅考虑了自从实体在当前运行的持久性上下文中加载以来已更改的实体属性。</p>
</div>
<div id="locking-optimistic-lock-type-dirty-example" class="exampleblock">
<div class="title">示例395 <code>OptimisticLockType.DIRTY</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "Person")
@OptimisticLocking(type = OptimisticLockType.DIRTY)
@DynamicUpdate
@SelectBeforeUpdate
public static class Person {

	@Id
	private Long id;

	@Column(name = "`name`")
	private String name;

	private String country;

	private String city;

	@Column(name = "created_on")
	private Timestamp createdOn;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您需要修改<code>Person</code>上面的实体：</p>
</div>
<div id="locking-optimistic-lock-type-dirty-update-example" class="exampleblock">
<div class="title">实施例396。 <code>OptimisticLockType.DIRTY</code>更新示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Person person = entityManager.find( Person.class, 1L );
person.setCity( "Washington D.C." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">UPDATE
    Person
SET
    city=?
WHERE
    id=?
    and city=?

-- binding parameter [1] as [VARCHAR] - [Washington D.C.]
-- binding parameter [2] as [BIGINT] - [1]
-- binding parameter [3] as [VARCHAR] - [New York]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次，仅更改的数据库列用于<code>WHERE</code>条款。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>主要优点<code>OptimisticLockType.DIRTY</code>过度<code>OptimisticLockType.ALL</code>和默认<code>OptimisticLockType.VERSION</code>与一起隐式使用<code>@Version</code>映射，它可以使您最大程度地降低<code>OptimisticLockException</code>跨非重叠实体的属性更改。</p>
</div>
<div class="paragraph">
<p>使用时<code>OptimisticLockType.DIRTY</code> ，您还应该使用<code>@DynamicUpdate</code>因为<code>UPDATE</code>语句必须考虑所有脏实体属性值，以及<code>@SelectBeforeUpdate</code>注释，以便分离的实体由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Session.html#update-java.lang.Object-"><code>Session#update(entity)</code></a>操作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking-pessimistic"><a class="anchor" href="#locking-pessimistic"></a> 10.2。悲观</h3>
<div class="paragraph">
<p>通常，您只需要为JDBC连接指定隔离级别，然后让数据库处理锁定问题。如果确实需要在新事务开始时获得排他的悲观锁或重新获得锁，则Hibernate将为您提供所需的工具。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate始终使用数据库的锁定机制，从不锁定内存中的对象。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="locking-LockMode"><a class="anchor" href="#locking-LockMode"></a> 10.3。 <code>LockMode</code>和<code>LockModeType</code></h3>
<div class="paragraph">
<p>早在JPA 1.0之前，Hibernate已经通过其Hibernate定义了各种显式锁定策略。 <code>LockMode</code>列举。JPA自带<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/LockModeType.html"><code>LockModeType</code></a>枚举，其定义与Hibernate-native类似的策略<code>LockMode</code> 。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>LockModeType</code></th>
<th class="tableblock halign-left valign-top"><code>LockMode</code></th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NONE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NONE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有锁。在事务结束时，所有对象都切换到此锁定模式。通过调用与会话相关联的对象<code>update()</code>要么<code>saveOrUpdate()</code>也以这种锁定模式开始。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>READ</code>和<code>OPTIMISTIC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>READ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在当前运行的事务即将结束时检查实体版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WRITE</code>和<code>OPTIMISTIC_FORCE_INCREMENT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WRITE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">即使未更改实体，实体版本也会自动增加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_FORCE_INCREMENT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_FORCE_INCREMENT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实体被悲观地锁定，即使实体没有更改，其版本也会自动增加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_READ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_READ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果数据库支持这样的功能，则使用共享锁悲观地锁定实体。否则，将使用显式锁。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_WRITE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_WRITE</code> ，<code>UPGRADE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用显式锁来锁定实体。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_WRITE</code>与一个<code>javax.persistence.lock.timeout</code>设置为0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPGRADE_NOWAIT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果行已被锁定，则锁定获取请求将快速失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PESSIMISTIC_WRITE</code>与一个<code>javax.persistence.lock.timeout</code>设置-2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPGRADE_SKIPLOCKED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">锁定获取请求将跳过已经锁定的行。它使用<code>SELECT …​ FOR UPDATE SKIP LOCKED</code>在Oracle和PostgreSQL 9.5中，或者<code>SELECT …​ with (rowlock, updlock, readpast) in SQL Server</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>上面提到的明确的用户请求是由于以下任何操作引起的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>致电<code>Session.load()</code> ，指定一个<code>LockMode</code> 。</p>
</li>
<li>
<p>致电<code>Session.lock()</code> 。</p>
</li>
<li>
<p>致电<code>Query.setLockMode()</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你打电话<code>Session.load()</code>有选择<code>UPGRADE</code> ， <code>UPGRADE_NOWAIT</code>要么<code>UPGRADE_SKIPLOCKED</code> ，并且会话尚未加载请求的对象，该对象使用加载<code>SELECT …​ FOR UPDATE</code> 。</p>
</div>
<div class="paragraph">
<p>如果你打电话<code>load()</code>对于已经装载了比您请求的限制更少的锁定的对象，Hibernate调用<code>lock()</code>对于那个对象。</p>
</div>
<div class="paragraph">
<p><code>Session.lock(</code> ）执行版本号检查，是否指定的锁定模式为<code>READ</code> ， <code>UPGRADE</code> ， <code>UPGRADE_NOWAIT</code>要么<code>UPGRADE_SKIPLOCKED</code> 。如果是<code>UPGRADE</code> ， <code>UPGRADE_NOWAIT</code>要么<code>UPGRADE_SKIPLOCKED</code> ， <code>SELECT …​ FOR UPDATE</code>使用语法。</p>
</div>
<div class="paragraph">
<p>如果数据库不支持请求的锁定模式，则Hibernate将使用适当的替代模式，而不是引发异常。这样可以确保应用程序是可移植的。</p>
</div>
</div>
<div class="sect2">
<h3 id="locking-jpa-query-hints"><a class="anchor" href="#locking-jpa-query-hints"></a> 10.4。JPA锁定查询提示</h3>
<div class="paragraph">
<p>JPA 2.0引入了两个查询提示：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">javax.persistence.lock.timeout</dt>
<dd>
<p>它给出锁定获取请求在引发异常之前将等待的毫秒数</p>
</dd>
<dt class="hdlist1">javax.persistence.lock.scope</dt>
<dd>
<p>定义锁获取请求的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PessimisticLockScope.html"><em>范围</em></a> 。范围可以是<code>NORMAL</code> （默认值）或<code>EXTENDED</code> 。的<code>EXTENDED</code>作用域将导致锁获取请求被传递给其他结构化的拥有表（例如， <code>@Inheritance(strategy=InheritanceType.JOINED)</code> ， <code>@ElementCollection</code> ）</p>
</dd>
</dl>
</div>
<div id="locking-jpa-query-hints-timeout-example" class="exampleblock">
<div class="title">示例397 <code>javax.persistence.lock.timeout</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager.find(
	Person.class, id, LockModeType.PESSIMISTIC_WRITE,
	Collections.singletonMap( "javax.persistence.lock.timeout", 200 )
);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT explicitlo0_.id     AS id1_0_0_,
       explicitlo0_."name" AS name2_0_0_
FROM   person explicitlo0_
WHERE  explicitlo0_.id = 1
FOR UPDATE wait 2</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>并非所有的JDBC数据库驱动程序都支持为锁定请求设置超时值。如果不支持，则Hibernate方言将忽略此查询提示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>javax.persistence.lock.scope</code> JPA标准<a href="https://hibernate.atlassian.net/browse/HHH-9636">未</a>指定<a href="https://hibernate.atlassian.net/browse/HHH-9636">支持</a>该功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="locking-buildLockRequest"><a class="anchor" href="#locking-buildLockRequest"></a> 10.5。的<code>buildLockRequest</code> API</h3>
<div class="paragraph">
<p>传统上，Hibernate提供<code>Session#lock()</code>获取给定实体的乐观或悲观锁的方法。因为在使用单个锁时更改锁定选项很困难<code>LockMode</code>参数，Hibernate已添加了<code>Session#buildLockRequest()</code>方法API。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在不等待锁获取请求的情况下获取共享数据库锁。</p>
</div>
<div id="locking-buildLockRequest-example" class="exampleblock">
<div class="title">示例398。 <code>buildLockRequest</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, id );
Session session = entityManager.unwrap( Session.class );
session
	.buildLockRequest( LockOptions.NONE )
	.setLockMode( LockMode.PESSIMISTIC_READ )
	.setTimeOut( LockOptions.NO_WAIT )
	.lock( person );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT p.id AS id1_0_0_ ,
       p.name AS name2_0_0_
FROM   Person p
WHERE  p.id = 1

SELECT id
FROM   Person
WHERE  id = 1
FOR    SHARE NOWAIT</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking-follow-on"><a class="anchor" href="#locking-follow-on"></a> 10.6。跟随锁定</h3>
<div class="paragraph">
<p>使用Oracle时， <a href="https://docs.oracle.com/database/121/SQLRF/statements_10002.htm#SQLRF55371"><code>FOR UPDATE</code>排他锁定子句</a>不能用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DISTINCT</code></p>
</li>
<li>
<p><code>GROUP BY</code></p>
</li>
<li>
<p><code>UNION</code></p>
</li>
<li>
<p>内联视图（派生表），因此也影响旧的Oracle分页机制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，Hibernate使用辅助选择来锁定先前获取的实体。</p>
</div>
<div id="locking-follow-on-example" class="exampleblock">
<div class="title">示例399跟随锁定示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select DISTINCT p from Person p", Person.class)
.setLockMode( LockModeType.PESSIMISTIC_WRITE )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT DISTINCT p.id as id1_0_, p."name" as name2_0_
FROM Person p

SELECT id
FROM Person
WHERE id = 1 FOR UPDATE

SELECT id
FROM Person
WHERE id = 1 FOR UPDATE</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了避免N + 1查询问题，可以使用单独的查询使用关联的实体标识符来应用锁。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="locking-follow-on-secondary-query-example" class="exampleblock">
<div class="title">例子400。辅助查询实体锁定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select DISTINCT p from Person p", Person.class)
.getResultList();

entityManager.createQuery(
	"select p.id from Person p where p in :persons")
.setLockMode( LockModeType.PESSIMISTIC_WRITE )
.setParameter( "persons", persons )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT DISTINCT p.id as id1_0_, p."name" as name2_0_
FROM Person p

SELECT p.id as col_0_0_
FROM Person p
WHERE p.id IN ( 1 , 2 )
FOR UPDATE</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>锁定请求从原始查询移到了第二个请求，该请求使用先前获取的实体来锁定其关联的数据库记录。</p>
</div>
<div class="paragraph">
<p>在Hibernate 5.2.1之前，后续锁定机制被统一应用于在Oracle上执行的任何锁定查询。从5.2.1开始，Oracle方言将尝试确定当前查询是否需要后续锁定机制。</p>
</div>
<div class="paragraph">
<p>更为重要的是，您可以否决默认的锁定后检测逻辑，并根据每个查询显式启用或禁用它。</p>
</div>
<div id="locking-follow-on-explicit-example" class="exampleblock">
<div class="title">例子401。明确禁用后续锁定机制</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p from Person p", Person.class)
.setMaxResults( 10 )
.unwrap( Query.class )
.setLockOptions(
	new LockOptions( LockMode.PESSIMISTIC_WRITE )
		.setFollowOnLocking( false ) )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT *
FROM (
    SELECT p.id as id1_0_, p."name" as name2_0_
    FROM Person p
)
WHERE rownum &lt;= 10
FOR UPDATE</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅当当前执行的查询失败时，才应显式启用跟踪锁定机制，因为<code>FOR UPDATE</code>子句无法应用，这意味着需要进一步改进方言解析机制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fetching"><a class="anchor" href="#fetching"></a> 11。正在取得</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本质上，获取是从数据库中获取数据并将其提供给应用程序的过程。调整应用程序的获取方式是确定应用程序将如何执行的最大因素之一。就宽度（值/列）和/或深度（结果/行）而言，获取太多数据会增加JDBC通信和ResultSet处理方面的不必要开销。提取太少的数据可能会导致需要进行其他提取。调整应用程序获取数据的方式提供了一个很大的机会来影响整体应用程序性能。</p>
</div>
<div class="sect2">
<h3 id="fetching-basics"><a class="anchor" href="#fetching-basics"></a> 11.1。基础</h3>
<div class="paragraph">
<p>访存的概念分为两个不同的问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>何时应提取数据？现在？后来？</p>
</li>
<li>
<p>应该如何获取数据？</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“现在”通常被称为渴望或立即，而“稍后”通常被称为懒惰或延迟。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>定义访存有很多范围：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>静态的</em></dt>
<dd>
<p>提取策略的静态定义在映射中完成。在没有任何动态定义策略的情况下使用静态定义的获取策略</p>
<div class="dlist">
<dl>
<dt class="hdlist1">选择</dt>
<dd>
<p>执行单独的SQL选择以加载数据。可以是EAGER（立即发出第二个选择）或LAZY（延迟第二个选择直到需要数据）。这就是通常称为N + 1的策略。</p>
</dd>
<dt class="hdlist1">加入</dt>
<dd>
<p>固有的获取风格。通过使用SQL外部联接获取要获取的数据。</p>
</dd>
<dt class="hdlist1">批量</dt>
<dd>
<p>执行一个单独的SQL选择，以基于批大小使用IN限制作为SQL WHERE子句的一部分来加载多个相关数据项。同样，它可以是EAGER（立即发出第二个选择）或LAZY（延迟第二个选择直到需要数据）。</p>
</dd>
<dt class="hdlist1">子选择</dt>
<dd>
<p>根据用于加载所有者的SQL限制执行单独的SQL选择以加载关联的数据。同样，它可以是EAGER（立即发出第二个选择）或LAZY（延迟第二个选择直到需要数据）。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><em>动态的</em> （有时称为运行时）</dt>
<dd>
<p>动态定义实际上是以用例为中心的。有多种定义动态获取的方法：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>获取配置文件</em></dt>
<dd>
<p>在映射中定义，但可以在<code>Session</code> 。</p>
</dd>
<dt class="hdlist1">HQL / JPQL</dt>
<dd>
<p>Hibernate和JPA Criteria查询都可以指定特定于该查询的访存。</p>
</dd>
<dt class="hdlist1">实体图</dt>
<dd>
<p>从Hibernate 4.2（JPA 2.1）开始，这也是一个选择。</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="fetching-direct-vs-query"><a class="anchor" href="#fetching-direct-vs-query"></a> 11.2。直接获取与实体查询</h3>
<div class="paragraph">
<p>要查看在直接获取的关联方面直接获取和实体查询之间的区别，请考虑以下实体：</p>
</div>
<div id="fetching-direct-vs-query-domain-model-example" class="exampleblock">
<div class="title">例子402。领域模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Department")
public static class Department {

	@Id
	private Long id;

	//Getters and setters omitted for brevity
}

@Entity(name = "Employee")
public static class Employee {

	@Id
	private Long id;

	@NaturalId
	private String username;

	@ManyToOne(fetch = FetchType.EAGER)
	private Department department;

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>Employee</code>实体有一个<code>@ManyToOne</code>关联到<code>Department</code>渴望得到。</p>
</div>
<div class="paragraph">
<p>发出直接实体获取时，Hibernate执行以下SQL查询：</p>
</div>
<div id="fetching-direct-vs-query-direct-fetching-example" class="exampleblock">
<div class="title">范例403。直接获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Employee employee = entityManager.find( Employee.class, 1L );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.username as username2_1_0_,
    d.id as id1_0_1_
from
    Employee e
left outer join
    Department d
        on e.department_id=d.id
where
    e.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>LEFT JOIN</code>子句被添加到生成的SQL查询中，因为需要热切地获取此关联。</p>
</div>
<div class="paragraph">
<p>另一方面，如果您使用的实体查询不包含<code>JOIN FETCH</code>指令<code>Department</code>协会：</p>
</div>
<div id="fetching-direct-vs-query-entity-query-example" class="exampleblock">
<div class="title">示例404实体查询获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Employee employee = entityManager.createQuery(
		"select e " +
		"from Employee e " +
		"where e.id = :id", Employee.class)
.setParameter( "id", 1L )
.getSingleResult();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    e.id as id1_1_,
    e.department_id as departme3_1_,
    e.username as username2_1_
from
    Employee e
where
    e.id = 1

select
    d.id as id1_0_0_
from
    Department d
where
    d.id = 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate改为使用辅助选择。这是因为实体查询的提取策略不能被覆盖，因此Hibernate要求进行二次选择，以确保在将结果返回给用户之前已提取EAGER关联。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您忘记加入所有EAGER关联，Hibernate将为每个关联发出一个次要选择，从而可以倾向于N + 1个查询问题。</p>
</div>
<div class="paragraph">
<p>因此，您应该首选LAZY关联。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="fetching-strategies"><a class="anchor" href="#fetching-strategies"></a> 11.3。应用提取策略</h3>
<div class="paragraph">
<p>让我们考虑这些主题，因为它们与一个简单的域模型和一些用例有关。</p>
</div>
<div id="fetching-strategies-domain-model-example" class="exampleblock">
<div class="title">示例405样本域模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Department")
public static class Department {

	@Id
	private Long id;

	@OneToMany(mappedBy = "department")
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity
}

@Entity(name = "Employee")
public static class Employee {

	@Id
	private Long id;

	@NaturalId
	private String username;

	@Column(name = "pswd")
	@ColumnTransformer(
		read = "decrypt( 'AES', '00', pswd  )",
		write = "encrypt('AES', '00', ?)"
	)
	private String password;

	private int accessLevel;

	@ManyToOne(fetch = FetchType.LAZY)
	private Department department;

	@ManyToMany(mappedBy = "employees")
	private List&lt;Project&gt; projects = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity
}

@Entity(name = "Project")
public class Project {

	@Id
	private Long id;

	@ManyToMany
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate的建议是静态地标记所有懒惰的关联，并使用动态获取策略来提高渴望。</p>
</div>
<div class="paragraph">
<p>不幸的是，这与JPA规范不一致，该规范定义默认情况下应急切获取所有一对一和多对一关联。</p>
</div>
<div class="paragraph">
<p>作为JPA提供者，Hibernate遵守该默认设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="fetching-strategies-no-fetching"><a class="anchor" href="#fetching-strategies-no-fetching"></a> 11.4。不取</h3>
<div class="paragraph">
<p>对于第一个用例，请考虑应用程序的登录过程<code>Employee</code> 。假设登录仅需要访问<code>Employee</code>信息，不是<code>Project</code>也不<code>Department</code>信息。</p>
</div>
<div id="fetching-strategies-no-fetching-example" class="exampleblock">
<div class="title">示例406没有获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Employee employee = entityManager.createQuery(
	"select e " +
	"from Employee e " +
	"where " +
	"	e.username = :username and " +
	"	e.password = :password",
	Employee.class)
.setParameter( "username", username)
.setParameter( "password", password)
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，应用程序获取<code>Employee</code>数据。但是，因为所有关联都来自<code>Employee</code>被声明为LAZY（JPA将集合的默认值定义为LAZY），不会获取其他数据。</p>
</div>
<div class="paragraph">
<p>如果登录过程不需要访问<code>Employee</code>特别是在信息方面，这里的另一个获取优化将是限制查询结果的宽度。</p>
</div>
<div id="fetching-strategies-no-fetching-scalar-example" class="exampleblock">
<div class="title">示例407没有获取（标量）示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Integer accessLevel = entityManager.createQuery(
	"select e.accessLevel " +
	"from Employee e " +
	"where " +
	"	e.username = :username and " +
	"	e.password = :password",
	Integer.class)
.setParameter( "username", username)
.setParameter( "password", password)
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fetching-strategies-dynamic-fetching"><a class="anchor" href="#fetching-strategies-dynamic-fetching"></a> 11.5。通过查询动态获取</h3>
<div class="paragraph">
<p>对于第二个用例，请考虑一个显示以下内容的屏幕： <code>Projects</code>为<code>Employee</code> 。当然可以进入<code>Employee</code>是需要的，以及<code>Projects</code>为那个雇员。相关信息<code>Departments</code> ，其他<code>Employees</code>或其他<code>Projects</code>不需要。</p>
</div>
<div id="fetching-strategies-dynamic-fetching-jpql-example" class="exampleblock">
<div class="title">示例408动态JPQL提取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Employee employee = entityManager.createQuery(
	"select e " +
	"from Employee e " +
	"left join fetch e.projects " +
	"where " +
	"	e.username = :username and " +
	"	e.password = :password",
	Employee.class)
.setParameter( "username", username)
.setParameter( "password", password)
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div id="fetching-strategies-dynamic-fetching-criteria-example" class="exampleblock">
<div class="title">示例409动态查询获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; query = builder.createQuery( Employee.class );
Root&lt;Employee&gt; root = query.from( Employee.class );
root.fetch( "projects", JoinType.LEFT);
query.select(root).where(
	builder.and(
		builder.equal(root.get("username"), username),
		builder.equal(root.get("password"), password)
	)
);
Employee employee = entityManager.createQuery( query ).getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们有一个<code>Employee</code>和他们的<code>Projects</code>加载到显示为HQL查询和JPA Criteria查询的单个查询中。在两种情况下，这都将解析为一个数据库查询以获取所有这些信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="fetching-strategies-dynamic-fetching-entity-graph"><a class="anchor" href="#fetching-strategies-dynamic-fetching-entity-graph"></a> 11.6。通过JPA实体图动态获取</h3>
<div class="paragraph">
<p>JPA 2.1引入了实体图，因此应用程序开发人员可以更好地控制获取计划。</p>
</div>
<div id="fetching-strategies-dynamic-fetching-entity-graph-example" class="exampleblock">
<div class="title">示例410提取图示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Employee")
@NamedEntityGraph(name = "employee.projects",
	attributeNodes = @NamedAttributeNode("projects")
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Employee employee = entityManager.find(
	Employee.class,
	userId,
	Collections.singletonMap(
		"javax.persistence.fetchgraph",
		entityManager.getEntityGraph( "employee.projects" )
	)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管JPA标准指定您可以使用以下命令在运行时覆盖EAGER提取关联<code>javax.persistence.fetchgraph</code>提示，当前，Hibernate没有实现此功能，因此不能懒惰地获取EAGER关联。有关更多信息，请查看<a href="https://hibernate.atlassian.net/browse/HHH-8776">HHH-8776</a> Jira问题。</p>
</div>
<div class="paragraph">
<p>当执行JPQL查询时，如果省略EAGER关联，则Hibernate将为需要急切获取的每个关联发出辅助选择，这可能导致N + 1查询问题。</p>
</div>
<div class="paragraph">
<p>出于这个原因，最好使用LAZY关联，并且仅在每个查询的基础上热切地获取它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>EntityGraph是“加载计划”的根，并且必须与EntityType相对应。</p>
</div>
<div class="sect3">
<h4 id="fetching-strategies-dynamic-fetching-entity-subgraph"><a class="anchor" href="#fetching-strategies-dynamic-fetching-entity-subgraph"></a> 11.6.1。JPA（关键）子图</h4>
<div class="paragraph">
<p>子图用于控制对其应用的AttributeNode的子属性的获取。通常是通过<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedSubgraph.html"><code>@NamedSubgraph</code></a>注解。</p>
</div>
<div class="paragraph">
<p>如果我们有一个<code>Project</code>具有一个<code>employees</code>儿童协会，我们想获取<code>department</code>为了<code>Employee</code>儿童协会。</p>
</div>
<div id="fetching-strategies-dynamic-fetching-entity-subgraph-mapping-example" class="exampleblock">
<div class="title">示例411。使用子图映射获取图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Project")
@NamedEntityGraph(name = "project.employees",
	attributeNodes = @NamedAttributeNode(
		value = "employees",
		subgraph = "project.employees.department"
	),
	subgraphs = @NamedSubgraph(
		name = "project.employees.department",
		attributeNodes = @NamedAttributeNode( "department" )
	)
)
public static class Project {

	@Id
	private Long id;

	@ManyToMany
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取该实体图时，Hibernate生成以下SQL查询：</p>
</div>
<div id="fetching-strategies-dynamic-fetching-entity-subgraph-example" class="exampleblock">
<div class="title">示例412使用子图映射获取图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Project project = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	return entityManager.find(
		Project.class,
		1L,
		Collections.singletonMap(
			"javax.persistence.fetchgraph",
			entityManager.getEntityGraph( "project.employees" )
		)
	);
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    p.id as id1_2_0_, e.id as id1_1_1_, d.id as id1_0_2_,
    e.accessLevel as accessLe2_1_1_,
    e.department_id as departme5_1_1_,
    decrypt( 'AES', '00', e.pswd  ) as pswd3_1_1_,
    e.username as username4_1_1_,
    p_e.projects_id as projects1_3_0__,
    p_e.employees_id as employee2_3_0__
from
    Project p
inner join
    Project_Employee p_e
        on p.id=p_e.projects_id
inner join
    Employee e
        on p_e.employees_id=e.id
inner join
    Department d
        on e.department_id=d.id
where
    p.id = ?

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>指定子图仅对类型为ManagedType的属性（或其“键”）有效。因此，尽管EntityGraph必须对应于EntityType，但是Subgraph对于任何ManagedType都是合法的。属性的键定义为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于单个属性，该属性的类型必须为IdentifiableType，并且该IdentifiableType必须具有复合标识符。“关键子图”应用于标识符类型。非关键子图适用于属性的值，该值必须是ManagedType。</p>
</li>
<li>
<p>对于复数属性，该属性必须是Map，并且Map的键值必须是ManagedType。“键子图”将应用于地图的键类型。在这种情况下，非关键子图适用于复数属性的值/元素。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="fetching-strategies-dynamic-fetching-entity-subgraph-subtype"><a class="anchor" href="#fetching-strategies-dynamic-fetching-entity-subgraph-subtype"></a> 11.6.2。JPA SubGraph子类型</h4>
<div class="paragraph">
<p>子图也可以是特定于子类型的。给定一个属性值为继承层次的属性，我们可以使用接受子类型Class的子图定义形式来引用特定子类型的属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="fetching-strategies-dynamic-fetching-entity-graph-parsing"><a class="anchor" href="#fetching-strategies-dynamic-fetching-entity-graph-parsing"></a> 11.6.3。通过文本表示创建和应用JPA图</h4>
<div class="paragraph">
<p>Hibernate允许通过解析图的文本表示来创建JPA提取/加载图。一般而言，图形的文本表示形式是属性名称的逗号分隔列表，可选地包括任何子图形规范。
<code>org.hibernate.graph.EntityGraphParser</code>是此类解析操作的起点。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>解析图的文本表示形式（尚未）是JPA规范的一部分。因此，此处描述的语法特定于Hibernate。我们确实希望最终使该语法成为JPA规范的一部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例413解析一个简单的图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">final EntityGraph&lt;Project&gt; graph = GraphParser.parse(
		Project.class,
		"employees( department )",
		entityManager
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例实际上<a href="#fetching-strategies-dynamic-fetching-entity-subgraph-example">与使用子图映射的Fetch图</a>完全一样，仅使用已解析图而不是命名图。</p>
</div>
<div class="paragraph">
<p>该语法还支持定义“关键子图”。要指定关键子图， <code>.key</code>被添加到属性名称的末尾。</p>
</div>
<div class="exampleblock">
<div class="title">实施例414。解析实体键图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">final EntityGraph&lt;Movie&gt; graph = GraphParser.parse(
		Movie.class,
		"cast.key( name )",
		entityManager
);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例415解析地图关键图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">final EntityGraph&lt;Ticket&gt; graph = GraphParser.parse(
		Ticket.class,
		"showing.key( movie( cast ) )",
		entityManager
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解析还可以处理特定于子类型的子图。例如，给定的实体层次结构为<code>LegalEntity</code> ←（ <code>Corporation</code> | <code>Person</code> | <code>NonProfit</code> ）和一个名为<code>responsibleParty</code>其类型是<code>LegalEntity</code>我们可能有的基本类型：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">responsibleParty(Corporation: ceo)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们甚至可以复制属性名称以应用不同的子类型子图：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">responsibleParty(taxIdNumber), responsibleParty(Corporation: ceo), responsibleParty(NonProfit: sector)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>重复的属性名称是根据JPA规范进行处理的，JPA规范指出，属性节点的重复规范会导致原始注册的AttributeNode被重新使用，从而有效地将2个AttributeNode规范合并在一起。换句话说，以上规范创建了具有3个不同的SubGraphs的单个AttributeNode。它在功能上与调用相同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Class&lt;Invoice&gt; invoiceClass = ...;
javax.persistence.EntityGraph&lt;Invoice&gt; invoiceGraph = entityManager.createEntityGraph( invoiceClass );
invoiceGraph.addAttributeNode( "responsibleParty" );
invoiceGraph.addSubgraph( "responsibleParty" ).addAttributeNode( "taxIdNumber" );
invoiceGraph.addSubgraph( "responsibleParty", Corporation.class ).addAttributeNode( "ceo" );
invoiceGraph.addSubgraph( "responsibleParty", NonProfit.class ).addAttributeNode( "sector" );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fetching-strategies-dynamic-fetching-entity-graph-merging"><a class="anchor" href="#fetching-strategies-dynamic-fetching-entity-graph-merging"></a> 11.6.4。将多个JPA实体图组合成一个</h4>
<div class="paragraph">
<p>可以将多个实体图组合成一个充当联合的单个“超级图”。也可以通过将单独的方面图组合成一个来构建上一个示例中的图，例如：</p>
</div>
<div class="exampleblock">
<div class="title">示例416。将多个图合并为一个</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">final EntityGraph&lt;Project&gt; a = GraphParser.parse(
		Project.class, "employees( username )", entityManager
);

final EntityGraph&lt;Project&gt; b = GraphParser.parse(
		Project.class, "employees( password, accessLevel )", entityManager
);

final EntityGraph&lt;Project&gt; c = GraphParser.parse(
		Project.class, "employees( department( employees( username ) ) )", entityManager
);

final EntityGraph&lt;Project&gt; all = EntityGraphs.merge( entityManager, Project.class, a, b, c );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fetching-strategies-dynamic-fetching-profile"><a class="anchor" href="#fetching-strategies-dynamic-fetching-profile"></a> 11.7。通过Hibernate配置文件动态获取</h3>
<div class="paragraph">
<p>假设我们想利用natural-id加载以获取<code>Employee</code> “用于员工的项目”用例中的信息。通过natural-id加载使用静态定义的获取策略，但未提供定义负载特定的获取的方法。因此，我们将利用提取配置文件。</p>
</div>
<div id="fetching-strategies-dynamic-fetching-profile-example" class="exampleblock">
<div class="title">例子417。提取配置文件示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Employee")
@FetchProfile(
	name = "employee.projects",
	fetchOverrides = {
		@FetchProfile.FetchOverride(
			entity = Employee.class,
			association = "projects",
			mode = FetchMode.JOIN
		)
	}
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">session.enableFetchProfile( "employee.projects" );
Employee employee = session.bySimpleNaturalId( Employee.class ).load( username );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里<code>Employee</code>是通过自然ID查找和员工的<code>Project</code>急切地获取数据。如果<code>Employee</code>数据是从缓存中解析的， <code>Project</code>数据自行解决。但是，如果<code>Employee</code>数据未在缓存中解析， <code>Employee</code>和<code>Project</code>如上所见，通过联接在一个SQL查询中解析了数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="fetching-batch"><a class="anchor" href="#fetching-batch"></a> 11.8。批量提取</h3>
<div class="paragraph">
<p>Hibernate提供了<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/BatchSize.html"><code>@BatchSize</code></a>批注，可在获取未初始化的实体代理时使用。</p>
</div>
<div class="paragraph">
<p>考虑以下实体映射：</p>
</div>
<div id="fetching-batch-mapping-example" class="exampleblock">
<div class="title">实施例418。 <code>@BatchSize</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Department")
public static class Department {

	@Id
	private Long id;

	@OneToMany(mappedBy = "department")
	//@BatchSize(size = 5)
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity

}

@Entity(name = "Employee")
public static class Employee {

	@Id
	private Long id;

	@NaturalId
	private String name;

	@ManyToOne(fetch = FetchType.LAZY)
	private Department department;

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑到我们以前已经获取了几个<code>Department</code>实体，现在我们需要初始化<code>employees</code>每个特定实体的集合<code>Department</code> ， <code>@BatchSize</code>批注允许我们加载多个<code>Employee</code>一次数据库往返中的所有实体。</p>
</div>
<div id="fetching-batch-fetching-example" class="exampleblock">
<div class="title">示例419。 <code>@BatchSize</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Department&gt; departments = entityManager.createQuery(
	"select d " +
	"from Department d " +
	"inner join d.employees e " +
	"where e.name like 'John%'", Department.class)
.getResultList();

for ( Department department : departments ) {
	log.infof(
		"Department %d has {} employees",
		department.getId(),
		department.getEmployees().size()
	);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    d.id as id1_0_
FROM
    Department d
INNER JOIN
    Employee employees1_
    ON d.id=employees1_.department_id

SELECT
    e.department_id as departme3_1_1_,
    e.id as id1_1_1_,
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.name as name2_1_0_
FROM
    Employee e
WHERE
    e.department_id IN (
        0, 2, 3, 4, 5
    )

SELECT
    e.department_id as departme3_1_1_,
    e.id as id1_1_1_,
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.name as name2_1_0_
FROM
    Employee e
WHERE
    e.department_id IN (
        6, 7, 8, 9, 1
    )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上例所示，只有两个SQL语句用于获取<code>Employee</code>与多个关联的实体<code>Department</code>实体。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不带<code>@BatchSize</code> ，您会遇到N + 1查询问题，因此，除了2条SQL语句外，还需要10条查询来获取<code>Employee</code>子实体。</p>
</div>
<div class="paragraph">
<p>然而，尽管<code>@BatchSize</code>通常比遇到N + 1查询问题更好，例如DTO投影或<code>JOIN FETCH</code>是一个更好的选择，因为它允许您通过单个查询获取所有必需的数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="fetching-fetch-annotation"><a class="anchor" href="#fetching-fetch-annotation"></a> 11.9。的<code>@Fetch</code>注释映射</h3>
<div class="paragraph">
<p>除了<code>FetchType.LAZY</code>要么<code>FetchType.EAGER</code> JPA批注，您还可以使用特定于Hibernate的注释<code>@Fetch</code>注释接受以下之一<code>FetchMode(s)</code> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">选择</dt>
<dd>
<p>对于每个单独的实体，集合或联接负载，将使用辅助选择来延迟获取关联。相当于JPA <code>FetchType.LAZY</code>获取策略。</p>
</dd>
<dt class="hdlist1">加入</dt>
<dd>
<p>使用直接获取时，请使用外部联接加载相关的实体，集合或联接。相当于JPA <code>FetchType.EAGER</code>获取策略。</p>
</dd>
<dt class="hdlist1">子选择</dt>
<dd>
<p>仅适用于收藏集。当访问未初始化的集合时，此提取模式将触发使用单个辅助选择为与持久性上下文关联的所有所有者加载具有相同角色的所有集合的所有元素。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="fetching-fetchmode-select"><a class="anchor" href="#fetching-fetchmode-select"></a> 11.10。<code>FetchMode.SELECT</code></h3>
<div class="paragraph">
<p>演示如何<code>FetchMode.SELECT</code>工作时，请考虑以下实体映射：</p>
</div>
<div id="fetching-strategies-fetch-mode-select-mapping-example" class="exampleblock">
<div class="title">示例420 <code>FetchMode.SELECT</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Department")
public static class Department {

	@Id
	private Long id;

	@OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
	@Fetch(FetchMode.SELECT)
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity

}

@Entity(name = "Employee")
public static class Employee {

	@Id
	@GeneratedValue
	private Long id;

	@NaturalId
	private String username;

	@ManyToOne(fetch = FetchType.LAZY)
	private Department department;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑到有多个<code>Department</code>实体，每个实体都有多个<code>Employee</code>实体，在执行以下测试用例时，Hibernate会获取每个未初始化的<code>Employee</code>使用辅助收集<code>SELECT</code>首次访问子集合时的声明：</p>
</div>
<div id="fetching-strategies-fetch-mode-select-example" class="exampleblock">
<div class="title">示例421。 <code>FetchMode.SELECT</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Department&gt; departments = entityManager.createQuery(
	"select d from Department d", Department.class )
.getResultList();

log.infof( "Fetched %d Departments", departments.size());

for (Department department : departments ) {
	assertEquals( 3, department.getEmployees().size() );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    d.id as id1_0_
FROM
    Department d

-- Fetched 2 Departments

SELECT
    e.department_id as departme3_1_0_,
    e.id as id1_1_0_,
    e.id as id1_1_1_,
    e.department_id as departme3_1_1_,
    e.username as username2_1_1_
FROM
    Employee e
WHERE
    e.department_id = 1

SELECT
    e.department_id as departme3_1_0_,
    e.id as id1_1_0_,
    e.id as id1_1_1_,
    e.department_id as departme3_1_1_,
    e.username as username2_1_1_
FROM
    Employee e
WHERE
    e.department_id = 2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>越多<code>Department</code>实体由第一个查询获取，第二个查询获取更多<code>SELECT</code>执行语句以初始化<code>employees</code>集合。因此， <code>FetchMode.SELECT</code>可能导致N + 1查询问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="fetching-fetchmode-subselect"><a class="anchor" href="#fetching-fetchmode-subselect"></a> 11.11。<code>FetchMode.SUBSELECT</code></h3>
<div class="paragraph">
<p>演示如何<code>FetchMode.SUBSELECT</code>可行，我们将修改<a href="#fetching-strategies-fetch-mode-select-mapping-example"><code>FetchMode.SELECT</code></a>使用的<a href="#fetching-strategies-fetch-mode-select-mapping-example">映射示例</a> <code>FetchMode.SUBSELECT</code> ：</p>
</div>
<div id="fetching-strategies-fetch-mode-subselect-mapping-example" class="exampleblock">
<div class="title">示例422 <code>FetchMode.SUBSELECT</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
@Fetch(FetchMode.SUBSELECT)
private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们将获取所有<code>Department</code>匹配给定过滤谓词的实体，然后浏览其<code>employees</code>集合。</p>
</div>
<div class="paragraph">
<p>Hibernate将通过生成单个SQL语句初始化所有N + 1来避免N + 1查询问题<code>employees</code>全部收藏<code>Department</code>先前获取的实体。Hibernate不用重新传递所有实体标识符，而只是重新运行获取了<code>Department</code>实体。</p>
</div>
<div id="fetching-strategies-fetch-mode-subselect-example" class="exampleblock">
<div class="title">示例423 <code>FetchMode.SUBSELECT</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Department&gt; departments = entityManager.createQuery(
	"select d " +
	"from Department d " +
	"where d.name like :token", Department.class )
.setParameter( "token", "Department%" )
.getResultList();

log.infof( "Fetched %d Departments", departments.size());

for (Department department : departments ) {
	assertEquals( 3, department.getEmployees().size() );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    d.id as id1_0_
FROM
    Department d
where
    d.name like 'Department%'

-- Fetched 2 Departments

SELECT
    e.department_id as departme3_1_1_,
    e.id as id1_1_1_,
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.username as username2_1_0_
FROM
    Employee e
WHERE
    e.department_id in (
        SELECT
            fetchmodes0_.id
        FROM
            Department fetchmodes0_
        WHERE
            d.name like 'Department%'
    )</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fetching-fetchmode-join"><a class="anchor" href="#fetching-fetchmode-join"></a> 11.12。<code>FetchMode.JOIN</code></h3>
<div class="paragraph">
<p>演示如何<code>FetchMode.JOIN</code>可行，我们将修改<a href="#fetching-strategies-fetch-mode-select-mapping-example"><code>FetchMode.SELECT</code></a>使用的<a href="#fetching-strategies-fetch-mode-select-mapping-example">映射示例</a> <code>FetchMode.JOIN</code>代替：</p>
</div>
<div id="fetching-strategies-fetch-mode-join-mapping-example" class="exampleblock">
<div class="title">示例424 <code>FetchMode.JOIN</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@OneToMany(mappedBy = "department")
@Fetch(FetchMode.JOIN)
private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们要获取一个<code>Department</code>并浏览其<code>employees</code>集合。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>我们之所以不使用JPQL查询来获取多个的原因<code>Department</code>实体是因为<code>FetchMode.JOIN</code>查询提取指令将覆盖该策略。</p>
</div>
<div class="paragraph">
<p>要通过JPQL查询获取多个关系， <code>JOIN FETCH</code>必须使用伪指令代替。</p>
</div>
<div class="paragraph">
<p>因此， <code>FetchMode.JOIN</code>通过实体的标识符或自然ID直接获取实体时，此功能很有用。</p>
</div>
<div class="paragraph">
<p>另外， <code>FetchMode.JOIN</code>充当<code>FetchType.EAGER</code>战略。即使我们将关联标记为<code>FetchType.LAZY</code> ， <code>FetchMode.JOIN</code>会尽快加载该关联。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate将通过发出OUTER JOIN来避免二级查询。 <code>employees</code>采集。</p>
</div>
<div id="fetching-strategies-fetch-mode-join-example" class="exampleblock">
<div class="title">示例425 <code>FetchMode.JOIN</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Department department = entityManager.find( Department.class, 1L );

log.infof( "Fetched department: %s", department.getId());

assertEquals( 3, department.getEmployees().size() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    d.id as id1_0_0_,
    e.department_id as departme3_1_1_,
    e.id as id1_1_1_,
    e.id as id1_1_2_,
    e.department_id as departme3_1_2_,
    e.username as username2_1_2_
FROM
    Department d
LEFT OUTER JOIN
    Employee e
        on d.id = e.department_id
WHERE
    d.id = 1

-- Fetched department: 1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这次没有辅助查询，因为子集合与父实体一起加载。</p>
</div>
</div>
<div class="sect2">
<h3 id="fetching-LazyCollection"><a class="anchor" href="#fetching-LazyCollection"></a> 11.13。<code>@LazyCollection</code></h3>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyCollection.html"><code>@LazyCollection</code></a>批注用于指定给定集合的延迟获取行为。可能的值由<code><a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyCollectionOption.html">LazyCollectionOption</a></code>列举：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>TRUE</code></dt>
<dd>
<p>在请求状态时加载它。</p>
</dd>
<dt class="hdlist1"><code>FALSE</code></dt>
<dd>
<p>认真加载它。</p>
</dd>
<dt class="hdlist1"><code>EXTRA</code></dt>
<dd>
<p>优先选择额外的查询而不是完整的集合加载。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>的<code>TRUE</code>和<code>FALSE</code>值已弃用，因为您应该使用JPA <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/FetchType.html"><code>FetchType</code></a>的属性<a href="#annotations-jpa-elementcollection"><code>@ElementCollection</code></a> ， <a href="#annotations-jpa-onetomany"><code>@OneToMany</code></a> ， 要么<a href="#annotations-jpa-manytomany"><code>@ManyToMany</code></a>采集。</p>
</div>
<div class="paragraph">
<p>的<code>EXTRA</code>值在JPA规范中没有等效项，即使在首次访问该集合时，它也可以避免加载整个集合。使用辅助查询分别获取每个元素。</p>
</div>
<div id="fetching-LazyCollection-domain-model-example" class="exampleblock">
<div class="title">示例426 <code>LazyCollectionOption.EXTRA</code>映射示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Department")
public static class Department {

	@Id
	private Long id;

	@OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
	@OrderColumn(name = "order_id")
	@LazyCollection( LazyCollectionOption.EXTRA )
	private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

	//Getters and setters omitted for brevity

}

@Entity(name = "Employee")
public static class Employee {

	@Id
	private Long id;

	@NaturalId
	private String username;

	@ManyToOne(fetch = FetchType.LAZY)
	private Department department;

	//Getters and setters omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>LazyCollectionOption.EXTRA</code>仅适用于有序集合，使用@OrderColumn注释的List或Map。</p>
</div>
<div class="paragraph">
<p>对于包（例如不保留任何特定顺序的常规实体列表），@ LazyCollection（LazyCollectionOption）。EXTRA）`的行为与其他任何行为一样<code>FetchType.LAZY</code>集合（在首次访问时完全获取了集合）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，考虑到我们具有以下实体：</p>
</div>
<div id="fetching-LazyCollection-persist-example" class="exampleblock">
<div class="title">示例427 <code>LazyCollectionOption.EXTRA</code> 域模型示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Department department = new Department();
department.setId( 1L );
entityManager.persist( department );

for (long i = 1; i &lt;= 3; i++ ) {
	Employee employee = new Employee();
	employee.setId( i );
	employee.setUsername( String.format( "user_%d", i ) );
	department.addEmployee(employee);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取<code>employee</code>集合条目在它们中的位置<code>List</code> ，Hibernate生成以下SQL语句：</p>
</div>
<div id="fetching-LazyCollection-select-example" class="exampleblock">
<div class="title">示例428 <code>LazyCollectionOption.EXTRA</code>取得范例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Department department = entityManager.find(Department.class, 1L);

int employeeCount = department.getEmployees().size();

for(int i = 0; i &lt; employeeCount; i++ ) {
	log.infof( "Fetched employee: %s", department.getEmployees().get( i ).getUsername());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    max(order_id) + 1
FROM
    Employee
WHERE
    department_id = ?

-- binding parameter [1] as [BIGINT] - [1]

SELECT
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.username as username2_1_0_
FROM
    Employee e
WHERE
    e.department_id=?
    AND e.order_id=?

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [INTEGER] - [0]

SELECT
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.username as username2_1_0_
FROM
    Employee e
WHERE
    e.department_id=?
    AND e.order_id=?

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [INTEGER] - [1]

SELECT
    e.id as id1_1_0_,
    e.department_id as departme3_1_0_,
    e.username as username2_1_0_
FROM
    Employee e
WHERE
    e.department_id=?
    AND e.order_id=?

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [INTEGER] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因此，子实体是一个接一个地获取的，而不触发完整的集合初始化。</p>
</div>
<div class="paragraph">
<p>因此，建议谨慎使用，因为使用<code>LazyCollectionOption.EXTRA</code>可能导致N + 1查询问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="batch"><a class="anchor" href="#batch"></a> 12批处理</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="batch-jdbcbatch"><a class="anchor" href="#batch-jdbcbatch"></a> 12.1。JDBC批处理</h3>
<div class="paragraph">
<p>JDBC提供了对可一起表示为单个PreparedStatement的SQL语句进行批处理的支持。在实现方面，这通常意味着驱动程序将在一次调用中将批处理操作发送到服务器，这可以节省对数据库的网络调用。Hibernate可以利用JDBC批处理。以下设置控制此行为。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.jdbc.batch_size</code></dt>
<dd>
<p>控制Hibernate在要求驱动程序执行批处理之前将批处理在一起的最大语句数。零或负数将禁用此功能。</p>
</dd>
<dt class="hdlist1"><code>hibernate.jdbc.batch_versioned_data</code></dt>
<dd>
<p>执行批处理时，某些JDBC驱动程序返回不正确的行数。如果您的JDBC驱动程序属于此类别，则应将此设置设置为<code>false</code> 。否则，可以安全地启用此功能，这将使Hibernate仍可以为版本控制的实体批处理DML，并且仍将返回的行数用于乐观锁检查。从5.0开始，它默认为true。以前（版本3.x和4.x），它曾经是false。</p>
</dd>
<dt class="hdlist1"><code>hibernate.jdbc.batch.builder</code></dt>
<dd>
<p>命名用于管理批处理功能的实现类。从Hibernate的默认实现切换几乎从来不是一个好主意。但是，如果您愿意，此设置将命名为<code>org.hibernate.engine.jdbc.batch.spi.BatchBuilder</code>实施使用。</p>
</dd>
<dt class="hdlist1"><code>hibernate.order_updates</code></dt>
<dd>
<p>强制Hibernate按实体类型和要更新的项目的主键值对SQL更新进行排序。这允许使用更多的批处理。在高度并发的系统中，这还将导致较少的事务死锁。它会带来性能上的损失，因此请在进行基准测试之前和之后进行测试，看看这是否对您的应用程序有帮助或损害。</p>
</dd>
<dt class="hdlist1"><code>hibernate.order_inserts</code></dt>
<dd>
<p>强制Hibernate命令插入，以允许使用更多批处理。它会带来性能上的损失，因此请在进行基准测试之前和之后进行测试，看看这是否对您的应用程序有帮助或损害。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从5.2版开始，Hibernate允许覆盖由JDBC提供的全局JDBC批处理大小。 <code>hibernate.jdbc.batch_size</code>每个配置属性<code>Session</code>基础。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="batch-session-jdbc-batch-size-example" class="exampleblock">
<div class="title">示例429。每个Hibernate特定的JDBC批处理大小配置<code>Session</code>基础</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager
	.unwrap( Session.class )
	.setJdbcBatchSize( 10 );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="batch-session-batch"><a class="anchor" href="#batch-session-batch"></a> 12.2。会话批处理</h3>
<div class="paragraph">
<p>以下示例显示了批处理插入的反模式。</p>
</div>
<div id="batch-session-batch-example" class="exampleblock">
<div class="title">示例430使用Hibernate插入10万个实体的简单方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager entityManager = null;
EntityTransaction txn = null;
try {
	entityManager = entityManagerFactory().createEntityManager();

	txn = entityManager.getTransaction();
	txn.begin();

	for ( int i = 0; i &lt; 100_000; i++ ) {
		Person Person = new Person( String.format( "Person %d", i ) );
		entityManager.persist( Person );
	}

	txn.commit();
} catch (RuntimeException e) {
	if ( txn != null &amp;&amp; txn.isActive()) txn.rollback();
		throw e;
} finally {
	if (entityManager != null) {
		entityManager.close();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此示例存在几个问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hibernate缓存所有新插入的<code>Customer</code>会话级实例中的实例，因此，当事务结束时，持久性上下文将管理100 000个实体。如果分配给JVM的最大内存很小，则此示例可能会失败，并显示<code>OutOfMemoryException</code> 。Java 1.8 JVM分配了1/4的可用RAM或1Gb，可以轻松地在堆上容纳10万个对象。</p>
</li>
<li>
<p>长时间运行的事务可能会耗尽连接池，因此其他事务没有机会继续进行。</p>
</li>
<li>
<p>默认情况下，不启用JDBC批处理，因此每个insert语句都需要数据库往返。要启用JDBC批处理，请设置<code>hibernate.jdbc.batch_size</code>属性设置为10到50之间的整数。</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果使用身份标识符生成器，则Hibernate透明地在JDBC级别禁用插入批处理。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="batch-session-batch-insert"><a class="anchor" href="#batch-session-batch-insert"></a> 12.2.1。批量插入</h4>
<div class="paragraph">
<p>当使新对象持久化时，采用方法<code>flush()</code>和<code>clear()</code>定期访问会话，以控制第一级缓存的大小。</p>
</div>
<div id="batch-session-batch-insert-example" class="exampleblock">
<div class="title">示例431冲洗并清除<code>Session</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager entityManager = null;
EntityTransaction txn = null;
try {
	entityManager = entityManagerFactory().createEntityManager();

	txn = entityManager.getTransaction();
	txn.begin();

	int batchSize = 25;

	for ( int i = 0; i &lt; entityCount; i++ ) {
		if ( i &gt; 0 &amp;&amp; i % batchSize == 0 ) {
			//flush a batch of inserts and release memory
			entityManager.flush();
			entityManager.clear();
		}

		Person Person = new Person( String.format( "Person %d", i ) );
		entityManager.persist( Person );
	}

	txn.commit();
} catch (RuntimeException e) {
	if ( txn != null &amp;&amp; txn.isActive()) txn.rollback();
		throw e;
} finally {
	if (entityManager != null) {
		entityManager.close();
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="batch-session-scroll"><a class="anchor" href="#batch-session-scroll"></a> 12.2.2。会话滚动</h4>
<div class="paragraph">
<p>当您检索和更新数据时， <code>flush()</code>和<code>clear()</code>定期开会。另外，使用方法<code>scroll()</code>利用服务器端游标进行查询以返回许多数据行。</p>
</div>
<div id="batch-session-scroll-example" class="exampleblock">
<div class="title">示例432使用<code>scroll()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager entityManager = null;
EntityTransaction txn = null;
ScrollableResults scrollableResults = null;
try {
	entityManager = entityManagerFactory().createEntityManager();

	txn = entityManager.getTransaction();
	txn.begin();

	int batchSize = 25;

	Session session = entityManager.unwrap( Session.class );

	scrollableResults = session
		.createQuery( "select p from Person p" )
		.setCacheMode( CacheMode.IGNORE )
		.scroll( ScrollMode.FORWARD_ONLY );

	int count = 0;
	while ( scrollableResults.next() ) {
		Person Person = (Person) scrollableResults.get( 0 );
		processPerson(Person);
		if ( ++count % batchSize == 0 ) {
			//flush a batch of updates and release memory:
			entityManager.flush();
			entityManager.clear();
		}
	}

	txn.commit();
} catch (RuntimeException e) {
	if ( txn != null &amp;&amp; txn.isActive()) txn.rollback();
		throw e;
} finally {
	if (scrollableResults != null) {
		scrollableResults.close();
	}
	if (entityManager != null) {
		entityManager.close();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果应用程序未关闭，则Hibernate将自动关闭基础资源（例如， <code>ResultSet</code>和<code>PreparedStatement</code> ）由内部使用<code>ScrollableResults</code>当前事务结束时（提交或回滚）。</p>
</div>
<div class="paragraph">
<p>但是，最好关闭<code>ScrollableResults</code>明确地。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_statelesssession"><a class="anchor" href="#_statelesssession"></a> 12.2.3。无状态会话</h4>
<div class="paragraph">
<p><code>StatelessSession</code>是Hibernate提供的面向命令的API。使用它以分离对象的形式在数据库之间传输数据。一种<code>StatelessSession</code>没有与之关联的持久性上下文，并且不提供许多更高级别的生命周期语义。</p>
</div>
<div class="paragraph">
<p>某些未提供的东西<code>StatelessSession</code>包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一级缓存</p>
</li>
<li>
<p>与任何第二级或查询缓存的交互</p>
</li>
<li>
<p>事务后写或自动脏检查</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>局限性<code>StatelessSession</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用无状态会话执行的操作永远不会级联到关联的实例。</p>
</li>
<li>
<p>无状态会话将忽略集合。</p>
</li>
<li>
<p>不支持延迟加载关联。</p>
</li>
<li>
<p>通过无状态会话执行的操作会绕过Hibernate的事件模型和拦截器。</p>
</li>
<li>
<p>由于缺少第一级缓存，无状态会话容易受到数据别名效应的影响。</p>
</li>
<li>
<p>无状态会话是更底层的JDBC，它更接近底层JDBC。</p>
</li>
</ul>
</div>
<div id="batch-stateless-session-example" class="exampleblock">
<div class="title">示例433用一个<code>StatelessSession</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StatelessSession statelessSession = null;
Transaction txn = null;
ScrollableResults scrollableResults = null;
try {
	SessionFactory sessionFactory = entityManagerFactory().unwrap( SessionFactory.class );
	statelessSession = sessionFactory.openStatelessSession();

	txn = statelessSession.getTransaction();
	txn.begin();

	scrollableResults = statelessSession
		.createQuery( "select p from Person p" )
		.scroll(ScrollMode.FORWARD_ONLY);

	while ( scrollableResults.next() ) {
		Person Person = (Person) scrollableResults.get( 0 );
		processPerson(Person);
		statelessSession.update( Person );
	}

	txn.commit();
} catch (RuntimeException e) {
	if ( txn != null &amp;&amp; txn.getStatus() == TransactionStatus.ACTIVE) txn.rollback();
		throw e;
} finally {
	if (scrollableResults != null) {
		scrollableResults.close();
	}
	if (statelessSession != null) {
		statelessSession.close();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>Customer</code>查询返回的实例将立即分离。它们从不与任何持久性上下文相关联。</p>
</div>
<div class="paragraph">
<p>的<code>insert()</code> ， <code>update()</code>和<code>delete()</code>由操作定义<code>StatelessSession</code>接口直接对数据库行进行操作。它们导致相应的SQL操作立即执行。它们的语义与<code>save()</code> ， <code>saveOrUpdate()</code>和<code>delete()</code>由操作定义<code>Session</code>接口。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="batch-bulk-hql"><a class="anchor" href="#batch-bulk-hql"></a> 12.3。DML的Hibernate查询语言</h3>
<div class="paragraph">
<p>DML或数据处理语言，指的是SQL语句，例如<code>INSERT</code> ， <code>UPDATE</code>和<code>DELETE</code> 。Hibernate以Hibernate查询语言（HQL）的形式提供了用于批量SQL风格DML语句执行的方法。</p>
</div>
<div class="sect3">
<h4 id="batch-bulk-hql-update-delete"><a class="anchor" href="#batch-bulk-hql-update-delete"></a> 12.3.1。HQL / JPQL用于更新和删除</h4>
<div class="paragraph">
<p>Hibernate本机查询语言和JPQL（Java持久性查询语言）均支持批量UPDATE和DELETE。</p>
</div>
<div id="batch-bulk-hql-update-delete-example" class="exampleblock">
<div class="title">示例434使用HQL的UPDATE和DELETE语句的伪语法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">UPDATE FROM EntityName e WHERE e.name = ?

DELETE FROM EntityName e WHERE e.name = ?</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然<code>FROM</code>和<code>WHERE</code>子句是可选的，优良作法是明确声明它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>FROM</code>子句只能引用可以别名的单个实体。如果实体名称是别名，则任何属性引用都必须使用该别名进行限定。如果实体名称没有别名，则对任何属性引用进行限定都是非法的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>批量HQL查询中禁止使用隐式或显式联接。您可以在<code>WHERE</code>子句，子查询本身可以包含联接。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="batch-bulk-jpql-update-example" class="exampleblock">
<div class="title">示例435执行JPQL <code>UPDATE</code> ， 使用<code>Query.executeUpdate()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int updatedEntities = entityManager.createQuery(
	"update Person p " +
	"set p.name = :newName " +
	"where p.name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div id="batch-bulk-hql-update-example" class="exampleblock">
<div class="title">示例436执行HQL <code>UPDATE</code> ， 使用<code>Query.executeUpdate()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int updatedEntities = session.createQuery(
	"update Person " +
	"set name = :newName " +
	"where name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了符合EJB3规范，HQL <code>UPDATE</code>缺省情况下，这些语句不影响受影响实体的版本或时间戳属性值。您可以使用版本更新来强制Hibernate通过添加以下内容来重置版本或时间戳属性值： <code>VERSIONED</code>之后的关键字<code>UPDATE</code>关键词。</p>
</div>
<div id="batch-bulk-hql-update-version-example" class="exampleblock">
<div class="title">示例437更新时间戳版本</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int updatedEntities = session.createQuery(
	"update versioned Person " +
	"set name = :newName " +
	"where name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您使用<code>VERSIONED</code>语句，您不能使用实现<code>org.hibernate.usertype.UserVersionType</code> 。</p>
</div>
<div class="paragraph">
<p>该功能仅在HQL中可用，因为JPA尚未对其进行标准化。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="batch-bulk-jpql-delete-example" class="exampleblock">
<div class="title">示例438JPQL <code>DELETE</code>声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int deletedEntities = entityManager.createQuery(
	"delete Person p " +
	"where p.name = :name" )
.setParameter( "name", name )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div id="batch-bulk-hql-delete-example" class="exampleblock">
<div class="title">示例439HQL <code>DELETE</code>声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int deletedEntities = session.createQuery(
	"delete Person " +
	"where name = :name" )
.setParameter( "name", name )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>方法<code>Query.executeUpdate()</code>返回一个<code>int</code>值，指示受操作影响的实体数。这可能与数据库中受影响的行数相关或不相关。JPQL / HQL批量操作可能会导致执行多个SQL语句，例如joined-subclass。在joined-subclass的示例中， <code>DELETE</code>子类之一的冲突实际上可能导致联接基础表中的删除，或者进一步导致继承层次结构的删除。</p>
</div>
</div>
<div class="sect3">
<h4 id="_hql_syntax_for_insert"><a class="anchor" href="#_hql_syntax_for_insert"></a> 12.3.2。INSERT的HQL语法</h4>
<div class="exampleblock">
<div class="title">示例440INSERT语句的伪语法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">INSERT INTO EntityName
	properties_list
SELECT properties_list
FROM ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只有<code>INSERT INTO …​ SELECT …​</code>支持表格。您不能指定要插入的显式值。</p>
</div>
<div class="paragraph">
<p>的<code>properties_list</code>类似于<code>SQL</code><code>INSERT</code>声明。对于涉及映射继承的实体，您只能使用直接在该给定类级别上定义的属性。 <code>properties_list</code> 。不允许超类属性，而子类属性则无关。换一种说法， <code>INSERT</code>语句本质上是非多态的。</p>
</div>
<div class="paragraph">
<p>SELECT语句可以是任何有效的HQL选择查询，但是返回类型必须与INSERT期望的类型匹配。 Hibernate在查询编译期间验证返回类型，而不是期望数据库对其进行检查。问题可能是由相等而不是相等的Hibernate类型引起的。一个这样的例子是定义为<code>org.hibernate.type.DateType</code>和一个定义为<code>org.hibernate.type.TimestampType</code> ，即使数据库可能没有区别，或者可能能够处理转换。</p>
</div>
<div class="paragraph">
<p>如果未在其中指定id属性<code>properties_list</code> ，Hibernate自动生成一个值。仅当使用在数据库上运行的ID生成器时，自动生成才可用。否则，Hibernate在解析过程中将引发异常。可用的数据库内生成器是<code>org.hibernate.id.SequenceGenerator</code>及其子类，以及实现的对象<code>org.hibernate.id.PostInsertIdentifierGenerator</code> 。</p>
</div>
<div class="paragraph">
<p>对于映射为版本或时间戳的属性，insert语句为您提供两个选项。您可以在properties_list中指定属性，在这种情况下，其值是从相应的select表达式中获取的，或者在properties_list中将其忽略，在这种情况下，其值是由org.hibernate.type定义的。使用VersionType。</p>
</div>
<div id="batch-bulk-hql-insert-example" class="exampleblock">
<div class="title">示例441HQL INSERT语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int insertedEntities = session.createQuery(
	"insert into Partner (id, name) " +
	"select p.id, p.name " +
	"from Person p ")
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>本节仅是HQL的简要概述。有关更多信息，请参见<a href="#hql">HQL</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="batch-bulk-hql-strategies"><a class="anchor" href="#batch-bulk-hql-strategies"></a> 12.3.3。大量ID策略</h4>
<div class="paragraph">
<p>本文是关于<a href="https://hibernate.atlassian.net/browse/HHH-11262">HHH-11262</a> JIRA问题的，该问题现在允许即使在您无法创建临时表时，批量ID策略也可以工作。</p>
</div>
<div class="sect4">
<h5 id="batch-bulk-hql-strategies-class-diagram"><a class="anchor" href="#batch-bulk-hql-strategies-class-diagram"></a>类图</h5>
<div class="paragraph">
<p>考虑到我们具有以下实体：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/domain/bulkid/temp_table_class_diagram.png" alt="实体类图"></span></p>
</div>
<div class="paragraph">
<p>的<code>Person</code>实体是该实体继承模型的基类，并映射如下：</p>
</div>
<div id="batch-bulk-hql-temp-table-base-class-example" class="exampleblock">
<div class="title">示例442本体ID基本类别实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
@Inheritance(strategy = InheritanceType.JOINED)
public static class Person implements Serializable {

	@Id
	private Integer id;

	@Id
	private String companyName;

	private String name;

	private boolean employed;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这俩<code>Doctor</code>和<code>Engineer</code>实体类扩展了<code>Person</code>基类：</p>
</div>
<div id="batch-bulk-hql-temp-table-sub-classes-example" class="exampleblock">
<div class="title">示例443批量ID子类实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Doctor")
public static class Doctor extends Person {
}

@Entity(name = "Engineer")
public static class Engineer extends Person {

	private boolean fellow;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="batch-bulk-hql-strategies-inheritance-tree"><a class="anchor" href="#batch-bulk-hql-strategies-inheritance-tree"></a>继承树批量处理</h5>
<div class="paragraph">
<p>现在，当您尝试执行批量实体删除查询时：</p>
</div>
<div id="batch-bulk-hql-temp-table-delete-query-example" class="exampleblock">
<div class="title">示例444批量ID删除查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">int updateCount = session.createQuery(
	"delete from Person where employed = :employed" )
.setParameter( "employed", false )
.executeUpdate();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create temporary table
    HT_Person
(
    id int4 not null,
    companyName varchar(255) not null
)

insert
into
    HT_Person
    select
        p.id as id,
        p.companyName as companyName
    from
        Person p
    where
        p.employed = ?

delete
from
    Engineer
where
    (
        id, companyName
    ) IN (
        select
            id,
            companyName
        from
            HT_Person
    )

delete
from
    Doctor
where
    (
        id, companyName
    ) IN (
        select
            id,
            companyName
        from
            HT_Person
    )

delete
from
    Person
where
    (
        id, companyName
    ) IN (
        select
            id,
            companyName
        from
            HT_Person
    )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>HT_Person</code>是一个临时表，Hibernate创建该表以保存将由批量id操作更新或删除的所有实体标识符。临时表可以是全局的也可以是局部的，具体取决于基础数据库的功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="batch-bulk-hql-strategies-non-temporary-table"><a class="anchor" href="#batch-bulk-hql-strategies-non-temporary-table"></a>非临时表批量ID策略</h5>
<div class="paragraph">
<p>正如<a href="https://hibernate.atlassian.net/browse/HHH-11262">HHH-11262</a>问题所描述的，在某些情况下，由于数据库用户缺乏此特权，因此应用程序开发人员无法使用临时表。</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们定义了几个选项，您可以根据数据库功能进行选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InlineIdsInClauseBulkIdStrategy</code></p>
</li>
<li>
<p><code>InlineIdsSubSelectValueListBulkIdStrategy</code></p>
</li>
<li>
<p><code>InlineIdsOrClauseBulkIdStrategy</code></p>
</li>
<li>
<p><code>CteValuesListBulkIdStrategy</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="batch-bulk-hql-strategies-InlineIdsInClauseBulkIdStrategy"><a class="anchor" href="#batch-bulk-hql-strategies-InlineIdsInClauseBulkIdStrategy"></a><code>InlineIdsInClauseBulkIdStrategy</code></h6>
<div class="paragraph">
<p>要使用此策略，您需要配置以下配置属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property name="hibernate.hql.bulk_id_strategy"
          value="org.hibernate.hql.spi.id.inline.InlineIdsInClauseBulkIdStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在运行前面的测试用例时，Hibernate生成以下SQL语句：</p>
</div>
<div id="batch-bulk-hql-InlineIdsInClauseBulkIdStrategy-delete-query-example" class="exampleblock">
<div class="title">示例445 <code>InlineIdsInClauseBulkIdStrategy</code>删除实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    p.id as id,
    p.companyName as companyName
from
    Person p
where
    p.employed = ?

delete
from
    Engineer
where
        ( id, companyName )
    in (
        ( 1,'Red Hat USA' ),
        ( 3,'Red Hat USA' ),
        ( 1,'Red Hat Europe' ),
        ( 3,'Red Hat Europe' )
    )

delete
from
    Doctor
where
        ( id, companyName )
    in (
        ( 1,'Red Hat USA' ),
        ( 3,'Red Hat USA' ),
        ( 1,'Red Hat Europe' ),
        ( 3,'Red Hat Europe' )
    )

delete
from
    Person
where
        ( id, companyName )
    in (
        ( 1,'Red Hat USA' ),
        ( 3,'Red Hat USA' ),
        ( 1,'Red Hat Europe' ),
        ( 3,'Red Hat Europe' )
    )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此，首先选择实体标识符，并将其用于每个特定的更新或删除语句。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>长期以来，Oracle，PostgreSQL一直支持IN子句行值表达式，而如今，MySQL 5.7支持IN子句行值表达式。但是，SQL Server 2014不支持它，因此您必须使用其他策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="batch-bulk-hql-strategies-InlineIdsSubSelectValueListBulkIdStrategy"><a class="anchor" href="#batch-bulk-hql-strategies-InlineIdsSubSelectValueListBulkIdStrategy"></a><code>InlineIdsSubSelectValueListBulkIdStrategy</code></h6>
<div class="paragraph">
<p>要使用此策略，您需要配置以下配置属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property name="hibernate.hql.bulk_id_strategy"
          value="org.hibernate.hql.spi.id.inline.InlineIdsSubSelectValueListBulkIdStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在运行前面的测试用例时，Hibernate生成以下SQL语句：</p>
</div>
<div id="batch-bulk-hql-InlineIdsSubSelectValueListBulkIdStrategy-delete-query-example" class="exampleblock">
<div class="title">示例446 <code>InlineIdsSubSelectValueListBulkIdStrategy</code>删除实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    p.id as id,
    p.companyName as companyName
from
    Person p
where
    p.employed = ?

delete
from
    Engineer
where
    ( id, companyName ) in (
        select
            id,
            companyName
        from (
        values
            ( 1,'Red Hat USA' ),
            ( 3,'Red Hat USA' ),
            ( 1,'Red Hat Europe' ),
            ( 3,'Red Hat Europe' )
        ) as HT
            (id, companyName)
    )

delete
from
    Doctor
where
    ( id, companyName ) in (
         select
            id,
            companyName
        from (
        values
            ( 1,'Red Hat USA' ),
            ( 3,'Red Hat USA' ),
            ( 1,'Red Hat Europe' ),
            ( 3,'Red Hat Europe' )
        ) as HT
            (id, companyName)
    )

delete
from
    Person
where
    ( id, companyName ) in (
        select
            id,
            companyName
        from (
        values
            ( 1,'Red Hat USA' ),
            ( 3,'Red Hat USA' ),
            ( 1,'Red Hat Europe' ),
            ( 3,'Red Hat Europe' )
        ) as HT
            (id, companyName)
    )</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基础数据库必须支持<code>VALUES</code> list子句，例如PostgreSQL或SQL Server 2008。但是，此策略要求复合标识符使用IN子句行值表达式，因此，您只能使用<code>InlineIdsSubSelectValueListBulkIdStrategy</code> PostgreSQL的策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="batch-bulk-hql-strategies-InlineIdsOrClauseBulkIdStrategy"><a class="anchor" href="#batch-bulk-hql-strategies-InlineIdsOrClauseBulkIdStrategy"></a><code>InlineIdsOrClauseBulkIdStrategy</code></h6>
<div class="paragraph">
<p>要使用此策略，您需要配置以下配置属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property name="hibernate.hql.bulk_id_strategy"
          value="org.hibernate.hql.spi.id.inline.InlineIdsOrClauseBulkIdStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在运行前面的测试用例时，Hibernate生成以下SQL语句：</p>
</div>
<div id="batch-bulk-hql-InlineIdsOrClauseBulkIdStrategy-delete-query-example" class="exampleblock">
<div class="title">示例447 <code>InlineIdsOrClauseBulkIdStrategy</code>删除实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    p.id as id,
    p.companyName as companyName
from
    Person p
where
    p.employed = ?

delete
from
    Engineer
where
    ( id = 1 and companyName = 'Red Hat USA' )
or  ( id = 3 and companyName = 'Red Hat USA' )
or  ( id = 1 and companyName = 'Red Hat Europe' )
or  ( id = 3 and companyName = 'Red Hat Europe' )

delete
from
    Doctor
where
    ( id = 1 and companyName = 'Red Hat USA' )
or  ( id = 3 and companyName = 'Red Hat USA' )
or  ( id = 1 and companyName = 'Red Hat Europe' )
or  ( id = 3 and companyName = 'Red Hat Europe' )

delete
from
    Person
where
    ( id = 1 and companyName = 'Red Hat USA' )
or  ( id = 3 and companyName = 'Red Hat USA' )
or  ( id = 1 and companyName = 'Red Hat Europe' )
or  ( id = 3 and companyName = 'Red Hat Europe' )</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>InlineIdsOrClauseBulkIdStrategy</code>该策略的优点是受到所有主要关系数据库系统（例如Oracle，SQL Server，MySQL和PostgreSQL）的支持。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="batch-bulk-hql-strategies-CteValuesListBulkIdStrategy"><a class="anchor" href="#batch-bulk-hql-strategies-CteValuesListBulkIdStrategy"></a><code>CteValuesListBulkIdStrategy</code></h6>
<div class="paragraph">
<p>要使用此策略，您需要配置以下配置属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property name="hibernate.hql.bulk_id_strategy"
          value="org.hibernate.hql.spi.id.inline.CteValuesListBulkIdStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在运行前面的测试用例时，Hibernate生成以下SQL语句：</p>
</div>
<div id="batch-bulk-hql-CteValuesListBulkIdStrategy-delete-query-example" class="exampleblock">
<div class="title">示例448 <code>CteValuesListBulkIdStrategy</code>删除实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    p.id as id,
    p.companyName as companyName
from
    Person p
where
    p.employed = ?

with HT_Person (id,companyName ) as (
    select id, companyName
    from (
    values
        (?, ?),
        (?, ?),
        (?, ?),
        (?, ?)
    ) as HT (id, companyName) )
delete
from
    Engineer
where
    ( id, companyName ) in (
        select
            id, companyName
        from
            HT_Person
    )

with HT_Person (id,companyName ) as (
    select id, companyName
    from (
    values
        (?, ?),
        (?, ?),
        (?, ?),
        (?, ?)
    ) as HT (id, companyName) )
delete
from
    Doctor
where
    ( id, companyName ) in (
        select
            id, companyName
        from
            HT_Person
    )


with HT_Person (id,companyName ) as (
    select id, companyName
    from (
    values
        (?, ?),
        (?, ?),
        (?, ?),
        (?, ?)
    ) as HT (id, companyName) )
delete
from
    Person
where
    ( id, companyName ) in (
        select
            id, companyName
        from
            HT_Person
    )</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基础数据库还必须支持可以从非查询语句引用的CTE（公用表表达式）。例如，自9.1版以来，PostgreSQL支持此功能，而自2005版起，SQL Server提供对此功能的支持。</p>
</div>
<div class="paragraph">
<p>基础数据库还必须支持VALUES list子句，例如PostgreSQL或SQL Server 2008。</p>
</div>
<div class="paragraph">
<p>但是，此策略要求复合标识符使用IN子句行值表达式，因此您只能将此策略与PostgreSQL一起使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果可以使用临时表，那可能是最好的选择。但是，如果不允许创建临时表，则必须选择与基础数据库一起使用的这四种策略之一。在下定决心之前，您应该确定哪种方法最适合当前的工作负载。例如， <a href="http://blog.2ndquadrant.com/postgresql-ctes-are-optimization-fences/">CTE是PostgreSQL中的优化栅栏</a> ，因此请确保在做出决定之前先进行测量。</p>
</div>
<div class="paragraph">
<p>如果您使用的是Oracle或MySQL 5.7，则可以选择<code>InlineIdsOrClauseBulkIdStrategy</code>要么<code>InlineIdsInClauseBulkIdStrategy</code> 。对于旧版本的MySQL，则只能使用<code>InlineIdsOrClauseBulkIdStrategy</code> 。</p>
</div>
<div class="paragraph">
<p>如果您使用的是SQL Server， <code>InlineIdsOrClauseBulkIdStrategy</code>是您唯一的选择。</p>
</div>
<div class="paragraph">
<p>如果使用的是PostgreSQL，则可以选择这四种策略中的任何一种。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="caching"><a class="anchor" href="#caching"></a> 13快取</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在运行时，Hibernate响应于由Hibernate执行的操作来处理将数据移入和移出二级缓存的过程。 <code>Session</code> ，用作持久性数据的事务级缓存。实体被管理后，该对象即被添加到当前持久性上下文的内部缓存中（ <code>EntityManager</code>要么<code>Session</code> ）。持久性上下文也称为第一级缓存，默认情况下启用。</p>
</div>
<div class="paragraph">
<p>可以配置JVM级（ <code>SessionFactory</code>级）或群集缓存（逐级逐个收集）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，Hibernate缓存不知道其他应用程序对持久性存储所做的更改。</p>
</div>
<div class="paragraph">
<p>为了解决此限制，您可以在第二级缓存区域级别配置TTL（生存时间）保留策略，以便基础缓存条目定期过期。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="caching-config"><a class="anchor" href="#caching-config"></a> 13.1。配置二级缓存</h3>
<div class="paragraph">
<p>Hibernate可以与各种缓存提供程序集成，以在特定环境之外缓存数据<code>Session</code> 。本节定义了控制此行为的设置。</p>
</div>
<div class="sect3">
<h4 id="caching-config-provider"><a class="anchor" href="#caching-config-provider"></a> 13.1.1。RegionFactory</h4>
<div class="paragraph">
<p><code>org.hibernate.cache.spi.RegionFactory</code>定义了Hibernate和可插拔缓存提供程序之间的集成。
<code>hibernate.cache.region.factory_class</code>用于声明提供者使用。Hibernate内置了对Java缓存标准<a href="#caching-provider-jcache">JCache的</a>内置支持，以及两个流行的缓存库： <a href="#caching-provider-ehcache">Ehcache</a>和<a href="#caching-provider-infinispan">Infinispan</a> 。本章稍后将提供详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="caching-config-properties"><a class="anchor" href="#caching-config-properties"></a> 13.1.2。缓存配置属性</h4>
<div class="paragraph">
<p>除了特定的提供程序配置之外，集成的Hibernate端还有许多配置选项可控制各种缓存行为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.cache.use_second_level_cache</code></dt>
<dd>
<p>总体上启用或禁用二级缓存。默认情况下，如果当前已配置<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/cache/spi/RegionFactory.html"><code>RegionFactory</code></a>不是<code>NoCachingRegionFactory</code> ，则将启用二级缓存。否则，将禁用二级缓存。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.use_query_cache</code></dt>
<dd>
<p>启用或禁用查询结果的二级缓存。默认为false。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.query_cache_factory</code></dt>
<dd>
<p>查询结果缓存由特殊合同处理，该合同处理基于陈旧性的结果无效。默认实现根本不允许过时的结果。将此应用程序用于想要放松的地方。命名一个实现<code>org.hibernate.cache.spi.QueryCacheFactory</code></p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.use_minimal_puts</code></dt>
<dd>
<p>优化第二级缓存操作以最大程度地减少写入，但需要更频繁地读取。提供者通常对此进行适当设置。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.region_prefix</code></dt>
<dd>
<p>定义一个名称，用作所有第二级缓存区域名称的前缀。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.default_cache_concurrency_strategy</code></dt>
<dd>
<p>在Hibernate二级缓存中，可以对所有区域进行不同的配置，包括在访问特定区域时要使用的并发策略。此设置允许定义要使用的默认策略。由于可插拔提供程序确实会指定要使用的默认策略，因此很少需要此设置。有效值包括：</p>
<div class="ulist">
<ul>
<li>
<p>只读，</p>
</li>
<li>
<p>读写</p>
</li>
<li>
<p>非严格读写</p>
</li>
<li>
<p>交易性的</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>hibernate.cache.use_structured_entries</code></dt>
<dd>
<p>如果<code>true</code> ，强制Hibernate以更人性化的格式将数据存储在二级缓存中。如果您希望能够直接在缓存中“浏览”数据，但确实会对性能产生影响，则可能很有用。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.auto_evict_collection_cache</code></dt>
<dd>
<p>当关联仅从拥有方更改时，启用或禁用双向关联的集合缓存条目的自动驱逐。默认情况下禁用此功能，因为它会对跟踪此状态产生性能影响。但是，如果您的应用程序不管理双向高速缓存收集端的双向关联，则替代方法是在该高速缓存中保存陈旧数据。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.use_reference_entries</code></dt>
<dd>
<p>为只读或不可变实体，将实体引用直接存储到二级缓存中。</p>
</dd>
<dt class="hdlist1"><code>hibernate.cache.keys_factory</code></dt>
<dd>
<p>当将条目作为键值对存储到第二级缓存中时，可以将标识符包装到元组中， <entity type,="" tenant,="" identifier="">以确保唯一性，以防第二级缓存将所有实体存储在单个空间中。这些元组然后用作高速缓存中的键。当二级缓存实现（包括其配置）保证不同的实体类型分开存储并且不使用多租户时，可以省略此包装以获得更好的性能。当前，仅当Infinispan配置为第二级缓存实现时才支持此属性。有效值为：</entity></p>
<div class="ulist">
<ul>
<li>
<p><code>default</code> （将identitifers包装在元组中）</p>
</li>
<li>
<p><code>simple</code> （使用标识符作为键，无需任何包装）</p>
</li>
<li>
<p>实现的完全限定的类名<code>org.hibernate.cache.spi.CacheKeysFactory</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-mappings"><a class="anchor" href="#caching-mappings"></a> 13.2。配置二级缓存映射</h3>
<div class="paragraph">
<p>可以通过JPA批注或XML描述符或使用特定于Hibernate的映射文件来配置缓存映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，实体不属于二级缓存，我们建议您坚持使用此设置。但是，您可以通过设置<code>shared-cache-mode</code>您的元素<code>persistence.xml</code>文件或使用<code>javax.persistence.sharedCache.mode</code>配置文件中的属性。可能有以下值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ENABLE_SELECTIVE</code> （默认和推荐值）</dt>
<dd>
<p>除非明确标记为可缓存（使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Cacheable.html"><code>@Cacheable</code></a>注解）。</p>
</dd>
<dt class="hdlist1"><code>DISABLE_SELECTIVE</code></dt>
<dd>
<p>除非明确标记为不可缓存，否则实体将被缓存。</p>
</dd>
<dt class="hdlist1"><code>ALL</code></dt>
<dd>
<p>即使标记为不可缓存，实体也始终被缓存。</p>
</dd>
<dt class="hdlist1"><code>NONE</code></dt>
<dd>
<p>即使标记为可缓存，也不会缓存任何实体。完全禁用第二级缓存很有意义。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>默认情况下使用的缓存并发策略可以通过<code>hibernate.cache.default_cache_concurrency_strategy</code>配置属性。此属性的值为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">只读</dt>
<dd>
<p>如果您的应用程序需要读取而不是修改持久类的实例，则只读缓存是最佳选择。应用程序仍然可以删除实体，并且这些更改应反映在二级缓存中，以便缓存不提供陈旧的实体。实现可以基于实体的不变性使用性能优化。</p>
</dd>
<dt class="hdlist1">读写</dt>
<dd>
<p>如果应用程序需要更新数据，则可以使用读写缓存。该策略提供对单个实体的一致访问，但不提供可序列化的事务隔离级别。例如，当TX1读取查找一个实体但找不到该实体时，TX2将该实体插入高速缓存，而TX1再次查找该实体，则可以在TX1中读取新实体。</p>
</dd>
<dt class="hdlist1">非严格读写</dt>
<dd>
<p>与读写策略相似，但是在并发访问实体时可能偶尔会有陈旧的读取。如果应用程序很少同时更新相同的数据并且不需要严格的事务隔离，则选择此策略可能是适当的。实现可以使用利用宽松的一致性保证的性能优化。</p>
</dd>
<dt class="hdlist1">交易性的</dt>
<dd>
<p>提供可序列化的事务隔离级别。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建议不要在每个实体的基础上定义高速缓存并发策略，而不是使用全局设置。</p>
</div>
<div class="paragraph">
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Cache.html"><code>@org.hibernate.annotations.Cache</code></a>为此目的的注释。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@Cache</code>批注定义三个属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">用法</dt>
<dd>
<p>定义<code>CacheConcurrencyStrategy</code></p>
</dd>
<dt class="hdlist1">区域</dt>
<dd>
<p>定义将存储条目的缓存区域</p>
</dd>
<dt class="hdlist1">包括</dt>
<dd>
<p>如果惰性属性应包括在第二级缓存中。默认值为<code>all</code>因此惰性属性是可缓存的。另一个可能的值是<code>non-lazy</code>因此惰性属性不可缓存。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="caching-mappings-inheritance"><a class="anchor" href="#caching-mappings-inheritance"></a> 13.3。实体继承和二级缓存映射</h3>
<div class="paragraph">
<p>传统上，在使用实体继承时，Hibernate要求实体层次结构要完全缓存或根本不缓存。因此，如果要缓存属于给定实体层次结构的子类，则JPA <code>@Cacheable</code>和特定于Hibernate的<code>@Cache</code>注释只能在根实体级别声明。</p>
</div>
<div class="paragraph">
<p>尽管我们仍然认为属于给定实体层次结构的所有实体都应共享相同的缓存语义，但JPA规范指出， <code>@Cacheable</code>注释可以被子类覆盖：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>的价值<code>Cacheable</code>注释由子类继承；通过指定可以覆盖它<code>Cacheable</code>在一个子类上。</p>
</div>
</blockquote>
<div class="attribution">— JPA 2.1规范的11.1.7节</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Hibernate ORM 5.3开始，您现在可以覆盖基类<code>@Cacheable</code>要么<code>@Cache</code>子类级别的定义。</p>
</div>
<div class="paragraph">
<p>但是，Hibernate缓存并发策略（例如，只读，非严格读写，读写，事务性）仍在根实体级别定义，并且不能被覆盖。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，我们建议您让属于继承树的所有实体共享相同的缓存定义的原因可以总结如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从性能的角度来看，在每个实体类型级别添加额外的检查会减慢引导过程。</p>
</li>
<li>
<p>为子类提供不同的缓存语义将违反<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov替换原则</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="caching-entity"><a class="anchor" href="#caching-entity"></a> 13.4。实体缓存</h3>
<div id="caching-entity-mapping-example" class="exampleblock">
<div class="title">示例449。实体缓存映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Phone")
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public static class Phone {

	@Id
	@GeneratedValue
	private Long id;

	private String mobile;

	@ManyToOne
	private Person person;

	@Version
	private int version;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate以脱水形式存储缓存的实体，这与数据库表示类似。除了外键列的值<code>@ManyToOne</code>要么<code>@OneToOne</code>子级关联，实体关系未存储在缓存中，</p>
</div>
<div class="paragraph">
<p>一旦实体存储在二级缓存中，就可以避免数据库被命中，并仅从缓存中加载该实体：</p>
</div>
<div id="caching-entity-jpa-example" class="exampleblock">
<div class="title">实施例450。使用JPA加载实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-entity-native-example" class="exampleblock">
<div class="title">示例451使用Hibernate本机API加载实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session.get( Person.class, 1L );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate二级缓存还可以通过其<a href="#naturalid">自然ID</a>加载实体：</p>
</div>
<div id="caching-entity-natural-id-mapping-example" class="exampleblock">
<div class="title">示例452Hibernate自然ID实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
   public static class Person {

       @Id
       @GeneratedValue(strategy = GenerationType.AUTO)
       private Long id;

       private String name;

	@NaturalId
	@Column(name = "code", unique = true)
	private String code;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-entity-natural-id-example" class="exampleblock">
<div class="title">示例453。使用Hibernate本地自然ID API加载实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = session
	.byNaturalId( Person.class )
	.using( "code", "unique-code")
	.load();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-collection"><a class="anchor" href="#caching-collection"></a> 13.5。集合缓存</h3>
<div class="paragraph">
<p>Hibernate还可以缓存集合，并且<code>@Cache</code>注释必须添加到collection属性中。</p>
</div>
<div class="paragraph">
<p>如果集合是由值类型组成的（基本或可嵌入对象映射为<code>@ElementCollection</code> ），则该集合将按原样存储。如果集合包含其他实体（ <code>@OneToMany</code>要么<code>@ManyToMany</code> ），则收集缓存条目将仅存储实体标识符。</p>
</div>
<div id="caching-collection-mapping-example" class="exampleblock">
<div class="title">实施例454。集合缓存映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;(  );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>集合是通读的，这意味着它们在首次访问时会被缓存：</p>
</div>
<div id="caching-collection-example" class="exampleblock">
<div class="title">示例455集合缓存的使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = entityManager.find( Person.class, 1L );
person.getPhones().size();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随后的集合检索将使用缓存而不是进入数据库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>集合缓存不是直写的，因此任何修改都会触发集合缓存条目无效。在后续访问中，将从数据库中加载集合并重新缓存。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="caching-query"><a class="anchor" href="#caching-query"></a> 13.6。查询缓存</h3>
<div class="paragraph">
<p>除了缓存实体和集合，Hibernate还提供了查询缓存。这对于具有固定参数值的频繁执行的查询很有用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>缓存查询结果会在应用程序正常事务处理方面带来一些开销。例如，如果您缓存针对的查询结果<code>Person</code> ，Hibernate将需要跟踪这些结果何时应无效，因为针对任何<code>Person</code>实体。</p>
</div>
<div class="paragraph">
<p>这样，再加上大多数应用程序根本无法从缓存查询结果中获得任何好处，导致Hibernate默认情况下禁用查询结果的缓存。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要使用查询缓存，您首先需要使用以下配置属性启用它：</p>
</div>
<div id="caching-query-configuration" class="exampleblock">
<div class="title">示例456启用查询缓存</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.cache.use_query_cache"
    value="true" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上所述，大多数查询都无法从缓存或其结果中受益。因此，默认情况下，即使启用查询缓存后，也不会缓存单个查询。必须将每个需要缓存的特定查询手动设置为可缓存。这样，查询将查找现有的缓存结果，或者在执行查询时将查询结果添加到缓存中。</p>
</div>
<div id="caching-query-jpa-example" class="exampleblock">
<div class="title">示例457使用JPA缓存查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name = :name", Person.class)
.setParameter( "name", "John Doe")
.setHint( "org.hibernate.cacheable", "true")
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-query-native-example" class="exampleblock">
<div class="title">示例458使用Hibernate本机API缓存查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name = :name")
.setParameter( "name", "John Doe")
.setCacheable(true)
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于实体查询，查询缓存不缓存实际实体的状态。而是，它存储实体标识符，并且当从缓存中获取查询结果时，将从第二级缓存实体区域中加载实体状态。</p>
</div>
<div class="paragraph">
<p>与集合缓存一样，对于那些希望作为查询结果缓存一部分进行缓存的实体，查询缓存应始终与二级缓存结合使用。</p>
</div>
<div class="paragraph">
<p>对于投影查询，查询缓存存储脱水实体状态（例如， <code>Object[]</code> ）与基础JDBC相关联<code>ResultSet</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="caching-query-region"><a class="anchor" href="#caching-query-region"></a> 13.6.1。查询缓存区域</h4>
<div class="paragraph">
<p>此设置将创建两个新的缓存区域：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>default-query-results-region</code></dt>
<dd>
<p>保留缓存的查询结果</p>
</dd>
<dt class="hdlist1"><code>default-update-timestamps-region</code></dt>
<dd>
<p>保留可查询表的最新更新的时间戳。这些用于验证结果，因为它们是从查询缓存中提供的。</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您将基础缓存实现配置为使用到期时间，则对于<code>default-update-timestamps-region</code>设置为比任何查询缓存的超时设置更高的值。</p>
</div>
<div class="paragraph">
<p>实际上，我们建议<code>default-update-timestamps-region</code>根本没有为区域配置到期（基于时间）或收回（针对大小/内存）。请注意，LRU（最近最少使用）缓存逐出策略永远不适用于此特定缓存区域。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果需要对查询缓存过期策略进行细粒度控制，则可以为特定查询指定命名缓存区域。</p>
</div>
<div id="caching-query-region-jpa-example" class="exampleblock">
<div class="title">示例459使用JPA在自定义区域中缓存查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
		"select p " +
		"from Person p " +
		"where p.id &gt; :id", Person.class)
		.setParameter( "id", 0L)
		.setHint( QueryHints.HINT_CACHEABLE, "true")
		.setHint( QueryHints.HINT_CACHE_REGION, "query.cache.person" )
		.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-query-region-native-example" class="exampleblock">
<div class="title">示例460使用Hibernate本机API在自定义区域中缓存查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.id &gt; :id")
.setParameter( "id", 0L)
.setCacheable(true)
.setCacheRegion( "query.cache.person" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要强制查询缓存刷新其区域之一（忽略在该区域找到的任何缓存结果），则可以使用自定义缓存模式。</p>
</div>
<div id="caching-query-region-store-mode-jpa-example" class="exampleblock">
<div class="title">示例461在JPA中使用自定义查询缓存模式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.id &gt; :id", Person.class)
.setParameter( "id", 0L)
.setHint( QueryHints.HINT_CACHEABLE, "true")
.setHint( QueryHints.HINT_CACHE_REGION, "query.cache.person" )
.setHint( "javax.persistence.cache.storeMode", CacheStoreMode.REFRESH )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-query-region-store-mode-native-example" class="exampleblock">
<div class="title">示例462通过Hibernate本机API使用自定义查询缓存模式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.id &gt; :id")
.setParameter( "id", 0L)
.setCacheable(true)
.setCacheRegion( "query.cache.person" )
.setCacheMode( CacheMode.REFRESH )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用时<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/CacheStoreMode.html#REFRESH"><code>CacheStoreMode.REFRESH</code></a>要么<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/CacheMode.html#REFRESH"><code>CacheMode.REFRESH</code></a>结合您为给定查询定义的区域，Hibernate将有选择地强制刷新在该特定区域中缓存的结果。</p>
</div>
<div class="paragraph">
<p>在基础数据可能已通过单独的过程进行更新的情况下，此行为尤其有用，它是通过以下方式对该区域进行大规模逐出的更有效的替代方法<code>SessionFactory</code>驱逐如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">session.getSessionFactory().getCache().evictQueryRegion( "query.cache.person" );</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-management"><a class="anchor" href="#caching-management"></a> 13.7。管理缓存的数据</h3>
<div class="paragraph">
<p>传统上，Hibernate定义了<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/CacheMode.html"><code>CacheMode</code></a>枚举来描述与缓存数据进行交互的方式。JPA按存储划分缓存模式（ <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/CacheStoreMode.html"><code>CacheStoreMode</code></a> ）和检索（ <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/CacheRetrieveMode.html"><code>CacheRetrieveMode</code></a> ）。</p>
</div>
<div class="paragraph">
<p>下表显示了Hibernate和JPA缓存模式之间的关系：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表5。缓存模式关系</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">冬眠</th>
<th class="tableblock halign-left valign-top">JPA</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheMode.NORMAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheStoreMode.USE</code>和<code>CacheRetrieveMode.USE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认。从缓存中读取/写入数据</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheMode.REFRESH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheStoreMode.REFRESH</code>和<code>CacheRetrieveMode.BYPASS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不从缓存中读取，而是在从数据库加载后写入缓存</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheMode.PUT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheStoreMode.USE</code>和<code>CacheRetrieveMode.BYPASS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不从缓存中读取，而是在从数据库中读取时写入缓存</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheMode.GET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheStoreMode.BYPASS</code>和<code>CacheRetrieveMode.USE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从缓存读取，但不写入缓存</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheMode.IGNORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CacheStoreMode.BYPASS</code>和<code>CacheRetrieveMode.BYPASS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不从缓存读/写数据</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>设置缓存模式既可以在直接加载实体时也可以在执行查询时完成。</p>
</div>
<div id="caching-management-cache-mode-entity-jpa-example" class="exampleblock">
<div class="title">示例463在JPA中使用自定义缓存模式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;(  );
hints.put( "javax.persistence.cache.retrieveMode " , CacheRetrieveMode.USE );
hints.put( "javax.persistence.cache.storeMode" , CacheStoreMode.REFRESH );
Person person = entityManager.find( Person.class, 1L , hints);</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-management-cache-mode-entity-native-example" class="exampleblock">
<div class="title">示例464在Hibernate本机API中使用自定义缓存模式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">session.setCacheMode( CacheMode.REFRESH );
Person person = session.get( Person.class, 1L );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还可以为查询设置自定义缓存模式：</p>
</div>
<div id="caching-management-cache-mode-query-jpa-example" class="exampleblock">
<div class="title">示例465使用自定义缓存模式进行JPA查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p from Person p", Person.class)
.setHint( QueryHints.HINT_CACHEABLE, "true")
.setHint( "javax.persistence.cache.retrieveMode " , CacheRetrieveMode.USE )
.setHint( "javax.persistence.cache.storeMode" , CacheStoreMode.REFRESH )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="caching-management-cache-mode-query-native-example" class="exampleblock">
<div class="title">示例466在Hibernate本机API中使用自定义缓存模式进行查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createQuery(
	"select p from Person p" )
.setCacheable( true )
.setCacheMode( CacheMode.REFRESH )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="caching-management-evict"><a class="anchor" href="#caching-management-evict"></a> 13.7.1。逐出缓存项</h4>
<div class="paragraph">
<p>因为二级缓存绑定到了<code>EntityManagerFactory</code>或者<code>SessionFactory</code> ，必须通过这两个接口完成缓存驱逐。</p>
</div>
<div class="paragraph">
<p>JPA仅通过以下方式支持实体逐出<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Cache.html"><code>javax.persistence.Cache</code></a>接口：</p>
</div>
<div id="caching-management-evict-jpa-example" class="exampleblock">
<div class="title">示例467通过JPA驱逐实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">entityManager.getEntityManagerFactory().getCache().evict( Person.class );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate在这方面更加灵活，因为它可以对需要逐出的内容进行细粒度的控制。的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Cache.html"><code>org.hibernate.Cache</code></a>界面定义了各种驱逐策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实体（按其类别或地区）</p>
</li>
<li>
<p>使用自然ID存储的实体（按其类别或地区）</p>
</li>
<li>
<p>集合（按区域划分，也可能带有集合所有者标识符）</p>
</li>
<li>
<p>查询（按地区）</p>
</li>
</ul>
</div>
<div id="caching-management-evict-native-example" class="exampleblock">
<div class="title">示例468。使用Hibernate本机API驱逐实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">session.getSessionFactory().getCache().evictQueryRegion( "query.cache.person" );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-statistics"><a class="anchor" href="#caching-statistics"></a> 13.8。缓存统计</h3>
<div class="paragraph">
<p>如果启用<code>hibernate.generate_statistics</code>配置属性，Hibernate将通过公开许多指标<code>SessionFactory.getStatistics()</code> 。甚至可以将Hibernate配置为通过JMX公开这些统计信息。</p>
</div>
<div class="paragraph">
<p>这样，您就可以访问<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/stat/Statistics.html"><code>Statistics</code></a>该类包含各种第二级缓存指标。</p>
</div>
<div id="caching-statistics-example" class="exampleblock">
<div class="title">示例469缓存统计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Statistics statistics = session.getSessionFactory().getStatistics();
CacheRegionStatistics secondLevelCacheStatistics =
		statistics.getDomainDataRegionStatistics( "query.cache.person" );
long hitCount = secondLevelCacheStatistics.getHitCount();
long missCount = secondLevelCacheStatistics.getMissCount();
double hitRatio = (double) hitCount / ( hitCount + missCount );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-provider-jcache"><a class="anchor" href="#caching-provider-jcache"></a> 13.9。缓存</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用<a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>的内置集成，您需要<code>hibernate-jcache</code>模块jar（及其所有依赖项）位于类路径上。</p>
</div>
<div class="paragraph">
<p>另外，还需要添加JCache实现。兼容的实现列表可以<a href="https://jcp.org/aboutJava/communityprocess/implementations/jsr107/index.html">在JCP网站上</a>找到。可以通过<a href="https://github.com/cruftex/jsr107-test-zoo">JSR-107测试动物园</a>找到兼容实现的替代来源。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="caching-provider-jcache-region-factory"><a class="anchor" href="#caching-provider-jcache-region-factory"></a> 13.9.1。RegionFactory</h4>
<div class="paragraph">
<p>的<code>hibernate-jcache</code>模块定义以下区域工厂： <code>JCacheRegionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>要使用<code>JCacheRegionFactory</code> ，您需要指定以下配置属性：</p>
</div>
<div id="caching-provider-jcache-region-factory-example" class="exampleblock">
<div class="title">示例470 <code>JCacheRegionFactory</code>组态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.cache.region.factory_class"
    value="jcache"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>JCacheRegionFactory</code>配置一个<code>javax.cache.CacheManager</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="caching-provider-jcache-cache-manager"><a class="anchor" href="#caching-provider-jcache-cache-manager"></a> 13.9.2。缓存<code>CacheManager</code></h4>
<div class="paragraph">
<p>JCache要求<code>CacheManager</code>共享相同的URI和类加载器在JVM中是唯一的。</p>
</div>
<div class="paragraph">
<p>如果您未指定其他属性，则<code>JCacheRegionFactory</code>将加载默认的JCache提供程序并创建默认的<code>CacheManager</code> 。也， <code>Cache</code>将使用默认值创建<code>javax.cache.configuration.MutableConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>为了控制使用哪个提供程序并指定配置<code>CacheManager</code>和<code>Cache</code>您可以使用以下两个属性：</p>
</div>
<div id="caching-provider-jcache-region-factory-config-example" class="exampleblock">
<div class="title">示例471JCache配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.javax.cache.provider"
    value="org.ehcache.jsr107.EhcacheCachingProvider"/&gt;
&lt;property
    name="hibernate.javax.cache.uri"
    value="file:/path/to/ehcache.xml"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>仅通过指定第二个属性<code>hibernate.javax.cache.uri</code>你能有一个<code>CacheManager</code>每<code>SessionFactory</code> 。</p>
</div>
<div class="sect4">
<h5 id="_using_a_non_default_jcache_code_cachemanager_code"><a class="anchor" href="#_using_a_non_default_jcache_code_cachemanager_code"></a>使用非默认的JCache<code>CacheManager</code></h5>
<div class="paragraph">
<p>如果您不想使用默认值<code>CacheManager</code> ，您需要设置<code>hibernate.javax.cache.cache_manager</code>配置属性为以下值之一：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">对象参考</dt>
<dd>
<p>如果值为<code>Object</code>实例实现<code>CacheManager</code>接口，提供<code>CacheManager</code>实例将被使用。</p>
</dd>
<dt class="hdlist1"><code>Class</code></dt>
<dd>
<p>如果值为Java <code>Class</code>实现<code>CacheManager</code>接口，Hibernate将为此创建一个新实例<code>Class</code>并使用它代替默认值。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传递Java时<code>Class</code>实现了<code>CacheManager</code>介面，您必须确定<code>CacheManager</code>实现类提供了一个默认的no-arg构造函数，因为它将用于实例化一个<code>CacheManager</code>实作<code>Object</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>如果值为Java <code>String</code> ，Hibernate希望它是完全合格的<code>Class</code>的名字<code>CacheManager</code>实现，将用于实例化非默认值<code>CacheManager</code> 。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传递完全限定的类名时，必须确保关联的<code>Class</code>类型提供了默认的无参数构造函数，因为它将用于实例化一个<code>CacheManager</code>实作<code>Object</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="caching-provider-jcache-missing-cache-strategy"><a class="anchor" href="#caching-provider-jcache-missing-cache-strategy"></a> 13.9.3。JCache缺少缓存策略</h4>
<div class="paragraph">
<p>默认情况下，当要求创建未在基础缓存管理器中明确配置和预先启动的缓存时，JCache区域工厂将记录警告。因此，如果您将实体类型或集合配置为已缓存，但未明确配置相应的缓存，则将为每个未明确配置的缓存记录一条警告。</p>
</div>
<div class="paragraph">
<p>您可以通过设置<code>hibernate.javax.cache.missing_cache_strategy</code>属性设置为以下值之一：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表6。缺少缓存策略</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fail</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由于缺少缓存而失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create-warn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>默认值</strong> 。当找不到缓存时创建一个新的缓存（请参阅<code>create</code>下方），并记录有关缺少缓存的警告。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当找不到缓存时创建新的缓存，而不记录有关丢失的缓存的任何警告。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，除非高速缓存提供程序显式提供默认高速缓存的特定配置，否则以这种方式创建的高速缓存可能不适用于生产用途（大小不受限制，尤其是没有逐出）。</p>
</div>
<div class="paragraph">
<p>特别是，Ehcache允许使用缓存模板设置这种默认配置。有关更多详细信息，请参见<a href="http://www.ehcache.org/documentation/3.0/107.html#supplement-jsr-107-configurations">Ehcache文档</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-provider-ehcache"><a class="anchor" href="#caching-provider-ehcache"></a> 13.10。高速缓存</h3>
<div class="paragraph">
<p>此集成涵盖了Ehcache 2.x，为了将Ehcache 3.x用作第二级缓存，请参考<a href="#caching-provider-jcache">JCache集成</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要对<a href="http://www.ehcache.org/">Ehcache</a>使用内置集成，需要<code>hibernate-ehcache</code>模块jar（及其所有依赖项）位于类路径上。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="caching-provider-ehcache-region-factory"><a class="anchor" href="#caching-provider-ehcache-region-factory"></a> 13.10.1。RegionFactory</h4>
<div class="paragraph">
<p>hibernate-ehcache模块定义了两个特定的区域工厂： <code>EhCacheRegionFactory</code>和<code>SingletonEhCacheRegionFactory</code> 。</p>
</div>
<div class="sect4">
<h5 id="caching-provider-ehcache-region-factory-shared"><a class="anchor" href="#caching-provider-ehcache-region-factory-shared"></a><code>EhCacheRegionFactory</code></h5>
<div class="paragraph">
<p>要使用<code>EhCacheRegionFactory</code> ，您需要指定以下配置属性：</p>
</div>
<div id="caching-provider-ehcache-region-factory-shared-example" class="exampleblock">
<div class="title">示例472 <code>EhCacheRegionFactory</code>组态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.cache.region.factory_class"
    value="ehcache"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>EhCacheRegionFactory</code>配置一个<code>net.sf.ehcache.CacheManager</code>每个<code>SessionFactory</code> ， 所以<code>CacheManager</code>不被多个人共享<code>SessionFactory</code>同一JVM中的实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="caching-provider-ehcache-region-factory-singleton"><a class="anchor" href="#caching-provider-ehcache-region-factory-singleton"></a><code>SingletonEhCacheRegionFactory</code></h5>
<div class="paragraph">
<p>要使用<code>SingletonEhCacheRegionFactory</code> ，您需要指定以下配置属性：</p>
</div>
<div id="caching-provider-ehcache-region-factory-singleton-example" class="exampleblock">
<div class="title">示例473 <code>SingletonEhCacheRegionFactory</code>组态</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="hibernate.cache.region.factory_class"
    value="ehcache-singleton"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>SingletonEhCacheRegionFactory</code>配置一个单例<code>net.sf.ehcache.CacheManager</code> （请参阅<a href="http://www.ehcache.org/apidocs/2.8.4/net/sf/ehcache/CacheManager.html#create%28%29">CacheManager＃create（）</a> ），在多个<code>SessionFactory</code>同一JVM中的实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://www.ehcache.org/documentation/2.8/integrations/hibernate#optional">Ehcache文档</a>建议使用多个非单个<code>CacheManager(s)</code>有多个Hibernate时<code>SessionFactory</code>在同一JVM中运行的实例。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="caching-provider-ehcache-missing-cache-strategy"><a class="anchor" href="#caching-provider-ehcache-missing-cache-strategy"></a> 13.10.2。Ehcache缺少缓存策略</h4>
<div class="paragraph">
<p>默认情况下，当要求创建未在基础缓存管理器中明确配置并预先启动的缓存时，Ehcache区域工厂将记录警告。因此，如果您将实体类型或集合配置为已缓存，但未明确配置相应的缓存，则将为每个未明确配置的缓存记录一条警告。</p>
</div>
<div class="paragraph">
<p>您可以通过设置<code>hibernate.cache.ehcache.missing_cache_strategy</code>属性设置为以下值之一：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表7。缺少缓存策略</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fail</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由于缺少缓存而失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create-warn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>默认值</strong> 。当找不到缓存时创建一个新的缓存（请参阅<code>create</code>下方），并记录有关缺少缓存的警告。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当找不到缓存时创建新的缓存，而不记录有关丢失的缓存的任何警告。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，除非使用适当的方法，否则以这种方式创建的缓存可能配置很差（尤其是大容量） <code><defaultCache></code>条目已添加到Ehcache配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching-provider-infinispan"><a class="anchor" href="#caching-provider-infinispan"></a> 13.11。Infinispan</h3>
<div class="paragraph">
<p>Infinispan是一个分布式的内存中键/值数据存储，可以用作缓存或数据网格，也可以用作Hibernate 2级缓存提供程序。</p>
</div>
<div class="paragraph">
<p>它支持高级功能，例如事务，事件，查询，分布式处理，堆外和地理故障转移。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请查阅《 <a href="http://infinispan.org/docs/stable/user_guide/user_guide.html#integrations_jpa_hibernate">Infinispan用户指南》</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="events"><a class="anchor" href="#events"></a> 14。拦截器和事件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于应用程序响应Hibernate内部发生的某些事件很有用。这允许实现通用功能和扩展Hibernate功能。</p>
</div>
<div class="sect2">
<h3 id="events-interceptors"><a class="anchor" href="#events-interceptors"></a> 14.1。拦截器</h3>
<div class="paragraph">
<p>的<code>org.hibernate.Interceptor</code>接口提供从会话到应用程序的回调，从而允许应用程序在保存，更新，删除或加载持久对象之前检查和/或操纵该对象的属性。</p>
</div>
<div class="paragraph">
<p>一种可能的用途是跟踪审核信息。以下示例显示了<code>Interceptor</code>实体更新时自动记录的实现。</p>
</div>
<div id="events-interceptors-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class LoggingInterceptor extends EmptyInterceptor {
	@Override
	public boolean onFlushDirty(
		Object entity,
		Serializable id,
		Object[] currentState,
		Object[] previousState,
		String[] propertyNames,
		Type[] types) {
			LOGGER.debugv( "Entity {0}#{1} changed from {2} to {3}",
				entity.getClass().getSimpleName(),
				id,
				Arrays.toString( previousState ),
				Arrays.toString( currentState )
			);
			return super.onFlushDirty( entity, id, currentState,
				previousState, propertyNames, types
		);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以实施<code>Interceptor</code>直接或扩展<code>org.hibernate.EmptyInterceptor</code>基类。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>拦截器可以是<code>Session</code>范围或<code>SessionFactory</code>范围。</p>
</div>
<div class="paragraph">
<p>打开会话时，将指定一个会话范围的拦截器。</p>
</div>
<div id="events-interceptors-session-scope-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SessionFactory sessionFactory = entityManagerFactory.unwrap( SessionFactory.class );
Session session = sessionFactory
	.withOptions()
	.interceptor(new LoggingInterceptor() )
	.openSession();
session.getTransaction().begin();

Customer customer = session.get( Customer.class, customerId );
customer.setName( "Mr. John Doe" );
//Entity Customer#1 changed from [John Doe, 0] to [Mr. John Doe, 0]

session.getTransaction().commit();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>SessionFactory</code>范围的拦截器已向<code>Configuration</code>建立对象之前<code>SessionFactory</code> 。除非明确指定要使用的拦截器打开了会话，否则<code>SessionFactory</code>范围的拦截器将应用于从该地址打开的所有会话<code>SessionFactory</code> 。
<code>SessionFactory</code>范围的拦截器必须是线程安全的。确保您不存储特定于会话的状态，因为多个会话可能会同时使用此拦截器。</p>
</div>
<div id="events-interceptors-session-factory-scope-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SessionFactory sessionFactory = new MetadataSources( new StandardServiceRegistryBuilder().build() )
	.addAnnotatedClass( Customer.class )
	.getMetadataBuilder()
	.build()
	.getSessionFactoryBuilder()
	.applyInterceptor( new LoggingInterceptor() )
	.build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="events-events"><a class="anchor" href="#events-events"></a> 14.2。本机事件系统</h3>
<div class="paragraph">
<p>如果您必须对持久层中的特定事件做出反应，则还可以使用Hibernate <em>事件</em>体系结构。该事件系统可以代替拦截器或除拦截器之外使用。</p>
</div>
<div class="paragraph">
<p>许多方法<code>Session</code>接口与事件类型相关。定义的事件类型的全部范围都声明为上的枚举值<code>org.hibernate.event.spi.EventType</code> 。当使用这些方法之一发出请求时，会话将生成适当的事件，并将其传递给该类型的已配置事件侦听器。</p>
</div>
<div class="paragraph">
<p>应用程序可以自定义侦听器界面（即<code>LoadEvent</code>由已注册的实施处理<code>LoadEventListener</code>接口），在这种情况下，其实现将负责处理<code>load()</code>提出的要求<code>Session</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>侦听器应被视为无状态。它们在请求之间共享，并且不应将任何状态另存为实例变量。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>自定义侦听器为想要处理和/或扩展便捷基类之一的事件（或什至是Hibernate使用的默认事件侦听器，即开即用，因为它们被声明为非最终的）实现了适当的接口。目的）。</p>
</div>
<div class="paragraph">
<p>这是一个自定义加载事件侦听器的示例：</p>
</div>
<div id="events-interceptors-load-listener-example" class="exampleblock">
<div class="title">示例474自订<code>LoadListener</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManagerFactory entityManagerFactory = entityManagerFactory();
SessionFactoryImplementor sessionFactory = entityManagerFactory.unwrap( SessionFactoryImplementor.class );
sessionFactory
	.getServiceRegistry()
	.getService( EventListenerRegistry.class )
	.prependListeners( EventType.LOAD, new SecuredLoadEntityListener() );

Customer customer = entityManager.find( Customer.class, customerId );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="events-mixing-events-and-interceptors"><a class="anchor" href="#events-mixing-events-and-interceptors"></a> 14.3。混合事件和拦截器</h3>
<div class="paragraph">
<p>要自定义实体状态转换行为时，必须选择：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>您提供一个自定义<code>Interceptor</code> ，默认的Hibernate事件侦听器会将其考虑在内。例如， <code>Interceptor#onSave()</code> Hibernate调用该方法<code>AbstractSaveEventListener</code> 。或者<code>Interceptor#onLoad()</code>由<code>DefaultPreLoadEventListener</code> 。</p>
</li>
<li>
<p>您可以使用自己的实现替换任何给定的默认事件监听器。这样做时，您可能应该扩展默认的侦听器，因为否则，您将必须照顾所有低层的实体状态转换逻辑。例如，如果您替换<code>DefaultPreLoadEventListener</code>然后使用您自己的实现<code>Interceptor#onLoad()</code>方法显式，您可以将自定义加载事件侦听器与自定义Hibernate拦截器混合使用。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="events-declarative-security"><a class="anchor" href="#events-declarative-security"></a> 14.4。Hibernate声明式安全</h3>
<div class="paragraph">
<p>通常，在会话外观层中管理Hibernate应用程序中的声明式安全。Hibernate允许通过JACC和JAAS授权某些操作。这是基于事件体系结构构建的可选功能。</p>
</div>
<div class="paragraph">
<p>首先，必须配置适当的事件侦听器，以启用JACC授权。再次，请参阅<a href="#bootstrap-event-listener-registration">事件侦听器注册</a>以获取详细信息。</p>
</div>
<div class="paragraph">
<p>以下是适当的示例<code>org.hibernate.integrator.spi.Integrator</code>为此目的实施。</p>
</div>
<div id="events-declarative-security-jacc-example" class="exampleblock">
<div class="title">示例475JACC侦听器注册示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class JaccIntegrator implements ServiceContributingIntegrator {

	private static final Logger log = Logger.getLogger( JaccIntegrator.class );

	private static final DuplicationStrategy DUPLICATION_STRATEGY =
			new DuplicationStrategy() {
		@Override
		public boolean areMatch(Object listener, Object original) {
			return listener.getClass().equals( original.getClass() ) &amp;&amp;
					JaccSecurityListener.class.isInstance( original );
		}

		@Override
		public Action getAction() {
			return Action.KEEP_ORIGINAL;
		}
	};

	@Override
	public void prepareServices(
			StandardServiceRegistryBuilder serviceRegistryBuilder) {
		boolean isSecurityEnabled = serviceRegistryBuilder
				.getSettings().containsKey( AvailableSettings.JACC_ENABLED );
		final JaccService jaccService = isSecurityEnabled ?
				new StandardJaccServiceImpl() : new DisabledJaccServiceImpl();
		serviceRegistryBuilder.addService( JaccService.class, jaccService );
	}

	@Override
	public void integrate(
			Metadata metadata,
			SessionFactoryImplementor sessionFactory,
			SessionFactoryServiceRegistry serviceRegistry) {
		doIntegration(
				serviceRegistry
						.getService( ConfigurationService.class ).getSettings(),
				// pass no permissions here, because atm actually injecting the
				// permissions into the JaccService is handled on SessionFactoryImpl via
				// the org.hibernate.boot.cfgxml.spi.CfgXmlAccessService
				null,
				serviceRegistry
		);
	}

	private void doIntegration(
			Map properties,
			JaccPermissionDeclarations permissionDeclarations,
			SessionFactoryServiceRegistry serviceRegistry) {
		boolean isSecurityEnabled = properties
				.containsKey( AvailableSettings.JACC_ENABLED );
		if ( ! isSecurityEnabled ) {
			log.debug( "Skipping JACC integration as it was not enabled" );
			return;
		}

		final String contextId = (String) properties
				.get( AvailableSettings.JACC_CONTEXT_ID );
		if ( contextId == null ) {
			throw new IntegrationException( "JACC context id must be specified" );
		}

		final JaccService jaccService = serviceRegistry
				.getService( JaccService.class );
		if ( jaccService == null ) {
			throw new IntegrationException( "JaccService was not set up" );
		}

		if ( permissionDeclarations != null ) {
			for ( GrantedPermission declaration : permissionDeclarations
					.getPermissionDeclarations() ) {
				jaccService.addPermission( declaration );
			}
		}

		final EventListenerRegistry eventListenerRegistry =
				serviceRegistry.getService( EventListenerRegistry.class );
		eventListenerRegistry.addDuplicationStrategy( DUPLICATION_STRATEGY );

		eventListenerRegistry.prependListeners(
				EventType.PRE_DELETE, new JaccPreDeleteEventListener() );
		eventListenerRegistry.prependListeners(
				EventType.PRE_INSERT, new JaccPreInsertEventListener() );
		eventListenerRegistry.prependListeners(
				EventType.PRE_UPDATE, new JaccPreUpdateEventListener() );
		eventListenerRegistry.prependListeners(
				EventType.PRE_LOAD, new JaccPreLoadEventListener() );
	}

	@Override
	public void disintegrate(SessionFactoryImplementor sessionFactory,
							 SessionFactoryServiceRegistry serviceRegistry) {
		// nothing to do
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还必须决定如何配置JACC提供程序。请查阅您的JACC提供者文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="events-jpa-callbacks"><a class="anchor" href="#events-jpa-callbacks"></a> 14.5。JPA回调</h3>
<div class="paragraph">
<p>JPA还通过注释定义了一组更有限的回调。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表8。回调注释</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PrePersist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在实体管理器持久操作实际执行或级联之前执行。此调用与持久操作同步。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PreRemove</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在实体管理器删除操作实际执行或级联之前执行。此调用与删除操作同步。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PostPersist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在实体管理器持久操作实际执行或级联之后执行。在执行数据库INSERT之后，将调用此调用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PostRemove</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在实体管理器删除操作实际执行或级联之后执行。此调用与删除操作同步。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PreUpdate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行数据库UPDATE操作之前执行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PostUpdate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在数据库执行UPDATE操作之后执行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PostLoad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在将实体加载到当前持久性上下文中或刷新实体后执行。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>定义了两种用于指定回调处理的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一种方法是对实体本身的方法进行注释，以接收有关特定实体生命周期事件的通知。</p>
</li>
<li>
<p>第二种是使用单独的实体侦听器类。实体侦听器是具有无参数构造函数的无状态类。回调批注放置在此类的方法上，而不是实体类上。然后，使用<code>javax.persistence.EntityListeners</code>注解</p>
</li>
</ul>
</div>
<div id="events-jpa-callbacks-example" class="exampleblock">
<div class="title">示例476指定JPA回调的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@EntityListeners( LastUpdateListener.class )
public static class Person {

	@Id
	private Long id;

	private String name;

	private Date dateOfBirth;

	@Transient
	private long age;

	private Date lastUpdate;

	public void setLastUpdate(Date lastUpdate) {
		this.lastUpdate = lastUpdate;
	}

	/**
	 * Set the transient property at load time based on a calculation.
	 * Note that a native Hibernate formula mapping is better for this purpose.
	 */
	@PostLoad
	public void calculateAge() {
		age = ChronoUnit.YEARS.between( LocalDateTime.ofInstant(
				Instant.ofEpochMilli( dateOfBirth.getTime()), ZoneOffset.UTC),
			LocalDateTime.now()
		);
	}
}

public static class LastUpdateListener {

	@PreUpdate
	@PrePersist
	public void setLastUpdate( Person p ) {
		p.setLastUpdate( new Date() );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些方法可以混合使用，这意味着您可以同时使用这两种方法。</p>
</div>
<div class="paragraph">
<p>无论回调方法是在实体上定义还是在实体侦听器上定义，它都必须具有void返回签名。该方法的名称无关紧要，因为使方法成为回调的是回调注释的位置。对于在实体类上定义的回调方法，该方法还必须具有无参数签名。对于在实体侦听器类上定义的回调方法，该方法必须具有单个参数签名。该参数的类型可以是<code>java.lang.Object</code> （以方便附加到多个实体）或特定的实体类型。</p>
</div>
<div class="paragraph">
<p>回调方法可以引发<code>RuntimeException</code> 。如果回调方法确实抛出了<code>RuntimeException</code> ，则必须回滚当前事务（如果有）。</p>
</div>
<div class="paragraph">
<p>回调方法不得调用<code>EntityManager</code>要么<code>Query</code>方法！</p>
</div>
<div class="paragraph">
<p>可能为特定的生命周期事件定义了多个回调方法。在这种情况下，JPA规范（特别是第3.5.4节）很好地定义了定义的执行顺序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与实体关联的任何默认侦听器都将首先按照在XML中指定的顺序被调用。见<code>javax.persistence.ExcludeDefaultListeners</code>注解。</p>
</li>
<li>
<p>接下来，按照在实体层次结构中定义的顺序调用与实体层次结构关联的实体侦听器类回调。 <code>EntityListeners</code> 。如果实体层次结构中的多个类定义了实体侦听器，则为超类定义的侦听器将在为其子类定义的侦听器之前调用。参见`javax.persistence。排除SuperclassListener的注释。</p>
</li>
<li>
<p>最后，调用在实体层次结构上定义的回调方法。如果在实体及其一个或多个超类上都标注了回调类型而未覆盖方法，则两者都将被称为最通用的超类。还允许实体类重写在超类中定义的回调方法，在这种情况下，不会调用超级回调。如果带注释，则覆盖方法将被调用。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="events-default-listener"><a class="anchor" href="#events-default-listener"></a> 14.6。默认实体监听器</h3>
<div class="paragraph">
<p>JPA规范允许您定义默认的实体侦听器，该侦听器将应用于该特定系统中的每个实体。默认实体侦听器只能在XML映射文件中定义。</p>
</div>
<div id="events-default-listener-mapping-example" class="exampleblock">
<div class="title">示例477默认事件侦听器映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class DefaultEntityListener {

    public void onPersist(Object entity) {
        if ( entity instanceof BaseEntity ) {
            BaseEntity baseEntity = (BaseEntity) entity;
            baseEntity.setCreatedOn( now() );
        }
    }

    public void onUpdate(Object entity) {
        if ( entity instanceof BaseEntity ) {
            BaseEntity baseEntity = (BaseEntity) entity;
            baseEntity.setUpdatedOn( now() );
        }
    }

    private Timestamp now() {
        return Timestamp.from(
            LocalDateTime.now().toInstant( ZoneOffset.UTC )
        );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm
                 http://xmlns.jcp.org/xml/ns/persistence/orm_2_1.xsd"
                 version="2.1"&gt;
    &lt;persistence-unit-metadata&gt;
        &lt;persistence-unit-defaults&gt;
            &lt;entity-listeners&gt;
                &lt;entity-listener
                    class="org.hibernate.userguide.events.DefaultEntityListener"&gt;
                    &lt;pre-persist method-name="onPersist"/&gt;
                    &lt;pre-update method-name="onUpdate"/&gt;
                &lt;/entity-listener&gt;
            &lt;/entity-listeners&gt;
        &lt;/persistence-unit-defaults&gt;
    &lt;/persistence-unit-metadata&gt;
&lt;/entity-mappings&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑到所有实体都扩展了<code>BaseEntity</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@MappedSuperclass
public abstract class BaseEntity {

    private Timestamp createdOn;

    private Timestamp updatedOn;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
public static class Person extends BaseEntity {

	@Id
	private Long id;

	private String name;

	//Getters and setters omitted for brevity
}

@Entity(name = "Book")
public static class Book extends BaseEntity {

	@Id
	private Long id;

	private String title;

	@ManyToOne
	private Person author;

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当坚持一个<code>Person</code>要么<code>Book</code>实体<code>createdOn</code>将由<code>onPersist</code>的方法<code>DefaultEntityListener</code> 。</p>
</div>
<div id="events-default-listener-persist-example" class="exampleblock">
<div class="title">示例478默认事件侦听器持久事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person author = new Person();
author.setId( 1L );
author.setName( "Vlad Mihalcea" );

entityManager.persist( author );

Book book = new Book();
book.setId( 1L );
book.setTitle( "High-Performance Java Persistence" );
book.setAuthor( author );

entityManager.persist( book );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Person
    (createdOn, updatedOn, name, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [2017-06-08 19:23:48.224]
-- binding parameter [2] as [TIMESTAMP] - [null]
-- binding parameter [3] as [VARCHAR]   - [Vlad Mihalcea]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    Book
    (createdOn, updatedOn, author_id, title, id)
values
    (?, ?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [2017-06-08 19:23:48.246]
-- binding parameter [2] as [TIMESTAMP] - [null]
-- binding parameter [3] as [BIGINT]    - [1]
-- binding parameter [4] as [VARCHAR]   - [High-Performance Java Persistence]
-- binding parameter [5] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更新时<code>Person</code>要么<code>Book</code>实体<code>updatedOn</code>将由<code>onUpdate</code>的方法<code>DefaultEntityListener</code> 。</p>
</div>
<div id="events-default-listener-update-example" class="exampleblock">
<div class="title">示例479默认事件侦听器更新事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person author = entityManager.find( Person.class, 1L );
author.setName( "Vlad-Alexandru Mihalcea" );

Book book = entityManager.find( Book.class, 1L );
book.setTitle( "High-Performance Java Persistence 2nd Edition" );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update
    Person
set
    createdOn=?,
    updatedOn=?,
    name=?
where
    id=?

-- binding parameter [1] as [TIMESTAMP] - [2017-06-08 19:23:48.224]
-- binding parameter [2] as [TIMESTAMP] - [2017-06-08 19:23:48.316]
-- binding parameter [3] as [VARCHAR]   - [Vlad-Alexandru Mihalcea]
-- binding parameter [4] as [BIGINT]    - [1]

update
    Book
set
    createdOn=?,
    updatedOn=?,
    author_id=?,
    title=?
where
    id=?

-- binding parameter [1] as [TIMESTAMP] - [2017-06-08 19:23:48.246]
-- binding parameter [2] as [TIMESTAMP] - [2017-06-08 19:23:48.317]
-- binding parameter [3] as [BIGINT]    - [1]
-- binding parameter [4] as [VARCHAR]   - [High-Performance Java Persistence 2nd Edition]
-- binding parameter [5] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="events-exclude-default-listener"><a class="anchor" href="#events-exclude-default-listener"></a> 14.6.1。排除默认实体侦听器</h4>
<div class="paragraph">
<p>如果您已经注册了默认实体侦听器，但是不想将其应用于特定实体，则可以使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ExcludeDefaultListeners.html"><code>@ExcludeDefaultListeners</code></a>和<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ExcludeSuperclassListeners.html"><code>@ExcludeSuperclassListeners</code></a> JPA批注。</p>
</div>
<div class="paragraph">
<p><code>@ExcludeDefaultListeners</code>指示当前类忽略当前实体的默认实体侦听器，同时<code>@ExcludeSuperclassListeners</code>用于忽略传播到的默认实体侦听器<code>BaseEntity</code>超一流。</p>
</div>
<div id="events-exclude-default-listener-mapping-example" class="exampleblock">
<div class="title">示例480排除默认事件侦听器映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Publisher")
@ExcludeDefaultListeners
@ExcludeSuperclassListeners
public static class Publisher extends BaseEntity {

	@Id
	private Long id;

	private String name;

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当坚持一个<code>Publisher</code>实体<code>createdOn</code>不会由<code>onPersist</code>的方法<code>DefaultEntityListener</code>因为<code>Publisher</code>实体标有<code>@ExcludeDefaultListeners</code>和<code>@ExcludeSuperclassListeners</code>注释。</p>
</div>
<div id="events-exclude-default-listener-persist-example" class="exampleblock">
<div class="title">示例481不包括默认事件侦听器事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Publisher publisher = new Publisher();
publisher.setId( 1L );
publisher.setName( "Amazon" );

entityManager.persist( publisher );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Publisher
    (createdOn, updatedOn, name, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [null]
-- binding parameter [2] as [TIMESTAMP] - [null]
-- binding parameter [3] as [VARCHAR]   - [Amazon]
-- binding parameter [4] as [BIGINT]    - [1]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hql"><a class="anchor" href="#hql"></a> 15HQL和JPQL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate查询语言（HQL）和Java持久性查询语言（JPQL）都是面向对象模型的查询语言，其本质类似于SQL。 JPQL是HQL的一个受很大启发的子集。 JPQL查询始终是有效的HQL查询，但是反之则不成立。</p>
</div>
<div class="paragraph">
<p>HQL和JPQL都是执行查询操作的非类型安全方式。条件查询提供了一种类型安全的查询方法。有关更多信息，请参见<a href="#criteria">条件</a> 。</p>
</div>
<div class="sect2">
<h3 id="hql-examples-domain-model"><a class="anchor" href="#hql-examples-domain-model"></a> 15.1。域模型示例</h3>
<div class="paragraph">
<p>为了更好地理解其他HQL和JPQL示例，是时候熟悉本章所有示例功能中使用的域模型实体了。</p>
</div>
<div id="hql-examples-domain-model-example" class="exampleblock">
<div class="title">示例482范例领域模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedQueries({
    @NamedQuery(
        name = "get_person_by_name",
        query = "select p from Person p where name = :name"
    )
    ,
    @NamedQuery(
        name = "get_read_only_person_by_name",
        query = "select p from Person p where name = :name",
        hints = {
            @QueryHint(
                name = "org.hibernate.readOnly",
                value = "true"
            )
        }
    )
})
@NamedStoredProcedureQueries(
    @NamedStoredProcedureQuery(
        name = "sp_person_phones",
        procedureName = "sp_person_phones",
        parameters = {
            @StoredProcedureParameter(
                name = "personId",
                type = Long.class,
                mode = ParameterMode.IN
            ),
            @StoredProcedureParameter(
                name = "personPhones",
                type = Class.class,
                mode = ParameterMode.REF_CURSOR
            )
        }
    )
)
@Entity
public class Person {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    private String nickName;

    private String address;

    @Temporal(TemporalType.TIMESTAMP )
    private Date createdOn;

    @OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
    @OrderColumn(name = "order_id")
    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();

    @ElementCollection
    @MapKeyEnumerated(EnumType.STRING)
    private Map&lt;AddressType, String&gt; addresses = new HashMap&lt;&gt;();

    @Version
    private int version;

    //Getters and setters are omitted for brevity

}

public enum AddressType {
    HOME,
    OFFICE
}

@Entity
public class Partner {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	@Version
	private int version;

	//Getters and setters are omitted for brevity

}

@Entity
public class Phone {

    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Person person;

    @Column(name = "phone_number")
    private String number;

    @Enumerated(EnumType.STRING)
    @Column(name = "phone_type")
    private PhoneType type;

    @OneToMany(mappedBy = "phone", cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(  );

    @OneToMany(mappedBy = "phone")
    @MapKey(name = "timestamp")
    @MapKeyTemporal(TemporalType.TIMESTAMP )
    private Map&lt;Date, Call&gt; callHistory = new HashMap&lt;&gt;();

    @ElementCollection
    private List&lt;Date&gt; repairTimestamps = new ArrayList&lt;&gt;(  );

    //Getters and setters are omitted for brevity

}

public enum PhoneType {
    LAND_LINE,
    MOBILE;
}

@Entity
@Table(name = "phone_call")
public class Call {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    private Phone phone;

    @Column(name = "call_timestamp")
    private Date timestamp;

    private int duration;

    //Getters and setters are omitted for brevity

}

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Payment {

    @Id
    @GeneratedValue
    private Long id;

    private BigDecimal amount;

    private boolean completed;

    @ManyToOne
    private Person person;

    //Getters and setters are omitted for brevity

}

@Entity
public class CreditCardPayment extends Payment {
}

@Entity
public class WireTransferPayment extends Payment {
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-api"><a class="anchor" href="#query-api"></a> 15.2。查询API</h3>
<div class="paragraph">
<p>使用Hibernate时，可以通过JPA或特定于Hibernate的API执行实体查询。从5.2开始，Hibernate<code>Session</code>接口扩展了JPA <code>EntityManager</code>接口。因此，查询API也已合并，现在是Hibernate <code>org.hibernate.query.Query</code>接口扩展了JPA <code>javax.persistence.Query</code> 。</p>
</div>
<div class="paragraph">
<p>接下来，我们将了解标准JPA接口和特定于Hibernate的API之间的查询API有何不同。</p>
</div>
<div class="sect3">
<h4 id="jpql-api"><a class="anchor" href="#jpql-api"></a> 15.2.1。JPA查询API</h4>
<div class="paragraph">
<p>在JPA中，查询由<code>javax.persistence.Query</code>要么<code>javax.persistence.TypedQuery</code>如从<code>EntityManager</code> 。创建内联<code>Query</code>要么<code>TypedQuery</code> ，您需要使用<code>EntityManager#createQuery</code>方法。对于命名查询， <code>EntityManager#createNamedQuery</code>方法是必需的。</p>
</div>
<div id="jpql-api-example" class="exampleblock">
<div class="title">示例483获得JPA <code>Query</code>或一个<code>TypedQuery</code>参考</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query query = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name"
);

TypedQuery&lt;Person&gt; typedQuery = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name", Person.class
);</code></pre>
</div>
</div>
</div>
</div>
<div id="jpql-api-named-query-example" class="exampleblock">
<div class="title">示例484获得JPA <code>Query</code>或一个<code>TypedQuery</code>命名查询的参考</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedQuery(
    name = "get_person_by_name",
    query = "select p from Person p where name = :name"
)

Query query = entityManager.createNamedQuery( "get_person_by_name" );

TypedQuery&lt;Person&gt; typedQuery = entityManager.createNamedQuery(
	"get_person_by_name", Person.class
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate提供了一个特定的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedQuery.html"><code>@NamedQuery</code></a>注释，它提供了配置各种查询功能的方式，例如刷新模式，可缓存性，超时间隔。</p>
</div>
<div id="jpql-api-hibernate-named-query-example" class="exampleblock">
<div class="title">示例485。获取Hibernate<code>Query</code>或一个<code>TypedQuery</code>命名查询的参考</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedQueries({
    @NamedQuery(
        name = "get_phone_by_number",
        query = "select p " +
                "from Phone p " +
                "where p.number = :number",
        timeout = 1,
        readOnly = true
    )
})

Phone phone = entityManager
	.createNamedQuery( "get_phone_by_number", Phone.class )
	.setParameter( "number", "123-456-7890" )
	.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>Query</code>接口然后可以用来控制查询的执行。例如，我们可能要指定执行超时或控件缓存。</p>
</div>
<div id="jpql-api-basic-usage-example" class="exampleblock">
<div class="title">示例486基本JPA <code>Query</code>用法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query query = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
// timeout - in milliseconds
.setHint( "javax.persistence.query.timeout", 2000 )
// flush only at commit time
.setFlushMode( FlushModeType.COMMIT );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参见<code>Query</code> <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Query.html">Javadocs</a> 。控制查询执行的许多设置都定义为提示。JPA定义了一些标准提示（例如示例中的超时），但是大多数都是特定于提供程序的。依赖于提供程序的特定提示在某种程度上限制了应用程序的可移植性。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>javax.persistence.query.timeout</code></dt>
<dd>
<p>定义查询超时（以毫秒为单位）。</p>
</dd>
<dt class="hdlist1"><code>javax.persistence.fetchgraph</code></dt>
<dd>
<p>定义一个<em>提取图EntityGraph</em> 。明确指定为的属性<code>AttributeNodes</code>被视为<code>FetchType.EAGER</code> （通过加入获取或随后的选择）。有关详细信息，请参见<a href="#fetching">Fetching中</a>的EntityGraph讨论。</p>
</dd>
<dt class="hdlist1"><code>javax.persistence.loadgraph</code></dt>
<dd>
<p>定义一个<em>加载图EntityGraph</em> 。明确指定为AttributeNodes的属性被视为<code>FetchType.EAGER</code> （通过加入获取或随后的选择）。未指定的属性被视为<code>FetchType.LAZY</code>要么<code>FetchType.EAGER</code>取决于元数据中属性的定义。有关详细信息，请参见<a href="#fetching">Fetching中</a>的EntityGraph讨论。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.cacheMode</code></dt>
<dd>
<p>定义<code>CacheMode</code>使用。看到<code>org.hibernate.query.Query#setCacheMode</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.cacheable</code></dt>
<dd>
<p>定义查询是否可缓存。真假。看到<code>org.hibernate.query.Query#setCacheable</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.cacheRegion</code></dt>
<dd>
<p>对于可缓存的查询，定义要使用的特定缓存区域。看到<code>org.hibernate.query.Query#setCacheRegion</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.comment</code></dt>
<dd>
<p>定义注释以应用于生成的SQL。看到<code>org.hibernate.query.Query#setComment</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.fetchSize</code></dt>
<dd>
<p>定义要使用的JDBC fetch-size。看到<code>org.hibernate.query.Query#setFetchSize</code></p>
</dd>
<dt class="hdlist1"><code>org.hibernate.flushMode</code></dt>
<dd>
<p>定义特定于Hibernate的<code>FlushMode</code>使用。看到<code>org.hibernate.query.Query#setFlushMode.</code>如果可能的话，最好使用<code>javax.persistence.Query#setFlushMode</code>代替。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.readOnly</code></dt>
<dd>
<p>定义该查询加载的实体和集合应标记为只读。看到<code>org.hibernate.query.Query#setReadOnly</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>执行查询之前需要完成的最后一件事情是绑定任何已定义参数的值。JPA定义了一组简化的参数绑定方法。本质上，它支持设置参数值（按名称/位置）和专用形式<code>Calendar</code> / <code>Date</code>类型另外接受<code>TemporalType</code> 。</p>
</div>
<div id="jpql-api-parameter-example" class="exampleblock">
<div class="title">示例487JPA名称参数绑定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query query = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" );

// For generic temporal field types (e.g. `java.util.Date`, `java.util.Calendar`)
// we also need to provide the associated `TemporalType`
Query query = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.createdOn &gt; :timestamp" )
.setParameter( "timestamp", timestamp, TemporalType.DATE );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>JPQL样式的位置参数使用问号声明，后跟序号- <code>?1</code> ， <code>?2</code> 。常规以1开始。就像命名参数一样，位置参数也可以在查询中多次出现。</p>
</div>
<div id="jpql-api-positional-parameter-example" class="exampleblock">
<div class="title">示例488JPA位置参数绑定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query query = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like ?1" )
.setParameter( 1, "J%" );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最好不要在给定查询中混合参数绑定形式。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在执行方面，JPA <code>Query</code>提供了两种检索结果集的方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Query#getResultList()</code> -执行选择查询并返回结果列表。</p>
</li>
<li>
<p><code>Query#getSingleResult()</code> -执行选择查询并返回单个结果。如果结果不止一个，则会引发异常。</p>
</li>
</ul>
</div>
<div id="jpql-api-list-example" class="exampleblock">
<div class="title">示例489JPA <code>getResultList()</code>结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="jpql-api-unique-result-example" class="exampleblock">
<div class="title">示例490JPA<code>getSingleResult()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = (Person) entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hql-api"><a class="anchor" href="#hql-api"></a> 15.2.2。Hibernate查询API</h4>
<div class="paragraph">
<p>在Hibernate中，HQL查询表示为<code>org.hibernate.query.Query</code>这是从<code>Session</code> 。如果HQL是命名查询， <code>Session#getNamedQuery</code>将被使用；除此以外<code>Session#createQuery</code>是必需的。</p>
</div>
<div id="hql-api-example" class="exampleblock">
<div class="title">示例491获取Hibernate<code>Query</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name"
);</code></pre>
</div>
</div>
</div>
</div>
<div id="hql-api-named-query-example" class="exampleblock">
<div class="title">示例492获取Hibernate<code>Query</code>命名查询的参考</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.getNamedQuery( "get_person_by_name" );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPQL语法不仅受到HQL的极大启发，而且许多JPA API也受到Hibernate的极大启发。他们俩<code>Query</code>合同非常相似。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以使用Query接口来控制查询的执行。例如，我们可能要指定执行超时或控件缓存。</p>
</div>
<div id="hql-api-basic-usage-example" class="exampleblock">
<div class="title">示例493。基本查询用法-Hibernate</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
// timeout - in seconds
.setTimeout( 2 )
// write to L2 caches, but do not read from them
.setCacheMode( CacheMode.REFRESH )
// assuming query cache was enabled for the SessionFactory
.setCacheable( true )
// add a comment to the generated SQL if enabled via the hibernate.use_sql_comments configuration property
.setComment( "+ INDEX(p idx_person_name)" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参见<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Query.html">Query</a> Javadocs。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里的查询提示是数据库查询提示。根据它们将它们直接添加到生成的SQL中<code>Dialect#getQueryHintString</code> 。</p>
</div>
<div class="paragraph">
<p>另一方面，查询提示的JPA概念指的是针对提供者（Hibernate）的提示。因此，即使它们的名称相同，也要注意它们的用途截然不同。此外，请注意，除非添加了代码的代码首先检查了Dialect，否则Hibernate查询提示通常会使应用程序无法跨数据库移植。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>“冲洗”中详细介绍了<a href="#flushing">冲洗</a> 。锁定在<a href="#locking">锁定</a>中有详细介绍。<a href="#pc">持久</a>状态涵盖了只读状态的概念。</p>
</div>
<div class="paragraph">
<p>Hibernate还允许应用程序通过以下方式进入构建查询结果的过程： <code>org.hibernate.transform.ResultTransformer</code>合同。有关其他详细信息，请参见其<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/transform/ResultTransformer.html">Javadocs</a>以及Hibernate提供的实现。</p>
</div>
<div class="paragraph">
<p>在执行查询之前，需要做的最后一件事是绑定查询中定义的任何参数的值。为此，查询定义了许多重载方法。最通用的形式采用该值以及“Hibernate类型”。</p>
</div>
<div id="hql-api-parameter-example" class="exampleblock">
<div class="title">示例494Hibernate名称参数绑定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%", StringType.INSTANCE );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate通常会根据查询中的上下文了解参数的预期类型。在上一个示例中，由于我们在<code>LIKE</code>与String类型的属性进行比较Hibernate会自动推断类型；因此可以简化以上内容。</p>
</div>
<div id="hql-api-parameter-inferred-type-example" class="exampleblock">
<div class="title">示例495Hibernate名称参数绑定（推断类型）</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也有用于绑定常见类型（例如字符串，布尔值，整数等）的简写形式。</p>
</div>
<div id="hql-api-parameter-short-form-example" class="exampleblock">
<div class="title">示例496Hibernate名称参数绑定（简短形式）</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name " +
	"  and p.createdOn &gt; :timestamp" )
.setParameter( "name", "J%" )
.setParameter( "timestamp", timestamp, TemporalType.TIMESTAMP);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传统上，Hibernate通过以下方式支持JDBC位置参数语法形式： <code>?</code>没有后继序号的符号。</p>
</div>
<div class="paragraph">
<p>除了将相同的值绑定到每个位置参数外，没有其他方法可以将两个这样的位置参数关联为“相同”，因此，不再支持此格式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.query.Query query = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like ?" )
.setParameter( 1, "J%" );</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在执行方面，Hibernate提供了4种不同的方法。最常用的2种是</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Query#list</code> -执行选择查询并返回结果列表。</p>
</li>
<li>
<p><code>Query#uniqueResult</code> -执行选择查询并返回单个结果。如果结果不止一个，则会引发异常。</p>
</li>
</ul>
</div>
<div id="hql-api-list-example" class="exampleblock">
<div class="title">示例497冬眠<code>list()</code>结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以从<code>Query</code> 。</p>
</div>
<div id="hql-api-unique-result-example" class="exampleblock">
<div class="title">示例498。冬眠<code>uniqueResult()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Person person = (Person) session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.uniqueResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果经常使用唯一结果，并且结果基于的属性是唯一的，则您可能需要考虑映射自然ID并使用自然ID加载API。有关此主题的更多信息，请参见<a href="#naturalid">自然ID</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="hql-api-scroll"><a class="anchor" href="#hql-api-scroll"></a> 15.2.3。查询滚动</h4>
<div class="paragraph">
<p>Hibernate提供了其他的专用方法来滚动查询和使用服务器端游标处理结果。</p>
</div>
<div class="paragraph">
<p><code>Query#scroll</code>与Scrollable的JDBC概念协同工作<code>ResultSet</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>Query#scroll</code>方法已重载：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>主要形式接受单个类型的参数<code>org.hibernate.ScrollMode</code>指示要使用的滚动类型。有关每个工具的详细信息，请参见<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/ScrollMode.html">Javadocs</a> 。</p>
</li>
<li>
<p>第二种形式不带参数，将使用<code>ScrollMode</code>表示为<code>Dialect#defaultScrollMode</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Query#scroll</code>返回一个<code>org.hibernate.ScrollableResults</code>包装基础JDBC（可滚动） <code>ResultSet</code>并提供对结果的访问。与典型的只进<code>ResultSet</code> ， <code>ScrollableResults</code>允许您浏览<code>ResultSet</code>在任何方向。</p>
</div>
<div id="hql-api-scroll-example" class="exampleblock">
<div class="title">示例499滚动浏览<code>ResultSet</code>包含实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try ( ScrollableResults scrollableResults = session.createQuery(
		"select p " +
		"from Person p " +
		"where p.name like :name" )
		.setParameter( "name", "J%" )
		.scroll()
) {
	while(scrollableResults.next()) {
		Person person = (Person) scrollableResults.get()[0];
		process(person);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于此表单包含JDBC <code>ResultSet</code>打开，应用程序应指示何时完成<code>ScrollableResults</code>通过调用它<code>close()</code>方法（继承自<code>java.io.Closeable</code>以便<code>ScrollableResults</code>将与<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a>块一起使用）。</p>
</div>
<div class="paragraph">
<p>如果应用程序未关闭，则Hibernate将自动关闭基础资源（例如， <code>ResultSet</code>和<code>PreparedStatement</code> ）由内部使用<code>ScrollableResults</code>当前事务结束时（提交或回滚）。</p>
</div>
<div class="paragraph">
<p>但是，最好关闭<code>ScrollableResults</code>明确地。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您打算使用<code>Query#scroll</code>使用集合获取时，重要的是查询必须对结果进行显式排序，以便JDBC结果顺序包含相关行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate也支持<code>Query#iterate</code> ，用于在已知加载的条目已经存储在二级缓存中时加载实体。进行迭代的想法是，将在SQL查询中仅获取匹配的标识符。根据这些标识符，通过二级缓存查找来解析标识符。如果这些第二级缓存查找失败，则将需要对数据库发出其他查询。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于加载某些特定于二级缓存中已经存在的实体的情况，此操作可以显着提高性能。在二级缓存中不存在许多实体的情况下，该操作几乎肯定会执行得更差。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>Iterator</code>从返回<code>Query#iterate</code>实际上是一个特殊类型的迭代器： <code>org.hibernate.engine.HibernateIterator</code> 。它是专门公开<code>close()</code>方法（同样，继承自<code>java.io.Closeable</code> ）。完成此操作后<code>Iterator</code>您应该通过强制转换为<code>HibernateIterator</code>要么<code>Closeable</code> ，或致电<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Hibernate.html#close-java.util.Iterator-"><code>Hibernate#close(java.util.Iterator)</code></a> 。</p>
</div>
<div class="paragraph">
<p>从5.2开始，Hibernate支持返回一个<code>Stream</code>以后可以用来转换基础<code>ResultSet</code> 。</p>
</div>
<div class="paragraph">
<p>在内部， <code>stream()</code>表现得像<code>Query#scroll</code>并且基础结果由一个<code>ScrollableResults</code> 。</p>
</div>
<div class="paragraph">
<p>使用提取投影<code>Query#stream</code>方法可以如下进行：</p>
</div>
<div id="hql-api-stream-projection-example" class="exampleblock">
<div class="title">示例500冬眠<code>stream()</code>使用投影结果类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try ( Stream&lt;Object[]&gt; persons = session.createQuery(
	"select p.name, p.nickName " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.stream() ) {

	persons
	.map( row -&gt; new PersonNames(
			(String) row[0],
			(String) row[1] ) )
	.forEach( this::process );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当获取单个结果时，例如<code>Person</code>实体，而不是<code>Stream<Object[]></code> ，Hibernate将找出实际的类型，因此结果是<code>Stream<Person></code> 。</p>
</div>
<div id="hql-api-stream-example" class="exampleblock">
<div class="title">例子501。冬眠<code>stream()</code>使用实体结果类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try( Stream&lt;Person&gt; persons = session.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like :name" )
.setParameter( "name", "J%" )
.stream() ) {

	Map&lt;Phone, List&lt;Call&gt;&gt; callRegistry = persons
			.flatMap( person -&gt; person.getPhones().stream() )
			.flatMap( phone -&gt; phone.getCalls().stream() )
			.collect( Collectors.groupingBy( Call::getPhone ) );

	process(callRegistry);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>就像<code>ScrollableResults</code> ，您应始终关闭Hibernate模式<code>Stream</code>显式地或使用<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a>块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-case-sensitivity"><a class="anchor" href="#hql-case-sensitivity"></a> 15.3。区分大小写</h3>
<div class="paragraph">
<p>除Java类和属性的名称外，查询不区分大小写。所以<code>SeLeCT</code>是相同的<code>sELEct</code>是相同的<code>SELECT</code> ，但是<code>org.hibernate.eg.FOO</code>和<code>org.hibernate.eg.Foo</code>是不同的<code>foo.barSet</code>和<code>foo.BARSET</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本文档使用小写关键字作为查询示例中的约定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-statement-types"><a class="anchor" href="#hql-statement-types"></a> 15.4。报表类型</h3>
<div class="paragraph">
<p>HQL和JPQL都允许<code>SELECT</code> ， <code>UPDATE</code>和<code>DELETE</code>要执行的语句。HQL还允许<code>INSERT</code>语句，形式类似于SQL <code>INSERT FROM SELECT</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>应注意何时<code>UPDATE</code>要么<code>DELETE</code>语句被执行。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>执行批量更新或删除操作时应谨慎，因为它们可能会导致数据库与活动持久性上下文中的实体之间出现不一致。通常，批量更新和删除操作仅应在新的持久性上下文中的事务内执行，或者应在获取或访问其状态可能受此类操作影响的实体之前执行。</p>
</div>
</blockquote>
<div class="attribution">— JPA 2.0规范的第4.10节</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-select"><a class="anchor" href="#hql-select"></a> 15.5。选择语句</h3>
<div class="paragraph">
<p>的<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> <code>SELECT</code> HQL中的语句为：</p>
</div>
<div id="hql-select-bnf-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select_statement :: =
    [select_clause]
    from_clause
    [where_clause]
    [groupby_clause]
    [having_clause]
    [orderby_clause]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最简单的HQL <code>SELECT</code>语句的形式为：</p>
</div>
<div id="hql-select-simplest-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">List&lt;Person&gt; persons = session.createQuery(
	"from Person" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPQL中的select语句与HQL完全相同，只是JPQL需要一个<code>select_clause</code> ，而HQL则没有。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p", Person.class )
.getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使HQL不需要存在<code>select_clause</code> ，最好是包含一个。对于简单的查询，意图很明确，因此预期的结果<code>select_clause</code>很容易推断。但是在更复杂的查询中，情况并非总是如此。</p>
</div>
<div class="paragraph">
<p>通常最好明确指定意图。Hibernate实际上并没有强制执行<code>select_clause</code>即使在解析JPQL查询时仍然存在，但是，对JPA可移植性感兴趣的应用程序应注意这一点。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-update"><a class="anchor" href="#hql-update"></a> 15.6。更新语句</h3>
<div class="paragraph">
<p>的BNF <code>UPDATE</code> HQL和JPQL中的语句相同：</p>
</div>
<div id="hql-update-bnf-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update_statement ::=
    update_clause [where_clause]

update_clause ::=
    UPDATE entity_name [[AS] identification_variable]
    SET update_item {, update_item}*

update_item ::=
    [identification_variable.]{state_field | single_valued_object_field} = new_value

new_value ::=
    scalar_expression | simple_entity_expression | NULL</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>UPDATE</code>语句，默认情况下不影响<code>version</code>或者<code>timestamp</code>受影响实体的属性值。</p>
</div>
<div class="paragraph">
<p>但是，您可以强制Hibernate设置<code>version</code>要么<code>timestamp</code>通过使用一个属性值<code>versioned update</code> 。这是通过添加<code>VERSIONED</code>之后的关键字<code>UPDATE</code>关键词。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>版本更新是特定于Hibernate的功能，无法以可移植的方式工作。</p>
</div>
<div class="paragraph">
<p>自定义版本类型， <code>org.hibernate.usertype.UserVersionType</code> ，不允许与<code>update versioned</code>声明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个<code>UPDATE</code>语句使用<code>executeUpdate()</code>两者之一<code>org.hibernate.query.Query</code>要么<code>javax.persistence.Query</code> 。该方法是为熟悉JDBC的人命名的<code>executeUpdate()</code>上<code>java.sql.PreparedStatement</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>int</code>由返回的值<code>executeUpdate()</code>方法指示受操作影响的实体数。这可能与数据库中受影响的行数相关或不相关。HQL批量操作可能会导致执行多个实际的SQL语句（例如，对于joined-subclass）。返回的数字表示受该语句影响的实际实体数。使用JOINED继承层次结构，对子类之一的删除实际上可能不仅导致对该子类映射到的表的删除，而且还导致“根”表和“中间”表的删除。</p>
</div>
<div id="hql-update-example" class="exampleblock">
<div class="title">示例502UPDATE查询语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">int updatedEntities = entityManager.createQuery(
	"update Person p " +
	"set p.name = :newName " +
	"where p.name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();

int updatedEntities = session.createQuery(
	"update Person " +
	"set name = :newName " +
	"where name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();

int updatedEntities = session.createQuery(
	"update versioned Person " +
	"set name = :newName " +
	"where name = :oldName" )
.setParameter( "oldName", oldName )
.setParameter( "newName", newName )
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>都没有<code>UPDATE</code>也不<code>DELETE</code>语句允许隐式联接。它们的形式也已经不允许显式连接。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-delete"><a class="anchor" href="#hql-delete"></a> 15.7。删除陈述</h3>
<div class="paragraph">
<p>的BNF <code>DELETE</code> HQL和JPQL中的语句相同：</p>
</div>
<div id="hql-delete-bnf-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">delete_statement ::=
    delete_clause [where_clause]

delete_clause ::=
    DELETE FROM entity_name [[AS] identification_variable]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>DELETE</code>语句也使用<code>executeUpdate()</code>任一方法<code>org.hibernate.query.Query</code>要么<code>javax.persistence.Query</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-insert"><a class="anchor" href="#hql-insert"></a> 15.8。插入语句</h3>
<div class="paragraph">
<p>HQL增加了定义的能力<code>INSERT</code>语句。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>没有与HQL样式的INSERT语句等效的JPQL。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>HQL的BNF <code>INSERT</code>声明是：</p>
</div>
<div id="hql-insert-bnf-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert_statement ::=
    insert_clause select_statement

insert_clause ::=
    INSERT INTO entity_name (attribute_list)

attribute_list ::=
    state_field[, state_field ]*</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>attribute_list</code>类似于<code>column specification</code>在SQL中<code>INSERT</code>声明。对于涉及映射继承的实体，只有直接在命名实体上定义的属性才能用于<code>attribute_list</code> 。不允许超类属性，子类属性没有意义。换一种说法， <code>INSERT</code>语句本质上是非多态的。</p>
</div>
<div class="paragraph">
<p><code>select_statement</code>可以是任何有效的HQL选择查询，但需要注意的是，返回类型必须与插入期望的类型匹配。当前，这是在查询编译过程中检查的，而不是允许检查委托给数据库的。这可能会导致Hibernate类型之间的问题，这些问题<em>等效</em>于<em>equal</em> 。例如，这可能会导致映射为<code>org.hibernate.type.DateType</code>以及一个定义为<code>org.hibernate.type.TimestampType</code> ，即使数据库可能没有区别或可能能够处理转换。</p>
</div>
<div class="paragraph">
<p>对于id属性，insert语句为您提供两个选项。您可以在中明确指定id属性<code>attribute_list</code> ，在这种情况下，其值取自相应的select表达式，或者从<code>attribute_list</code>在这种情况下，将使用生成的值。仅当使用在“数据库中”运行的id生成器时，后一个选项才可用。尝试与任何“ in memory”类型生成器一起使用此选项将在解析期间导致异常。</p>
</div>
<div class="paragraph">
<p>对于乐观锁定属性，insert语句再次为您提供两个选择。您可以在<code>attribute_list</code>在这种情况下，其值取自相应的选择表达式，或者从<code>attribute_list</code>在这种情况下<code>seed value</code>由相应的定义<code>org.hibernate.type.VersionType</code>用来。</p>
</div>
<div id="hql-insert-example" class="exampleblock">
<div class="title">例子503。INSERT查询语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">int insertedEntities = session.createQuery(
	"insert into Partner (id, name) " +
	"select p.id, p.name " +
	"from Person p ")
.executeUpdate();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-from-clause"><a class="anchor" href="#hql-from-clause"></a> 15.9。的<code>FROM</code>条款</h3>
<div class="paragraph">
<p>的<code>FROM</code>子句负责定义其余查询可用的对象模型类型的范围。它也负责定义其余查询可用的所有“标识变量”。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-identification-variables"><a class="anchor" href="#hql-identification-variables"></a> 15.10。识别变量</h3>
<div class="paragraph">
<p>标识变量通常称为别名。对对象模型类的引用<code>FROM</code>子句可以与一个标识变量相关联，然后可以在整个查询的其余部分中将该标识变量用于引用该类型。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，声明标识变量是可选的，尽管声明它们通常是一种好习惯。</p>
</div>
<div class="paragraph">
<p>标识变量必须遵循Java标识符有效性的规则。</p>
</div>
<div class="paragraph">
<p>根据JPQL，标识变量必须被视为不区分大小写。优良作法表示，在整个查询中应使用相同的大小写来引用给定的标识变量。换句话说，JPQL表示它们<em>可能</em>不区分大小写，因此Hibernate必须能够对它们进行区分，但这并不是一个好的做法。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-root-reference"><a class="anchor" href="#hql-root-reference"></a> 15.11。根实体引用</h3>
<div class="paragraph">
<p>根实体引用或JPA所谓的<code>range variable declaration</code> ，具体是对应用程序中映射实体类型的引用。它不能命名组件/可嵌入类型。关联（包括集合）以不同的方式处理，如稍后讨论。</p>
</div>
<div class="paragraph">
<p>根实体引用的BNF为：</p>
</div>
<div id="hql-root-reference-bnf-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">root_entity_reference ::=
    entity_name [AS] identification_variable</code></pre>
</div>
</div>
</div>
</div>
<div id="hql-root-reference-jpql-fqn-example" class="exampleblock">
<div class="title">示例504。简单查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from org.hibernate.userguide.model.Person p", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们看到查询正在定义对<code>org.hibernate.userguide.model.Person</code>对象模型类型。此外，它声明了一个别名<code>p</code>那个<code>org.hibernate.userguide.model.Person</code>参考，这是标识变量。</p>
</div>
<div class="paragraph">
<p>通常，根实体引用仅代表<code>entity name</code>而不是实体类FQN（全限定名）。默认情况下，实体名称是不合格的实体类名称，此处<code>Person</code></p>
</div>
<div id="hql-root-reference-jpql-example" class="exampleblock">
<div class="title">示例505使用实体名称作为根实体参考的简单查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使命名同一个实体，也可以指定多个根实体引用。</p>
</div>
<div id="hql-multiple-root-reference-jpql-example" class="exampleblock">
<div class="title">例子506。使用多个根实体引用的简单查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">List&lt;Object[]&gt; persons = entityManager.createQuery(
	"select distinct pr, ph " +
	"from Person pr, Phone ph " +
	"where ph.person = pr and ph is not null", Object[].class)
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr1 " +
	"from Person pr1, Person pr2 " +
	"where pr1.id &lt;&gt; pr2.id " +
	"  and pr1.address = pr2.address " +
	"  and pr1.createdOn &lt; pr2.createdOn", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-explicit-join"><a class="anchor" href="#hql-explicit-join"></a> 15.12。显式联接</h3>
<div class="paragraph">
<p>的<code>FROM</code>子句还可以使用<code>join</code>关键词。这些联接可以是<code>inner</code>要么<code>left outer</code>风格加入。</p>
</div>
<div id="hql-explicit-inner-join-example" class="exampleblock">
<div class="title">示例507。显式内部联接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr " +
	"from Person pr " +
	"join pr.phones ph " +
	"where ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.MOBILE )
.getResultList();

// same query but specifying join type as 'inner' explicitly
List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr " +
	"from Person pr " +
	"inner join pr.phones ph " +
	"where ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.MOBILE )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="hql-explicit-outer-join-example" class="exampleblock">
<div class="title">示例508显式左（外）连接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr " +
	"from Person pr " +
	"left join pr.phones ph " +
	"where ph is null " +
	"   or ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.getResultList();

// functionally the same query but using the 'left outer' phrase
List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr " +
	"from Person pr " +
	"left outer join pr.phones ph " +
	"where ph is null " +
	"   or ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>HQL还定义了一个<code>WITH</code>子句以限定加入条件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HQL样式的WITH关键字特定于Hibernate。JPQL定义了<code>ON</code>此功能的条款。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="hql-explicit-join-with-example" class="exampleblock">
<div class="title">示例509高品质<code>WITH</code>子句连接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; personsAndPhones = session.createQuery(
	"select pr.name, ph.number " +
	"from Person pr " +
	"left join pr.phones ph with ph.type = :phoneType " )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div id="hql-explicit-join-jpql-on-example" class="exampleblock">
<div class="title">示例510JPQL <code>ON</code>子句连接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; personsAndPhones = entityManager.createQuery(
	"select pr.name, ph.number " +
	"from Person pr " +
	"left join pr.phones ph on ph.type = :phoneType " )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>重要的区别在于，在生成的SQL中，条件<code>WITH/ON</code>子句成为<code>ON</code>生成的SQL中的子句，与本节中将HQL / JPQL条件作为一部分的其他查询相反<code>WHERE</code>生成的SQL中的子句。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在此特定示例中的区别可能并不那么重要。的<code>with clause</code>对于更复杂的查询，有时是必需的。</p>
</div>
<div class="paragraph">
<p>显式联接可以引用关联或组件/嵌入的属性。对于组件/嵌入式属性，联接只是逻辑上的，与物理（SQL）联接不相关。有关集合值关联引用的更多信息，请参见<a href="#hql-collection-valued-associations">集合成员引用</a> 。</p>
</div>
<div class="paragraph">
<p>显式联接的一个重要用例是定义<code>FETCH JOINS</code>它覆盖了加入的关联的惰性。例如，给定一个名为<code>Person</code>具有名为集合值的关联<code>phones</code> ， <code>JOIN FETCH</code>还将在相同的SQL查询中加载子集合：</p>
</div>
<div id="hql-explicit-fetch-join-example" class="exampleblock">
<div class="title">示例511。获取连接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// functionally the same query but using the 'left outer' phrase
List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct pr " +
	"from Person pr " +
	"left join fetch pr.phones ", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从示例中可以看到，通过插入关键字来指定访存联接<code>fetch</code>在关键字之后<code>join</code> 。在该示例中，我们使用了左外部联接，因为我们还想返回没有订单的客户。</p>
</div>
<div class="paragraph">
<p>也可以获取内部联接，但是内部联接会过滤掉根实体。在该示例中，使用内部联接将导致客户没有从结果中过滤出任何订单。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>提取联接在子查询中无效。</p>
</div>
<div class="paragraph">
<p>提取加入集合值关联时要小心，该关联在任何方面都受到进一步限制（提取的集合也将受到限制）。因此，通常认为最佳做法是不为获取的联接分配标识变量，除非指定嵌套的获取联接。</p>
</div>
<div class="paragraph">
<p>分页查询中不应使用提取联接（例如， <code>setFirstResult()</code>要么<code>setMaxResults()</code> ），也不应将它们与<code>scroll()</code>要么<code>iterate()</code>特征。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-implicit-join"><a class="anchor" href="#hql-implicit-join"></a> 15.13。隐式联接（路径表达式）</h3>
<div class="paragraph">
<p>增加对查询可用的对象模型类型范围的另一种方法是通过使用隐式联接或路径表达式。</p>
</div>
<div id="hql-implicit-join-example" class="exampleblock">
<div class="title">示例512简单的隐式联接示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createQuery(
	"select ph " +
	"from Phone ph " +
	"where ph.person.address = :address ", Phone.class )
.setParameter( "address", address )
.getResultList();

// same as
List&lt;Phone&gt; phones = entityManager.createQuery(
	"select ph " +
	"from Phone ph " +
	"join ph.person pr " +
	"where pr.address = :address ", Phone.class )
.setParameter( "address", address)
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>隐式连接始终从<code>identification variable</code> ，然后是导航运算符（ <code>.</code> ），然后是初始引用的对象模型类型的属性<code>identification variable</code> 。在示例中，初始<code>identification variable</code>是<code>ph</code>指的是<code>Phone</code>实体。的<code>ph.person</code>参考然后指的是<code>person</code>的属性<code>Phone</code>实体。
<code>person</code>是关联类型，因此我们可以进一步导航至其年龄属性。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果属性表示实体关联（非集合）或组件/嵌入式，则可以进一步导航该引用。基本值和集合值的关联无法进一步导航。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如示例所示，隐式联接可以出现在<code>FROM clause</code> 。但是，它们会影响<code>FROM clause</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>隐式联接始终被视为内部联接。</p>
</div>
<div class="paragraph">
<p>对同一隐式联接的多个引用始终引用同一逻辑和物理（SQL）联接。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="hql-implicit-join-alias-example" class="exampleblock">
<div class="title">例子513。重用隐式联接</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createQuery(
	"select ph " +
	"from Phone ph " +
	"where ph.person.address = :address " +
	"  and ph.person.createdOn &gt; :timestamp", Phone.class )
.setParameter( "address", address )
.setParameter( "timestamp", timestamp )
.getResultList();

//same as
List&lt;Phone&gt; phones = entityManager.createQuery(
	"select ph " +
	"from Phone ph " +
	"inner join ph.person pr " +
	"where pr.address = :address " +
	"  and pr.createdOn &gt; :timestamp", Phone.class )
.setParameter( "address", address )
.setParameter( "timestamp", timestamp )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就像显式联接一样，隐式联接可以引用关联或组件/嵌入的属性。有关集合值关联引用的更多信息，请参见<a href="#hql-collection-valued-associations">集合成员引用</a> 。</p>
</div>
<div class="paragraph">
<p>对于组件/嵌入式属性，联接只是逻辑上的，与物理（SQL）联接不相关。但是，与显式连接不同，隐式连接也可以引用基本状态字段，只要路径表达式在此结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-distinct"><a class="anchor" href="#hql-distinct"></a> 15.14。不同</h3>
<div class="paragraph">
<p>对于JPQL和HQL， <code>DISTINCT</code>有两个含义：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>可以将其传递到数据库，以便从结果集中删除重复项</p>
</li>
<li>
<p>联接获取子集合时，可用于过滤出相同的父实体引用</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="hql-distinct-projection-query"><a class="anchor" href="#hql-distinct-projection-query"></a> 15.14.1。将DISTINCT与SQL投影配合使用</h4>
<div class="paragraph">
<p>对于SQL预测， <code>DISTINCT</code>需要将其传递到数据库，因为重复的条目需要先过滤掉，然后再返回数据库客户端。</p>
</div>
<div id="hql-distinct-projection-query-example" class="exampleblock">
<div class="title">示例514结合使用DISTINCT和投影查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">         List&lt;String&gt; lastNames = entityManager.createQuery(
	"select distinct p.lastName " +
	"from Person p", String.class)
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行上面的查询时，Hibernate生成以下SQL查询：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT DISTINCT
    p.last_name as col_0_0_
FROM person p</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于此特定用例，通过<code>DISTINCT</code>从JPQL / HQL到数据库的关键字是正确的做法。</p>
</div>
</div>
<div class="sect3">
<h4 id="hql-distinct-entity-query"><a class="anchor" href="#hql-distinct-entity-query"></a> 15.14.2。结合使用DISTINCT和实体查询</h4>
<div class="paragraph">
<p><code>DISTINCT</code>还可在与父实体一起获取子关联时用于过滤实体对象引用。</p>
</div>
<div id="hql-distinct-entity-query-example" class="exampleblock">
<div class="title">示例515结合使用DISTINCT和实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; authors = entityManager.createQuery(
	"select distinct p " +
	"from Person p " +
	"left join fetch p.books", Person.class)
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>DISTINCT</code>之所以使用，是因为可以有多个<code>Books</code>与给定关联的实体<code>Person</code> 。如果在数据库中有3 <code>Persons</code>在数据库中，每个人都有2 <code>Books</code> ，没有<code>DISTINCT</code>该查询将返回6 <code>Persons</code>因为SQL级别的结果集大小是由联接的数量给定的<code>Book</code>记录。</p>
</div>
<div class="paragraph">
<p>然而<code>DISTINCT</code>关键字也传递给数据库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT DISTINCT
    p.id as id1_1_0_,
    b.id as id1_0_1_,
    p.first_name as first_na2_1_0_,
    p.last_name as last_nam3_1_0_,
    b.author_id as author_i3_0_1_,
    b.title as title2_0_1_,
    b.author_id as author_i3_0_0__,
    b.id as id1_0_0__
FROM person p
LEFT OUTER JOIN book b ON p.id=b.author_id</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>DISTINCT</code>不希望使用SQL关键字，因为它会进行多余的结果集排序，如<a href="http://in.relation.to/2016/08/04/introducing-distinct-pass-through-query-hint/">本博</a>文<a href="http://in.relation.to/2016/08/04/introducing-distinct-pass-through-query-hint/">中所述</a> 。为了解决此问题，Hibernate 5.2.2添加了对<code>HINT_PASS_DISTINCT_THROUGH</code>实体查询提示：</p>
</div>
<div id="hql-distinct-entity-query-hint-example" class="exampleblock">
<div class="title">示例516。结合使用DISTINCT和实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; authors = entityManager.createQuery(
	"select distinct p " +
	"from Person p " +
	"left join fetch p.books", Person.class)
.setHint( QueryHints.HINT_PASS_DISTINCT_THROUGH, false )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有了这个实体查询提示，Hibernate将不会通过<code>DISTINCT</code> SQL查询的关键字：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    p.id as id1_1_0_,
    b.id as id1_0_1_,
    p.first_name as first_na2_1_0_,
    p.last_name as last_nam3_1_0_,
    b.author_id as author_i3_0_1_,
    b.title as title2_0_1_,
    b.author_id as author_i3_0_0__,
    b.id as id1_0_0__
FROM person p
LEFT OUTER JOIN book b ON p.id=b.author_id</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用时<code>HINT_PASS_DISTINCT_THROUGH</code>实体查询提示，Hibernate仍然可以从查询结果中删除重复的父方实体。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-collection-valued-associations"><a class="anchor" href="#hql-collection-valued-associations"></a> 15.15。集合成员参考</h3>
<div class="paragraph">
<p>对集合值关联的引用实际上是指该集合的<em>值</em> 。</p>
</div>
<div id="hql-collection-valued-associations-example" class="exampleblock">
<div class="title">例子517。集合引用示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createQuery(
	"select ph " +
	"from Person pr " +
	"join pr.phones ph " +
	"join ph.calls c " +
	"where pr.address = :address " +
	"  and c.duration &gt; :duration", Phone.class )
.setParameter( "address", address )
.setParameter( "duration", duration )
.getResultList();

// alternate syntax
List&lt;Phone&gt; phones = session.createQuery(
	"select ph " +
	"from Person pr, " +
	"in (pr.phones) ph, " +
	"in (ph.calls) c " +
	"where pr.address = :address " +
	"  and c.duration &gt; :duration" )
.setParameter( "address", address )
.setParameter( "duration", duration )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在示例中，标识变量<code>ph</code>实际上是指对象模型类型<code>Phone</code> ，这是元素的类型<code>Person#phones</code>协会。</p>
</div>
<div class="paragraph">
<p>该示例还显示了使用以下命令指定集合关联联接的备用语法： <code>IN</code>句法。两种形式是等效的。应用程序选择使用哪种形式只是一个品味问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-collection-qualification"><a class="anchor" href="#hql-collection-qualification"></a> 15.16。特殊情况-限定路径表达式</h3>
<div class="paragraph">
<p>前面我们说过，集合值关联实际上是指该集合的<em>值</em> 。根据集合的类型，还可以使用一组显式的资格表达。</p>
</div>
<div id="hql-collection-qualification-example" class="exampleblock">
<div class="title">示例518合格的收藏参考示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@OneToMany(mappedBy = "phone")
@MapKey(name = "timestamp")
@MapKeyTemporal(TemporalType.TIMESTAMP )
private Map&lt;Date, Call&gt; callHistory = new HashMap&lt;&gt;();


// select all the calls (the map value) for a given Phone
List&lt;Call&gt; calls = entityManager.createQuery(
	"select ch " +
	"from Phone ph " +
	"join ph.callHistory ch " +
	"where ph.id = :id ", Call.class )
.setParameter( "id", id )
.getResultList();

// same as above
List&lt;Call&gt; calls = entityManager.createQuery(
	"select value(ch) " +
	"from Phone ph " +
	"join ph.callHistory ch " +
	"where ph.id = :id ", Call.class )
.setParameter( "id", id )
.getResultList();

// select all the Call timestamps (the map key) for a given Phone
List&lt;Date&gt; timestamps = entityManager.createQuery(
	"select key(ch) " +
	"from Phone ph " +
	"join ph.callHistory ch " +
	"where ph.id = :id ", Date.class )
.setParameter( "id", id )
.getResultList();

// select all the Call and their timestamps (the 'Map.Entry') for a given Phone
List&lt;Map.Entry&lt;Date, Call&gt;&gt; callHistory = entityManager.createQuery(
	"select entry(ch) " +
	"from Phone ph " +
	"join ph.callHistory ch " +
	"where ph.id = :id " )
.setParameter( "id", id )
.getResultList();

// Sum all call durations for a given Phone of a specific Person
Long duration = entityManager.createQuery(
	"select sum(ch.duration) " +
	"from Person pr " +
	"join pr.phones ph " +
	"join ph.callHistory ch " +
	"where ph.id = :id " +
	"  and index(ph) = :phoneIndex", Long.class )
.setParameter( "id", id )
.setParameter( "phoneIndex", phoneIndex )
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">值</dt>
<dd>
<p>引用集合值。与未指定限定符相同。有助于明确显示意图。对任何类型的集合值引用有效。</p>
</dd>
<dt class="hdlist1">指数</dt>
<dd>
<p>根据HQL规则，这对于<code>Maps</code>和<code>Lists</code>指定一个<code>javax.persistence.OrderColumn</code>注释以引用<code>Map</code>键或<code>List</code>位置（又名<code>OrderColumn</code>值）。但是，JPQL保留了此功能，以便在<code>List</code>案例和添加<code>KEY</code>为了<code>Map</code>案件。对JPA提供程序可移植性感兴趣的应用程序应意识到这一区别。</p>
</dd>
<dt class="hdlist1">键</dt>
<dd>
<p>仅对<code>Maps</code> 。指地图的键。如果键本身是实体，则可以进一步导航。</p>
</dd>
<dt class="hdlist1">条目</dt>
<dd>
<p>仅对<code>Maps</code> 。指地图的逻辑<code>java.util.Map.Entry</code>元组（键和值的组合）。
<code>ENTRY</code>仅作为终端路径有效，并且适用于<code>SELECT</code>仅子句。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关<a href="#hql-collection-expressions">与集合相关的表达式</a>的更多详细信息，请参见<a href="#hql-collection-expressions">与</a>集合相关的表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-polymorphism"><a class="anchor" href="#hql-polymorphism"></a> 15.17。多态性</h3>
<div class="paragraph">
<p>HQL和JPQL查询本质上是多态的。</p>
</div>
<div id="hql-polymorphism-example" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p ", Payment.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询将命名为<code>Payment</code>实体。但是，所有的子类<code>Payment</code>也可用于查询。所以，如果<code>CreditCardPayment</code>和<code>WireTransferPayment</code>实体扩展了<code>Payment</code>类，这三种类型都可用于实体查询，并且该查询将返回这三种类型的实例。</p>
</div>
<div class="paragraph">
<p>可以通过两种方式更改此行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过限制查询以仅从子类实体中选择</p>
</li>
<li>
<p>通过使用<code>org.hibernate.annotations.Polymorphism</code>注释（全局和特定于Hibernate的注释）。见<a href="#entity-inheritance-polymorphism"><code>@Polymorphism</code>部分，以获取有关此用例的更多信息</a> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HQL查询<code>from java.lang.Object</code>是完全有效的（尽管从性能角度来看不是很实用）！</p>
</div>
<div class="paragraph">
<p>它返回由应用程序映射定义的每个实体类型的每个对象。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-expressions"><a class="anchor" href="#hql-expressions"></a> 15.18。表达方式</h3>
<div class="paragraph">
<p>本质上，表达式是解析为基本或元组值的引用。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-identification-variable"><a class="anchor" href="#hql-identification-variable"></a> 15.19。识别变量</h3>
<div class="paragraph">
<p>查看<a href="#hql-from-clause">该<code>FROM</code>条款</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-path-expressions"><a class="anchor" href="#hql-path-expressions"></a> 15.20。路径表达式</h3>
<div class="paragraph">
<p>再次，看<a href="#hql-from-clause">的<code>FROM</code>条款</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-literals"><a class="anchor" href="#hql-literals"></a> 15.21。文字</h3>
<div class="paragraph">
<p>字符串文字用单引号引起来。要在字符串文字中转义单引号，请使用双单引号。</p>
</div>
<div id="hql-string-literals-example" class="exampleblock">
<div class="title">示例519字符串文字示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like 'Joe'", Person.class)
.getResultList();

// Escaping quotes
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like 'Joe''s'", Person.class)
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>允许使用几种不同形式的数字文字。</p>
</div>
<div id="hql-numeric-literals-example" class="exampleblock">
<div class="title">示例520数值文字示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// simple integer literal
Person person = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.id = 1", Person.class)
.getSingleResult();

// simple integer literal, typed as a long
Person person = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.id = 1L", Person.class)
.getSingleResult();

// decimal notation
List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration &gt; 100.5", Call.class )
.getResultList();

// decimal notation, typed as a float
List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration &gt; 100.5F", Call.class )
.getResultList();

// scientific notation
List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration &gt; 1e+2", Call.class )
.getResultList();

// scientific notation, typed as a float
List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration &gt; 1e+2F", Call.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以科学计数形式， <code>E</code>不区分大小写。</p>
</div>
<div class="paragraph">
<p>可以通过使用Java指定的相同后缀方法来实现特定类型。所以， <code>L</code>表示很长， <code>D</code>表示双精度<code>F</code>表示浮点数。实际的后缀不区分大小写。</p>
</div>
<div class="paragraph">
<p>布尔文字是<code>TRUE</code>和<code>FALSE</code> ，同样不区分大小写。</p>
</div>
<div class="paragraph">
<p>枚举甚至可以作为文字引用。必须使用标准的枚举类名称。尽管JPQL并未将其定义为受支持，但HQL也可以以相同的方式处理常量。</p>
</div>
<div class="paragraph">
<p>实体名称也可以用作文字。请参阅<a href="#hql-entity-type-exp">实体类型</a> 。</p>
</div>
<div class="paragraph">
<p>可以使用JDBC转义语法指定日期/时间文字：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{d 'yyyy-mm-dd'}</code>对于日期</p>
</li>
<li>
<p><code>{t 'hh:mm:ss'}</code>多次</p>
</li>
<li>
<p><code>{ts 'yyyy-mm-dd hh:mm:ss[.millis]'}</code> （millis可选）用于时间戳记。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>仅当底层JDBC驱动程序支持这些日期/时间文字时，它们才起作用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-numeric-arithmetic"><a class="anchor" href="#hql-numeric-arithmetic"></a> 15.22。算术</h3>
<div class="paragraph">
<p>算术运算也表示有效的表达式。</p>
</div>
<div id="hql-numeric-arithmetic-example" class="exampleblock">
<div class="title">示例521。数值算术示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// select clause date/time arithmetic operations
Long duration = entityManager.createQuery(
	"select sum(ch.duration) * :multiplier " +
	"from Person pr " +
	"join pr.phones ph " +
	"join ph.callHistory ch " +
	"where ph.id = 1L ", Long.class )
.setParameter( "multiplier", 1000L )
.getSingleResult();

// select clause date/time arithmetic operations
Integer years = entityManager.createQuery(
	"select year( current_date() ) - year( p.createdOn ) " +
	"from Person p " +
	"where p.id = 1L", Integer.class )
.getSingleResult();

// where clause arithmetic operations
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where year( current_date() ) - year( p.createdOn ) &gt; 1", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下规则适用于算术运算的结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果两个操作数之一是<code>Double</code> / <code>double</code> ，结果是<code>Double</code></p>
</li>
<li>
<p>否则，如果其中一个操作数是<code>Float</code> / <code>float</code> ，结果是<code>Float</code></p>
</li>
<li>
<p>否则，如果任何一个操作数是<code>BigDecimal</code> ，结果是<code>BigDecimal</code></p>
</li>
<li>
<p>否则，如果任何一个操作数是<code>BigInteger</code> ，结果是<code>BigInteger</code> （除法除外，在这种情况下，结果类型将不再定义）</p>
</li>
<li>
<p>否则，如果任何一个操作数是<code>Long</code> / <code>long</code> ，结果是<code>Long</code> （除法除外，在这种情况下，结果类型将不再定义）</p>
</li>
<li>
<p>否则，（假设两个操作数都是整数类型），结果是<code>Integer</code> （除法除外，在这种情况下，结果类型将不再定义）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>日期算术也受支持，尽管以更有限的方式。这是由于数据库支持方面的差异，部分是由于缺乏对数据库的支持<code>INTERVAL</code>查询语言本身的定义。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-concatenation"><a class="anchor" href="#hql-concatenation"></a> 15.23。串联（操作）</h3>
<div class="paragraph">
<p>HQL除了支持串联之外，还定义了串联运算符（ <code>CONCAT</code> ）功能。JPQL并未定义此属性，因此可移植的应用程序应避免使用它。串联运算符取自SQL串联运算符（例如<code>||</code> ）。</p>
</div>
<div id="hql-concatenation-example" class="exampleblock">
<div class="title">示例522串联操作示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">String name = entityManager.createQuery(
	"select 'Customer ' || p.name " +
	"from Person p " +
	"where p.id = 1", String.class )
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关<a href="#hql-exp-functions">标尺函数</a>的详细信息，请参见<a href="#hql-exp-functions">标量函数</a> 。 <code>concat()</code>功能</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-aggregate-functions"><a class="anchor" href="#hql-aggregate-functions"></a> 15.24。汇总功能</h3>
<div class="paragraph">
<p>聚合函数也是HQL和JPQL中的有效表达式。语义与它们的SQL对应物相同。支持的聚合函数是：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>COUNT</code> （包括不同/所有限定词）</dt>
<dd>
<p>结果类型始终为<code>Long</code> 。</p>
</dd>
<dt class="hdlist1"><code>AVG</code></dt>
<dd>
<p>结果类型始终为<code>Double</code> 。</p>
</dd>
<dt class="hdlist1"><code>MIN</code></dt>
<dd>
<p>结果类型与参数类型相同。</p>
</dd>
<dt class="hdlist1"><code>MAX</code></dt>
<dd>
<p>结果类型与参数类型相同。</p>
</dd>
<dt class="hdlist1"><code>SUM</code></dt>
<dd>
<p>的结果类型<code>SUM()</code>函数取决于要求和的值的类型。对于整数值（非<code>BigInteger</code> ），结果类型为<code>Long</code> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于浮点值（非<code>BigDecimal</code> ）结果类型是<code>Double</code> 。对于<code>BigInteger</code>值，结果类型为<code>BigInteger</code> 。对于<code>BigDecimal</code>值，结果类型为<code>BigDecimal</code> 。</p>
</div>
<div id="hql-aggregate-functions-example" class="exampleblock">
<div class="title">示例523汇总函数示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Object[] callStatistics = entityManager.createQuery(
	"select " +
	"	count(c), " +
	"	sum(c.duration), " +
	"	min(c.duration), " +
	"	max(c.duration), " +
	"	avg(c.duration)  " +
	"from Call c ", Object[].class )
.getSingleResult();

Long phoneCount = entityManager.createQuery(
	"select count( distinct c.phone ) " +
	"from Call c ", Long.class )
.getSingleResult();

List&lt;Object[]&gt; callCount = entityManager.createQuery(
	"select p.number, count(c) " +
	"from Call c " +
	"join c.phone p " +
	"group by p.number", Object[].class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>聚集通常与分组一起出现。有关分组的信息，请参见<a href="#hql-group-by">分组依据</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-exp-functions"><a class="anchor" href="#hql-exp-functions"></a> 15.25。标量函数</h3>
<div class="paragraph">
<p>HQL和JPQL都定义了一些可用的标准功能，而与使用的基础数据库无关。HQL还可以理解方言和应用程序定义的其他功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="jpql-standardized-functions"><a class="anchor" href="#jpql-standardized-functions"></a> 15.26。JPQL标准化功能</h3>
<div class="paragraph">
<p>这是JPQL支持定义的功能列表。对在JPA提供者之间保持可移植性感兴趣的应用程序应坚持使用这些功能。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">康卡特</dt>
<dd>
<p>字符串串联函数。两个或多个字符串值的可变参数长度要串联在一起。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; callHistory = entityManager.createQuery(
	"select concat( p.number, ' : ' , cast(c.duration as string) ) " +
	"from Call c " +
	"join c.phone p", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">订阅</dt>
<dd>
<p>提取字符串值的一部分。第二个参数表示起始位置，其中1是字符串的第一个字符。第三个（可选）参数表示长度。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; prefixes = entityManager.createQuery(
	"select substring( p.number, 1, 2 ) " +
	"from Call c " +
	"join c.phone p", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">上</dt>
<dd>
<p>大写指定的字符串</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; names = entityManager.createQuery(
	"select upper( p.name ) " +
	"from Person p ", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">降低</dt>
<dd>
<p>小写指定的字符串</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; names = entityManager.createQuery(
	"select lower( p.name ) " +
	"from Person p ", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">修剪</dt>
<dd>
<p>遵循SQL trim函数的语义。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; names = entityManager.createQuery(
	"select trim( p.name ) " +
	"from Person p ", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">长度</dt>
<dd>
<p>返回字符串的长度。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; lengths = entityManager.createQuery(
	"select length( p.name ) " +
	"from Person p ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">定位</dt>
<dd>
<p>在另一个字符串中找到一个字符串。第三个参数（可选）用于表示从其开始寻找的位置。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; sizes = entityManager.createQuery(
	"select locate( 'John', p.name ) " +
	"from Person p ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ABS</dt>
<dd>
<p>计算数值的数学绝对值。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; abs = entityManager.createQuery(
	"select abs( c.duration ) " +
	"from Call c ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">MOD</dt>
<dd>
<p>计算将第一个参数除以第二个参数的余数。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; mods = entityManager.createQuery(
	"select mod( c.duration, 10 ) " +
	"from Call c ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SQRT</dt>
<dd>
<p>计算数值的数学平方根。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Double&gt; sqrts = entityManager.createQuery(
	"select sqrt( c.duration ) " +
	"from Call c ", Double.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">当前日期</dt>
<dd>
<p>返回数据库的当前日期。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.timestamp = current_date", Call.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">当前时间</dt>
<dd>
<p>返回数据库的当前时间。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.timestamp = current_time", Call.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">CURRENT_TIMESTAMP</dt>
<dd>
<p>返回数据库的当前时间戳。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.timestamp = current_timestamp", Call.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-functions"><a class="anchor" href="#hql-functions"></a> 15.27。HQL功能</h3>
<div class="paragraph">
<p>除了JPQL标准化功能外，HQL还提供了一些可用的附加功能，而与使用的基础数据库无关。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BIT_LENGTH</dt>
<dd>
<p>返回二进制数据的长度。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Number&gt; bits = entityManager.createQuery(
	"select bit_length( c.duration ) " +
	"from Call c ", Number.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">投</dt>
<dd>
<p>执行SQL强制转换。强制转换目标应命名要使用的Hibernate映射类型。有关更多信息，请参见<a href="#basic-provided">数据类型</a>一章。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; durations = entityManager.createQuery(
	"select cast( c.duration as string ) " +
	"from Call c ", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">提取</dt>
<dd>
<p>对日期时间值执行SQL提取。提取会提取日期时间的一部分（例如年份）。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; years = entityManager.createQuery(
	"select extract( YEAR from c.timestamp ) " +
	"from Call c ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅下面的缩写形式。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">年</dt>
<dd>
<p>提取年份的缩写形式。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Integer&gt; years = entityManager.createQuery(
	"select year( c.timestamp ) " +
	"from Call c ", Integer.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">月</dt>
<dd>
<p>提取月份的缩写形式。</p>
</dd>
<dt class="hdlist1">天</dt>
<dd>
<p>提取日的缩写形式。</p>
</dd>
<dt class="hdlist1">小时</dt>
<dd>
<p>用于提取小时数的缩写提取形式。</p>
</dd>
<dt class="hdlist1">分钟</dt>
<dd>
<p>用于提取分钟的缩写提取形式。</p>
</dd>
<dt class="hdlist1">第二</dt>
<dd>
<p>用于提取第二种的缩写提取形式。</p>
</dd>
<dt class="hdlist1">STR</dt>
<dd>
<p>用于将值转换为字符数据的缩写形式。</p>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; timestamps = entityManager.createQuery(
	"select str( c.timestamp ) " +
	"from Call c ", String.class )
.getResultList();
List&lt;String&gt; timestamps = entityManager.createQuery(
	"select str( cast(duration as float) / 60, 4, 2 ) " +
	"from Call c ", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-user-defined-functions"><a class="anchor" href="#hql-user-defined-functions"></a> 15.28。用户定义的功能</h3>
<div class="paragraph">
<p>Hibernate方言可以注册已知可用于该特定数据库产品的其他功能。这些功能也可以在HQL（和JPQL）中使用，尽管仅当显然将Hibernate用作JPA提供程序时才可用。但是，它们仅在使用该数据库方言时可用。旨在数据库可移植性的应用程序应避免使用此类中的功能。</p>
</div>
<div class="paragraph">
<p>应用程序开发人员还可以提供自己的功能集。这通常代表用户定义的SQL函数或SQL代码段的别名。此类函数声明是通过使用<code>addSqlFunction()</code>的方法<code>org.hibernate.boot.MetadataBuilder</code>或遗产<code>org.hibernate.cfg.Configuration</code> 。</p>
</div>
<div class="paragraph">
<p>现在，假设我们有以下<code>apply_vat</code> PostgreSQL用户定义函数：</p>
</div>
<div id="hql-user-defined-function-postgresql-example" class="exampleblock">
<div class="title">示例524PostgreSQL用户定义函数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
	"CREATE OR REPLACE FUNCTION apply_vat(integer) RETURNS integer " +
	"   AS 'select cast(($1 * 1.2) as integer);' " +
	"   LANGUAGE SQL " +
	"   IMMUTABLE " +
	"   RETURNS NULL ON NULL INPUT;"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一下，我们在数据库中保留了以下实体：</p>
</div>
<div id="hql-user-defined-function-postgresql-entity-example" class="exampleblock">
<div class="title">示例525图书实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Book book = new Book();

book.setIsbn( "978-9730228236" );
book.setTitle( "High-Performance Java Persistence" );
book.setAuthor( "Vlad Mihalcea" );
book.setPriceCents( 4500 );

entityManager.persist( book );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hql-user-defined-functions-where-clause"><a class="anchor" href="#hql-user-defined-functions-where-clause"></a> 15.28.1。WHERE子句中引用的用户定义函数</h4>
<div class="paragraph">
<p>默认情况下，Hibernate可以传递JPQL / HQL实体查询的WHERE子句中使用的任何用户定义函数。</p>
</div>
<div id="hql-user-defined-function-postgresql-where-clause-example" class="exampleblock">
<div class="title">示例526通过WHERE子句的用户定义函数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Book&gt; books = entityManager.createQuery(
	"select b " +
	"from Book b " +
	"where apply_vat(b.priceCents) = :price ", Book.class )
.setParameter( "price", 5400 )
.getResultList();

assertTrue( books
	.stream()
	.filter( book -&gt; "High-Performance Java Persistence".equals( book.getTitle() ) )
	.findAny()
	.isPresent()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虽然这对于Hibernate来说很好，但是对于其他JPA提供程序来说可能是个问题。为此，JPA提供了<code>function</code> JPQL关键字的工作方式如下。</p>
</div>
<div id="hql-user-defined-function-postgresql-jpql-example" class="exampleblock">
<div class="title">示例527使用JPQL <code>function</code>关键词</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Book&gt; books = entityManager.createQuery(
	"select b " +
	"from Book b " +
	"where function('apply_vat', b.priceCents) = :price ", Book.class )
.setParameter( "price", 5400 )
.getResultList();

assertTrue( books
	.stream()
	.filter( book -&gt; "High-Performance Java Persistence".equals( book.getTitle() ) )
	.findAny()
	.isPresent()
);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hql-user-defined-functions-select-clause"><a class="anchor" href="#hql-user-defined-functions-select-clause"></a> 15.28.2。SELECT子句中引用的用户定义函数</h4>
<div class="paragraph">
<p>当在JPQL / HQL实体查询的SELECT子句中引用了用户定义的函数时，除非注册了该函数，否则Hibernate将无法再传递它。</p>
</div>
<div id="hql-user-defined-functions-register-metadata-builder-example" class="exampleblock">
<div class="title">例子528。使用以下命令注册用户定义的功能<code>MetadataBuilderContributor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">settings.put( "hibernate.metadata_builder_contributor",
	(MetadataBuilderContributor) metadataBuilder -&gt;
		metadataBuilder.applySqlFunction(
			"apply_vat",
			new StandardSQLFunction(
				"apply_vat",
				StandardBasicTypes.INTEGER
			)
		)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在那<code>apply_vat</code>已注册，我们可以在JPQL SELECT子句中引用它。</p>
</div>
<div id="hql-user-defined-function-postgresql-select-clause-example" class="exampleblock">
<div class="title">示例529。SELECT子句中的用户定义函数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Tuple&gt; books = entityManager.createQuery(
	"select b.title as title, apply_vat(b.priceCents) as price " +
	"from Book b " +
	"where b.author = :author ", Tuple.class )
.setParameter( "author", "Vlad Mihalcea" )
.getResultList();

assertEquals( 1, books.size() );

Tuple book = books.get( 0 );
assertEquals( "High-Performance Java Persistence", book.get( "title" ) );
assertEquals( 5400, ((Number) book.get( "price" )).intValue() );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-collection-expressions"><a class="anchor" href="#hql-collection-expressions"></a> 15.29。与集合相关的表达式</h3>
<div class="paragraph">
<p>有一些专门的表达式可用于集合值关联。通常，为了简明起见，这些仅仅是缩写形式或其他表达。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">尺寸</dt>
<dd>
<p>计算集合的大小。等同于子查询！</p>
</dd>
<dt class="hdlist1">最大化</dt>
<dd>
<p>可用于基本类型的集合。指通过应用<code>max</code> SQL聚合。</p>
</dd>
<dt class="hdlist1">MAXINDEX</dt>
<dd>
<p>可用于索引集合。指通过应用以下内容确定的最大索引（键/位置） <code>max</code> SQL聚合。</p>
</dd>
<dt class="hdlist1">军团</dt>
<dd>
<p>可用于基本类型的集合。指通过应用<code>min</code> SQL聚合。</p>
</dd>
<dt class="hdlist1">MININDEX</dt>
<dd>
<p>可用于索引集合。指通过应用以下内容确定的最小索引（键/位置） <code>min</code> SQL聚合。</p>
</dd>
<dt class="hdlist1">元素</dt>
<dd>
<p>用于指整个集合的元素。仅在where子句中允许。经常与<code>ALL</code> ， <code>ANY</code>要么<code>SOME</code>限制。</p>
</dd>
<dt class="hdlist1">指标</dt>
<dd>
<p>相似<code>elements</code>除了<code>indices</code>表达式是指整个集合的索引（键/位置）。</p>
</dd>
</dl>
</div>
<div id="hql-collection-expressions-example" class="exampleblock">
<div class="title">示例530与集合相关的表达式示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where maxelement( p.calls ) = :call", Phone.class )
.setParameter( "call", call )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where minelement( p.calls ) = :call", Phone.class )
.setParameter( "call", call )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where maxindex( p.phones ) = 0", Person.class )
.getResultList();

// the above query can be re-written with member of
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where :phone member of p.phones", Person.class )
.setParameter( "phone", phone )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where :phone = some elements ( p.phones )", Person.class )
.setParameter( "phone", phone )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where exists elements ( p.phones )", Person.class )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where current_date() &gt; key( p.callHistory )", Phone.class )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where current_date() &gt; all elements( p.repairTimestamps )", Phone.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where 1 in indices( p.phones )", Person.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where size( p.phones ) = 2", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>索引运算符可以引用索引集合的元素（数组，列表和映射）。</p>
</div>
<div id="hql-collection-index-operator-example" class="exampleblock">
<div class="title">示例531索引运算符示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// indexed lists
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.phones[ 0 ].type = 'LAND_LINE'", Person.class )
.getResultList();

// maps
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.addresses[ 'HOME' ] = :address", Person.class )
.setParameter( "address", address)
.getResultList();

//max index in list
List&lt;Person&gt; persons = entityManager.createQuery(
	"select pr " +
	"from Person pr " +
	"where pr.phones[ maxindex(pr.phones) ].type = 'LAND_LINE'", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参阅“ <a href="#hql-collection-qualification">特例-限定路径表达式”，</a>因为存在大量重叠。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-entity-type-exp"><a class="anchor" href="#hql-entity-type-exp"></a> 15.30。实体类型</h3>
<div class="paragraph">
<p>我们还可以将实体的类型称为表达式。在处理实体继承层次结构时，这主要有用。可以使用<code>TYPE</code>用于引用表示实体的标识变量的类型的函数。实体名称还用作引用实体类型的方式。另外，可以对实体类型进行参数化，在这种情况下，实体的Java类引用将被绑定为参数值。</p>
</div>
<div id="hql-entity-type-exp-example" class="exampleblock">
<div class="title">示例532实体类型表达式示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p " +
	"where type(p) = CreditCardPayment", Payment.class )
.getResultList();
List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p " +
	"where type(p) = :type", Payment.class )
.setParameter( "type", WireTransferPayment.class)
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HQL还具有一种传统形式，即使用<code>class</code>关键字，尽管该旧形式被认为已弃用，而被<code>TYPE</code> 。</p>
</div>
<div class="paragraph">
<p>旧版表格会使用<code>p.class</code>在示例而不是<code>type(p)</code> 。仅出于完整性而提及。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-case-expressions"><a class="anchor" href="#hql-case-expressions"></a> 15.31。案例表达</h3>
<div class="paragraph">
<p>支持简单和搜索形式，以及两个SQL定义的缩写形式（ <code>NULLIF</code>和<code>COALESCE</code> ）</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-simple-case-expressions"><a class="anchor" href="#hql-simple-case-expressions"></a> 15.32。简单的CASE表达式</h3>
<div class="paragraph">
<p>简单形式具有以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CASE {operand} WHEN {test_value} THEN {match_result} ELSE {miss_result} END</code></pre>
</div>
</div>
<div id="hql-simple-case-expressions-example" class="exampleblock">
<div class="title">示例533简单案例表达示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; nickNames = entityManager.createQuery(
	"select " +
	"	case p.nickName " +
	"	when 'NA' " +
	"	then '&lt;no nick name&gt;' " +
	"	else p.nickName " +
	"	end " +
	"from Person p", String.class )
.getResultList();

// same as above
List&lt;String&gt; nickNames = entityManager.createQuery(
	"select coalesce(p.nickName, '&lt;no nick name&gt;') " +
	"from Person p", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-searched-case-expressions"><a class="anchor" href="#hql-searched-case-expressions"></a> 15.33。搜索的CASE表达式</h3>
<div class="paragraph">
<p>搜索的表单具有以下语法：</p>
</div>
<div id="hql-searched-case-expressions-bnf" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CASE [ WHEN {test_conditional} THEN {match_result} ]* ELSE {miss_result} END</code></pre>
</div>
</div>
<div id="hql-searched-case-expressions-example" class="exampleblock">
<div class="title">示例534搜索的案例表达示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; nickNames = entityManager.createQuery(
	"select " +
	"	case " +
	"	when p.nickName is null " +
	"	then " +
	"		case " +
	"		when p.name is null " +
	"		then '&lt;no nick name&gt;' " +
	"		else p.name " +
	"		end" +
	"	else p.nickName " +
	"	end " +
	"from Person p", String.class )
.getResultList();

// coalesce can handle this more succinctly
List&lt;String&gt; nickNames = entityManager.createQuery(
	"select coalesce( p.nickName, p.name, '&lt;no nick name&gt;' ) " +
	"from Person p", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-case-arithmetic-expressions"><a class="anchor" href="#hql-case-arithmetic-expressions"></a> 15.34。具有算术运算的CASE表达式</h3>
<div class="paragraph">
<p>如果要在CASE表达式中使用算术运算，则需要将算术运算包装在括号中，如以下示例所示：</p>
</div>
<div id="hql-case-arithmetic-expressions-example" class="exampleblock">
<div class="title">示例535带有算术运算示例的案例表达</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Long&gt; values = entityManager.createQuery(
	"select " +
	"	case when p.nickName is null " +
	"		 then (p.id * 1000) " +
	"		 else p.id " +
	"	end " +
	"from Person p " +
	"order by p.id", Long.class)
.getResultList();

assertEquals(3, values.size());
assertEquals( 1L, (long) values.get( 0 ) );
assertEquals( 2000, (long) values.get( 1 ) );
assertEquals( 3000, (long) values.get( 2 ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无需将算术表达式包装在<code>(</code>和<code>)</code> ，则实体查询解析器将无法解析算术运算符。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-nullif"><a class="anchor" href="#hql-nullif"></a> 15.35。NULLIF表达式</h3>
<div class="paragraph">
<p>NULLIF是CASE的缩写形式，如果认为其操作数相等，则返回NULL。</p>
</div>
<div id="hql-nullif-example" class="exampleblock">
<div class="title">示例536NULLIF示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; nickNames = entityManager.createQuery(
	"select nullif( p.nickName, p.name ) " +
	"from Person p", String.class )
.getResultList();

// equivalent CASE expression
List&lt;String&gt; nickNames = entityManager.createQuery(
	"select " +
	"	case" +
	"	when p.nickName = p.name" +
	"	then null" +
	"	else p.nickName" +
	"	end " +
	"from Person p", String.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coalesce_expressions"><a class="anchor" href="#_coalesce_expressions"></a> 15.36。COALESCE表达式</h3>
<div class="paragraph">
<p><code>COALESCE</code>是缩写的CASE表达式，它返回第一个非空操作数。我们已经看到了许多<code>COALESCE</code>上面的例子。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-select-clause"><a class="anchor" href="#hql-select-clause"></a> 15.37。的<code>SELECT</code>条款</h3>
<div class="paragraph">
<p>的<code>SELECT</code>子句标识要作为查询结果返回的对象和值。除非另有说明，否则在<a href="#hql-expressions">表达式</a>中讨论的<a href="#hql-expressions">表达式</a>都是有效的选择表达式。请参见<a href="#hql-api">Hibernate Query API</a>小节，以获取有关根据结果中指定的值类型处理结果的信息。 <code>SELECT</code>条款。</p>
</div>
<div class="paragraph">
<p>有一个特定的表达式类型仅在select子句中有效。Hibernate将此称为“动态实例化”。JPQL支持其中的某些功能，并将其称为“构造函数表达式”。</p>
</div>
<div class="paragraph">
<p>因此，与其处理<code>Object[]</code> （再次参见<a href="#hql-api">Hibernate Query API</a> ），我们将值包装在类型安全的Java对象中，该对象将作为查询结果返回。</p>
</div>
<div id="hql-select-clause-dynamic-instantiation-example" class="exampleblock">
<div class="title">示例537。动态HQL和JPQL实例化示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CallStatistics {

    private final long count;
    private final long total;
    private final int min;
    private final int max;
    private final double avg;

    public CallStatistics(long count, long total, int min, int max, double avg) {
        this.count = count;
        this.total = total;
        this.min = min;
        this.max = max;
        this.avg = avg;
    }

    //Getters and setters omitted for brevity
}

CallStatistics callStatistics = entityManager.createQuery(
	"select new org.hibernate.userguide.hql.CallStatistics(" +
	"	count(c), " +
	"	sum(c.duration), " +
	"	min(c.duration), " +
	"	max(c.duration), " +
	"	avg(c.duration)" +
	")  " +
	"from Call c ", CallStatistics.class )
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>投影类必须在实体查询中完全合格，并且必须定义一个匹配的构造函数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里的类不需要映射。它可以是DTO类。</p>
</div>
<div class="paragraph">
<p>如果它确实表示实体，则返回的实例将以NEW状态（不被管理！）返回。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>HQL支持其他“动态实例化”功能。首先，查询可以指定返回一个<code>List</code>而不是<code>Object[]</code>对于标量结果：</p>
</div>
<div id="hql-select-clause-dynamic-list-instantiation-example" class="exampleblock">
<div class="title">示例538动态实例化示例-列表</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;List&gt; phoneCallDurations = entityManager.createQuery(
	"select new list(" +
	"	p.number, " +
	"	c.duration " +
	")  " +
	"from Call c " +
	"join c.phone p ", List.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询的结果将是<code>List<List></code>相对于<code>List<Object[]></code></p>
</div>
<div class="paragraph">
<p>HQL还支持将标量结果包装在<code>Map</code> 。</p>
</div>
<div id="hql-select-clause-dynamic-map-instantiation-example" class="exampleblock">
<div class="title">例子539。动态实例化示例-地图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Map&gt; phoneCallTotalDurations = entityManager.createQuery(
	"select new map(" +
	"	p.number as phoneNumber , " +
	"	sum(c.duration) as totalDuration, " +
	"	avg(c.duration) as averageDuration " +
	")  " +
	"from Call c " +
	"join c.phone p " +
	"group by p.number ", Map.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询的结果将是<code>List<Map<String, Object>></code>相对于<code>List<Object[]></code> 。映射的键由提供给选择表达式的别名定义。如果用户未分配别名，则键将是每个特定结果集列的索引（例如0、1、2等）。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-conditional-expressions"><a class="anchor" href="#hql-conditional-expressions"></a> 15.38。谓词</h3>
<div class="paragraph">
<p>谓词构成where子句，having子句和搜索到的大小写表达式的基础。它们通常是解析为真值的表达式<code>TRUE</code>要么<code>FALSE</code> ，尽管布尔比较涉及<code>NULL</code>通常解决<code>UNKNOWN</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-relational-comparisons"><a class="anchor" href="#hql-relational-comparisons"></a> 15.39。关系比较</h3>
<div class="paragraph">
<p>比较涉及比较运算符之一： <code>=</code> ， <code>></code> ， <code>>=</code> ， <code><</code> ， <code><=</code> ， <code><></code> 。HQL还定义了<code>!=</code>作为比较运算符，与<code><></code> 。操作数应为相同类型。</p>
</div>
<div id="hql-relational-comparisons-example" class="exampleblock">
<div class="title">示例540关系比较示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// numeric comparison
List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration &lt; 30 ", Call.class )
.getResultList();

// string comparison
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like 'John%' ", Person.class )
.getResultList();

// datetime comparison
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.createdOn &gt; '1950-01-01' ", Person.class )
.getResultList();

// enum comparison
List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where p.type = 'MOBILE' ", Phone.class )
.getResultList();

// boolean comparison
List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p " +
	"where p.completed = true ", Payment.class )
.getResultList();

// boolean comparison
List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p " +
	"where type(p) = WireTransferPayment ", Payment.class )
.getResultList();

// entity value comparison
List&lt;Object[]&gt; phonePayments = entityManager.createQuery(
	"select p " +
	"from Payment p, Phone ph " +
	"where p.person = ph.person ", Object[].class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>比较还可以涉及子查询限定符： <code>ALL</code> ， <code>ANY</code> ， <code>SOME</code> 。 <code>SOME</code>和<code>ANY</code>是同义词。</p>
</div>
<div class="paragraph">
<p>的<code>ALL</code>如果子查询结果中所有值的比较结果为true，则限定符将解析为true。如果子查询结果为空，则解析为false。</p>
</div>
<div id="hql-all-subquery-comparison-qualifier-example" class="exampleblock">
<div class="title">示例541ALL子查询比较限定符示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// select all persons with all calls shorter than 50 seconds
List&lt;Person&gt; persons = entityManager.createQuery(
	"select distinct p.person " +
	"from Phone p " +
	"join p.calls c " +
	"where 50 &gt; all ( " +
	"	select duration" +
	"	from Call" +
	"	where phone = p " +
	") ", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>ANY</code> / <code>SOME</code>如果对子查询结果中的某些（至少其中一个）值的比较为true，则限定符将解析为true。如果子查询结果为空，则解析为false。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-null-predicate"><a class="anchor" href="#hql-null-predicate"></a> 15.40。无效谓词</h3>
<div class="paragraph">
<p>它检查值是否为空。它可以应用于基本属性引用，实体引用和参数。HQL还允许将其应用于组件/可嵌入类型。</p>
</div>
<div id="hql-null-predicate-example" class="exampleblock">
<div class="title">示例542空度检查示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// select all persons with a nickname
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.nickName is not null", Person.class )
.getResultList();

// select all persons without a nickname
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.nickName is null", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-like-predicate"><a class="anchor" href="#hql-like-predicate"></a> 15.41。像谓词</h3>
<div class="paragraph">
<p>对字符串值执行类似的比较。语法为：</p>
</div>
<div id="hql-like-predicate-bnf" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">like_expression ::=
    string_expression
    [NOT] LIKE pattern_value
    [ESCAPE escape_character]</code></pre>
</div>
</div>
<div class="paragraph">
<p>语义遵循类似SQL的表达式的语义。的<code>pattern_value</code>是尝试匹配的模式<code>string_expression</code> 。就像SQL一样<code>pattern_value</code>可以使用<code>_</code>和<code>%</code>作为通配符。含义是相同的。的<code>_</code>符号匹配任何单个字符，并且<code>%</code>匹配任意数量的字符。</p>
</div>
<div id="hql-like-predicate-example" class="exampleblock">
<div class="title">示例543像谓词示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like 'Jo%'", Person.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name not like 'Jo%'", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可选的<code>escape 'escape character'</code>用于指定转义字符，用于转义的特殊含义<code>_</code>和<code>%</code>在里面<code>pattern_value</code> 。当需要搜索包括以下内容的模式时，这很有用<code>_</code>要么<code>%</code> 。</p>
</div>
<div class="paragraph">
<p>语法如下所示： <code>'like_predicate' escape 'escape_symbol'</code>因此，如果<code>|</code>是转义符号，我们要匹配所有以开头的存储过程<code>Dr_</code> ，类似的条件变为： <code>'Dr|_%' escape '|'</code> ：</p>
</div>
<div id="hql-like-predicate-escape-example" class="exampleblock">
<div class="title">示例544像带有逃生符号</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// find any person with a name starting with "Dr_"
List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name like 'Dr|_%' escape '|'", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-between-predicate"><a class="anchor" href="#hql-between-predicate"></a> 15.42。谓词之间</h3>
<div class="paragraph">
<p>类似于SQL <code>BETWEEN</code>表达式，它检查值是否在边界内。所有操作数应具有可比较的类型。</p>
</div>
<div id="hql-between-predicate-example" class="exampleblock">
<div class="title">示例545谓词之间</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"join p.phones ph " +
	"where p.id = 1L and index(ph) between 0 and 3", Person.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.createdOn between '1999-01-01' and '2001-01-02'", Person.class )
.getResultList();

List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"where c.duration between 5 and 20", Call.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.name between 'H' and 'M'", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-in-predicate"><a class="anchor" href="#hql-in-predicate"></a> 15.43。谓语</h3>
<div class="paragraph">
<p><code>IN</code>谓词执行检查特定值是否在值列表中。其语法为：</p>
</div>
<div id="hql-in-predicate-bnf" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">in_expression ::=
    single_valued_expression [NOT] IN single_valued_list

single_valued_list ::=
    constructor_expression | (subquery) | collection_valued_input_parameter

constructor_expression ::= (expression[, expression]*)</code></pre>
</div>
</div>
<div class="paragraph">
<p>的类型<code>single_valued_expression</code>以及<code>single_valued_list</code>必须保持一致。</p>
</div>
<div class="paragraph">
<p>JPQL在这里将有效类型限制为字符串，数字，日期，时间，时间戳和枚举类型，而在JPQL中， <code>single_valued_expression</code>只能指：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“状态字段”，它是简单属性的术语。具体来说，这不包括关联和组件/嵌入属性。</p>
</li>
<li>
<p>实体类型表达式。请参阅<a href="#hql-entity-type-exp">实体类型</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在HQL中， <code>single_valued_expression</code>可以引用更广泛的表达式类型集。允许单值关联，组件/嵌入式属性也是如此，尽管该功能取决于基础数据库中元组或“行值构造函数语法”的支持级别。此外，HQL不会以任何方式限制值类型，尽管应用程序开发人员应注意，基于基础数据库供应商的不同类型可能会产生有限的支持。这很大程度上是JPQL限制的原因。</p>
</div>
<div class="paragraph">
<p>值列表可以来自许多不同的来源。在里面<code>constructor_expression</code>和<code>collection_valued_input_parameter</code> ，值列表不能为空；它必须包含至少一个值。</p>
</div>
<div id="hql-in-predicate-example" class="exampleblock">
<div class="title">示例546在谓词示例中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Payment&gt; payments = entityManager.createQuery(
	"select p " +
	"from Payment p " +
	"where type(p) in ( CreditCardPayment, WireTransferPayment )", Payment.class )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where type in ( 'MOBILE', 'LAND_LINE' )", Phone.class )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select p " +
	"from Phone p " +
	"where type in :types", Phone.class )
.setParameter( "types", Arrays.asList( PhoneType.MOBILE, PhoneType.LAND_LINE ) )
.getResultList();

List&lt;Phone&gt; phones = entityManager.createQuery(
	"select distinct p " +
	"from Phone p " +
	"where p.person.id in (" +
	"	select py.person.id " +
	"	from Payment py" +
	"	where py.completed = true and py.amount &gt; 50 " +
	")", Phone.class )
.getResultList();

// Not JPQL compliant!
List&lt;Phone&gt; phones = entityManager.createQuery(
	"select distinct p " +
	"from Phone p " +
	"where p.person in (" +
	"	select py.person " +
	"	from Payment py" +
	"	where py.completed = true and py.amount &gt; 50 " +
	")", Phone.class )
.getResultList();

// Not JPQL compliant!
List&lt;Payment&gt; payments = entityManager.createQuery(
	"select distinct p " +
	"from Payment p " +
	"where ( p.amount, p.completed ) in (" +
	"	(50, true )," +
	"	(100, true )," +
	"	(5, false )" +
	")", Payment.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-exists-predicate"><a class="anchor" href="#hql-exists-predicate"></a> 15.44。存在谓词</h3>
<div class="paragraph">
<p>存在表达式测试子查询结果的存在。如果子查询结果包含值，则肯定形式返回true。如果子查询结果为空，则取反的形式返回true。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-empty-collection-predicate"><a class="anchor" href="#hql-empty-collection-predicate"></a> 15.45。空集合谓词</h3>
<div class="paragraph">
<p>的<code>IS [NOT] EMPTY</code>表达式适用于集合值的路径表达式。它检查特定集合是否具有任何关联的值。</p>
</div>
<div id="hql-empty-collection-predicate-example" class="exampleblock">
<div class="title">示例547空集合表达式示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.phones is empty", Person.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where p.phones is not empty", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-member-of-collection-predicate"><a class="anchor" href="#hql-member-of-collection-predicate"></a> 15.46。集合成员谓词</h3>
<div class="paragraph">
<p>的<code>[NOT] MEMBER [OF]</code>表达式适用于集合值的路径表达式。它检查一个值是否是指定集合的成员。</p>
</div>
<div id="hql-member-of-collection-predicate-example" class="exampleblock">
<div class="title">示例548成员集合表达式示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where 'Home address' member of p.addresses", Person.class )
.getResultList();

List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"where 'Home address' not member of p.addresses", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-not-predicate"><a class="anchor" href="#hql-not-predicate"></a> 15.47。非谓词运算符</h3>
<div class="paragraph">
<p>的<code>NOT</code>运算符用于否定其后的谓词。如果以下谓词为true，则NOT解析为false。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果谓词为true，则NOT解析为false。如果谓词未知（例如， <code>NULL</code> ），那么NOT也不会解析为未知。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="hql-and-predicate"><a class="anchor" href="#hql-and-predicate"></a> 15.48。AND谓词运算符</h3>
<div class="paragraph">
<p>的<code>AND</code>运算符用于组合2个谓词表达式。当且仅当两个谓词都解析为true时，AND表达式的结果才为true。如果任一谓词解析为未知，则AND表达式也解析为未知。否则，结果为假。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-or-predicate"><a class="anchor" href="#hql-or-predicate"></a> 15.49。或谓词运算符</h3>
<div class="paragraph">
<p>的<code>OR</code>运算符用于组合2个谓词表达式。如果一个谓词解析为true，则OR表达式的结果为true。如果两个谓词都解析为未知，则OR表达式解析为未知。否则，结果为假。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-where-clause"><a class="anchor" href="#hql-where-clause"></a> 15.50。的<code>WHERE</code>条款</h3>
<div class="paragraph">
<p>的<code>WHERE</code>查询的子句由谓词组成，这些谓词断言每个潜在行中的值是否与当前过滤条件匹配。因此，where子句限制从选择查询返回的结果，并限制更新和删除查询的范围。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-group-by"><a class="anchor" href="#hql-group-by"></a> 15.51。通过...分组</h3>
<div class="paragraph">
<p>的<code>GROUP BY</code>子句允许为各种价值组建立汇总结果。例如，请考虑以下查询：</p>
</div>
<div id="hql-group-by-example" class="exampleblock">
<div class="title">示例549按示例分组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Long totalDuration = entityManager.createQuery(
	"select sum( c.duration ) " +
	"from Call c ", Long.class )
.getSingleResult();

List&lt;Object[]&gt; personTotalCallDurations = entityManager.createQuery(
	"select p.name, sum( c.duration ) " +
	"from Call c " +
	"join c.phone ph " +
	"join ph.person p " +
	"group by p.name", Object[].class )
.getResultList();

//It's even possible to group by entities!
List&lt;Object[]&gt; personTotalCallDurations = entityManager.createQuery(
	"select p, sum( c.duration ) " +
	"from Call c " +
	"join c.phone ph " +
	"join ph.person p " +
	"group by p", Object[].class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个查询检索所有订单的完整总数。第二个检索按每个客户分组的每个客户的总数。</p>
</div>
<div class="paragraph">
<p>在分组查询中，where子句适用于非聚合值（本质上，它确定行是否将其纳入聚合）。的<code>HAVING</code>子句还限制结果，但是它对汇总值起作用。在“ <a href="#hql-group-by-example">按示例分组”中</a> ，我们检索了<code>Call</code>每个人的持续时间总计。如果最终导致要处理的数据过多，我们可能希望将结果限制为仅关注总数超过1000的客户：</p>
</div>
<div id="hql-group-by-having-example" class="exampleblock">
<div class="title">示例550有例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; personTotalCallDurations = entityManager.createQuery(
	"select p.name, sum( c.duration ) " +
	"from Call c " +
	"join c.phone ph " +
	"join ph.person p " +
	"group by p.name " +
	"having sum( c.duration ) &gt; 1000", Object[].class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>HAVING</code>子句遵循与<code>WHERE</code>子句，也由谓词组成。
<code>HAVING</code>在完成分组和汇总后应用，而<code>WHERE</code>子句之前被应用。</p>
</div>
</div>
<div class="sect2">
<h3 id="hql-order-by"><a class="anchor" href="#hql-order-by"></a> 15.52。排序依据</h3>
<div class="paragraph">
<p>查询的结果也可以排序。的<code>ORDER BY</code>子句用于指定用于对结果进行排序的所选值。被视为有效的一部分表达式<code>ORDER BY</code>条款包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>状态栏</p>
</li>
<li>
<p>组件/可嵌入属性</p>
</li>
<li>
<p>标量表达式，例如算术运算，函数等。</p>
</li>
<li>
<p>在select子句中声明的用于任何先前表达式类型的标识变量</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，JPQL表示， <code>ORDER BY</code>子句必须在<code>SELECT</code>条款。HQL并没有强制执行该限制，但是希望数据库具有可移植性的应用程序应注意，并非所有数据库都支持引用数据库中的值。 <code>ORDER BY</code> select子句中未引用的子句。</p>
</div>
<div class="paragraph">
<p>排序中的单个表达式可以用以下任意一种进行限定<code>ASC</code> （升序）或<code>DESC</code> （降序）表示所需的订购方向。可以使用以下命令将空值放在排序集的前面或结尾<code>NULLS FIRST</code>要么<code>NULLS LAST</code>条款。</p>
</div>
<div id="hql-order-by-example" class="exampleblock">
<div class="title">示例551举例订购</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createQuery(
	"select p " +
	"from Person p " +
	"order by p.name", Person.class )
.getResultList();

List&lt;Object[]&gt; personTotalCallDurations = entityManager.createQuery(
	"select p.name, sum( c.duration ) as total " +
	"from Call c " +
	"join c.phone ph " +
	"join ph.person p " +
	"group by p.name " +
	"order by total", Object[].class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-read-only-entities"><a class="anchor" href="#hql-read-only-entities"></a> 15.53。只读实体</h3>
<div class="paragraph">
<p>如<a href="#entity-immutability">实体不变性</a>部分所述，以只读模式获取实体比获取读写实体效率更高。即使实体是可变的，您仍然可以以只读模式获取它们，并受益于减少内存占用和加快刷新过程。</p>
</div>
<div class="paragraph">
<p>脏检查机制将跳过只读实体，如以下示例所示：</p>
</div>
<div id="hql-read-only-entities-example" class="exampleblock">
<div class="title">示例552只读实体查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"join c.phone p " +
	"where p.number = :phoneNumber ", Call.class )
.setParameter( "phoneNumber", "123-456-7890" )
.setHint( "org.hibernate.readOnly", true )
.getResultList();

calls.forEach( c -&gt; c.setDuration( 0 ) );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT c.id AS id1_5_ ,
       c.duration AS duration2_5_ ,
       c.phone_id AS phone_id4_5_ ,
       c.call_timestamp AS call_tim3_5_
FROM   phone_call c
INNER JOIN phone p ON c.phone_id = p.id
WHERE   p.phone_number = '123-456-7890'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，没有SQL <code>UPDATE</code>被执行。</p>
</div>
<div class="paragraph">
<p>您还可以使用JPA将只读提示传递给命名查询。 <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/QueryHint.html"><code>@QueryHint</code></a>注解。</p>
</div>
<div id="jpa-read-only-entities-native-example" class="exampleblock">
<div class="title">示例553使用命名查询和只读提示获取只读实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedQuery(
    name = "get_read_only_person_by_name",
    query = "select p from Person p where name = :name",
    hints = {
        @QueryHint(
            name = "org.hibernate.readOnly",
            value = "true"
        )
    }
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate本机API提供了一个<code>Query#setReadOnly</code>方法，作为使用JPA查询提示的替代方法：</p>
</div>
<div id="hql-read-only-entities-native-example" class="exampleblock">
<div class="title">示例554。只读实体本机查询示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Call&gt; calls = entityManager.createQuery(
	"select c " +
	"from Call c " +
	"join c.phone p " +
	"where p.number = :phoneNumber ", Call.class )
.setParameter( "phoneNumber", "123-456-7890" )
.unwrap( org.hibernate.query.Query.class )
.setReadOnly( true )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hql-query-plan-cache"><a class="anchor" href="#hql-query-plan-cache"></a> 15.54。实体查询计划缓存</h3>
<div class="paragraph">
<p>任何实体查询，无论是JPQL还是Criteria API，都必须解析为AST（抽象语法树），以便Hibernate可以生成正确的SQL语句。实体查询编译需要时间，因此，Hibernate提供了查询计划缓存。</p>
</div>
<div class="paragraph">
<p>执行实体查询时，Hibernate首先检查计划缓存，只有在没有可用计划时，才会立即计算一个新计划。</p>
</div>
<div class="paragraph">
<p>可以通过以下配置属性来配置查询计划缓存：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.query.plan_cache_max_size</code></dt>
<dd>
<p>此设置给出了计划缓存的最大条目数。默认值为2048。</p>
</dd>
<dt class="hdlist1"><code>hibernate.query.plan_parameter_metadata_max_size</code></dt>
<dd>
<p>该设置给出了最大数量<code>ParameterMetadataImpl</code>查询计划缓存维护的实例。的<code>ParameterMetadataImpl</code>对象封装有关查询中遇到的参数的元数据。默认值为128。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>现在，如果您有许多JPQL或Criteria API查询，则增加查询计划缓存大小是一个好主意，以便绝大多数执行实体查询可以跳过编译阶段，从而减少了执行时间。</p>
</div>
<div class="paragraph">
<p>为了更好地了解查询计划缓存的有效性，Hibernate提供了一些可以使用的统计信息。有关更多详细信息，请查看“ <a href="#statistics-query-plan-cache">查询计划缓存统计信息”</a>部分。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="criteria"><a class="anchor" href="#criteria"></a> 16。标准</h2>
<div class="sectionbody">
<div class="paragraph">
<p>标准查询提供了HQL，JPQL和本机SQL查询的类型安全的替代方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate提供了较旧的传统<code>org.hibernate.Criteria</code>应视为已弃用的API。</p>
</div>
<div class="paragraph">
<p>没有针对这些API的功能开发。最终，特定于Hibernate的Criteria功能将被移植为JPA的扩展<code>javax.persistence.criteria.CriteriaQuery</code> 。有关的详细信息<code>org.hibernate.Criteria</code> API，请参见<a href="#appendix-legacy-criteria">旧版Hibernate标准查询</a> 。</p>
</div>
<div class="paragraph">
<p>本章将重点介绍用于声明类型安全条件查询的JPA API。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>标准查询是一种编程的，类型安全的方式来表达查询。就使用接口和类表示查询的各种结构部分（例如查询本身，select子句或排序依据等）而言，它们是类型安全的。就引用属性而言，它们也是类型安全的。正如我们将看到的。较旧的Hibernate用户<code>org.hibernate.Criteria</code>查询API将认可通用方法，尽管我们认为JPA API会更胜一筹，因为它可以清晰地了解从该API中学到的教训。</p>
</div>
<div class="paragraph">
<p>条件查询本质上是一个对象图，其中图的每个部分代表查询中越来越多的原子部分（随着我们向下浏览该图）。执行条件查询的第一步是构建该图。的<code>javax.persistence.criteria.CriteriaBuilder</code>界面是开始使用条件查询时需要熟悉的第一件事。它的作用是为所有准则的各个部分提供工厂服务。您获得一个<code>javax.persistence.criteria.CriteriaBuilder</code>通过调用实例<code>getCriteriaBuilder()</code>任一方法<code>javax.persistence.EntityManagerFactory</code>要么<code>javax.persistence.EntityManager</code> 。</p>
</div>
<div class="paragraph">
<p>下一步是获取<code>javax.persistence.criteria.CriteriaQuery</code> 。这是通过以下三种方法之一完成的<code>javax.persistence.criteria.CriteriaBuilder</code>以此目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><T> CriteriaQuery<T> createQuery( Class<T> resultClass )</code></p>
</li>
<li>
<p><code>CriteriaQuery<Tuple> createTupleQuery()</code></p>
</li>
<li>
<p><code>CriteriaQuery<Object> createQuery()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每种查询都有不同的用途，具体取决于查询结果的预期类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA规范的第6章（即Criteria API）已经包含与标准查询的各个部分有关的大量参考资料。因此，与其在此处复制所有内容，不如看一下API的一些更广泛预期的用法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="criteria-typedquery"><a class="anchor" href="#criteria-typedquery"></a> 16.1。键入条件查询</h3>
<div class="paragraph">
<p>条件查询的类型（也称为<code><T></code> ）表示查询结果中的预期类型。这可能是一个实体，一个<code>Integer</code>或任何其他对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-typedquery-entity"><a class="anchor" href="#criteria-typedquery-entity"></a> 16.2。选择一个实体</h3>
<div class="paragraph">
<p>这可能是最常见的查询形式。该应用程序要选择实体实例。</p>
</div>
<div id="criteria-typedquery-entity-example" class="exampleblock">
<div class="title">示例555选择根实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Person&gt; criteria = builder.createQuery( Person.class );
Root&lt;Person&gt; root = criteria.from( Person.class );
criteria.select( root );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;Person&gt; persons = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例使用<code>createQuery()</code>传递<code>Person</code>类引用，因为查询结果将是<code>Person</code>对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>呼吁<code>CriteriaQuery#select</code>在此示例中，方法是不必要的，因为<em>root</em>是隐含的选择，因为我们只有一个查询root。此处仅出于示例完整性的目的进行了此操作。</p>
</div>
<div class="paragraph">
<p>的<code>Person_.name</code> reference是JPA元模型参考的静态形式的示例。我们将在本章中专门使用该表格。有关JPA静态元模型的更多详细信息，请参见<a href="https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/metamodelgen/MetamodelGenerator.html">Hibernate JPA元模型生成器</a>的文档。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="criteria-typedquery-expression"><a class="anchor" href="#criteria-typedquery-expression"></a> 16.3。选择一个表达式</h3>
<div class="paragraph">
<p>选择表达式的最简单形式是从实体中选择特定属性。但是此表达式也可能表示聚合，数学运算等。</p>
</div>
<div id="criteria-typedquery-expression-example" class="exampleblock">
<div class="title">示例556选择一个属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;String&gt; criteria = builder.createQuery( String.class );
Root&lt;Person&gt; root = criteria.from( Person.class );
criteria.select( root.get( Person_.nickName ) );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;String&gt; nickNames = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此的示例查询键入为<code>java.lang.String</code>因为这是预期的结果类型（ <code>Person#nickName</code>属性是<code>java.lang.String</code> ）。由于查询可能包含对的多个引用<code>Person</code>实体，属性引用始终需要限定。这是通过<code>Root#get</code>方法调用。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-typedquery-multiselect"><a class="anchor" href="#criteria-typedquery-multiselect"></a> 16.4。选择多个值</h3>
<div class="paragraph">
<p>实际上，有几种使用条件查询选择多个值的方法。我们将在此处探讨两个选项，但推荐的替代方法是使用元<a href="#criteria-tuple">组条件查询中</a>所述的<a href="#criteria-tuple">元组</a> ，或考虑包装器查询，有关详细信息，请参阅<a href="#criteria-typedquery-wrapper">选择包装器</a> 。</p>
</div>
<div id="criteria-typedquery-multiselect-array-explicit-example" class="exampleblock">
<div class="title">示例557。选择一个数组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Object[]&gt; criteria = builder.createQuery( Object[].class );
Root&lt;Person&gt; root = criteria.from( Person.class );

Path&lt;Long&gt; idPath = root.get( Person_.id );
Path&lt;String&gt; nickNamePath = root.get( Person_.nickName);

criteria.select( builder.array( idPath, nickNamePath ) );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;Object[]&gt; idAndNickNames = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从技术上讲，这被归类为类型化查询，但是从处理结果中可以看出，这是一种误导。无论如何，这里的预期结果类型是一个数组。</p>
</div>
<div class="paragraph">
<p>然后，该示例使用以下数组方法<code>javax.persistence.criteria.CriteriaBuilder</code>明确地将单个选择组合到一个<code>javax.persistence.criteria.CompoundSelection</code> 。</p>
</div>
<div id="criteria-typedquery-multiselect-array-implicit-example" class="exampleblock">
<div class="title">示例558使用选择数组<code>multiselect</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Object[]&gt; criteria = builder.createQuery( Object[].class );
Root&lt;Person&gt; root = criteria.from( Person.class );

Path&lt;Long&gt; idPath = root.get( Person_.id );
Path&lt;String&gt; nickNamePath = root.get( Person_.nickName);

criteria.multiselect( idPath, nickNamePath );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;Object[]&gt; idAndNickNames = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就像在<a href="#criteria-typedquery-multiselect-array-explicit-example">选择数组中</a>看到的那样<a href="#criteria-typedquery-multiselect-array-explicit-example">，</a>我们有一个类型化条件查询返回一个<code>Object</code>数组。这两个查询在功能上是等效的。第二个示例使用<code>multiselect()</code>该方法的行为根据首次建立条件查询时给定的类型而略有不同，但是在这种情况下，它表示选择并返回<em>Object []</em> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-typedquery-wrapper"><a class="anchor" href="#criteria-typedquery-wrapper"></a> 16.5。选择包装纸</h3>
<div class="paragraph">
<p><a href="#criteria-typedquery-multiselect">选择多个值的</a>另一种<a href="#criteria-typedquery-multiselect">选择</a>是改为选择一个将“包装”多个值的对象。回到那里的示例查询，而不是返回<em>[Person＃id，Person＃nickName]</em>的数组，而是声明一个包含这些值的类并将其用作返回对象。</p>
</div>
<div id="criteria-typedquery-wrapper-example" class="exampleblock">
<div class="title">示例559选择包装纸</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PersonWrapper {

    private final Long id;

    private final String nickName;

    public PersonWrapper(Long id, String nickName) {
        this.id = id;
        this.nickName = nickName;
    }

    public Long getId() {
        return id;
    }

    public String getNickName() {
        return nickName;
    }
}


CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;PersonWrapper&gt; criteria = builder.createQuery( PersonWrapper.class );
Root&lt;Person&gt; root = criteria.from( Person.class );

Path&lt;Long&gt; idPath = root.get( Person_.id );
Path&lt;String&gt; nickNamePath = root.get( Person_.nickName);

criteria.select( builder.construct( PersonWrapper.class, idPath, nickNamePath ) );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;PersonWrapper&gt; wrappers = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>首先，我们将看到用于包装结果值的包装对象的简单定义。具体来说，请注意构造函数及其参数类型。因为我们会回来<code>PersonWrapper</code>对象，我们使用<code>PersonWrapper</code>作为我们的条件查询的类型。</p>
</div>
<div class="paragraph">
<p>此示例说明了<code>javax.persistence.criteria.CriteriaBuilder</code>用于构造包装器表达式的方法构造。对于结果的每一行，我们都说我们想要一个<code>PersonWrapper</code>由匹配的构造函数用剩余的参数实例化。然后将这个包装表达式作为选择传递。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-tuple"><a class="anchor" href="#criteria-tuple"></a> 16.6。元组条件查询</h3>
<div class="paragraph">
<p><a href="#criteria-typedquery-multiselect">选择多个值的</a>一种更好的方法是使用包装器（我们刚刚在<a href="#criteria-typedquery-wrapper">选择包装器中</a>看到<a href="#criteria-typedquery-wrapper">了</a> ）或使用<code>javax.persistence.Tuple</code>合同。</p>
</div>
<div id="criteria-tuple-example" class="exampleblock">
<div class="title">示例560选择一个元组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Tuple&gt; criteria = builder.createQuery( Tuple.class );
Root&lt;Person&gt; root = criteria.from( Person.class );

Path&lt;Long&gt; idPath = root.get( Person_.id );
Path&lt;String&gt; nickNamePath = root.get( Person_.nickName);

criteria.multiselect( idPath, nickNamePath );
criteria.where( builder.equal( root.get( Person_.name ), "John Doe" ) );

List&lt;Tuple&gt; tuples = entityManager.createQuery( criteria ).getResultList();

for ( Tuple tuple : tuples ) {
	Long id = tuple.get( idPath );
	String nickName = tuple.get( nickNamePath );
}

//or using indices
for ( Tuple tuple : tuples ) {
	Long id = (Long) tuple.get( 0 );
	String nickName = (String) tuple.get( 1 );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>本示例说明了通过查询访问查询结果<code>javax.persistence.Tuple</code>接口。该示例使用显式<code>createTupleQuery()</code>的<code>javax.persistence.criteria.CriteriaBuilder</code> 。另一种方法是使用<code>createQuery( Tuple.class )</code> 。</p>
</div>
<div class="paragraph">
<p>再次，我们看到了<code>multiselect()</code>方法，就像使用中<a href="#criteria-typedquery-multiselect-array-implicit-example">选择数组一样<code>multiselect</code></a> 。此处的区别在于<code>javax.persistence.criteria.CriteriaQuery</code>被定义为<code>javax.persistence.Tuple</code>因此，在这种情况下，复合选择被解释为元组元素。</p>
</div>
<div class="paragraph">
<p>javax.persistence。元组合约提供了三种访问基本元素的方式：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">打字</dt>
<dd>
<p>“ <a href="#criteria-tuple-example">选择元组”</a>示例说明了这种访问方式<code>tuple.get( idPath )</code>和<code>tuple.get( nickNamePath )</code>电话。这允许基于以下内容对基础元组值进行类型化访问： <code>javax.persistence.TupleElement</code>用于构建标准的表达式。</p>
</dd>
<dt class="hdlist1">位置的</dt>
<dd>
<p>允许根据位置访问基础元组值。简单的<em>Object get（int position）</em>形式与<a href="#criteria-typedquery-multiselect-array-explicit-example">选择数组</a>和<a href="#criteria-typedquery-multiselect-array-implicit-example">使用</a> <a href="#criteria-typedquery-multiselect-array-explicit-example">选择数组中</a>所示的访问非常相似。 <a href="#criteria-typedquery-multiselect-array-implicit-example"><code>multiselect</code></a> 。<em><x>X get（int position，Class <x>type</x></x></em>形式）允许键入位置访问，但是基于显式提供的类型，该元组值必须是类型可分配的。</p>
</dd>
<dt class="hdlist1">混叠</dt>
<dd>
<p>允许基于（可选）分配的别名访问基础元组值。示例查询未应用别名。别名将通过别名方法应用于<code>javax.persistence.criteria.Selection</code> 。就像<code>positional</code>访问，既有类型化的（ <em>Object get（String alias）</em> ）和无类型化的（ <em><x>X get（String alias，Class <x>type</x></x></em> form）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="criteria-from"><a class="anchor" href="#criteria-from"></a> 16.7。FROM子句</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>一种<code>CriteriaQuery</code>对象定义对一个或多个实体，可嵌入或基本抽象模式类型的查询。查询的根对象是实体，通过导航可从中访问其他类型。</p>
</div>
<div class="paragraph">
<p>— JPA规范，第6.5.2节“查询根”，第262页</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FROM子句的所有各个部分（根，连接，路径）都实现了<code>javax.persistence.criteria.From</code>接口。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="criteria-from-root"><a class="anchor" href="#criteria-from-root"></a> 16.8。根源</h3>
<div class="paragraph">
<p>根定义了查询中所有联接，路径和属性可用的基础。根始终是实体类型。根是通过将方法的重载定义并添加到标准中的<code>javax.persistence.criteria.CriteriaQuery</code> ：</p>
</div>
<div id="criteria-from-root-methods-example" class="exampleblock">
<div class="title">示例561根方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">&lt;X&gt; Root&lt;X&gt; from( Class&lt;X&gt; );

&lt;X&gt; Root&lt;X&gt; from( EntityType&lt;X&gt; );</code></pre>
</div>
</div>
</div>
</div>
<div id="criteria-from-root-example" class="exampleblock">
<div class="title">实施例562。添加根示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Person&gt; criteria = builder.createQuery( Person.class );
Root&lt;Person&gt; root = criteria.from( Person.class );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>条件查询可以定义多个根，其作用是在新添加的根和其他根之间创建笛卡尔乘积。这是一个定义之间的笛卡尔积的示例<code>Person</code>和<code>Partner</code>实体：</p>
</div>
<div id="criteria-from-multiple-root-example" class="exampleblock">
<div class="title">示例563。添加多个根示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Tuple&gt; criteria = builder.createQuery( Tuple.class );

Root&lt;Person&gt; personRoot = criteria.from( Person.class );
Root&lt;Partner&gt; partnerRoot = criteria.from( Partner.class );
criteria.multiselect( personRoot, partnerRoot );

Predicate personRestriction = builder.and(
	builder.equal( personRoot.get( Person_.address ), address ),
	builder.isNotEmpty( personRoot.get( Person_.phones ) )
);
Predicate partnerRestriction = builder.and(
	builder.like( partnerRoot.get( Partner_.name ), prefix ),
	builder.equal( partnerRoot.get( Partner_.version ), 0 )
);
criteria.where( builder.and( personRestriction, partnerRestriction ) );

List&lt;Tuple&gt; tuples = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-from-join"><a class="anchor" href="#criteria-from-join"></a> 16.9。加入</h3>
<div class="paragraph">
<p>联接允许从其他导航<code>javax.persistence.criteria.From</code>关联或嵌入属性。联接是由许多重载联接方法创建的。 <code>javax.persistence.criteria.From</code>接口。</p>
</div>
<div id="criteria-from-join-example" class="exampleblock">
<div class="title">示例564。加盟实例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Phone&gt; criteria = builder.createQuery( Phone.class );
Root&lt;Phone&gt; root = criteria.from( Phone.class );

// Phone.person is a @ManyToOne
Join&lt;Phone, Person&gt; personJoin = root.join( Phone_.person );
// Person.addresses is an @ElementCollection
Join&lt;Person, String&gt; addressesJoin = personJoin.join( Person_.addresses );

criteria.where( builder.isNotEmpty( root.get( Phone_.calls ) ) );

List&lt;Phone&gt; phones = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-from-fetch"><a class="anchor" href="#criteria-from-fetch"></a> 16.10。抓取</h3>
<div class="paragraph">
<p>就像在HQL和JPQL中一样，条件查询可以指定与所有者一起提取关联的数据。提取是通过多种重载的提取方法创建的<code>javax.persistence.criteria.From</code>接口。</p>
</div>
<div id="criteria-from-fetch-example" class="exampleblock">
<div class="title">实施例565。加入获取示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Phone&gt; criteria = builder.createQuery( Phone.class );
Root&lt;Phone&gt; root = criteria.from( Phone.class );

// Phone.person is a @ManyToOne
Fetch&lt;Phone, Person&gt; personFetch = root.fetch( Phone_.person );
// Person.addresses is an @ElementCollection
Fetch&lt;Person, String&gt; addressesJoin = personFetch.fetch( Person_.addresses );

criteria.where( builder.isNotEmpty( root.get( Phone_.calls ) ) );

List&lt;Phone&gt; phones = entityManager.createQuery( criteria ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从技术上讲，嵌入属性总是与它们的所有者一起获取。但是，为了定义对<em>Phone＃</em> addresss的提取，我们需要一个<code>javax.persistence.criteria.Fetch</code>因为元素集合是<code>LAZY</code>默认。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="criteria-path"><a class="anchor" href="#criteria-path"></a> 16.11。路径表达式</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根，联接和访存本身也是路径表达式。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="criteria-param"><a class="anchor" href="#criteria-param"></a> 16.12。使用参数</h3>
<div id="criteria-param-example" class="exampleblock">
<div class="title">实施例566。参数示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Person&gt; criteria = builder.createQuery( Person.class );
Root&lt;Person&gt; root = criteria.from( Person.class );

ParameterExpression&lt;String&gt; nickNameParameter = builder.parameter( String.class );
criteria.where( builder.equal( root.get( Person_.nickName ), nickNameParameter ) );

TypedQuery&lt;Person&gt; query = entityManager.createQuery( criteria );
query.setParameter( nickNameParameter, "JD" );
List&lt;Person&gt; persons = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用参数方法<code>javax.persistence.criteria.CriteriaBuilder</code>获取参数参考。然后使用参数引用将参数值绑定到<code>javax.persistence.Query</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-group-by"><a class="anchor" href="#criteria-group-by"></a> 16.13。使用分组依据</h3>
<div id="criteria-group-by-example" class="exampleblock">
<div class="title">示例567按示例分组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery&lt;Tuple&gt; criteria = builder.createQuery( Tuple.class );
Root&lt;Person&gt; root = criteria.from( Person.class );

criteria.groupBy(root.get("address"));
criteria.multiselect(root.get("address"), builder.count(root));

List&lt;Tuple&gt; tuples = entityManager.createQuery( criteria ).getResultList();

for ( Tuple tuple : tuples ) {
	String name = (String) tuple.get( 0 );
	Long count = (Long) tuple.get( 1 );
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sql"><a class="anchor" href="#sql"></a> 17。本机SQL查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您也可以使用数据库的本地SQL方言来表达查询。如果您要利用特定于数据库的功能（例如窗口函数，通用表表达式（CTE）或<code>CONNECT BY</code> Oracle中的选项。它还提供了从直接基于SQL / JDBC的应用程序到Hibernate / JPA的干净迁移路径。 Hibernate还允许您为所有创建，更新，删除和检索操作指定手写SQL（包括存储过程）。</p>
</div>
<div class="sect2">
<h3 id="sql-jpa-query"><a class="anchor" href="#sql-jpa-query"></a> 17.1。使用JPA创建本机查询</h3>
<div class="paragraph">
<p>本机SQL查询的执行是通过<code>NativeQuery</code>接口，通过调用获得<code>Session.createNativeQuery()</code> 。以下各节介绍如何使用此API进行查询。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-scalar-query"><a class="anchor" href="#sql-scalar-query"></a> 17.2。标量查询</h3>
<div class="paragraph">
<p>最基本的SQL查询是获取标量（列）值的列表。</p>
</div>
<div id="sql-jpa-all-columns-scalar-query-example" class="exampleblock">
<div class="title">示例568JPA本机查询选择所有列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = entityManager.createNativeQuery(
	"SELECT * FROM Person" )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-jpa-custom-column-selection-scalar-query-example" class="exampleblock">
<div class="title">示例569。具有自定义列选择的JPA本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = entityManager.createNativeQuery(
	"SELECT id, name FROM Person" )
.getResultList();

for(Object[] person : persons) {
	Number id = (Number) person[0];
	String name = (String) person[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-all-columns-scalar-query-example" class="exampleblock">
<div class="title">示例570Hibernate本机查询选择所有列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = session.createNativeQuery(
	"SELECT * FROM Person" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-custom-column-selection-scalar-query-example" class="exampleblock">
<div class="title">示例571具有自定义列选择的Hibernate本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = session.createNativeQuery(
	"SELECT id, name FROM Person" )
.list();

for(Object[] person : persons) {
	Number id = (Number) person[0];
	String name = (String) person[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些将返回一个<code>List</code>的<code>Object</code>数组（ <code>Object[]</code> ），并为<code>PERSON</code>表。Hibernate将使用<code>java.sql.ResultSetMetadata</code>推断返回的标量值的实际顺序和类型。</p>
</div>
<div class="paragraph">
<p>避免使用的开销<code>ResultSetMetadata</code> ，或者只是为了更明确地说明返回的内容，可以使用<code>addScalar()</code> ：</p>
</div>
<div id="sql-hibernate-scalar-query-explicit-result-set-example" class="exampleblock">
<div class="title">示例572具有显式结果集选择的Hibernate本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = session.createNativeQuery(
	"SELECT * FROM Person" )
.addScalar( "id", LongType.INSTANCE )
.addScalar( "name", StringType.INSTANCE )
.list();

for(Object[] person : persons) {
	Long id = (Long) person[0];
	String name = (String) person[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管它仍然返回<code>Object</code>数组，此查询将不使用<code>ResultSetMetadata</code>因为它明确获得了<code>id</code>和<code>name</code>列分别为<code>BigInteger</code>和一个<code>String</code>从底层<code>ResultSet</code> 。这也意味着即使查询仍在使用中，也仅返回这两列<code>*</code>和<code>ResultSet</code>包含的内容不止列出的三个列。</p>
</div>
<div class="paragraph">
<p>可以省略所有或某些标量的类型信息。</p>
</div>
<div id="sql-hibernate-scalar-query-partial-explicit-result-set-example" class="exampleblock">
<div class="title">示例573选择部分结果集的Hibernate本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; persons = session.createNativeQuery(
	"SELECT * FROM Person" )
.addScalar( "id", LongType.INSTANCE )
.addScalar( "name" )
.list();

for(Object[] person : persons) {
	Long id = (Long) person[0];
	String name = (String) person[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询与以前基本相同，但是现在<code>ResultSetMetaData</code>用于确定类型<code>name</code> ，而类型<code>id</code>被明确指定。</p>
</div>
<div class="paragraph">
<p>如何<code>java.sql.Types</code>从返回<code>ResultSetMetaData</code>映射到Hibernate类型是由<code>Dialect</code> 。如果未映射特定类型，或未生成预期类型，则可以通过调用以下内容来对其进行自定义<code>registerHibernateType</code>在方言中。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-entity-query"><a class="anchor" href="#sql-entity-query"></a> 17.3。实体查询</h3>
<div class="paragraph">
<p>在上面的查询都是返回标量值的，也就是从返回<em>原始</em>值<code>ResultSet</code> 。</p>
</div>
<div id="sql-jpa-entity-query-example" class="exampleblock">
<div class="title">示例574JPA本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createNativeQuery(
	"SELECT * FROM Person", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-query-example" class="exampleblock">
<div class="title">示例575Hibernate本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createNativeQuery(
	"SELECT * FROM Person" )
.addEntity( Person.class )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假如说<code>Person</code>被映射为带有列的类<code>id</code> ， <code>name</code> ， <code>nickName</code> ， <code>address</code> ， <code>createdOn</code>和<code>version</code> ，以下查询还将返回一个<code>List</code>每个元素是一个<code>Person</code>实体。</p>
</div>
<div id="sql-jpa-entity-query-explicit-result-set-example" class="exampleblock">
<div class="title">范例576。JPA本机查询选择具有显式结果集的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createNativeQuery(
	"SELECT id, name, nickName, address, createdOn, version " +
	"FROM Person", Person.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-query-explicit-result-set-example" class="exampleblock">
<div class="title">示例577Hibernate本机查询选择具有显式结果集的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createNativeQuery(
	"SELECT id, name, nickName, address, createdOn, version " +
	"FROM Person" )
.addEntity( Person.class )
.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sql-entity-associations-query"><a class="anchor" href="#sql-entity-associations-query"></a> 17.4。处理关联和集合</h3>
<div class="paragraph">
<p>如果实体与<code>many-to-one</code>或儿童方面<code>one-to-one</code>对于另一个实体，在执行本机查询时还需要返回此值，否则，将发生数据库特定的<em>列未找到</em>错误。</p>
</div>
<div id="sql-jpa-entity-associations-query-many-to-one-example" class="exampleblock">
<div class="title">示例578具有多对一关联的JPA本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createNativeQuery(
	"SELECT id, phone_number, phone_type, person_id " +
	"FROM Phone", Phone.class )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-associations-query-many-to-one-example" class="exampleblock">
<div class="title">范例579。具有多对一关联的Hibernate本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = session.createNativeQuery(
	"SELECT id, phone_number, phone_type, person_id " +
	"FROM Phone" )
.addEntity( Phone.class )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将允许<code>Phone#person</code>由于<code>many-to-one</code>要么<code>one-to-one</code>关联将使用第一次导航时将初始化的代理。</p>
</div>
<div class="paragraph">
<p>有可能热切地加入<code>Phone</code>和<code>Person</code>实体，以避免可能的额外往返来初始化<code>many-to-one</code>协会。</p>
</div>
<div id="sql-hibernate-entity-associations-query-many-to-one-join-example" class="exampleblock">
<div class="title">示例580具有连接的多对一关联的Hibernate本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = session.createNativeQuery(
	"SELECT * " +
	"FROM Phone ph " +
	"JOIN Person pr ON ph.person_id = pr.id" )
.addEntity("phone", Phone.class )
.addJoin( "pr", "phone.person")
.list();

for(Object[] tuple : tuples) {
	Phone phone = (Phone) tuple[0];
	Person person = (Person) tuple[1];
	assertNotNull( person.getName() );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    *
FROM
    Phone ph
JOIN
    Person pr
ON  ph.person_id = pr.id</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从关联的SQL查询中可以看出，Hibernate无需任何额外的数据库往返就可以构造实体层次结构。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，使用<code>addJoin()</code>方法，结果集将包含两个连接的实体。要构建实体层次结构，您需要使用<code>ROOT_ENTITY</code>要么<code>DISTINCT_ROOT_ENTITY</code><code>ResultTransformer</code> 。</p>
</div>
<div id="sql-hibernate-entity-associations-query-many-to-one-join-result-transformer-example" class="exampleblock">
<div class="title">示例581具有连接的多对一关联的Hibernate本机查询选择实体<code>ResultTransformer</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createNativeQuery(
	"SELECT * " +
	"FROM Phone ph " +
	"JOIN Person pr ON ph.person_id = pr.id" )
.addEntity("phone", Phone.class )
.addJoin( "pr", "phone.person")
.setResultTransformer( Criteria.ROOT_ENTITY )
.list();

for(Person person : persons) {
	person.getPhones();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因为<code>ROOT_ENTITY</code><code>ResultTransformer</code> ，上面的查询将返回父级作为根实体。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，您添加了别名<em>pr</em> ，以便能够指定联接的目标属性路径。可以对集合进行同样的渴望加入（例如<code>Phone#calls</code><code>one-to-many</code>协会）。</p>
</div>
<div id="sql-jpa-entity-associations-query-one-to-many-join-example" class="exampleblock">
<div class="title">示例582具有一对多关联的JPA本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Phone&gt; phones = entityManager.createNativeQuery(
	"SELECT * " +
	"FROM Phone ph " +
	"JOIN phone_call c ON c.phone_id = ph.id", Phone.class )
.getResultList();

for(Phone phone : phones) {
	List&lt;Call&gt; calls = phone.getCalls();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT *
FROM phone ph
JOIN call c ON c.phone_id = ph.id</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-associations-query-one-to-many-join-example" class="exampleblock">
<div class="title">示例583具有一对多关联的Hibernate本机查询选择实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = session.createNativeQuery(
	"SELECT * " +
	"FROM Phone ph " +
	"JOIN phone_call c ON c.phone_id = ph.id" )
.addEntity("phone", Phone.class )
.addJoin( "c", "phone.calls")
.list();

for(Object[] tuple : tuples) {
	Phone phone = (Phone) tuple[0];
	Call call = (Call) tuple[1];
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT *
FROM phone ph
JOIN call c ON c.phone_id = ph.id</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此阶段，您正在达到本机查询所能达到的极限，而没有开始增强SQL查询以使其在Hibernate中可用。返回多个相同类型的实体或默认别名/列名称不够用时，可能会出现问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-multi-entity-query"><a class="anchor" href="#sql-multi-entity-query"></a> 17.5。返回多个实体</h3>
<div class="paragraph">
<p>到目前为止，假定结果集的列名与映射文档中指定的列名相同。对于连接多个表的SQL查询，这可能会出现问题，因为相同的列名可能出现在多个表中。</p>
</div>
<div class="paragraph">
<p>在以下查询中需要列别名注入，否则将抛出<code>NonUniqueDiscoveredSqlAliasException</code> 。</p>
</div>
<div id="sql-jpa-multi-entity-query-example" class="exampleblock">
<div class="title">示例584JPA本机查询选择具有相同列名称的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object&gt; entities = entityManager.createNativeQuery(
	"SELECT * " +
	"FROM Person pr, Partner pt " +
	"WHERE pr.name = pt.name" )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-multi-entity-query-example" class="exampleblock">
<div class="title">示例585Hibernate本机查询选择具有相同列名称的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object&gt; entities = session.createNativeQuery(
	"SELECT * " +
	"FROM Person pr, Partner pt " +
	"WHERE pr.name = pt.name" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询旨在返回所有<code>Person</code>和<code>Partner</code>具有相同名称的实例。查询失败，因为两个实体映射到相同的列名（例如，名称冲突） <code>id</code> ， <code>name</code> ， <code>version</code> ）。另外，在某些数据库上，返回的列别名很可能在表单上<code>pr.id</code> ， <code>pr.name</code>等等，它们不等于映射中指定的列（ <code>id</code>和<code>name</code> ）。</p>
</div>
<div class="paragraph">
<p>以下形式不易受到列名重复的影响：</p>
</div>
<div id="sql-hibernate-multi-entity-query-alias-example" class="exampleblock">
<div class="title">示例586Hibernate本机查询选择具有相同列名和别名的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object&gt; entities = session.createNativeQuery(
	"SELECT {pr.*}, {pt.*} " +
	"FROM Person pr, Partner pt " +
	"WHERE pr.name = pt.name" )
.addEntity( "pr", Person.class)
.addEntity( "pt", Partner.class)
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA中没有这样的等效项，因为<code>javax.persistence.Query</code>接口未定义<code>addEntity</code>方法等效。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>{pr.<strong>}</strong></code> <strong>和<code>{pt.</code></strong> <code>}</code>上面使用的符号是“所有属性”的简写。另外，您可以显式列出这些列，但是即使在这种情况下，Hibernate也会为每个属性注入SQL列别名。列别名的占位符只是表别名限定的属性名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-alias-references"><a class="anchor" href="#sql-alias-references"></a> 17.6。别名和属性参考</h3>
<div class="paragraph">
<p>在大多数情况下，需要上述别名注入。对于与更复杂的映射有关的查询，例如复合属性，继承标识符，集合等，可以使用允许Hibernate注入适当别名的特定别名。</p>
</div>
<div class="paragraph">
<p>下表显示了可以使用别名注入的不同方式。请注意，结果中的别名仅是示例，使用时每个别名将具有唯一且可能不同的名称。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表9。别名注入名称</caption>
<colgroup>
<col style="width:23%">
<col style="width:22%">
<col style="width:55%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">句法</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个简单的属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].[propertyname]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>A_NAME as {item.name}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">复合属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].[componentname].[propertyname]}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实体的歧视者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].class}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISC as {item.class}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实体的所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].*}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{item.*}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">收集钥匙</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].key}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ORGID as {coll.key}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合的ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EMPID as {coll.id}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合的元素</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].element}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>XID as {coll.element}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合中元素的属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].element.[propertyname]}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NAME as {coll.element.name}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合中元素的所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].element.*}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{coll.element.*}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合的所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{[aliasname].*}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{coll.*}</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="sql-dto-query"><a class="anchor" href="#sql-dto-query"></a> 17.7。返回DTO（数据传输对象）</h3>
<div class="paragraph">
<p>可以应用<code>ResultTransformer</code>到本机SQL查询，使其返回非托管实体。</p>
</div>
<div id="sql-hibernate-dto-query-example" class="exampleblock">
<div class="title">示例587Hibernate本机查询选择DTO</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PersonSummaryDTO {

    private Number id;

    private String name;

    //Getters and setters are omitted for brevity

    public Number getId() {
        return id;
    }

    public void setId(Number id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

List&lt;PersonSummaryDTO&gt; dtos = session.createNativeQuery(
	"SELECT p.id as \"id\", p.name as \"name\" " +
	"FROM Person p")
.setResultTransformer( Transformers.aliasToBean( PersonSummaryDTO.class ) )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA中没有这样的等效项，因为<code>javax.persistence.Query</code>接口未定义<code>setResultTransformer</code>方法等效。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上面的查询将返回一个列表<code>PersonSummaryDTO</code>已实例化并注入了<code>id</code>和<code>name</code>进入其相应的属性或字段。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-inheritance-query"><a class="anchor" href="#sql-inheritance-query"></a> 17.8。处理继承</h3>
<div class="paragraph">
<p>查询作为继承的一部分映射的实体的本机SQL查询必须包括基类及其所有子类的所有属性。</p>
</div>
<div id="sql-hibernate-inheritance-query-example" class="exampleblock">
<div class="title">示例588Hibernate本机查询选择子类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;CreditCardPayment&gt; payments = session.createNativeQuery(
	"SELECT * " +
	"FROM Payment p " +
	"JOIN CreditCardPayment cp on cp.id = p.id" )
.addEntity( CreditCardPayment.class )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA中没有这样的等效项，因为<code>javax.persistence.Query</code>接口未定义<code>addEntity</code>方法等效。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sql-query-parameters"><a class="anchor" href="#sql-query-parameters"></a> 17.9。参量</h3>
<div class="paragraph">
<p>本机SQL查询支持位置参数和命名参数：</p>
</div>
<div id="sql-jpa-query-parameters-example" class="exampleblock">
<div class="title">示例589带参数的JPA本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createNativeQuery(
	"SELECT * " +
	"FROM Person " +
	"WHERE name like :name", Person.class )
.setParameter("name", "J%")
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-query-parameters-example" class="exampleblock">
<div class="title">示例590带有参数的Hibernate本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.createNativeQuery(
	"SELECT * " +
	"FROM Person " +
	"WHERE name like :name" )
.addEntity( Person.class )
.setParameter("name", "J%")
.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sql-named-queries"><a class="anchor" href="#sql-named-queries"></a> 17.10。命名SQL查询</h3>
<div class="paragraph">
<p>还可以在映射期间定义命名SQL查询，并以与命名HQL查询完全相同的方式进行调用。在这种情况下，你<em>不需要</em>调用<code>addEntity()</code>不再。</p>
</div>
<div class="paragraph">
<p>JPA定义了<code>javax.persistence.NamedNativeQuery</code>为此使用注释和Hibernate<code>org.hibernate.annotations.NamedNativeQuery</code>批注扩展了它并添加了以下属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>flushMode()</code></dt>
<dd>
<p>查询的刷新模式。默认情况下，它使用当前的持久性上下文刷新模式。</p>
</dd>
<dt class="hdlist1"><code>cacheable()</code></dt>
<dd>
<p>查询（结果）是否可缓存。默认情况下，不缓存查询。</p>
</dd>
<dt class="hdlist1"><code>cacheRegion()</code></dt>
<dd>
<p>如果查询结果是可缓存的，请命名要使用的查询缓存区域。</p>
</dd>
<dt class="hdlist1"><code>fetchSize()</code></dt>
<dd>
<p>JDBC驱动程序每次数据库行程获取的行数。缺省值由JDBC驱动程序提供。</p>
</dd>
<dt class="hdlist1"><code>timeout()</code></dt>
<dd>
<p>查询超时（以秒为单位）。默认情况下，没有超时。</p>
</dd>
<dt class="hdlist1"><code>callable()</code></dt>
<dd>
<p>SQL查询是否表示对过程/函数的调用？默认为false。</p>
</dd>
<dt class="hdlist1"><code>comment()</code></dt>
<dd>
<p>添加到SQL查询中的注释，用于调整执行计划。</p>
</dd>
<dt class="hdlist1"><code>cacheMode()</code></dt>
<dd>
<p>用于此查询的缓存模式。这是指查询返回的实体/集合。默认值为<code>CacheModeType.NORMAL</code> 。</p>
</dd>
<dt class="hdlist1"><code>readOnly()</code></dt>
<dd>
<p>结果是否应为只读。默认情况下，查询不是只读的，因此实体存储在持久性上下文中。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="sql-scalar-named-queries"><a class="anchor" href="#sql-scalar-named-queries"></a> 17.10.1。选择标量值的命名SQL查询</h4>
<div class="paragraph">
<p>要获取给定表的单个列，命名查询如下所示：</p>
</div>
<div id="sql-scalar-NamedNativeQuery-example" class="exampleblock">
<div class="title">示例591。单标量值<code>NamedNativeQuery</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "find_person_name",
    query =
        "SELECT name " +
        "FROM Person "
),</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-jpa-scalar-named-query-example" class="exampleblock">
<div class="title">范例592。JPA命名本机查询选择一个标量值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; names = entityManager.createNamedQuery(
	"find_person_name" )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-scalar-named-query-example" class="exampleblock">
<div class="title">示例593。Hibernate命名本机查询选择标量值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;String&gt; names = session.getNamedQuery(
	"find_person_name" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>选择多个标量值是这样完成的：</p>
</div>
<div id="sql-multiple-scalar-values-NamedNativeQuery-example" class="exampleblock">
<div class="title">示例594多标量值<code>NamedNativeQuery</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "find_person_name_and_nickName",
    query =
        "SELECT " +
        "   name, " +
        "   nickName " +
        "FROM Person "
),</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在不指定显式结果类型的情况下，Hibernate将假定<code>Object</code>数组：</p>
</div>
<div id="sql-jpa-multiple-scalar-values-named-query-example" class="exampleblock">
<div class="title">示例595。JPA命名本机查询选择多个标量值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = entityManager.createNamedQuery(
	"find_person_name_and_nickName" )
.getResultList();

for(Object[] tuple : tuples) {
	String name = (String) tuple[0];
	String nickName = (String) tuple[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-multiple-scalar-values-named-query-example" class="exampleblock">
<div class="title">示例596Hibernate命名本机查询选择多个标量值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = session.getNamedQuery(
	"find_person_name_and_nickName" )
.list();

for(Object[] tuple : tuples) {
	String name = (String) tuple[0];
	String nickName = (String) tuple[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用DTO存储结果标量值：</p>
</div>
<div id="sql-ConstructorResult-dto-example" class="exampleblock">
<div class="title">示例597DTO存储多个标量值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PersonNames {

    private final String name;

    private final String nickName;

    public PersonNames(String name, String nickName) {
        this.name = name;
        this.nickName = nickName;
    }

    public String getName() {
        return name;
    }

    public String getNickName() {
        return nickName;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-multiple-scalar-values-dto-NamedNativeQuery-example" class="exampleblock">
<div class="title">实施例598。多标量值<code>NamedNativeQuery</code>与<code>ConstructorResult</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "find_person_name_and_nickName_dto",
    query =
        "SELECT " +
        "   name, " +
        "   nickName " +
        "FROM Person ",
    resultSetMapping = "name_and_nickName_dto"
),
@SqlResultSetMapping(
    name = "name_and_nickName_dto",
    classes = @ConstructorResult(
        targetClass = PersonNames.class,
        columns = {
            @ColumnResult(name = "name"),
            @ColumnResult(name = "nickName")
        }
    )
)</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-jpa-multiple-scalar-values-dto-named-query-example" class="exampleblock">
<div class="title">示例599。JPA命名本机查询将多个标量值选择到DTO中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;PersonNames&gt; personNames = entityManager.createNamedQuery(
	"find_person_name_and_nickName_dto" )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-multiple-scalar-values-dto-named-query-example" class="exampleblock">
<div class="title">示例600Hibernate命名本机查询将多个标量值选择到DTO中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;PersonNames&gt; personNames = session.getNamedQuery(
	"find_person_name_and_nickName_dto" )
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedNativeQuery.html"><code>@NamedNativeQuery</code></a> Hibernate批注使用各种配置（例如访存模式，可缓存性，超时间隔）来自定义命名查询。</p>
</div>
<div id="sql-multiple-scalar-values-dto-NamedNativeQuery-hibernate-example" class="exampleblock">
<div class="title">示例601使用多个标量值<code>ConstructorResult</code>和Hibernate<code>NamedNativeQuery</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQueries({
    @NamedNativeQuery(
        name = "get_person_phone_count",
        query = "SELECT pr.name AS name, count(*) AS phoneCount " +
                "FROM Phone p " +
                "JOIN Person pr ON pr.id = p.person_id " +
                "GROUP BY pr.name",
        resultSetMapping = "person_phone_count",
        timeout = 1,
        readOnly = true
    ),
})
@SqlResultSetMapping(
    name = "person_phone_count",
    classes = @ConstructorResult(
        targetClass = PersonPhoneCount.class,
        columns = {
            @ColumnResult(name = "name"),
            @ColumnResult(name = "phoneCount")
        }
    )
)</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-multiple-scalar-values-dto-hibernate-named-query-example" class="exampleblock">
<div class="title">范例602。冬眠<code>NamedNativeQuery</code>命名本机查询选择多个标量值到DTO中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;PersonPhoneCount&gt; personNames = session.getNamedNativeQuery(
	"get_person_phone_count")
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sql-entity-named-queries"><a class="anchor" href="#sql-entity-named-queries"></a> 17.10.2。命名SQL查询选择实体</h4>
<div class="paragraph">
<p>考虑以下命名查询：</p>
</div>
<div id="sql-entity-NamedNativeQuery-example" class="exampleblock">
<div class="title">示例603单实体<code>NamedNativeQuery</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "find_person_by_name",
    query =
        "SELECT " +
        "   p.id AS \"id\", " +
        "   p.name AS \"name\", " +
        "   p.nickName AS \"nickName\", " +
        "   p.address AS \"address\", " +
        "   p.createdOn AS \"createdOn\", " +
        "   p.version AS \"version\" " +
        "FROM Person p " +
        "WHERE p.name LIKE :name",
    resultClass = Person.class
),</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>结果集映射声明此本地查询检索的实体。实体的每个字段都绑定到一个SQL别名（或列名）。实体的所有字段（包括子类和相关实体的外键列）都必须存在于SQL查询中。字段定义是可选的，只要它们映射到与在class属性上声明的列名称相同的列名即可。</p>
</div>
<div class="paragraph">
<p>可以按以下步骤执行此命名的本机查询：</p>
</div>
<div id="sql-jpa-entity-named-query-example" class="exampleblock">
<div class="title">例子604。JPA命名本机实体查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = entityManager.createNamedQuery(
	"find_person_by_name" )
.setParameter("name", "J%")
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-named-query-example" class="exampleblock">
<div class="title">示例605Hibernate命名本机实体查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Person&gt; persons = session.getNamedQuery(
	"find_person_by_name" )
.setParameter("name", "J%")
.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要加入多个实体，您需要使用<code>SqlResultSetMapping</code>对于每个实体，将提取SQL查询。</p>
</div>
<div id="sql-entity-associations-NamedNativeQuery-example" class="exampleblock">
<div class="title">示例606联合实体<code>NamedNativeQuery</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "find_person_with_phones_by_name",
    query =
        "SELECT " +
        "   pr.id AS \"pr.id\", " +
        "   pr.name AS \"pr.name\", " +
        "   pr.nickName AS \"pr.nickName\", " +
        "   pr.address AS \"pr.address\", " +
        "   pr.createdOn AS \"pr.createdOn\", " +
        "   pr.version AS \"pr.version\", " +
        "   ph.id AS \"ph.id\", " +
        "   ph.person_id AS \"ph.person_id\", " +
        "   ph.phone_number AS \"ph.number\", " +
        "   ph.phone_type AS \"ph.type\" " +
        "FROM Person pr " +
        "JOIN Phone ph ON pr.id = ph.person_id " +
        "WHERE pr.name LIKE :name",
    resultSetMapping = "person_with_phones"
)
 @SqlResultSetMapping(
     name = "person_with_phones",
     entities = {
         @EntityResult(
             entityClass = Person.class,
             fields = {
                 @FieldResult( name = "id", column = "pr.id" ),
                 @FieldResult( name = "name", column = "pr.name" ),
                 @FieldResult( name = "nickName", column = "pr.nickName" ),
                 @FieldResult( name = "address", column = "pr.address" ),
                 @FieldResult( name = "createdOn", column = "pr.createdOn" ),
                 @FieldResult( name = "version", column = "pr.version" ),
             }
         ),
         @EntityResult(
             entityClass = Phone.class,
             fields = {
                 @FieldResult( name = "id", column = "ph.id" ),
                 @FieldResult( name = "person", column = "ph.person_id" ),
                 @FieldResult( name = "number", column = "ph.number" ),
                 @FieldResult( name = "type", column = "ph.type" ),
             }
         )
     }
 ),</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-jpa-entity-associations_named-query-example" class="exampleblock">
<div class="title">示例607JPA命名的具有联合关联的本机实体查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = entityManager.createNamedQuery(
	"find_person_with_phones_by_name" )
.setParameter("name", "J%")
.getResultList();

for(Object[] tuple : tuples) {
	Person person = (Person) tuple[0];
	Phone phone = (Phone) tuple[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-entity-associations_named-query-example" class="exampleblock">
<div class="title">示例608带有关联的Hibernate命名本机实体查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = session.getNamedQuery(
	"find_person_with_phones_by_name" )
.setParameter("name", "J%")
.list();

for(Object[] tuple : tuples) {
	Person person = (Person) tuple[0];
	Phone phone = (Phone) tuple[1];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，如果与相关实体的关联涉及复合主键，则<code>@FieldResult</code>元素应用于每个外键列。的<code>@FieldResult</code>名称由关系的属性名称，后跟点（“。”），后跟名称或主键的字段或属性组成。对于此示例，将使用以下实体：</p>
</div>
<div id="sql-composite-key-entity-associations_named-query-example" class="exampleblock">
<div class="title">示例609具有复合键和命名本机查询的实体关联</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public class Dimensions {

    private int length;

    private int width;

    //Getters and setters are omitted for brevity

}

@Embeddable
public class Identity implements Serializable {

    private String firstname;

    private String lastname;

    //Getters and setters are omitted for brevity

    public boolean equals(Object o) {
        if ( this == o ) return true;
        if ( o == null || getClass() != o.getClass() ) return false;

        final Identity identity = (Identity) o;

        if ( !firstname.equals( identity.firstname ) ) return false;
        if ( !lastname.equals( identity.lastname ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = firstname.hashCode();
        result = 29 * result + lastname.hashCode();
        return result;
    }
}

@Entity
public class Captain {

    @EmbeddedId
    private Identity id;

    //Getters and setters are omitted for brevity

}

@Entity
@NamedNativeQueries({
    @NamedNativeQuery(name = "find_all_spaceships",
        query =
            "SELECT " +
            "   name as \"name\", " +
            "   model, " +
            "   speed, " +
            "   lname as lastn, " +
            "   fname as firstn, " +
            "   length, " +
            "   width, " +
            "   length * width as surface, " +
            "   length * width * 10 as volume " +
            "FROM SpaceShip",
        resultSetMapping = "spaceship"
    )
})
@SqlResultSetMapping(
    name = "spaceship",
    entities = @EntityResult(
        entityClass = SpaceShip.class,
        fields = {
            @FieldResult(name = "name", column = "name"),
            @FieldResult(name = "model", column = "model"),
            @FieldResult(name = "speed", column = "speed"),
            @FieldResult(name = "captain.lastname", column = "lastn"),
            @FieldResult(name = "captain.firstname", column = "firstn"),
            @FieldResult(name = "dimensions.length", column = "length"),
            @FieldResult(name = "dimensions.width", column = "width"),
        }
    ),
    columns = {
        @ColumnResult(name = "surface"),
        @ColumnResult(name = "volume")
    }
)
public class SpaceShip {

    @Id
    private String name;

    private String model;

    private double speed;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({
        @JoinColumn(name = "fname", referencedColumnName = "firstname"),
        @JoinColumn(name = "lname", referencedColumnName = "lastname")
    })
    private Captain captain;

    private Dimensions dimensions;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-jpa-composite-key-entity-associations_named-query-example" class="exampleblock">
<div class="title">示例610JPA命名的本机实体查询，具有联接的关联和组合键</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = entityManager.createNamedQuery(
	"find_all_spaceships" )
.getResultList();

for(Object[] tuple : tuples) {
	SpaceShip spaceShip = (SpaceShip) tuple[0];
	Number surface = (Number) tuple[1];
	Number volume = (Number) tuple[2];
}</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-composite-key-entity-associations_named-query-example" class="exampleblock">
<div class="title">示例611具有连接的关联和组合键的Hibernate命名本机实体查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; tuples = session.getNamedQuery(
	"find_all_spaceships" )
.list();

for(Object[] tuple : tuples) {
	SpaceShip spaceShip = (SpaceShip) tuple[0];
	Number surface = (Number) tuple[1];
	Number volume = (Number) tuple[2];
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sql-global-catalog-schema"><a class="anchor" href="#sql-global-catalog-schema"></a> 17.11。在本机SQL查询中解析全局编录和架构</h3>
<div class="paragraph">
<p>当使用多个数据库目录和模式时，Hibernate提供了设置全局目录或模式的可能性，这样您就不必为每个实体都明确地声明它。</p>
</div>
<div id="sql-global-catalog-schema-configuration" class="exampleblock">
<div class="title">示例612。设置全局目录和架构</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property name="hibernate.default_catalog" value="crm"/&gt;
&lt;property name="hibernate.default_schema" value="analytics"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，我们可以在每个JPQL，HQL或Criteria API查询中隐含全局<strong>crm</strong>目录和<strong>分析</strong>架构。</p>
</div>
<div class="paragraph">
<p>但是，对于本机查询，SQL查询将按原样传递，因此，无论何时引用数据库表，都需要显式设置全局编录和架构。幸运的是，Hibernate允许您使用以下占位符解析当前的全局目录和架构：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">{h-catalog}</dt>
<dd>
<p>解决当前<code>hibernate.default_catalog</code>配置属性值。</p>
</dd>
<dt class="hdlist1">{h-schema}</dt>
<dd>
<p>解决当前<code>hibernate.default_schema</code>配置属性值。</p>
</dd>
<dt class="hdlist1">{h-domain}</dt>
<dd>
<p>解决当前<code>hibernate.default_catalog</code>和<code>hibernate.default_schema</code>配置属性值（例如catalog.schema）。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>使用这些占位符，您可以隐含每个本机查询的目录，架构，或者隐含目录和架构。</p>
</div>
<div class="paragraph">
<p>因此，在运行以下本机查询时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedNativeQuery(
    name = "last_30_days_hires",
    query =
        "select * " +
        "from {h-domain}person " +
        "where age(hired_on) &lt; '30 days'",
    resultClass = Person.class
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hibernate将解决<code>{h-domain}</code>根据默认目录和架构的值的占位符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT *
FROM   crm.analytics.person
WHERE  age(hired_on) &lt; '30 days'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sql-sp"><a class="anchor" href="#sql-sp"></a> 17.12。使用存储过程进行查询</h3>
<div class="paragraph">
<p>Hibernate通过存储过程和功能为查询提供支持。存储过程参数使用<code>IN</code>参数类型，结果可以用<code>OUT</code>参数类型，一个<code>REF_CURSOR</code>或者它可以像函数一样返回结果。</p>
</div>
<div id="sql-sp-out-mysql-example" class="exampleblock">
<div class="title">示例613MySQL存储过程<code>OUT</code>参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
    "CREATE PROCEDURE sp_count_phones (" +
    "   IN personId INT, " +
    "   OUT phoneCount INT " +
    ") " +
    "BEGIN " +
    "    SELECT COUNT(*) INTO phoneCount " +
    "    FROM Phone p " +
    "    WHERE p.person_id = personId; " +
    "END"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用此存储过程，可以执行以下JPA 2.1查询：</p>
</div>
<div id="sql-jpa-call-sp-out-mysql-example" class="exampleblock">
<div class="title">示例614用调用MySQL存储过程<code>OUT</code>使用JPA的参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StoredProcedureQuery query = entityManager.createStoredProcedureQuery( "sp_count_phones");
query.registerStoredProcedureParameter( "personId", Long.class, ParameterMode.IN);
query.registerStoredProcedureParameter( "phoneCount", Long.class, ParameterMode.OUT);

query.setParameter("personId", 1L);

query.execute();
Long phoneCount = (Long) query.getOutputParameterValue("phoneCount");</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-call-sp-out-mysql-example" class="exampleblock">
<div class="title">示例615。用调用MySQL存储过程<code>OUT</code> Hibernate使用参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap( Session.class );

ProcedureCall call = session.createStoredProcedureCall( "sp_count_phones" );
call.registerParameter( "personId", Long.class, ParameterMode.IN ).bindValue( 1L );
call.registerParameter( "phoneCount", Long.class, ParameterMode.OUT );

Long phoneCount = (Long) call.getOutputs().getOutputParameterValue( "phoneCount" );
assertEquals( Long.valueOf( 2 ), phoneCount );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果存储过程直接输出结果而没有<code>OUT</code>参数类型：</p>
</div>
<div id="sql-sp-mysql-return-no-out-example" class="exampleblock">
<div class="title">示例616MySQL存储过程没有<code>OUT</code>参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
    "CREATE PROCEDURE sp_phones(IN personId INT) " +
    "BEGIN " +
    "    SELECT *  " +
    "    FROM Phone   " +
    "    WHERE person_id = personId;  " +
    "END"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以按以下方式检索上述MySQL存储过程的结果：</p>
</div>
<div id="sql-jpa-call-sp-no-out-mysql-example" class="exampleblock">
<div class="title">示例617调用MySQL存储过程并获取结果集，而无需<code>OUT</code>使用JPA的参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StoredProcedureQuery query = entityManager.createStoredProcedureQuery( "sp_phones");
query.registerStoredProcedureParameter( 1, Long.class, ParameterMode.IN);

query.setParameter(1, 1L);

List&lt;Object[]&gt; personComments = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-call-sp-no-out-mysql-example" class="exampleblock">
<div class="title">示例618调用MySQL存储过程并获取结果集，而无需<code>OUT</code> Hibernate使用参数类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap( Session.class );

ProcedureCall call = session.createStoredProcedureCall( "sp_phones" );
call.registerParameter( 1, Long.class, ParameterMode.IN ).bindValue( 1L );

Output output = call.getOutputs().getCurrent();

List&lt;Object[]&gt; personComments = ( (ResultSetOutput) output ).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为一个<code>REF_CURSOR</code>结果集，我们将考虑以下Oracle存储过程：</p>
</div>
<div id="sql-sp-ref-cursor-oracle-example" class="exampleblock">
<div class="title">示例619甲骨文<code>REF_CURSOR</code>存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
    "CREATE OR REPLACE PROCEDURE sp_person_phones ( " +
    "   personId IN NUMBER, " +
    "   personPhones OUT SYS_REFCURSOR ) " +
    "AS  " +
    "BEGIN " +
    "    OPEN personPhones FOR " +
    "    SELECT *" +
    "    FROM phone " +
    "    WHERE person_id = personId; " +
    "END;"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>REF_CURSOR</code>结果集仅受某些关系数据库（例如Oracle和PostgreSQL）支持，而其他数据库系统JDBC驱动程序可能不支持此功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用标准的Java Persistence API调用此函数：</p>
</div>
<div id="sql-jpa-call-sp-ref-cursor-oracle-example" class="exampleblock">
<div class="title">范例620。呼叫甲骨文<code>REF_CURSOR</code>使用JPA的存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StoredProcedureQuery query = entityManager.createStoredProcedureQuery( "sp_person_phones" );
query.registerStoredProcedureParameter( 1, Long.class, ParameterMode.IN );
query.registerStoredProcedureParameter( 2, Class.class, ParameterMode.REF_CURSOR );
query.setParameter( 1, 1L );

query.execute();
List&lt;Object[]&gt; postComments = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div id="sql-hibernate-call-sp-ref-cursor-oracle-example" class="exampleblock">
<div class="title">示例621呼叫甲骨文<code>REF_CURSOR</code>使用Hibernate的存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = entityManager.unwrap(Session.class);

ProcedureCall call = session.createStoredProcedureCall( "sp_person_phones");
call.registerParameter(1, Long.class, ParameterMode.IN).bindValue(1L);
call.registerParameter(2, Class.class, ParameterMode.REF_CURSOR);

Output output = call.getOutputs().getCurrent();
List&lt;Object[]&gt; postComments = ( (ResultSetOutput) output ).getResultList();
assertEquals(2, postComments.size());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果数据库定义了SQL函数：</p>
</div>
<div id="sql-function-mysql-example" class="exampleblock">
<div class="title">示例622。MySQL功能</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
    "CREATE FUNCTION fn_count_phones(personId integer)  " +
    "RETURNS integer " +
    "DETERMINISTIC " +
    "READS SQL DATA " +
    "BEGIN " +
    "    DECLARE phoneCount integer; " +
    "    SELECT COUNT(*) INTO phoneCount " +
    "    FROM Phone p " +
    "    WHERE p.person_id = personId; " +
    "    RETURN phoneCount; " +
    "END"
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为目前<code>StoredProcedureQuery</code>实现尚不支持SQL函数，我们需要使用JDBC语法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://hibernate.atlassian.net/browse/HHH-10530">HHH-10530</a>问题已确认并且将解决此限制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="sql-call-function-mysql-example" class="exampleblock">
<div class="title">示例623。调用MySQL函数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">final AtomicReference&lt;Integer&gt; phoneCount = new AtomicReference&lt;&gt;();
Session session = entityManager.unwrap( Session.class );
session.doWork( connection -&gt; {
    try (CallableStatement function = connection.prepareCall(
            "{ ? = call fn_count_phones(?) }" )) {
        function.registerOutParameter( 1, Types.INTEGER );
        function.setInt( 2, 1 );
        function.execute();
        phoneCount.set( function.getInt( 1 ) );
    }
} );</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无法对存储过程查询进行分页<code>setFirstResult()/setMaxResults()</code> 。</p>
</div>
<div class="paragraph">
<p>由于这些服务器可以返回多个结果集和更新计数，因此Hibernate将迭代结果，并将结果集的第一个结果作为其返回值，因此所有其他内容都将被丢弃。</p>
</div>
<div class="paragraph">
<p>对于SQL Server，如果可以启用<code>SET NOCOUNT ON</code>在您的过程中，它可能会更有效，但这不是必需的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sql-sp-named-query"><a class="anchor" href="#sql-sp-named-query"></a> 17.13。使用命名查询来调用存储过程</h3>
<div class="paragraph">
<p>就像使用SQL语句一样，您也可以使用命名查询来调用存储过程。为此，JPA定义了<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedStoredProcedureQuery.html"><code>@NamedStoredProcedureQuery</code></a>注解。</p>
</div>
<div id="sql-sp-ref-cursor-oracle-named-query-example" class="exampleblock">
<div class="title">示例624甲骨文<code>REF_CURSOR</code>命名查询存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@NamedStoredProcedureQueries(
    @NamedStoredProcedureQuery(
        name = "sp_person_phones",
        procedureName = "sp_person_phones",
        parameters = {
            @StoredProcedureParameter(
                name = "personId",
                type = Long.class,
                mode = ParameterMode.IN
            ),
            @StoredProcedureParameter(
                name = "personPhones",
                type = Class.class,
                mode = ParameterMode.REF_CURSOR
            )
        }
    )
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>调用此存储过程很简单，如以下示例所示。</p>
</div>
<div id="sql-jpa-call-sp-ref-cursor-oracle-named-query-example" class="exampleblock">
<div class="title">示例625呼叫甲骨文<code>REF_CURSOR</code>使用JPA命名查询的存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Object[]&gt; postComments = entityManager
.createNamedStoredProcedureQuery( "sp_person_phones" )
.setParameter( "personId", 1L )
.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sql-crud"><a class="anchor" href="#sql-crud"></a> 17.14。用于CRUD的自定义SQL（创建，读取，更新和删除）</h3>
<div class="paragraph">
<p>Hibernate可以将自定义SQL用于CRUD操作。可以在语句级别或单个列级别覆盖SQL。本节介绍语句覆盖。有关列，请参见<a href="#mapping-column-read-and-write">列转换器：读取和写入表达式</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用注释定义自定义SQL操作。
<code>@SQLInsert</code> ， <code>@SQLUpdate</code>和<code>@SQLDelete</code>覆盖给定实体的INSERT，UPDATE，DELETE语句。对于SELECT子句， <code>@Loader</code>必须与<code>@NamedNativeQuery</code>用于加载基础表记录。</p>
</div>
<div class="paragraph">
<p>对于集合，Hibernate允许定义一个自定义<code>@SQLDeleteAll</code>用于删除与给定父实体关联的所有子记录。要过滤集合， <code>@Where</code>批注允许自定义基础SQL WHERE子句。</p>
</div>
<div id="sql-custom-crud-example" class="exampleblock">
<div class="title">示例626。自定义CRUD</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
@SQLInsert(
	sql = "INSERT INTO person (name, id, valid) VALUES (?, ?, true) ",
	check = ResultCheckStyle.COUNT
)
@SQLUpdate(
	sql = "UPDATE person SET name = ? where id = ? "
)
@SQLDelete(
	sql = "UPDATE person SET valid = false WHERE id = ? "
)
@Loader(namedQuery = "find_valid_person")
@NamedNativeQueries({
	@NamedNativeQuery(
		name = "find_valid_person",
		query = "SELECT id, name " +
				"FROM person " +
				"WHERE id = ? and valid = true",
		resultClass = Person.class
	)
})
public static class Person {

	@Id
	@GeneratedValue
	private Long id;

	private String name;

	@ElementCollection
	@SQLInsert(
		sql = "INSERT INTO person_phones (person_id, phones, valid) VALUES (?, ?, true) ")
	@SQLDeleteAll(
		sql = "UPDATE person_phones SET valid = false WHERE person_id = ?")
	@Where( clause = "valid = true" )
	private List&lt;String&gt; phones = new ArrayList&lt;&gt;();

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，映射了实体，以便条目被软删除（记录不会从数据库中删除，而是用一个标志标记行的有效性）。的<code>Person</code>实体受益于自定义INSERT，UPDATE和DELETE语句，这些语句更新了<code>valid</code>列相应。风俗<code>@Loader</code>仅用于检索<code>Person</code>有效的行。</p>
</div>
<div class="paragraph">
<p>相同的<code>phones</code>采集。的<code>@SQLDeleteAll</code>和<code>SQLInsert</code>只要修改了集合，就使用查询。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还可以使用自定义CRUD语句调用存储过程。唯一的要求是设置<code>callable</code>归因于<code>true</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了检查执行是否正确，Hibernate允许您定义以下三种策略之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>none：不执行任何检查；违反约束条件，存储过程将失败</p>
</li>
<li>
<p>count：使用返回的行数<code>executeUpdate()</code>方法调用以检查更新是否成功</p>
</li>
<li>
<p>参数：喜欢计数，但使用<code>CallableStatement</code>输出参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要定义结果检查样式，请使用<code>check</code>参数。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>参数顺序很重要，并且由Hibernate处理属性的顺序定义。您可以通过启用调试日志记录来查看预期的顺序，因此Hibernate可以打印出用于创建，更新和删除实体的静态SQL。</p>
</div>
<div class="paragraph">
<p>要查看预期的顺序，请记住不要通过注释或映射文件包括您的自定义SQL，因为这将覆盖Hibernate生成的静态SQL。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>也可以使用以下方法覆盖辅助表的SQL语句<code>@org.hibernate.annotations.Table</code>和<code>sqlInsert</code> ， <code>sqlUpdate</code> ， <code>sqlDelete</code>属性。</p>
</div>
<div id="sql-custom-crud-secondary-table-example" class="exampleblock">
<div class="title">示例627。覆盖辅助表的SQL语句</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "Person")
@Table(name = "person")
@SQLInsert(
    sql = "INSERT INTO person (name, id, valid) VALUES (?, ?, true) "
)
@SQLDelete(
    sql = "UPDATE person SET valid = false WHERE id = ? "
)
@SecondaryTable(name = "person_details",
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "person_id"))
@org.hibernate.annotations.Table(
    appliesTo = "person_details",
    sqlInsert = @SQLInsert(
        sql = "INSERT INTO person_details (image, person_id, valid) VALUES (?, ?, true) ",
        check = ResultCheckStyle.COUNT
    ),
    sqlDelete = @SQLDelete(
        sql = "UPDATE person_details SET valid = false WHERE person_id = ? "
    )
)
@Loader(namedQuery = "find_valid_person")
@NamedNativeQueries({
    @NamedNativeQuery(
        name = "find_valid_person",
        query = "SELECT " +
                "    p.id, " +
                "    p.name, " +
                "    pd.image  " +
                "FROM person p  " +
                "LEFT OUTER JOIN person_details pd ON p.id = pd.person_id  " +
                "WHERE p.id = ? AND p.valid = true AND pd.valid = true",
        resultClass = Person.class
    )
})
public static class Person {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    @Column(name = "image", table = "person_details")
    private byte[] image;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>SQL直接在数据库中执行，因此您可以使用任何喜欢的方言。但是，如果使用特定于数据库的SQL，这将降低映射的可移植性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以使用存储过程来自定义CRUD语句。</p>
</div>
<div class="paragraph">
<p>假设以下存储过程：</p>
</div>
<div id="sql-sp-soft-delete-example" class="exampleblock">
<div class="title">示例628。Oracle存储过程软删除给定实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">statement.executeUpdate(
	"CREATE OR REPLACE PROCEDURE sp_delete_person ( " +
	"   personId IN NUMBER ) " +
	"AS  " +
	"BEGIN " +
	"    UPDATE person SET valid = 0 WHERE id = personId; " +
	"END;"
);}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实体可以使用此存储过程来软删除相关实体：</p>
</div>
<div id="sql-sp-custom-crud-example" class="exampleblock">
<div class="title">示例629。自定义实体delete语句以使用Oracle存储过程=</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@SQLDelete(
	sql =   "{ call sp_delete_person( ? ) } ",
	callable = true
)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您需要设置<code>callable</code>使用存储过程而不是SQL语句时的属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spatial"><a class="anchor" href="#spatial"></a> 18岁空间空间</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="spatial-overview"><a class="anchor" href="#spatial-overview"></a> 18.1。总览</h3>
<div class="paragraph">
<p>Hibernate Spatial最初是作为Hibernate的通用扩展而开发的，用于处理地理数据。从5.0开始，Hibernate Spatial现在是Hibernate ORM项目的一部分，它允许您以标准化方式处理地理数据。</p>
</div>
<div class="paragraph">
<p>Hibernate Spatial为地理数据存储和查询功能提供了标准化的跨数据库接口。它支持OGC简单功能规范中描述的大多数功能。支持的数据库是Oracle 10g / 11g，PostgreSQL / PostGIS，MySQL，Microsoft SQL Server和H2 / GeoDB。</p>
</div>
<div class="paragraph">
<p>空间数据类型不是Java标准库的一部分，而JDBC规范中却没有。多年来， <a href="http://tsusiatsoftware.net/jts/main.html">JTS</a>已经出现了<em>事实上的</em>标准来填补这一空白。JTS是<a href="https://portal.opengeospatial.org/files/?artifact_id=829">简单功能规范（SFS）的实现</a> 。另一方面，许多数据库都实现了SQL / MM-第3部分：空间数据规范-相关但范围更广的规范。最大的区别是SFS限于投影平面中的2D几何形状（尽管JTS支持3D坐标），而SQL / MM支持2、3或4维坐标空间。</p>
</div>
<div class="paragraph">
<p>Hibernate Spatial支持两种不同的几何模型： <a href="http://tsusiatsoftware.net/jts/main.html">JTS</a>和<a href="https://github.com/GeoLatte/geolatte-geom">geolatte-geom</a> 。如前所述，JTS是<em>事实上的</em>标准。Geolatte-geom（也由Hibernate Spatial的首席开发人员编写）是一个更新的库，它支持SQL / MM中指定的许多功能，但JTS中不可用（例如，对4D几何的支持以及对扩展的WKT / WKB格式的支持）。 。Geolatte-geom还为数据库本机类型实现了编码器/解码器。Geolatte-geom与JTS具有良好的互操作性。转换Geolatte <code>geometry</code>例如，将其更改为JTS`几何不需要复制坐标。它还将空间处理委托给JTS。</p>
</div>
<div class="paragraph">
<p>无论您使用JTS还是Geolatte-geom，Hibernate空间都会将数据库空间类型映射到您选择的几何模型。但是，它将始终使用Geolatte-geom来解码数据库本机类型。</p>
</div>
<div class="paragraph">
<p>Hibernate Spatial还使HQL和Criteria Query API中提供了许多空间功能。这些函数在SQL / MM中都指定为SFS，并且通常在具有空间支持的数据库中实现（请参见<a href="#spatial-configuration-dialect-features">Hibernate Spatial方言函数支持</a> ）。</p>
</div>
</div>
<div class="sect2">
<h3 id="spatial-configuration"><a class="anchor" href="#spatial-configuration"></a> 18.2。组态</h3>
<div class="paragraph">
<p>Hibernate Spatial需要一些配置才能开始使用它。</p>
</div>
<div class="sect3">
<h4 id="spatial-configuration-dependency"><a class="anchor" href="#spatial-configuration-dependency"></a> 18.2.1。相依性</h4>
<div class="paragraph">
<p>您需要包括<code>hibernate-spatial</code>在构建环境中的依赖性。对于Maven，您需要添加以下依赖项：</p>
</div>
<div id="spatial-configuration-maven-example" class="exampleblock">
<div class="title">示例630Maven依赖</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-spatial&lt;/artifactId&gt;
    &lt;version&gt;${hibernate.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-configuration-dialect"><a class="anchor" href="#spatial-configuration-dialect"></a> 18.2.2。方言</h4>
<div class="paragraph">
<p>Hibernate Spatial扩展了Hibernate ORM方言，以便在HQL和JPQL中提供数据库的空间功能。因此，例如，不要使用<code>PostgreSQL82Dialect</code> ，我们使用该方言的Hibernate Spatial扩展名，即<code>PostgisDialect</code> 。</p>
</div>
<div id="spatial-configuration-dialect-example" class="exampleblock">
<div class="title">示例631指定空间方言</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property
    name="hibernate.dialect"
    value="org.hibernate.spatial.dialect.postgis.PostgisDialect"
/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>并非所有数据库都支持Hibernate Spatial定义的所有功能。下表概述了每个数据库提供的功能。如果功能是在“ <a href="https://portal.opengeospatial.org/files/?artifact_id=829">简单功能规范”中</a>定义的，则说明将参考相关部分。</p>
</div>
<table id="spatial-configuration-dialect-features" class="tableblock frame-all grid-all spread">
<caption class="title">表10。Hibernate Spatial方言功能支持</caption>
<colgroup>
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
<col style="width:12.5%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">甲骨文10g / 11g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GeoDB（H2）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">几何基本功能</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int dimension(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String geometrytype(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int srid(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry envelope(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String astext(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte[] asbinary(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean isempty(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean issimple(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry boundary(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">测试几何对象之间空间关系的函数</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean equals(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean disjoint(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean intersects(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean touches(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean crosses(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean within(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean contains(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean overlaps(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean relate(Geometry, Geometry, String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持空间分析的功能</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double distance(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry buffer(Geometry, double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry convexhull(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <sup>（1）</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry intersection(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <sup>（1）</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry geomunion(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3（从工会重命名）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <sup>（1）</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry difference(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <sup>（1）</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry symdifference(Geometry, Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SFS§2.1.1.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <sup>（1）</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">常见的非SFS功能</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean dwithin(Geometry, Geometry, double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果几何之间的距离在指定范围内，则返回true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry transform(Geometry, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回一个新几何，其坐标转换为整型参数引用的SRID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">空间聚集函数</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Geometry extent(Geometry)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回一个边界框，该边界框限制了返回的几何图形集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><sup>（1）</sup>参数几何必须具有相同的维数。</p>
</div>
<div id="spatial-configuration-dialect-postgis" class="dlist">
<dl>
<dt class="hdlist1">Postgis</dt>
<dd>
<p>对于1.3及更高版本的Postgis，最好的方言是<code>org.hibernate.spatial.dialect.postgis.PostgisDialect</code> 。</p>
<div class="paragraph">
<p>这会将HQL空间功能转换为Postgis SQL / MM兼容功能。对于不兼容SQL / MM的Postgis v1.3之前的较早版本，应使用方言<code>org.hibernate.spatial.dialect.postgis.PostgisNoSQLMM</code>提供。</p>
</div>
</dd>
</dl>
</div>
<div id="spatial-configuration-dialect-mysql" class="dlist">
<dl>
<dt class="hdlist1">的MySQL</dt>
<dd>
<p>MySQL有几种方言：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>MySQLSpatialDialect</code></dt>
<dd>
<p>Hibernate的空间扩展版本<code>MySQLDialect</code></p>
</dd>
<dt class="hdlist1"><code>MySQL5SpatialDialect</code></dt>
<dd>
<p>Hibernate的空间扩展版本<code>MySQL5Dialect</code></p>
</dd>
<dt class="hdlist1"><code>MySQLSpatial56Dialect</code></dt>
<dd>
<p>Hibernate的空间扩展版本<code>MySQL55Dialect</code> 。</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>5.6.1之前的MySQL版本仅对空间运算符提供有限支持。大多数运算符仅考虑几何的最小边界矩形（MBR），而不考虑几何本身。</p>
</div>
<div class="paragraph">
<p>当MySQL引入时，版本5.6.1中发生了更改<code>ST_*</code>空间算子。方言<code>MySQLSpatial56Dialect</code>使用这些更新，更精确的运算符。</p>
</div>
<div class="paragraph">
<p>因此，这些方言可能会产生与其他空间方言不同的结果。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见MySQL参考指南中的此页面（尤其是<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-relation-functions.html">测试几何对象之间空间关系的函数</a>部分）</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="spatial-configuration-dialect-oracle" class="dlist">
<dl>
<dt class="hdlist1">Oracle10g / 11g</dt>
<dd>
<p>当前只有一种Oracle空间方言： <code>OracleSpatial10gDialect</code>扩展了Hibernate方言<code>Oracle10gDialect</code> 。该方言已经在Oracle 10g和Oracle 11g上进行了测试，使用<code>SDO_GEOMETRY</code>空间数据库类型。</p>
<div class="paragraph">
<p>可以使用Hibernate属性配置此方言：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>hibernate.spatial.connection_finder</code></dt>
<dd>
<p>用于实施的完全限定的类名<code>ConnectionFinder</code>使用（见下文）。</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">的<code>ConnectionFinder</code>接口</div>
<div class="paragraph">
<p>的<code>SDOGeometryType</code>需要访问<code>OracleConnection</code>将几何转换为SDO_GEOMETRY时的对象。但是，在某些环境中<code>OracleConnection</code>不可用（例如，因为Java EE容器或连接池代理将连接对象包装在自己的包装中） <code>Connection</code>实施）。一种<code>ConnectionFinder</code>知道如何检索<code>OracleConnection</code>从包装器或代理连接对象传递到准备好的语句中。</p>
</div>
<div class="paragraph">
<p>如果传递的对象还不是<code>OracleConnection</code> ，默认实现将尝试检索<code>OracleConnection</code>通过递归反射。它将搜索返回的方法<code>Connection</code>对象，执行这些方法并检查结果。如果结果是类型<code>OracleConnection</code>返回对象。否则，它将重复执行。</p>
</div>
<div class="paragraph">
<p>在某些情况下，此策略已足够。如果没有，您可以在类路径上提供您自己的接口实现，并在<code>hibernate.spatial.connection_finder</code>属性。请注意，实现必须是线程安全的，并且具有默认的无参数构造函数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SQL服务器</dt>
<dd>
<p>方言<code>SqlServer2008Dialect</code>支持<code>GEOMETRY</code>在SQL Server 2008及更高版本中输入。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>GEOGRAPHY</code>当前不支持类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">GeoDB（H2）</dt>
<dd>
<p>的<code>GeoDBDialect</code>支持GeoDB H2内存数据库的空间扩展。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该方言已通过GeoDB 0.7版进行了测试</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DB2</dt>
<dd>
<p>的<code>DB2SpatialDialect</code>支持DB2 LUW数据库的空间扩展。该方言已通过DB2 LUW 11.1进行了测试。该方言不支持DB2 for z / OS或DB2面向列的数据库。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使用DB2 Hibernate Spatial功能，必须首先执行以下SQL语句，该语句将允许DB2接受扩展的已知文本（EWKT）数据并返回EWKT数据。一种实现方法是将这些语句复制到ewkt.sql之类的文件中，并在DB2命令窗口中使用“ db2 -tvf ewkt.sql”之类的命令执行该语句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create or replace function db2gse.asewkt(geometry db2gse.st_geometry)
returns clob(2G)
specific db2gse.asewkt1
language sql
deterministic
no external action
reads sql data
return 'srid=' || varchar(db2gse.st_srsid(geometry)) || ';' || db2gse.st_astext(geometry);

create or replace function db2gse.geomfromewkt(instring varchar(32000))
returns db2gse.st_geometry
specific db2gse.fromewkt1
language sql
deterministic
no external action
reads sql data
return db2gse.st_geometry(
substr(instring,posstr(instring,';')+1, length(instring) - posstr(instring,';')),
integer(substr(instring,posstr(instring,'=')+1,posstr(instring,';')-(posstr(instring,'=')+1))));

create transform for db2gse.st_geometry ewkt (
 from sql with function db2gse.asewkt(db2gse.st_geometry),
 to   sql with function db2gse.geomfromewkt(varchar(32000)) );

drop transform db2_program for db2gse.st_geometry;
create transform for db2gse.st_geometry db2_program (
 from sql with function db2gse.asewkt(db2gse.st_geometry),
 to   sql with function db2gse.geomfromewkt(varchar(32000)) );</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-types"><a class="anchor" href="#spatial-types"></a> 18.3。种类</h3>
<div class="paragraph">
<p>Hibernate Spatial具有以下类型：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">jts_geometry</dt>
<dd>
<p>处理者<code>org.hibernate.spatial.JTSGeometryType</code>它将数据库几何列类型映射为<code>org.locationtech.jts.geom.Geometry</code>实体属性类型。</p>
</dd>
<dt class="hdlist1">geolatte_geometry</dt>
<dd>
<p>处理者<code>org.hibernate.spatial.GeolatteGeometryType</code> ，它将数据库几何列类型映射为<code>org.geolatte.geom.Geometry</code>实体属性类型。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>将属性声明为JTS或Geolatte-geom就足够了<code>Geometry</code>然后Hibernate Spatial将使用相关类型对其进行映射。</p>
</div>
<div class="paragraph">
<p>这是使用JTS的示例：</p>
</div>
<div id="spatial-types-mapping-example" class="exampleblock">
<div class="title">示例632类型映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.locationtech.jts.geom.Point;

@Entity(name = "Event")
public static class Event {

    @Id
    private Long id;

    private String name;

    private Point location;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以像对待任何其他类型一样对待空间几何形状。</p>
</div>
<div id="spatial-types-point-creation-example" class="exampleblock">
<div class="title">示例633创建一个点</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Event event = new Event();
event.setId( 1L);
event.setName( "Hibernate ORM presentation");
Point point = geometryFactory.createPoint( new Coordinate( 10, 5 ) );
event.setLocation( point );

entityManager.persist( event );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>空间方言定义了许多在HQL和JPQL查询中都可用的查询功能。下面我们展示了如何使用<code>within</code>函数可查找给定空间范围或窗口内的所有对象。</p>
</div>
<div id="spatial-types-query-example" class="exampleblock">
<div class="title">示例634查询几何</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">Polygon window = geometryFactory.createPolygon( coordinates );
Event event = entityManager.createQuery(
    "select e " +
    "from Event e " +
    "where within(e.location, :window) = true", Event.class)
.setParameter("window", window)
.getSingleResult();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multitenacy"><a class="anchor" href="#multitenacy"></a> 19多租户</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="multitenacy-intro"><a class="anchor" href="#multitenacy-intro"></a> 19.1。什么是多租户？</h3>
<div class="paragraph">
<p>通常，术语“多租户”用于软件开发以表示一种体系结构，在该体系结构中，一个应用程序的单个运行实例同时为多个客户端（租户）提供服务。这在SaaS解决方案中非常普遍。在这些系统中，隔离与各种租户有关的信息（数据，定制等）是一个特殊的挑战。这包括存储在数据库中的每个租户所拥有的数据。这是我们将重点关注的最后一部分，有时也称为多租户数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="multitenacy-approaches"><a class="anchor" href="#multitenacy-approaches"></a> 19.2。多租户数据方法</h3>
<div class="paragraph">
<p>在这些多租户系统中，有三种隔离信息的主要方法，这些方法与不同的数据库模式定义和JDBC设置紧密结合。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个多租户策略都有优点和缺点以及特定的技术和注意事项。这些主题超出了本文档的范围。有许多资源可以深入探讨其他主题，例如<a href="http://msdn.microsoft.com/en-us/library/aa479086.aspx">这一</a>资源，在涵盖该主题方面做得很好。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="multitenacy-separate-database"><a class="anchor" href="#multitenacy-separate-database"></a> 19.2.1。单独的数据库</h4>
<div class="paragraph">
<p><span class="image"><img src="images/multitenancy/multitenacy_database.png" alt="多租户数据库"></span></p>
</div>
<div class="paragraph">
<p>每个租户的数据都保存在物理上独立的数据库实例中。JDBC连接将专门指向每个数据库，因此任何池都是固定的。在这里，一种通用的应用程序方法是定义每个租户的JDBC连接池，并根据与当前登录用户关联的<em>租户标识符</em>选择要使用的池。</p>
</div>
</div>
<div class="sect3">
<h4 id="multitenacy-separate-schema"><a class="anchor" href="#multitenacy-separate-schema"></a> 19.2.2。单独的架构</h4>
<div class="paragraph">
<p><span class="image"><img src="images/multitenancy/multitenacy_schema.png" alt="多租户模式"></span></p>
</div>
<div class="paragraph">
<p>每个租户的数据都保存在单个数据库实例上的不同数据库架构中。这里有两种不同的方法来定义JDBC连接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>连接可以专门指向每个架构，正如我们在<code>Separate database</code>方法。如果驱动程序支持在连接URL中命名默认架构，或者如果池化机制支持命名用于其连接的架构，则此选项是一个选项。使用这种方法，我们将为每个租户提供一个不同的JDBC连接池，其中将根据与当前登录用户相关联的“租户标识符”来选择要使用的池。</p>
</li>
<li>
<p>连接可以指向数据库本身（使用某些默认架构），但是可以使用SQL更改连接<code>SET SCHEMA</code> （或类似）命令。使用这种方法，我们将有一个用于为所有租户提供服务的JDBC连接池，但是在使用Connection之前，将其更改为引用由与当前登录用户相关联的“租户标识符”命名的架构。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multitenacy-discriminator"><a class="anchor" href="#multitenacy-discriminator"></a> 19.3。分区（区分）数据</h3>
<div class="paragraph">
<p><span class="image"><img src="images/multitenancy/multitenacy_discriminator.png" alt="多租户鉴别器"></span></p>
</div>
<div class="paragraph">
<p>所有数据都保存在单个数据库架构中。每个租户的数据通过使用分区值或区分符进行分区。此区分符的复杂度可能从简单的列值到复杂的SQL公式。同样，此方法将使用单个连接池为所有租户提供服务。但是，在这种方法中，应用程序需要更改发送到数据库的每个SQL语句，以引用“租户标识符”鉴别符。</p>
</div>
</div>
<div class="sect2">
<h3 id="multitenacy-hibernate"><a class="anchor" href="#multitenacy-hibernate"></a> 19.4。Hibernate中的多租户</h3>
<div class="paragraph">
<p>将Hibernate与多租户数据一起使用归结为一个API，然后是集成件。像往常一样，Hibernate努力使API保持简单并与任何底层集成复杂性隔离。该API实际上只是通过在打开任何会话的过程中传递承租方标识符来定义的。</p>
</div>
<div id="multitenacy-hibernate-session-example" class="exampleblock">
<div class="title">示例635从中指定租户标识符<code>SessionFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">private void doInSession(String tenant, Consumer&lt;Session&gt; function) {
    Session session = null;
    Transaction txn = null;
    try {
        session = sessionFactory
            .withOptions()
            .tenantIdentifier( tenant )
            .openSession();
        txn = session.getTransaction();
        txn.begin();
        function.accept(session);
        txn.commit();
    } catch (Throwable e) {
        if ( txn != null ) txn.rollback();
        throw e;
    } finally {
        if (session != null) {
            session.close();
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，在指定配置时， <code>org.hibernate.MultiTenancyStrategy</code>应该使用<code>hibernate.multiTenancy</code>设置。Hibernate将根据您指定的策略类型执行验证。这里的策略与上面讨论的隔离方法相关。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">没有</dt>
<dd>
<p>（默认）不希望有多租户。实际上，如果使用此策略打开会话时指定了租户标识符，则认为是错误。</p>
</dd>
<dt class="hdlist1">施玛</dt>
<dd>
<p>与单独的架构方法相关。使用此策略尝试在没有租户标识符的情况下打开会话是错误的。此外， <code>MultiTenantConnectionProvider</code>必须指定。</p>
</dd>
<dt class="hdlist1">数据库</dt>
<dd>
<p>与单独的数据库方法相关。使用此策略尝试在没有租户标识符的情况下打开会话是错误的。此外， <code>MultiTenantConnectionProvider</code>必须指定。</p>
</dd>
<dt class="hdlist1">判别器</dt>
<dd>
<p>与分区（区分器）方法相关。使用此策略尝试在没有租户标识符的情况下打开会话是错误的。该策略尚未实施，您可以通过<a href="https://hibernate.atlassian.net/browse/HHH-6054">HHH-6054 Jira问题</a>跟踪其进展。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="multitenacy-hibernate-MultiTenantConnectionProvider"><a class="anchor" href="#multitenacy-hibernate-MultiTenantConnectionProvider"></a> 19.4.1。MultiTenantConnectionProvider</h4>
<div class="paragraph">
<p>当使用DATABASE或SCHEMA方法时，Hibernate需要能够以租户特定的方式获取连接。</p>
</div>
<div class="paragraph">
<p>那就是角色<code>MultiTenantConnectionProvider</code>合同。应用程序开发人员将需要提供此合同的实施。</p>
</div>
<div class="paragraph">
<p>它的大多数方法都是非常不言自明的。唯一可能不是的<code>getAnyConnection</code>和<code>releaseAnyConnection</code> 。还必须注意，这些方法不接受承租方标识符。Hibernate在启动期间会使用这些方法来执行各种配置，主要是通过<code>java.sql.DatabaseMetaData</code>宾语。</p>
</div>
<div class="paragraph">
<p>的<code>MultiTenantConnectionProvider</code>可以通过多种方式指定使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>hibernate.multi_tenant_connection_provider</code>设置。它可以命名为<code>MultiTenantConnectionProvider</code>例如，一个<code>MultiTenantConnectionProvider</code>实现类参考或<code>MultiTenantConnectionProvider</code>实现类名称。</p>
</li>
<li>
<p>直接传递给<code>org.hibernate.boot.registry.StandardServiceRegistryBuilder</code> 。</p>
</li>
<li>
<p>如果以上选项都不匹配，但是设置确实指定了一个<code>hibernate.connection.datasource</code>值，Hibernate将假定它应该使用特定的<code>DataSourceBasedMultiTenantConnectionProviderImpl</code>在应用服务器内部运行并使用一个时，该实现基于许多相当合理的假设进行工作<code>javax.sql.DataSource</code>每个租户。有关更多详细信息，请参见其<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.html">Javadocs</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例描绘了<code>MultiTenantConnectionProvider</code>处理多个的实现<code>ConnectionProviders</code> 。</p>
</div>
<div id="multitenacy-hibernate-ConfigurableMultiTenantConnectionProvider-example" class="exampleblock">
<div class="title">示例636一种<code>MultiTenantConnectionProvider</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class ConfigurableMultiTenantConnectionProvider
        extends AbstractMultiTenantConnectionProvider {

    private final Map&lt;String, ConnectionProvider&gt; connectionProviderMap =
        new HashMap&lt;&gt;(  );

    public ConfigurableMultiTenantConnectionProvider(
            Map&lt;String, ConnectionProvider&gt; connectionProviderMap) {
        this.connectionProviderMap.putAll( connectionProviderMap );
    }

    @Override
    protected ConnectionProvider getAnyConnectionProvider() {
        return connectionProviderMap.values().iterator().next();
    }

    @Override
    protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {
        return connectionProviderMap.get( tenantIdentifier );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>ConfigurableMultiTenantConnectionProvider</code>可以设置如下：</p>
</div>
<div id="multitenacy-hibernate-MultiTenantConnectionProvider-example" class="exampleblock">
<div class="title">示例637一种<code>MultiTenantConnectionProvider</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">private void init() {
    registerConnectionProvider( FRONT_END_TENANT );
    registerConnectionProvider( BACK_END_TENANT );

    Map&lt;String, Object&gt; settings = new HashMap&lt;&gt;(  );

    settings.put( AvailableSettings.MULTI_TENANT, multiTenancyStrategy() );
    settings.put( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,
        new ConfigurableMultiTenantConnectionProvider( connectionProviderMap ) );

    sessionFactory = sessionFactory(settings);
}

protected void registerConnectionProvider(String tenantIdentifier) {
    Properties properties = properties();
    properties.put( Environment.URL,
        tenantUrl(properties.getProperty( Environment.URL ), tenantIdentifier) );

    DriverManagerConnectionProviderImpl connectionProvider =
        new DriverManagerConnectionProviderImpl();
    connectionProvider.configure( properties );
    connectionProviderMap.put( tenantIdentifier, connectionProvider );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用多租户时，可以在不同的租户之间保存具有相同标识符的实体：</p>
</div>
<div id="multitenacy-hibernate-same-entity-example" class="exampleblock">
<div class="title">示例638一种<code>MultiTenantConnectionProvider</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInSession( FRONT_END_TENANT, session -&gt; {
    Person person = new Person(  );
    person.setId( 1L );
    person.setName( "John Doe" );
    session.persist( person );
} );

doInSession( BACK_END_TENANT, session -&gt; {
    Person person = new Person(  );
    person.setId( 1L );
    person.setName( "John Doe" );
    session.persist( person );
} );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multitenacy-hibernate-CurrentTenantIdentifierResolver"><a class="anchor" href="#multitenacy-hibernate-CurrentTenantIdentifierResolver"></a> 19.4.2。CurrentTenantIdentifierResolver</h4>
<div class="paragraph">
<p><code>org.hibernate.context.spi.CurrentTenantIdentifierResolver</code>是Hibernate能够解决应用程序认为当前租户标识符的合同。要使用的实现可以直接传递给<code>Configuration</code>通过其<code>setCurrentTenantIdentifierResolver</code>方法。也可以通过指定<code>hibernate.tenant_identifier_resolver</code>设置。</p>
</div>
<div class="paragraph">
<p>在两种情况下使用CurrentTenantIdentifierResolver：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一种情况是应用程序正在使用<code>org.hibernate.context.spi.CurrentSessionContext</code>结合多租户功能。对于当前会话功能，如果Hibernate在范围内找不到现有的会话，则需要打开一个会话。但是，在多租户环境中打开会话时，必须指定租户标识符。这是<code>CurrentTenantIdentifierResolver</code>发挥作用； Hibernate将咨询您提供的实现，以确定在打开会话时要使用的租户标识符。在这种情况下，要求<code>CurrentTenantIdentifierResolver</code>提供。</p>
</li>
<li>
<p>另一种情况是您不想一直都必须明确指定租户标识符。如果一个<code>CurrentTenantIdentifierResolver</code>已被指定，Hibernate将使用它来确定打开会话时要使用的默认租户标识符。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，如果<code>CurrentTenantIdentifierResolver</code>实施回报<code>true</code>对于它<code>validateExistingCurrentSessions</code>方法，Hibernate将确保在范围内找到的所有现有会话都具有匹配的租户标识符。仅当<code>CurrentTenantIdentifierResolver</code>在当前会话设置中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="multitenacy-hibernate-caching"><a class="anchor" href="#multitenacy-hibernate-caching"></a> 19.4.3。快取</h4>
<div class="paragraph">
<p>Hibernate中的多租户支持与Hibernate二级缓存无缝配合。用于缓存数据的密钥对租户标识符进行编码。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当前，模式导出不能真正用于多租户。</p>
</div>
<div class="paragraph">
<p>JPA专家组正在为即将发布的规范版本定义多租户支持。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="multitenacy-hibernate-session-configuration"><a class="anchor" href="#multitenacy-hibernate-session-configuration"></a> 19.4.4。多租户Hibernate会话配置</h4>
<div class="paragraph">
<p>使用多租户时，您可能需要配置每个特定于租户的<code>Session</code>不一样。例如，每个租户可以采用不同的时区配置。</p>
</div>
<div id="multitenacy-hibernate-timezone-configuration-registerConnectionProvider-call-example" class="exampleblock">
<div class="title">示例639。注册特定于租户的时区信息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">registerConnectionProvider( FRONT_END_TENANT, TimeZone.getTimeZone( "UTC" ) );
registerConnectionProvider( BACK_END_TENANT, TimeZone.getTimeZone( "CST" ) );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>registerConnectionProvider</code>方法用于定义特定于租户的上下文。</p>
</div>
<div id="multitenacy-hibernate-timezone-configuration-registerConnectionProvider-example" class="exampleblock">
<div class="title">示例640的<code>registerConnectionProvider</code>用于定义特定于租户的上下文的方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">protected void registerConnectionProvider(String tenantIdentifier, TimeZone timeZone) {
    Properties properties = properties();
    properties.put(
        Environment.URL,
        tenantUrl( properties.getProperty( Environment.URL ), tenantIdentifier )
    );

    DriverManagerConnectionProviderImpl connectionProvider =
            new DriverManagerConnectionProviderImpl();
    connectionProvider.configure( properties );

    connectionProviderMap.put( tenantIdentifier, connectionProvider );

    timeZoneTenantMap.put( tenantIdentifier, timeZone );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于我们的示例，特定于租户的上下文保存在<code>connectionProviderMap</code>和<code>timeZoneTenantMap</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">private Map&lt;String, ConnectionProvider&gt; connectionProviderMap = new HashMap&lt;&gt;();

private Map&lt;String, TimeZone&gt; timeZoneTenantMap = new HashMap&lt;&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在构建Hibernate模式时<code>Session</code> ，除了传递租户标识符外，我们还可以配置<code>Session</code>使用特定于租户的时区。</p>
</div>
<div id="multitenacy-hibernate-timezone-configuration-session-example" class="exampleblock">
<div class="title">示例641。冬眠<code>Session</code>可以使用特定于租户的上下文进行配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">private void doInSession(String tenant, Consumer&lt;Session&gt; function, boolean useTenantTimeZone) {
    Session session = null;
    Transaction txn = null;

    try {
        SessionBuilder sessionBuilder = sessionFactory
                .withOptions()
                .tenantIdentifier( tenant );

        if ( useTenantTimeZone ) {
            sessionBuilder.jdbcTimeZone( timeZoneTenantMap.get( tenant ) );
        }

        session = sessionBuilder.openSession();

        txn = session.getTransaction();
        txn.begin();

        function.accept( session );

        txn.commit();
    }
    catch (Throwable e) {
        if ( txn != null ) {
            txn.rollback();
        }
        throw e;
    }
    finally {
        if ( session != null ) {
            session.close();
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因此，如果我们将<code>useTenantTimeZone</code>参数<code>true</code> ，Hibernate将坚持<code>Timestamp</code>使用特定于租户的时区的属性。如以下示例所示， <code>Timestamp</code>即使当前正在运行的JVM使用其他时区，也可以成功检索到。</p>
</div>
<div id="multitenacy-hibernate-applying-timezone-configuration-example" class="exampleblock">
<div class="title">示例642。的<code>useTenantTimeZone</code>让你坚持一个<code>Timestamp</code>在提供的时区</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInSession( FRONT_END_TENANT, session -&gt; {
    Person person = new Person();
    person.setId( 1L );
    person.setName( "John Doe" );
    person.setCreatedOn( LocalDateTime.of( 2018, 11, 23, 12, 0, 0 ) );

    session.persist( person );
}, true );

doInSession( BACK_END_TENANT, session -&gt; {
    Person person = new Person();
    person.setId( 1L );
    person.setName( "John Doe" );
    person.setCreatedOn( LocalDateTime.of( 2018, 11, 23, 12, 0, 0 ) );

    session.persist( person );
}, true );

doInSession( FRONT_END_TENANT, session -&gt; {
    Timestamp personCreationTimestamp = (Timestamp) session
    .createNativeQuery(
        "select p.created_on " +
        "from Person p " +
        "where p.id = :personId" )
    .setParameter( "personId", 1L )
    .getSingleResult();

    assertEquals(
        Timestamp.valueOf( LocalDateTime.of( 2018, 11, 23, 12, 0, 0 ) ),
        personCreationTimestamp
    );
}, true );

doInSession( BACK_END_TENANT, session -&gt; {
    Timestamp personCreationTimestamp = (Timestamp) session
    .createNativeQuery(
        "select p.created_on " +
        "from Person p " +
        "where p.id = :personId" )
    .setParameter( "personId", 1L )
    .getSingleResult();

    assertEquals(
        Timestamp.valueOf( LocalDateTime.of( 2018, 11, 23, 12, 0, 0 ) ),
        personCreationTimestamp
    );
}, true );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，在后台，我们可以看到Hibernate已保存了<code>created_on</code>属性在租户特定的时区。以下示例显示了<code>Timestamp</code>已保存在UTC时区中，因此在测试输出中显示了偏移量。</p>
</div>
<div id="multitenacy-hibernate-not-applying-timezone-configuration-example" class="exampleblock">
<div class="title">示例643。随着<code>useTenantTimeZone</code>属性设置为<code>false</code> ， <code>Timestamp</code>在特定于租户的时区中获取</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">doInSession( FRONT_END_TENANT, session -&gt; {
    Timestamp personCreationTimestamp = (Timestamp) session
    .createNativeQuery(
        "select p.created_on " +
        "from Person p " +
        "where p.id = :personId" )
    .setParameter( "personId", 1L )
    .getSingleResult();

    log.infof(
        "The created_on timestamp value is: [%s]",
        personCreationTimestamp
    );

    long timeZoneOffsetMillis =
            Timestamp.valueOf( LocalDateTime.of( 2018, 11, 23, 12, 0, 0 ) ).getTime() -
            personCreationTimestamp.getTime();

    assertEquals(
        TimeZone.getTimeZone(ZoneId.systemDefault()).getRawOffset(),
        timeZoneOffsetMillis
    );

    log.infof(
        "For the current time zone: [%s], the UTC time zone offset is: [%d]",
        TimeZone.getDefault().getDisplayName(), timeZoneOffsetMillis
    );
}, false );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">SELECT
    p.created_on
FROM
    Person p
WHERE
    p.id = ?

-- binding parameter [1] as [BIGINT] - [1]
-- extracted value ([CREATED_ON] : [TIMESTAMP]) - [2018-11-23 10:00:00.0]

-- The created_on timestamp value is: [2018-11-23 10:00:00.0]
-- For the current time zone: [Eastern European Time], the UTC time zone offset is: [7200000]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，对于<code>Eastern European Time</code>时区，执行测试时的时区偏移为2小时。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="osgi"><a class="anchor" href="#osgi"></a> 20OSGi</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_osgi_specification_and_environment"><a class="anchor" href="#_osgi_specification_and_environment"></a> 20.1。OSGi规范和环境</h3>
<div class="paragraph">
<p>Hibernate的目标是OSGi 4.3规范或更高版本。由于我们对OSGi的依赖，因此必须从4.3开始，超过4.2 <code>BundleWiring</code>用于实体/映射扫描。</p>
</div>
<div class="paragraph">
<p>Hibernate在OSGi中支持三种类型的配置。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>容器管理的JPA <a href="#osgi-managed-jpa">容器管理的JPA</a></p>
</li>
<li>
<p>非托管JPA <a href="#osgi-unmanaged-jpa">非托管JPA</a></p>
</li>
<li>
<p>非托管本机<a href="#osgi-unmanaged-native">非托管本机</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_hibernate_osgi"><a class="anchor" href="#_hibernate_osgi"></a> 20.2。冬眠</h3>
<div class="paragraph">
<p>不是将OSGi功能嵌入到Hibernate核心和子模块中，而是创建了hibernate-osgi。它是有目的地分离的，隔离了所有OSGi依赖项。它提供了特定于OSGi的<code>ClassLoader</code> （汇总容器的<code>ClassLoader</code>与核心和<code>EntityManager</code><code>ClassLoader`s), JPA persistence provider, `SessionFactory</code> / <code>EntityManagerFactory</code>引导程序，实体/映射扫描程序和服务管理。</p>
</div>
</div>
<div class="sect2">
<h3 id="_features_xml"><a class="anchor" href="#_features_xml"></a> 20.3。 features.xml</h3>
<div class="paragraph">
<p>Apache Karaf环境倾向于大量使用其“功能”概念，该功能是一组特定于订单的捆绑软件，这些捆绑软件专注于简洁的功能。这些功能通常在<code>features.xml</code>文件。Hibernate生产并发布自己的产品<code>features.xml</code>定义一个核心<code>hibernate-orm</code> ，以及其他可选功能（缓存，Envers等）的功能。它包含在二进制发行版中，并已部署到JBoss Nexus存储库（使用<code>org.hibernate</code> groupId和<code>hibernate-osgi</code>与<code>karaf.xml</code>分类器）。</p>
</div>
<div class="paragraph">
<p>请注意，我们的功能使用与其包装的相同ORM工件版本进行版本控制。另外，请注意，作为基于PaxExam的集成测试的一部分，这些功能已针对Karaf 3.0.3进行了严格测试。但是，它们也可能会在其他版本上使用。</p>
</div>
<div class="paragraph">
<p>从理论上讲，hibernate-osgi支持各种OSGi容器，例如Equinox。在这种情况下，请使用`features.xm`l作为激活必要捆绑包及其正确顺序的参考。但是，请注意，Karaf会自动启动许多捆绑软件，其中一些捆绑软件需要在替代产品上手动安装。</p>
</div>
</div>
<div class="sect2">
<h3 id="_quickstarts_demos"><a class="anchor" href="#_quickstarts_demos"></a> 20.4。快速入门/演示</h3>
<div class="paragraph">
<p>所有三个配置在<a href="https://github.com/hibernate/hibernate-demos">hibernate-demos</a>项目中都有一个QuickStart / Demo：</p>
</div>
</div>
<div class="sect2">
<h3 id="osgi-managed-jpa"><a class="anchor" href="#osgi-managed-jpa"></a> 20.5。容器管理的JPA</h3>
<div class="paragraph">
<p>Enterprise OSGi规范包括容器管理的JPA。容器负责发现捆绑中的持久性单元并自动创建<code>EntityManagerFactory</code> （一<code>EntityManagerFactory</code>每<code>PersistenceUnit</code> ）。它使用已向OSGi注册了自己的JPA提供程序（hibernate-osgi） <code>PersistenceProvider</code>服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_enterprise_osgi_jpa_container"><a class="anchor" href="#_enterprise_osgi_jpa_container"></a> 20.6。企业OSGi JPA容器</h3>
<div class="paragraph">
<p>为了利用容器管理的JPA，Enterprise OSGi JPA容器必须在运行时处于活动状态。在Karaf中，这表示即装即用的Aries JPA（只需激活<code>jpa</code>和<code>transaction</code>特征）。最初，我们打算将这些依赖项包含在我们自己的<code>features.xml</code> 。然而，在卡拉夫和白羊队的指导下，它被撤出。这使Hibernate OSGi可以移植，并且不直接与Aries版本绑定，而不必让用户选择要使用的版本。</p>
</div>
<div class="paragraph">
<p>就是说，QuickStart / Demo项目包含一个示例<a href="https://github.com/hibernate/hibernate-demos/tree/master/hibernate-orm/osgi/managed-jpa/features.xml">features.xml</a> ，该示例显示了需要在Karaf中激活哪些功能才能支持此环境。如前所述，仅将其用作参考！</p>
</div>
</div>
<div class="sect2">
<h3 id="_persistence_xml"><a class="anchor" href="#_persistence_xml"></a> 20.7。 persistence.xml</h3>
<div class="paragraph">
<p>与任何其他JPA设置类似，您的捆绑包必须包含一个<code>persistence.xml</code>文件。通常位于<code>META-INF</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_datasource"><a class="anchor" href="#_datasource"></a> 20.8。数据源</h3>
<div class="paragraph">
<p>典型的Enterprise OSGi JPA用法包括<code>DataSource</code>安装在容器中。您的捆绑包<code>persistence.xml</code>呼唤<code>DataSource</code>通过JNDI。例如，您可以安装以下H2 <code>DataSource</code> 。您可以部署<code>DataSource</code>手动（Karaf有一个<code>deploy</code> dir），或通过“蓝图包”（ <code>blueprint:file:/[PATH]/datasource-h2.xml</code> ）。</p>
</div>
<div class="exampleblock">
<div class="title">例子644. datasource-h2.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
First install the H2 driver using:
&gt; install -s mvn:com.h2database/h2/1.3.163

Then copy this file to the deploy folder
--&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"&gt;

    &lt;bean id="dataSource" class="org.h2.jdbcx.JdbcDataSource"&gt;
        &lt;property name="URL" value="jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE"/&gt;
        &lt;property name="user" value="sa"/&gt;
        &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;

    &lt;service interface="javax.sql.DataSource" ref="dataSource"&gt;
        &lt;service-properties&gt;
            &lt;entry key="osgi.jndi.service.name" value="jdbc/h2ds"/&gt;
        &lt;/service-properties&gt;
    &lt;/service&gt;
&lt;/blueprint&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>那<code>DataSource</code>然后由您使用<code>persistence.xml</code>持久性单元。以下内容在Karaf中有效，但名称可能需要在其他容器中进行调整。</p>
</div>
<div class="exampleblock">
<div class="title">示例645META-INF / persistence.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;jta-data-source&gt;osgi:service/javax.sql.DataSource/(osgi.jndi.service.name=jdbc/h2ds)&lt;/jta-data-source&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bundle_package_imports"><a class="anchor" href="#_bundle_package_imports"></a> 20.9。捆绑包导入</h3>
<div class="paragraph">
<p>捆绑商品的清单至少需要导入，</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>javax.persistence</code></p>
</li>
<li>
<p><code>org.hibernate.proxy</code>和<code>javassist.util.proxy</code> ，由于Hibernate可以返回代理以进行延迟初始化（Javassist增强功能发生在实体的<code>ClassLoader</code>在运行期间）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_obtaining_an_entitymanger"><a class="anchor" href="#_obtaining_an_entitymanger"></a> 20.10。获取实体</h3>
<div class="paragraph">
<p>最简单，最受支持的获取方法<code>EntityManager</code>利用OSGi的<code>OSGI-INF/blueprint/blueprint.xml</code>在您的捆绑包中。容器使用您的持久性单元的名称，然后自动注入<code>EntityManager</code>实例进入给定的bean属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例646OSGI-INF / blueprint / blueprint.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns:jpa="http://aries.apache.org/xmlns/jpa/v1.0.0"
           xmlns:tx="http://aries.apache.org/xmlns/transactions/v1.0.0"
           default-activation="eager"
           xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"&gt;

    &lt;!-- This gets the container-managed EntityManager and injects it into the DataPointServiceImpl bean.
    Assumes DataPointServiceImpl has an "entityManager" field with a getter and setter. --&gt;
    &lt;bean id="dpService" class="org.hibernate.osgitest.DataPointServiceImpl"&gt;
        &lt;jpa:context unitname="managed-jpa" property="entityManager"/&gt;
        &lt;tx:transaction method="*" value="Required"/&gt;
    &lt;/bean&gt;

    &lt;service ref="dpService" interface="org.hibernate.osgitest.DataPointService"/&gt;

&lt;/blueprint&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="osgi-unmanaged-jpa"><a class="anchor" href="#osgi-unmanaged-jpa"></a> 20.11。非托管JPA</h3>
<div class="paragraph">
<p>Hibernate还支持不受OSGi容器管理的JPA的使用。客户端捆绑包负责管理<code>EntityManagerFactory</code>和`EntityManager`s。</p>
</div>
</div>
<div class="sect2">
<h3 id="_persistence_xml_2"><a class="anchor" href="#_persistence_xml_2"></a> 20.12。 persistence.xml</h3>
<div class="paragraph">
<p>与任何其他JPA设置类似，您的捆绑包必须包含一个<code>persistence.xml</code>文件。通常位于<code>META-INF</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bundle_package_imports_2"><a class="anchor" href="#_bundle_package_imports_2"></a> 20.13。捆绑包导入</h3>
<div class="paragraph">
<p>捆绑商品的清单至少需要导入，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>javax.persistence</p>
</li>
<li>
<p><code>org.hibernate.proxy</code>和<code>javassist.util.proxy</code> ，由于Hibernate可以返回代理以进行延迟初始化（Javassist增强功能发生在实体的<code>ClassLoader</code>在运行期间）</p>
</li>
<li>
<p>JDBC驱动程序包（示例： <code>org.h2</code> ）</p>
</li>
<li>
<p><code>org.osgi.framework</code> ，对于发现<code>EntityManagerFactory</code> （如下面所描述的）</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_obtaining_an_entitymangerfactory"><a class="anchor" href="#_obtaining_an_entitymangerfactory"></a> 20.14。获取EntityMangerFactory</h3>
<div class="paragraph">
<p><code>hibernate-osgi</code>使用JPA注册OSGi服务<code>PersistenceProvider</code>接口名称，该名称引导并创建一个<code>EntityManagerFactory</code>特定于OSGi环境。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您的生命至关重要<code>EntityManagerFactory</code>可以通过服务获得，而不是手动创建。该服务处理OSGi <code>ClassLoader</code> ，发现的扩展点，扫描等。手动创建<code>EntityManagerFactory</code>保证在运行期间不起作用！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="osgi-discover-EntityManagerFactory" class="exampleblock">
<div class="title">示例647发现/使用<code>EntityManagerFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class HibernateUtil {

    private EntityManagerFactory emf;

    public EntityManager getEntityManager() {
        return getEntityManagerFactory().createEntityManager();
    }

    private EntityManagerFactory getEntityManagerFactory() {
        if ( emf == null ) {
            Bundle thisBundle = FrameworkUtil.getBundle(
                HibernateUtil.class
            );
            BundleContext context = thisBundle.getBundleContext();

            ServiceReference serviceReference = context.getServiceReference(
                PersistenceProvider.class.getName()
            );
            PersistenceProvider persistenceProvider = ( PersistenceProvider ) context
            .getService(
                serviceReference
            );

            emf = persistenceProvider.createEntityManagerFactory(
                "YourPersistenceUnitName",
                null
            );
        }
        return emf;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="osgi-unmanaged-native"><a class="anchor" href="#osgi-unmanaged-native"></a> 20.15。非托管本地</h3>
<div class="paragraph">
<p>还支持本地Hibernate使用。客户端捆绑包负责管理<code>SessionFactory</code>和`Session`s。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bundle_package_imports_3"><a class="anchor" href="#_bundle_package_imports_3"></a> 20.16。捆绑包导入</h3>
<div class="paragraph">
<p>捆绑商品的清单至少需要导入，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>javax.persistence</p>
</li>
<li>
<p><code>org.hibernate.proxy</code>和<code>javassist.util.proxy</code> ，由于Hibernate可以返回代理以进行延迟初始化（Javassist增强功能发生在实体的<code>ClassLoader</code>在运行期间）</p>
</li>
<li>
<p>JDBC驱动程序包（示例： <code>org.h2</code> ）</p>
</li>
<li>
<p><code>org.osgi.framework</code> ，对于发现<code>SessionFactory</code> （如下面所描述的）</p>
</li>
<li>
<p><code>org.hibernate.*</code>必要的软件包（例如：cfg，标准，服务等）</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_obtaining_a_sessionfactory"><a class="anchor" href="#_obtaining_a_sessionfactory"></a> 20.17。获取SessionFactory</h3>
<div class="paragraph">
<p><code>hibernate-osgi</code>使用以下命令注册OSGi服务<code>SessionFactory</code>接口名称，该名称引导并创建一个<code>SessionFactory</code>特定于OSGi环境。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您的生命至关重要<code>SessionFactory</code>可以通过服务获得，而不是手动创建。该服务处理OSGi <code>ClassLoader</code> ，发现的扩展点，扫描等。手动创建<code>SessionFactory</code>保证在运行期间不起作用！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="osgi-discover-SessionFactory" class="exampleblock">
<div class="title">示例648发现/使用<code>SessionFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class HibernateUtil {

    private SessionFactory sf;

    public Session getSession() {
        return getSessionFactory().openSession();
    }

    private SessionFactory getSessionFactory() {
        if ( sf == null ) {
            Bundle thisBundle = FrameworkUtil.getBundle(
                HibernateUtil.class
            );
            BundleContext context = thisBundle.getBundleContext();

            ServiceReference sr = context.getServiceReference(
                SessionFactory.class.getName()
            );
            sf = ( SessionFactory ) context.getService( sr );
        }
        return sf;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optional_modules"><a class="anchor" href="#_optional_modules"></a> 20.18。可选模块</h3>
<div class="paragraph">
<p><a href="https://github.com/hibernate/hibernate-demos/tree/master/hibernate-orm/osgi/unmanaged-native">非托管本地</a>演示项目显示了可选Hibernate模块的使用。每个模块都添加了必须首先手动或通过其他功能激活的其他依赖项捆绑包。从ORM 4.2开始，完全支持Envers。在4.3中添加了对C3P0，Proxool，EhCache和Infinispan的支持。但是，他们的第3方库目前都无法在OSGi中使用（很多<code>ClassLoader</code>问题等）。我们正在跟踪JIRA中的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_extension_points"><a class="anchor" href="#_extension_points"></a> 20.19。延伸点</h3>
<div class="paragraph">
<p>存在多个合同，以允许应用程序与Hibernate功能集成并扩展它们。大多数应用程序都使用JDK服务来提供其实现。
<code>hibernate-osgi</code>通过OSGi服务支持相同的扩展。实施并注册这三种配置中的任何一种。
<code>hibernate-osgi</code>将在发现和整合它们的过程中<code>EntityManagerFactory</code> / <code>SessionFactory</code>自举。支持的扩展点如下。服务注册期间应使用指定的接口。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.integrator.spi.Integrator</code></dt>
<dd>
<p>（从4.2开始）</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.boot.registry.selector.StrategyRegistrationProvider</code></dt>
<dd>
<p>（从4.3版开始）</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.boot.model.TypeContributor</code></dt>
<dd>
<p>（从4.3版开始）</p>
</dd>
<dt class="hdlist1">JTA的</dt>
<dd>
<p><code>javax.transaction.TransactionManager</code>和<code>javax.transaction.UserTransaction</code> （从4.2版开始）。但是，这些通常是由OSGi容器提供的。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>注册扩展点实现的最简单方法是通过<code>blueprint.xml</code>文件。加<code>OSGI-INF/blueprint/blueprint.xml</code>到你的classpath。Envers的蓝图就是一个很好的例子：</p>
</div>
<div class="exampleblock">
<div class="title">示例649blueprint.xml中的示例扩展点注册</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.
  --&gt;
&lt;blueprint default-activation="eager"
           xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"&gt;

    &lt;bean id="integrator" class="org.hibernate.envers.boot.internal.EnversIntegrator"/&gt;
    &lt;service ref="integrator" interface="org.hibernate.integrator.spi.Integrator"/&gt;

    &lt;bean id="typeContributor"
          class="org.hibernate.envers.boot.internal.TypeContributorImpl"/&gt;
    &lt;service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor"/&gt;

&lt;/blueprint&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>扩展点还可以通过程序注册<code>BundleContext#registerService</code> ，通常在您的<code>BundleActivator#start</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_caveats"><a class="anchor" href="#_caveats"></a> 20.20。注意事项</h3>
<div class="ulist">
<ul>
<li>
<p>从技术上讲，Enterprise OSGi JPA和非托管Hibernate JPA使用支持多个持久性单元。但是，我们目前无法在OSGi中支持此功能。在Hibernate 4中，只有一个特定于OSGi的实例<code>ClassLoader</code>每个Hibernate捆绑包都使用，主要是因为大量使用静态TCCL实用程序。我们希望支持一个OSGi <code>ClassLoader</code> Hibernate 5中的每个持久性单元。</p>
</li>
<li>
<p>支持扫描以查找未明确列出的实体和映射。但是，它们必须与您的持久性单元放在同一个包中（无论如何还是很典型的）。我们的OSGi <code>ClassLoader</code>仅考虑“请求包”（因此要求使用服务来创建<code>EntityManagerFactory</code> / <code>SessionFactory</code> ），而不是尝试扫描所有可用的捆绑软件。这主要是出于版本控制，碰撞保护等方面的考虑。</p>
</li>
<li>
<p>某些容器（例如：白羊座）对于<code>PersistenceUnitInfo#excludeUnlistedClasses</code> ，即使您<code>persistence.xml</code>明确有<code>exclude-unlisted-classes</code>调成<code>false</code> 。他们声称，这是为了保护JPA提供程序免于实施扫描（“我们为您处理”），即使我们在许多情况下仍希望支持它也是如此。解决方法是设置<code>hibernate.archive.autodetection</code>例如<code>hbm,class</code> 。这告诉冬眠忽略<code>excludeUnlistedClasses</code>值并扫描<code>*.hbm.xml</code>和实体。</p>
</li>
<li>
<p>扫描目前不支持以下格式的带注释的程序包： <code>package-info.java</code> 。</p>
</li>
<li>
<p>当前，主要使用Apache Karaf和Apache Aries JPA对Hibernate OSGi进行测试。 Equinox，Gemini和其他容器提供商需要进行其他测试。</p>
</li>
<li>
<p>Hibernate ORM具有许多当前不提供OSGi清单的依赖项。快速入门教程大量使用了第三方捆绑包（SpringSource，ServiceMix）或<code>wrap:…​</code>操作员。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="envers"><a class="anchor" href="#envers"></a> 21Envers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="envers-basics"><a class="anchor" href="#envers-basics"></a> 21.1。基本</h3>
<div class="paragraph">
<p>要审核在实体上执行的更改，您仅需要两件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>hibernate-envers</code>在类路径上的jar，</p>
</li>
<li>
<p>一个<code>@Audited</code>实体上的注释。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与以前的版本不同，您不再需要在Hibernate配置文件中指定侦听器。只需将Envers jar放在类路径上就足够了，因为侦听器将自动注册。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>就这样。您可以像往常一样创建，修改和删除实体。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JPA的使用<code>CriteriaUpdate</code>和<code>CriteriaDelete</code> Envers当前不支持批量操作，这是因为实体的生命周期事件是如何分派的。应避免此类操作，因为它们不会被Envers捕获，并导致不完整的审核历史记录。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果查看为您的实体生成的架构，或查看Hibernate保留的数据，您会发现没有任何更改。但是，对于每个审核实体，都会引入一个新表- <code>entity_table_AUD</code> ，只要您提交交易，它就会存储历史数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果出现以下情况，则Envers自动创建审核表<code>hibernate.hbm2ddl.auto</code>选项设置为<code>create</code> ， <code>create-drop</code>要么<code>update</code> 。还可以在<a href="#envers-generateschema">使用Hibernate hbm2ddl工具生成Envers架构中</a>的Ant任务中<a href="#envers-generateschema">生成</a>适当的DDL语句。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑到我们有一个<code>Customer</code>实体，当用<code>Audited</code>注释，Hibernate将使用<code>hibernate.hbm2ddl.auto</code>模式工具：</p>
</div>
<div id="envers-audited-mapping-example" class="exampleblock">
<div class="title">示例650基本Envers实体映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	@Temporal( TemporalType.TIMESTAMP )
	@Column(name = "created_on")
	@CreationTimestamp
	private Date createdOn;

	//Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id)
)

create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Customer_AUD
   add constraint FK5ecvi1a0ykunrriib7j28vpdj
   foreign key (REV)
   references REVINFO</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您不必注释整个类并审核所有属性，而可以使用以下方法仅注释一些持久属性： <code>@Audited</code> 。这将导致仅审核这些属性。</p>
</div>
<div class="paragraph">
<p>现在，考虑到以前<code>Customer</code>实体，让我们看看在插入，更新和删除相关实体时Envers审计的工作方式。</p>
</div>
<div id="envers-audited-insert-example" class="exampleblock">
<div class="title">示例651审计实体<code>INSERT</code>运作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = new Customer();
customer.setId( 1L );
customer.setFirstName( "John" );
customer.setLastName( "Doe" );

entityManager.persist( customer );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Customer
    (created_on, firstName, lastName, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [Mon Jul 24 17:21:32 EEST 2017]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [1]
-- binding parameter [2] as [BIGINT]    - [1500906092803]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [0]
-- binding parameter [2] as [TIMESTAMP] - [Mon Jul 24 17:21:32 EEST 2017]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [1]</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-audited-update-example" class="exampleblock">
<div class="title">示例652。审计实体<code>UPDATE</code>运作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.find( Customer.class, 1L );
customer.setLastName( "Doe Jr." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update
    Customer
set
    created_on=?,
    firstName=?,
    lastName=?
where
    id=?

-- binding parameter [1] as [TIMESTAMP] - [2017-07-24 17:21:32.757]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [2]
-- binding parameter [2] as [BIGINT]    - [1500906092853]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [1]
-- binding parameter [2] as [TIMESTAMP] - [2017-07-24 17:21:32.757]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [2]</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-audited-delete-example" class="exampleblock">
<div class="title">示例653。审计实体<code>DELETE</code>运作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.getReference( Customer.class, 1L );
entityManager.remove( customer );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">delete
from
    Customer
where
    id = ?

-- binding parameter [1] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [3]
-- binding parameter [2] as [BIGINT]    - [1500906092876]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [2]
-- binding parameter [2] as [TIMESTAMP] - [null]
-- binding parameter [3] as [VARCHAR]   - [null]
-- binding parameter [4] as [VARCHAR]   - [null]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [3]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>REVTYPE</code>列值取自<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/envers/RevisionType.html"><code>RevisionType</code></a>枚举</p>
</div>
<table id="envers-revtype-column" class="tableblock frame-all grid-all spread">
<caption class="title">表11。 <code>REVTYPE</code>列值</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:60%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据库列值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">关联的<code>RevisionType</code>枚举值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">插入了数据库表行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MOD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据库表行已更新。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据库表行已删除。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用以下命令访问实体的审计（历史记录） <code>AuditReader</code>界面，可以通过打开<code>EntityManager</code>要么<code>Session</code>通过<code>AuditReaderFactory</code> 。</p>
</div>
<div id="envers-audited-revisions-example" class="exampleblock">
<div class="title">示例654。获取修订的列表<code>Customer</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Number&gt; revisions = doInJPA( this::entityManagerFactory, entityManager -&gt; {
	 return AuditReaderFactory.get( entityManager ).getRevisions(
		Customer.class,
		1L
	);
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.REV as col_0_0_
from
    Customer_AUD c
cross join
    REVINFO r
where
    c.id = ?
    and c.REV = r.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用之前获取的修订，我们现在可以检查<code>Customer</code>特定版本的实体：</p>
</div>
<div id="envers-audited-rev1-example" class="exampleblock">
<div class="title">示例655获得第一个修订版<code>Customer</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 0 ) )
.getSingleResult();

assertEquals("Doe", customer.getLastName());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_1_,
    c.REV as REV2_1_,
    c.REVTYPE as REVTYPE3_1_,
    c.created_on as created_4_1_,
    c.firstName as firstNam5_1_,
    c.lastName as lastName6_1_
from
    Customer_AUD c
where
    c.REV = (
        select
            max( c_max.REV )
        from
            Customer_AUD c_max
        where
            c_max.REV &lt;= ?
            and c.id = c_max.id
    )
    and c.REVTYPE &lt;&gt; ?

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行上述SQL查询时，有两个参数：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">版本号</dt>
<dd>
<p>第一个参数标记我们感兴趣的修订版本号，或者标记直到该特定修订版本为止的最新版本。</p>
</dd>
<dt class="hdlist1">version_type</dt>
<dd>
<p>第二个参数指定我们不感兴趣<code>DEL</code><code>RevisionType</code>以便删除删除的条目。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>与版本关联的第二个修订版也是如此<code>UPDATE</code>声明。</p>
</div>
<div id="envers-audited-rev2-example" class="exampleblock">
<div class="title">示例656。获得第二版<code>Customer</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 1 ) )
.getSingleResult();

assertEquals("Doe Jr.", customer.getLastName());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于已删除的实体修订，Envers会引发一个<code>NoResultException</code>因为该实体在该修订版中不再有效。</p>
</div>
<div id="envers-audited-rev3-example" class="exampleblock">
<div class="title">示例657。获得第三版<code>Customer</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try {
	Customer customer = (Customer) AuditReaderFactory
	.get( entityManager )
	.createQuery()
	.forEntitiesAtRevision( Customer.class, revisions.get( 2 ) )
	.getSingleResult();

	fail("The Customer was deleted at this revision: " + revisions.get( 2 ));
}
catch (NoResultException expected) {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/envers/query/AuditQueryCreator.html#forEntitiesAtRevision-java.lang.Class-java.lang.String-java.lang.Number-boolean-"><code>forEntitiesAtRevision(Class<T> cls, String entityName, Number revision, boolean includeDeletions)</code></a>获取已删除的实体修订的方法，以便代替<code>NoResultException</code> ，除实体标识符外的所有属性都将是<code>null</code> 。</p>
</div>
<div id="envers-audited-rev4-example" class="exampleblock">
<div class="title">示例658获得第三版<code>Customer</code>没有得到一个实体<code>NoResultException</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision(
	Customer.class,
	Customer.class.getName(),
	revisions.get( 2 ),
	true )
.getSingleResult();

assertEquals( Long.valueOf( 1L ), customer.getId() );
assertNull( customer.getFirstName() );
assertNull( customer.getLastName() );
assertNull( customer.getCreatedOn() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关提供的其他功能的详细信息，请参见<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/envers/AuditReader.html">Javadocs</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-configuration"><a class="anchor" href="#envers-configuration"></a> 21.2。配置属性</h3>
<div class="paragraph">
<p>可以配置Hibernate Envers行为的各个方面，例如表名等。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_table_prefix</strong></code></dt>
<dd>
<p>字符串，将在被审核实体的名称之前添加以创建实体名称，并将包含审核信息。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_table_suffix</strong></code> （默认： <code>_AUD</code> ）</dt>
<dd>
<p>字符串，该字符串将附加到被审核实体的名称上以创建实体名称，并将包含审核信息。</p>
<div class="paragraph">
<p>如果您审核表名称为Person的实体，则默认情况下，Envers会生成一个<code>Person_AUD</code>表以存储历史数据。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_field_name</strong></code> （默认： <code>REV</code> ）</dt>
<dd>
<p>审核实体中将保留修订号的字段名称。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_type_field_name</strong></code> （默认： <code>REVTYPE</code> ）</dt>
<dd>
<p>审核实体中将保留修订类型的字段名称（当前可以是： <code>add</code> ， <code>mod</code> ， <code>del</code> ）。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_on_collection_change</strong></code> （默认： <code>true</code> ）</dt>
<dd>
<p>当非所有关系字段发生更改时是否应生成修订（这可以是一对多关系中的集合，也可以是使用<code>mappedBy</code>一对一关系中的属性）。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.do_not_audit_optimistic_locking_field</strong></code> （默认： <code>true</code> ）</dt>
<dd>
<p>为true时，用于乐观锁定的属性带有注释<code>@Version</code> ，不会被自动审核（其历史记录将不会被存储；通常，将其存储起来是没有意义的）。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.store_data_at_delete</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>删除实体时，应将实体数据存储在修订版中（而不是仅将id和所有其他属性存储为null）。</p>
<div class="paragraph">
<p>通常不需要这样做，因为数据存在于上一个修订版本中。但是，有时在上一个修订版中访问它会更容易，更有效（然后，删除之前包含的实体的数据将存储两次）。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.default_schema</strong></code> （默认： <code>null</code> -与要审核的表相同的架构）</dt>
<dd>
<p>应用于审核表的默认架构名称。</p>
<div class="paragraph">
<p>可以使用<code>@AuditTable( schema="…​" )</code>注解。</p>
</div>
<div class="paragraph">
<p>如果不存在，则该架构将与被审核表的架构相同。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.default_catalog</strong></code> （默认： <code>null</code> -与要审核的表相同的目录）</dt>
<dd>
<p>审计表应使用的默认目录名称。</p>
<div class="paragraph">
<p>可以使用<code>@AuditTable( catalog="…​" )</code>注解。</p>
</div>
<div class="paragraph">
<p>如果不存在，则目录将与普通表的目录相同。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy</strong></code> （默认： <code>org.hibernate.envers.strategy.DefaultAuditStrategy</code> ）</dt>
<dd>
<p>保留审核数据时应使用的审核策略。缺省值仅存储修改实体的修订版本。</p>
<div class="paragraph">
<p>另一种选择<code>org.hibernate.envers.strategy.ValidityAuditStrategy</code>存储开始修订和结束修订。这些共同定义了审核行何时有效，因此命名为ValidityAuditStrategy。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</strong></code> （默认： <code>REVEND</code> ）</dt>
<dd>
<p>将在审核实体中保存最终修订版本号的列名称。仅当使用有效性审核策略时，此属性才有效。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>除了最终修订本身之外，是否还应存储最终修订的时间戳，直到该数据有效为止。这对于通过使用表分区从关系数据库中清除旧的Audit记录很有用。</p>
<div class="paragraph">
<p>分区需要表中存在一列。仅在以下情况下评估此属性： <code>ValidityAuditStrategy</code>用来。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</strong></code> （默认： <code>REVEND_TSTMP</code> ）</dt>
<dd>
<p>数据有效之前的最终修订的时间戳的列名。仅在<code>ValidityAuditStrategy</code>被使用，并且<code>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code>评估为真</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.use_revision_entity_with_native_id</strong></code> （默认： <code>true</code> ）</dt>
<dd>
<p>布尔值标志，用于确定修订号生成策略。修订版实体的默认实现使用本机标识符生成器。</p>
<div class="paragraph">
<p>如果当前数据库引擎不支持标识列，建议用户将此属性设置为false。</p>
</div>
<div class="paragraph">
<p>在这种情况下，修订号是通过预配置创建的<code>org.hibernate.id.enhanced.SequenceStyleGenerator</code> 。看到： <code>org.hibernate.envers.DefaultRevisionEntity</code>和<code>org.hibernate.envers.enhanced.SequenceIdRevisionEntity</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.track_entities_changed_in_revision</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>应该跟踪在每个修订版中已修改的实体类型。默认实现创建<code>REVCHANGES</code>存储已修改的持久对象的实体名称的表。单个记录封装了修订标识符（外键<code>REVINFO</code>表）和一个字符串值。有关更多信息，请参阅<a href="#envers-tracking-modified-entities-revchanges">跟踪修订期间修改的实体名称</a>和<a href="#envers-tracking-modified-entities-queries">查询在给定修订中修改的实体类型</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.global_with_modified_flag</strong></code> （默认： <code>false</code> ，可以单独覆盖<code>@Audited( withModifiedFlag=true )</code> ）</dt>
<dd>
<p>是否应为所有审核实体和所有属性存储属性修改标志。</p>
<div class="paragraph">
<p>设置为true时，对于所有属性，将在审核表中创建一个附加的布尔列，并在给定版本中更改给定属性时填充信息。</p>
</div>
<div class="paragraph">
<p>设置为false时，可以使用将该列添加到选定的实体或属性<code>@Audited</code>注解。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="#envers-tracking-properties-changes">在属性级别跟踪实体更改</a>和<a href="#envers-tracking-properties-changes-queries">查询修改了给定属性的实体修订</a> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.modified_flag_suffix</strong></code> （默认： <code>_MOD</code> ）</dt>
<dd>
<p>存储“ Modified Flags”的列的后缀。</p>
<div class="paragraph">
<p>例如，默认情况下，名为“ age”的属性将获得列名为“ age_MOD”的修改标志。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.modified_column_naming_strategy</strong></code> （默认： <code>org.hibernate.envers.boot.internal.LegacyModifiedColumnNamingStrategy</code> ）</dt>
<dd>
<p>用于审核元数据中的已修改标志列的命名策略。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.embeddable_set_ordinal_field_name</strong></code> （默认： <code>SETORDINAL</code> ）</dt>
<dd>
<p>用于存储可嵌入元素集中的更改顺序的列的名称。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.cascade_delete_revision</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>删除修订条目时，请删除关联的审核实体的数据。需要数据库支持才能删除级联行。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.allow_identifier_reuse</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>当应用程序重用已删除实体的标识符时，保证适当的有效性审计策略行为。正好与<code>null</code>每个标识符都有结束日期。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.original_id_prop_name</strong></code> （默认： <code>originalId</code> ）</dt>
<dd>
<p>指定审核表映射使用的Composite-id键属性名称。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.find_by_revision_exact_match</strong></code> （默认： <code>false</code> ）</dt>
<dd>
<p>指定是否<code>AuditReader#find</code>接受修订号参数的方法是根据模糊匹配或完全匹配行为查找结果。</p>
<div class="paragraph">
<p>旧的（旧式）行为一直是执行模糊匹配，如果主键存在任何修订版本且修订号小于或等于修订方法参数，则这些方法将返回匹配项。当您要基于另一个实体的修订号查找不相关实体的快照时，此行为很好。</p>
</div>
<div class="paragraph">
<p>启用此选项后，新的（可选）行为会强制查询执行完全匹配。为了使这些方法返回非<code>null</code>值，对于具有指定主键和修订号的实体，必须存在修订条目；否则结果将是<code>null</code> 。</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最近添加了以下配置选项，应将其视为实验性的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>org.hibernate.envers.track_entities_changed_in_revision</code></p>
</li>
<li>
<p><code>org.hibernate.envers.using_modified_flag</code></p>
</li>
<li>
<p><code>org.hibernate.envers.modified_flag_suffix</code></p>
</li>
<li>
<p><code>org.hibernate.envers.modified_column_naming_strategy</code></p>
</li>
<li>
<p><code>org.hibernate.envers.original_id_prop_name</code></p>
</li>
<li>
<p><code>org.hibernate.envers.find_by_revision_exact_match</code></p>
</li>
</ol>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="envers-additional-mappings"><a class="anchor" href="#envers-additional-mappings"></a> 21.3。其他映射注释</h3>
<div class="paragraph">
<p>审核表的名称可以使用<code>@AuditTable</code>注解。将此注释添加到每个审核的实体可能很乏味，因此，如果可能的话，最好使用前缀/后缀。</p>
</div>
<div class="paragraph">
<p>如果您具有包含辅助表的映射，则将以相同的方式（通过添加前缀和后缀）为它们生成审核表。如果您希望覆盖此行为，则可以使用<code>@SecondaryAuditTable</code>和<code>@SecondaryAuditTables</code>注释。</p>
</div>
<div class="paragraph">
<p>如果您想覆盖从中继承的某些字段/属性的审核行为<code>@MappedSuperclass</code>或在嵌入式组件中，您可以应用<code>@AuditOverride</code>组件的子类型或使用位置上的注释。</p>
</div>
<div class="paragraph">
<p>如果您要审核映射到的关系<code>@OneToMany</code>和<code>@JoinColumn</code> ，请参阅“ <a href="#envers-mappingexceptions">映射例外”</a>以获取其他说明<code>@AuditJoinTable</code>您可能要使用的注释。</p>
</div>
<div class="paragraph">
<p>如果您要审核一个关系，在该关系中不审核目标实体（例如，像字典一样的实体就是这种情况，它们不会更改，也不必审核），只需使用以下注释即可<code>@Audited( targetAuditMode = RelationTargetAuditMode.NOT_AUDITED )</code> 。然后，在读取您实体的历史版本时，该关系将始终指向与“当前”相关的实体。默认情况下，Envers引发<code>javax.persistence.EntityNotFoundException</code>当数据库中不存在“当前”实体时。应用<code>@NotFound( action = NotFoundAction.IGNORE )</code>注释使异常静音并分配空值。因此，解决方案导致隐式渴望加载一对一关系。</p>
</div>
<div class="paragraph">
<p>如果您想审核未明确审核的实体超类的属性（它们没有<code>@Audited</code>在任何属性或类上的注释），您可以设置<code>@AuditOverride( forClass = SomeEntity.class, isAudited = true/false )</code>注解。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@Audited</code>注释还具有一个<code>auditParents</code>属性，但现在不赞成使用<code>@AuditOverride</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="envers-audit-strategy"><a class="anchor" href="#envers-audit-strategy"></a> 21.4。选择审核策略</h3>
<div class="paragraph">
<p>完成基本配置后，重要的是选择将用于保留和检索审核信息的审核策略。在持久性能和查询审计信息的性能之间需要权衡。当前，有两种审计策略。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>默认审核策略将审核数据与开始修订版一起保留。对于在审计表中插入，更新或删除的每一行，将在审计表中插入一行或多行，以及其有效性的开始修订。插入后，审计表中的行永远不会更新。审核信息查询使用子查询来选择审核表中的适用行。</p>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">众所周知，这些子查询很慢并且很难索引。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>替代方法是有效性审核策略。此策略存储审核信息的开始修订和结束修订。对于在审计表中插入，更新或删除的每一行，将在审计表中插入一行或多行，以及其有效性的开始修订。但是同时，之前审核行的结束修订字段（如果可用）设置为此修订。然后，对审核信息的查询可以使用“开始和结束修订之间”，而不是默认审核策略所使用的子查询。</p>
<div class="paragraph">
<p>此策略的结果是，由于涉及额外的更新，因此保留审核信息的速度会稍微慢一些，但是检索审核信息的速度会快很多。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">可以通过添加额外的索引来进一步改善。
</td>
</tr>
</tbody></table>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="envers-audit-ValidityAuditStrategy"><a class="anchor" href="#envers-audit-ValidityAuditStrategy"></a> 21.4.1。配置<code>ValidityAuditStrategy</code></h4>
<div class="paragraph">
<p>为了更好地可视化<code>ValidityAuditStrategy</code> ，请考虑以下练习，在该练习中，我们将为<code>Customer</code>实体。</p>
</div>
<div class="paragraph">
<p>首先，您需要配置<code>ValidityAuditStrategy</code> ：</p>
</div>
<div id="envers-audited-validity-configuration-example" class="exampleblock">
<div class="title">示例659。配置<code>ValidityAuditStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">options.put(
	EnversSettings.AUDIT_STRATEGY,
	ValidityAuditStrategy.class.getName()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是<code>persistence.xml</code>配置文件，则映射将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="org.hibernate.envers.audit_strategy"
    value="org.hibernate.envers.strategy.ValidityAuditStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置完<code>ValidityAuditStrategy</code> ，以下架构将自动生成：</p>
</div>
<div id="envers-audited-validity-mapping-example" class="exampleblock">
<div class="title">示例660启用<code>ValidityAuditStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id)
)

create table Customer_AUD (
   id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Customer_AUD
    add constraint FK5ecvi1a0ykunrriib7j28vpdj
    foreign key (REV)
    references REVINFO

alter table Customer_AUD
    add constraint FKqd4fy7ww1yy95wi4wtaonre3f
    foreign key (REVEND)
    references REVINFO</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见， <code>REVEND</code>列及其外键添加到了<code>REVINFO</code>表。</p>
</div>
<div class="paragraph">
<p>重新运行上一个<code>Customer</code>审核日志查询<code>ValidityAuditStrategy</code> ，我们得到以下结果：</p>
</div>
<div id="envers-audited-validity-rev1-example" class="exampleblock">
<div class="title">示例661获得第一个修订版<code>Customer</code>实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_1_,
    c.REV as REV2_1_,
    c.REVTYPE as REVTYPE3_1_,
    c.REVEND as REVEND4_1_,
    c.created_on as created_5_1_,
    c.firstName as firstNam6_1_,
    c.lastName as lastName7_1_
from
    Customer_AUD c
where
    c.REV &lt;= ?
    and c.REVTYPE &lt;&gt; ?
    and (
        c.REVEND &gt; ?
        or c.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与默认策略相比， <code>ValidityAuditStrategy</code>生成更简单的查询，这些查询可以呈现更好的SQL执行计划。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-revisionlog"><a class="anchor" href="#envers-revisionlog"></a> 21.5。修订日志</h3>
<div class="paragraph">
<p>当Envers启动新修订时，它将创建一个新修订实体，该实体存储有关修订的信息。</p>
</div>
<div class="paragraph">
<p>默认情况下，仅包括：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">修订号</dt>
<dd>
<p>整数值（ <code>int/Integer</code>要么<code>long/Long</code> ）。本质上，修订的主键</p>
</dd>
<dt class="hdlist1">修订时间戳</dt>
<dd>
<p>要么<code>long/Long</code>要么<code>java.util.Date</code>表示进行修订的瞬间的值。当使用<code>java.util.Date</code> ， 代替<code>long/Long</code>对于修订时间戳，请注意不要将其存储到会损失精度的列数据类型中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Envers将此信息作为实体处理。默认情况下，它使用自己的内部类作为实体，映射到<code>REVINFO</code>表。但是，您可以提供自己的方法来收集此信息，这可能有助于捕获其他详细信息，例如谁进行了更改或发出请求的IP地址。要完成这项工作，需要做两件事：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>首先，您需要将要使用的实体告诉Envers。您的实体必须使用<code>@org.hibernate.envers.RevisionEntity</code>注解。它必须定义上述两个属性，并用注释<code>@org.hibernate.envers.RevisionNumber</code>和<code>@org.hibernate.envers.RevisionTimestamp</code> ， 分别。您可以从<code>org.hibernate.envers.DefaultRevisionEntity</code> （如果愿意）继承所有这些必需的行为。</p>
<div class="paragraph">
<p>只需像常规实体那样添加自定义修订版实体，Envers就会<strong>找到它</strong> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">多个实体标记为<code>@org.hibernate.envers.RevisionEntity</code>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>其次，您需要告诉Envers如何创建修订实体的实例，该实例由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/envers/RevisionListener.html#newRevision-java.lang.Object-"><code>newRevision( Object revisionEntity )</code></a>的方法<code>org.hibernate.envers.RevisionListener</code>接口。</p>
<div class="paragraph">
<p>您告诉Envers您的习惯<code>org.hibernate.envers.RevisionListener</code>通过在上指定它来使用的实现<code>@org.hibernate.envers.RevisionEntity</code>注释，使用value属性。如果你的<code>RevisionListener</code>从以下位置无法访问该课程<code>@RevisionEntity</code> （例如，它存在于其他模块中），设置<code>org.hibernate.envers.revision_listener</code>属性为其完全限定的类名。配置参数定义的类名将覆盖修订实体的value属性。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>考虑到我们有一个<code>CurrentUser</code>存储当前登录用户的实用程序：</p>
</div>
<div id="envers-revisionlog-CurrentUser-example" class="exampleblock">
<div class="title">范例662。 <code>CurrentUser</code>效用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CurrentUser {

	public static final CurrentUser INSTANCE = new CurrentUser();

	private static final ThreadLocal&lt;String&gt; storage = new ThreadLocal&lt;&gt;();

	public void logIn(String user) {
		storage.set( user );
	}

	public void logOut() {
		storage.remove();
	}

	public String get() {
		return storage.get();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们需要提供一个自定义<code>@RevisionEntity</code>存储当前登录的用户</p>
</div>
<div id="envers-revisionlog-RevisionEntity-example" class="exampleblock">
<div class="title">示例663。自订<code>@RevisionEntity</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomRevisionEntity")
@Table(name = "CUSTOM_REV_INFO")
@RevisionEntity( CustomRevisionEntityListener.class )
public static class CustomRevisionEntity extends DefaultRevisionEntity {

	private String username;

	public String getUsername() {
		return username;
	}

	public void setUsername( String username ) {
		this.username = username;
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与风俗<code>RevisionEntity</code>实施到位，我们只需要提供<code>RevisionEntity</code>作为工厂的实现<code>RevisionEntity</code>实例。</p>
</div>
<div id="envers-revisionlog-RevisionListener-example" class="exampleblock">
<div class="title">示例664。自订<code>@RevisionListener</code>例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomRevisionEntityListener implements RevisionListener {

	public void newRevision( Object revisionEntity ) {
		CustomRevisionEntity customRevisionEntity =
			( CustomRevisionEntity ) revisionEntity;

		customRevisionEntity.setUsername(
			CurrentUser.INSTANCE.get()
		);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生成数据库架构时，Envers创建以下内容<code>RevisionEntity</code>表：</p>
</div>
<div id="envers-revisionlog-custom-revision-entity-table-example" class="exampleblock">
<div class="title">实施例665。自动产生<code>RevisionEntity</code>转换表</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table CUSTOM_REV_INFO (
    id integer not null,
    timestamp bigint not null,
    username varchar(255),
    primary key (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以看到<code>username</code>列就位。</p>
</div>
<div class="paragraph">
<p>现在，当插入一个<code>Customer</code>实体，Envers生成以下语句：</p>
</div>
<div id="envers-revisionlog-RevisionEntity-persist-example" class="exampleblock">
<div class="title">示例666使用自定义审核<code>@RevisionEntity</code>实例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CurrentUser.INSTANCE.logIn( "Vlad Mihalcea" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
	Customer customer = new Customer();
	customer.setId( 1L );
	customer.setFirstName( "John" );
	customer.setLastName( "Doe" );

	entityManager.persist( customer );
} );

CurrentUser.INSTANCE.logOut();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Customer
    (created_on, firstName, lastName, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [Thu Jul 27 15:45:00 EEST 2017]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    CUSTOM_REV_INFO
    (timestamp, username, id)
values
    (?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1501159500888]
-- binding parameter [2] as [VARCHAR] - [Vlad Mihalcea]
-- binding parameter [3] as [INTEGER] - [1]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [0]
-- binding parameter [2] as [TIMESTAMP] - [Thu Jul 27 15:45:00 EEST 2017]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上面的示例所示，用户名已正确设置并传播到<code>CUSTOM_REV_INFO</code>表。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>从5.2版开始不推荐使用此策略。替代方法是使用版本5.3提供的依赖项注入。</strong></p>
</div>
<div class="paragraph">
<p>另一种使用<code>org.hibernate.envers.RevisionListener</code>而是打电话给<span class="line-through"><a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/envers/AuditReader.html#getCurrentRevision-java.lang.Class-boolean-"><code>getCurrentRevision( Class<T> revisionEntityClass, boolean persist )</code></a></span>的方法<code>org.hibernate.envers.AuditReader</code>界面以获取当前修订，并在其中填充所需的信息。</p>
</div>
<div class="paragraph">
<p>该方法接受<code>persist</code>指示在从此方法返回之前是否应保留修订实体的参数：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>确保返回的实体可以访问其标识符值（修订号），但是修订实体将保持不变，无论是否有任何审核的实体发生更改。</p>
</dd>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>表示修订号为<code>null</code> ，但修订实体将仅在某些已审计实体已更改的情况下保留。</p>
</dd>
</dl>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Hibernate Envers 5.3起，现在支持依赖注入<code>RevisionListener</code> 。</p>
</div>
<div class="paragraph">
<p>此功能取决于各种依赖项框架（例如CDI和Spring），以便在Hibernate ORM引导期间提供必要的实现以支持注入。如果未提供合格实施，则<code>RevisionListener</code>无需注射即可建造。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-modified-entities-revchanges"><a class="anchor" href="#envers-tracking-modified-entities-revchanges"></a> 21.6。修订期间修改的跟踪实体名称</h3>
<div class="paragraph">
<p>默认情况下，不会跟踪在每个修订版中已更改的实体类型。这意味着有必要查询存储审计数据的所有表，以检索在指定修订期间所做的更改。Envers提供了一种简单的机制来创建<code>REVCHANGES</code>该表存储已修改的持久对象的实体名称。单个记录封装了修订标识符（外键<code>REVINFO</code>表）和一个字符串值。</p>
</div>
<div class="paragraph">
<p>可以通过三种不同方式启用对已修改实体名称的跟踪：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>组<code>org.hibernate.envers.track_entities_changed_in_revision</code>参数<code>true</code> 。在这种情况下<code>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code>将隐式用作修订日志实体。</p>
</li>
<li>
<p>创建一个扩展的自定义修订版实体<code>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code>类。</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity
public static class CustomTrackingRevisionEntity
	extends DefaultTrackingModifiedEntitiesRevisionEntity {

}</code></pre>
</div>
</div>
</li>
<li>
<p>使用以下命令标记自定义修订实体的适当字段<code>@org.hibernate.envers.ModifiedEntityNames</code>注解。该财产必须是<code>Set<String></code>类型。</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity
public static class CustomTrackingRevisionEntity extends DefaultRevisionEntity {

    @ElementCollection
    @JoinTable(
        name = "REVCHANGES",
        joinColumns = @JoinColumn( name = "REV" )
    )
    @Column( name = "ENTITYNAME" )
    @ModifiedEntityNames
    private Set&lt;String&gt; modifiedEntityNames = new HashSet&lt;&gt;();

    public Set&lt;String&gt; getModifiedEntityNames() {
        return modifiedEntityNames;
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>考虑到我们有一个<code>Customer</code>实体由以下示例说明：</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-before-rename-example" class="exampleblock">
<div class="title">示例667 <code>Customer</code>重命名之前的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果<code>Customer</code>实体类名称更改为<code>ApplicationCustomer</code> ，Envers将会在<code>REVCHANGES</code>具有先前实体类名称的表：</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-after-rename-example" class="exampleblock">
<div class="title">实施例668。 <code>Customer</code>重命名后的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class ApplicationCustomer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    REVCHANGES
    (REV, ENTITYNAME)
values
    (?, ?)

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [VARCHAR] - [org.hibernate.userguide.envers.EntityTypeChangeAuditTest$Customer]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>选择了上面列出的方法之一的用户可以利用<a href="#envers-tracking-modified-entities-queries">查询在给定版本中修改的实体类型中所述的</a> API来检索在指定版本中修改的所有实体。</p>
</div>
<div class="paragraph">
<p>还允许用户实施跟踪已修改实体类型的自定义机制。在这种情况下，他们应通过自己的实现<code>org.hibernate.envers.EntityTrackingRevisionListener</code>接口作为的值<code>@org.hibernate.envers.RevisionEntity</code>注解。</p>
</div>
<div class="paragraph">
<p><code>EntityTrackingRevisionListener</code>接口公开了一种方法，该方法会在当前版本边界内添加，修改或删除受审核实体实例时进行通知。</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-EntityTrackingRevisionListener-example" class="exampleblock">
<div class="title">示例669。的<code>EntityTrackingRevisionListener</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomTrackingRevisionListener implements EntityTrackingRevisionListener {

	@Override
	public void entityChanged(Class entityClass,
							  String entityName,
							  Serializable entityId,
							  RevisionType revisionType,
							  Object revisionEntity ) {
		String type = entityClass.getName();
		( (CustomTrackingRevisionEntity) revisionEntity ).addModifiedEntityType( type );
	}

	@Override
	public void newRevision( Object revisionEntity ) {
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>CustomTrackingRevisionListener</code>将完全限定的类名称添加到<code>modifiedEntityTypes</code>的属性<code>CustomTrackingRevisionEntity</code> 。</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-RevisionEntity-example" class="exampleblock">
<div class="title">示例670的<code>RevisionEntity</code>使用自定义<code>EntityTrackingRevisionListener</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity( CustomTrackingRevisionListener.class )
public static class CustomTrackingRevisionEntity {

	@Id
	@GeneratedValue
	@RevisionNumber
	private int customId;

	@RevisionTimestamp
	private long customTimestamp;

	@OneToMany(
		mappedBy="revision",
		cascade={
			CascadeType.PERSIST,
			CascadeType.REMOVE
		}
	)
	private Set&lt;EntityType&gt; modifiedEntityTypes = new HashSet&lt;&gt;();

	public Set&lt;EntityType&gt; getModifiedEntityTypes() {
		return modifiedEntityTypes;
	}

	public void addModifiedEntityType(String entityClassName ) {
		modifiedEntityTypes.add( new EntityType( this, entityClassName ) );
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>CustomTrackingRevisionEntity</code>包含一个<code>@OneToMany</code>列表<code>ModifiedTypeRevisionEntity</code></p>
</div>
<div id="envers-tracking-modified-entities-revchanges-EntityType-example" class="exampleblock">
<div class="title">示例671的<code>EntityType</code>在类名称修改之前封装实体类型名称</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "EntityType")
public static class EntityType {

	@Id
	@GeneratedValue
	private Integer id;

	@ManyToOne
	private CustomTrackingRevisionEntity revision;

	private String entityClassName;

	private EntityType() {
	}

	public EntityType(CustomTrackingRevisionEntity revision, String entityClassName) {
		this.revision = revision;
		this.entityClassName = entityClassName;
	}

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，当获取<code>CustomTrackingRevisionEntity</code> ，您可以访问以前的实体类名称。</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-query-example" class="exampleblock">
<div class="title">示例672得到<code>EntityType</code>通过<code>CustomTrackingRevisionEntity</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditReader auditReader = AuditReaderFactory.get( entityManager );

List&lt;Number&gt; revisions = auditReader.getRevisions(
	ApplicationCustomer.class,
	1L
);

CustomTrackingRevisionEntity revEntity = auditReader.findRevision(
	CustomTrackingRevisionEntity.class,
	revisions.get( 0 )
);

Set&lt;EntityType&gt; modifiedEntityTypes = revEntity.getModifiedEntityTypes();
assertEquals( 1, modifiedEntityTypes.size() );

EntityType entityType = modifiedEntityTypes.iterator().next();
assertEquals(
	Customer.class.getName(),
	entityType.getEntityClassName()
);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-properties-changes"><a class="anchor" href="#envers-tracking-properties-changes"></a> 21.7。在属性级别跟踪实体更改</h3>
<div class="paragraph">
<p>默认情况下，Envers存储的唯一信息是已修改实体的修订版。通过这种方法，用户可以基于实体属性的历史值创建审核查询。有时，当您还对更改类型（不仅是结果值）感兴趣时，为每个修订存储其他元数据很有用。</p>
</div>
<div class="paragraph">
<p><a href="#envers-tracking-modified-entities-revchanges">跟踪修订期间修改的实体名称中</a>描述的功能使您可以知道在给定修订中修改了哪些实体。</p>
</div>
<div class="paragraph">
<p>此处描述的功能使它更进一步。
<em>修改标志</em>使Envers能够跟踪在给定的修订中哪些审计实体的属性被修改。</p>
</div>
<div class="paragraph">
<p>可以通过以下方式启用在属性级别的跟踪实体更改：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>设置<code>org.hibernate.envers.global_with_modified_flag</code>配置属性为<code>true</code> 。此全局开关将导致为所有审核实体的所有审核属性存储添加修改标记。</p>
</li>
<li>
<p>使用<code>@Audited( withModifiedFlag=true )</code>在财产或实体上。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>与此功能相关的权衡是增加了审计表的大小，并且在审计写入过程中性能下降很少，几乎可以忽略不计。这是由于以下事实：每个跟踪的属性都必须在架构中具有一个随附的布尔列，该布尔列用于存储有关属性修改的信息。当然，相应地填写这些列是Enver的工作-无需开发人员进行其他工作。由于提到的成本，建议在需要时使用上述粒度配置工具有选择地启用该功能。</p>
</div>
<div id="envers-tracking-properties-changes-mapping-example" class="exampleblock">
<div class="title">示例673映射以在属性级别跟踪实体更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited(withModifiedFlag = true)
@Entity(name = "Customer")
public static class Customer {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	@Temporal( TemporalType.TIMESTAMP )
	@Column(name = "created_on")
	@CreationTimestamp
	private Date createdOn;

	//Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    created_on timestamp,
    createdOn_MOD boolean,
    firstName varchar(255),
    firstName_MOD boolean,
    lastName varchar(255),
    lastName_MOD boolean,
    primary key (id, REV)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，每个属性都有一个<code>_MOD</code>列（例如<code>createdOn_MOD</code> ）在审核日志中。</p>
</div>
<div id="envers-tracking-properties-changes-example" class="exampleblock">
<div class="title">示例674在属性级别跟踪实体更改的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.find( Customer.class, 1L );
customer.setLastName( "Doe Jr." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update
    Customer
set
    created_on = ?,
    firstName = ?,
    lastName = ?
where
    id = ?

-- binding parameter [1] as [TIMESTAMP] - [2017-07-31 15:58:20.342]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (null, ?)

-- binding parameter [1] as [BIGINT] - [1501505900439]

insert
into
    Customer_AUD
    (REVTYPE, created_on, createdOn_MOD, firstName, firstName_MOD, lastName, lastName_MOD, id, REV)
values
    (?, ?, ?, ?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [1]
-- binding parameter [2] as [TIMESTAMP] - [2017-07-31 15:58:20.342]
-- binding parameter [3] as [BOOLEAN]   - [false]
-- binding parameter [4] as [VARCHAR]   - [John]
-- binding parameter [5] as [BOOLEAN]   - [false]
-- binding parameter [6] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [7] as [BOOLEAN]   - [true]
-- binding parameter [8] as [BIGINT]    - [1]
-- binding parameter [9] as [INTEGER]   - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要查看如何使用“修改的标志”，请查看使用它们的非常简单的查询API： <a href="#envers-tracking-properties-changes-queries">查询修改了给定属性的实体修订</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-properties-changes-strategy"><a class="anchor" href="#envers-tracking-properties-changes-strategy"></a> 21.8。选择策略以跟踪属性级别更改</h3>
<div class="paragraph">
<p>默认情况下，Envers使用<code>legacy</code>修改的列命名策略。此策略旨在根据以下规则集添加列：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果属性带有注释<code>@Audited</code>并且指定了<em>modifiedColumnName</em>属性，则该列将直接基于提供的名称。</p>
</li>
<li>
<p>如果属性未使用注释<code>@Audited</code>否则，如果没有给出<em>ModifyedColumnName</em>属性，则该列将以java类属性命名，并附加配置的后缀，默认为<code>_MOD</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>尽管此策略没有性能上的缺点，但确实给那些希望保持一致而不冗长的用户带来了困扰。让我们以以下实体映射为例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@Audited(withModifiedFlags = true)
@Entity
public class Customer {
  @Id
  private Integer id;
  @Column(name = "customer_name")
  private String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种映射实际上会导致列之间的命名不一致，请参见下文，了解如何将模型名称存储在<code>customer_name</code>但是跟踪该列是否在修订之间进行更改的已修改列被命名为<code>name_MOD</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>CREATE TABLE Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint not null,
    customer_name varchar(255),
    name_MOD boolean,
    primary key(id, REV)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种策略称为<code>improved</code>旨在解决这些一致的列命名问题。此策略使用以下规则集：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>属性是基本类型（单列值属性）</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>如果属性映射中提供了一个，则直接使用<em>modifiedColumnName</em></p>
</li>
<li>
<p>否则，请使用已解析的ORM列名，并附加修改后的标志后缀配置值。</p>
</li>
</ol>
</div>
</li>
<li>
<p>属性是使用单列与外键的关联（到一个映射）</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>如果属性映射中提供了一个，则直接使用<em>modifiedColumnName</em></p>
</li>
<li>
<p>否则，请使用已解析的ORM列名，并附加修改后的标志后缀配置值。</p>
</li>
</ol>
</div>
</li>
<li>
<p>属性是使用多列的外键的关联（到一个映射）</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>如果属性映射中提供了一个，则直接使用<em>modifiedColumnName</em></p>
</li>
<li>
<p>否则，请使用属性名称加上修改后的标志后缀配置值。</p>
</li>
</ol>
</div>
</li>
<li>
<p>财产是可嵌入的</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>如果属性映射中提供了一个，则直接使用<em>modifiedColumnName</em></p>
</li>
<li>
<p>否则，请使用属性名称加上修改后的标志后缀配置值。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用此策略时，相同<code>Customer</code>映射将生成以下表模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>CREATE TABLE Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint not null,
    customer_name varchar(255),
    customer_name_MOD boolean,
    primary key(id, REV)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当已经将Envers与已修改的列标志功能结合使用时，建议不要立即启用新策略，因为将需要更改架构。您将需要手动迁移现有模式以遵守上述规则，或者在服务器上使用显式的<em>ModifyColumnName</em>属性。 <code>@Audited</code>使用该功能的现有列的注释。</p>
</div>
<div class="paragraph">
<p>要配置自定义策略实施或使用改进的策略，请使用配置选项<code>org.hibernate.envers.modified_column_naming_strategy</code>将需要设置。此选项可以是<code>ModifiedColumnNameStrategy</code>实施或<code>legacy</code>要么<code>improved</code>对于两个提供的实现中的任何一个。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-queries"><a class="anchor" href="#envers-queries"></a> 21.9。查询</h3>
<div class="paragraph">
<p>您可以认为历史数据具有两个维度：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">水平的</dt>
<dd>
<p>给定版本的数据库状态。因此，您可以查询版本为N的实体。</p>
</dd>
<dt class="hdlist1">垂直</dt>
<dd>
<p>实体发生更改的修订。因此，您可以查询给定实体已更改的修订。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Envers中的查询与Hibernate Criteria查询类似，因此，如果您对它们熟悉，则使用Envers查询会容易得多。</p>
</div>
<div class="paragraph">
<p>当前查询实现的主要限制是您无法遍历关系。您只能在相关实体的ID上指定约束，并且只能在关系的“拥有”端指定约束。但是，在将来的版本中将对此进行更改。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在许多情况下，对审计数据的查询要比对“实时”数据的相应查询慢得多，因为，尤其是对于默认审计策略，它们涉及相关的子选择。</p>
</div>
<div class="paragraph">
<p>使用有效性审计策略时，查询在速度和可能性上都得到了改进，该策略存储实体的开始和结束修订。请参阅<a href="#envers-audit-ValidityAuditStrategy">配置<code>ValidityAuditStrategy</code></a>进行更详细的讨论。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="entities-at-revision"><a class="anchor" href="#entities-at-revision"></a> 21.10。在给定的版本中查询类的实体</h3>
<div class="paragraph">
<p>此类查询的入口点是：</p>
</div>
<div id="entities-at-revision-example" class="exampleblock">
<div class="title">示例675。得到<code>Customer</code>给定修订版的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 0 ) )
.getSingleResult();

assertEquals("Doe", customer.getLastName());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entities-filtering"><a class="anchor" href="#entities-filtering"></a> 21.11。使用过滤条件查询实体</h3>
<div class="paragraph">
<p>然后，您可以通过添加限制来指定约束，返回的实体应满足这些约束，可以使用<code>AuditEntity</code>工厂课。</p>
</div>
<div class="paragraph">
<p>例如，仅选择<code>firstName</code>属性等于“ John”：</p>
</div>
<div id="entities-filtering-example" class="exampleblock">
<div class="title">示例676得到<code>Customer</code>给定审计日志<code>firstName</code>属性值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.property( "firstName" ).eq( "John" ) )
.getResultList();

assertEquals(2, customers.size());
assertEquals( "Doe", customers.get( 0 ).getLastName() );
assertEquals( "Doe Jr.", customers.get( 1 ).getLastName() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>并且，要仅选择其关系与给定实体相关的实体，可以使用目标实体或其标识符。</p>
</div>
<div id="entities-filtering-by-entity-example" class="exampleblock">
<div class="title">示例677得到<code>Customer</code>其实体<code>address</code>属性匹配给定的实体引用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Address address = entityManager.getReference( Address.class, 1L );

List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.property( "address" ).eq( address ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id = ?
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使我们提供标识符而不是目标实体引用，也会生成相同的SQL。</p>
</div>
<div id="entities-filtering-by-entity-identifier-example" class="exampleblock">
<div class="title">示例678得到<code>Customer</code>其实体<code>address</code>标识符与给定的实体标识符匹配</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.relatedId( "address" ).eq( 1L ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了严格的相等匹配之外，您还可以使用<code>IN</code>子句以提供多个实体标识符：</p>
</div>
<div id="entities-in-clause-filtering-by-entity-identifier-example" class="exampleblock">
<div class="title">范例679。得到<code>Customer</code>其实体<code>address</code>标识符与给定实体标识符之一匹配</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.relatedId( "address" ).in( new Object[] { 1L, 2L } ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id in (
        ? , ?
    )
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]
-- binding parameter [2] as [BIGINT] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以限制结果的数量，对其进行排序，并以通常的方式设置汇总和预测（分组除外）。查询完成后，您可以通过调用<code>getSingleResult()</code>要么<code>getResultList()</code>方法。</p>
</div>
<div class="paragraph">
<p>一个完整的查询，可以看起来像这样：</p>
</div>
<div id="entities-filtering-and-pagination" class="exampleblock">
<div class="title">示例680得到<code>Customer</code>使用过滤和分页的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.addOrder( AuditEntity.property( "lastName" ).desc() )
.add( AuditEntity.relatedId( "address" ).eq( 1L ) )
.setFirstResult( 1 )
.setMaxResults( 2 )
.getResultList();

assertEquals(1, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id = ?
order by
    c.lastName desc
limit ?
offset ?</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="revisions-of-entity"><a class="anchor" href="#revisions-of-entity"></a> 21.12。查询修订，给定类的实体已更改</h3>
<div class="paragraph">
<p>此类查询的入口点是：</p>
</div>
<div id="revisions-of-entity-query-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery query = AuditReaderFactory.get( entityManager )
	.createQuery()
	.forRevisionsOfEntity( Customer.class, false, true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以按照与上一个查询相同的方式向该查询添加约束。</p>
</div>
<div class="paragraph">
<p>还有一些其他可能性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用<code>AuditEntity.revisionNumber()</code>您可以在修订号上指定约束，预测和顺序，在该修订号中修改了审核实体</p>
</li>
<li>
<p>类似地，使用<code>AuditEntity.revisionProperty( propertyName )</code>您可以在修订实体的属性上指定约束，投影和顺序，该属性对应于修改了审核实体的修订</p>
</li>
<li>
<p><code>AuditEntity.revisionType()</code>使您可以如上所述访问修订类型（ <code>ADD</code> ， <code>MOD</code> ， <code>DEL</code> ）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用这些方法，您可以按修订号对查询结果进行排序，将投影数设置为投影或将其限制为大于或小于指定值等。例如，以下查询将选择最小的修订号，在该实体上类<code>MyEntity</code>编号<code>entityId</code>在修订版本2之后已更改：</p>
</div>
<div id="revisions-of-entity-query-by-revision-number-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Number revision = (Number) AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.addProjection( AuditEntity.revisionNumber().min() )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.revisionNumber().gt( 2 ) )
.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在修订查询中使用的第二个附加功能是<em>最大化</em> / <em>最小化</em>属性的能力。</p>
</div>
<div class="paragraph">
<p>例如，如果您要选择最小的修订版本， <code>createdOn</code>属性大于给定值，则可以运行以下查询：</p>
</div>
<div id="revisions-of-entity-query-minimize-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Number revision = (Number) AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.addProjection( AuditEntity.revisionNumber().min() )
.add( AuditEntity.id().eq( 1L ) )
.add(
	AuditEntity.property( "createdOn" )
	.minimize()
	.add( AuditEntity.property( "createdOn" )
		.ge(
			Timestamp.from(
				LocalDateTime.now()
					.minusDays( 1 )
					.toInstant( ZoneOffset.UTC )
				)
		)
	)
)
.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>minimize()</code>和<code>maximize()</code>方法返回一个条件，可以向其中添加约束，具有<em>最大化</em> / <em>最小化</em>属性的实体必须满足这些条件。</p>
</div>
<div class="paragraph">
<p>您可能还注意到创建查询时传递了两个布尔参数。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>selectEntitiesOnly</code></dt>
<dd>
<p>第一个参数仅在未设置显式投影时才有效。</p>
<div class="paragraph">
<p>如果为true，则查询结果将为实体列表（在满足指定约束的修订版本中更改）。</p>
</div>
<div class="paragraph">
<p>如果为false，则结果将是三个元素数组的列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个元素将是更改后的实体实例。</p>
</li>
<li>
<p>第二个将是包含修订数据的实体（如果未使用自定义实体，则将是<code>DefaultRevisionEntity</code> ）。</p>
</li>
<li>
<p>第三个将是修订的类型（ <code>RevisionType</code>列举： <code>ADD</code> ， <code>MOD</code> ， <code>DEL</code> ）。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>selectDeletedEntities</code></dt>
<dd>
<p>第二个参数指定结果中是否应包含删除实体的修订。</p>
<div class="paragraph">
<p>如果是，则此类实体将具有修订版类型<code>DEL</code>和所有属性，除了<code>id</code> ，将设置为<code>null</code> 。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>另一个有用的功能是<code>AggregatedAuditExpression#computeAggregationInInstanceContext()</code> 。这可用于基于实体实例主键创建聚合查询。</p>
</div>
<div class="paragraph">
<p>例如，如果要查找所有客户，但只想检索具有最大修订号的实例，则可以使用以下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; results = AuditReaderFactory
	.get( entityManager )
	.createQuery()
	.forRevisionsOfEntity( Customer.class, true, false )
	.add( AuditEntity.revisionNumber().maximize().computeAggregationInInstanceContext() )
	.getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，结果集将包含<code>Customer</code>实例，每个主键一个。每个实例将以每个版本的<em>最大</em>修订号保存审核的属性数据<code>Customer</code>首要的关键。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-properties-changes-queries"><a class="anchor" href="#envers-tracking-properties-changes-queries"></a> 21.13。查询修改给定属性的实体修订</h3>
<div class="paragraph">
<p>对于上述两种查询，可以使用特殊查询<code>Audit</code>称为标准<code>hasChanged()</code>和<code>hasNotChanged()</code>利用<a href="#envers-tracking-properties-changes">属性级别的跟踪实体更改中</a>描述的功能。</p>
</div>
<div class="paragraph">
<p>让我们看一下可以从这两个条件中受益的各种查询。</p>
</div>
<div class="paragraph">
<p>首先，您必须确保您的实体可以跟踪<em>修改标志</em> ：</p>
</div>
<div id="envers-tracking-properties-changes-queries-entity-example" class="exampleblock">
<div class="title">示例681。仅当审核日志记录跟踪实体属性修改标志时才有效</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited( withModifiedFlag = true )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询将返回该版本的所有修订<code>Customer</code>给定的实体<code>id</code> ，为此<code>lastName</code>属性已更改。</p>
</div>
<div id="envers-tracking-properties-changes-queries-hasChanged-example" class="exampleblock">
<div class="title">示例682。得到所有<code>Customer</code>的修订<code>lastName</code>属性已更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_0_,
    c.REV as REV2_3_0_,
    defaultrev1_.REV as REV1_4_1_,
    c.REVTYPE as REVTYPE3_3_0_,
    c.REVEND as REVEND4_3_0_,
    c.created_on as created_5_3_0_,
    c.createdOn_MOD as createdO6_3_0_,
    c.firstName as firstNam7_3_0_,
    c.firstName_MOD as firstNam8_3_0_,
    c.lastName as lastName9_3_0_,
    c.lastName_MOD as lastNam10_3_0_,
    c.address_id as address11_3_0_,
    c.address_MOD as address12_3_0_,
    defaultrev1_.REVTSTMP as REVTSTMP2_4_1_
from
    Customer_AUD c cross
join
    REVINFO defaultrev1_
where
    c.id = ?
    and c.lastName_MOD = ?
    and c.REV=defaultrev1_.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [BOOLEAN] - [true]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此查询，我们将无法获得其中的所有其他修订<code>lastName</code>没有被感动。从SQL查询中，您可以看到<code>lastName_MOD</code> WHERE子句中使用了column，因此上述跟踪修改标志的要求。</p>
</div>
<div class="paragraph">
<p>当然，没有什么可以阻止用户合并<code>hasChanged</code>条件与一些其他条件。</p>
</div>
<div id="envers-tracking-properties-changes-queries-hasChanged-and-hasNotChanged-example" class="exampleblock">
<div class="title">示例683得到所有<code>Customer</code>的修订<code>lastName</code>属性已更改，并且<code>firstName</code>属性未更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.add( AuditEntity.property( "firstName" ).hasNotChanged() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_0_,
    c.REV as REV2_3_0_,
    defaultrev1_.REV as REV1_4_1_,
    c.REVTYPE as REVTYPE3_3_0_,
    c.REVEND as REVEND4_3_0_,
    c.created_on as created_5_3_0_,
    c.createdOn_MOD as createdO6_3_0_,
    c.firstName as firstNam7_3_0_,
    c.firstName_MOD as firstNam8_3_0_,
    c.lastName as lastName9_3_0_,
    c.lastName_MOD as lastNam10_3_0_,
    c.address_id as address11_3_0_,
    c.address_MOD as address12_3_0_,
    defaultrev1_.REVTSTMP as REVTSTMP2_4_1_
from
    Customer_AUD c cross
join
    REVINFO defaultrev1_
where
    c.id=?
    and c.lastName_MOD=?
    and c.firstName_MOD=?
    and c.REV=defaultrev1_.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [BOOLEAN] - [true]
-- binding parameter [3] as [BOOLEAN] - [false]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了得到<code>Customer</code>实体在给定时发生了变化<code>revisionNumber</code>与<code>lastName</code>修改并<code>firstName</code>保持不变，我们必须使用<code>forEntitiesModifiedAtRevision</code>查询：</p>
</div>
<div id="envers-tracking-properties-changes-queries-at-revision-example" class="exampleblock">
<div class="title">示例684。得到<code>Customer</code>给定修订的实体，如果<code>lastName</code>属性已更改，并且<code>firstName</code>属性未更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesModifiedAtRevision( Customer.class, 2 )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.add( AuditEntity.property( "firstName" ).hasNotChanged() )
.getSingleResult();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.createdOn_MOD as createdO6_3_,
    c.firstName as firstNam7_3_,
    c.firstName_MOD as firstNam8_3_,
    c.lastName as lastName9_3_,
    c.lastName_MOD as lastNam10_3_,
    c.address_id as address11_3_,
    c.address_MOD as address12_3_
from
    Customer_AUD c
where
    c.REV=?
    and c.id=?
    and c.lastName_MOD=?
    and c.firstName_MOD=?

-- binding parameter [1] as [INTEGER] - [2]
-- binding parameter [2] as [BIGINT]  - [1]
-- binding parameter [3] as [BOOLEAN] - [true]
-- binding parameter [4] as [BOOLEAN] - [false]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-obtain-properties-changed-queries"><a class="anchor" href="#envers-tracking-obtain-properties-changed-queries"></a> 21.14。查询实体的修订版，包括已修改的属性名称</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里描述的此功能仍被认为是实验性的。它会根据用户反馈在将来的发行版中进行更改，以提高其实用性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有时，查询实体修订版本并确定该修订版本的所有属性（而不必使用发出多个查询）可能会很有用<code>hasChanged()</code>和<code>hasNotChanged()</code>标准。</p>
</div>
<div class="paragraph">
<p>现在，您可以使用以下查询轻松获得此信息：</p>
</div>
<div class="exampleblock">
<div class="title">示例685查询实体修订，包括已修改的属性名称。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List results  = AuditReaderFactory.get( entityManager )
  .createQuery()
  .forRevisionsOfEntityWithChanges( Customer.class, false )
  .add( AuditEntity.id().eq( 1L ) )
  .getResultList();

for ( Object entry : results ) {
  final Object[] array = (Object[]) entry;
  final Set&lt;String&gt; propertiesChanged = (Set&lt;String&gt;) array[3];
  for ( String propertyName : propertiesChanged ) {
    /* Do something useful with the modified property `propertyName` */
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-modified-entities-queries"><a class="anchor" href="#envers-tracking-modified-entities-queries"></a> 21.15。查询在给定版本中修改的实体类型</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅当启用了跟踪更改的实体类型的默认机制（请参阅<a href="#envers-tracking-modified-entities-revchanges">修订版本中跟踪的实体名称</a> ）时，才可以使用下面描述的方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此基本查询允许检索在指定版本中更改的实体名称和相应的Java类：</p>
</div>
<div id="envers-tracking-modified-entities-queries-example" class="exampleblock">
<div class="title">示例686。检索指定版本中更改的实体名称和对应的Java类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertEquals(
    "org.hibernate.userguide.envers.EntityTypeChangeAuditTest$Customer",
    AuditReaderFactory
        .get( entityManager )
        .getCrossTypeRevisionChangesReader()
        .findEntityTypes( 1 )
        .iterator().next()
        .getFirst()
    );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertEquals(
    "org.hibernate.userguide.envers.EntityTypeChangeAuditTest$ApplicationCustomer",
    AuditReaderFactory
    .get( entityManager )
    .getCrossTypeRevisionChangesReader()
    .findEntityTypes( 2 )
    .iterator().next()
    .getFirst()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>其他查询（也可以从<code>org.hibernate.envers.CrossTypeRevisionChangesReader</code> ）：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>List<Object> findEntities( Number )</code></dt>
<dd>
<p>返回在给定版本中已更改（添加，更新和删除）的所有审核实体的快照。执行<code>N+1</code> SQL查询，其中<code>N</code>是在指定修订版中修改的许多不同实体类。</p>
</dd>
<dt class="hdlist1"><code>List<Object> findEntities( Number, RevisionType )</code></dt>
<dd>
<p>返回在给定版本中按修改类型筛选的所有更改（添加，更新或删除）的审核实体的快照。执行<code>N+1</code> SQL查询，其中<code>N</code>是在指定修订版中修改的许多不同实体类。</p>
</dd>
<dt class="hdlist1"><code>Map<RevisionType, List<Object>> findEntitiesGroupByRevisionType( Number )</code></dt>
<dd>
<p>返回一个映射，其中包含按修改操作（例如，添加，更新和删除）分组的实体快照列表。执行<code>3N+1</code> SQL查询，其中<code>N</code>是在指定修订版中修改的许多不同实体类。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="envers-querying-entity-relation-joins"><a class="anchor" href="#envers-querying-entity-relation-joins"></a> 21.16。使用实体关系联接查询实体</h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关系联接查询被认为是实验性的，可能会在将来的版本中进行更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>审计查询支持基于实体关系应用约束，预测和排序操作的功能。为了遍历审计查询中的实体关系，必须将关系遍历API与联接类型一起使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关系联接可以应用于<code>many-to-one</code>和<code>many-to-one</code>仅在使用时映射<code>JoinType.LEFT</code>要么<code>JoinType.INNER</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>创建实体关系联接查询的基础如下：</p>
</div>
<div id="envers-querying-entity-relation-inner-join" class="exampleblock">
<div class="title">示例687。INNER JOIN实体审核查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery innerJoinAuditQuery = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER );</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-querying-entity-relation-left-join" class="exampleblock">
<div class="title">示例688LEFT JOIN实体审核查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery innerJoinAuditQuery = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.LEFT );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>像任何其他查询一样，可以添加约束来限制结果。</p>
</div>
<div class="paragraph">
<p>例如，找到一个<code>Customers</code>给定修订版中地址位于的实体<code>România</code> ，您可以使用以下查询：</p>
</div>
<div id="envers-querying-entity-relation-join-restriction" class="exampleblock">
<div class="title">示例689。使用WHERE子句谓词过滤联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER )
.add( AuditEntity.property( "country" ).eq( "România" ) )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
inner join
    Address_AUD a
        on (
            c.address_id=a.id
            or (
                c.address_id is null
            )
            and (
                a.id is null
            )
        )
where
    c.REV&lt;=?
    and c.REVTYPE&lt;&gt;?
    and (
        c.REVEND&gt;?
        or c.REVEND is null
    )
    and a.REV&lt;=?
    and a.country=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [VARCHAR] - [România]
-- binding parameter [6] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还可以遍历实体图中的第一个关系。</p>
</div>
<div class="paragraph">
<p>例如，查找所有<code>Customer</code>给定版本的实体，其中address属性的country属性为<code>România</code> ：</p>
</div>
<div id="envers-querying-entity-relation-nested-join-restriction" class="exampleblock">
<div class="title">示例690使用WHERE子句谓词过滤嵌套的联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER )
.traverseRelation( "country", JoinType.INNER )
.add( AuditEntity.property( "name" ).eq( "România" ) )
.getResultList();

assertEquals( 1, customers.size() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD co
        on (
            a.country_id=co.id
            or (
                a.country_id is null
            )
            and (
                co.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and co.REV&lt;=?
    and co.name=?
    and (
        co.REVEND&gt;?
        or co.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [INTEGER] - [1]
-- binding parameter [6] as [INTEGER] - [1]
-- binding parameter [7] as [VARCHAR] - [România]
-- binding parameter [8] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>约束也可以添加到嵌套连接关系的属性中，例如测试<code>null</code> 。</p>
</div>
<div class="paragraph">
<p>例如，以下查询说明了如何查找所有<code>Customer</code>给定版本的实体具有<code>address</code>在<code>Cluj-Napoca</code>或者<code>address</code> <em>没有</em>任何一个国家实体引用：</p>
</div>
<div id="envers-querying-entity-relation-join-multiple-restrictions" class="exampleblock">
<div class="title">示例691使用多个谓词过滤联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.LEFT, "a" )
.add(
	AuditEntity.or(
		AuditEntity.property( "a", "city" ).eq( "Cluj-Napoca" ),
		AuditEntity.relatedId( "country" ).eq( null )
	)
)
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
  c.id as id1_5_,
  c.REV as REV2_5_,
  c.REVTYPE as REVTYPE3_5_,
  c.REVEND as REVEND4_5_,
  c.created_on as created_5_5_,
  c.firstName as firstNam6_5_,
  c.lastName as lastName7_5_,
  c.address_id as address_8_5_
from
  Customer_AUD c
left outer join
  Address_AUD a
    on (
      c.address_id=a.id
      or (
        c.address_id is null
      )
      and (
        a.id is null
      )
    )
where
  c.REV&lt;=?
  and c.REVTYPE&lt;&gt;?
  and (
    c.REVEND&gt;?
    or c.REVEND is null
  )
  and (
    a.REV is null
    or a.REV&lt;=?
    and (
      a.REVEND&gt;?
      or a.REVEND is null
    )
  )
  and (
    a.city=?
    or a.country_id is null
  )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [INTEGER] - [1]
-- binding parameter [6] as [VARCHAR] - [Cluj-Napoca]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>查询可以使用<code>up</code>导航回实体图的方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>析取标准也可以应用于关系联接查询。</p>
</div>
<div class="paragraph">
<p>例如，以下查询将查找所有<code>Customer</code>给定版本的国家名称为<code>România</code>或者那个<code>Customer</code>住在<code>Cluj-Napoca</code> ：</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions" class="exampleblock">
<div class="title">示例692。使用多个谓词过滤嵌套的联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER, "a" )
.traverseRelation( "country", JoinType.INNER, "cn" )
.up()
.up()
.add(
	AuditEntity.disjunction()
	.add( AuditEntity.property( "a", "city" ).eq( "Cluj-Napoca" ) )
	.add( AuditEntity.property( "cn", "name" ).eq( "România" ) )
)
.addOrder( AuditEntity.property( "createdOn" ).asc() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD co
        on (
            a.country_id=co.id
            or (
                a.country_id is null
            )
            and (
                co.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and (
        a.city=?
        or co.name=?
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and co.REV&lt;=?
    and (
        co.REVEND&gt;?
        or co.REVEND is null
    )
order by
    cu.created_on asc

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [VARCHAR] - [Cluj-Napoca]
-- binding parameter [5] as [VARCHAR] - [România]
-- binding parameter [6] as [INTEGER] - [1]
-- binding parameter [7] as [INTEGER] - [1]
-- binding parameter [8] as [INTEGER] - [1]
-- binding parameter [9] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，此示例说明如何在单个约束中比较相关实体属性。</p>
</div>
<div class="paragraph">
<p>假设， <code>Customer</code>和<code>Address</code>以前的更改如下：</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions-combined-entities" class="exampleblock">
<div class="title">示例693。改变<code>Address</code>匹配<code>Country</code>名称</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.createQuery(
	"select c " +
	"from Customer c " +
	"join fetch c.address a " +
	"join fetch a.country " +
	"where c.id = :id", Customer.class )
.setParameter( "id", 1L )
.getSingleResult();

customer.setLastName( "Doe Sr." );

customer.getAddress().setCity(
	customer.getAddress().getCountry().getName()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询显示了如何查找<code>Customer</code>实体<code>city</code>的属性<code>address</code>属性等于<code>name</code>的相关<code>country</code>属性。</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions-combined" class="exampleblock">
<div class="title">示例694。使用多个谓词过滤嵌套的联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Number&gt; revisions = AuditReaderFactory.get( entityManager ).getRevisions(
	Customer.class,
	1L
);

List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( revisions.size() - 1 ) )
.traverseRelation( "address", JoinType.INNER, "a" )
.traverseRelation( "country", JoinType.INNER, "cn" )
.up()
.up()
.add( AuditEntity.property( "a", "city" ).eqProperty( "cn", "name" ) )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD cr
        on (
            a.country_id=cr.id
            or (
                a.country_id is null
            )
            and (
                cr.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and a.city=cr.name
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and cr.REV&lt;=?
    and (
        cr.REVEND&gt;?
        or cr.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [2]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [2]
-- binding parameter [4] as [INTEGER] - [2]
-- binding parameter [5] as [INTEGER] - [2]
-- binding parameter [6] as [INTEGER] - [2]
-- binding parameter [7] as [INTEGER] - [2]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-querying-revision-entities"><a class="anchor" href="#envers-querying-revision-entities"></a> 21.17。在不加载实体的情况下查询修订信息</h3>
<div class="paragraph">
<p>有时，加载有关修订的信息以找出执行特定修订的人员或了解修改了哪些实体名称可能很有用，但是不需要有关相关审核实体的变更日志。该API提供了一种有效的方式来获取修订信息实体日志，而无需实例化实际实体本身。</p>
</div>
<div class="paragraph">
<p>这是一个简单的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">AuditQuery query = getAuditReader().createQuery()
    .forRevisionsOfEntity( DefaultRevisionEntity.class, true )
    .add( AuditEntity.revisionNumber().between( 1, 25 ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>此查询将返回1到25之间的所有修订信息实体，包括那些与删除有关的修订。如果删除不重要，您将通过<code>false</code>作为第二个论点。</p>
</div>
<div class="paragraph">
<p>请注意，此查询使用<code>DefaultRevisionEntity</code>类类型。所提供的类将根据用于配置Envers的配置属性或您是否提供自己的修订版实体而有所不同。通常，将使用此API的用户可能会提供自定义修订版实体实现，以获取每个修订版维护的自定义信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-conditional-auditing"><a class="anchor" href="#envers-conditional-auditing"></a> 21.18。有条件的审计</h3>
<div class="paragraph">
<p>Envers可以对各种Hibernate事件做出反应（例如，保留审核数据） <code>post update</code> ， <code>post insert</code> ，依此类推），使用来自<code>org.hibernate.envers.event.spi</code>包。默认情况下，如果Envers jar位于类路径中，则事件侦听器会自动向Hibernate注册。</p>
</div>
<div class="paragraph">
<p>可以通过覆盖某些Envers事件侦听器来实现条件审核。要使用自定义的Envers事件侦听器，需要执行以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过设置以下选项来关闭自动Envers事件侦听器注册<code>hibernate.envers.autoRegisterListeners</code>Hibernate属性<code>false</code> 。</p>
</li>
<li>
<p>为适当的事件侦听器创建子类。例如，如果要有条件地审核实体插入，请扩展<code>org.hibernate.envers.event.spi.EnversPostInsertEventListenerImpl</code>类。将条件审核逻辑放在子类中，如果应执行审核，则调用super方法。</p>
</li>
<li>
<p>创建自己的实现<code>org.hibernate.integrator.spi.Integrator</code> ， 相似<code>org.hibernate.envers.boot.internal.EnversIntegrator</code> 。使用事件侦听器类而不是默认类。</p>
</li>
<li>
<p>为了在Hibernate启动时自动使用积分器，您需要添加一个<code>META-INF/services/org.hibernate.integrator.spi.Integrator</code>归档到您的jar中。该文件应包含实现接口的类的完全限定名称。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指某东西的用途<code>hibernate.listeners.envers.autoRegister</code>已不推荐使用。新的<code>hibernate.envers.autoRegisterListeners</code>应该使用配置设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="envers-schema"><a class="anchor" href="#envers-schema"></a> 21.19。了解Envers模式</h3>
<div class="paragraph">
<p>对于每个审核实体（即，对于包含至少一个审核字段的每个实体），创建一个审核表。默认情况下，审计表的名称是通过在原始表名中添加“ _AUD”后缀来创建的，但是可以通过在配置属性或每个实体中使用<code>@org.hibernate.envers.AuditTable</code>注解。</p>
</div>
<div class="paragraph">
<p>审核表包含以下列：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ID</dt>
<dd>
<p><code>id</code>原始实体（如果是复合主键，则可能超过一列）</p>
</dd>
<dt class="hdlist1">修订号</dt>
<dd>
<p>一个整数，与修订实体表中的修订号匹配。</p>
</dd>
<dt class="hdlist1">修订类型</dt>
<dd>
<p>的<code>org.hibernate.envers.RevisionType</code>枚举序号，说明更改是否表示INSERT，UPDATE或DELETE。</p>
</dd>
<dt class="hdlist1">审计领域</dt>
<dd>
<p>来自原始实体的属性</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>审核表的主键是实体的原始ID和修订号的组合，因此在给定的修订版中，给定的实体实例最多可以有一个历史条目。</p>
</div>
<div class="paragraph">
<p>当前实体数据存储在原始表和审核表中。这是数据的重复，但是由于此解决方案使查询系统功能更加强大，并且内存便宜，因此希望这对用户而言不会成为主要缺点。</p>
</div>
<div class="paragraph">
<p>审核表中具有实体ID的行<code>ID</code> ，修订<code>N</code>和数据<code>D</code>表示：具有ID的实体<code>ID</code>有数据<code>D</code>从修订<code>N</code>向上。因此，如果我们要查找修订版的实体<code>M</code> ，我们必须在审核表中搜索一行，其修订号小于或等于<code>M</code> ，但尽可能大。如果找不到这样的行，或者找到带有“已删除”标记的行，则表示该版本不存在该实体。</p>
</div>
<div class="paragraph">
<p>“修订类型”字段当前可以具有三个值： <code>0</code> ， <code>1</code>和<code>2</code> ， 意思是<code>ADD</code> ， <code>MOD</code>和<code>DEL</code> ， 分别。具有类型修订的行<code>DEL</code>将仅包含实体的ID，不包含任何数据（所有字段<code>NULL</code> ），因为它仅用作标记，表示“此实体在该修订版中已删除”。</p>
</div>
<div class="paragraph">
<p>此外，还有一个修订实体表，其中包含有关全局修订的信息。默认情况下，生成的表名为<code>REVINFO</code>并且仅包含两列： <code>ID</code>和<code>TIMESTAMP</code> 。在每个新修订版本（即，在事务的每次提交中）都会在此表中插入一行，该行会更改审核的数据。可以配置该表的名称，可以按照<a href="#envers-revisionlog">修订日志中的</a>讨论实现其列名以及添加其他列。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管全球修订版是提供正确审核关系的一种好方法，但有人指出，这可能是经常修改数据的系统的瓶颈。</p>
</div>
<div class="paragraph">
<p>一种可行的解决方案是引入一个选项，使实体“本地修订”，即将为其独立创建修订。这将无法对关系进行正确的版本控制，但是如果没有<code>REVINFO</code>表。</p>
</div>
<div class="paragraph">
<p>另一种可能性是引入“修订组”的概念，该概念将对共享相同修订号的实体进行分组。每个这样的组必须由一个或多个强连接的组件组成，这些组件属于由实体之间的关系引起的实体图。</p>
</div>
<div class="paragraph">
<p>在论坛上，欢迎您提出关于该主题的意见。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="envers-generateschema"><a class="anchor" href="#envers-generateschema"></a> 21.20。使用Hibernate hbm2ddl工具生成Envers模式</h3>
<div class="paragraph">
<p>如果您想使用Hibernate生成数据库模式文件，则也只需要使用hbm2ddl。</p>
</div>
<div class="paragraph">
<p>此任务将生成所有实体的定义，这两个实体均由Envers审核，而未经实体审核。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#schema-generation">模式生成</a>一章。</p>
</div>
<div class="paragraph">
<p>对于以下实体，Hibernate将生成以下数据库架构：</p>
</div>
<div id="envers-generateschema-example" class="exampleblock">
<div class="title">例子695。使用多个谓词过滤嵌套的联接关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

	@Id
	private Long id;

	private String firstName;

	private String lastName;

	@Temporal( TemporalType.TIMESTAMP )
	@Column(name = "created_on")
	@CreationTimestamp
	private Date createdOn;

	@ManyToOne(fetch = FetchType.LAZY)
	private Address address;

	//Getters and setters omitted for brevity
}

@Audited
@Entity(name = "Address")
public static class Address {

	@Id
	private Long id;

	@ManyToOne(fetch = FetchType.LAZY)
	private Country country;

	private String city;

	private String street;

	private String streetNumber;

	//Getters and setters omitted for brevity
}

@Audited
@Entity(name = "Country")
public static class Country {

	@Id
	private Long id;

	private String name;

	//Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Address (
    id bigint not null,
    city varchar(255),
    street varchar(255),
    streetNumber varchar(255),
    country_id bigint,
    primary key (id)
)

create table Address_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    city varchar(255),
    street varchar(255),
    streetNumber varchar(255),
    country_id bigint,
    primary key (id, REV)
)

create table Country (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

create table Country_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    name varchar(255),
    primary key (id, REV)
)

create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    address_id bigint,
    primary key (id)
)

create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    address_id bigint,
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Address
add constraint FKpr4rl83u5fv832kdihl6w3kii
foreign key (country_id)
references Country

alter table Address_AUD
add constraint FKgwp5sek4pjb4awy66sp184hrv
foreign key (REV)
references REVINFO

alter table Address_AUD
add constraint FK52pqkpismfxg2b9tmwtncnk0d
foreign key (REVEND)
references REVINFO

alter table Country_AUD
add constraint FKrix4g8hm9ui6sut5sy86ujggr
foreign key (REV)
references REVINFO

alter table Country_AUD
add constraint FKpjeqmdccv22y1lbtswjb84ghi
foreign key (REVEND)
references REVINFO

alter table Customer
add constraint FKfok4ytcqy7lovuiilldbebpd9
foreign key (address_id)
references Address

alter table Customer_AUD
add constraint FK5ecvi1a0ykunrriib7j28vpdj
foreign key (REV)
references REVINFO

alter table Customer_AUD
add constraint FKqd4fy7ww1yy95wi4wtaonre3f
foreign key (REVEND)
references REVINFO</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-mappingexceptions"><a class="anchor" href="#envers-mappingexceptions"></a> 21.21。映射异常</h3>
<div class="sect3">
<h4 id="_what_isn_t_and_will_not_be_supported"><a class="anchor" href="#_what_isn_t_and_will_not_be_supported"></a> 21.21.1。什么是不支持</h4>
<div class="paragraph">
<p>不支持袋子，因为袋子中可能包含非唯一元素。坚持，一袋`String`违反了关系数据库的原则，即每个表都是一组元组。</p>
</div>
<div class="paragraph">
<p>但是，在使用bag的情况下（需要连接表），如果存在重复元素，则对应于元素的两个元组将相同。尽管Hibernate允许这样做，但是Envers（或更准确地说：数据库连接器）由于唯一的约束冲突而在尝试保留两个相同元素时将引发异常。</p>
</div>
<div class="paragraph">
<p>如果需要bag语义，至少有两种方法可以解决：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用索引集合， <code>@javax.persistence.OrderColumn</code>注解</p>
</li>
<li>
<p>为您的元素提供唯一的ID， <code>@CollectionId</code>注解。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_what_isn_t_and_em_will_em_be_supported"><a class="anchor" href="#_what_isn_t_and_em_will_em_be_supported"></a> 21.21.2。什么不是， <em>将</em>支持</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>包款式搭配<code>@CollectionId</code>标识符列（请参阅<a href="https://hibernate.atlassian.net/browse/HHH-3950">HHH-3950</a> ）。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_onetomany_code_with_code_joincolumn_code"><a class="anchor" href="#_code_onetomany_code_with_code_joincolumn_code"></a> 21.22。 <code>@OneToMany</code>与<code>@JoinColumn</code></h3>
<div class="paragraph">
<p>当使用这两个注释映射集合时，Hibernate不会生成联接表。但是，Envers必须这样做，以便当您阅读相关实体已更改的修订时，不会得到错误的结果。</p>
</div>
<div class="paragraph">
<p>为了能够命名附加的联接表，有一个特殊的注释： <code>@AuditJoinTable</code> ，其语义与JPA相似<code>@JoinTable</code> 。</p>
</div>
<div class="paragraph">
<p>一种特殊情况是将关系映射为<code>@OneToMany</code>与<code>@JoinColumn</code>一方面， <code>@ManyToOne</code>和<code>@JoinColumn( insertable=false, updatable=false</code> ）。实际上，这种关系是双向的，但是所有权是集合。</p>
</div>
<div class="paragraph">
<p>要与Envers正确审核此类关系，您可以使用<code>@AuditMappedBy</code>注解。它使您可以指定反向属性（使用<code>mappedBy</code>元件）。如果是索引集合，则索引列也必须映射到引用的实体中（使用<code>@Column( insertable=false, updatable=false )</code> ，并使用指定<code>positionMappedBy</code> 。此注释将仅影响Envers的工作方式。请注意，注释是实验性的，将来可能会更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning"><a class="anchor" href="#envers-partitioning"></a> 21.23。高级：审核表分区</h3>

</div>
<div class="sect2">
<h3 id="envers-partitioning-benefits"><a class="anchor" href="#envers-partitioning-benefits"></a> 21.24。审核表分区的好处</h3>
<div class="paragraph">
<p>由于审核表会无限期地增长，因此它们很快就会变得很大。当审核表增长到一定限制（每个RDBMS和/或操作系统不同）时，开始使用表分区是有意义的。SQL表分区提供了许多优点，包括但不限于：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过选择性地将行移动到各个分区（甚至清除旧行）来提高查询性能</p>
</li>
<li>
<p>更快的数据加载，索引创建等</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-columns"><a class="anchor" href="#envers-partitioning-columns"></a> 21.25。适用于审计表分区的列</h3>
<div class="paragraph">
<p>通常，SQL表必须在表中存在的列上进行分区。通常，将“ <em>最终修订”</em>或“ <em>最终修订时间戳记”</em>列用于审核表的分区是有意义的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最终版本信息不适用于默认设置<code>AuditStrategy</code> 。</p>
</div>
<div class="paragraph">
<p>因此，需要以下Envers配置选项：</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy</code> =<code>org.hibernate.envers.strategy.ValidityAuditStrategy</code></p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> =<code>true</code></p>
</div>
<div class="paragraph">
<p>（可选）您还可以使用以下属性覆盖默认值：</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code></p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code></p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#envers-configuration">配置属性</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>应将最终修订信息用于审核表分区的原因是基于这样的假设，即审核表应按照“相关程度的提高”进行分区，如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>几个分区的审核数据不很相关（或不再相关）。它可以存储在慢速介质上，甚至可能最终被清除。</p>
</li>
<li>
<p>审计数据的某些分区可能相关。</p>
</li>
<li>
<p>一个最可能相关的审计数据分区。应该将其存储在最快的介质上，以便进行读取和写入。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example"><a class="anchor" href="#envers-partitioning-example"></a> 21.26。审计表分区示例</h3>
<div class="paragraph">
<p>为了确定“相关程度增加”的合适列，请考虑一个未命名机构的工资注册的简化示例。</p>
</div>
<div class="paragraph">
<p>当前，薪水表包含某人X的以下行：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表12。薪水表</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">年</th>
<th class="tableblock halign-left valign-top">薪金（美元）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2006年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3300</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3500</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4500</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当前会计年度（2010年）的薪水未知。该机构要求记录一个会计年度的所有注册薪金变动（即审计追踪）。其背后的理由是，在特定日期做出的决定是基于当时的注册工资。并且在任何时候都必须能够再现在某个特定日期做出特定决定的原因。</p>
</div>
<div class="paragraph">
<p>提供了以下审核信息，并按出现的顺序对其进行了排序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表13。薪金-审计表</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">年</th>
<th class="tableblock halign-left valign-top">修订类型</th>
<th class="tableblock halign-left valign-top">修订时间戳</th>
<th class="tableblock halign-left valign-top">薪金（美元）</th>
<th class="tableblock halign-left valign-top">结束修订时间戳</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2006年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">35</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-02</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-02</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3700</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-07-01</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-07-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-02-01</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-02-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009年</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example-column"><a class="anchor" href="#envers-partitioning-example-column"></a> 21.27。确定合适的分区列</h3>
<div class="paragraph">
<p>要对该数据进行分区，必须定义<em>相关级别</em> 。考虑以下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>对于2006会计年度，仅进行了一次修订。它具有所有审计行中最早的<em>修订时间戳</em> ，但仍应视为具有相关性，因为它是薪资表中该会计年度的最新<em>修订</em> （其<em>最终修订时间戳</em>为null）。</p>
<div class="paragraph">
<p>另外，请注意，如果在2011年更新2006会计年度的薪水（这可能要到会计年度后至少10年才能更新），并且审计信息已移至慢速磁盘（基于<em>修订时间戳的期限</em> ）。请记住，在这种情况下，Envers将必须更新最新审核行的<em>结束修订时间戳</em> 。</p>
</div>
</li>
<li>
<p>2007会计年度的薪水有两个修订版本，它们具有几乎相同的<em>修订时间戳</em>和不同的<em>最终修订时间戳</em> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>乍一看，很明显，第一次修订是一个错误，可能不相关。2007年唯一相关的修订版是带有<em>最终修订版时间戳为</em> null的<em>修订版</em> 。</p>
</div>
<div class="paragraph">
<p>基于以上内容，很明显，只有<em>最终修订时间戳才</em>适合审计表分区。<em>修订时间戳</em>不适合。</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example-scheme"><a class="anchor" href="#envers-partitioning-example-scheme"></a> 21.28。确定合适的分区方案</h3>
<div class="paragraph">
<p>薪水表的可能分区方案如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>结束修订时间戳记</em>年= 2008</dt>
<dd>
<p>此分区包含无关紧要的审核数据。</p>
</dd>
<dt class="hdlist1"><em>结束修订时间戳记</em>年= 2009</dt>
<dd>
<p>该分区包含可能相关的审核数据。</p>
</dd>
<dt class="hdlist1"><em>结束修订时间戳记</em>年份> = 2010或为null</dt>
<dd>
<p>此分区包含最相关的审核数据。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此分区方案还涵盖了<em>最终修订时间戳记</em>更新的潜在问题，如果修改了审核表中的行，则会发生此问题。即使Envers在<em>修改时</em>将审核行的<em>结束修订时间戳记</em>更新为系统日期，审核行仍将保留在同一分区（“扩展存储桶”）中。</p>
</div>
<div class="paragraph">
<p>在2011年的某个时候，最后一个分区（或“扩展存储桶”）被分为两个新分区：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>最终修订时间戳记</em>年= 2010 ：：此分区包含可能相关的审核数据（2011年）。</p>
</li>
<li>
<p><em>结束修订时间戳记</em>年份> = 2011或为null ：：此分区包含最有趣的审核数据，并且是新的“扩展存储段”。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-links"><a class="anchor" href="#envers-links"></a> 21.29。启用链接</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://hibernate.org">Hibernate主页</a></p>
</li>
<li>
<p><a href="http://community.jboss.org/en/envers?view=discussions">论坛</a></p>
</li>
<li>
<p><a href="https://hibernate.atlassian.net/">JIRA问题跟踪器</a> （添加有关Envers的问题时，请确保选择“ envers”组件！）</p>
</li>
<li>
<p><a href="https://hibernate.hipchat.com/chat/room/1238636">嘻哈频道</a></p>
</li>
<li>
<p><a href="https://community.jboss.org/wiki/EnversFAQ">常问问题</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="portability"><a class="anchor" href="#portability"></a> 22数据库可移植性注意事项</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="portability-basics"><a class="anchor" href="#portability-basics"></a> 22.1可移植性基础</h3>
<div class="paragraph">
<p>数据库可移植性是Hibernate的卖点之一（实际上是整个对象/关系映射）。这可能意味着内部IT用户从一个数据库供应商迁移到另一数据库供应商，也可能意味着框架或可部署的应用程序消耗了Hibernate来使其用户同时定位多个数据库产品。不管确切的情况如何，基本思想都是希望Hibernate帮助您针对任何数量的数据库运行而无需更改代码，理想情况下无需更改映射元数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="portability-dialect"><a class="anchor" href="#portability-dialect"></a> 22.2。方言</h3>
<div class="paragraph">
<p>Hibernate可移植性的第一行是方言，它是<code>org.hibernate.dialect.Dialect</code>合同。一种方言封装了Hibernate必须如何与特定数据库通信以完成某些任务（例如获取序列值或构造SELECT查询）的所有差异。Hibernate为许多最受欢迎的数据库捆绑了多种方言。如果您发现您的特定数据库不在其中，那么编写自己的数据库并不难。</p>
</div>
</div>
<div class="sect2">
<h3 id="portability-dialectresolver"><a class="anchor" href="#portability-dialectresolver"></a> 22.3。方言解析</h3>
<div class="paragraph">
<p>最初，Hibernate始终要求用户指定要使用的方言。如果用户希望同时使用其构建目标多个数据库，那将是有问题的。通常，这要求其用户配置Hibernate方言或定义自己的设置该值的方法。</p>
</div>
<div class="paragraph">
<p>从3.2版开始，Hibernate引入了根据语言自动检测要使用的方言的概念。 <code>java.sql.DatabaseMetaData</code>从<code>java.sql.Connection</code>到该数据库。这要好得多，只不过此解决方案仅限于Hibernate提前知道的数据库，而且绝不是可配置或可重写的。</p>
</div>
<div class="paragraph">
<p>从3.3版开始，Hibernate提供了一种功能更强大的方法，它可以依靠一系列实现该方法的代表来自动确定应使用哪种方言。 <code>org.hibernate.dialect.resolver.DialectResolver</code>仅定义一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的基本约定是，如果解析器“理解”给定的数据库元数据，则它将返回相应的Dialect；如果不是，则返回null，然后过程继续到下一个解析器。签名还标识<code>org.hibernate.exception.JDBCConnectionException</code>可能会被抛出。一种<code>JDBCConnectionException</code>此处的解释是隐式表示<em>非暂时性</em> （即不可恢复）连接问题，用于指示立即停止解决解析问题。所有其他异常都会导致警告并继续进行下一个解析器。</p>
</div>
<div class="paragraph">
<p>关于这些解析器的最酷的部分是用户还可以注册自己的自定义解析器，该解析器将在内置的Hibernate解析器之前进行处理。这在许多不同情况下可能有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>除了Hibernate本身附带的方言外，它还可以轻松集成以自动检测方言</p>
</li>
<li>
<p>它允许您指定在识别特定数据库时使用自定义方言。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要注册一个或多个解析器，只需使用“ hibernate.dialect_resolvers”配置设置指定它们（用逗号，制表符或空格分隔）。 <code>DIALECT_RESOLVERS</code>持续<code>org.hibernate.cfg.Environment</code> ）。</p>
</div>
</div>
<div class="sect2">
<h3 id="portability-idgen"><a class="anchor" href="#portability-idgen"></a> 22.4。标识符生成</h3>
<div class="paragraph">
<p>考虑数据库之间的可移植性时，另一个重要的决定是选择要使用的标识符生成策略。最初，Hibernate为此目的提供了<em>本机</em>生成器，该生成器旨在根据基础数据库的功能在<em>序列</em> ， <em>标识</em>或<em>表</em>策略之间进行选择。</p>
</div>
<div class="paragraph">
<p>但是，当针对某些支持<em>身份</em>生成的数据库，而某些不支持<em>身份</em>生成的数据库时，这种方法会带来隐患。
<em>身份</em>生成依赖于IDENTITY（或自动递增）列的SQL定义来管理标识符值。这就是所谓<em>的插入后</em>生成策略，因为插入实际上必须在我们知道标识符值之前发生。</p>
</div>
<div class="paragraph">
<p>因为Hibernate依赖于此标识符值来在持久性上下文中唯一引用实体，所以当用户请求该实体与会话相关联时，它必须立即发出插入（例如，通过<code>save()</code>要么<code>persist()</code> ），而不考虑当前的事务语义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一旦更好地理解了它的含义，Hibernate就会稍作更改，因此在可行的情况下，现在可以延迟插入。</p>
</div>
<div class="paragraph">
<p>潜在的问题是，在这些情况下，应用程序本身的实际语义会发生变化。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从版本3.2.3开始，Hibernate附带了一组<a href="http://in.relation.to/2082.lace">增强的</a>标识符生成器，它们以非常不同的方式针对可移植性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>具体来说，有2个捆绑的<em>增强型</em>生成器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.id.enhanced.SequenceStyleGenerator</code></p>
</li>
<li>
<p><code>org.hibernate.id.enhanced.TableGenerator</code></p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这些生成器背后的思想是将标识符值生成的实际语义移植到不同的数据库。例如， <code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>通过使用表模拟序列在不支持序列的数据库上的行为。</p>
</div>
</div>
<div class="sect2">
<h3 id="portability-functions"><a class="anchor" href="#portability-functions"></a> 22.5。数据库功能</h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在数据库功能方面，Hibernate可以从改进中受益。</p>
</div>
<div class="paragraph">
<p>在可移植性方面，当前的功能处理在HQL中运行良好，但是在所有其他方面都非常缺乏。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>用户可以通过多种方式引用SQL函数。但是，并非所有数据库都支持相同的功能集。Hibernate提供了一种将<em>逻辑</em>函数名称映射到委托的方法，该委托知道如何呈现该特定函数，甚至可能使用完全不同的物理函数调用。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从技术上讲，SQL函数注册是通过<code>org.hibernate.dialect.function.SQLFunctionRegistry</code>类，旨在允许用户提供自定义功能定义而不必提供自定义方言。到目前为止，此特定行为尚未完全完成。</p>
</div>
<div class="paragraph">
<p>它的实现方式是使用户可以通过编程方式向<code>org.hibernate.cfg.Configuration</code>这些功能将被HQL识别。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="portability-types"><a class="anchor" href="#portability-types"></a> 22.6。类型映射</h3>
<div class="paragraph">
<p>TODO：还要记录以下内容</p>
</div>
<div class="sect3">
<h4 id="portability-types-lobs"><a class="anchor" href="#portability-types-lobs"></a> 22.6.1。BLOB / CLOB映射</h4>

</div>
<div class="sect3">
<h4 id="portability-types-bool"><a class="anchor" href="#portability-types-bool"></a> 22.6.2。布尔映射</h4>
<div class="paragraph">
<p>JPA可移植性</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HQL / JPQL的差异</p>
</li>
<li>
<p>命名策略</p>
</li>
<li>
<p>基本类型</p>
</li>
<li>
<p>简单ID类型</p>
</li>
<li>
<p>生成的ID类型</p>
</li>
<li>
<p>复合ID和多对一</p>
</li>
<li>
<p>“嵌入式复合标识符”</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="statistics"><a class="anchor" href="#statistics"></a> 23。统计</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate可以收集各种统计信息，可以帮助您更好地了解Hibernate在幕后所做的事情。</p>
</div>
<div class="paragraph">
<p>默认情况下，不收集统计信息，因为这会导致额外的处理和内存开销。要指示Hibernate开始收集统计信息，您需要设置<code>hibernate.generate_statistics</code>配置属性为<code>true</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;property
    name="hibernate.generate_statistics"
    value="true"
/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="statistics-methods"><a class="anchor" href="#statistics-methods"></a> 23.1。 org.hibernate.stat。统计方法</h3>
<div class="paragraph">
<p>可以通过以下方式获取Hibernate统计信息： <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/stat/Statistics.html"><code>Statistics</code></a>接口，它公开以下方法：</p>
</div>
<div class="sect3">
<h4 id="statistics-general"><a class="anchor" href="#statistics-general"></a> 23.1.1。一般统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>isStatisticsEnabled</code></dt>
<dd>
<p>是否启用统计信息？</p>
</dd>
<dt class="hdlist1"><code>setStatisticsEnabled(boolean b)</code></dt>
<dd>
<p>根据提供的参数启用统计信息。</p>
</dd>
<dt class="hdlist1"><code>clear</code></dt>
<dd>
<p>重置所有统计信息。</p>
</dd>
<dt class="hdlist1"><code>logSummary</code></dt>
<dd>
<p>将当前统计信息的摘要打印到应用程序日志中。</p>
</dd>
<dt class="hdlist1"><code>getStartTime</code></dt>
<dd>
<p>毫秒（JVM标准<code>currentTimeMillis()</code> ），因为此Statistics实例是首次创建或上次创建<code>clear()</code>被称为。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-aggregates"><a class="anchor" href="#statistics-aggregates"></a> 23.1.2。汇总统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getQueries</code></dt>
<dd>
<p>获取执行的查询字符串。Hibernate统计信息跟踪的最大查询数由<code>hibernate.statistics.query_max_size</code>属性。</p>
</dd>
<dt class="hdlist1"><code>getEntityStatistics(String entityName)</code></dt>
<dd>
<p>查找给定名称的实体统计信息。</p>
</dd>
<dt class="hdlist1"><code>getCollectionStatistics(String role)</code></dt>
<dd>
<p>获取每个角色的集合统计信息（集合名称）。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdStatistics(String entityName)</code></dt>
<dd>
<p>获取给定实体的特定于Hibernate的自然ID解析统计信息。</p>
</dd>
<dt class="hdlist1"><code>getQueryStatistics(String queryString)</code></dt>
<dd>
<p>获取给定查询字符串（JPQL / HQL或本机SQL）的统计信息。</p>
</dd>
<dt class="hdlist1"><code>getDomainDataRegionStatistics(String regionName)</code></dt>
<dd>
<p>获取每个域数据（实体，集合，自然ID）区域的二级缓存统计信息。</p>
</dd>
<dt class="hdlist1"><code>getQueryRegionStatistics(String regionName)</code></dt>
<dd>
<p>获取每个查询区域的二级缓存统计信息。</p>
</dd>
<dt class="hdlist1"><code>getCacheRegionStatistics(String regionName)</code></dt>
<dd>
<p>获取域数据或查询结果区域的统计信息（此方法同时检查两者，如果有则优先选择域数据区域）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-session-factory"><a class="anchor" href="#statistics-session-factory"></a> 23.1.3。SessionFactory统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getEntityNames</code></dt>
<dd>
<p>获取使用当前配置的所有实体的名称<code>SessionFactory</code> 。</p>
</dd>
<dt class="hdlist1"><code>getCollectionRoleNames</code></dt>
<dd>
<p>获取使用当前配置的所有集合角色的名称<code>SessionFactory</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-session"><a class="anchor" href="#statistics-session"></a> 23.1.4。会话统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getSessionCloseCount</code></dt>
<dd>
<p>全球已关闭的会话数。</p>
</dd>
<dt class="hdlist1"><code>getSessionOpenCount</code></dt>
<dd>
<p>已打开的全局会话数。</p>
</dd>
<dt class="hdlist1"><code>getFlushCount</code></dt>
<dd>
<p>获取执行的刷新操作的全局数目（手动或自动）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-jdbc"><a class="anchor" href="#statistics-jdbc"></a> 23.1.5。JDBC统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getPrepareStatementCount</code></dt>
<dd>
<p>Hibernate获取的JDBC准备的语句数。</p>
</dd>
<dt class="hdlist1"><code>getCloseStatementCount</code></dt>
<dd>
<p>Hibernate发布的JDBC准备的语句数。</p>
</dd>
<dt class="hdlist1"><code>getConnectCount</code></dt>
<dd>
<p>获取由Hibernate会话获取的全局连接数（实际使用的连接数可能会少得多，具体取决于是否使用连接池）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-transaction"><a class="anchor" href="#statistics-transaction"></a> 23.1.6。交易统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getSuccessfulTransactionCount</code></dt>
<dd>
<p>成功完成的事务数。</p>
</dd>
<dt class="hdlist1"><code>getTransactionCount</code></dt>
<dd>
<p>我们知道已完成的交易数量。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-concurrency-control"><a class="anchor" href="#statistics-concurrency-control"></a> 23.1.7。并发控制统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getOptimisticFailureCount</code></dt>
<dd>
<p>发生的Hibernate`StaleObjectStateException`或JPA`OptimisticLockException`的数量。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-entity"><a class="anchor" href="#statistics-entity"></a> 23.1.8。实体统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getEntityDeleteCount</code></dt>
<dd>
<p>获取实体删除的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getEntityInsertCount</code></dt>
<dd>
<p>获取实体插入的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getEntityLoadCount</code></dt>
<dd>
<p>获取实体加载的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getEntityFetchCount</code></dt>
<dd>
<p>获取实体获取的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getEntityUpdateCount</code></dt>
<dd>
<p>获取实体更新的全球数量。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-collection"><a class="anchor" href="#statistics-collection"></a> 23.1.9。馆藏统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getCollectionLoadCount</code></dt>
<dd>
<p>已加载的全局集合数。</p>
</dd>
<dt class="hdlist1"><code>getCollectionFetchCount</code></dt>
<dd>
<p>已获取的全球收藏数量。</p>
</dd>
<dt class="hdlist1"><code>getCollectionUpdateCount</code></dt>
<dd>
<p>已更新的全局集合数。</p>
</dd>
<dt class="hdlist1"><code>getCollectionRemoveCount</code></dt>
<dd>
<p>已删除的全局集合数。</p>
</dd>
<dt class="hdlist1"><code>getCollectionRecreateCount</code></dt>
<dd>
<p>重新创建的集合的全局数量。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-query"><a class="anchor" href="#statistics-query"></a> 23.1.10。查询统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getQueryExecutionCount</code></dt>
<dd>
<p>获取已执行查询的全局数目。</p>
</dd>
<dt class="hdlist1"><code>getQueryExecutionMaxTime</code></dt>
<dd>
<p>获取最慢查询的时间（以毫秒为单位）。</p>
</dd>
<dt class="hdlist1"><code>getQueryExecutionMaxTimeQueryString</code></dt>
<dd>
<p>获取最慢查询的查询字符串。</p>
</dd>
<dt class="hdlist1"><code>getQueryPlanCacheHitCount</code></dt>
<dd>
<p>获取成功从缓存中检索的查询计划的全局数目。</p>
</dd>
<dt class="hdlist1"><code>getQueryPlanCacheMissCount</code></dt>
<dd>
<p>获取的查询计划的全球多家查找<strong>不在</strong>缓存中找到。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-natural-id"><a class="anchor" href="#statistics-natural-id"></a> 23.1.11。自然ID统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getNaturalIdQueryExecutionCount</code></dt>
<dd>
<p>获取针对数据库执行的自然ID查询的全局数目。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdQueryExecutionMaxTime</code></dt>
<dd>
<p>获取针对数据库执行的自然ID查询的全局最大查询时间。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdQueryExecutionMaxTimeRegion</code></dt>
<dd>
<p>获取最大自然ID查询时间的区域。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdQueryExecutionMaxTimeEntity</code></dt>
<dd>
<p>获取最大自然ID查询时间的实体。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="statistics-second-level-cache"><a class="anchor" href="#statistics-second-level-cache"></a> 23.1.12。二级缓存统计方法</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getSecondLevelCacheRegionNames</code></dt>
<dd>
<p>获取所有第二级域数据缓存区域名称。</p>
</dd>
<dt class="hdlist1"><code>getSecondLevelCacheHitCount</code></dt>
<dd>
<p>从缓存中成功检索的可缓存实体/集合的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getSecondLevelCacheMissCount</code></dt>
<dd>
<p>在缓存中找不到并从数据库加载的可缓存实体/集合的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getSecondLevelCachePutCount</code></dt>
<dd>
<p>放入缓存的全局可缓存实体/集合的数量。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="statistics-second-level-cache-natural-id"><a class="anchor" href="#statistics-second-level-cache-natural-id"></a>二级缓存自然ID统计方法</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getNaturalIdCacheHitCount</code></dt>
<dd>
<p>获取成功从缓存中检索的缓存自然ID查找的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdCacheMissCount</code></dt>
<dd>
<p>获取缓存中<strong>找不到</strong>缓存天然ID查找的全球数量。</p>
</dd>
<dt class="hdlist1"><code>getNaturalIdCachePutCount</code></dt>
<dd>
<p>获取放入缓存的全局可缓存自然ID查找数。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="statistics-second-level-cache-query"><a class="anchor" href="#statistics-second-level-cache-query"></a>二级缓存查询统计方法</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getQueryCacheHitCount</code></dt>
<dd>
<p>获取成功从缓存中检索的缓存查询的全局数量。</p>
</dd>
<dt class="hdlist1"><code>getQueryCacheMissCount</code></dt>
<dd>
<p>获取缓存中<strong>没有</strong>发现缓存的查询全球多家。</p>
</dd>
<dt class="hdlist1"><code>getQueryCachePutCount</code></dt>
<dd>
<p>获取放入缓存的全局可缓存查询数。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="statistics-second-level-cache-timestamp"><a class="anchor" href="#statistics-second-level-cache-timestamp"></a>二级缓存时间戳统计方法</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getUpdateTimestampsCacheHitCount</code></dt>
<dd>
<p>获取成功从缓存中检索的全局时间戳数。</p>
</dd>
<dt class="hdlist1"><code>getUpdateTimestampsCacheMissCount</code></dt>
<dd>
<p>获取在缓存中找不到的全局时间戳请求数量。</p>
</dd>
<dt class="hdlist1"><code>getUpdateTimestampsCachePutCount</code></dt>
<dd>
<p>获取放入缓存的全局时间戳数。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="statistics-query-max-size"><a class="anchor" href="#statistics-query-max-size"></a> 23.2。查询统计信息的最大大小</h3>
<div class="paragraph">
<p>传统上，启用统计信息后，Hibernate会存储所有已执行的查询。但是，这是一个非常糟糕的默认值，因为如果您的应用程序运行数百万个不同的查询，您将面临内存不足的风险。</p>
</div>
<div class="paragraph">
<p>因此，为了限制Hibernate统计信息可以容纳的查询数量， <code>hibernate.statistics.query_max_size</code>属性已添加。默认情况下，保留的最大查询数为<strong>5000</strong> ，但是您可以通过<code>hibernate.statistics.query_max_size</code>属性。</p>
</div>
<div class="paragraph">
<p>因此，如果您的应用程序大量使用了JPA Criteria API，或者您仅拥有非常多的查询，则可能需要提高由JPA Criteria API存储的查询的最大数量。 <code>Statistics</code>实例。</p>
</div>
<div class="paragraph">
<p>如果已达到最大查询数量，则Hibernate将使用<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">最近最少使用（LRU）</a>策略为新查询条目腾出空间。</p>
</div>
</div>
<div class="sect2">
<h3 id="statistics-query-plan-cache"><a class="anchor" href="#statistics-query-plan-cache"></a> 23.3。查询计划缓存统计信息</h3>
<div class="paragraph">
<p>每个实体查询（无论是JPQL / HQL还是Criteria API）都被编译为AST（抽象语法树），并且此过程是资源密集型的。为了加快实体查询的执行速度，Hibernate提供了一个查询计划缓存，以便可以重用已编译的计划。</p>
</div>
<div class="paragraph">
<p>要监视查询计划缓存，您需要以下统计信息。</p>
</div>
<div class="sect3">
<h4 id="statistics-query-plan-cache-global-level"><a class="anchor" href="#statistics-query-plan-cache-global-level"></a> 23.3.1。查询计划缓存全局统计信息</h4>
<div class="paragraph">
<p>的<code>Statistics</code>实例提供了两个全局计数器，它们可以为您提供查询计划缓存有效性的总体情况。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getQueryPlanCacheHitCount</code></p>
</li>
<li>
<p><code>getQueryPlanCacheMissCount</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果命中计数高而未命中计数低，则查询计划缓存有效，并且绝大多数实体查询均由查询计划缓存提供服务，而不是反复编译。</p>
</div>
</div>
<div class="sect3">
<h4 id="statistics-query-plan-cache-query-level"><a class="anchor" href="#statistics-query-plan-cache-query-level"></a> 23.3.2。查询计划缓存查询级统计</h4>
<div class="paragraph">
<p>的<code>QueryStatistics</code>实例，您可以通过<code>getQueryStatistics(String queryString)</code>的方法<code>Statistics</code>对象，存储以下查询计划缓存指标：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getPlanCacheHitCount</code></dt>
<dd>
<p>从缓存中成功获取的查询计划的数量。</p>
</dd>
<dt class="hdlist1"><code>getQueryPlanCacheMissCount</code></dt>
<dd>
<p><strong>未</strong>从缓存中获取的查询计划的数量。</p>
</dd>
<dt class="hdlist1"><code>getQueryPlanCacheMissCount</code></dt>
<dd>
<p>为该特定查询编译计划所花费的总时间。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configurations"><a class="anchor" href="#configurations"></a> 24构型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="configurations-strategy"><a class="anchor" href="#configurations-strategy"></a> 24.1。策略配置</h3>
<div class="paragraph">
<p>许多配置设置定义了Hibernate用于各种目的的可插拔策略。这些策略类型设置中的许多配置接受各种形式的定义。此类配置设置的文档在这里参考。在这种情况下可用的表格类型包括：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">简称（如果已定义）</dt>
<dd>
<p>某些内置策略实现具有相应的简称。</p>
</dd>
<dt class="hdlist1">策略实例</dt>
<dd>
<p>可以指定要使用的策略实施的实例</p>
</dd>
<dt class="hdlist1">策略类参考</dt>
<dd>
<p>一种<code>java.lang.Class</code>战略实施参考</p>
</dd>
<dt class="hdlist1">策略类别名称</dt>
<dd>
<p>班级名称（ <code>java.lang.String</code> ）策略实施使用</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-general"><a class="anchor" href="#configurations-general"></a> 24.2。常规配置</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.dialect</strong></code> （例如<code>org.hibernate.dialect.PostgreSQL94Dialect</code> ）</dt>
<dd>
<p>Hibernate的类名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html"><code>Dialect</code></a> Hibernate可以从中生成针对特定关系数据库优化的SQL。</p>
<div class="paragraph">
<p>在大多数情况下，Hibernate可以选择正确的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html"><code>Dialect</code></a>实现是基于JDBC驱动程序返回的JDBC元数据的。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.current_session_context_class</strong></code> （例如<code>jta</code> ， <code>thread</code> ， <code>managed</code> ，或实现的自定义类<code>org.hibernate.context.spi.CurrentSessionContext</code> ）</dt>
<dd>
<div class="paragraph">
<p>提供一个自定义策略，为<em>当前</em>的作用域<code>Session</code> 。</p>
</div>
<div class="paragraph">
<p><em>当前</em>确切含义的定义由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/context/spi/CurrentSessionContext.html"><code>CurrentSessionContext</code></a>使用中的实现。</p>
</div>
<div class="paragraph">
<p>请注意，为了向后兼容，如果<code>CurrentSessionContext</code>未配置，但已配置JTA，则默认为<code>JTASessionContext</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-jpa-compliance"><a class="anchor" href="#configurations-jpa-compliance"></a> 24.3。符合JPA</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.transaction</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>此设置控制是否Hibernate<code>Transaction</code>的行为应符合JPA规范的规定<code>javax.persistence.EntityTransaction</code>因为它扩展了JPA。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.query</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>控制Hibernate是否处理<code>javax.persistence.Query</code> （JPQL，条件和本机查询）应严格遵循JPA规范。</p>
<div class="paragraph">
<p>这既包括解析或翻译查询，也包括对<code>javax.persistence.Query</code>抛出规范定义的异常的方法，而Hibernate则不会。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.list</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>控制Hibernate是否应识别其认为的“袋子”（ <code>org.hibernate.collection.internal.PersistentBag</code> ）作为列表（ <code>org.hibernate.collection.internal.PersistentList</code> ）或作为袋子。</p>
<div class="paragraph">
<p>如果启用，我们会将其识别为列表，其中<code>javax.persistence.OrderColumn</code>只是缺少（将使用其默认值）。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.closed</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>JPA在调用特定方法时定义特定异常<code>javax.persistence.EntityManager</code>和<code>javax.persistence.EntityManagerFactory</code>先前已关闭的对象。</p>
<div class="paragraph">
<p>此设置控制将使用JPA规范定义的行为还是Hibernate行为。</p>
</div>
<div class="paragraph">
<p>如果启用，则Hibernate将以JPA指定的方式运行，并在规范要求时抛出异常。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.proxy</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>JPA规范指出<code>javax.persistence.EntityNotFoundException</code>访问实体代理（在数据库中没有关联的表行）时，应该抛出该异常。</p>
<div class="paragraph">
<p>传统上，由于我们已经知道标识符值，因此Hibernate在访问其标识符时不会初始化实体代理，因此可以节省数据库往返。</p>
</div>
<div class="paragraph">
<p>如果启用，则Hibernate即使在访问其标识符时也将初始化实体代理。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.compliance.global_id_generators</strong></code> （例如<code>true</code>要么<code>false</code> （默认值） ）</dt>
<dd>
<p>JPA规范说，TableGenerator和SequenceGenerator名称的范围对于持久性单元是全局的（跨所有生成器类型）。</p>
<div class="paragraph">
<p>传统上，Hibernate会考虑本地范围内的名称。</p>
</div>
<div class="paragraph">
<p>如果启用，则使用的名称<code>@TableGenerator</code>和<code>@SequenceGenerator</code>将被认为是全局的，因此使用相同名称配置两个不同的生成器将导致`java.lang。IllegalArgumentException”将在启动时引发。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-database-connection"><a class="anchor" href="#configurations-database-connection"></a> 24.4。数据库连接属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.connection.driver_class</strong></code>要么<code><strong>javax.persistence.jdbc.driver</strong></code> （例如<code>org.postgresql.Driver</code> ）</dt>
<dd>
<p>命名JDBC <code>Driver</code>班级名称。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.url</strong></code>要么<code><strong>javax.persistence.jdbc.url</strong></code> （例如<code>jdbc:postgresql:hibernate_orm_test</code> ）</dt>
<dd>
<p>命名JDBC连接URL。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.username</strong></code>要么<code><strong>javax.persistence.jdbc.user</strong></code></dt>
<dd>
<p>命名JDBC连接用户名。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.password</strong></code>要么<code><strong>javax.persistence.jdbc.password</strong></code></dt>
<dd>
<p>命名JDBC连接密码。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.isolation</strong></code> （例如<code>REPEATABLE_READ</code>要么<code>Connection.TRANSACTION_REPEATABLE_READ</code> ）</dt>
<dd>
<p>命名JDBC连接事务隔离级别。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.autocommit</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>命名从在某些ConnectionProvider隐含中创建的连接池返回的JDBC连接的初始自动提交模式。</p>
<div class="paragraph">
<p>见讨论<code>hibernate.connection.provider_disables_autocommit</code>也一样</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.provider_disables_autocommit</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>指示用户的承诺，即无论从数据提供者或某些其他连接池机制支持该提供者，当Hibernate从已配置的ConnectionProvider获得的连接都已从该提供者获取时，自动提交都被禁用。通常，在以下情况下会发生这种情况：</p>
<div class="ulist">
<ul>
<li>
<p>Hibernate配置为从基础数据源获取连接，并且该数据源已配置为在其托管连接上禁用自动提交</p>
</li>
<li>
<p>Hibernate配置为从非DataSource连接池获取连接，并且该连接池已配置为禁用自动提交。对于Hibernate提供的实现，这将取决于<code>hibernate.connection.autocommit</code>设置。</p>
<div class="paragraph">
<p>Hibernate将此保证作为选择退出某些可能会对性能产生影响的操作的机会（尽管这种影响通常可以忽略不计）。具体来说，当通过Hibernate或JPA事务API启动事务时，Hibernate通常会立即从提供程序获取连接，并且：</p>
</div>
</li>
<li>
<p>通过调用以下命令检查连接是否最初处于自动提交模式<code>Connection#getAutocommit</code>了解释放时如何清理连接。</p>
</li>
<li>
<p>通过调用来启动JDBC事务<code>Connection#setAutocommit(false)</code></p>
<div class="paragraph">
<p>如果我们知道ConnectionProvider将始终返回禁用了自动提交的连接，则可以跳过这两个步骤。这就是此设置的目的。通过设置为<code>true</code> ， <code>Connection</code>采集可以延迟到需要执行第一个SQL语句之前。连接获取延迟使您可以减少数据库连接的租用时间，因此可以增加事务吞吐量。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>将此值设置为<strong>不适当</strong> <code>true</code>实际上，从提供程序获取连接Hibernate时，实际上并没有禁用自动提交功能。</p>
</div>
<div class="paragraph">
<p>这样做将导致Hibernate在任何JDBC / SQL事务之外执行SQL操作。</p>
</div>
</div>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.handling_mode</strong></code></dt>
<dd>
<p>指定Hibernate在获取和释放方面应如何管理JDBC连接。此配置属性取代<code><strong>hibernate.connection.acquisition_mode</strong></code>和<code><strong>hibernate.connection.release_mode</strong></code> 。</p>
<div class="paragraph">
<p>连接处理模式策略由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/jdbc/spi/PhysicalConnectionHandlingMode.html"><code>PhysicalConnectionHandlingMode</code></a>列举。</p>
</div>
<div class="paragraph">
<p>该配置可以是<code>PhysicalConnectionHandlingMode</code>引用或其不区分大小写<code>String</code>表示。</p>
</div>
<div class="paragraph">
<p>有关的更多详细信息<code>PhysicalConnectionHandlingMode</code>和Hibernate连接处理，请查看“ <a href="#database-connection-handling">连接处理”</a>部分。</p>
</div>
</dd>
<dt class="hdlist1"><span class="line-through"><code><strong>hibernate.connection.acquisition_mode</strong></code></span> （例如<code>immediate</code> ）</dt>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用此设置。您应该使用<code><strong>hibernate.connection.handling_mode</strong></code>代替。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>+指定Hibernate如何获取JDBC连接。可能的值由<code>org.hibernate.ConnectionAcquisitionMode</code> 。</p>
</div>
<div class="paragraph">
<p>+通常应该只配置此或<code>hibernate.connection.release_mode</code> ， 不是都。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><span class="line-through"><code><strong>hibernate.connection.release_mode</strong></code></span> （例如<code>auto</code> （默认值））</dt>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用此设置。您应该使用<code><strong>hibernate.connection.handling_mode</strong></code>代替。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>+指定Hibernate如何释放JDBC连接。可能的值由当前交易模式给出（ <code>after_transaction</code>用于JDBC事务和<code>after_statement</code>对于JTA交易）。</p>
</div>
<div class="paragraph">
<p>+通常应该只配置此或<code>hibernate.connection.acquisition_mode</code> ， 不是都。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.connection.datasource</strong></code></dt>
<dd>
<p>要么<code>javax.sql.DataSource</code>实例或JNDI名称以找到<code>DataSource</code> 。</p>
<div class="paragraph">
<p>对于JNDI名称，ses也<code>hibernate.jndi.class</code> ， <code>hibernate.jndi.url</code> ， <code>hibernate.jndi</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection</strong></code></dt>
<dd>
<p>命名用于定义任意JDBC连接属性的前缀。创建连接时，这些属性将传递给JDBC提供程序。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.provider_class</strong></code> （例如<code>org.hibernate.hikaricp.internal. HikariCPConnectionProvider</code> ）</dt>
<dd>
<p>命名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/connections/spi/ConnectionProvider.html"><code>ConnectionProvider</code></a>用于获取JDBC连接。</p>
<div class="paragraph">
<p>可以参考：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的实例<code>ConnectionProvider</code></p>
</li>
<li>
<p>一种<code>Class<? extends ConnectionProvider</code>对象参考</p>
</li>
<li>
<p>类实现的完全限定名称<code>ConnectionProvider</code></p>
<div class="paragraph">
<p>术语<code>class</code>由于遗留原因，设置名称中会出现。但是，它可以接受实例。</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jndi.class</strong></code></dt>
<dd>
<p>命名JNDI <code>javax.naming.InitialContext</code>类。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jndi.url</strong></code> （例如java：global / jdbc / default）</dt>
<dd>
<p>命名JNDI提供程序/连接URL。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jndi</strong></code></dt>
<dd>
<p>命名用于定义任意JNDI的前缀<code>javax.naming.InitialContext</code>属性。</p>
<div class="paragraph">
<p>这些属性将传递给<code>javax.naming.InitialContext#InitialContext(java.util.Hashtable)</code></p>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_hibernate_internal_connection_pool_options"><a class="anchor" href="#_hibernate_internal_connection_pool_options"></a> 24.4.1。Hibernate内部连接池选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.connection.initial_pool_size</strong></code> （例如1（默认值））</dt>
<dd>
<p>内置的Hibernate连接池的最小连接数。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.pool_size</strong></code> （例如20（默认值））</dt>
<dd>
<p>内置的Hibernate连接池的最大连接数。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection.pool_validation_interval</strong></code> （例如30（默认值））</dt>
<dd>
<p>两次连续池验证之间的秒数。在验证期间，池大小可以根据连接获取请求计数增加或减少。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurations-c3p0"><a class="anchor" href="#configurations-c3p0"></a> 24.5。 c3p0属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.c3p0.min_size</strong></code> （例如1）</dt>
<dd>
<p>C3P0连接池的最小大小。指<a href="http://www.mchange.com/projects/c3p0/#minPoolSize">c3p0 <code>minPoolSize</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0.max_size</strong></code> （例如5）</dt>
<dd>
<p>C3P0连接池的最大大小。指<a href="http://www.mchange.com/projects/c3p0/#maxPoolSize">c3p0 <code>maxPoolSize</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0.timeout</strong></code> （例如30）</dt>
<dd>
<p>C3P0连接池的最大空闲时间。指<a href="http://www.mchange.com/projects/c3p0/#maxIdleTime">c3p0 <code>maxIdleTime</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0.max_statements</strong></code> （例如5）</dt>
<dd>
<p>C3P0语句缓存的最大大小。指<a href="http://www.mchange.com/projects/c3p0/#maxStatements">c3p0 <code>maxStatements</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0.acquire_increment</strong></code> （例如2）</dt>
<dd>
<p>池中没有可用连接时获得的连接数。指<a href="http://www.mchange.com/projects/c3p0/#acquireIncrement">c3p0 <code>acquireIncrement</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0.idle_test_period</strong></code> （例如5）</dt>
<dd>
<p>验证C3P0池连接之前的空闲时间。指<a href="http://www.mchange.com/projects/c3p0/#idleConnectionTestPeriod">c3p0 <code>idleConnectionTestPeriod</code>设置</a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.c3p0</strong></code></dt>
<dd>
<p>设置前缀，用于指示需要传递给基础c3p0连接池的其他c3p0属性。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-mapping"><a class="anchor" href="#configurations-mapping"></a> 24.6。映射属性</h3>
<div class="sect3">
<h4 id="_table_qualifying_options"><a class="anchor" href="#_table_qualifying_options"></a> 24.6.1。表资格选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.default_catalog</strong></code> （例如，目录名称）</dt>
<dd>
<p>使用生成的SQL中的给定目录来限定不合格的表名。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.default_schema</strong></code> （例如，架构名称）</dt>
<dd>
<p>在生成的SQL中使用给定的架构或表空间来限定不合格的表名。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.schema_name_resolver</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/env/spi/SchemaNameResolver.html"><code>org.hibernate.engine.jdbc.env.spi.SchemaNameResolver</code></a>实现类）</dt>
<dd>
<p>默认情况下，Hibernate使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html#getSchemaNameResolver--"><code>org.hibernate.dialect.Dialect#getSchemaNameResolver</code></a> 。您可以通过提供以下内容的自定义实现来自定义模式名称的解析方式<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/env/spi/SchemaNameResolver.html"><code>SchemaNameResolver</code></a>接口。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_identifier_options"><a class="anchor" href="#_identifier_options"></a> 24.6.2。标识符选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.id.new_generator_mappings</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>设定是否指示新<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/id/IdentifierGenerator.html"><code>IdentifierGenerator</code></a>用于<code>AUTO</code> ， <code>TABLE</code>和<code>SEQUENCE</code> 。</p>
<div class="paragraph">
<p>现有的应用程序可能要禁用此功能（设置它<code>false</code> ）以实现从3.x和4.x到5.x的升级兼容性。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.use_identifier_rollback</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>如果为true，则删除对象时将生成的标识符属性重置为默认值。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.id.optimizer.pooled.preferred</strong></code> （例如<code>none</code> ， <code>hilo</code> ， <code>legacy-hilo</code> ， <code>pooled</code> （默认值）， <code>pooled-lo</code> ， <code>pooled-lotl</code>或完整的名称<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/id/enhanced/Optimizer.html"><code>Optimizer</code></a>实施）</dt>
<dd>
<p>如果生成器指定了增量大小，而未明确指定优化器，则应首选哪个<em>合并的</em>优化器？</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.id.generator.stored_last_used</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>如果为true，则存储在表所使用的值中<code>@TableGenerator</code>是最后使用的值，如果为false，则为下一个要使用的值。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.model.generator_name_as_sequence_name</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>如果为true，则由<code>generator</code>的属性<code>@GeneratedValue</code>没有匹配项时，注释应用作序列/表名<code>@SequenceGenerator</code>要么<code>TableGenerator</code>被发现。</p>
<div class="paragraph">
<p>默认值为<code>true</code>意思是<code>@GeneratedValue.generator()</code>默认情况下将用作序列/表名称。使用旧版从早期版本迁移的用户<code>hibernate_sequence</code>名称应禁用此设置。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.identifier_generator_strategy_provider</strong></code> （例如，完全合格的班级名称或实际的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/spi/IdentifierGeneratorStrategyProvider.html"><code>IdentifierGeneratorStrategyProvider</code></a>实例）</dt>
<dd>
<p>通过此设置，您可以提供实例或实现<code>org.hibernate.jpa.spi.IdentifierGeneratorStrategyProvider</code>界面，因此您可以提供一组<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/id/IdentifierGenerator.html"><code>IdentifierGenerator</code></a>允许覆盖Hibernate Core默认策略的策略。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.id.disable_delayed_identity_inserts</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>如果为true，则使用生成的标识符（标识/序列）的插入将永远不会延迟，并且始终会立即插入。如果您遇到以下任何错误，则应使用此选项<code>DelayedPostInsertIdentifier</code>并应视为<em>临时</em>解决方案。请向我们报告导致问题的映射，以便我们检查默认算法以查看是否应包含您的用例。</p>
<div class="paragraph">
<p>默认值为<code>false</code>这意味着Hibernate将使用一种算法来确定插入是否可以延迟或是否应该立即执行插入。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_quoting_options"><a class="anchor" href="#_quoting_options"></a> 24.6.3。报价选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.globally_quoted_identifiers</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>所有数据库标识符都应加引号。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.globally_quoted_identifiers_skip_column_definitions</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>假设<code>hibernate.globally_quoted_identifiers</code>是<code>true</code> ，这允许全局引用跳过列定义，如<code>javax.persistence.Column</code> ， <code>javax.persistence.JoinColumn</code>等等，尽管它避免了由于全局引用而导致对列定义的引用，但仍可以在批注/ xml映射中显式引用它们。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.auto_quote_keyword</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>指定是否自动引用被视为关键字的任何名称。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_discriminator_options"><a class="anchor" href="#_discriminator_options"></a> 24.6.4。鉴别器选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.discriminator.implicit_for_joined</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>Hibernate的遗留行为是不使用区分符进行联合继承（Hibernate不需要区分符）。但是，某些JPA提供程序确实需要区分符来处理连接继承，因此，出于可移植性考虑，此功能也已添加到Hibernate中。</p>
<div class="paragraph">
<p>因为要确保旧版应用程序也能继续正常工作，所以在如何处理<em>隐式</em>标识符映射方面，这使我们陷入了困境。解决方案是假定没有区分符元数据意味着遵循旧行为， <em>除非</em>启用此设置。</p>
</div>
<div class="paragraph">
<p>启用此设置后，Hibernate会将没有鉴别符元数据的情况解释为使用JPA定义的默认值来处理这些缺少的注释的指示。</p>
</div>
<div class="paragraph">
<p>有关其他背景信息，请参见Hibernate Jira问题<a href="https://hibernate.atlassian.net/browse/HHH-6911">HHH-6911</a> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.discriminator.ignore_explicit_for_joined</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>Hibernate的遗留行为是不使用区分符进行联合继承（Hibernate不需要区分符）。但是，某些JPA提供程序确实需要区分符来处理连接继承，因此，出于可移植性考虑，此功能也已添加到Hibernate中。</p>
<div class="paragraph">
<p>现有的应用程序（隐式或显式）依赖于Hibernate，而忽略了任何<code>DiscriminatorColumn</code>联合继承层次结构的声明。通过此设置，这些应用程序可以保持以下行为： <code>DiscriminatorColumn</code>与连接的继承配对时，注释将被忽略。</p>
</div>
<div class="paragraph">
<p>有关其他背景信息，请参见Hibernate Jira问题<a href="https://hibernate.atlassian.net/browse/HHH-6911">HHH-6911</a> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_naming_strategies"><a class="anchor" href="#_naming_strategies"></a> 24.6.5。命名策略</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.implicit_naming_strategy</strong></code> （例如<code>default</code> （默认值）， <code>jpa</code> ， <code>legacy-jpa</code> ， <code>legacy-hbm</code> ， <code>component-path</code> ）</dt>
<dd>
<p>用于指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategy.html"><code>ImplicitNamingStrategy</code></a>使用的类。为此设置定义了以下简称：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>default</code></dt>
<dd>
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategyJpaCompliantImpl.html"><code>ImplicitNamingStrategyJpaCompliantImpl</code></a></p>
</dd>
<dt class="hdlist1"><code>jpa</code></dt>
<dd>
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategyJpaCompliantImpl.html"><code>ImplicitNamingStrategyJpaCompliantImpl</code></a></p>
</dd>
<dt class="hdlist1"><code>legacy-jpa</code></dt>
<dd>
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategyLegacyJpaImpl.html"><code>ImplicitNamingStrategyLegacyJpaImpl</code></a></p>
</dd>
<dt class="hdlist1"><code>legacy-hbm</code></dt>
<dd>
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategyLegacyHbmImpl.html"><code>ImplicitNamingStrategyLegacyHbmImpl</code></a></p>
</dd>
<dt class="hdlist1"><code>component-path</code></dt>
<dd>
<p>使用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/ImplicitNamingStrategyComponentPathImpl.html"><code>ImplicitNamingStrategyComponentPathImpl</code></a></p>
<div class="paragraph">
<p>如果此属性恰好为空，则后备方法是使用<code>default</code>战略。</p>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.physical_naming_strategy</strong></code> （例如<code>org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</code> （默认值））</dt>
<dd>
<p>用于指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/naming/PhysicalNamingStrategy.html"><code>PhysicalNamingStrategy</code></a>使用的类。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_metadata_scanning_options"><a class="anchor" href="#_metadata_scanning_options"></a> 24.6.6。元数据扫描选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.archive.scanner</strong></code></dt>
<dd>
<p>通过实施<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/archive/scan/spi/Scanner.html"><code>Scanner</code></a> 。默认， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/archive/scan/internal/StandardScanner.html"><code>StandardScanner</code></a>用来。</p>
<div class="paragraph">
<p>接受：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实际的<code>Scanner</code>实例</p>
</li>
<li>
<p>对实现的类的引用<code>Scanner</code></p>
</li>
<li>
<p>实现的Class的完全限定名称<code>Scanner</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.archive.interpreter</strong></code></dt>
<dd>
<p>通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/archive/spi/ArchiveDescriptorFactory.html"><code>ArchiveDescriptorFactory</code></a>在扫描过程中使用。</p>
<div class="paragraph">
<p>接受：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实际的<code>ArchiveDescriptorFactory</code>实例</p>
</li>
<li>
<p>对实现的类的引用<code>ArchiveDescriptorFactory</code></p>
</li>
<li>
<p>实现的Class的完全限定名称<code>ArchiveDescriptorFactory</code></p>
<div class="paragraph">
<p>查看有关的信息<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/archive/scan/spi/Scanner.html"><code>Scanner</code></a>关于预期的构造函数形式。</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.archive.autodetection</strong></code> （例如<code>hbm,class</code> （默认值））</dt>
<dd>
<p>标识值的逗号分隔列表，这些值指示我们在扫描期间应自动检测到的映射类型。</p>
<div class="paragraph">
<p>允许的值包括：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>class</code></dt>
<dd>
<p>扫描类别（例如<code>.class</code> ）提取实体映射元数据</p>
</dd>
<dt class="hdlist1"><code>hbm</code></dt>
<dd>
<p>扫描<code>hbm</code>映射文件（例如<code>hbm.xml</code> ）提取实体映射元数据</p>
<div class="paragraph">
<p>默认情况下，将扫描HBM，注释和JPA XML映射。</p>
</div>
<div class="paragraph">
<p>使用JPA时，要禁用所有实体类的自动扫描， <code>exclude-unlisted-classes</code><code>persistence.xml</code>元素必须设置为true。因此，设定时<code>exclude-unlisted-classes</code>设为true，则只有在<code>persistence.xml</code>配置文件将被考虑在内。</p>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.mapping.precedence</strong></code> （例如<code>hbm,class</code> （默认值））</dt>
<dd>
<p>用于指定处理元数据源的顺序。值是一个定界列表，其元素由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/cfg/MetadataSourceType.html"><code>MetadataSourceType</code></a> 。</p>
<div class="paragraph">
<p>默认是<code>hbm,class"</code> ，因此<code>hbm.xml</code>首先处理文件，然后处理注释（与<code>orm.xml</code>映射）。</p>
</div>
<div class="paragraph">
<p>使用JPA时，XML映射将覆盖以相同实体属性为目标的冲突注释映射。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_jdbc_related_options"><a class="anchor" href="#_jdbc_related_options"></a> 24.6.7。JDBC相关的选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.use_nationalized_character_data</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>对所有基于字符串/ Clob的属性（字符串，char，clob，文本等）启用民族化字符支持。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.lob.non_contextual_creation</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>我们是否不应该使用上下文LOB创建（也称为基于<code>java.sql.Connection#createBlob()</code>等）？HANA，H2和PostgreSQL的默认值为<code>true</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.time_zone</strong></code> （例如A <code>java.util.TimeZone</code> ， 一种<code>java.time.ZoneId</code>或一个<code>String</code>一个的表示<code>ZoneId</code> ）</dt>
<dd>
<p>除非指定，否则JDBC驱动程序将使用默认的JVM时区。如果通过此设置配置了其他时区，则JDBC <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-">PreparedStatement＃setTimestamp</a>将使用<code>Calendar</code>实例根据指定的时区。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.dialect.oracle.prefer_long_raw</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>此设置仅适用于Oracle方言，它指定是否<code>byte[]</code>要么<code>Byte[]</code>数组应映射到不推荐使用<code>LONG RAW</code> （当此配置属性值为<code>true</code> ）或<code>BLOB</code>列类型（当此配置属性值为<code>false</code> ）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_bean_validation_options"><a class="anchor" href="#_bean_validation_options"></a> 24.6.8。Bean验证选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>javax.persistence.validation.factory</strong></code> （例如<code>javax.validation.ValidationFactory</code>实施）</dt>
<dd>
<p>指定<code>javax.validation.ValidationFactory</code>用于Bean验证的实现。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.check_nullability</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>启用可空性检查。如果标记为not-null的属性为null，则引发异常。</p>
<div class="paragraph">
<p>默认为<code>false</code>如果Bean验证存在于类路径中，并且使用了Hibernate Annotations， <code>true</code>除此以外。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.validator.apply_to_ddl</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<div class="paragraph">
<p>如果启用了自动模式生成，那么将在DDL中应用Bean验证约束。换句话说，数据库模式将反映Bean验证约束。</p>
</div>
<div class="paragraph">
<p>要禁用向DDL的约束传播，请进行设置<code>hibernate.validator.apply_to_ddl</code>至<code>false</code>在配置文件中。这种需求非常罕见，不建议这样做。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_misc_options"><a class="anchor" href="#_misc_options"></a> 24.6.9。杂项选项</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.create_empty_composites.enabled</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>当其所有属性值均为时启用复合/可嵌入对象的实例化<code>null</code> 。默认（和历史）行为是<code>null</code>当其所有属性都为<code>null</code> 。</p>
<div class="paragraph">
<p>这是一项实验性功能，存在已知问题。在稳定之前，不得在生产中使用它。有关详细信息，请参见Hibernate Jira问题<a href="https://hibernate.atlassian.net/browse/HHH-11936">HHH-11936</a> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.entity_dirtiness_strategy</strong></code> （例如，完全合格的班级名称或实际<code>CustomEntityDirtinessStrategy</code>实例）</dt>
<dd>
<p>设置以识别<code>org.hibernate.CustomEntityDirtinessStrategy</code>使用。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.default_entity_mode</strong></code> （例如<code>pojo</code> （默认值）或<code>dynamic-map</code> ）</dt>
<dd>
<p>默认<code>EntityMode</code>用于从此打开的所有会话的实体表示<code>SessionFactory</code> ，默认为<code>pojo</code> 。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurations-bytecode-enhancement"><a class="anchor" href="#configurations-bytecode-enhancement"></a> 24.7。字节码增强属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableDirtyTracking</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用脏跟踪功能。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableLazyInitialization</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用延迟加载功能。这样，即使是基本类型（例如<code>@Basic(fetch = FetchType.LAZY</code> ））可以延迟获取。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.enhancer.enableAssociationManagement</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在运行时字节码增强中启用关联管理功能，当仅更改一侧时，该功能会自动同步双向关联。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.bytecode.provider</strong></code> （例如<code>bytebuddy</code> （默认值））</dt>
<dd>
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/bytecode/spi/BytecodeProvider.html"><code>BytecodeProvider</code></a>内置实现风格。目前，只有<code>bytebuddy</code>和<code>javassist</code>是有效值。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.bytecode.use_reflection_optimizer</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>我们应该使用反射优化吗？反射优化器实现了<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/bytecode/spi/ReflectionOptimizer.html"><code>ReflectionOptimizer</code></a>接口并改进实体实例化和属性获取/设置程序调用。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.bytecode.enforce_legacy_proxy_classnames</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>其他一些库（例如Spring）过去依赖于运行时生成的代理类所使用的特定命名模式。设置为<code>true</code>使代理类名称符合旧模式。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-query"><a class="anchor" href="#configurations-query"></a> 24.8。查询设定</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.query.plan_cache_max_size</strong></code> （例如<code>2048</code> （默认值））</dt>
<dd>
<p>最大条目数包括： <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/query/spi/HQLQueryPlan.html"><code>HQLQueryPlan</code></a> ， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/query/spi/FilterQueryPlan.html"><code>FilterQueryPlan</code></a> ， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/query/spi/NativeSQLQueryPlan.html"><code>NativeSQLQueryPlan</code></a> 。</p>
<div class="paragraph">
<p>维护者<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/query/spi/QueryPlanCache.html"><code>QueryPlanCache</code></a> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.plan_parameter_metadata_max_size</strong></code> （例如<code>128</code> （默认值））</dt>
<dd>
<p>与关联的强引用的最大数量<code>ParameterMetadata</code>由...维护<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/query/spi/QueryPlanCache.html"><code>QueryPlanCache</code></a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.order_by.default_null_ordering</strong></code> （例如<code>none</code> ， <code>first</code>要么<code>last</code> ）</dt>
<dd>
<p>在中定义空值的优先级<code>ORDER BY</code>条款。默认为<code>none</code>在RDBMS实施之间会有所不同。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.discriminator.force_in_select</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>对于没有明确说明的实体，我们是否应将区分符强制放入SQL选择中？</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.substitutions</strong></code> （例如<code>true=1,false=0</code> ）</dt>
<dd>
<p>将Hibernate查询转换为SQL时使用的逗号分隔的标记替换列表。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.factory_class</strong></code> （例如<code>org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory</code> （默认值）或<code>org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory</code> ）</dt>
<dd>
<p>选择HQL解析器实现。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.jpaql_strict_compliance</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>从Hibernate查询中的令牌映射到SQL令牌，例如函数或文字名称。</p>
<div class="paragraph">
<p>我们应该严格遵守JPA查询语言（JPQL）语法，还是更广泛地支持Hibernate的所有超集（HQL）？</p>
</div>
<div class="paragraph">
<p>设置为<code>true</code>可能会导致有效的HQL引发异常，因为它违反了JPQL子集。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.startup_check</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>启动期间是否应检查命名查询？</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.proc.param_null_passing</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>全局设置是否<code>null</code>参数绑定应作为以下内容的一部分传递给数据库过程/函数调用<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/procedure/ProcedureCall.html"><code>ProcedureCall</code></a>处理。隐含地Hibernate将无法通过<code>null</code> ，目的是允许应用任何默认参数值。</p>
<div class="paragraph">
<p>这定义了一个全局设置，然后可以通过以下参数对每个参数进行控制<code>org.hibernate.procedure.ParameterRegistration#enablePassingNulls(boolean)</code></p>
</div>
<div class="paragraph">
<p>值是<code>true</code> （传递NULL）或<code>false</code> （请勿传递NULL）。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.log.warnings</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>启用提取JDBC语句警告以进行日志记录。默认值为<code>org.hibernate.dialect.Dialect#isJdbcLogWarningsEnabledByDefault()</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session_factory.statement_inspector</strong></code> （例如，完全限定的类名，实例或<code>Class</code>对象参考）</dt>
<dd>
<p>命名一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/jdbc/spi/StatementInspector.html"><code>StatementInspector</code></a>实施适用于每个<code>Session</code>由当前创建<code>SessionFactory</code> 。</p>
<div class="paragraph">
<p>可以参考一个<code>StatementInspector</code>实例<code>StatementInspector</code>实作<code>Class</code>参考或<code>StatementInspector</code>实现类名称（完全限定的类名称）。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.validate_parameters</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>此配置属性可用于禁用由以下人员执行的参数验证<code>org.hibernate.query.Query#setParameter</code>通过JPA引导会话时<code>javax.persistence.EntityManagerFactory</code></p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.criteria.literal_handling_mode</strong></code> （例如<code>AUTO</code> （默认值）， <code>BIND</code>要么<code>INLINE</code> ）</dt>
<dd>
<p>默认情况下，条件查询对非数字值的所有文字使用绑定参数。但是，为了增加JDBC语句缓存的可能性，您可能还希望对数字值使用绑定参数。</p>
<div class="paragraph">
<p>的<code>org.hibernate.query.criteria.LiteralHandlingMode#BIND</code>模式将对任何文字值使用绑定变量。的<code>org.hibernate.query.criteria.LiteralHandlingMode#INLINE</code>模式将按原样内联文字值。</p>
</div>
<div class="paragraph">
<p>为防止SQL注入，切勿使用<code>org.hibernate.query.criteria.LiteralHandlingMode#INLINE</code>与字符串变量。始终将常量与<code>org.hibernate.query.criteria.LiteralHandlingMode#INLINE</code>模式。</p>
</div>
<div class="paragraph">
<p>有效选项由<code>org.hibernate.query.criteria.LiteralHandlingMode</code>枚举。默认值为<code>org.hibernate.query.criteria.LiteralHandlingMode#AUTO</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.fail_on_pagination_over_collection_fetch</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在即将执行对集合获取的内存中分页时引发异常。</p>
<div class="paragraph">
<p>默认禁用。设置为true启用。</p>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_multi_table_bulk_hql_operations"><a class="anchor" href="#_multi_table_bulk_hql_operations"></a> 24.8.1。多表批量HQL操作</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.hql.bulk_id_strategy</strong></code> （例如，完全限定的类名，实例或<code>Class</code>对象参考）</dt>
<dd>
<p>提供自定义<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/hql/spi/id/MultiTableBulkIdStrategy.html"><code>org.hibernate.hql.spi.id.MultiTableBulkIdStrategy</code></a>用于处理多表批量HQL操作的实现。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hql.bulk_id_strategy.global_temporary.drop_tables</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>对于不支持本地表而仅支持全局表的数据库，此配置属性允许您在以下情况下DROP删除用于多表批量HQL操作的全局表： <code>SessionFactory</code>或者<code>EntityManagerFactory</code>已经关了。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hql.bulk_id_strategy.persistent.drop_tables</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>此配置属性由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/hql/spi/id/persistent/PersistentTableBulkIdStrategy.html"><code>PersistentTableBulkIdStrategy</code></a> ，它模拟不支持临时表的数据库的临时表。它遵循类似于全局临时表的ANSI SQL定义的模式，其中使用“会话ID”列来分割各个会话中的行。</p>
<div class="paragraph">
<p>通过此配置属性，您可以在以下情况下放弃用于多表批量HQL操作的表： <code>SessionFactory</code>或者<code>EntityManagerFactory</code>已经关了。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hql.bulk_id_strategy.persistent.schema</strong></code> （例如，数据库架构名称。默认情况下， <code>hibernate.default_schema</code>用来。）</dt>
<dd>
<p>此配置属性由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/hql/spi/id/persistent/PersistentTableBulkIdStrategy.html"><code>PersistentTableBulkIdStrategy</code></a> ，它模拟不支持临时表的数据库的临时表。它遵循类似于全局临时表的ANSI SQL定义的模式，其中使用“会话ID”列来分割各个会话中的行。</p>
<div class="paragraph">
<p>此配置属性定义用于存储用于批量HQL操作的临时表的数据库架构。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hql.bulk_id_strategy.persistent.catalog</strong></code> （例如，数据库目录名称。默认情况下， <code>hibernate.default_catalog</code>用来。）</dt>
<dd>
<p>此配置属性由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/hql/spi/id/persistent/PersistentTableBulkIdStrategy.html"><code>PersistentTableBulkIdStrategy</code></a> ，它模拟不支持临时表的数据库的临时表。它遵循类似于全局临时表的ANSI SQL定义的模式，其中使用“会话ID”列来分割各个会话中的行。</p>
<div class="paragraph">
<p>此配置属性定义用于存储用于批量HQL操作的临时表的数据库目录。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.legacy_limit_handler</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>指示是否使用的设定<code>org.hibernate.dialect.pagination.LimitHandler</code>牺牲性能优化以允许旧版4.x限制行为的实现。</p>
<div class="paragraph">
<p>旧版4.x行为通过避免使用偏移量值而倾向于在内存中执行分页，该值总体上是较差的性能。在5.x中，限制处理程序的行为会提高性能，因此，如果方言不支持偏移量，则会引发异常。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.query.conventional_java_constants</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>指示Java常量是否遵循<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">Java Naming约定的设置</a> 。</p>
<div class="paragraph">
<p>默认是<code>true</code> 。现有的应用程序可能要禁用此功能（设置它<code>false</code> ）（如果使用了非常规Java常量）。但是，使用非传统的Java常量会产生很大的性能开销，因为Hibernate无法确定是否应将别名视为Java常量。</p>
</div>
<div class="paragraph">
<p>请查看<a href="https://hibernate.atlassian.net/browse/HHH-4959">HHH-4959</a>了解更多详细信息。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurations-batch"><a class="anchor" href="#configurations-batch"></a> 24.9。批处理属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.jdbc.batch_size</strong></code> （例如5）</dt>
<dd>
<p>最大JDBC批处理大小。非零值将启用批量更新。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.order_inserts</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>强制Hibernate通过要插入的项的主键值对SQL插入进行排序。使用级联时，这将保留批处理。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.order_updates</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>强制Hibernate通过要更新的项目的主键值对SQL更新进行排序。这在使用级联时保留了批处理，并减少了高并发系统中事务死锁的可能性。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.batch_versioned_data</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>版本化的实体是否应包括在批处理中？</p>
<div class="paragraph">
<p>将此属性设置为<code>true</code>如果您的JDBC驱动程序从executeBatch（）返回正确的行数。此选项通常是安全的，但默认情况下处于禁用状态。如果启用，则Hibernate将批处理DML用于自动版本化的数据。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.batch_fetch_style</strong></code> （例如<code>LEGACY</code> （默认值））</dt>
<dd>
<p>命名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/loader/BatchFetchStyle.html"><code>BatchFetchStyle</code></a>使用。</p>
<div class="paragraph">
<p>可以指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/loader/BatchFetchStyle.html"><code>BatchFetchStyle</code></a>名称（不敏感地），或者<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/loader/BatchFetchStyle.html"><code>BatchFetchStyle</code></a>实例。 <code>LEGACY}</code>是默认值。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.batch.builder</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/batch/spi/BatchBuilder.html"><code>BatchBuilder</code></a>实现类类型或实际对象实例）</dt>
<dd>
<p>命名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/batch/spi/BatchBuilder.html"><code>BatchBuilder</code></a>实施使用。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="configurations-database-fetch"><a class="anchor" href="#configurations-database-fetch"></a> 24.9.1。获取属性</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.max_fetch_depth</strong></code> （例如，介于<code>0</code>和<code>3</code> ）</dt>
<dd>
<p>为单端关联设置外部联接获取树的最大深度。单端关联是一对一或多对一关联。值<code>0</code>禁用默认的外部联接获取。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.default_batch_fetch_size</strong></code> （例如<code>4</code> ， <code>8</code> ， 要么<code>16</code> ）</dt>
<dd>
<p>Hibernate批量提取关联的默认大小（可以批量提取延迟提取的关联，以防止出现N + 1查询问题）。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.fetch_size</strong></code> （例如<code>0</code>或整数）</dt>
<dd>
<p>非零值通过调用来确定JDBC的获取大小。 <code>Statement.setFetchSize()</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.use_scrollable_resultset</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>使Hibernate使用JDBC2可滚动结果集。此属性仅与用户提供的JDBC连接有关。否则，Hibernate将使用连接元数据。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.use_streams_for_binary</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>书写或阅读时使用流<code>binary</code>要么<code>serializable</code> JDBC的类型。这是系统级的属性。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.use_get_generated_keys</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>允许Hibernate使用JDBC3 <code>PreparedStatement.getGeneratedKeys()</code>插入后检索本机生成的键。您需要JDBC3 +驱动程序和JRE1.4 +。如果您的驱动程序在Hibernate标识符生成器方面有问题，请禁用此属性。默认情况下，它尝试从连接元数据中检测驱动程序功能。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jdbc.wrap_result_sets</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>启用JDBC结果集包装，以加快对损坏的JDBC驱动程序的列名查找。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.enable_lazy_load_no_trans</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在给定的事务持久性上下文之外初始化惰性代理或集合。</p>
<div class="paragraph">
<p>虽然启用此配置可以使<code>LazyInitializationException</code>不用了，最好使用可确保在关闭Session之前正确初始化所有属性的提取计划。</p>
</div>
<div class="paragraph">
<p>实际上，无论如何您都不应该启用此设置。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurations-logging"><a class="anchor" href="#configurations-logging"></a> 24.10。语句记录和统计</h3>
<div class="sect3">
<h4 id="_sql_statement_logging"><a class="anchor" href="#_sql_statement_logging"></a> 24.10.1。SQL语句记录</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.show_sql</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>将所有SQL语句写入控制台。这是设置日志类别的替代方法<code>org.hibernate.SQL</code>调试。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.format_sql</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>在日志和控制台中漂亮地打印SQL。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.use_sql_comments</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>如果为true，Hibernate会在SQL内生成注释，以便于调试。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_statistics_settings"><a class="anchor" href="#_statistics_settings"></a> 24.10.2。统计设置</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.generate_statistics</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>使Hibernate收集统计信息以进行性能调整。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.stats.factory</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/stat/spi/StatisticsFactory.html"><code>StatisticsFactory</code></a>实现或实际实例）</dt>
<dd>
<p>的<code>StatisticsFactory</code>允许您自定义如何收集Hibernate统计信息。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session.events.log</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>用于控制是否<code>org.hibernate.engine.internal.StatisticalLoggingSessionEventListener</code>在所有启用<code>Sessions</code> （除非已明确禁用给定<code>Session</code> ）。</p>
<div class="paragraph">
<p>此设置的默认值取决于<code>hibernate.generate_statistics</code> ，表示如果启用了统计信息，那么默认情况下也会启用会话指标的日志记录。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurations-cache"><a class="anchor" href="#configurations-cache"></a> 24.11。缓存属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.cache.region.factory_class</strong></code> （例如<code>jcache</code> ）</dt>
<dd>
<p>快捷方式名称（例如<code>jcache</code> ， <code>ehcache</code> ）或标准名称<code>RegionFactory</code>实现类。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.default_cache_concurrency_strategy</strong></code></dt>
<dd>
<p>用于提供默认名称的设置<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CacheConcurrencyStrategy.html"><code>CacheConcurrencyStrategy</code></a>使用时<code>@javax.persistence.Cacheable</code>要么<code>@org.hibernate.annotations.Cache</code> 。 <code>@org.hibernate.annotations.Cache</code>用于覆盖全局设置。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.use_minimal_puts</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>优化第二级缓存操作以最大程度地减少写入，但需要更频繁地读取。这对于群集缓存最有用，并且默认情况下对群集缓存实现启用。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.use_query_cache</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>启用查询缓存。您仍然需要将单个查询设置为可缓存。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.use_second_level_cache</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>启用/禁用二级缓存，默认情况下启用，尽管默认情况下<code>RegionFactor</code>是<code>NoCachingRegionFactory</code> （这意味着没有实际的缓存实现）。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.query_cache_factory</strong></code> （例如，完全合格的班级名称）</dt>
<dd>
<p>一个习俗<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/cache/spi/QueryCacheFactory.html"><code>QueryCacheFactory</code></a>接口。默认为内置<code>StandardQueryCacheFactory</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.region_prefix</strong></code> （例如一个字符串）</dt>
<dd>
<p>二级缓存区域名称的前缀。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.use_structured_entries</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>强制Hibernate以更易于理解的格式将数据存储在二级缓存中。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.auto_evict_collection_cache</strong></code> （例如<code>true</code>要么<code>false</code> （默认值：false））</dt>
<dd>
<p>当元素中的某个元素出现时，启用双向关联的集合缓存的自动驱逐<code>ManyToOne</code>集合的添加/更新/删除未正确管理<code>OneToMany</code>侧。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.cache.use_reference_entries</strong></code> （例如<code>true</code>要么<code>false</code> ）</dt>
<dd>
<p>优化第二级缓存操作以将不具有关联的不可变实体（也称为“引用”）直接存储到缓存中，在这种情况下，可以避免反汇编和深度复制操作。此属性的默认值为<code>false</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.classcache</strong></code> （例如<code>hibernate.ejb.classcache.org.hibernate.ejb.test.Item</code> = <code>read-write</code> ）</dt>
<dd>
<p>为指定区域设置关联的实体类缓存并发策略。缓存配置应遵循以下模式<code>hibernate.ejb.classcache.<fully.qualified.Classname></code> usage [，region]其中use是使用的缓存策略，并在区域中缓存区域名称。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.collectioncache</strong></code> （例如<code>hibernate.ejb.collectioncache.org.hibernate.ejb.test.Item.distributors</code> = <code>read-write, RegionName</code> ）</dt>
<dd>
<p>为指定区域设置关联的集合缓存并发策略。缓存配置应遵循以下模式<code>hibernate.ejb.collectioncache.<fully.qualified.Classname>.<role></code> usage [，region]其中use是使用的缓存策略，区域是缓存区域名称</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-infinispan"><a class="anchor" href="#configurations-infinispan"></a> 24.12。Infinispan属性</h3>
<div class="paragraph">
<p>有关如何自定义Infinispan二级缓存提供程序的更多详细信息，请查阅《 <a href="http://infinispan.org/docs/stable/user_guide/user_guide.html#configuration_properties">Infinispan用户指南》。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="configurations-transactions"><a class="anchor" href="#configurations-transactions"></a> 24.13。交易属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.transaction.jta.platform</strong></code> （例如<code>JBossAS</code> ， <code>BitronixJtaPlatform</code> ）</dt>
<dd>
<p>命名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.html"><code>JtaPlatform</code></a>用于与JTA系统集成的实现。可以引用一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.html"><code>JtaPlatform</code></a>实例或名称<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.html"><code>JtaPlatform</code></a>实现类</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jta.prefer_user_transaction</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>我们是否应该使用<code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform#retrieveUserTransaction</code>过度使用<code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform#retrieveTransactionManager</code></p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.transaction.jta.platform_resolver</strong></code></dt>
<dd>
<p>命名<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatformResolver.html"><code>JtaPlatformResolver</code></a>实施使用。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jta.cacheTransactionManager</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>配置值键，用于指示可以安全缓存。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jta.cacheUserTransaction</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>配置值键，用于指示可以安全缓存。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.transaction.flush_before_completion</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>导致在事务的完成阶段之前刷新会话。如果可能，请改用内置的自动会话上下文管理。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.transaction.auto_close_session</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>使会话在事务的完成阶段之后关闭。如果可能，请改用内置的自动会话上下文管理。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.transaction.coordinator_class</strong></code></dt>
<dd>
<p>命名执行<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/transaction/spi/TransactionCoordinatorBuilder.html"><code>TransactionCoordinatorBuilder</code></a>用于创建<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/transaction/spi/TransactionCoordinator.html"><code>TransactionCoordinator</code></a>实例。</p>
<div class="paragraph">
<p>可以是“ TransactionCoordinatorBuilder”实例， <code>TransactionCoordinatorBuilder</code>实作<code>Class</code>参考，一个<code>TransactionCoordinatorBuilder</code>实现类名称（完全限定名称）或简称。</p>
</div>
<div class="paragraph">
<p>为此设置定义了以下简称：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>jdbc</code></dt>
<dd>
<p>通过调用来管理交易<code>java.sql.Connection</code> （非JPA应用程序的默认设置）</p>
</dd>
<dt class="hdlist1"><code>jta</code></dt>
<dd>
<p>通过JTA管理交易。请参阅<a href="#bootstrap-jpa-compliant">Java EE引导</a></p>
<div class="paragraph">
<p>如果JPA应用程序未提供以下设置<code>hibernate.transaction.coordinator_class</code> ，Hibernate将根据持久性单元的事务类型自动构建适当的事务协调器。</p>
</div>
<div class="paragraph">
<p>如果非JPA应用程序未提供以下设置<code>hibernate.transaction.coordinator_class</code> ，Hibernate将使用<code>jdbc</code>作为默认值。如果应用程序实际使用基于JTA的事务，则此默认值将导致问题。使用基于JTA的事务的非JPA应用程序应明确设置<code>hibernate.transaction.coordinator_class=jta</code>或提供风俗习惯<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/transaction/TransactionCoordinatorBuilder.html"><code>TransactionCoordinatorBuilder</code></a>建立一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/resource/transaction/TransactionCoordinator.html"><code>TransactionCoordinator</code></a>可以与基于JTA的事务正确协调。</p>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jta.track_by_thread</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>事务可以由另一个线程（“按线程跟踪”）而不是原始应用程序回滚。这样的示例包括由后台收割者线程处理的JTA事务超时。</p>
<div class="paragraph">
<p>处理这种情况的能力要求每次调用Session时都要检查线程ID，因此启用它肯定会对性能产生影响。</p>
</div>
</dd>
<dt class="hdlist1"><span class="line-through"><code><strong>hibernate.transaction.factory_class</strong></code></span></dt>
<dd>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">这是一个已过时的旧设置，您应该使用<code>hibernate.transaction.jta.platform</code>代替。
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jta.allowTransactionAccess</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>它允许访问底层<code>org.hibernate.Transaction</code>即使使用JTA也是如此，因为JPA规范禁止这种行为。</p>
<div class="paragraph">
<p>如果此配置属性设置为<code>true</code> ，授予基础访问权限<code>org.hibernate.Transaction</code> 。如果设置为<code>false</code> ，您将无法访问<code>org.hibernate.Transaction</code> 。</p>
</div>
<div class="paragraph">
<p>默认行为是允许访问，除非<code>Session</code>通过JPA引导。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-multi-tenancy"><a class="anchor" href="#configurations-multi-tenancy"></a> 24.14。多租户设置</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.multiTenancy</strong></code> （例如<code>NONE</code> （默认值）， <code>SCHEMA</code> ， <code>DATABASE</code>和<code>DISCRIMINATOR</code> （尚未实施）</dt>
<dd>
<p>正在使用的多租户策略。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.multi_tenant_connection_provider</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>命名一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/connections/spi/MultiTenantConnectionProvider.html"><code>MultiTenantConnectionProvider</code></a>实施使用。如<code>MultiTenantConnectionProvider</code>也是一项服务，可以直接通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/registry/StandardServiceRegistryBuilder.html"><code>StandardServiceRegistryBuilder</code></a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.tenant_identifier_resolver</strong></code></dt>
<dd>
<p>命名一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/context/spi/CurrentTenantIdentifierResolver.html"><code>CurrentTenantIdentifierResolver</code></a>解决解析当前租户标识的实现，以便调用<code>SessionFactory#openSession()</code>会得到一个<code>Session</code>连接到正确的租户。</p>
<div class="paragraph">
<p>可以是<code>CurrentTenantIdentifierResolver</code>实例<code>CurrentTenantIdentifierResolver</code>实作<code>Class</code>对象引用或<code>CurrentTenantIdentifierResolver</code>实现类名称。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.multi_tenant.datasource.identifier_for_any</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>当。。。的时候<code>hibernate.connection.datasource</code>属性值解析为<code>javax.naming.Context</code>对象，此配置属性定义用于查找以下内容的JNDI名称： <code>DataSource</code>用于获取初始<code>Connection</code>它用于访问基础数据库的数据库元数据（在我们没有租户ID的情况下，例如启动处理）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-hbmddl"><a class="anchor" href="#configurations-hbmddl"></a> 24.15。自动模式生成</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.auto</strong></code> （例如<code>none</code> （默认值）， <code>create-only</code> ， <code>drop</code> ， <code>create</code> ， <code>create-drop</code> ， <code>validate</code>和<code>update</code> ）</dt>
<dd>
<p>设定执行<code>SchemaManagementTool</code>作为<code>SessionFactory</code>生命周期。有效选项由<code>externalHbm2ddlName</code>的价值<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/Action.html"><code>Action</code></a>枚举：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>将不执行任何操作。</p>
</dd>
<dt class="hdlist1"><code>create-only</code></dt>
<dd>
<p>将创建数据库创建。</p>
</dd>
<dt class="hdlist1"><code>drop</code></dt>
<dd>
<p>数据库删除将被生成。</p>
</dd>
<dt class="hdlist1"><code>create</code></dt>
<dd>
<p>将创建数据库删除，然后创建数据库。</p>
</dd>
<dt class="hdlist1"><code>create-drop</code></dt>
<dd>
<p>删除架构，并在SessionFactory启动时重新创建它。此外，在SessionFactory关闭时删除架构。</p>
</dd>
<dt class="hdlist1"><code>validate</code></dt>
<dd>
<p>验证数据库架构</p>
</dd>
<dt class="hdlist1"><code>update</code></dt>
<dd>
<p>更新数据库架构</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.database.action</strong></code> （例如<code>none</code> （默认值）， <code>create-only</code> ， <code>drop</code> ， <code>create</code> ， <code>create-drop</code> ， <code>validate</code>和<code>update</code> ）</dt>
<dd>
<p>设定执行<code>SchemaManagementTool</code>作为<code>SessionFactory</code>生命周期。有效选项由<code>externalJpaName</code>的价值<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/Action.html"><code>Action</code></a>枚举：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>将不执行任何操作。</p>
</dd>
<dt class="hdlist1"><code>create</code></dt>
<dd>
<p>将创建数据库创建。</p>
</dd>
<dt class="hdlist1"><code>drop</code></dt>
<dd>
<p>数据库删除将被生成。</p>
</dd>
<dt class="hdlist1"><code>drop-and-create</code></dt>
<dd>
<p>将创建数据库删除，然后创建数据库。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.scripts.action</strong></code> （例如<code>none</code> （默认值）， <code>create-only</code> ， <code>drop</code> ， <code>create</code> ， <code>create-drop</code> ， <code>validate</code>和<code>update</code> ）</dt>
<dd>
<p>设定执行<code>SchemaManagementTool</code>将命令写入DDL脚本文件的操作。有效选项由<code>externalJpaName</code>的价值<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/Action.html"><code>Action</code></a>枚举：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>将不执行任何操作。</p>
</dd>
<dt class="hdlist1"><code>create</code></dt>
<dd>
<p>将创建数据库创建。</p>
</dd>
<dt class="hdlist1"><code>drop</code></dt>
<dd>
<p>数据库删除将被生成。</p>
</dd>
<dt class="hdlist1"><code>drop-and-create</code></dt>
<dd>
<p>将创建数据库删除，然后创建数据库。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation-connection</strong></code></dt>
<dd>
<p>允许通过特定<code>java.sql.Connection</code>要使用的实例<code>SchemaManagementTool</code></p>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.database-product-name</strong></code></dt>
<dd>
<p>在与基础数据库的连接不可用（主要是在生成脚本中）的情况下，指定数据库提供程序的名称。在这种情况下， <em>必须</em>指定此设置的值。</p>
<div class="paragraph">
<p>此设置的值应与的返回值匹配<code>java.sql.DatabaseMetaData#getDatabaseProductName()</code>用于目标数据库。</p>
</div>
<div class="paragraph">
<p>另外，指定<code>javax.persistence.database-major-version</code>和/或<code>javax.persistence.database-minor-version</code>可能需要确切了解如何生成所需的架构命令。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.database-major-version</strong></code></dt>
<dd>
<p>指定基础数据库的主版本，由<code>java.sql.DatabaseMetaData#getDatabaseMajorVersion</code>用于目标数据库。</p>
<div class="paragraph">
<p>该值用于在以下情况下更精确地确定如何为基础数据库执行模式生成任务： <code>javax.persistence.database-product-name</code>没有提供足够的区分。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.database-minor-version</strong></code></dt>
<dd>
<p>指定基础数据库的次版本，由<code>java.sql.DatabaseMetaData#getDatabaseMinorVersion</code>用于目标数据库。</p>
<div class="paragraph">
<p>该值用于在以下情况下更精确地确定如何为基础数据库执行模式生成任务： <code>javax.persistence.database-product-name</code>和<code>javax.persistence.database-major-version</code>没有提供足够的区分。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.create-source</strong></code></dt>
<dd>
<p>指定是否基于对象/关系映射元数据，DDL脚本或两者的组合来确定用于模式创建的模式生成命令。看到<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/SourceType.html"><code>SourceType</code></a>获取有效的一组值。</p>
<div class="paragraph">
<p>如果未指定任何值，则采用默认值，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果指定了源脚本（每个<code>javax.persistence.schema-generation.create-script-source</code> ）， 然后<code>script</code>假设</p>
</li>
<li>
<p>除此以外， <code>metadata</code>假设</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.drop-source</strong></code></dt>
<dd>
<p>指定是否要基于对象/关系映射元数据，DDL脚本或两者的组合来确定用于模式删除的模式生成命令。看到<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/SourceType.html"><code>SourceType</code></a>获取有效的一组值。</p>
<div class="paragraph">
<p>如果未指定任何值，则采用默认值，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果指定了源脚本（每个<code>javax.persistence.schema-generation.create-script-source</code> ），然后<code>script</code>假设选项</p>
</li>
<li>
<p>除此以外， <code>metadata</code>假设</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.create-script-source</strong></code></dt>
<dd>
<p>指定<code>create</code>脚本文件为<code>java.io.Reader</code>配置为读取DDL脚本文件或指定文件的字符串<code>java.net.URL</code>用于DDL脚本。</p>
<div class="paragraph">
<p>Hibernate状态在历史上也被接受<code>hibernate.hbm2ddl.import_files</code>为了类似的目的，但是<code>javax.persistence.schema-generation.create-script-source</code>应该优先于<code>hibernate.hbm2ddl.import_files</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.drop-script-source</strong></code></dt>
<dd>
<p>指定<code>drop</code>脚本文件为<code>java.io.Reader</code>配置为读取DDL脚本文件或指定文件的字符串<code>java.net.URL</code>用于DDL脚本。</p>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.scripts.create-target</strong></code></dt>
<dd>
<p>对于以下情况<code>javax.persistence.schema-generation.scripts.action</code>值表示应将架构创建命令写入DDL脚本文件， <code>javax.persistence.schema-generation.scripts.create-target</code>指定一个<code>java.io.Writer</code>配置为输出DDL脚本或指定DDL脚本文件URL的字符串。</p>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.schema-generation.scripts.drop-target</strong></code></dt>
<dd>
<p>对于以下情况<code>javax.persistence.schema-generation.scripts.action</code>值表示应将架构删除命令写入DDL脚本文件， <code>javax.persistence.schema-generation.scripts.drop-target</code>指定一个<code>java.io.Writer</code>配置为输出DDL脚本或指定DDL脚本文件URL的字符串。</p>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.hibernate.hbm2ddl.import_files</strong></code> （例如<code>import.sql</code> （默认值））</dt>
<dd>
<p>在执行过程中执行的包含SQL DML语句的可选文件的名称，以逗号分隔。 <code>SessionFactory</code>创建。文件顺序很重要，给定文件的语句在下一个语句之前执行。</p>
<div class="paragraph">
<p>这些语句仅在创建架构时执行，这意味着<code>hibernate.hbm2ddl.auto</code>被设定为<code>create</code> ， <code>create-drop</code> ， 要么<code>update</code> 。
<code>javax.persistence.schema-generation.create-script-source</code> / <code>javax.persistence.schema-generation.drop-script-source</code>应该是首选。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.sql-load-script-source</strong></code></dt>
<dd>
<p>JPA的变体<code>hibernate.hbm2ddl.import_files</code> 。指定一个<code>java.io.Reader</code>配置为读取SQL加载脚本或指定文件的字符串<code>java.net.URL</code>用于SQL加载脚本。“ SQL加载脚本”是执行一些数据库初始化（INSERT等）的脚本。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.import_files_sql_extractor</strong></code></dt>
<dd>
<p>参考<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/hbm2ddl/ImportSqlCommandExtractor.html"><code>ImportSqlCommandExtractor</code></a>实现类，用于解析由定义的源/导入文件<code>javax.persistence.schema-generation.create-script-source</code> ， <code>javax.persistence.schema-generation.drop-script-source</code>要么<code>hibernate.hbm2ddl.import_files</code> 。</p>
<div class="paragraph">
<p>引用可以引用一个实例，一个Class实现<code>ImportSqlCommandExtractor</code>的全限定名称<code>ImportSqlCommandExtractor</code>实施。如果给出了完全限定的名称，则实现必须提供一个无参数的构造函数。</p>
</div>
<div class="paragraph">
<p>默认值为<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/hbm2ddl/SingleLineSqlCommandExtractor.html"><code>SingleLineSqlCommandExtractor</code></a> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.create_namespaces</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>指定是否也自动创建数据库模式/目录。</p>
</dd>
<dt class="hdlist1"><code><strong>javax.persistence.create-database-schemas</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>JPA的变体<code>hibernate.hbm2ddl.create_namespaces</code> 。指定除了创建数据库对象（表，序列，约束等）之外，持久性提供程序是否还将创建数据库模式。此布尔属性的值应设置为<code>true</code>如果持久性提供程序要在数据库中创建架构或生成包含“ CREATE SCHEMA”命令的DDL。</p>
<div class="paragraph">
<p>如果未提供此属性（或显式<code>false</code> ），提供程序不应尝试创建数据库模式。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.schema_filter_provider</strong></code></dt>
<dd>
<p>用于指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/spi/SchemaFilterProvider.html"><code>SchemaFilterProvider</code></a>供...使用<code>create</code> ， <code>drop</code> ， <code>migrate</code>和<code>validate</code>对数据库模式的操作。
<code>SchemaFilterProvider</code>提供可用于将这些操作的范围限制为特定名称空间，表和序列的过滤器。默认情况下包括所有对象。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.jdbc_metadata_extraction_strategy</strong></code> （例如<code>grouped</code> （默认值）或<code>individually</code> ）</dt>
<dd>
<p>设置选择用于访问JDBC元数据的策略。有效选项由<code>strategy</code>的价值<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/JdbcMetadaAccessStrategy.html"><code>JdbcMetadaAccessStrategy</code></a>枚举：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>grouped</code></dt>
<dd>
<p><a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/spi/SchemaMigrator.html"><code>SchemaMigrator</code></a>和<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/spi/SchemaValidator.html"><code>SchemaValidator</code></a>执行一个<code>java.sql.DatabaseMetaData#getTables(String, String, String, String[])</code>调用以检索所有数据库表，以确定是否所有<code>javax.persistence.Entity</code>有一个对应的映射数据库表。此策略可能需要<code>hibernate.default_schema</code>和/或<code>hibernate.default_catalog</code>即将呈现。</p>
</dd>
<dt class="hdlist1"><code>individually</code></dt>
<dd>
<p><a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/spi/SchemaMigrator.html"><code>SchemaMigrator</code></a>和<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/schema/spi/SchemaValidator.html"><code>SchemaValidator</code></a>执行一个<code>java.sql.DatabaseMetaData#getTables(String, String, String, String[])</code>呼吁每个<code>javax.persistence.Entity</code>为了确定是否存在相应的数据库表。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.delimiter</strong></code> （例如<code>;</code> ）</dt>
<dd>
<p>标识用于在脚本输出中分隔模式管理语句的定界符。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.schema_management_tool</strong></code> （例如，架构名称）</dt>
<dd>
<p>用于指定<code>SchemaManagementTool</code>用于执行模式管理。默认使用<code>HibernateSchemaManagementTool</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.synonyms</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>如果启用，则允许架构更新和验证以支持同义词。由于这可能会返回重复的表（尤其是在Oracle中），因此默认情况下处于禁用状态。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.extra_physical_table_types</strong></code> （例如<code>BASE TABLE</code> ）</dt>
<dd>
<p>标识以逗号分隔的值列表，以指定默认值以外的其他表类型<code>TABLE</code>值，以识别为通过架构更新，创建和验证来定义物理表。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.schema_update.unique_constraint_strategy</strong></code> （例如<code>DROP_RECREATE_QUIETLY</code> ， <code>RECREATE_QUIETLY</code> ， <code>SKIP</code> ）</dt>
<dd>
<p>唯一列和唯一键在大多数方言中都使用唯一约束。
<code>SchemaUpdate</code>需要创建这些约束，但是数据库对查找现有约束的支持极为不一致。此外，未明确命名的唯一约束使用随机生成的字符。</p>
<div class="paragraph">
<p>因此， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tool/hbm2ddl/UniqueConstraintSchemaUpdateStrategy.html"><code>UniqueConstraintSchemaUpdateStrategy</code></a>提供以下选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>DROP_RECREATE_QUIETLY</code></dt>
<dd>
<p>默认选项。尝试删除，然后（重新）创建每个唯一约束。忽略任何引发的异常。</p>
</dd>
<dt class="hdlist1"><code>RECREATE_QUIETLY</code></dt>
<dd>
<p>尝试（重新）创建唯一约束，如果约束已经存在，则忽略抛出的异常</p>
</dd>
<dt class="hdlist1"><code>SKIP</code></dt>
<dd>
<p>不要尝试在架构更新上创建唯一约束。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.charset_name</strong></code> （例如<code>Charset.defaultCharset()</code> ）</dt>
<dd>
<p>定义用于所有输入/输出模式生成资源的字符集（编码）。默认情况下，Hibernate使用的默认字符集为<code>Charset.defaultCharset()</code> 。该配置属性允许您覆盖默认的JVM设置，以便您可以指定在读写模式生成资源（例如，文件，URL）时使用哪种编码。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.hbm2ddl.halt_on_error</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>模式迁移工具是否应因错误而停止，因此终止引导过程。默认情况下， <code>EntityManagerFactory</code>要么<code>SessionFactory</code>即使架构迁移引发异常，也会被创建。为避免这种默认行为，请将此属性值设置为<code>true</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-exception-handling"><a class="anchor" href="#configurations-exception-handling"></a> 24.16。异常处理</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.jdbc.sql_exception_converter</strong></code> （例如，实施类的全限定名称<code>SQLExceptionConverter</code> ）</dt>
<dd>
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/exception/spi/SQLExceptionConverter.html"><code>SQLExceptionConverter</code></a>用于转换<code>SQLExceptions</code>到冬眠的<code>JDBCException</code>层次结构。默认是使用配置的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/dialect/Dialect.html"><code>Dialect</code></a>的首选<code>SQLExceptionConverter</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.native_exception_handling_51_compliance</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>指示是否针对<code>SessionFactory</code>通过Hibernate的本机引导构建的行为应与Hibernate ORM 5.1中的本机异常处理相同。设置为<code>true</code> ， <code>HibernateException</code>不会根据JPA规范进行包装或转换。此设置将被忽略<code>SessionFactory</code>通过JPA引导程序构建。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-session-events"><a class="anchor" href="#configurations-session-events"></a> 24.17。会议活动</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.session.events.auto</strong></code></dt>
<dd>
<p>实施<code>SessionEventListener</code>接口。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session_factory.interceptor</strong></code> （例如<code>org.hibernate.EmptyInterceptor</code> （默认值））</dt>
<dd>
<p>命名一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/Interceptor"><code>Interceptor</code></a>实施适用于每个<code>Session</code>由当前创建<code>org.hibernate.SessionFactory</code></p>
<div class="paragraph">
<p>可以参考：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Interceptor</code>实例</p>
</li>
<li>
<p><code>Interceptor</code>实作<code>Class</code>对象参考</p>
</li>
<li>
<p><code>Interceptor</code>实现类名称</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><span class="line-through"><code><strong>hibernate.ejb.interceptor</strong></code></span> （例如<code>hibernate.session_factory.interceptor</code> （默认值））</dt>
<dd>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">弃用的设置。使用<code>hibernate.session_factory.session_scoped_interceptor</code>代替。
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session_factory.session_scoped_interceptor</strong></code> （例如，完全合格的班级名称或班级参考）</dt>
<dd>
<p>命名一个<code>org.hibernate.Interceptor</code>适用于<code>org.hibernate.SessionFactory</code>并传播到每个<code>Session</code>从创建<code>SessionFactory</code> 。</p>
<div class="paragraph">
<p>此设置标识一个<code>Interceptor</code>适用于每个<code>Session</code>从打开<code>SessionFactory</code> ，但与<code>hibernate.session_factory.interceptor</code> ，是<code>Interceptor</code>用于每个<code>Session</code> 。</p>
</div>
<div class="paragraph">
<p>可以参考：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Interceptor</code>实例</p>
</li>
<li>
<p><code>Interceptor</code>实作<code>Class</code>对象参考</p>
</li>
<li>
<p><code>java.util.function.Supplier</code>用于检索<code>Interceptor</code>实例。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">具体来说，此设置无法命名<code>Interceptor</code>实例。
</td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><span class="line-through"><code><strong>hibernate.ejb.interceptor.session_scoped</strong></code></span> （例如，完全合格的班级名称或班级参考）</dt>
<dd>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">弃用的设置。使用<code>hibernate.session_factory.session_scoped_interceptor</code>代替。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可选的Hibernate拦截器。</p>
</div>
<div class="paragraph">
<p>拦截器实例特定于给定的Session实例（因此不是线程安全的）必须实现<code>org.hibernate.Interceptor</code>并有一个无参数的构造函数。</p>
</div>
<div class="paragraph">
<p>此属性不能与<code>hibernate.ejb.interceptor</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.session_factory_observer</strong></code> （例如，完全合格的班级名称或班级参考）</dt>
<dd>
<p>指定一个<code>SessionFactoryObserver</code>应用于SessionFactory。该类必须具有无参数构造函数。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.event</strong></code> （例如<code>hibernate.ejb.event.pre-load</code> = <code>com.acme.SecurityListener,com.acme.AuditListener</code> ）</dt>
<dd>
<p>给定事件类型的事件侦听器列表。事件侦听器列表是用逗号分隔的完全限定的类名称列表。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-jmx"><a class="anchor" href="#configurations-jmx"></a> 24.18。JMX设置</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.jmx.enabled</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>启用JMX。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jmx.usePlatformServer</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>使用平台MBeanServer，由<code>ManagementFactory#getPlatformMBeanServer()</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jmx.agentId</strong></code></dt>
<dd>
<p>关联的代理标识符<code>MBeanServer</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jmx.defaultDomain</strong></code></dt>
<dd>
<p>关联域名<code>MBeanServer</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jmx.sessionFactoryName</strong></code></dt>
<dd>
<p>的<code>SessionFactory</code>附加到对象名称的名称，该对象名称是向可管理Bean注册的。如果为null，则<code>hibernate.session_factory_name</code>使用配置值。</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.core</strong></code></dt>
<dd>
<p>默认对象域附加到可管理Bean所注册到的对象名称上。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-jacc"><a class="anchor" href="#configurations-jacc"></a> 24.19。JACC设置</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.jacc.enabled</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>是否启用了JACC？</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jacc</strong></code> （例如<code>hibernate.jacc.allowed.org.jboss.ejb3.test.jacc.AllEntity</code> ）</dt>
<dd>
<p>属性名称定义角色（例如， <code>allowed</code> ）和实体类名称（例如<code>org.jboss.ejb3.test.jacc.AllEntity</code> ），而属性值定义了授权操作（例如<code>insert,update,read</code> ）。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jacc_context_id</strong></code></dt>
<dd>
<p>一个字符串，用于标识要返回其PolicyConfiguration接口的策略上下文。传递给此参数的值不能为null。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-classloader"><a class="anchor" href="#configurations-classloader"></a> 24.20。ClassLoaders属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.classLoaders</strong></code></dt>
<dd>
<p>用于定义一个<code>java.util.Collection<ClassLoader></code>或者<code>ClassLoader</code> Hibernate实例应用于类加载和资源查找。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.classLoader.application</strong></code></dt>
<dd>
<p>命名<code>ClassLoader</code>用于加载用户应用程序类。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.classLoader.resources</strong></code></dt>
<dd>
<p>命名<code>ClassLoader</code> Hibernate应该用于执行资源加载。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.classLoader.hibernate</strong></code></dt>
<dd>
<p>命名<code>ClassLoader</code>负责加载Hibernate类。默认情况下，这是<code>ClassLoader</code>加载了此类。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.classLoader.environment</strong></code></dt>
<dd>
<p>命名<code>ClassLoader</code>当Hibernate无法在<code>hibernate.classLoader.application</code>要么<code>hibernate.classLoader.hibernate</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-bootstrap"><a class="anchor" href="#configurations-bootstrap"></a> 24.21。引导程序属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.integrator_provider</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/boot/spi/IntegratorProvider.html"><code>IntegratorProvider</code></a> ）</dt>
<dd>
<p>用于定义列表<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/integrator/spi/Integrator.html"><code>Integrator</code></a>在引导过程中用于集成各种服务。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.strategy_registration_provider</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/boot/spi/StrategyRegistrationProviderList.html"><code>StrategyRegistrationProviderList</code></a> ）</dt>
<dd>
<p>用于定义列表<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/registry/selector/StrategyRegistrationProvider.html"><code>StrategyRegistrationProvider</code></a>它在引导过程中用于提供策略选择器的注册。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.type_contributors</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/boot/spi/TypeContributorList.html"><code>TypeContributorList</code></a> ）</dt>
<dd>
<p>用于定义列表<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/boot/model/TypeContributor.html"><code>TypeContributor</code></a>在引导过程中用于贡献类型。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.persister.resolver</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/spi/PersisterClassResolver.html"><code>PersisterClassResolver</code></a>或一个<code>PersisterClassResolver</code>实例）</dt>
<dd>
<p>用于定义<code>PersisterClassResolver</code>界面，可用于自定义实体或集合的持久化方式。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.persister.factory</strong></code> （例如， <a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/spi/PersisterFactory.html"><code>PersisterFactory</code></a>或一个<code>PersisterFactory</code>实例）</dt>
<dd>
<p>像一个<code>PersisterClassResolver</code> ， <code>PersisterFactory</code>可用于自定义实体或集合的持久化方式。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.service.allow_crawling</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>搜寻所有可用的服务绑定，以进行给定Hibernate的备用注册<code>Service</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.metadata_builder_contributor</strong></code> （例如，一个实例的实例，类或完全限定的类名称<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/boot/spi/MetadataBuilderContributor.html"><code>MetadataBuilderContributor</code></a> ）</dt>
<dd>
<p>用于定义实例，类或完全限定的类名称<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/boot/spi/MetadataBuilderContributor.html"><code>MetadataBuilderContributor</code></a>可以用来配置<code>MetadataBuilder</code>通过JPA引导时<code>EntityManagerFactory</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-misc"><a class="anchor" href="#configurations-misc"></a> 24.22。杂项属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.dialect_resolvers</strong></code></dt>
<dd>
<p>命名其他名称<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/dialect/spi/DialectResolver.html"><code>DialectResolver</code></a>向标准注册的实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/engine/jdbc/dialect/spi/DialectFactory.html"><code>DialectFactory</code></a></p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session_factory_name</strong></code> （例如，JNDI名称）</dt>
<dd>
<p>用于命名Hibernate的设置<code>SessionFactory</code> 。命名<code>SessionFactory</code>只要在每个JVM上使用相同的名称，它就可以在JVM之间正确地序列化它。</p>
<div class="paragraph">
<p>如果<code>hibernate.session_factory_name_is_jndi</code>被设定为<code>true</code> ，这也是<code>SessionFactory</code>在启动时绑定到JNDI，并且可以从JNDI获得它。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.session_factory_name_is_jndi</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>值是否由<code>hibernate.session_factory_name</code>表示一个JNDI命名空间， <code>org.hibernate.SessionFactory</code>应该绑定并可以访问？</p>
<div class="paragraph">
<p>默认为<code>true</code>向后兼容。设置为<code>false</code>如果出于序列化目的需要命名SessionFactory，但是在运行时环境中不存在可写的JNDI上下文，或者用户只是不想使用JNDI。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.entitymanager_factory_name</strong></code> （例如，默认情况下，使用持久性单元名称，否则使用随机生成的UUID）</dt>
<dd>
<p>在内部，Hibernate跟踪所有<code>EntityManagerFactory</code>实例使用<code>EntityManagerFactoryRegistry</code> 。该名称用作识别给定键的键<code>EntityManagerFactory</code>参考。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.cfgfile</strong></code> （例如<code>hibernate.cfg.xml</code> （默认值））</dt>
<dd>
<p>用于配置Hibernate的XML配置文件。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.discard_pc_on_close</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>如果为true，则将丢弃持久性上下文（请考虑<code>clear()</code>调用该方法时。否则，持久化上下文将一直保持活动状态，直到事务完成：所有对象都将保持托管状态，并且所有更改都将与数据库同步（默认为false，即等待事务完成）。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.ejb.metamodel.population</strong></code> （例如<code>enabled</code>要么<code>disabled</code> ， 要么<code>ignoreUnsupported</code> （默认值））</dt>
<dd>
<p>该设置指示是否构建JPA类型。</p>
<div class="paragraph">
<p>接受三个值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">已启用</dt>
<dd>
<p>做构建</p>
</dd>
<dt class="hdlist1">残障人士</dt>
<dd>
<p>不做构建</p>
</dd>
<dt class="hdlist1">不支持</dt>
<dd>
<p>进行构建，但忽略任何会导致失败的非JPA功能（例如<code>@Any</code>注解）。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jpa.static_metamodel.population</strong></code> （例如<code>enabled</code>要么<code>disabled</code> ， 要么<code>skipUnsupported</code> （默认值））</dt>
<dd>
<p>该设置控制我们是否查找JPA <em>静态元模型</em>类并填充它们。</p>
<div class="paragraph">
<p>接受三个值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">已启用</dt>
<dd>
<p>做人口</p>
</dd>
<dt class="hdlist1">残障人士</dt>
<dd>
<p>不做人口</p>
</dd>
<dt class="hdlist1">skip不支持</dt>
<dd>
<p>进行填充，但忽略任何会导致填充失败的非JPA功能（例如<code>@Any</code>注解）。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.delay_cdi_access</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>定义对CDI的延迟访问<code>BeanManager</code> 。从5.1开始，CDI自举的首选方法是通过<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/jpa/event/spi/jpa/ExtendedBeanManager.html"><code>ExtendedBeanManager</code></a> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.resource.beans.container</strong></code> （例如，完全合格的班级名称）</dt>
<dd>
<p>标识一个明确的<code>org.hibernate.resource.beans.container.spi.BeanContainer</code>要使用的。</p>
<div class="paragraph">
<p>请注意，对于基于CDI的容器，无需进行设置。只需通过<code>BeanManager</code>通过使用<code>javax.persistence.bean.manager</code>并可选地指定<code>hibernate.delay_cdi_access</code> 。</p>
</div>
<div class="paragraph">
<p>此设置更适合于集成非CDI bean容器，例如Spring。</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.allow_update_outside_transaction</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>允许在事务边界之外执行更新操作的设置。</p>
<div class="paragraph">
<p>接受两个值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">真正</dt>
<dd>
<p>允许从事务中清除更新</p>
</dd>
<dt class="hdlist1">假</dt>
<dd>
<p>不允许</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><strong>hibernate.collection_join_subquery</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>该设置指示是否应将新的JOINS over收集表重写为子查询。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.allow_refresh_detached_entity</strong></code> （例如<code>true</code> （使用Hibernate本机引导时的默认值）或<code>false</code> （使用JPA自举时的默认值）</dt>
<dd>
<p>允许通话的设定<code>javax.persistence.EntityManager#refresh(entity)</code>要么<code>Session#refresh(entity)</code>在独立实例上，即使<code>org.hibernate.Session</code>从JPA获得<code>javax.persistence.EntityManager</code> 。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.use_entity_where_clause_for_collections</strong></code> （例如， <code>true</code> （默认）或<code>false</code> ）</dt>
<dd>
<p>设置控制是否使用映射的实体的“ where”子句<code>@Where(clause="…​")</code>或<entity …="" where="…​">加载该类型的实体的一对多或多对多集合时要考虑到。</entity></p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.event.merge.entity_copy_observer</strong></code> （例如<code>disallow</code> （默认值）， <code>allow</code> ， <code>log</code> （仅用于测试目的）或完全合格的班级名称）</dt>
<dd>
<p>该设置指定在合并时检测到同一持久性实体（“实体副本”）的多个表示形式时，Hibernate将如何响应。</p>
<div class="paragraph">
<p>可能的值为：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">禁止（默认）</dt>
<dd>
<p>抛出<code>IllegalStateException</code>如果检测到实体副本</p>
</dd>
<dt class="hdlist1">允许</dt>
<dd>
<p>对检测到的每个实体副本执行合并操作</p>
</dd>
<dt class="hdlist1">日志</dt>
<dd>
<p>（仅提供用于测试）对检测到的每个实体副本执行合并操作，并记录有关实体副本的信息。此设置要求启用调试日志记录<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/event/internal/EntityCopyAllowedLoggedObserver.html"><code>EntityCopyAllowedLoggedObserver</code></a> 。</p>
<div class="paragraph">
<p>另外，应用程序可以通过提供以下实现来自定义行为<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/event/spi/EntityCopyObserver.html"><code>EntityCopyObserver</code></a>和设置<code>hibernate.event.merge.entity_copy_observer</code>类名。当此属性设置为<code>allow</code>要么<code>log</code> ，Hibernate将在级联合并操作时合并检测到的每个实体副本。在合并每个实体副本的过程中，Hibernate将从每个实体副本到其关联的级联合并操作<code>cascade=CascadeType.MERGE</code>要么<code>CascadeType.ALL</code> 。合并另一个实体副本时，由于合并一个实体副本而导致的实体状态将被覆盖。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请查看“ <a href="#pc-merge-gotchas">合并陷阱”</a>部分。</p>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-envers"><a class="anchor" href="#configurations-envers"></a> 24.23。启用属性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.envers.autoRegisterListeners</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>设置为<code>false</code> ，则Envers实体侦听器不再自动注册，因此您需要在引导过程中手动注册它们。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.integration.envers.enabled</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>启用或禁用HibernateEnvers <code>Service</code>积分。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.listeners.envers.autoRegister</strong></code></dt>
<dd>
<p>旧版设置。使用<code>hibernate.envers.autoRegisterListeners</code>要么<code>hibernate.integration.envers.enabled</code>代替。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-spatial"><a class="anchor" href="#configurations-spatial"></a> 24.24。空间特性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.integration.spatial.enabled</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>启用或禁用Hibernate空间<code>Service</code>积分。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.spatial.connection_finder</strong></code> （例如<code>org.geolatte.geom.codec.db.oracle.DefaultConnectionFinder</code> ）</dt>
<dd>
<p>定义实现该类的类的全限定名称<code>org.geolatte.geom.codec.db.oracle.ConnectionFinder</code>接口。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configurations-internal"><a class="anchor" href="#configurations-internal"></a> 24.25。内部性质</h3>
<div class="paragraph">
<p>以下配置属性在内部使用，您可能不必在应用程序中对其进行配置。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>hibernate.enable_specj_proprietary_syntax</strong></code> （例如<code>true</code>要么<code>false</code> （默认值））</dt>
<dd>
<p>启用或禁用与JPA规范不同的SpecJ专有映射语法。仅在性能测试期间使用。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.temp.use_jdbc_metadata_defaults</strong></code> （例如<code>true</code> （默认值）或<code>false</code> ）</dt>
<dd>
<p>此设置用于控制当数据库可能不可用时（主要是在工具使用方面），是否应参考JDBC元数据来确定某些设置默认值。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.connection_provider.injection_data</strong></code> （例如<code>java.util.Map</code> ）</dt>
<dd>
<p>要注入到当前配置的连接提供程序中的连接提供程序设置。</p>
</dd>
<dt class="hdlist1"><code><strong>hibernate.jandex_index</strong></code> （例如<code>org.jboss.jandex.Index</code> ）</dt>
<dd>
<p>命名Jandex <code>org.jboss.jandex.Index</code>实例使用。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="annotations"><a class="anchor" href="#annotations"></a> 25映射注释</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="annotations-jpa"><a class="anchor" href="#annotations-jpa"></a> 25.1。JPA批注</h3>
<div class="sect3">
<h4 id="annotations-jpa-access"><a class="anchor" href="#annotations-jpa-access"></a> 25.1.1。<code>@Access</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Access.html"><code>@Access</code></a>批注用于指定关联的实体类，映射的超类或可嵌入的类或实体属性的访问类型。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#access">访问类型</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-associationoverride"><a class="anchor" href="#annotations-jpa-associationoverride"></a> 25.1.2。<code>@AssociationOverride</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AssociationOverride.html"><code>@AssociationOverride</code></a>注释用于覆盖关联映射（例如， <code>@ManyToOne</code> ， <code>@OneToOne</code> ， <code>@OneToMany</code> ， <code>@ManyToMany</code> ）继承自映射的超类或可嵌入对象。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#embeddable-override">覆盖可嵌入类型</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-associationoverrides"><a class="anchor" href="#annotations-jpa-associationoverrides"></a> 25.1.3。<code>@AssociationOverrides</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AssociationOverrides.html"><code>@AssociationOverrides</code></a>用于分组几个<a href="#annotations-jpa-associationoverride"><code>@AssociationOverride</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-attributeoverride"><a class="anchor" href="#annotations-jpa-attributeoverride"></a> 25.1.4。<code>@AttributeOverride</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AttributeOverride.html"><code>@AttributeOverride</code></a>批注用于覆盖从映射超类或可嵌入对象继承的属性映射。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#embeddable-override">覆盖可嵌入类型</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-attributeoverrides"><a class="anchor" href="#annotations-jpa-attributeoverrides"></a> 25.1.5。<code>@AttributeOverrides</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AttributeOverrides.html"><code>@AttributeOverrides</code></a>用于分组几个<a href="#annotations-jpa-attributeoverride"><code>@AttributeOverride</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-basic"><a class="anchor" href="#annotations-jpa-basic"></a> 25.1.6。<code>@Basic</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Basic.html"><code>@Basic</code></a>批注用于将基本属性类型映射到数据库列。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#basic">基本类型”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-cacheable"><a class="anchor" href="#annotations-jpa-cacheable"></a> 25.1.7。<code>@Cacheable</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Cacheable.html"><code>@Cacheable</code></a>批注用于指定是否将实体存储在二级缓存中。</p>
</div>
<div class="paragraph">
<p>如果<code>persistence.xml</code><code>shared-cache-mode</code> XML属性设置为<code>ENABLE_SELECTIVE</code> ，则只有带有注释的实体<code>@Cacheable</code>将被存储在二级缓存中。</p>
</div>
<div class="paragraph">
<p>如果<code>shared-cache-mode</code> XML属性值为<code>DISABLE_SELECTIVE</code> ，然后标有的实体<code>@Cacheable</code>注解不会存储在二级缓存中，而所有其他实体都存储在缓存中。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#caching">缓存”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-collectiontable"><a class="anchor" href="#annotations-jpa-collectiontable"></a> 25.1.8。<code>@CollectionTable</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/CollectionTable.html"><code>@CollectionTable</code></a>批注用于指定存储基本或可嵌入类型集合的值的数据库表。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#embeddable-collections">可嵌入类型</a>的<a href="#embeddable-collections">集合</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-column"><a class="anchor" href="#annotations-jpa-column"></a> 25.1.9。<code>@Column</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html"><code>@Column</code></a>批注用于指定基本实体属性和数据库表列之间的映射。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-column-annotation"><code>@Column</code>注释</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-columnresult"><a class="anchor" href="#annotations-jpa-columnresult"></a> 25.1.10。<code>@ColumnResult</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ColumnResult.html"><code>@ColumnResult</code></a>批注与<a href="#annotations-jpa-sqlresultsetmapping"><code>@SqlResultSetMapping</code></a>要么<a href="#annotations-jpa-constructorresult"><code>@ConstructorResult</code></a>注释以映射给定SELECT查询的SQL列。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#sql-composite-key-entity-associations_named-query-example">与命名本机查询</a>的<a href="#sql-composite-key-entity-associations_named-query-example">实体关联</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-constructorresult"><a class="anchor" href="#annotations-jpa-constructorresult"></a> 25.1.11。<code>@ConstructorResult</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ConstructorResult.html"><code>@ConstructorResult</code></a>批注与<a href="#annotations-jpa-sqlresultsetmapping"><code>@SqlResultSetMapping</code></a>用于将给定SELECT查询的列映射到某个对象构造函数的注释。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#sql-multiple-scalar-values-dto-NamedNativeQuery-example">多重标量值<code>NamedNativeQuery</code>与<code>ConstructorResult</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-convert"><a class="anchor" href="#annotations-jpa-convert"></a> 25.1.12。<code>@Convert</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Convert.html"><code>@Convert</code></a>批注用于指定<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AttributeConverter.html"><code>AttributeConverter</code></a>用于转换当前带注释的基本属性的实现。</p>
</div>
<div class="paragraph">
<p>如果<code>AttributeConverter</code>用途<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Converter.html#autoApply--"><code>autoApply</code></a> ，那么具有相同目标类型的所有实体属性都将自动转换。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-enums-attribute-converter"><code>AttributeConverter</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-converter"><a class="anchor" href="#annotations-jpa-converter"></a> 25.1.13。<code>@Converter</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Converter.html"><code>@Converter</code></a>注解用于指定当前的注解<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/AttributeConverter.html"><code>AttributeConverter</code></a>实现可以用作JPA基本属性转换器。</p>
</div>
<div class="paragraph">
<p>如果<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Converter.html#autoApply--"><code>autoApply</code></a>属性设置为<code>true</code> ，那么JPA提供程序将自动转换具有当前转换器定义的相同Java类型的所有基本属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-enums-attribute-converter"><code>AttributeConverter</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-converts"><a class="anchor" href="#annotations-jpa-converts"></a> 25.1.14。<code>@Converts</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Converts.html"><code>@Converts</code></a>批注用于分组多个<a href="#annotations-jpa-convert"><code>@Convert</code></a>注释。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-enums-attribute-converter"><code>AttributeConverter</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-discriminatorcolumn"><a class="anchor" href="#annotations-jpa-discriminatorcolumn"></a> 15.1.15。<code>@DiscriminatorColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/DiscriminatorColumn.html"><code>@DiscriminatorColumn</code></a>注释用于指定标识符列名称和<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/DiscriminatorColumn.html#discriminatorType--">标识符类型</a> <code>SINGLE_TABLE</code>和<code>JOINED</code>继承策略。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#entity-inheritance-discriminator">鉴别器”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-discriminatorvalue"><a class="anchor" href="#annotations-jpa-discriminatorvalue"></a> 25.1.16。<code>@DiscriminatorValue</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/DiscriminatorValue.html"><code>@DiscriminatorValue</code></a>注解用于指定鉴别符列的值用于映射当前带注释的实体。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#entity-inheritance-discriminator">鉴别器”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-elementcollection"><a class="anchor" href="#annotations-jpa-elementcollection"></a> 25.1.17。<code>@ElementCollection</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ElementCollection.html"><code>@ElementCollection</code></a>批注用于指定基本或可嵌入类型的集合。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#collections">收藏”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-embeddable"><a class="anchor" href="#annotations-jpa-embeddable"></a> 25.1.18。<code>@Embeddable</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Embeddable.html"><code>@Embeddable</code></a>批注用于指定可嵌入的类型。与基本类型一样，可嵌入类型没有任何身份，由其拥有的实体进行管理。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#embeddables">Embeddables</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-embedded"><a class="anchor" href="#annotations-jpa-embedded"></a> 25.1.19。<code>@Embedded</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Embedded.html"><code>@Embedded</code></a>批注用于指定给定的实体属性表示可嵌入类型。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#embeddables">Embeddables</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-embeddedid"><a class="anchor" href="#annotations-jpa-embeddedid"></a> 25.1.20。<code>@EmbeddedId</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/EmbeddedId.html"><code>@EmbeddedId</code></a>批注用于指定实体标识符为可嵌入类型。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#identifiers-composite-aggregated">带有</a>的<a href="#identifiers-composite-aggregated">复合标识符<code>@EmbeddedId</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-entity"><a class="anchor" href="#annotations-jpa-entity"></a> 25.1.21。<code>@Entity</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Entity.html"><code>@Entity</code></a>注解用于指定当前注释类表示实体类型。与基本类型和可嵌入类型不同，实体类型具有标识，其状态由基础持久性上下文管理。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#entity">实体</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-entitylisteners"><a class="anchor" href="#annotations-jpa-entitylisteners"></a> 25.1.22。<code>@EntityListeners</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/EntityListeners.html"><code>@EntityListeners</code></a>注解用于指定当前已注释的实体使用的回调侦听器类的数组。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-entityresult"><a class="anchor" href="#annotations-jpa-entityresult"></a> 25.1.23。<code>@EntityResult</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/EntityResult.html"><code>@EntityResult</code></a>注释与<a href="#annotations-jpa-sqlresultsetmapping"><code>@SqlResultSetMapping</code></a>注释以将选定的列映射到实体。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#sql-composite-key-entity-associations_named-query-example">与命名本机查询</a>的<a href="#sql-composite-key-entity-associations_named-query-example">实体关联</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-enumerated"><a class="anchor" href="#annotations-jpa-enumerated"></a> 25.1.24。<code>@Enumerated</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Enumerated.html"><code>@Enumerated</code></a>批注用于指定实体属性表示枚举类型。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-enums-Enumerated"><code>@Enumerated</code>基本类型</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-excludedefaultlisteners"><a class="anchor" href="#annotations-jpa-excludedefaultlisteners"></a> 25.1.25。<code>@ExcludeDefaultListeners</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ExcludeDefaultListeners.html"><code>@ExcludeDefaultListeners</code></a>注解用于指定当前带注释的实体跳过任何默认侦听器的调用。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-exclude-default-listener">排除默认实体侦听器</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-excludesuperclasslisteners"><a class="anchor" href="#annotations-jpa-excludesuperclasslisteners"></a> 25.1.26。<code>@ExcludeSuperclassListeners</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ExcludeSuperclassListeners.html"><code>@ExcludeSuperclassListeners</code></a>注解用于指定当前带注释的实体跳过其超类声明的侦听器的调用。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-exclude-default-listener">排除默认实体侦听器</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-fieldresult"><a class="anchor" href="#annotations-jpa-fieldresult"></a> 25.1.27。<code>@FieldResult</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/FieldResult.html"><code>@FieldResult</code></a>注释与<a href="#annotations-jpa-entityresult"><code>@EntityResult</code></a>注释，将选定的列映射到某些特定实体的字段。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#sql-composite-key-entity-associations_named-query-example">与命名本机查询</a>的<a href="#sql-composite-key-entity-associations_named-query-example">实体关联</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-foreignkey"><a class="anchor" href="#annotations-jpa-foreignkey"></a> 25.1.28。<code>@ForeignKey</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ForeignKey.html"><code>@ForeignKey</code></a>批注用于指定关联的外键<a href="#annotations-jpa-joincolumn"><code>@JoinColumn</code></a>映射。的<code>@ForeignKey</code>仅当启用了自动模式生成工具时才使用批注，在这种情况下，它允许您自定义基础外键定义。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-many-to-one-example"><code>@ManyToOne</code>与<code>@ForeignKey</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-generatedvalue"><a class="anchor" href="#annotations-jpa-generatedvalue"></a> 25.1.29。<code>@GeneratedValue</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/GeneratedValue.html"><code>@GeneratedValue</code></a>注释指定使用标识列，数据库序列或表生成器自动生成实体标识符值。Hibernate支持<code>@GeneratedValue</code>甚至映射<code>UUID</code>身份标识。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#identifiers-simple-generated">自动生成的标识符</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-id"><a class="anchor" href="#annotations-jpa-id"></a> 25.1.30。<code>@Id</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Id.html"><code>@Id</code></a>注释指定实体标识符。实体必须始终具有一个标识符属性，该属性在给定的持久性上下文中加载该实体时使用。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#identifiers">标识符</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-idclass"><a class="anchor" href="#annotations-jpa-idclass"></a> 25.1.31。<code>@IdClass</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/IdClass.html"><code>@IdClass</code></a>如果当前实体定义了复合标识符，则使用注释。一个单独的类封装了所有标识符属性，这些标识符属性由当前实体映射进行镜像。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#identifiers-composite-nonaggregated">带有</a>的<a href="#identifiers-composite-nonaggregated">复合标识符<code>@IdClass</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-index"><a class="anchor" href="#annotations-jpa-index"></a> 25.1.32。<code>@Index</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Index.html"><code>@Index</code></a>自动模式生成工具使用注释来创建数据库索引。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#schema-generation-columns-index">列索引”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-inheritance"><a class="anchor" href="#annotations-jpa-inheritance"></a> 25.1.33。<code>@Inheritance</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Inheritance.html"><code>@Inheritance</code></a>批注用于指定给定实体类层次结构的继承策略。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#entity-inheritance">继承</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-joincolumn"><a class="anchor" href="#annotations-jpa-joincolumn"></a> 25.1.34。<code>@JoinColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/JoinColumn.html"><code>@JoinColumn</code></a>批注用于指定加入实体关联或可嵌入集合时使用的FOREIGN KEY列。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-many-to-one-example"><code>@ManyToOne</code>与<code>@JoinColumn</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-joincolumns"><a class="anchor" href="#annotations-jpa-joincolumns"></a> 25.1.35。<code>@JoinColumns</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/JoinColumns.html"><code>@JoinColumns</code></a>批注用于分组多个<a href="#annotations-jpa-joincolumn"><code>@JoinColumn</code></a>注释，在使用复合标识符映射实体关联或可嵌入集合时使用</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-jointable"><a class="anchor" href="#annotations-jpa-jointable"></a> 25.1.36。<code>@JoinTable</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/JoinTable.html"><code>@JoinTable</code></a>批注用于指定其他两个数据库表之间的链接表。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-unidirectional-example"><code>@JoinTable</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-lob"><a class="anchor" href="#annotations-jpa-lob"></a> 25.1.37。<code>@Lob</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Lob.html"><code>@Lob</code></a>注解用于指定当前带注释的实体属性表示大型对象类型。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-blob-example"><code>BLOB</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-manytomany"><a class="anchor" href="#annotations-jpa-manytomany"></a> 25.1.38。<code>@ManyToMany</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ManyToMany.html"><code>@ManyToMany</code></a>批注用于指定多对多数据库关系。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-many-to-many"><code>@ManyToMany</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-manytoone"><a class="anchor" href="#annotations-jpa-manytoone"></a> 25.1.39。<code>@ManyToOne</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/ManyToOne.html"><code>@ManyToOne</code></a>批注用于指定多对一数据库关系。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-many-to-one"><code>@ManyToOne</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkey"><a class="anchor" href="#annotations-jpa-mapkey"></a> 25.1.40。<code>@MapKey</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKey.html"><code>@MapKey</code></a>批注用于指定<code>java.util.Map</code>关联，其键类型是主键或代表地图值的实体的属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-unidirectional-example"><code>@MapKey</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeyclass"><a class="anchor" href="#annotations-jpa-mapkeyclass"></a> 25.1.41。<code>@MapKeyClass</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyClass.html"><code>@MapKeyClass</code></a>批注用于指定地图键的类型<code>java.util.Map</code>协会。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-key-class"><code>@MapKeyClass</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeycolumn"><a class="anchor" href="#annotations-jpa-mapkeycolumn"></a> 25.1.42。<code>@MapKeyColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyColumn.html"><code>@MapKeyColumn</code></a>注释用于指定存储列的键的数据库列<code>java.util.Map</code>映射键是基本类型的关联。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-custom-key-type-mapping-example"><code>@MapKeyType</code>映射部分</a>的示例<code>@MapKeyColumn</code>注释用法。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeyenumerated"><a class="anchor" href="#annotations-jpa-mapkeyenumerated"></a> 25.1.43。<code>@MapKeyEnumerated</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyEnumerated.html"><code>@MapKeyEnumerated</code></a>批注用于指定<code>java.util.Map</code> association是一个Java枚举。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-bidirectional-example"><code>@MapKeyEnumerated</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeyjoincolumn"><a class="anchor" href="#annotations-jpa-mapkeyjoincolumn"></a> 25.1.44。<code>@MapKeyJoinColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyJoinColumn.html"><code>@MapKeyJoinColumn</code></a>批注用于指定<code>java.util.Map</code>关联是实体关联。映射键列是链接表中的FOREIGN KEY，该链接表也将<code>Map</code>所有者的表与表所在的位置<code>Map</code>价值存在。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-value-type-entity-key-example"><code>@MapKeyJoinColumn</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeyjoincolumns"><a class="anchor" href="#annotations-jpa-mapkeyjoincolumns"></a> 25.1.45。<code>@MapKeyJoinColumns</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyJoinColumns.html"><code>@MapKeyJoinColumns</code></a>批注用于分组几个<a href="#annotations-jpa-mapkeyjoincolumn"><code>@MapKeyJoinColumn</code></a>映射时<code>java.util.Map</code>关联密钥使用复合标识符。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapkeytemporal"><a class="anchor" href="#annotations-jpa-mapkeytemporal"></a> 25.1.46。<code>@MapKeyTemporal</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapKeyTemporal.html"><code>@MapKeyTemporal</code></a>批注用于指定<code>java.util.Map</code>协会是一个<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/TemporalType.html"><code>@TemporalType</code></a> （例如<code>DATE</code> ， <code>TIME</code> ， <code>TIMESTAMP</code> ）。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-unidirectional-example"><code>@MapKeyTemporal</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mappedsuperclass"><a class="anchor" href="#annotations-jpa-mappedsuperclass"></a> 25.1.47。<code>@MappedSuperclass</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MappedSuperclass.html"><code>@MappedSuperclass</code></a>注解用于指定任何子类实体继承当前带注释的类型属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-inheritance-mapped-superclass"><code>@MappedSuperclass</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-mapsid"><a class="anchor" href="#annotations-jpa-mapsid"></a> 25.1.48。<code>@MapsId</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/MapsId.html"><code>@MapsId</code></a>批注用于指定实体标识符由当前批注映射<code>@ManyToOne</code>要么<code>@OneToOne</code>协会。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-derived-mapsid"><code>@MapsId</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedattributenode"><a class="anchor" href="#annotations-jpa-namedattributenode"></a> 25.1.49。<code>@NamedAttributeNode</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedAttributeNode.html"><code>@NamedAttributeNode</code></a>注释用于指定需要由实体图获取的每个单独的属性节点。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#fetching-strategies-dynamic-fetching-entity-graph-example">获取图</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedentitygraph"><a class="anchor" href="#annotations-jpa-namedentitygraph"></a> 25.1.50。<code>@NamedEntityGraph</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedEntityGraph.html"><code>@NamedEntityGraph</code></a>批注用于指定实体图，实体查询可使用该图来覆盖默认的提取计划。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#fetching-strategies-dynamic-fetching-entity-graph-example">获取图</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedentitygraphs"><a class="anchor" href="#annotations-jpa-namedentitygraphs"></a> 25.1.51。<code>@NamedEntityGraphs</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedEntityGraphs.html"><code>@NamedEntityGraphs</code></a>批注用于分组多个<a href="#annotations-jpa-namedentitygraph"><code>@NamedEntityGraph</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namednativequeries"><a class="anchor" href="#annotations-jpa-namednativequeries"></a> 25.1.52。<code>@NamedNativeQueries</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedNativeQueries.html"><code>@NamedNativeQueries</code></a>批注用于分组多个<a href="#annotations-jpa-namednativequery"><code>@NamedNativeQuery</code></a>注释。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namednativequery"><a class="anchor" href="#annotations-jpa-namednativequery"></a> 25.1.53。<code>@NamedNativeQuery</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedNativeQuery.html"><code>@NamedNativeQuery</code></a>批注用于指定本机SQL查询，以后可以通过其名称检索。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedqueries"><a class="anchor" href="#annotations-jpa-namedqueries"></a> 25.1.54。<code>@NamedQueries</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedQueries.html"><code>@NamedQueries</code></a>批注用于分组多个<a href="#annotations-jpa-namedquery"><code>@NamedQuery</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedquery"><a class="anchor" href="#annotations-jpa-namedquery"></a> 25.1.55。<code>@NamedQuery</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedQuery.html"><code>@NamedQuery</code></a>批注用于指定JPQL查询，以后可以通过其名称检索该查询。</p>
</div>
<div class="paragraph">
<p>见<a href="#jpql-api-named-query-example"><code>@NamedQuery</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedstoredprocedurequeries"><a class="anchor" href="#annotations-jpa-namedstoredprocedurequeries"></a> 25.1.56。<code>@NamedStoredProcedureQueries</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedStoredProcedureQueries.html"><code>@NamedStoredProcedureQueries</code></a>批注用于分组多个<a href="#annotations-jpa-namedstoredprocedurequery"><code>@NamedStoredProcedureQuery</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedstoredprocedurequery"><a class="anchor" href="#annotations-jpa-namedstoredprocedurequery"></a> 25.1.57。<code>@NamedStoredProcedureQuery</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedStoredProcedureQuery.html"><code>@NamedStoredProcedureQuery</code></a>批注用于指定存储过程查询，以后可以通过其名称检索该查询。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#sql-sp-named-query">使用命名查询调用存储过程</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-namedsubgraph"><a class="anchor" href="#annotations-jpa-namedsubgraph"></a> 25.1.58。<code>@NamedSubgraph</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/NamedSubgraph.html"><code>@NamedSubgraph</code></a>用于在实体图中指定子图的注释。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#fetching-strategies-dynamic-fetching-entity-subgraph">获取子图”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-onetomany"><a class="anchor" href="#annotations-jpa-onetomany"></a> 25.1.59。<code>@OneToMany</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OneToMany.html"><code>@OneToMany</code></a>批注用于指定一对多数据库关系。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-one-to-many"><code>@OneToMany</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-onetoone"><a class="anchor" href="#annotations-jpa-onetoone"></a> 25.1.60。<code>@OneToOne</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OneToOne.html"><code>@OneToOne</code></a>批注用于指定一对一的数据库关系。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-one-to-one"><code>@OneToOne</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-orderby"><a class="anchor" href="#annotations-jpa-orderby"></a> 25.1.61。<code>@OrderBy</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OrderBy.html"><code>@OrderBy</code></a>注解用于指定在获取当前带注释的集合时用于排序的实体属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-unidirectional-ordered-list"><code>@OrderBy</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-ordercolumn"><a class="anchor" href="#annotations-jpa-ordercolumn"></a> 25.1.62。<code>@OrderColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/OrderColumn.html"><code>@OrderColumn</code></a>注解用于指定当前的注解收集顺序应在数据库中实现。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-unidirectional-ordered-list-order-column-example"><code>@OrderColumn</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-persistencecontext"><a class="anchor" href="#annotations-jpa-persistencecontext"></a> 25.1.63。<code>@PersistenceContext</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceContext.html"><code>@PersistenceContext</code></a>批注用于指定<code>EntityManager</code>需要作为依赖注入。</p>
</div>
<div class="paragraph">
<p>见<a href="#bootstrap-jpa-compliant-PersistenceContext-example"><code>@PersistenceContext</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-persistencecontexts"><a class="anchor" href="#annotations-jpa-persistencecontexts"></a> 25.1.64。<code>@PersistenceContexts</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceContexts.html"><code>@PersistenceContexts</code></a>批注用于分组多个<a href="#annotations-jpa-persistencecontext"><code>@PersistenceContext</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-persistenceproperty"><a class="anchor" href="#annotations-jpa-persistenceproperty"></a> 25.1.65。<code>@PersistenceProperty</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceProperty.html"><code>@PersistenceProperty</code></a>注释由<a href="#annotations-jpa-persistencecontext"><code>@PersistenceContext</code></a>注释，用于声明在以下情况下传递到基础容器的JPA提供程序属性： <code>EntityManager</code>实例已创建。</p>
</div>
<div class="paragraph">
<p>见<a href="#bootstrap-jpa-compliant-PersistenceContext-configurable-example"><code>@PersistenceProperty</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-persistenceunit"><a class="anchor" href="#annotations-jpa-persistenceunit"></a> 25.1.66。<code>@PersistenceUnit</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceUnit.html"><code>@PersistenceUnit</code></a>批注用于指定<code>EntityManagerFactory</code>需要作为依赖注入。</p>
</div>
<div class="paragraph">
<p>见<a href="#bootstrap-jpa-compliant-PersistenceUnit-example"><code>@PersistenceUnit</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-persistenceunits"><a class="anchor" href="#annotations-jpa-persistenceunits"></a> 25.1.67。<code>@PersistenceUnits</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PersistenceUnits.html"><code>@PersistenceUnits</code></a>批注用于分组多个<a href="#annotations-jpa-persistenceunit"><code>@PersistenceUnit</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-postload"><a class="anchor" href="#annotations-jpa-postload"></a> 25.1.68。<code>@PostLoad</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PostLoad.html"><code>@PostLoad</code></a>批注用于指定在加载实体后触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-postpersist"><a class="anchor" href="#annotations-jpa-postpersist"></a> 25.1.69。<code>@PostPersist</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PostPersist.html"><code>@PostPersist</code></a>批注用于指定实体保留后触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-postremove"><a class="anchor" href="#annotations-jpa-postremove"></a> 25.1.70。<code>@PostRemove</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PostRemove.html"><code>@PostRemove</code></a>批注用于指定在删除实体后触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-postupdate"><a class="anchor" href="#annotations-jpa-postupdate"></a> 25.1.71。<code>@PostUpdate</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PostUpdate.html"><code>@PostUpdate</code></a>批注用于指定在实体更新后触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-prepersist"><a class="anchor" href="#annotations-jpa-prepersist"></a> 25.1.72。<code>@PrePersist</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PrePersist.html"><code>@PrePersist</code></a>批注用于指定在持久保存实体之前触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-preremove"><a class="anchor" href="#annotations-jpa-preremove"></a> 25.1.73。<code>@PreRemove</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PreRemove.html"><code>@PreRemove</code></a>批注用于指定在删除实体之前触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-preupdate"><a class="anchor" href="#annotations-jpa-preupdate"></a> 25.1.74。<code>@PreUpdate</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PreUpdate.html"><code>@PreUpdate</code></a>批注用于指定在更新实体之前触发的回调方法。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#events-jpa-callbacks-example">JPA回调</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-primarykeyjoincolumn"><a class="anchor" href="#annotations-jpa-primarykeyjoincolumn"></a> 25.1.75。<code>@PrimaryKeyJoinColumn</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PrimaryKeyJoinColumn.html"><code>@PrimaryKeyJoinColumn</code></a>注释用于指定当前注释实体的主键列也是其他实体的外键（例如， <code>JOINED</code>继承策略，辅助表映射中的主表或子表中的父表<code>@OneToOne</code>关系）。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-derived-primarykeyjoincolumn"><code>@PrimaryKeyJoinColumn</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-primarykeyjoincolumns"><a class="anchor" href="#annotations-jpa-primarykeyjoincolumns"></a> 25.1.76。<code>@PrimaryKeyJoinColumns</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/PrimaryKeyJoinColumns.html"><code>@PrimaryKeyJoinColumns</code></a>批注用于分组多个<a href="#annotations-jpa-primarykeyjoincolumn"><code>@PrimaryKeyJoinColumn</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-queryhint"><a class="anchor" href="#annotations-jpa-queryhint"></a> 25.1.77。<code>@QueryHint</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/QueryHint.html"><code>@QueryHint</code></a>批注用于指定由JPA提供程序使用的JPA提供程序提示<code>@NamedQuery</code>或一个<code>@NamedNativeQuery</code>注解。</p>
</div>
<div class="paragraph">
<p>见<a href="#jpa-read-only-entities-native-example"><code>@QueryHint</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-secondarytable"><a class="anchor" href="#annotations-jpa-secondarytable"></a> 25.1.78。<code>@SecondaryTable</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/SecondaryTable.html"><code>@SecondaryTable</code></a>注解用于为当前带注释的实体指定辅助表。</p>
</div>
<div class="paragraph">
<p>见<a href="#sql-custom-crud-secondary-table-example"><code>@SecondaryTable</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-secondarytables"><a class="anchor" href="#annotations-jpa-secondarytables"></a> 25.1.79。<code>@SecondaryTables</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/SecondaryTables.html"><code>@SecondaryTables</code></a>批注用于分组多个<a href="#annotations-jpa-secondarytable"><code>@SecondaryTable</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-sequencegenerator"><a class="anchor" href="#annotations-jpa-sequencegenerator"></a> 25.1.80。<code>@SequenceGenerator</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/SequenceGenerator.html"><code>@SequenceGenerator</code></a>注解用于指定当前被注释实体的标识符生成器使用的数据库序列。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-generators-sequence-configured"><code>@SequenceGenerator</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-sqlresultsetmapping"><a class="anchor" href="#annotations-jpa-sqlresultsetmapping"></a> 25.1.81。<code>@SqlResultSetMapping</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/SqlResultSetMapping.html"><code>@SqlResultSetMapping</code></a>批注用于指定<code>ResultSet</code>本机SQL查询或存储过程的映射。</p>
</div>
<div class="paragraph">
<p>见<a href="#sql-composite-key-entity-associations_named-query-example"><code>SqlResultSetMapping</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-sqlresultsetmappings"><a class="anchor" href="#annotations-jpa-sqlresultsetmappings"></a> 25.1.82。<code>@SqlResultSetMappings</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/SqlResultSetMappings.html"><code>@SqlResultSetMappings</code></a>注解是多组<a href="#annotations-jpa-sqlresultsetmapping"><code>@SqlResultSetMapping</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-storedprocedureparameter"><a class="anchor" href="#annotations-jpa-storedprocedureparameter"></a> 25.1.83。<code>@StoredProcedureParameter</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/StoredProcedureParameter.html"><code>@StoredProcedureParameter</code></a>批注用于指定一个参数<a href="#annotations-jpa-namedstoredprocedurequery"><code>@NamedStoredProcedureQuery</code></a> 。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#sql-sp-named-query">使用命名查询调用存储过程</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-table"><a class="anchor" href="#annotations-jpa-table"></a> 25.1.84。<code>@Table</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Table.html"><code>@Table</code></a>注解用于指定当前带注释的实体的主表。</p>
</div>
<div class="paragraph">
<p>见<a href="#sql-custom-crud-secondary-table-example"><code>@Table</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-tablegenerator"><a class="anchor" href="#annotations-jpa-tablegenerator"></a> 25.1.85。<code>@TableGenerator</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/TableGenerator.html"><code>@TableGenerator</code></a>注解用于指定当前被注解实体的身份生成器使用的数据库表。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-generators-table-configured-mapping-example"><code>@TableGenerator</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-temporal"><a class="anchor" href="#annotations-jpa-temporal"></a> 25.1.86。<code>@Temporal</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Temporal.html"><code>@Temporal</code></a>批注用于指定<code>TemporalType</code>当前注释的<code>java.util.Date</code>要么<code>java.util.Calendar</code>实体属性。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#basic-datetime">基本时态类型”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-transient"><a class="anchor" href="#annotations-jpa-transient"></a> 25.1.87。<code>@Transient</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Transient.html"><code>@Transient</code></a>批注用于指定不应保留给定的实体属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#events-jpa-callbacks-example"><code>@Transient</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-uniqueconstraint"><a class="anchor" href="#annotations-jpa-uniqueconstraint"></a> 25.1.88。<code>@UniqueConstraint</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/UniqueConstraint.html"><code>@UniqueConstraint</code></a>注释用于为与当前注释的实体相关联的主表或辅助表指定唯一的约束，该约束将由自动模式生成器包括。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#schema-generation-columns-unique-constraint">列唯一约束”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-jpa-version"><a class="anchor" href="#annotations-jpa-version"></a> 25.1.89。<code>@Version</code></h4>
<div class="paragraph">
<p>的<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Version.html"><code>@Version</code></a>批注用于指定用于乐观锁定的version属性。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#locking-optimistic">乐观锁定映射</a>部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations-hibernate"><a class="anchor" href="#annotations-hibernate"></a> 25.2。Hibernate注释</h3>
<div class="sect3">
<h4 id="annotations-hibernate-accesstype"><a class="anchor" href="#annotations-hibernate-accesstype"></a> 25.2.1。<span class="line-through"><code>@AccessType</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/AccessType.html"><span class="line-through"><code>@AccessType</code></span></a>注解已弃用。您应该使用JPA <a href="#annotations-jpa-access"><code>@Access</code></a>或Hibernate本机<a href="#annotations-hibernate-attributeaccessor"><code>@AttributeAccessor</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-any"><a class="anchor" href="#annotations-hibernate-any"></a> 25.2.2。<code>@Any</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Any.html"><code>@Any</code></a>批注用于定义可以指向几种实体类型之一的<strong>任意一对一</strong>关联。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-any"><code>@Any</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-anymetadef"><a class="anchor" href="#annotations-hibernate-anymetadef"></a> 25.2.3。<code>@AnyMetaDef</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/AnyMetaDef.html"><code>@AnyMetaDef</code></a>批注用于提供有关<code>@Any</code>要么<code>@ManyToAny</code>映射。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-any"><code>@Any</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-anymetadefs"><a class="anchor" href="#annotations-hibernate-anymetadefs"></a> 25.2.4。<code>@AnyMetaDefs</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/AnyMetaDefs.html"><code>@AnyMetaDefs</code></a>批注用于分组多个<a href="#annotations-hibernate-anymetadef"><code>@AnyMetaDef</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-attributeaccessor"><a class="anchor" href="#annotations-hibernate-attributeaccessor"></a> 25.2.5。<code>@AttributeAccessor</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/AttributeAccessor.html"><code>@AttributeAccessor</code></a>批注用于指定自定义<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/property/access/spi/PropertyAccessStrategy.html"><code>PropertyAccessStrategy</code></a> 。</p>
</div>
<div class="paragraph">
<p>仅应用于命名风俗<code>PropertyAccessStrategy</code> 。对于属性/字段访问类型，JPA <a href="#annotations-jpa-access"><code>@Access</code></a>注释应该是首选。</p>
</div>
<div class="paragraph">
<p>但是，如果将此批注与value =“ property”或value =“ field”一起使用，它将作为JPA的相应用法<a href="#annotations-jpa-access"><code>@Access</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-batchsize"><a class="anchor" href="#annotations-hibernate-batchsize"></a> 25.2.6。<code>@BatchSize</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/BatchSize.html"><code>@BatchSize</code></a>批注用于指定批量加载惰性集合条目的大小。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#fetching-batch">批量提取</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-cache"><a class="anchor" href="#annotations-hibernate-cache"></a> 25.2.7。<code>@Cache</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Cache.html"><code>@Cache</code></a>批注用于指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CacheConcurrencyStrategy.html"><code>CacheConcurrencyStrategy</code></a>根实体或集合。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#caching">缓存”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-cascade"><a class="anchor" href="#annotations-hibernate-cascade"></a> 25.2.8。<code>@Cascade</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Cascade.html"><code>@Cascade</code></a>批注用于应用特定于Hibernate的<a href="http://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CascadeType.html"><code>CascadeType</code></a>策略（例如<code>CascadeType.LOCK</code> ， <code>CascadeType.SAVE_UPDATE</code> ， <code>CascadeType.REPLICATE</code> ）在给定的关联上。</p>
</div>
<div class="paragraph">
<p>对于JPA级联，建议使用<a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/CascadeType.html"><code>javax.persistence.CascadeType</code></a>代替。</p>
</div>
<div class="paragraph">
<p>结合使用JPA和Hibernate时<code>CascadeType</code>策略，Hibernate将合并两组级联。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#pc-cascade">级联</a>章节。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-check"><a class="anchor" href="#annotations-hibernate-check"></a> 25.2.9。<code>@Check</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Check.html"><code>@Check</code></a>批注用于指定可以在类级别定义的任意SQL CHECK约束。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#schema-generation-database-checks">数据库级检查</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-collectionid"><a class="anchor" href="#annotations-hibernate-collectionid"></a> 25.2.10。<code>@CollectionId</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CollectionId.html"><code>@CollectionId</code></a>批注用于指定idbag集合的标识符列。</p>
</div>
<div class="paragraph">
<p>您可能要使用JPA <a href="#annotations-jpa-ordercolumn"><code>@OrderColumn</code></a>代替。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-collectiontype"><a class="anchor" href="#annotations-hibernate-collectiontype"></a> 25.2.11。<code>@CollectionType</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CollectionType.html"><code>@CollectionType</code></a>批注用于指定自定义集合类型。</p>
</div>
<div class="paragraph">
<p>集合也可以命名为<a href="#annotations-hibernate-type"><code>@Type</code></a> ，它定义了集合元素的Hibernate类型。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#collections-custom">自定义集合类型”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-columndefault"><a class="anchor" href="#annotations-hibernate-columndefault"></a> 25.2.12。<code>@ColumnDefault</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ColumnDefault.html"><code>@ColumnDefault</code></a>批注用于指定<code>DEFAULT</code>使用自动模式生成器时要应用的DDL值。</p>
</div>
<div class="paragraph">
<p>使用以下命令可以实现相同的行为<code>definition</code> JPA的属性<a href="#annotations-jpa-column"><code>@Column</code></a>注解。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#schema-generation-column-default-value">数据库</a>的<a href="#schema-generation-column-default-value">默认值列</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-columns"><a class="anchor" href="#annotations-hibernate-columns"></a> 25.2.13。<code>@Columns</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Columns.html"><code>@Columns</code></a>批注用于将多个JPA分组<a href="#annotations-jpa-column"><code>@Column</code></a>注释。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-column-read-and-write-composite-type-example"><code>@Columns</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-columntransformer"><a class="anchor" href="#annotations-hibernate-columntransformer"></a> 25.2.14。<code>@ColumnTransformer</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ColumnTransformer.html"><code>@ColumnTransformer</code></a>批注用于自定义如何从数据库读取或写入给定的列值。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-column-read-and-write-example"><code>@ColumnTransformer</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-columntransformers"><a class="anchor" href="#annotations-hibernate-columntransformers"></a> 25.2.15。<code>@ColumnTransformers</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ColumnTransformers.html"><code>@ColumnTransformers</code></a>注释iis用于将多个分组<a href="#annotations-hibernate-columntransformer"><code>@ColumnTransformer</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-creationtimestamp"><a class="anchor" href="#annotations-hibernate-creationtimestamp"></a> 25.2.16。<code>@CreationTimestamp</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/CreationTimestamp.html"><code>@CreationTimestamp</code></a>注解用于指定必须使用当前JVM时间戳记值初始化当前注释的时间类型。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-generated-CreationTimestamp"><code>@CreationTimestamp</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-discriminatorformula"><a class="anchor" href="#annotations-hibernate-discriminatorformula"></a> 25.2.17。<code>@DiscriminatorFormula</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DiscriminatorFormula.html"><code>@DiscriminatorFormula</code></a>注释用于指定Hibernate<a href="#annotations-hibernate-formula"><code>@Formula</code></a>解决继承标识符值。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-inheritance-single-table-discriminator-formula-example"><code>@DiscriminatorFormula</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-discriminatoroptions"><a class="anchor" href="#annotations-hibernate-discriminatoroptions"></a> 25.2.18。<code>@DiscriminatorOptions</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DiscriminatorOptions.html"><code>@DiscriminatorOptions</code></a>批注用于提供<code>force</code>和<code>insert</code>鉴别器属性。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#entity-inheritance-discriminator">鉴别器”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-dynamicinsert"><a class="anchor" href="#annotations-hibernate-dynamicinsert"></a> 25.2.19。<code>@DynamicInsert</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DynamicInsert.html"><code>@DynamicInsert</code></a>批注用于指定<code>INSERT</code>每当要保留实体时，都应生成SQL语句。</p>
</div>
<div class="paragraph">
<p>默认情况下，Hibernate使用缓存的<code>INSERT</code>设置所有表列的语句。当实体带有注释时<code>@DynamicInsert</code>注释， <code>PreparedStatement</code>将仅包含非null列。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-generated-CreationTimestamp"><code>@CreationTimestamp</code>映射</a>部分以获取有关如何的更多信息<code>@DynamicInsert</code>作品。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-dynamicupdate"><a class="anchor" href="#annotations-hibernate-dynamicupdate"></a> 25.2.20。<code>@DynamicUpdate</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DynamicUpdate.html"><code>@DynamicUpdate</code></a>批注用于指定<code>UPDATE</code>只要修改实体，就应生成SQL语句。</p>
</div>
<div class="paragraph">
<p>默认情况下，Hibernate使用缓存的<code>UPDATE</code>设置所有表列的语句。当实体带有注释时<code>@DynamicUpdate</code>注释， <code>PreparedStatement</code>将仅包括其值已更改的列。</p>
</div>
<div class="paragraph">
<p>见<a href="#pc-managed-state-dynamic-update"><code>@DynamicUpdate</code></a>部分以获取更多信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于重新连接的分离实体，如果没有<a href="#annotations-hibernate-selectbeforeupdate"><code>@SelectBeforeUpdate</code></a>注释也是如此。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-entity"><a class="anchor" href="#annotations-hibernate-entity"></a> 25.2.21。<span class="line-through"><code>@Entity</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Entity.html"><span class="line-through"><code>@Entity</code></span></a>注解已弃用。使用JPA <a href="#annotations-jpa-entity"><code>@Entity</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-fetch"><a class="anchor" href="#annotations-hibernate-fetch"></a> 25.2.22。<code>@Fetch</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Fetch.html"><code>@Fetch</code></a>批注用于指定特定于Hibernate的内容<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FetchMode.html"><code>FetchMode</code></a> （例如<code>JOIN</code> ， <code>SELECT</code> ， <code>SUBSELECT</code> ）用于当前带注释的关联：</p>
</div>
<div class="paragraph">
<p>见<a href="#fetching-fetch-annotation"><code>@Fetch</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-fetchprofile"><a class="anchor" href="#annotations-hibernate-fetchprofile"></a> 25.2.23。<code>@FetchProfile</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FetchProfile.html"><code>@FetchProfile</code></a>批注用于指定自定义提取配置文件，类似于JPA实体图。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#fetching-strategies-dynamic-fetching-profile-example">获取映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-fetchprofile-fetchoverride"><a class="anchor" href="#annotations-hibernate-fetchprofile-fetchoverride"></a> 25.2.24。<code>@FetchProfile.FetchOverride</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FetchProfile.FetchOverride.html"><code>@FetchProfile.FetchOverride</code></a>批注与<a href="#annotations-hibernate-fetchprofile"><code>@FetchProfile</code></a>批注，它用于覆盖特定实体关联的提取策略。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#fetching-strategies-dynamic-fetching-profile-example">获取配置文件</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-fetchprofiles"><a class="anchor" href="#annotations-hibernate-fetchprofiles"></a> 25.2.25。<code>@FetchProfiles</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FetchProfiles.html"><code>@FetchProfiles</code></a>批注用于分组多个<a href="#annotations-hibernate-fetchprofile"><code>@FetchProfile</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filter"><a class="anchor" href="#annotations-hibernate-filter"></a> 25.2.26。<code>@Filter</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Filter.html"><code>@Filter</code></a>批注用于将过滤器添加到集合的实体或目标实体。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参<a href="#pc-filter">见过滤器映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filterdef"><a class="anchor" href="#annotations-hibernate-filterdef"></a> 25.2.27。<code>@FilterDef</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FilterDef.html"><code>@FilterDef</code></a>批注用于指定一个<code>@Filter</code>定义（名称，默认条件和参数类型，如果有的话）。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参<a href="#pc-filter">见过滤器映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filterdefs"><a class="anchor" href="#annotations-hibernate-filterdefs"></a> 25.2.28。<code>@FilterDefs</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FilterDefs.html"><code>@FilterDefs</code></a>批注用于分组多个<a href="#annotations-hibernate-filterdef"><code>@FilterDef</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filterjointable"><a class="anchor" href="#annotations-hibernate-filterjointable"></a> 25.2.29。<code>@FilterJoinTable</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FilterJoinTable.html"><code>@FilterJoinTable</code></a>注释用于添加<code>@Filter</code>连接表集合的功能。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#pc-filter-join-table">FilterJoinTable映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filterjointables"><a class="anchor" href="#annotations-hibernate-filterjointables"></a> 25.2.30。<code>@FilterJoinTables</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/FilterJoinTables.html"><code>@FilterJoinTables</code></a>批注用于分组多个<a href="#annotations-hibernate-filterjointable"><code>@FilterJoinTable</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-filters"><a class="anchor" href="#annotations-hibernate-filters"></a> 25.2.31。<code>@Filters</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Filters.html"><code>@Filters</code></a>批注用于分组多个<a href="#annotations-hibernate-filter"><code>@Filter</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="_span_class_line_through_code_foreignkey_code_span"><a class="anchor" href="#_span_class_line_through_code_foreignkey_code_span"></a> 25.2.32。<span class="line-through"><code>@ForeignKey</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ForeignKey.html"><span class="line-through"><code>@ForeignKey</code></span></a>注解已弃用。使用JPA 2.1 <a href="#annotations-jpa-foreignkey"><code>@ForeignKey</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-formula"><a class="anchor" href="#annotations-hibernate-formula"></a> 25.2.33。<code>@Formula</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Formula.html"><code>@Formula</code></a>批注用于指定要填充给定实体属性而执行的SQL片段。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-column-formula-example"><code>@Formula</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-generated"><a class="anchor" href="#annotations-hibernate-generated"></a> 25.2.34。<code>@Generated</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Generated.html"><code>@Generated</code></a>注解用于指定当前已注释的实体属性是由数据库生成的。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-generated-Generated"><code>@Generated</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-generatortype"><a class="anchor" href="#annotations-hibernate-generatortype"></a> 25.2.35。<code>@GeneratorType</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GeneratorType.html"><code>@GeneratorType</code></a>注释用于提供<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tuple/ValueGenerator.html"><code>ValueGenerator</code></a>和一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenerationTime.html"><code>GenerationTime</code></a>当前注释的生成属性。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-generated-GeneratorType-example"><code>@GeneratorType</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-genericgenerator"><a class="anchor" href="#annotations-hibernate-genericgenerator"></a> 25.2.36。<code>@GenericGenerator</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenericGenerator.html"><code>@GenericGenerator</code></a>批注可用于配置任何Hibernate标识符生成器。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-generators-GenericGenerator"><code>@GenericGenerator</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-genericgenerators"><a class="anchor" href="#annotations-hibernate-genericgenerators"></a> 25.2.37。<code>@GenericGenerators</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/GenericGenerators.html"><code>@GenericGenerators</code></a>批注用于分组多个<a href="#annotations-hibernate-genericgenerator"><code>@GenericGenerator</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-immutable"><a class="anchor" href="#annotations-hibernate-immutable"></a> 25.2.38。<code>@Immutable</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Immutable.html"><code>@Immutable</code></a>注解用于指定带注释的实体，属性或集合是不可变的。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-immutability"><code>@Immutable</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-index"><a class="anchor" href="#annotations-hibernate-index"></a> 25.2.39。<span class="line-through"><code>@Index</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Index.html"><span class="line-through"><code>@Index</code></span></a>注解已弃用。使用JPA <a href="#annotations-jpa-index"><code>@Index</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-indexcolumn"><a class="anchor" href="#annotations-hibernate-indexcolumn"></a> 25.2.40。<span class="line-through"><code>@IndexColumn</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/IndexColumn.html"><span class="line-through"><code>@IndexColumn</code></span></a>注解已弃用。使用JPA <a href="#annotations-jpa-ordercolumn"><code>@OrderColumn</code></a>注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-joincolumnorformula"><a class="anchor" href="#annotations-hibernate-joincolumnorformula"></a> 25.2.41。<code>@JoinColumnOrFormula</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/JoinColumnOrFormula.html"><code>@JoinColumnOrFormula</code></a>批注用于指定实体关联是通过FOREIGN KEY连接解析的（例如<a href="#annotations-jpa-joincolumn"><code>@JoinColumn</code></a> ）或使用给定的SQL公式的结果（例如<a href="#annotations-hibernate-joinformula"><code>@JoinFormula</code></a> ）。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-JoinColumnOrFormula"><code>@JoinColumnOrFormula</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-joincolumnsorformulas"><a class="anchor" href="#annotations-hibernate-joincolumnsorformulas"></a> 25.2.42。<code>@JoinColumnsOrFormulas</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/JoinColumnsOrFormulas.html"><code>@JoinColumnsOrFormulas</code></a>批注用于分组多个<a href="#annotations-hibernate-joincolumnorformula"><code>@JoinColumnOrFormula</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-joinformula"><a class="anchor" href="#annotations-hibernate-joinformula"></a> 25.2.43。<code>@JoinFormula</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/JoinFormula.html"><code>@JoinFormula</code></a>注释用于替代<a href="#annotations-jpa-joincolumn"><code>@JoinColumn</code></a>当关联没有专用的FOREIGN KEY列时。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-JoinFormula"><code>@JoinFormula</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-lazycollection"><a class="anchor" href="#annotations-hibernate-lazycollection"></a> 25.2.44。<code>@LazyCollection</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyCollection.html"><code>@LazyCollection</code></a>批注用于指定给定集合的延迟获取行为。可能的值由<code><a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyCollectionOption.html">LazyCollectionOption</a></code>列举：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>TRUE</code></dt>
<dd>
<p>在请求状态时加载它。</p>
</dd>
<dt class="hdlist1"><code>FALSE</code></dt>
<dd>
<p>认真加载它。</p>
</dd>
<dt class="hdlist1"><code>EXTRA</code></dt>
<dd>
<p>优先选择额外的查询而不是完整的集合加载。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>的<code>TRUE</code>和<code>FALSE</code>值已弃用，因为您应该使用JPA <a href="https://javaee.github.io/javaee-spec/javadocs/javax/persistence/FetchType.html"><code>FetchType</code></a>的属性<a href="#annotations-jpa-elementcollection"><code>@ElementCollection</code></a> ， <a href="#annotations-jpa-onetomany"><code>@OneToMany</code></a> ， 要么<a href="#annotations-jpa-manytomany"><code>@ManyToMany</code></a>采集。</p>
</div>
<div class="paragraph">
<p>的<code>EXTRA</code>值在JPA规范中没有等效项，即使在首次访问该集合时，它也可以避免加载整个集合。使用辅助查询分别获取每个元素。</p>
</div>
<div class="paragraph">
<p>见<a href="#fetching-LazyCollection"><code>@LazyCollection</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-lazygroup"><a class="anchor" href="#annotations-hibernate-lazygroup"></a> 25.2.45。<code>@LazyGroup</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyGroup.html"><code>@LazyGroup</code></a>批注用于指定应将实体属性与属于同一组的所有其他属性一起获取。</p>
</div>
<div class="paragraph">
<p>要延迟加载实体属性，需要增强字节码。默认情况下，所有非集合属性都加载到一个名为“ DEFAULT”的组中。</p>
</div>
<div class="paragraph">
<p>当访问组中的一个属性时，此批注允许定义不同的属性组以一起初始化。</p>
</div>
<div class="paragraph">
<p>见<a href="#BytecodeEnhancement-lazy-loading-example"><code>@LazyGroup</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-lazytoone"><a class="anchor" href="#annotations-hibernate-lazytoone"></a> 25.2.46。<code>@LazyToOne</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyToOne.html"><code>@LazyToOne</code></a>批注用于指定懒惰选项，由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/LazyToOneOption.html"><code>LazyToOneOption</code></a> ，适用于<code>@OneToOne</code>要么<code>@ManyToOne</code>协会。</p>
</div>
<div class="paragraph">
<p><code>LazyToOneOption</code>定义以下替代方法：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">假</dt>
<dd>
<p>认真加载关联。自JPA以来就不需要此<code>FetchType.EAGER</code>提供相同的行为。</p>
</dd>
<dt class="hdlist1">NO_PROXY</dt>
<dd>
<p>该选项将在返回真实实体对象时延迟获取关联。</p>
</dd>
<dt class="hdlist1">代理</dt>
<dd>
<p>此选项将延迟返回关联，同时返回代理。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>见<a href="#associations-one-to-one-bidirectional-lazy"><code>@LazyToOne</code>映射示例</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-listindexbase"><a class="anchor" href="#annotations-hibernate-listindexbase"></a> 25.2.47。<code>@ListIndexBase</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ListIndexBase.html"><code>@ListIndexBase</code></a>批注用于指定存储在数据库中的列表索引的起始值。</p>
</div>
<div class="paragraph">
<p>默认， <code>List</code>索引从零开始存储。通常与<a href="#annotations-jpa-ordercolumn"><code>@OrderColumn</code></a> 。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-customizing-ordered-list-ordinal"><code>@ListIndexBase</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-loader"><a class="anchor" href="#annotations-hibernate-loader"></a> 25.2.48。<code>@Loader</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Loader.html"><code>@Loader</code></a>注释用于覆盖默认值<code>SELECT</code>用于加载实体查询的查询。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-manytoany"><a class="anchor" href="#annotations-hibernate-manytoany"></a> 25.2.49。<code>@ManyToAny</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ManyToAny.html"><code>@ManyToAny</code></a>当动态解析目标类型时，注释用于指定多对一关联。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-many-to-any"><code>@ManyToAny</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-mapkeytype"><a class="anchor" href="#annotations-hibernate-mapkeytype"></a> 25.2.50。<code>@MapKeyType</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/MapKeyType.html"><code>@MapKeyType</code></a>批注用于指定地图键类型。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-map-custom-key-type"><code>@MapKeyType</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-metavalue"><a class="anchor" href="#annotations-hibernate-metavalue"></a> 25.2.51。<code>@MetaValue</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/MetaValue.html"><code>@MetaValue</code></a>注释由<a href="#annotations-hibernate-anymetadef"><code>@AnyMetaDef</code></a>注释，用于指定给定的标识符值和实体类型之间的关联。</p>
</div>
<div class="paragraph">
<p>见<a href="#associations-any"><code>@Any</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-namednativequeries"><a class="anchor" href="#annotations-hibernate-namednativequeries"></a> 25.2.52。<code>@NamedNativeQueries</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedNativeQueries.html"><code>@NamedNativeQueries</code></a>批注用于分组多个<a href="#annotations-hibernate-namednativequery"><code>@NamedNativeQuery</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-namednativequery"><a class="anchor" href="#annotations-hibernate-namednativequery"></a> 25.2.53。<code>@NamedNativeQuery</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedNativeQuery.html"><code>@NamedNativeQuery</code></a>注释扩展了JPA <a href="#annotations-jpa-namednativequery"><code>@NamedNativeQuery</code></a>具有Hibernate的特定功能，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>此特定查询的刷新模式</p>
</li>
<li>
<p>是否应缓存查询以及应使用哪个缓存区域</p>
</li>
<li>
<p>所选实体<code>CacheModeType</code>战略</p>
</li>
<li>
<p>JDBC <code>Statement</code>取得大小</p>
</li>
<li>
<p>JDBC <code>Statement</code>执行超时</p>
</li>
<li>
<p>如果查询是一个<code>CallableStatement</code> ，针对存储过程或数据库函数</p>
</li>
<li>
<p>应该将什么SQL级别的注释发送到数据库</p>
</li>
<li>
<p>如果查询是只读的，则不会将结果实体存储到当前正在运行的持久性上下文中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>看到<a href="#sql-multiple-scalar-values-dto-NamedNativeQuery-hibernate-example">冬眠<code>@NamedNativeQuery</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-namedqueries"><a class="anchor" href="#annotations-hibernate-namedqueries"></a> 25.2.54。<code>@NamedQueries</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedQueries.html"><code>@NamedQueries</code></a>批注用于分组多个<a href="#annotations-hibernate-namedquery"><code>@NamedQuery</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-namedquery"><a class="anchor" href="#annotations-hibernate-namedquery"></a> 25.2.55。<code>@NamedQuery</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NamedQuery.html"><code>@NamedQuery</code></a>注释扩展了JPA <a href="#annotations-jpa-namedquery"><code>@NamedQuery</code></a>具有Hibernate的特定功能，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>此特定查询的刷新模式</p>
</li>
<li>
<p>是否应缓存查询以及应使用哪个缓存区域</p>
</li>
<li>
<p>所选实体<code>CacheModeType</code>战略</p>
</li>
<li>
<p>JDBC <code>Statement</code>取得大小</p>
</li>
<li>
<p>JDBC <code>Statement</code>执行超时</p>
</li>
<li>
<p>如果查询是一个<code>CallableStatement</code> ，针对存储过程或数据库函数</p>
</li>
<li>
<p>应该将什么SQL级别的注释发送到数据库</p>
</li>
<li>
<p>如果查询是只读的，则不会将结果实体存储到当前正在运行的持久性上下文中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>见<a href="#jpql-api-hibernate-named-query-example"><code>@NamedQuery</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-nationalized"><a class="anchor" href="#annotations-hibernate-nationalized"></a> 25.2.56。<code>@Nationalized</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Nationalized.html"><code>@Nationalized</code></a>注释用于指定当前注释的属性是字符类型（例如<code>String</code> ， <code>Character</code> ， <code>Clob</code> ）存储在国有化的列类型（ <code>NVARCHAR</code> ， <code>NCHAR</code> ， <code>NCLOB</code> ）。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-nationalized-example"><code>@Nationalized</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-naturalid"><a class="anchor" href="#annotations-hibernate-naturalid"></a> 25.2.57。<code>@NaturalId</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NaturalId.html"><code>@NaturalId</code></a>注解用于指定当前带注释的属性是实体自然ID的一部分。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#naturalid">自然ID</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-naturalidcache"><a class="anchor" href="#annotations-hibernate-naturalidcache"></a> 25.2.58。<code>@NaturalIdCache</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NaturalIdCache.html"><code>@NaturalIdCache</code></a>注释用于指定与带注释的实体关联的自然id值应存储在第二级缓存中。</p>
</div>
<div class="paragraph">
<p>见<a href="#naturalid-caching"><code>@NaturalIdCache</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-notfound"><a class="anchor" href="#annotations-hibernate-notfound"></a> 25.2.59。<code>@NotFound</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NotFound.html"><code>@NotFound</code></a>批注用于指定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/NotFoundAction.html"><code>NotFoundAction</code></a>在给定关联中找不到元素时的策略。</p>
</div>
<div class="paragraph">
<p>的<code>NotFoundAction</code>用两种可能性定义：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>EXCEPTION</code></dt>
<dd>
<p>如果找不到元素（默认和推荐），则会引发异常。</p>
</dd>
<dt class="hdlist1"><code>IGNORE</code></dt>
<dd>
<p>在数据库中找不到该元素时，请忽略该元素。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>见<a href="#associations-not-found"><code>@NotFound</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-ondelete"><a class="anchor" href="#annotations-hibernate-ondelete"></a> 25.2.60。<code>@OnDelete</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OnDelete.html"><code>@OnDelete</code></a>注解用于指定当前带注释的集合，数组或联接的子类采用的删除策略。自动模式生成工具使用此注释来生成适当的FOREIGN KEY DDL级联指令。</p>
</div>
<div class="paragraph">
<p>两种可能的策略由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OnDeleteAction.html"><code>OnDeleteAction</code></a>列举：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">级联</dt>
<dd>
<p>使用数据库的FOREIGN KEY级联功能。</p>
</dd>
<dt class="hdlist1">NO_ACTION</dt>
<dd>
<p>不采取行动。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>见<a href="#pc-cascade-on-delete"><code>@OnDelete</code>级联</a>章节以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-optimisticlock"><a class="anchor" href="#annotations-hibernate-optimisticlock"></a> 25.2.61。<code>@OptimisticLock</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLock.html"><code>@OptimisticLock</code></a>注解用于指定当前带注释的属性在被修改后是否将触发实体版本增量。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#locking-optimistic-exclude-attribute">排除属性</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-optimisticlocking"><a class="anchor" href="#annotations-hibernate-optimisticlocking"></a> 25.2.62。<code>@OptimisticLocking</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLocking.html"><code>@OptimisticLocking</code></a>注解用于指定当前带注释的实体的乐观锁定策略。</p>
</div>
<div class="paragraph">
<p>四种可能的策略由<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OptimisticLockType.html"><code>OptimisticLockType</code></a>列举：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">没有</dt>
<dd>
<p>隐式乐观锁定机制已禁用。</p>
</dd>
<dt class="hdlist1">版</dt>
<dd>
<p>隐式乐观锁定机制正在使用专用版本列。</p>
</dd>
<dt class="hdlist1">所有</dt>
<dd>
<p>隐式乐观锁定机制将<strong>所有</strong>属性用作扩展的WHERE子句限制的一部分， <code>UPDATE</code>和<code>DELETE</code> SQL语句。</p>
</dd>
<dt class="hdlist1">脏</dt>
<dd>
<p>隐式的乐观锁定机制将<strong>脏</strong>属性（已修改的属性）用作扩展的WHERE子句限制的一部分， <code>UPDATE</code>和<code>DELETE</code> SQL语句。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关更多信息，请参见无<a href="#locking-optimistic-versionless">版本乐观锁定</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-orderby"><a class="anchor" href="#annotations-hibernate-orderby"></a> 25.2.63。<code>@OrderBy</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/OrderBy.html"><code>@OrderBy</code></a>注解用于指定<strong>SQL</strong>排序指令以对当前带注释的集合进行排序。</p>
</div>
<div class="paragraph">
<p>它与JPA不同<a href="#annotations-jpa-orderby"><code>@OrderBy</code></a>注释，因为JPA注释需要JPQL排序片段，而不是SQL指令。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-customizing-ordered-by-sql-clause"><code>@OrderBy</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-paramdef"><a class="anchor" href="#annotations-hibernate-paramdef"></a> 25.2.64。<code>@ParamDef</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ParamDef.html"><code>@ParamDef</code></a>批注与<a href="#annotations-hibernate-filterdef"><code>@FilterDef</code></a>这样就可以使用运行时提供的参数值来自定义Hibernate Filter。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参<a href="#pc-filter-example">见过滤器映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-parameter"><a class="anchor" href="#annotations-hibernate-parameter"></a> 25.2.65。<code>@Parameter</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Parameter.html"><code>@Parameter</code></a>注解是用于参数化其他注解的通用参数（基本上是键/值组合），例如<a href="#annotations-hibernate-collectiontype"><code>@CollectionType</code></a> ， <a href="#annotations-hibernate-genericgenerator"><code>@GenericGenerator</code></a>和<a href="#annotations-hibernate-type"><code>@Type</code></a> ， <a href="#annotations-hibernate-typedef"><code>@TypeDef</code></a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-parent"><a class="anchor" href="#annotations-hibernate-parent"></a> 25.2.66。<code>@Parent</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Parent.html"><code>@Parent</code></a>注解用于指定当前带注释的可嵌入属性引用了所属实体。</p>
</div>
<div class="paragraph">
<p>见<a href="#embeddable-Parent"><code>@Parent</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-persister"><a class="anchor" href="#annotations-hibernate-persister"></a> 25.2.67。<code>@Persister</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Persister.html"><code>@Persister</code></a>批注用于指定自定义实体或集合持久性。</p>
</div>
<div class="paragraph">
<p>对于实体，自定义持久程序必须实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/entity/EntityPersister.html"><code>EntityPersister</code></a>接口。</p>
</div>
<div class="paragraph">
<p>对于集合，自定义持久性必须实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/persister/collection/CollectionPersister.html"><code>CollectionPersister</code></a>接口。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-persister"><code>@Persister</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-polymorphism"><a class="anchor" href="#annotations-hibernate-polymorphism"></a> 25.2.68。<code>@Polymorphism</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Polymorphism.html"><code>@Polymorphism</code></a>批注用于定义<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/PolymorphismType.html"><code>PolymorphismType</code></a> Hibernate将适用于实体层次结构。</p>
</div>
<div class="paragraph">
<p>有两种可能<code>PolymorphismType</code>选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">显式</dt>
<dd>
<p>仅在明确询问时才检索当前带注释的实体。</p>
</dd>
<dt class="hdlist1">隐含的</dt>
<dd>
<p>如果检索到其任何超级实体，则检索当前带注释的实体。这是默认选项。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>见<a href="#entity-inheritance-polymorphism"><code>@Polymorphism</code></a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-proxy"><a class="anchor" href="#annotations-hibernate-proxy"></a> 25.2.69。<code>@Proxy</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Proxy.html"><code>@Proxy</code></a>注解用于为当前带注释的实体指定自定义代理实现。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-proxy"><code>@Proxy</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-rowid"><a class="anchor" href="#annotations-hibernate-rowid"></a> 25.2.70。<code>@RowId</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/RowId.html"><code>@RowId</code></a>批注用于指定用作<code>ROWID</code>伪列。例如，Oracle定义了<a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns008.htm"><code>ROWID</code>伪列</a> ，它提供每个表行的地址。</p>
</div>
<div class="paragraph">
<p>根据Oracle文档， <code>ROWID</code>是从表访问单行的最快方法。</p>
</div>
<div class="paragraph">
<p>见<a href="#identifiers-rowid"><code>@RowId</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-selectbeforeupdate"><a class="anchor" href="#annotations-hibernate-selectbeforeupdate"></a> 25.2.71。<code>@SelectBeforeUpdate</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SelectBeforeUpdate.html"><code>@SelectBeforeUpdate</code></a>注释用于指定当重新附着分离的实体时是否确定是否执行更新时，从数据库中选择当前已注释的实体状态。</p>
</div>
<div class="paragraph">
<p>见<a href="#locking-optimistic-lock-type-dirty-example"><code>OptimisticLockType.DIRTY</code>映射</a>部分以获取有关如何的更多信息<code>@SelectBeforeUpdate</code>作品。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sort"><a class="anchor" href="#annotations-hibernate-sort"></a> 25.2.72。<span class="line-through"><code>@Sort</code></span></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Sort.html"><span class="line-through"><code>@Sort</code></span></a>注解已弃用。使用特定的Hibernate <a href="#annotations-hibernate-sortcomparator"><code>@SortComparator</code></a>要么<a href="#annotations-hibernate-sortnatural"><code>@SortNatural</code></a>注释代替。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sortcomparator"><a class="anchor" href="#annotations-hibernate-sortcomparator"></a> 25.2.73。<code>@SortComparator</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SortComparator.html"><code>@SortComparator</code></a>批注用于指定一个<code>Comparator</code>用于排序<code>Set</code> / <code>Map</code>在记忆中。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-unidirectional-sorted-set-custom-comparator-example"><code>@SortComparator</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sortnatural"><a class="anchor" href="#annotations-hibernate-sortnatural"></a> 25.2.74。<code>@SortNatural</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SortNatural.html"><code>@SortNatural</code></a>批注用于指定<code>Set</code> / <code>Map</code>应该使用自然排序进行排序。</p>
</div>
<div class="paragraph">
<p>见<a href="#collections-bidirectional-sorted-set-example"><code>@SortNatural</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-source"><a class="anchor" href="#annotations-hibernate-source"></a> 25.2.75。<code>@Source</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Source.html"><code>@Source</code></a>注释与<code>@Version</code>时间戳实体属性，指示<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SourceType.html"><code>SourceType</code></a>时间戳值。</p>
</div>
<div class="paragraph">
<p>的<code>SourceType</code>提供两种选择：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">D B</dt>
<dd>
<p>从数据库获取时间戳。</p>
</dd>
<dt class="hdlist1">虚拟机</dt>
<dd>
<p>从当前的JVM获取时间戳。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#locking-optimistic-version-timestamp-source-mapping-example">数据库生成的版本时间戳映射</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sqldelete"><a class="anchor" href="#annotations-hibernate-sqldelete"></a> 25.2.76。<code>@SQLDelete</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SQLDelete.html"><code>@SQLDelete</code></a>批注用于指定自定义SQL <code>DELETE</code>当前注释的实体或集合的语句。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sqldeleteall"><a class="anchor" href="#annotations-hibernate-sqldeleteall"></a> 25.2.77。<code>@SQLDeleteAll</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SQLDeleteAll.html"><code>@SQLDeleteAll</code></a>批注用于指定自定义SQL <code>DELETE</code>删除当前带注释集合的所有元素时的语句。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sqlfragmentalias"><a class="anchor" href="#annotations-hibernate-sqlfragmentalias"></a> 25.2.78。<code>@SqlFragmentAlias</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SqlFragmentAlias.html"><code>@SqlFragmentAlias</code></a>批注用于为Hibernate指定别名<a href="#annotations-hibernate-filter"><code>@Filter</code></a> 。</p>
</div>
<div class="paragraph">
<p>别名（例如<code>myAlias</code> ）然后可以在<code>@Filter</code><code>condition</code>子句使用<code>{alias}</code> （例如<code>{myAlias}</code> ）占位符。</p>
</div>
<div class="paragraph">
<p>见<a href="#pc-filter-sql-fragment-alias"><code>@SqlFragmentAlias</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sqlinsert"><a class="anchor" href="#annotations-hibernate-sqlinsert"></a> 25.2.79。<code>@SQLInsert</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SQLInsert.html"><code>@SQLInsert</code></a>批注用于指定自定义SQL <code>INSERT</code>当前注释的实体或集合的语句。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-sqlupdate"><a class="anchor" href="#annotations-hibernate-sqlupdate"></a> 25.2.80。<code>@SQLUpdate</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/SQLUpdate.html"><code>@SQLUpdate</code></a>批注用于指定自定义SQL <code>UPDATE</code>当前注释的实体或集合的语句。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ <a href="#sql-custom-crud-example">自定义CRUD映射”</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-subselect"><a class="anchor" href="#annotations-hibernate-subselect"></a> 25.2.81。<code>@Subselect</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Subselect.html"><code>@Subselect</code></a>批注用于使用自定义SQL指定不可变的只读实体<code>SELECT</code>声明。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见将<a href="#entity-sql-query-mapping">实体映射到SQL查询</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-synchronize"><a class="anchor" href="#annotations-hibernate-synchronize"></a> 25.2.82。<code>@Synchronize</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Synchronize.html"><code>@Synchronize</code></a>注释通常与<a href="#annotations-hibernate-subselect"><code>@Subselect</code></a>注释以指定由...使用的数据库表的列表<code>@Subselect</code> SQL查询。</p>
</div>
<div class="paragraph">
<p>有了这些信息后，只要针对<code>@Subselect</code>实体在持久化上下文已针对由数据库使用的数据库表安排了一些插入/更新/删除操作时执行<code>@Subselect</code> SQL查询。</p>
</div>
<div class="paragraph">
<p>因此， <code>@Synchronize</code>注释可防止派生实体在针对实体执行查询时返回过时的数据。 <code>@Subselect</code>实体。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见将<a href="#entity-sql-query-mapping">实体映射到SQL查询</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-table"><a class="anchor" href="#annotations-hibernate-table"></a> 25.2.83。<code>@Table</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Table.html"><code>@Table</code></a>批注用于为JPA指定附加信息<a href="#annotations-hibernate-table"><code>@Table</code></a>注释，如自定义<code>INSERT</code> ， <code>UPDATE</code>要么<code>DELETE</code>陈述或特定<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/FetchMode.html"><code>FetchMode</code></a> 。</p>
</div>
<div class="paragraph">
<p>见<a href="#sql-custom-crud-secondary-table-example"><code>@SecondaryTable</code>映射</a>部分以获取有关特定于Hibernate的更多信息<code>@Table</code>映射。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-tables"><a class="anchor" href="#annotations-hibernate-tables"></a> 25.2.84。<code>@Tables</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Tables.html"><code>@Tables</code></a>批注用于分组多个<a href="#annotations-hibernate-table"><code>@Table</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-target"><a class="anchor" href="#annotations-hibernate-target"></a> 25.2.85。<code>@Target</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Target.html"><code>@Target</code></a>当当前带注释的关联使用接口类型时，注释用于指定显式目标实现。</p>
</div>
<div class="paragraph">
<p>见<a href="#embeddable-Target"><code>@Target</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-tuplizer"><a class="anchor" href="#annotations-hibernate-tuplizer"></a> 25.2.86。<code>@Tuplizer</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Tuplizer.html"><code>@Tuplizer</code></a>注解用于为当前带注释的实体或可嵌入的实体指定自定义修饰符。</p>
</div>
<div class="paragraph">
<p>对于实体，导师必须实施<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tuple/entity/EntityTuplizer.html"><code>EntityTuplizer</code></a>接口。</p>
</div>
<div class="paragraph">
<p>对于可嵌入的内容，讲解器必须实现<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/tuple/component/ComponentTuplizer.html"><code>ComponentTuplizer</code></a>接口。</p>
</div>
<div class="paragraph">
<p>见<a href="#entity-tuplizer"><code>@Tuplizer</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-tuplizers"><a class="anchor" href="#annotations-hibernate-tuplizers"></a> 25.2.87。<code>@Tuplizers</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Tuplizers.html"><code>@Tuplizers</code></a>批注用于分组多个<a href="#annotations-hibernate-tuplizer"><code>@Tuplizer</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-type"><a class="anchor" href="#annotations-hibernate-type"></a> 25.2.88。<code>@Type</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Type.html"><code>@Type</code></a>注释用于指定Hibernate<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/type/Type.html"><code>@Type</code></a>由当前注释的基本属性使用。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-custom-type-BitSetType-mapping-example"><code>@Type</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-typedef"><a class="anchor" href="#annotations-hibernate-typedef"></a> 25.2.89。<code>@TypeDef</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/TypeDef.html"><code>@TypeDef</code></a>批注用于指定一个<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/type/Type.html"><code>@Type</code></a>定义，以后可用于多个基本属性映射。</p>
</div>
<div class="paragraph">
<p>见<a href="#basic-custom-type-BitSetTypeDef-mapping-example"><code>@TypeDef</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-typedefs"><a class="anchor" href="#annotations-hibernate-typedefs"></a> 25.2.90。<code>@TypeDefs</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/TypeDefs.html"><code>@TypeDefs</code></a>批注用于分组多个<a href="#annotations-hibernate-typedef"><code>@TypeDef</code></a>注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-updatetimestamp"><a class="anchor" href="#annotations-hibernate-updatetimestamp"></a> 25.2.91。<code>@UpdateTimestamp</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/UpdateTimestamp.html"><code>@UpdateTimestamp</code></a>注解用于指定每当拥有实体被修改时，应使用当前JVM时间戳更新当前注释的时间戳属性。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Date</code></p>
</li>
<li>
<p><code>java.util.Calendar</code></p>
</li>
<li>
<p><code>java.sql.Date</code></p>
</li>
<li>
<p><code>java.sql.Time</code></p>
</li>
<li>
<p><code>java.sql.Timestamp</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>见<a href="#mapping-generated-UpdateTimestamp"><code>@UpdateTimestamp</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-valuegenerationtype"><a class="anchor" href="#annotations-hibernate-valuegenerationtype"></a> 25.2.92。<code>@ValueGenerationType</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/ValueGenerationType.html"><code>@ValueGenerationType</code></a>注解用于指定当前的注解类型应用作生成器注解类型。</p>
</div>
<div class="paragraph">
<p>见<a href="#mapping-database-generated-value-example"><code>@ValueGenerationType</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-where"><a class="anchor" href="#annotations-hibernate-where"></a> 25.2.93。<code>@Where</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/Where.html"><code>@Where</code></a>批注用于指定自定义SQL <code>WHERE</code>提取实体或集合时使用的子句。</p>
</div>
<div class="paragraph">
<p>见<a href="#pc-where-example"><code>@Where</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotations-hibernate-wherejointable"><a class="anchor" href="#annotations-hibernate-wherejointable"></a> 25.2.94。<code>@WhereJoinTable</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/WhereJoinTable.html"><code>@WhereJoinTable</code></a>批注用于指定自定义SQL <code>WHERE</code>提取联接收集表时使用的子句。</p>
</div>
<div class="paragraph">
<p>见<a href="#pc-where-join-table"><code>@WhereJoinTable</code>映射</a>部分以获取更多信息。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="best-practices"><a class="anchor" href="#best-practices"></a> 26性能调优和最佳实践</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每个企业系统都是唯一的。但是，拥有非常高效的数据访问层是许多企业应用程序的普遍要求。Hibernate具有多种功能，可以帮助您调整数据访问层。</p>
</div>
<div class="sect2">
<h3 id="best-practices-schema"><a class="anchor" href="#best-practices-schema"></a> 26.1。模式管理</h3>
<div class="paragraph">
<p>尽管Hibernate提供了<code>update</code>的选项<code>hibernate.hbm2ddl.auto</code>配置属性，此功能不适用于生产环境。</p>
</div>
<div class="paragraph">
<p>一个自动化的架构迁移工具（如<a href="https://flywaydb.org/">迁飞</a> ， <a href="http://www.liquibase.org/">Liquibase</a> ）允许你使用任何特定数据库的DDL功能（如规则，触发器，分区表）。每个迁移都应具有一个关联的脚本，该脚本与应用程序源代码一起存储在版本控制系统中。</p>
</div>
<div class="paragraph">
<p>如果将应用程序部署在类似生产的QA环境中，并且部署按预期进行，那么将部署推送到生产环境应该很简单，因为已经测试了最新的架构迁移。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您应该始终使用自动模式迁移工具，并将所有迁移脚本存储在版本控制系统中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-logging"><a class="anchor" href="#best-practices-logging"></a> 26.2。记录中</h3>
<div class="paragraph">
<p>无论何时使用代表您生成SQL语句的框架，都必须确保生成的语句首先是您想要的。</p>
</div>
<div class="paragraph">
<p>日志记录语句有多种选择。您可以通过配置基础日志记录框架来记录语句。对于Log4j，可以使用以下附加程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">### log just the SQL
log4j.logger.org.hibernate.SQL=debug

### log JDBC bind parameters ###
log4j.logger.org.hibernate.type=trace
log4j.logger.org.hibernate.type.descriptor.sql=trace</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，还有其他一些选择，例如使用datasource-proxy或p6spy。使用JDBC的优势<code>Driver</code>要么<code>DataSource</code>代理是您可以超越简单的SQL日志记录：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>语句执行时间</p>
</li>
<li>
<p>JDBC批处理记录</p>
</li>
<li>
<p><a href="https://github.com/vladmihalcea/flexy-pool">数据库连接监控</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用<code>DataSource</code>代理是您可以在测试时声明已执行语句的数量。这样，当自动检测到N + 1查询问题时，可以使集成测试失败。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尽管简单的语句记录很好，但使用<a href="https://github.com/ttddyy/datasource-proxy">datasource-proxy</a>或<a href="https://github.com/p6spy/p6spy">p6spy</a>更好。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-jdbc-batching"><a class="anchor" href="#best-practices-jdbc-batching"></a> 26.3。JDBC批处理</h3>
<div class="paragraph">
<p>JDBC允许我们批处理多个SQL语句并将它们发送到单个请求中到数据库服务器。这样可以节省数据库往返时间，因此可以<a href="https://leanpub.com/high-performance-java-persistence/read#jdbc-batch-updates">大大减少响应时间</a> 。</p>
</div>
<div class="paragraph">
<p>不只是<code>INSERT</code>和<code>UPDATE</code>陈述，但即使<code>DELETE</code>语句也可以批处理。对于<code>INSERT</code>和<code>UPDATE</code>语句，请确保您具有所有正确的配置属性，例如订购插入和更新以及激活版本数据的批处理。请查看本文以获取有关此主题的更多详细信息。</p>
</div>
<div class="paragraph">
<p>对于<code>DELETE</code>语句，没有选择排序父语句和子语句的选项，因此级联会干扰JDBC批处理过程。</p>
</div>
<div class="paragraph">
<p>与其他任何无法自动生成SQL语句的框架不同，Hibernate使激活JDBC级批处理变得非常容易，如<a href="#batch">Batching一章所述</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-mapping"><a class="anchor" href="#best-practices-mapping"></a> 26.4。映射</h3>
<div class="paragraph">
<p>选择正确的映射对于高性能数据访问层非常重要。从标识符生成器到关联，有许多选项可供选择，但从性能的角度来看，并非所有选择都是平等的。</p>
</div>
<div class="sect3">
<h4 id="best-practices-mapping-identifiers"><a class="anchor" href="#best-practices-mapping-identifiers"></a> 26.4.1。身份标识</h4>
<div class="paragraph">
<p>关于标识符，您可以选择自然ID或合成密钥。</p>
</div>
<div class="paragraph">
<p>对于自然标识符， <strong>分配的</strong>标识符生成器是正确的选择。</p>
</div>
<div class="paragraph">
<p>对于合成密钥，应用程序开发人员可以选择随机生成的固定大小序列（例如UUID）或自然标识符。自然标识符非常实用，比UUID标识符更紧凑，因此有多个生成器可供选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IDENTITY</code></p>
</li>
<li>
<p><code>SEQUENCE</code></p>
</li>
<li>
<p><code>TABLE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然<code>TABLE</code>生成器解决了可移植性问题，实际上，它性能很差，因为它需要使用单独的事务和行级锁来模拟数据库序列。因此，通常在<code>IDENTITY</code>和<code>SEQUENCE</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果基础数据库支持序列，则应始终将其用作Hibernate实体标识符。</p>
</div>
<div class="paragraph">
<p>仅在关系数据库不支持序列（例如MySQL 5.7）时，才应使用<code>IDENTITY</code>发电机。但是，您应该记住<code>IDENTITY</code>生成器禁用JDBC批处理<code>INSERT</code>陈述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用的是<code>SEQUENCE</code>生成器，那么您应该使用在Hibernate 5中默认启用的增强标识符生成器。<strong>汇集</strong>和<strong>汇集-LO</strong>优化是每个写入数据库事务多个实体时减少数据库的往返次数非常有用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="best-practices-mapping-associations"><a class="anchor" href="#best-practices-mapping-associations"></a> 26.4.2。社团协会</h4>
<div class="paragraph">
<p>JPA提供了四种实体关联类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ManyToOne</code></p>
</li>
<li>
<p><code>@OneToOne</code></p>
</li>
<li>
<p><code>@OneToMany</code></p>
</li>
<li>
<p><code>@ManyToMany</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和<code>@ElementCollection</code>用于收集可嵌入物。</p>
</div>
<div class="paragraph">
<p>由于对象关联可以是双向的，因此存在许多可能的关联组合。但是，从数据库的角度来看，并非每种可能的关联类型都是有效的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关联映射越接近基础数据库关系，它将执行得越好。</p>
</div>
<div class="paragraph">
<p>另一方面，关联映射越奇特，效率低下的机会就越大。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此， <code>@ManyToOne</code>和<code>@OneToOne</code>儿童方面的协会最好代表<code>FOREIGN KEY</code>关系。</p>
</div>
<div class="paragraph">
<p>父母一方<code>@OneToOne</code>关联需要字节码增强，以便可以延迟加载关联。否则，即使关联标记为，也总是获取父端<code>FetchType.LAZY</code> 。</p>
</div>
<div class="paragraph">
<p>因此，最好是映射<code>@OneToOne</code>关联使用<code>@MapsId</code>所以这样<code>PRIMARY KEY</code>在子实体和父实体之间共享。使用时<code>@MapsId</code> ，由于可以使用父实体标识符轻松获取子实体，因此父方变得多余。</p>
</div>
<div class="paragraph">
<p>对于集合，关联可以是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单向</p>
</li>
<li>
<p>双向的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于单向收集， <code>Sets</code>是最佳选择，因为它们会生成最有效的SQL语句。单向<code>Lists</code>效率不如<code>@ManyToOne</code>协会。</p>
</div>
<div class="paragraph">
<p>双向关联通常是更好的选择，因为<code>@ManyToOne</code>边控制关联。</p>
</div>
<div class="paragraph">
<p>可嵌入的收藏集（ <code>`@ElementCollection</code> ）是单向关联，因此<code>Sets</code>效率最高，其次是<code>Lists</code> ，而箱包（无序<code>Lists</code> ）效率最低。</p>
</div>
<div class="paragraph">
<p>的<code>@ManyToMany</code>注释很少是一个好选择，因为它将双方都视为单向关联。</p>
</div>
<div class="paragraph">
<p>因此，映射链接表要好得多，如“ <a href="#associations-many-to-many-bidirectional-with-link-entity-lifecycle-example">具有链接实体</a>的<a href="#associations-many-to-many-bidirectional-with-link-entity-lifecycle-example">双向多对多生命周期”</a>部分所述。每<code>FOREIGN KEY</code>列将被映射为<code>@ManyToOne</code>协会。在每个父端，双向<code>@OneToMany</code>协会将映射到上述<code>@ManyToOne</code>链接实体中的关系。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅仅因为您对集合具有支持，并不意味着您必须将任何一对多数据库关系转换为一个集合。</p>
</div>
<div class="paragraph">
<p>有时候， <code>@ManyToOne</code>关联就足够了，并且可以使用实体查询简单地替换集合，该实体查询更易于分页或过滤。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-inheritance"><a class="anchor" href="#best-practices-inheritance"></a> 26.5。遗产</h3>
<div class="paragraph">
<p>JPA提供<code>SINGLE_TABLE</code> ， <code>JOINED</code>和<code>TABLE_PER_CLASS</code>处理继承映射，每种策略各有利弊。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SINGLE_TABLE</code>在执行的SQL语句方面表现最佳。但是，您不能使用<code>NOT NULL</code>列级别的约束。您仍然可以使用触发器和规则来强制执行此类约束，但这并不是那么简单。</p>
</li>
<li>
<p><code>JOINED</code>解决了数据完整性问题，因为每个子类都与一个不同的表关联。多态查询或<code>@OneToMany</code>基类关联在这种策略下效果不佳。但是，多态<code>@ManyToOne</code>关联很好，它们可以提供很多价值。</p>
</li>
<li>
<p><code>TABLE_PER_CLASS</code>应该避免使用它，因为它不能呈现有效的SQL语句。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-fetching"><a class="anchor" href="#best-practices-fetching"></a> 26.6。正在取得</h3>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于绝大多数JPA应用程序而言，获取太多数据是性能的首要问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate支持实体查询（JPQL / HQL和Criteria API）和本机SQL语句。实体查询仅在您需要修改获取的实体时才有用，因此可以从自动脏检查机制中受益。</p>
</div>
<div class="paragraph">
<p>对于只读事务，应该获取DTO预测，因为它们使您可以选择满足特定业务用例所需的任意多列。这具有许多好处，例如可以减少当前运行的持久性上下文的负担，因为不需要管理DTO投影。</p>
</div>
<div class="sect3">
<h4 id="best-practices-fetching-associations"><a class="anchor" href="#best-practices-fetching-associations"></a> 26.6.1。提取关联</h4>
<div class="paragraph">
<p>与关联相关，有两种主要的获取策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EAGER</code></p>
</li>
<li>
<p><code>LAZY</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>EAGER</code>提取几乎总是一个坏选择。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在JPA之前，Hibernate曾经将所有关联<code>LAZY</code>默认。但是，当JPA 1.0规范出现时，人们认为并非所有提供程序都将使用代理。因此， <code>@ManyToOne</code>和<code>@OneToOne</code>协会现在<code>EAGER</code>默认。</p>
</div>
<div class="paragraph">
<p>的<code>EAGER</code>提取策略不能在每个查询的基础上被覆盖，因此即使您不需要该关联，也总是可以对其进行检索。更多，如果您忘记了<code>JOIN FETCH</code>一个<code>EAGER</code>在JPQL查询中关联时，Hibernate将使用辅助语句对其进行初始化，这反过来可能导致N + 1查询问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>所以， <code>EAGER</code>应避免获取。因此，最好将所有关联都标记为<code>LAZY</code>默认。</p>
</div>
<div class="paragraph">
<p>然而， <code>LAZY</code>关联必须在访问之前进行初始化。否则， <code>LazyInitializationException</code>被抛出。有好方法和坏方法来治疗<code>LazyInitializationException</code> 。</p>
</div>
<div class="paragraph">
<p>最好的应对方式<code>LazyInitializationException</code>是在关闭持久性上下文之前获取所有必需的关联。的<code>JOIN FETCH</code>指令适合<code>@ManyToOne</code>和<code>OneToOne</code>关联，并且最多收集一个（例如<code>@OneToMany</code>要么<code>@ManyToMany</code> ）。如果您需要获取多个集合，则为了避免使用笛卡尔积，应使用通过查询以下内容触发的辅助查询： <code>LAZY</code>关联或致电<code>Hibernate#initialize(proxy)</code>方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="best-practices-caching"><a class="anchor" href="#best-practices-caching"></a> 26.7。快取</h3>
<div class="paragraph">
<p>Hibernate具有两个缓存层：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供应用程序级可重复读取的第一级缓存（持久性上下文）。</p>
</li>
<li>
<p>第二级缓存，与应用程序级缓存不同，它不存储实体集合，但存储归一化的脱水实体条目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一级缓存不是“本身”的缓存解决方案，它对于确保<code>READ COMMITTED</code>隔离级别。</p>
</div>
<div class="paragraph">
<p>虽然第一级缓存是短暂的，但当底层<code>EntityManager</code>关闭后，二级缓存会绑定到<code>EntityManagerFactory</code> 。一些第二级缓存提供程序为群集提供支持。因此，节点仅需要存储整个缓存数据的子集。</p>
</div>
<div class="paragraph">
<p>尽管由于从缓存而不是从数据库中检索实体，第二级缓存可以减少事务响应时间，但是还有其他选项可以实现相同的目标，在跳转到第二级缓存层之前，您应该考虑这些替代方案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调整基础数据库缓存，以使工作集适合内存，从而减少磁盘I / O流量。</p>
</li>
<li>
<p>通过JDBC批处理，语句缓存，索引优化数据库语句可以减少平均响应时间，因此也可以提高吞吐量。</p>
</li>
<li>
<p>数据库复制也是增加只读事务吞吐量的非常有价值的选择</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在适当调整数据库后，为了进一步减少平均响应时间并增加系统吞吐量，应用程序级缓存变得不可避免。</p>
</div>
<div class="paragraph">
<p>通常，键值应用程序级缓存（如<a href="https://memcached.org/">Memcached</a>或<a href="http://redis.io/">Redis）</a>是存储数据聚合的常见选择。如果可以复制键值存储中的所有数据，则可以选择关闭数据库系统进行维护，而不会完全失去可用性，因为仍然可以从缓存中提供只读流量。</p>
</div>
<div class="paragraph">
<p>使用应用程序级缓存的主要挑战之一是确保跨实体聚合的数据一致性。这就是二级缓存的解决方法。与Hibernate紧密集成后，二级缓存可以提供更好的数据一致性，因为条目是以标准化方式缓存的，就像在关系数据库中一样。更改父实体只需要更新一次条目缓存，而不是键值存储中级联的缓存条目失效。</p>
</div>
<div class="paragraph">
<p>二级缓存提供了四种缓存并发策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>READ_ONLY</code></p>
</li>
<li>
<p><code>NONSTRICT_READ_WRITE</code></p>
</li>
<li>
<p><code>READ_WRITE</code></p>
</li>
<li>
<p><code>TRANSACTIONAL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>READ_WRITE</code>这是一个非常好的默认并发策略，因为它在不影响吞吐量的情况下提供了强大的一致性保证。的<code>TRANSACTIONAL</code>并发策略使用JTA。因此，当实体经常被修改时，它更合适。</p>
</div>
<div class="paragraph">
<p>都<code>READ_WRITE</code>和<code>TRANSACTIONAL</code>使用直写式缓存，而<code>NONSTRICT_READ_WRITE</code>是通读缓存策略。为此原因， <code>NONSTRICT_READ_WRITE</code>如果经常更改实体，则不太适合。</p>
</div>
<div class="paragraph">
<p>使用群集时，第二级缓存条目分布在多个节点上。使用<a href="http://blog.infinispan.org/2015/10/hibernate-second-level-cache.html">Infinispan分布式缓存时</a> ，仅<code>READ_WRITE</code>和<code>NONSTRICT_READ_WRITE</code>可用于读写缓存。请记住<code>NONSTRICT_READ_WRITE</code>由于较旧的更新是可能的，因此提供了较弱的一致性保证。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关Hibernate Performance Tuning的更多信息，请查看Devoxx France <a href="https://www.youtube.com/watch?v=BTdTEe9QL5k&t=1s">的高性能Hibernate</a>演示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix-legacy-bootstrap"><a class="anchor" href="#appendix-legacy-bootstrap"></a> 27。传统引导</h2>
<div class="sectionbody">
<div class="paragraph">
<p>引导SessionFactory的旧方法是通过<code>org.hibernate.cfg.Configuration</code>宾语。
<code>Configuration</code>从本质上讲，它表示用于指定构建<code>SessionFactory</code> ：从设置，映射到策略等所有内容。我喜欢思考<code>Configuration</code>作为一个大锅，我们向其中添加一堆东西（映射，设置等），并最终从中获得<code>SessionFactory.</code></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传统引导程序机制存在一些重大缺陷，导致其过时和新方法的开发，这将在<a href="#bootstrap-native">Native Bootstrapping中进行</a>讨论。</p>
</div>
<div class="paragraph">
<p><code>Configuration</code>半淘汰，但仍可以使用，但仍以消除这些缺点的有限形式使用。“在幕后”， <code>Configuration</code>使用新的引导程序代码，因此这里的内容以及此处的自动发现功能都可以使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以获取<code>Configuration</code>通过直接实例化它。然后，您可以指定描述您的应用程序对象模型及其到SQL数据库的映射的映射元数据（XML映射文档，带注释的类）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Configuration cfg = new Configuration()
    // addResource does a classpath resource lookup
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml")

    // calls addResource using "/org/hibernate/auction/User.hbm.xml"
    .addClass(`org.hibernate.auction.User.class`)

    // parses Address class for mapping annotations
    .addAnnotatedClass( Address.class )

    // reads package-level (package-info.class) annotations in the named package
    .addPackage( "org.hibernate.auction" )

    .setProperty("hibernate.dialect", "org.hibernate.dialect.H2Dialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有其他方法可以指定配置信息，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将名为hibernate.properties的文件放在类路径的根目录中</p>
</li>
<li>
<p>传递java.util的实例。的属性<code>Configuration#setProperties</code></p>
</li>
<li>
<p>通过一个<code>hibernate.cfg.xml</code>文件</p>
</li>
<li>
<p>使用Java的系统属性<code>-Dproperty=value</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_migration"><a class="anchor" href="#_migration"></a> 28。移民</h2>
<div class="sectionbody">
<div class="paragraph">
<p>将配置方法映射到新API中的相应方法。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addFile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addFile</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#add(XmlDocument)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#add(XmlDocument)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addXML</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addXML</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addCacheableFile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addCacheableFile</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addURL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addURL</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addInputStream</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addInputStream</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addResource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addClass</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addAnnotatedClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addAnnotatedClass</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addPackage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addPackage</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addJar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addJar</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addDirectory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addDirectory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#registerTypeContributor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#registerTypeContributor</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#registerTypeOverride</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#registerTypeOverride</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setProperty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setProperty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setProperties</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setProperties</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addProperties</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#addProperties</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setNamingStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setNamingStrategy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setImplicitNamingStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setImplicitNamingStrategy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setPhysicalNamingStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setPhysicalNamingStrategy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#configure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#configure</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setInterceptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setInterceptor</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setEntityNotFoundDelegate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setEntityNotFoundDelegate</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setSessionFactoryObserver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setSessionFactoryObserver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setCurrentTenantIdentifierResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Configuration#setCurrentTenantIdentifierResolver</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="appendix-legacy-domain-model"><a class="anchor" href="#appendix-legacy-domain-model"></a> 29。传统域模型</h2>
<div class="sectionbody">
<div class="exampleblock">
<div class="title">示例696在中声明版本属性<code>hbm.xml</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.
  --&gt;
&lt;version
    column="version_column"
    name="propertyName"
    type="typename"
    access="field|property|ClassName"
    unsaved-value="null|negative|undefined"
    generated="never|always"
    insert="true|false"
    node="element-name|@attribute-name|element/@attribute|."
/&gt;</code></pre>
</div>
</div>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">柱</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含版本号的列的名称。可选，默认为属性名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">持久类的属性的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">版本号的类型。可选，默认为<code>integer</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate访问属性值的策略。可选，默认为<code>property</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">未保存的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示实例是新实例化的，因此未保存。这将其与在先前会话中保存或加载的分离实例区分开。默认值<code>undefined</code> ，指示应使用标识符属性值。可选的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">产生的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示版本属性值是由数据库生成的。可选，默认为<code>never</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">插入</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否包括<code>version</code> SQL中的列<code>insert</code>陈述。默认为<code>true</code> ，但您可以将其设置为<code>false</code>如果数据库列定义为默认值<code>0</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="exampleblock">
<div class="title">示例697中的时间戳记元素<code>hbm.xml</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.
  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.
  --&gt;
&lt;timestamp
    column="timestamp_column"
    name="propertyName"
    access="field|property|ClassName"
    unsaved-value="null|undefined"
    source="vm|db"
    generated="never|always"
    node="element-name|@attribute-name|element/@attribute|."
/&gt;</code></pre>
</div>
</div>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">柱</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含时间戳的列的名称。可选，默认为属性名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java类型的JavaBeans样式属性的名称<code>Date</code>要么<code>Timestamp</code>持久类的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate用于访问属性值的策略。可选，默认为<code>property</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">未保存的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个版本属性，指示实例是新实例化的并且尚未保存。这将其与在先前会话中保存或加载的分离实例区分开。的默认值<code>undefined</code>表示Hibernate使用标识符属性值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate是从数据库还是从当前JVM检索时间戳。基于数据库的时间戳会产生开销，因为Hibernate每次都需要查询数据库以确定增量下一个值。但是，在群集环境中使用数据库派生的时间戳更加安全。并不是所有的数据库方言都支持数据库当前时间戳的检索。其他人也可能由于缺乏精确度而无法安全锁定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">产生的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳属性值是否由数据库生成。可选，默认为<code>never</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="appendix-legacy-criteria"><a class="anchor" href="#appendix-legacy-criteria"></a> 30岁旧版Hibernate标准查询</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本附录介绍了传统的Hibernate <code>org.hibernate.Criteria</code> API，应视为已弃用。</p>
</div>
<div class="paragraph">
<p>新开发应集中在JPA javax.persistence.criteria。CriteriaQuery API。最终，特定于Hibernate的条件功能将被移植为JPA的扩展<code>javax.persistence.criteria.CriteriaQuery</code> 。有关JPA API的详细信息，请参阅<a href="#criteria">Criteria</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hibernate具有直观，可扩展的条件查询API。</p>
</div>
<div class="sect2">
<h3 id="criteria-creating"><a class="anchor" href="#criteria-creating"></a> 30.1。创建一个<code>Criteria</code>实例</h3>
<div class="paragraph">
<p>介面<code>org.hibernate.Criteria</code>表示针对特定持久性类的查询。的<code>Session</code>是一家工厂<code>Criteria</code>实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-entity-name"><a class="anchor" href="#criteria-entity-name"></a> 30.2。JPA与Hibernate实体名称</h3>
<div class="paragraph">
<p>使用时<a href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/SharedSessionContract.html#createCriteria-java.lang.String-"><code>Session#createCriteria(String entityName)</code>要么<code>StatelessSession#createCriteria(String entityName)</code></a> ， <strong>EntityName</strong>表示基础实体的标准名称，而不是<code>name</code> JPA的属性<code>@Entity</code>注解。</p>
</div>
<div class="paragraph">
<p>考虑到您具有以下实体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity(name = "ApplicationEvent")
public static class Event {

    @Id
    private Long id;

    private String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果将JPA实体名称提供给旧的Criteria查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Event&gt; events =
    entityManager.unwrap( Session.class )
.createCriteria( "ApplicationEvent" )
.list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hibernate将抛出以下内容<code>MappingException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">org.hibernate.MappingException: Unknown entity: ApplicationEvent</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一方面，Hibernate实体名称（完全合格的类名称）可以正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Event&gt; events =
    entityManager.unwrap( Session.class )
.createCriteria( Event.class.getName() )
.list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关此主题的更多信息，请查看<a href="https://hibernate.atlassian.net/browse/HHH-2597">HHH-2597</a> JIRA问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-narrowing"><a class="anchor" href="#criteria-narrowing"></a> 30.3。缩小结果集</h3>
<div class="paragraph">
<p>单个查询条件是接口的一个实例<code>org.hibernate.criterion.Criterion</code> 。班级<code>org.hibernate.criterion.Restrictions</code>定义用于获取某些内置方法的工厂方法<code>Criterion</code>类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>限制可以按逻辑分组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>有多种内置标准类型（ <code>Restrictions</code>子类）。最有用的之一<code>Restrictions</code>允许您直接指定SQL。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sqlRestriction("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>{alias}</code>占位符将替换为所查询实体的行别名。</p>
</div>
<div class="paragraph">
<p>您还可以从<code>Property</code>实例。您可以创建一个<code>Property</code>通过打电话<code>Property.forName()</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-ordering"><a class="anchor" href="#criteria-ordering"></a> 30.4。排序结果</h3>
<div class="paragraph">
<p>您可以使用以下命令订购结果<code>org.hibernate.criterion.Order</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name").nulls(NullPrecedence.LAST) )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-associations"><a class="anchor" href="#criteria-associations"></a> 30.5。社团协会</h3>
<div class="paragraph">
<p>通过使用导航关联<code>createCriteria()</code>您可以指定对相关实体的约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%") )
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%") )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二<code>createCriteria()</code>返回的新实例<code>Criteria</code>指的是<code>kittens</code>采集。</p>
</div>
<div class="paragraph">
<p>还有一种在某些情况下有用的替代形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>（ <code>createAlias()</code>不会创建的新实例<code>Criteria</code> ）</p>
</div>
<div class="paragraph">
<p>举行的小猫收藏<code>Cat</code>前两个查询返回的实例<em>未按条件</em>预先过滤。如果您只想检索符合条件的小猫，则必须使用<code>ResultTransformer</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您可以使用左外部联接来操纵结果集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>List cats = session.createCriteria( Cat.class )
   .createAlias("mate", "mt", Criteria.LEFT_JOIN, Restrictions.like("mt.name", "good%") )
   .addOrder(Order.asc("mt.age"))
   .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将返回所有`Cat`，并且其配偶的名称以其同龄人的年龄排序为“好”，以及所有没有配偶的猫。当需要在返回复杂/大型结果集之前对数据库进行排序或限制时，这很有用，并且可以删除许多必须执行多个查询并将结果由Java合并到内存中的实例。</p>
</div>
<div class="paragraph">
<p>如果没有此功能，则首先需要在一个查询中加载所有没有伴侣的猫。</p>
</div>
<div class="paragraph">
<p>第二个查询将需要检索以名字“ good”开头的，按同伴年龄分类的同伴的猫。</p>
</div>
<div class="paragraph">
<p>第三，在记忆中；这些列表将需要手动加入。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-dynamicfetching"><a class="anchor" href="#criteria-dynamicfetching"></a> 30.6。动态关联获取</h3>
<div class="paragraph">
<p>您可以在运行时使用以下命令指定关联获取语义<code>setFetchMode()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>该查询将同时获取<code>mate</code>和<code>kittens</code>通过外部联接。</p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-components"><a class="anchor" href="#criteria-components"></a> 30.7。组件</h3>
<div class="paragraph">
<p>要添加对嵌入式组件属性的限制，在创建嵌入式组件时，组件属性名称应放在该属性名称之前。 <code>Restriction</code> 。条件对象应该在拥有实体上创建，而不能在组件本身上创建。例如，假设<code>Cat</code>具有组件属性<code>fullName</code>带有子属性<code>firstName</code>和<code>lastName</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>List cats = session.createCriteria(Cat.class)
    .add(Restrictions.eq("fullName.lastName", "Cattington"))
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：这不适用于查询组件的集合，有关信息请参见下面的<a href="#criteria-collections">集合</a></p>
</div>
</div>
<div class="sect2">
<h3 id="criteria-collections"><a class="anchor" href="#criteria-collections"></a> 30.8。馆藏</h3>
<div class="paragraph">
<p>在对集合使用条件时，有两种不同的情况。一种是如果集合包含实体（例如<code><one-to-many/></code>要么<code><many-to-many/></code> ）或组件（ <code><composite-element/></code> ），第二个是集合中是否包含标量值（ <code><element/></code> ）。在第一种情况下，语法如上文“ <a href="#criteria-associations">关联</a> ”部分中所述，我们在其中限制了<code>kittens</code>采集。本质上，我们创建了一个<code>Criteria</code>对象反对集合属性，并使用该实例限制实体或组件属性。</p>
</div>
<div class="paragraph">
<p>为了查询基本值的集合，我们仍然创建<code>Criteria</code>对象反对集合，但要引用值，我们使用特殊属性“元素”。对于索引集合，我们还可以使用特殊属性“ indices”来引用index属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>List cats = session.createCriteria(Cat.class)
    .createCriteria("nickNames")
    .add(Restrictions.eq("elements", "BadBoy"))
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-examples"><a class="anchor" href="#criteria-examples"></a> 30.9。查询示例</h3>
<div class="paragraph">
<p>班级<code>org.hibernate.criterion.Example</code>允许您从给定实例构造查询条件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>版本属性，标识符和关联将被忽略。默认情况下，排除空值属性。</p>
</div>
<div class="paragraph">
<p>您可以调整<code>Example</code>被申请;被应用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以使用示例在关联对象上放置条件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-projection"><a class="anchor" href="#criteria-projection"></a> 30.10。投影，汇总和分组</h3>
<div class="paragraph">
<p>班级<code>org.hibernate.criterion.Projections</code>是一家工厂<code>Projection</code>实例。您可以通过调用将投影应用于查询<code>setProjection()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在条件查询中，没有明确的“分组依据”。某些投影类型被定义为<em>分组投影</em> ，它们也出现在SQL中<code>group by</code>条款。</p>
</div>
<div class="paragraph">
<p>可以将别名分配给投影，以便可以在限制或顺序中引用投影值。这是两种不同的方法来执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>alias()</code>和<code>as()</code>方法只是将投影实例包装在的另一个别名实例中<code>Projection</code> 。作为快捷方式，可以在将投影添加到投影列表时分配别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>Property.forName()</code>表达预测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-detachedqueries"><a class="anchor" href="#criteria-detachedqueries"></a> 30.11。分离的查询和子查询</h3>
<div class="paragraph">
<p>的<code>DetachedCriteria</code>类允许您在会话范围之外创建查询，然后使用任意查询执行该查询<code>Session</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );

Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种<code>DetachedCriteria</code>也可以用来表示子查询。
<code>Criterion</code>可以通过以下方式获取涉及子查询的实例<code>Subqueries</code>要么<code>Property</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight").gt(avgWeight) )
    .list();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>相关子查询也是可能的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight").gt(avgWeightForSex) )
    .list();</code></pre>
</div>
</div>
<div class="paragraph">
<p>基于子查询的多列限制示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">DetachedCriteria sizeQuery = DetachedCriteria.forClass( Man.class )
    .setProjection( Projections.projectionList().add( Projections.property( "weight" ) )
                                                .add( Projections.property( "height" ) ) )
    .add( Restrictions.eq( "name", "John" ) );
session.createCriteria( Woman.class )
    .add( Subqueries.propertiesEq( new String[] { "weight", "height" }, sizeQuery ) )
    .list();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-criteria-naturalid"><a class="anchor" href="#query-criteria-naturalid"></a> 30.12。通过自然标识符查询</h3>
<div class="paragraph">
<p>对于大多数查询（包括条件查询），查询缓存效率不高，因为查询缓存失效发生得太频繁了。但是，存在一种特殊的查询，您可以在其中优化缓存失效算法：通过恒定的自然键进行查找。在某些应用程序中，这种查询经常发生。Criteria API为此用例提供了特殊的规定。</p>
</div>
<div class="paragraph">
<p>首先，使用<code><natural-id></code>并启用二级缓存的使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此功能不适用于具有<em>可变</em>自然键的实体。</p>
</div>
<div class="paragraph">
<p>启用Hibernate查询缓存后， <code>Restrictions.naturalId()</code>使您可以利用更高效的缓存算法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb")
    ).setCacheable(true)
    .uniqueResult();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix-legacy-native-queries"><a class="anchor" href="#appendix-legacy-native-queries"></a> 31。旧版Hibernate原生查询</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="legacy-sql-named-queries"><a class="anchor" href="#legacy-sql-named-queries"></a> 31.1。旧式命名SQL查询</h3>
<div class="paragraph">
<p>还可以在映射期间定义命名SQL查询，并以与命名HQL查询完全相同的方式进行调用。在这种情况下，你<em>不需要</em>调用<code>addEntity()</code>不再。</p>
</div>
<div class="exampleblock">
<div class="title">示例698使用命名SQL查询<code><sql-query></code>映射元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例699执行命名查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List people = session
    .getNamedQuery( "persons" )
    .setParameter( "namePattern", namePattern )
    .setMaxResults( 50 )
    .list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code><return-join></code>元素用于加入关联，并且<code><load-collection></code>元素用于定义初始化集合的查询。</p>
</div>
<div class="exampleblock">
<div class="title">示例700具有关联的命名SQL查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>命名的SQL查询可能返回标量值。您必须使用以下命令声明列别名和Hibernate类型<code><return-scalar></code>元件：</p>
</div>
<div class="exampleblock">
<div class="title">示例701命名查询返回标量</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "mySqlQuery"&gt;
    &lt;return-scalar column = "name" type="string"/&gt;
    &lt;return-scalar column = "age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将结果集映射信息外部化<code><resultset></code>元素，您可以通过多个命名查询或通过<code>setResultSetMapping()</code> API。</p>
</div>
<div class="exampleblock">
<div class="title">例子702. <resultset>用于外部化映射信息的映射</resultset></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;resultset name = "personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name = "personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以直接在Java代码中使用hbm文件中的结果集映射信息。</p>
</div>
<div class="exampleblock">
<div class="title">例子703。以编程方式指定结果映射信息</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List cats = session
    .createSQLQuery( "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id" )
    .setResultSetMapping("catAndKitten")
    .list();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="legacy-propertyresults"><a class="anchor" href="#legacy-propertyresults"></a> 31.2。旧版返回属性，用于明确指定列/别名</h3>
<div class="paragraph">
<p>您可以明确告诉Hibernate要使用哪些列别名<code><return-property></code> ，而不是使用<code>{}</code>让Hibernate注入自己的别名的语法。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "mySqlQuery"&gt;
    &lt;return alias = "person" class = "eg.Person"&gt;
        &lt;return-property name = "name" column = "myName"/&gt;
        &lt;return-property name = "age" column = "myAge"/&gt;
        &lt;return-property name = "sex" column = "mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><return-property></code>也适用于多列。这解决了<code>{}</code>不允许对多列属性进行细粒度控制的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "organizationCurrentEmployments"&gt;
    &lt;return alias = "emp" class = "Employment"&gt;
        &lt;return-property name = "salary"&gt;
            &lt;return-column name = "VALUE"/&gt;
            &lt;return-column name = "CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name = "endDate" column = "myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中<code><return-property></code>与<code>{}</code>注入语法。这使用户可以选择他们要如何引用列和属性。</p>
</div>
<div class="paragraph">
<p>如果您的映射有一个鉴别符，则必须使用<code><return-discriminator></code>指定鉴别符列。</p>
</div>
</div>
<div class="sect2">
<h3 id="legacy-sp_query"><a class="anchor" href="#legacy-sp_query"></a> 31.3。旧版存储过程用于查询</h3>
<div class="paragraph">
<p>Hibernate通过存储过程和功能为查询提供支持。以下大多数文档对于两者都是等效的。存储过程/函数必须返回结果集作为第一个输出参数，才能与Hibernate一起使用。在Oracle 9和更高版本中，这样的存储函数的示例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
        SELECT EMPLOYEE, EMPLOYER,
        STARTDATE, ENDDATE,
        REGIONCODE, EID, VALUE, CURRENCY
        FROM EMPLOYMENT;
    RETURN  st_cursor;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在Hibernate中使用此查询，您需要通过命名查询将其映射。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "selectAllEmployees_SP" callable = "true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name = "employee" column = "EMPLOYEE"/&gt;
        &lt;return-property name = "employer" column = "EMPLOYER"/&gt;
        &lt;return-property name = "startDate" column = "STARTDATE"/&gt;
        &lt;return-property name = "endDate" column = "ENDDATE"/&gt;
        &lt;return-property name = "regionCode" column = "REGIONCODE"/&gt;
        &lt;return-property name = "id" column = "EID"/&gt;
        &lt;return-property name = "salary"&gt;
            &lt;return-column name = "VALUE"/&gt;
            &lt;return-column name = "CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当前，存储过程仅返回标量和实体。
<code><return-join></code>和<code><load-collection></code>不支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="legacy-sql-limits-storedprocedures"><a class="anchor" href="#legacy-sql-limits-storedprocedures"></a> 31.4。使用存储过程的旧规则/限制</h3>
<div class="paragraph">
<p>除非遵循某些过程/功能规则，否则不能将存储过程与Hibernate一起使用。如果他们不遵守这些规则，则无法在Hibernate中使用。如果仍然要使用这些过程，则必须通过以下方式执行它们<code>session.doWork()</code> 。</p>
</div>
<div class="paragraph">
<p>每个数据库的规则都不同，因为数据库供应商具有不同的存储过程语义/语法。</p>
</div>
<div class="paragraph">
<p>无法对存储过程查询进行分页<code>setFirstResult()/setMaxResults()</code> 。</p>
</div>
<div class="paragraph">
<p>推荐的调用形式是标准SQL92： <code>{ ? = call functionName(<parameters>) }</code>要么<code>{ ? = call procedureName(<parameters>}</code> 。不支持本机调用语法。</p>
</div>
<div class="paragraph">
<p>对于Oracle，适用以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>函数必须返回结果集。过程的第一个参数必须是<code>OUT</code>返回结果集。这是通过使用<code>SYS_REFCURSOR</code>输入Oracle 9或10。在Oracle中，您需要定义一个<code>REF CURSOR</code>类型。有关更多信息，请参见Oracle文献。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于Sybase或MS SQL Server，适用以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该过程必须返回结果集。注意，由于这些服务器可以返回多个结果集和更新计数，因此Hibernate将迭代结果并将结果集的第一个结果作为其返回值。其他一切将被丢弃。</p>
</li>
<li>
<p>如果可以启用<code>SET NOCOUNT ON</code>在您的过程中，它可能会更有效，但这不是必需的。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="legacy-sql-cud"><a class="anchor" href="#legacy-sql-cud"></a> 31.5。旧版自定义SQL，用于创建，更新和删除</h3>
<div class="paragraph">
<p>Hibernate可以使用自定义SQL进行创建，更新和删除操作。可以在语句级别或单个列级别覆盖SQL。本节介绍语句覆盖。有关列，请参见<a href="#mapping-column-read-and-write">列转换器：读取和写入表达式</a> 。以下示例显示了如何使用注释定义自定义SQL操作。</p>
</div>
<div class="exampleblock">
<div class="title">示例704自定义CRUD XML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;class name = "Person"&gt;
    &lt;id name = "id"&gt;
        &lt;generator class = "increment"/&gt;
    &lt;/id&gt;
    &lt;property name = "name" not-null = "true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您希望调用存储过程，请确保设置<code>callable</code>归因于<code>true</code>在注释和基于XML的映射中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了检查执行是否正确，Hibernate允许您定义以下三种策略之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>none：不执行检查：存储过程在出现问题时会失败</p>
</li>
<li>
<p>计数：使用行数检查更新是否成功</p>
</li>
<li>
<p>参数：类似于COUNT，但使用输出参数而不是标准机制</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要定义结果检查样式，请使用<code>check</code>注释以及xml中再次可用的参数。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，在大多数情况下，需要使用存储过程来返回插入，更新和删除的行数。Hibernate始终将第一个语句参数注册为CUD操作的数字输出参数：</p>
</div>
<div class="exampleblock">
<div class="title">示例705。存储过程及其返回值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="legacy-sql-load"><a class="anchor" href="#legacy-sql-load"></a> 31.6。旧版自定义SQL进行加载</h3>
<div class="paragraph">
<p>您也可以声明自己的SQL（或HQL）查询以进行实体加载。与插入，更新和删除一样，这可以在单独的列级别上完成，如For列中所述，请参阅<a href="#mapping-column-read-and-write">列转换器：读取和写入表达式</a>或在语句级别。这是一个语句级别覆盖的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "person"&gt;
    &lt;return alias = "pers" class = "Person" lock-mod e= "upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，这只是一个命名查询声明。您可以在类映射中引用此命名查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;class name = "Person"&gt;
    &lt;id name = "id"&gt;
        &lt;generator class = "increment"/&gt;
    &lt;/id&gt;
    &lt;property name = "name" not-null = "true"/&gt;
    &lt;loader query-ref = "person"/&gt;
&lt;/class&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这甚至适用于存储过程。</p>
</div>
<div class="paragraph">
<p>您甚至可以为集合加载定义查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;set name = "employments" inverse = "true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class = "Employment"/&gt;
    &lt;loader query-ref = "employments"/&gt;
&lt;/set&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "employments"&gt;
    &lt;load-collection alias = "emp" role = "Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以定义一个实体加载器，该实体加载器通过联接获取来加载集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;sql-query name = "person"&gt;
    &lt;return alias = "pers" class = "Person"/&gt;
    &lt;return-join alias = "emp" property = "pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references"><a class="anchor" href="#_references"></a> 32。参考文献</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="PoEAA"></a> [PoEAA] Martin Fowler。企业应用程序架构的模式。Addison-Wesley出版公司。2003。</p>
</li>
<li>
<p><a id="JPwH"></a> [JPwH] Christian Bauer和Gavin King。<a href="http://www.manning.com/bauer2">Java持久性与Hibernate</a> 。曼宁出版社公司，2007年。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">上次更新时间2019-11-11 19:06:15 GMT</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>