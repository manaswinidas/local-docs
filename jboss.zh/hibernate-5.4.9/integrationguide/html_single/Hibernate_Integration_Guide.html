<html lang="zh-Hans" ><head></head><body class="article" >﻿
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Steve Ebersole, Vlad Mihalcea">
<title>Hibernate ORM 5.4集成指南</title>
<link rel="stylesheet" href="./css/hibernate.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>Hibernate ORM 5.4集成指南</h1>
<div class="details">
<span id="author" class="author">史蒂夫·埃伯索尔（Steve Ebersole），弗拉德·米哈尔西娅（Vlad Mihalcea）</span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#preface">前言</a>
<ul class="sectlevel2">
<li><a href="#_audience">听众</a></li>
</ul>
</li>
<li><a href="#services">1。服务和注册</a>
<ul class="sectlevel2">
<li><a href="#services-service">1.1。什么是服务？</a>
<ul class="sectlevel3">
<li><a href="#services-contracts">1.1.1。 <code>Service</code>合约</a></li>
<li><a href="#services-dependencies">1.1.2。 <code>Service</code>依存关系</a></li>
</ul>
</li>
<li><a href="#services-registry">1.2。什么是<code>ServiceRegistry</code> ？</a></li>
<li><a href="#services-binding">1.3。服务绑定</a></li>
<li><a href="#services-registry-types">1.4。服务注册表的类型</a>
<ul class="sectlevel3">
<li><a href="#services-registry-boot">1.4.1。<code>BootstrapServiceRegistry</code></a></li>
<li><a href="#services-registry-standard">1.4.2。<code>StandardServiceRegistry</code></a></li>
<li><a href="#services-registry-sf">1.4.3。<code>SessionFactoryServiceRegistry</code></a></li>
</ul>
</li>
<li><a href="#services-custom">1.5。海关服务</a>
<ul class="sectlevel3">
<li><a href="#services-overriding">1.5.1。自订<code>Service</code>实现（覆盖）</a></li>
<li><a href="#services-extending">1.5.2。自订<code>Service</code>角色（扩展）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface">前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate是一种用于Java环境的<a href="http://en.wikipedia.org/wiki/Object-relational_mapping">对象/关系映射</a>解决方案。</p>
</div>
<div class="paragraph">
<p>Hibernate不仅负责从Java类到数据库表（以及从Java数据类型到SQL数据类型）的映射，而且还提供数据查询和检索功能。它可以显着减少开发时间，否则将花费在SQL和JDBC中的手动数据处理上。 Hibernate的设计目标是通过消除使用SQL和JDBC进行手工数据手工处理的需求，使开发人员摆脱95％的常见数据持久性相关编程任务。但是，与许多其他持久性解决方案不同，Hibernate不会向您隐藏SQL的强大功能，并保证您对关系技术和知识的投资一如既往地有效。</p>
</div>
<div class="sect2">
<h3 id="_audience">听众</h3>
<div class="paragraph">
<p>本指南适用于将Hibernate与Java EE应用服务器，Spring框架，缓存解决方案（例如Infinispan，Ehcache，Hazelcast）集成的软件开发人员和架构师。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="services">1。服务和注册</h2>
<div class="sectionbody">
<div class="paragraph">
<p>服务和注册是从4.0开始<strong>的正式概念，</strong>是新的。但是，不同服务提供的功能实际上在Hibernate中已经存在了很长时间。新功能是通过轻巧的专用容器（称为容器）来管理它们，它们的生命周期和依赖性<code>ServiceRegistry</code> 。本指南的目的是描述这些产品的设计和目的<code>Services</code>和<code>Registries</code> ，并在适当的地方查看其实现的详细信息。它还将研究第三方集成商和应用程序可以利用和定制的方式<code>Services</code>和<code>Registries</code> 。</p>
</div>
<div class="sect2">
<h3 id="services-service">1.1。什么是服务？</h3>
<div class="paragraph">
<p>服务以可插入方式提供某些类型的功能。具体来说，它们是定义某些功能然后实现这些功能的接口<code>Service</code>合约接口。该接口称为<code>Service</code>角色;实现类称为<code>Service</code>实施。可插拔性来自以下事实： <code>Service</code>实施遵守由接口定义的合同<code>Service</code>角色和消费者<code>Service</code>程序到<code>Service</code>角色，而不是执行。</p>
</div>
<div class="paragraph">
<p>一般来说，用户可以插入所有标准的替代实现<code>Service</code>角色（覆盖）；他们还可以定义基本服务集之外的其他服务<code>Service</code>角色（扩展）。</p>
</div>
<div class="paragraph">
<p>让我们看一个示例，以更好地定义<code>Service</code>是。Hibernate需要能够访问JDBC <code>Connections</code>到数据库。它获取和释放这些内容的方式<code>Connections</code>通过<code>ConnectionProvider</code>服务。的<code>Service</code>由接口定义（服务角色） <code>org.hibernate.engine.jdbc.connections.spi.ConnectionProvider</code>声明获取和释放<code>Connections</code> 。然后有多个实现<code>Service</code>合同，实际管理方式各不相同<code>Connections</code> 。</p>
</div>
<div class="paragraph">
<p>内部Hibernate总是引用<code>org.hibernate.engine.jdbc.connections.spi.ConnectionProvider</code>而不是使用特定的实现<code>Service</code> （我们将制作<code>Service</code>稍后我们讨论注册管理机构时）。因此，其他<code>ConnectionProvider</code><code>Service</code>实现很容易插入。</p>
</div>
<div class="paragraph">
<p>这里没有革命性的东西。对接口进行编程通常被认为是良好的编程习惯。有趣的是<code>ServiceRegistry</code>以及不同实现者的可插拔交换。</p>
</div>
<div class="sect3">
<h4 id="services-contracts">1.1.1。 <code>Service</code>合约</h4>
<div class="paragraph">
<p>基本要求<code>Service</code>是实现标记接口<code>org.hibernate.service.Service</code> 。Hibernate在内部将其用于某些基本类型的安全性。</p>
</div>
<div class="paragraph">
<p>的<code>Service</code>还可以实施一些与生命周期相关的可选合同：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.service.spi.Startable</code></dt>
<dd>
<p>允许<code>Service</code>暗示将被通知它正在启动并即将投入使用。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.service.spi.Stoppable</code></dt>
<dd>
<p>允许<code>Service</code>暗示将被通知它已停止并且将停止使用。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.service.spi.ServiceRegistryAwareService</code></dt>
<dd>
<p>允许<code>Service</code>注入对管理它的注册表的引用。看到<a href="#services-dependencies"><code>Service</code>依赖项</a>以获取更多详细信息。</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.service.spi.Manageable</code></dt>
<dd>
<p>标记<code>Service</code>如果启用了JMX集成，则在JMX中可管理。此功能仍不完整。</p>
</dd>
<dt class="hdlist1">其他</dt>
<dd>
<p>不同的注册表实现还了解特定于该注册表的其他可选合同。有关详细信息，请参阅<a href="#services-registry">什么是</a>注册表中的每个注册表的详细信息。 <a href="#services-registry"><code>ServiceRegistry</code> ？</a> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="services-dependencies">1.1.2。 <code>Service</code>依存关系</h4>
<div class="paragraph">
<p>允许服务使用两种方法之一声明对其他服务的依赖关系。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@org.hibernate.service.spi.InjectService</code></dt>
<dd>
<div class="paragraph">
<p>上的任何方法<code>Service</code>接受单个参数并用注释的实现类<code>@InjectService</code>被视为请求注入其他服务。</p>
</div>
<div class="paragraph">
<p>默认情况下，method参数的类型应为<code>Service</code>要注入的角色。如果参数类型不同于<code>Service</code>角色，该属性的serviceRole属性<code>@InjectService</code>注释应用于显式命名角色。</p>
</div>
<div class="paragraph">
<p>默认情况下，注入的服务被认为是必需的，也就是说，如果命名的依赖项启动将失败<code>Service</code>不见了。如果<code>Service</code>要注入是可选的， <code>@InjectService</code>注释应声明为<code>false</code> （默认为<code>true</code> ）。</p>
</div>
</dd>
<dt class="hdlist1"><code>org.hibernate.service.spi.ServiceRegistryAwareService</code></dt>
<dd>
<div class="paragraph">
<p>第二种方法是拉动方法，其中<code>Service</code>实现可选<code>Service</code>接口<code>org.hibernate.service.spi.ServiceRegistryAwareService</code>声明一个<code>injectServices</code>方法。</p>
</div>
<div class="paragraph">
<p>在启动过程中，Hibernate将注入<code>org.hibernate.service.ServiceRegistry</code>本身成为实现此接口的服务。的<code>Service</code>然后可以使用<code>ServiceRegistry</code>查找所需的其他任何服务的参考。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="services-registry">1.2。什么是<code>ServiceRegistry</code> ？</h3>
<div class="paragraph">
<p>一种<code>ServiceRegistry</code> ，最基本的是托管和管理服务。它的合同由<code>org.hibernate.service.ServiceRegistry</code>接口。</p>
</div>
<div class="paragraph">
<p>我们已经对服务进行了基本概述和定义。但是服务还具有其他有趣的特征：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务具有生命周期。</p>
</li>
<li>
<p>他们有范围。</p>
</li>
<li>
<p>服务可能依赖于其他服务。</p>
</li>
<li>
<p>需要产生它们（选择使用一种实现而不是另一种实现）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>ServiceRegistry</code>满足所有这些需求。</p>
</div>
<div class="paragraph">
<p>简而言之， <code>ServiceRegistry</code>充当<a href="https://en.wikipedia.org/wiki/Inversion_of_control">控制反转（IoC）</a>容器。</p>
</div>
<div class="paragraph">
<p>为什么不只使用现有的IoC框架？主要原因是它必须重量轻且占用空间尽可能小。最初的设计还要求<code>Services</code>可以在运行时进行交换，但是由于基于代理的交换解决方案中的性能问题，因此不得不将其删除；该计划将在日后研究实现可交换性更好的性能的替代方法。</p>
</div>
<div class="paragraph">
<p>一种<code>Service</code>与一个相关联<code>ServiceRegistry</code> 。的<code>ServiceRegistry</code>范围<code>Service</code> 。的<code>ServiceRegistry</code>管理生命周期<code>Service</code> 。的<code>ServiceRegistry</code>处理将依赖项注入<code>Service</code> （实际上支持拉和推/注入方法）。
<code>ServiceRegistries</code>也是分层的，意思是<code>ServiceRegistry</code>可以有父母<code>ServiceRegistry</code> 。一个注册表中的服务可以依赖并利用同一注册表以及任何父注册表中的服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="services-binding">1.3。服务绑定</h3>
<div class="paragraph">
<p>给定的关联<code>Service</code>给定的<code>ServiceRegistry</code>被称为绑定，并由<code>org.hibernate.service.spi.ServiceBinding</code>接口。此外，ServiceBinding和<code>ServiceRegistry</code>由<code>org.hibernate.service.spi.ServiceBinding.ServiceLifecycleOwner</code>接口。</p>
</div>
<div class="paragraph">
<p>有两种方法<code>Service</code>关联（绑定）到<code>ServiceRegistry</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>Service</code>可以直接实例化然后交给<code>ServiceRegistry</code></p>
</li>
<li>
<p>一种<code>ServiceInitiator</code>可以给<code>ServiceRegistry</code> （其中<code>ServiceRegistry</code>将在何时以及何时使用<code>Service</code>需要）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ServiceRegistry</code>实现通过调用重载来注册绑定<code>org.hibernate.service.internal.AbstractServiceRegistryImpl#createServiceBinding</code>接受一个方法<code>Service</code>实例或<code>ServiceInitiator</code>实例。</p>
</div>
<div class="paragraph">
<p>每种特定类型的注册表都定义自己的注册表<code>ServiceInitiator</code>专业化。</p>
</div>
</div>
<div class="sect2">
<h3 id="services-registry-types">1.4。服务注册表的类型</h3>
<div class="paragraph">
<p>目前，Hibernate使用三种不同的方式<code>ServiceRegistry</code>实现形成层次结构。每种类型都是出于类型安全性的目的而专门化的，但是它们没有添加任何新功能。</p>
</div>
<div class="sect3">
<h4 id="services-registry-boot">1.4.1。<code>BootstrapServiceRegistry</code></h4>
<div class="paragraph">
<p>的<code>org.hibernate.boot.registry.BootstrapServiceRegistry</code>持有三个<code>Service</code>并且通常是通过<code>org.hibernate.boot.registry.BootstrapServiceRegistryBuilder</code>工厂课。构建器使类型安全地访问来定制这三个<code>Services</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该注册表包含的服务对于Hibernate中的大多数功能来说绝对是可用的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在正常使用中， <code>BootstrapServiceRegistry</code>没有父母。</p>
</div>
<div class="paragraph">
<p>的服务<code>BootstrapServiceRegistry</code>不能扩展（添加到）或覆盖（替换）。</p>
</div>
<div class="sect4">
<h5 id="_code_classloaderservice_code"><code>ClassLoaderService</code></h5>
<div class="paragraph">
<p>的<code>Service</code>为此的作用<code>Service</code>是<code>org.hibernate.boot.registry.classloading.spi.ClassLoaderService</code> 。这个<code>Service</code>定义了Hibernate与之交互的能力<code>ClassLoaders</code> 。Hibernate（或任何库）应该与之交互的方式<code>ClassLoaders</code>根据托管应用程序的运行时环境而变化。应用服务器，OSGi容器和其他模块化类加载系统提出了非常特定的类加载要求。这个<code>Service</code>为Hibernate提供了这种环境复杂性的抽象。同样重要的是，它以集中的，可交换的方式进行操作。</p>
</div>
<div class="paragraph">
<p>在此公开的特定功能<code>Service</code>包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定位<code>Class</code>按名称引用。这包括应用程序类以及<em>集成</em>类。</p>
</li>
<li>
<p>将资源（属性文件，xml文件等）定位为<em>类路径资源</em></p>
</li>
<li>
<p>与...互动<code>java.util.ServiceLoader</code> ，Java自己的<code>Service</code>提供者发现机制</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_code_integratorservice_code"><code>IntegratorService</code></h5>
<div class="paragraph">
<p>的<code>Service</code>为此的作用<code>Service</code>是<code>org.hibernate.integrator.spi.IntegratorService.</code>应用程序，第三方集成商和其他所有人都需要与Hibernate集成。从历史上看，这曾经需要某些东西（通常是应用程序）来协调注册代表每个集成所需的每个集成的各个部分。的<code>org.hibernate.integrator.spi.Integrator</code>合同正式确定了该“集成SPI”。IntegratorService管理所有已知的集成商。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“集成商”的概念仍在积极地定义和发展中。期望这些SPI发生变化。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>积分器有两种已知的方式。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以通过调用手动注册集成商<code>BootstrapServiceRegistryBuilder#with(Integrator)</code></p>
</li>
<li>
<p>利用标准Java可以发现集成商<code>ServiceLoader</code>提供的能力<code>ClassLoaderService</code> 。
<code>Integrators</code>只需定义一个名为<code>/META-INF/services/org.hibernate.integrator.spi.Integrator</code>并使其在类路径上可用。
<code>ServiceLoader</code>详细介绍了此文件的格式，但从本质上讲，它按实现的标准名称列出了类<code>Integrator</code>每行一个。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_code_strategyselector_code"><code>StrategySelector</code></h5>
<div class="paragraph">
<p>的<code>Service</code>为此的作用<code>Service</code>是<code>org.hibernate.boot.registry.selector.spi.StrategySelector</code> 。将此视为<em>短命名</em>服务。从历史上看，配置Hibernate用户经常需要为内部Hibernate类提供完全合格的名称引用。当然，这在我们重构内部代码并将这些类移动到不同的包结构中时引起了很多问题。输入简短命名的概念，为策略/实施类使用定义明确且众所周知的<em>简称</em> 。</p>
</div>
<div class="paragraph">
<p>短名称映射<code>Service</code>甚至可以由功能非常强大的应用程序和集成器来管理。有关此方面的更多信息，请参见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BootstrapServiceRegistryBuilder#applyStrategySelector</code></p>
</li>
<li>
<p><code>BootstrapServiceRegistryBuilder#applyStrategySelectors</code></p>
</li>
<li>
<p><code>org.hibernate.boot.registry.selector.StrategyRegistrationProvider</code>通过<code>ServiceLoader</code>发现</p>
</li>
<li>
<p><code>StrategySelector#registerStrategyImplementor</code> /<code>StrategySelector#unRegisterStrategyImplementor</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="services-registry-standard">1.4.2。<code>StandardServiceRegistry</code></h4>
<div class="paragraph">
<p>的<code>org.hibernate.boot.registry.StandardServiceRegistry</code>定义主要的Hibernate<code>ServiceRegistry</code> ，建立在<code>BootstrapServiceRegistry</code>这是它的父母。此注册表通常使用<code>org.hibernate.boot.registry.StandardServiceRegistryBuilder</code>类。默认情况下，它包含大多数<code>Services</code>由Hibernate使用。有关的完整列表<code>Services</code>通常在<code>StandardServiceRegistry</code> ，请参阅的源代码<code>org.hibernate.service.StandardServiceInitiators</code> 。</p>
</div>
<div class="paragraph">
<p>在正常使用中，StandardServiceRegistry的父级是BootstrapServiceRegistry。</p>
</div>
<div class="paragraph">
<p>StandardServiceRegistry的服务可以扩展（添加到）和重写（替换）。</p>
</div>
<div class="sect4">
<h5 id="_code_connectionprovider_multitenantconnectionprovider_code"><code>ConnectionProvider/MultiTenantConnectionProvider</code></h5>
<div class="paragraph">
<p>的<code>Service</code>为Hibernate提供<code>Connections</code>如所须。有两种不同（且互斥）的角色：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.hibernate.engine.jdbc.connections.spi.ConnectionProvider</code></dt>
<dd>
<p>提供<code>Connections</code>在正常环境下</p>
</dd>
<dt class="hdlist1"><code>org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider</code></dt>
<dd>
<p>提供（特定于租户） <code>Connections</code>在多租户环境中</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_code_jdbcservices_code"><code>JdbcServices</code></h5>
<div class="paragraph">
<p><code>org.hibernate.engine.jdbc.spi.JdbcServices</code>是一个聚合器<code>Service</code> （一种<code>Service</code>聚合其他服务），从而提供围绕JDBC可访问性的统一功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_transactioncoordinatorbuilder_code"><code>TransactionCoordinatorBuilder</code></h5>
<div class="paragraph">
<p><code>org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder</code>由Hibernate用于与基础交易系统集成。它负责建筑<code>org.hibernate.resource.transaction.spi.TransactionCoordinator</code>每个Hibernate使用的实例<code>Session</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_jtaplatform_code"><code>JtaPlatform</code></h5>
<div class="paragraph">
<p>当使用基于JTA的<code>TransactionCoordinatorBuilder</code> ， <code>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</code><code>Service</code>提供对JTA的Hibernate访问<code>TransactionManager</code>和<code>UserTransaction</code> ，以及处理<code>Synchronization</code>注册。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_jndiservice_code"><code>JndiService</code></h5>
<div class="paragraph">
<p>的<code>org.hibernate.engine.jndi.spi.JndiService</code><code>Service</code>由Hibernate用于与JNDI上下文进行交互。Hibernate的默认<code>JndiService</code>假设只是一个<code>InitialContext</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_regionfactory_code"><code>RegionFactory</code></h5>
<div class="paragraph">
<p>的<code>org.hibernate.cache.spi.RegionFactory</code><code>Service</code>将与第三方缓存实现者的集成定义为第二级缓存提供者。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_sessionfactoryserviceregistryfactory_code"><code>SessionFactoryServiceRegistryFactory</code></h5>
<div class="paragraph">
<p><code>org.hibernate.service.spi.SessionFactoryServiceRegistryFactory</code>是一个<code>Service</code>作为建造第三种类型的工厂的工厂<code>ServiceRegistry</code> （SessionFactoryServiceRegistry），我们将在下面讨论。我选择<em>工厂作为服务</em>方法，因为在当前设计中，对于何时<code>SessionFactoryServiceRegistry</code>需要建立。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="services-registry-sf">1.4.3。<code>SessionFactoryServiceRegistry</code></h4>
<div class="paragraph">
<p><code>org.hibernate.service.spi.SessionFactoryServiceRegistry</code>是Hibernate的第三个标准<code>ServiceRegistry</code> 。
<code>SessionFactoryServiceRegistry</code>旨在容纳<code>Services</code>需要访问<code>SessionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>通常，其父注册表是<code>StandardServiceRegistry</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>集成商（如4.x所示）在<code>SessionFactoryServiceRegistry</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>目前<code>SessionFactoryServiceRegistry</code>仅拥有四个服务。</p>
</div>
<div class="sect4">
<h5 id="_code_eventlistenerregistry_code"><code>EventListenerRegistry</code></h5>
<div class="paragraph">
<p><code>org.hibernate.event.service.spi.EventListenerRegistry</code>是主要的<code>Service</code>在<code>SessionFactoryServiceRegistry</code> 。是的<code>Service</code>管理所有Hibernate的事件监听器。一个主要的用例<code>Integrators</code>是更改侦听器注册表。</p>
</div>
<div class="paragraph">
<p>如果要进行自定义侦听器注册，那么了解<code>org.hibernate.event.service.spi.DuplicationStrategy</code>及其对注册的影响。基本思想是告诉Hibernate：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>是什么使收听者重复</p>
</li>
<li>
<p>如何处理重复注册（错误，首胜，最后胜利）</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_code_statisticsimplementor_code"><code>StatisticsImplementor</code></h5>
<div class="paragraph">
<p><code>org.hibernate.stat.spi.StatisticsImplementor</code>是Statistics API的SPI部分；收集器部分（如果需要）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_nativequeryinterpreter_code"><code>NativeQueryInterpreter</code></h5>
<div class="paragraph">
<p><code>org.hibernate.engine.query.spi.NativeQueryInterpreter</code>是个<code>Service</code> Hibernate用于解释本机查询。作为一个存在<code>Service</code>主要是为了使诸如OGM的集成可以覆盖它。</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_cacheimplementor_code"><code>CacheImplementor</code></h5>
<div class="paragraph">
<p><code>org.hibernate.engine.spi.CacheImplementor</code>提供一种自定义Hibernate与第二级缓存实现交互的方式的方法。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="services-custom">1.5。海关服务</h3>
<div class="paragraph">
<p>到目前为止，我们专注于Hibernate提供的服务。但是应用程序和集成也可以提供自己的服务，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供新的标准实施<code>Service</code> （覆盖）</p>
</li>
<li>
<p>提供一个全新的<code>Service</code>角色（扩展）</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="services-overriding">1.5.1。自订<code>Service</code>实现（覆盖）</h4>
<div class="paragraph">
<p>我们讨论了<code>Service</code>上面的实现。让我们看一个实际的例子。为了说明起见，可以说我们已经开发了一个新的<code>ConnectionProvider</code>与精彩的最新，最新的连接池库集成。让我们看看实现这一目标所需的步骤。</p>
</div>
<div class="paragraph">
<p>第一步是通过实施<code>ConnectionProvider</code>合同。</p>
</div>
<div id="services-overriding-custom-ConnectionProvider-example" class="exampleblock">
<div class="title">范例1。自订<code>ConnectionProvider</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import java.lang.Override;

public class LatestAndGreatestConnectionProviderImpl
    implements ConnectionProvider, Startable, Stoppable, Configurable {

    private LatestAndGreatestPoolBuilder lagPoolBuilder;

    private LatestAndGreatestPool lagPool;

    private boolean available = false;

    @Override
    public void configure(Map configurationValues) {
        // extract our config from the settings map
        lagPoolBuilder = buildBuilder( configurationValues );
    }

    @Override
    public void start() {
        // start the underlying pool
        lagPool = lagPoolBuilder.buildPool();

        available = true;
    }

    @Override
    public void stop() {
        available = false;

        // stop the underlying pool
        lagPool.shutdown();
    }

    @Override
    public Connection getConnection() throws SQLException {
        if ( !available ) {
            throwException(
                "LatestAndGreatest ConnectionProvider not available for use" )
        }

        return lagPool.borrowConnection();
    }

    @Override
    public void closeConnection(Connection conn) throws SQLException {
        if ( !available ) {
            warn(
                "LatestAndGreatest ConnectionProvider not available for use" )
        }

        if ( conn == null ) {
            return;
        }

        lagPool.releaseConnection( conn );
    }

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这一点上，我们决定如何集成此新<code>ConnectionProvider</code>进入Hibernate状态。您可能会猜到，有多种方法。</p>
</div>
<div class="paragraph">
<p>作为第一种选择，我们可能只需要代码自举<code>StandardServiceRegistry</code>做整合。</p>
</div>
<div id="services-overriding-override-via-StandardServiceRegistryBuilder-example" class="exampleblock">
<div class="title">示例2通过覆盖服务实现<code>StandardServiceRegistryBuilder</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistryBuilder builder = ...;
...
builder.addService(
    ConnectionProvider.class,
    new LatestAndGreatestConnectionProviderImpl()
);
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二种选择，如果我们<code>LatestAndGreatestConnectionProviderImpl</code>应该始终使用，将提供<code>org.hibernate.service.spi.ServiceContributor</code>实现以及代表用户处理集成。</p>
</div>
<div id="services-LatestAndGreatestConnectionProviderImplContributor-example" class="exampleblock">
<div class="title">范例3。<code>LatestAndGreatestConnectionProviderImplContributor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class LatestAndGreatestConnectionProviderImplContributor1
        implements ServiceContributor {

    @Override
    public void contribute(StandardServiceRegistryBuilder serviceRegistryBuilder) {
        serviceRegistryBuilder.addService(
            ConnectionProvider.class,
            new LatestAndGreatestConnectionProviderImpl()
        );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们仍然需要告诉Hibernate为我们执行此集成。为此，我们利用Java的<code>ServiceLoader</code> 。当建造<code>StandardServiceRegistry</code> ，Hibernate将寻找JDK <code>Service</code>类型的提供者<code>org.hibernate.service.spi.ServiceContributor</code>并自动整合它们。我们在上面讨论了这种行为。在这里，我们将定义一个名为<code>META-INF/services/org.hibernate.service.spi.ServiceContributor</code> 。该文件只有一行命名我们的impl。</p>
</div>
<div id="services-META-INF-example" class="exampleblock">
<div class="title">示例4<code>META-INF/services/org.hibernate.service.spi.ServiceContributor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fully.qualified.package.LatestAndGreatestConnectionProviderImplContributor1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第三种选择，如果我们只是想让我们<code>LatestAndGreatestConnectionProviderImpl</code>作为配置选择，我们将再次使用<code>ServiceContributor</code>但方式略有不同。</p>
</div>
<div id="services-LatestAndGreatestConnectionProviderImplContributor-variation-example" class="exampleblock">
<div class="title">示例5 <code>LatestAndGreatestConnectionProviderImplContributor</code>变异</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class LatestAndGreatestConnectionProviderImplContributor
    implements ServiceContributor {

    @Override
    public void contribute(
            standardserviceregistrybuilder serviceregistrybuilder) {

        // here we will register a short-name for our service strategy
        strategyselector selector = serviceregistrybuilder
            .getbootstrapserviceregistry().
            .getservice( strategyselector.class );

        selector.registerstrategyimplementor(
            connectionprovider.class,
            "lag"
            latestandgreatestconnectionproviderimpl.class
        );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这一切都允许应用程序选择我们<code>LatestAndGreatestConnectionProviderImpl</code>简称。</p>
</div>
<div id="services-custom-service-short-name-example" class="exampleblock">
<div class="title">范例6。定制服务简称</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">StandardServiceRegistryBuilder builder = ...;
...
builder.applySetting( "hibernate.connection.provider_class", "lag" );
...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="services-extending">1.5.2。自订<code>Service</code>角色（扩展）</h4>
<div class="paragraph">
<p>我们也可以<code>ServiceRegistry</code>托管自定义服务（全新<code>Service</code>角色）。举例来说，假设我们的应用程序将Hibernate事件发布到JMS主题，并且我们想利用Hibernate <code>ServiceRegistry</code>主持一个<code>Service</code>代表我们发布的事件。因此，我们将扩大<code>ServiceRegistry</code>主办这个全新的<code>Service</code>为我们扮演角色并管理其生命周期。</p>
</div>
<div id="services-EventPublishingService-service-role-example" class="exampleblock">
<div class="title">范例7。的<code>EventPublishingService</code>服务角色</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface EventPublishingService extends Service {

    public void publish(Event theEvent);
}</code></pre>
</div>
</div>
</div>
</div>
<div id="services-EventPublishingService-implementation-example" class="exampleblock">
<div class="title">范例8。的<code>EventPublishingService</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class EventPublishingServiceImpl
    implements EventPublishingService, Configurable, Startable, Stoppable,
               ServiceRegistryAwareService {

    private ServiceRegistryImplementor serviceRegistry;

    private String jmsConnectionFactoryName;

    private String destinationName;

    private Connection jmsConnection;

    private Session jmsSession;

    private MessageProducer publisher;

    @Override
    public void injectServices(ServiceRegistryImplementor serviceRegistry) {
        this.serviceRegistry = serviceRegistry;
    }

    public void configure(Map configurationValues) {
        this.jmsConnectionFactoryName = configurationValues
            .get( JMS_CONNECTION_FACTORY_NAME_SETTING );
        this.destinationName = configurationValues
            .get( JMS_DESTINATION_NAME_SETTING );
    }

    @Override
    public void start() {
        final JndiService jndiService = serviceRegistry
            .getService( JndiService.class );
        final ConnectionFactory jmsConnectionFactory = jndiService
            .locate( jmsConnectionFactoryName );

        this.jmsConnection = jmsConnectionFactory.createConnection();
        this.jmsSession = jmsConnection.createSession(
            true,
            Session.AUTO_ACKNOWLEDGE
        );

        final Destination destination = jndiService.locate( destinationName );

        this.publisher = jmsSession.createProducer( destination );
    }

    @Override
    public void publish(Event theEvent) {
        publisher.send( theEvent );
    }

    @Override
    public void stop() {
        publisher.close();
        jmsSession.close();
        jmsConnection.close();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div id="services-alternate-EventPublishingService-implementation-example" class="exampleblock">
<div class="title">范例9。替代<code>EventPublishingService</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class DisabledEventPublishingServiceImpl implements EventPublishingService {

    public static DisabledEventPublishingServiceImpl INSTANCE =
        new DisabledEventPublishingServiceImpl();

    private DisabledEventPublishingServiceImpl() {
    }

    @Override
    public void publish(Event theEvent) {
        // nothing to do...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为我们有其他实现，所以最好开发一个启动器，并在运行时在它们之间进行选择。</p>
</div>
<div id="services-EventPublishingServiceInitiator-example" class="exampleblock">
<div class="title">示例10的<code>EventPublishingServiceInitiator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class EventPublishingServiceInitiator
    implements StandardServiceInitiator&lt;EventPublishingService&gt; {

    public static EventPublishingServiceInitiator INSTANCE =
            new EventPublishingServiceInitiator();

    public static final String ENABLE_PUBLISHING_SETTING =
            "com.acme.EventPublishingService.enabled";

    @Override
    public Class&lt;R&gt; getServiceInitiated() {
        return EventPublishingService.class;
    }

    @Override
    public R initiateService(
            Map configurationValues,
            ServiceRegistryImplementor registry) {

        final boolean enabled = extractBoolean(
                configurationValues,
                ENABLE_PUBLISHING_SETTING
        );
        if ( enabled ) {
            return new EventPublishingServiceImpl();
        }
        else {
            return DisabledEventPublishingServiceImpl.INSTANCE;
        }
    }

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以让应用程序注册<code>EventPublishingServiceInitiator</code>与<code>StandardServiceRegistryBuilder</code> ，但是写一个更好<code>ServiceContributor</code>为应用程序处理。</p>
</div>
<div id="services-EventPublishingServiceContributor-example" class="exampleblock">
<div class="title">示例11的<code>EventPublishingServiceContributor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class EventPublishingServiceContributor
    implements ServiceContributor {

    @Override
    public void contribute(StandardServiceRegistryBuilder builder) {
        builder.addinitiator( eventpublishingserviceinitiator.instance );

        // if we wanted to allow other strategies (e.g. a jms
        // queue publisher) we might also register short names
        // here with the strategyselector.  the initiator would
        // then need to accept the strategy as a config setting
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-06-28 11:26:24 BST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>