<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools专家用户指南</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"><meta name="generator" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" content="DocBook XSL-NS Stylesheets V1.74.0"><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e7">1。规则引擎</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10">1.1。什么是规则引擎？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13">1.1.1。介绍和背景</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e103">1.2。为什么要使用规则引擎？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e124">1.2.1。规则引擎的优势</a></span></dt><dt><span class="section"><a href="#d0e167">1.2.2。什么时候应该使用规则引擎？</a></span></dt><dt><span class="section"><a href="#d0e204">1.2.3。何时不使用规则引擎</a></span></dt><dt><span class="section"><a href="#d0e216">1.2.4。脚本或流程引擎</a></span></dt><dt><span class="section"><a href="#d0e229">1.2.5。强而弱的耦合</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e237">2。快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e240">2.1。基础</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e243">2.1.1。无状态知识会议</a></span></dt><dt><span class="section"><a href="#d0e390">2.1.2。有状态知识会议</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">2.2。一点理论</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e565">2.2.1。方法与规则</a></span></dt><dt><span class="section"><a href="#d0e597">2.2.2。交叉产品</a></span></dt><dt><span class="section"><a href="#d0e622">2.2.3。激活，议程和冲突集。</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e788">2.3。有关构建和部署的更多信息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e791">2.3.1。使用变更集的配置知识库</a></span></dt><dt><span class="section"><a href="#d0e819">2.3.2。知识代理</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e840">3。用户指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e843">3.1。建造</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e852">3.1.1。使用代码构建</a></span></dt><dt><span class="section"><a href="#d0e933">3.1.2。使用Configuration和ChangeSet XML构建</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e989">3.2。部署中</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e992">3.2.1。知识包和知识定义</a></span></dt><dt><span class="section"><a href="#d0e1005">3.2.2。知识库</a></span></dt><dt><span class="section"><a href="#d0e1055">3.2.3。进程内构建和部署</a></span></dt><dt><span class="section"><a href="#d0e1070">3.2.4。在单独的流程中构建和部署</a></span></dt><dt><span class="section"><a href="#d0e1109">3.2.5。状态知识会话和知识库修改</a></span></dt><dt><span class="section"><a href="#d0e1123">3.2.6。知识代理商</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1248">3.3。跑步</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1252">3.3.1。知识库</a></span></dt><dt><span class="section"><a href="#d0e1271">3.3.2。有状态知识会话</a></span></dt><dt><span class="section"><a href="#d0e1293">3.3.3。知识运行时</a></span></dt><dt><span class="section"><a href="#d0e1560">3.3.4。议程</a></span></dt><dt><span class="section"><a href="#d0e1666">3.3.5。事件模型</a></span></dt><dt><span class="section"><a href="#d0e1781">3.3.6。KnowledgeRuntimeLogger</a></span></dt><dt><span class="section"><a href="#d0e1797">3.3.7。无状态知识会话</a></span></dt><dt><span class="section"><a href="#d0e1992">3.3.8。管道</a></span></dt><dt><span class="section"><a href="#d0e2250">3.3.9。命令和CommandExecutor</a></span></dt><dt><span class="section"><a href="#d0e2593">3.3.10。编组</a></span></dt><dt><span class="section"><a href="#d0e2668">3.3.11。持久性和交易</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2712">4。规则语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2715">4.1。总览</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2723">4.1.1。规则文件</a></span></dt><dt><span class="section"><a href="#d0e2756">4.1.2。什么是规则</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2792">4.2。关键词</a></span></dt><dt><span class="section"><a href="#d0e3005">4.3。评论</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3010">4.3.1。单行注释</a></span></dt><dt><span class="section"><a href="#d0e3023">4.3.2。多行评论</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3036">4.4。错误讯息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3045">4.4.1。讯息格式</a></span></dt><dt><span class="section"><a href="#d0e3076">4.4.2。错误信息说明</a></span></dt><dt><span class="section"><a href="#d0e3231">4.4.3。其他讯息</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3236">4.5。包</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3259">4.5.1。进口</a></span></dt><dt><span class="section"><a href="#d0e3273">4.5.2。全球</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3316">4.6。功能</a></span></dt><dt><span class="section"><a href="#d0e3350">4.7。类型声明</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3378">4.7.1。声明新类型</a></span></dt><dt><span class="section"><a href="#d0e3500">4.7.2。声明元数据</a></span></dt><dt><span class="section"><a href="#d0e3571">4.7.3。声明现有类型的元数据</a></span></dt><dt><span class="section"><a href="#d0e3614">4.7.4。从应用程序代码访问声明的类型</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3663">4.8。规则</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3705">4.8.1。规则属性</a></span></dt><dt><span class="section"><a href="#RuleLanguage-ConditionalElements">4.8.2。左侧（当）条件元素</a></span></dt><dt><span class="section"><a href="#d0e5216">4.8.3。右侧（然后）</a></span></dt><dt><span class="section"><a href="#d0e5455">4.8.4。关于自动装箱和原始类型的注释</a></span></dt></dl></dd><dt><span class="section"><a href="#sec.query">4.9。询问</a></span></dt><dt><span class="section"><a href="#d0e5495">4.10。领域特定语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5506">4.10.1。何时使用DSL</a></span></dt><dt><span class="section"><a href="#d0e5515">4.10.2。编辑和管理DSL</a></span></dt><dt><span class="section"><a href="#d0e5569">4.10.3。在规则中使用DSL</a></span></dt><dt><span class="section"><a href="#d0e5595">4.10.4。给事实增加约束</a></span></dt><dt><span class="section"><a href="#d0e5628">4.10.5。怎么运行的</a></span></dt><dt><span class="section"><a href="#d0e5637">4.10.6。从头开始创建DSL</a></span></dt><dt><span class="section"><a href="#d0e5665">4.10.7。范围和关键字</a></span></dt><dt><span class="section"><a href="#d0e5670">4.10.8。BRMS和IDE中的DSL</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5679">4.11。XML规则语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5688">4.11.1。何时使用XML</a></span></dt><dt><span class="section"><a href="#d0e5699">4.11.2。XML格式</a></span></dt><dt><span class="section"><a href="#d0e5745">4.11.3。旧版Drools 2.x XML规则格式</a></span></dt><dt><span class="section"><a href="#d0e5750">4.11.4。在格式之间自动转换（XML和DRL）</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e5762">5，创作</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5765">5.1。电子表格中的决策表</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5777">5.1.1。何时使用决策表</a></span></dt><dt><span class="section"><a href="#d0e5789">5.1.2。总览</a></span></dt><dt><span class="section"><a href="#d0e5827">5.1.3。决策表如何工作</a></span></dt><dt><span class="section"><a href="#d0e5900">5.1.4。关键字和语法</a></span></dt><dt><span class="section"><a href="#d0e6103">5.1.5。创建和集成基于电子表格的决策表</a></span></dt><dt><span class="section"><a href="#d0e6116">5.1.6。在决策表中管理业务规则。</a></span></dt><dt><span class="section"><a href="#d0e6161">5.1.7。规则模板</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6212">5.2。范本</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6225">5.2.1。规则模板文件</a></span></dt><dt><span class="section"><a href="#d0e6322">5.2.2。扩展模板</a></span></dt><dt><span class="section"><a href="#d0e6376">5.2.3。例</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e6447">6。Java规则引擎API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6450">6.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e6465">6.2。如何使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6470">6.2.1。建立和注册RuleExecutionSets</a></span></dt><dt><span class="section"><a href="#d0e6503">6.2.2。使用有状态和无状态RuleSession</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6538">6.3。参考文献</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e6584">7。规则IDE（Eclipse）</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6602">7.1。功能概述</a></span></dt><dt><span class="section"><a href="#d0e6658">7.2。创建规则项目</a></span></dt><dt><span class="section"><a href="#d0e6681">7.3。创建新规则和向导</a></span></dt><dt><span class="section"><a href="#d0e6702">7.4。文字规则编辑器</a></span></dt><dt><span class="section"><a href="#d0e6725">7.5。指导编辑器（规则GUI）</a></span></dt><dt><span class="section"><a href="#d0e6742">7.6。流口水的意见</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6759">7.6.1。工作记忆视图</a></span></dt><dt><span class="section"><a href="#d0e6773">7.6.2。议程视图</a></span></dt><dt><span class="section"><a href="#d0e6787">7.6.3。全局数据视图</a></span></dt><dt><span class="section"><a href="#d0e6801">7.6.4。审核视图</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6885">7.7。领域特定语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6892">7.7.1。编辑语言</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6915">7.8。Rete视图</a></span></dt><dt><span class="section"><a href="#d0e6931">7.9。大DRL文件</a></span></dt><dt><span class="section"><a href="#d0e6947">7.10。调试规则</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6958">7.10.1。创建断点</a></span></dt><dt><span class="section"><a href="#d0e6972">7.10.2。调试规则</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e7010">8。例子</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7013">8.1。得到例子</a></span></dt><dt><span class="section"><a href="#d0e7018">8.2。你好，世界</a></span></dt><dt><span class="section"><a href="#d0e7283">8.3。状态示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7288">8.3.1。了解状态示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7566">8.4。斐波那契示例</a></span></dt><dt><span class="section"><a href="#d0e7769">8.5。银行教程</a></span></dt><dt><span class="section"><a href="#d0e8093">8.6。定价规则决策表示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8114">8.6.1。执行示例</a></span></dt><dt><span class="section"><a href="#d0e8156">8.6.2。决策表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8221">8.7。宠物店的例子</a></span></dt><dt><span class="section"><a href="#d0e8780">8.8。诚实的政客例子</a></span></dt><dt><span class="section"><a href="#d0e8905">8.9。数独示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8926">8.9.1。数独概述</a></span></dt><dt><span class="section"><a href="#d0e8940">8.9.2。运行示例</a></span></dt><dt><span class="section"><a href="#d0e9026">8.9.3。Java源代码和规则概述</a></span></dt><dt><span class="section"><a href="#d0e9144">8.9.4。数独验证器规则（validatorSudoku.drl）</a></span></dt><dt><span class="section"><a href="#d0e9174">8.9.5。数独求解规则（solverSudoku.drl）</a></span></dt><dt><span class="section"><a href="#d0e9282">8.9.6。对未来发展的建议</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9337">8.10。猜数字</a></span></dt><dt><span class="section"><a href="#d0e9627">8.11。礼貌小姐和标杆管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9646">8.11.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e9732">8.11.2。深入讨论</a></span></dt><dt><span class="section"><a href="#d0e9942">8.11.3。输出汇总</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9997">8.12。康威的人生游戏</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7"></a>第1章。规则引擎</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e10">1.1。什么是规则引擎？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13">1.1.1。介绍和背景</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e103">1.2。为什么要使用规则引擎？</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e124">1.2.1。规则引擎的优势</a></span></dt><dt><span class="section"><a href="#d0e167">1.2.2。什么时候应该使用规则引擎？</a></span></dt><dt><span class="section"><a href="#d0e204">1.2.3。何时不使用规则引擎</a></span></dt><dt><span class="section"><a href="#d0e216">1.2.4。脚本或流程引擎</a></span></dt><dt><span class="section"><a href="#d0e229">1.2.5。强而弱的耦合</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10"></a> 1.1。什么是规则引擎？</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13"></a> 1.1.1。介绍和背景</h3></div></div></div><p>人工智能（AI）是一个非常广泛的研究领域，专注于“使计算机像人一样思考”，并包括诸如神经网络，遗传算法，决策树，框架系统和专家系统之类的学科。知识表示是AI领域中与如何表示和操纵知识有关的领域。专家系统使用知识表示法来促进将知识编码为可用于推理的知识库，即，我们可以使用该知识库处理数据以推断结论。专家系统也被称为基于知识的系统和基于知识的专家系统，被认为是“应用的人工智能”。使用专家系统进行开发的过程是知识工程。EMYCIN是专家系统的第一批“外壳”，它是由MYCIN医学诊断专家系统创建的。早期的专家系统对其逻辑进行了硬编码，而“外壳”将逻辑与系统分开，从而为用户输入提供了易于使用的环境。Drools是一个规则引擎，它使用基于规则的方法来实施专家系统，并且更正确地归类为生产规则系统。</p><p>术语“生产规则”起源于形式语法，在形式语法中它被描述为“精确描述形式语言的抽象结构，即，一组数学上描绘（通常是无限）有限长度字符串的规则（通常是有限）字母”（ <a class="ulink" href="http://en.wikipedia.org/wiki/Formal_grammar"><em class="citetitle">维基百科</em></a> ）。</p><p>业务规则管理系统通过为规则创建，管理，部署，协作，分析和最终用户工具提供以业务用户为中心的系统，在通用规则引擎之上构建附加价值。快速增长且流行的方法“业务规则方法”进一步增加了此价值，这有助于形式化规则引擎在企业中的作用。</p><p>术语“规则引擎”非常模棱两可，因为它可以是使用任何形式的规则的任何系统，这些规则可以应用于数据以产生结果。这包括简单的系统，例如表单验证和动态表达式引擎。马尔科姆·奇斯霍尔姆（Malcolm Chisholm）所著的“如何构建业务规则引擎（2004）”一书就说明了这种歧义。这本书实际上是关于如何构建和更改数据库架构以保存验证规则的。然后，这本书展示了如何从那些验证规则生成VB代码以验证数据输入。尽管对于某些人来说这是一个非常有效和有用的话题，但令当时的作者感到惊讶，他当时并未意识到Rule Engines差异的微妙之处，他希望找到一些隐藏的秘密来帮助改进Drools引擎。JBoss jBPM在其Decision节点中使用表达式和委托，这些表达式和委托控制工作流中的过渡。在每个节点上，它评估的是一个规则集，该规则集指示要进行的过渡，因此这也是一个规则引擎。生产规则系统既是规则引擎，又是专家系统，而前面提到的验证和表达评估规则引擎不是专家系统。</p><p>生产规则系统是图灵完整的，重点是知识表示，以简洁，明确和声明性的方式表达命题和一阶逻辑。生产规则系统的大脑是一个推理引擎，能够根据大量规则和事实进行扩展。推理引擎将事实和数据与生产规则（也称为生产或规则）进行匹配，以推断出导致采取行动的结论。生产规则是使用一阶逻辑对知识表示进行推理的两部分结构。</p><pre class="programlisting">when
    &lt;conditions&gt;
then
    &lt;actions&gt;;</pre><p>将新事实或现有事实与生产规则进行匹配的过程称为<a id="d0e36" class="indexterm"></a>模式匹配，由<a id="d0e40" class="indexterm"></a>推理机。推理引擎用于模式匹配的算法有很多，包括：</p><div class="itemizedlist"><ul><li><p>线性的</p></li><li><p>te</p></li><li><p>对待</p></li><li><p>飞跃</p></li></ul></div><p>Drools实现并扩展了<a id="d0e59" class="indexterm"></a> Rete算法； <a id="d0e63" class="indexterm"></a>曾经提供过飞跃，但由于不再维护而已退役。流口水<a id="d0e67" class="indexterm"></a> Rete实现称为ReteOO，表示Drools对面向对象系统具有Rete算法的增强和优化实现。其他基于Rete的引擎（如RetePlus和Rete III）也具有针对其对Rete的专有增强功能的营销条款。 Robert B. Doorenbos撰写的“大型学习系统的产品匹配（Rete / UL）”（1995年）中介绍了最常见的增强功能。</p><p>规则存储在<a id="d0e73" class="indexterm"></a>生产记忆和推理引擎匹配的事实都保留在<a id="d0e77" class="indexterm"></a>工作记忆。事实被断言到工作存储器中，然后可以在其中进行修改或收回。具有大量规则和事实的系统可能会导致许多规则对于相同的事实断言是正确的。据说这些规则是冲突的。议程使用“冲突解决”策略管理这些冲突规则的执行顺序。</p><div class="figure"><a id="d0e81"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/rule-engine-inkscape.png" align="middle" width="540" height="300" alt="规则引擎的高级视图"></div></div><p class="title"><b>图1.1。规则引擎的高级视图</b></p></div><br class="figure-break"><p>规则系统有两种执行方法：前向链接和后向链接；实现这两种功能的系统称为混合规则系统。了解这两种操作模式是理解生产规则系统为何不同以及如何从中获得最大收益的关键。正向链是“数据驱动的”，因此是反动的，事实被断言存入工作记忆中，这导致一个或多个规则同时为真，并计划由议程执行。简而言之，我们从一个事实开始，它传播并最终得出结论。Drools是一个前向链接引擎。</p><div class="figure"><a id="d0e89"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Forward_Chaining.png" align="middle" alt="正向链接"></div></div><p class="title"><b>图1.2。正向链接</b></p></div><br class="figure-break"><p>向后链接是“目标驱动”的，这意味着我们从引擎试图满足的结论开始。如果不能，则搜索它可以满足的结论。这些称为子目标，将有助于满足当前目标的某些未知部分。它会继续执行此过程，直到证明初始结论或没有更多子目标为止。Prolog是向后链接引擎的一个示例； Drools计划在将来的版本中为“向后链接”提供支持。</p><div class="figure"><a id="d0e97"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Backward_Chaining.png" align="middle" alt="向后链接"></div></div><p class="title"><b>图1.3。向后链接</b></p></div><br class="figure-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e103"></a> 1.2。为什么要使用规则引擎？</h2></div></div></div><p>一些常见问题：</p><div class="orderedlist"><ol type="1"><li><p>什么时候应该使用规则引擎？</p></li><li><p>规则引擎比手工编码的“如果...那么”方法有什么优势？</p></li><li><p>为什么要使用规则引擎而不是脚本框架，例如<a id="d0e118" class="indexterm"></a> BeanShell？</p></li></ol></div><p>我们将在下面尝试解决这些问题。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e124"></a> 1.2.1。规则引擎的优势</h3></div></div></div><div class="itemizedlist"><ul><li><p>声明式编程</p><p>规则引擎允许您说“该怎么做”，而不是“怎么做”。</p><p>这一点的主要优点是，使用规则可以使表达困难问题的解决方案变得容易，因此可以验证这些解决方案。规则比代码容易阅读。</p><p>规则系统能够解决非常非常棘手的问题，并解释了解决方案的产生方式以及沿途做出每个“决定”的原因（对于其他AI系统，例如神经网络或人脑，这并不那么容易-我不知道为什么我要刮擦汽车的侧面。</p></li><li><p>逻辑与数据分离</p><p>您的数据在域对象中，逻辑在规则中。这从根本上打破了数据和逻辑的OO耦合，根据您的观点，这可能是优点还是缺点。结果是，随着将来的变化，逻辑可以更容易维护，因为逻辑都是按规则排列的。如果逻辑是跨域或多域逻辑，则尤其如此。可以将逻辑全部组织在一个或多个非常不同的规则文件中，而不是将逻辑分布在许多域对象或控制器中。</p></li><li><p>速度和可扩展性</p><p>Rete算法，Leaps算法及其后代（如Drools的ReteOO）提供了非常有效的方式来将规则模式与您的域对象数据进行匹配。当您的数据集变化很小时，这些规则特别有效，因为规则引擎可以记住过去的匹配项。这些算法已经过实战证明。</p></li><li><p>知识集中</p><p>通过使用规则，您可以创建可执行的知识库（知识库）。这意味着，例如，对于业务策略，这是一个单一的真理。理想情况下，规则具有很高的可读性，因此它们也可以用作文档。</p></li><li><p>工具整合</p><p>诸如Eclipse之类的工具（以及将来基于Web的用户界面）提供了编辑和管理规则以及获得即时反馈，验证和内容帮助的方法。还提供审计和调试工具。</p></li><li><p>说明设施</p><p>规则系统能够记录规则引擎做出的决定以及做出决定的原因，从而有效地提供了“解释工具”。</p></li><li><p>可理解的规则</p><p>通过创建对象模型以及（可选）为问题域建模的领域特定语言，您可以设置自己编写与自然语言非常接近的规则。他们以自己的语言表达自己的逻辑，这可能是非技术领域的专家可以理解的，并且所有程序都经过检查，而技术知识则隐藏在常规代码中。</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e167"></a> 1.2.2。什么时候应该使用规则引擎？</h3></div></div></div><p>对此的最短答案是“当没有令人满意的传统编程方法来解决该问题时”。给定简短答案，需要更多说明。没有“传统”方法的原因可能是以下之一：</p><div class="itemizedlist"><ul><li><p>对于传统代码来说，这个问题实在太小了。</p><p>该问题可能并不复杂，但是您看不到为其构建解决方案的非脆弱方法。</p></li><li><p>这个问题超出了任何明显的算法解决方案。</p><p>要解决的是一个复杂的问题，没有明显的传统解决方案，或者基本上没有完全理解该问题。</p></li><li><p>逻辑经常变化</p><p>逻辑本身甚至可能很简单，但是规则却经常更改。在许多组织中，软件发行版之间相差无几，可插拔规则可以帮助以合理安全的方式提供所需和期望的“敏捷性”。</p></li><li><p>领域专家（或业务分析师）很容易获得，但不是技术性的。</p><p>领域专家通常具有有关业务规则和流程的丰富知识。它们通常是非技术性的，但可能非常合逻辑。规则可以使他们用自己的术语表达逻辑。当然，他们仍然必须批判性思考并具有逻辑思维能力。许多非技术职位的人没有经过形式逻辑方面的培训，因此要当心并与他们合作，例如，通过将业务知识整理成规则，您经常会暴露出当前对业务规则和流程的理解上的漏洞。</p></li></ul></div><p>如果规则对您的项目团队来说是一项新技术，则必须考虑执行过程中的开销。这不是一项琐碎的技术，但是本文档试图使其更易于理解。</p><p>通常，在现代OO应用程序中，您将使用规则引擎来包含业务逻辑的关键部分， <span class="emphasis"><em>尤其是真正混乱的部分</em></span> 。这是将所有逻辑封装在对象内部的OO概念的颠倒。这并不是说您放弃了OO实践，相反，在任何实际应用程序中，业务逻辑只是该应用程序的一部分。如果您发现很多条件语句（例如“ if”和“ switch”），那么代码中就会出现过多的策略模式和其他混乱的逻辑，这是不合适的：这将是规则的地方。如果存在某种这样的逻辑，而您又回来修复它，要么是因为您弄错了，要么是逻辑或您的理解发生了变化：请考虑使用规则。如果您面临没有算法或模式的难题，请考虑使用规则。</p><p>规则可以嵌入您的应用程序中，也可以作为服务使用。通常，规则引擎最适合作为“状态”组件，它是应用程序的组成部分。但是，已经成功地创建了无状态的可重用规则服务。</p><p>对于您的组织而言，决定用于更新生产系统中的规则的过程非常重要。选项很多，但是不同的组织有不同的要求。通常，规则维护不受应用程序供应商或项目开发人员的控制。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e204"></a> 1.2.3。何时不使用规则引擎</h3></div></div></div><p>定期引用Drools邮件列表：</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>在我看来，使用规则引擎很激动，人们忘记了规则引擎只是复杂的应用程序或解决方案中的一个。规则引擎并非真正旨在处理工作流或流程执行，也不是旨在设计规则的工作流引擎或流程管理工具。使用正确的工具完成工作。当然，可以在钳口中使用一把钳子作为锤击工具，但这不是其设计目的。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top"><span class="attribution">戴夫·哈姆</span> （ <span class="attribution">Dave Hamu）</span></td></tr></tbody></table></div><p>由于规则引擎是动态的（在某种意义上说，动态的规则可以作为数据进行存储，管理和更新），因此它们通常被视为解决软件部署问题的解决方案。（似乎大多数IT部门都是为了防止软件推出而设立的。）如果这是您希望使用规则引擎的原因，请注意，当您能够编写声明性规则时，规则引擎最有效。作为替代方案，您可以考虑数据驱动的设计（查找表）或脚本处理引擎，其中脚本在数据库中进行管理，并且可以即时更新。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e216"></a> 1.2.4。脚本或流程引擎</h3></div></div></div><p>希望前面的部分已经解释了何时需要使用规则引擎。</p><p>替代方案是基于脚本的引擎，该引擎提供了“实时更改”的驱动力，并且有许多此类解决方案。</p><p>另外，诸如jBPM之类的Process Engines（也具有工作流功能）允许您以图形（或编程）方式描述流程中的步骤。这些步骤也可能涉及决策点，而决策点本身就是一条简单的规则。流程引擎和规则通常可以很好地协同工作，因此它们不是相互排斥的。</p><p>规则引擎要注意的一个关键点是，某些规则引擎实际上是脚本引擎。脚本引擎的缺点是您将应用程序与脚本紧密耦合。如果它们是规则，则您实际上是在直接调用规则，这可能会导致将来的维护更加困难，因为随着时间的流逝，它们的复杂性会不断增加。脚本引擎的好处在于，它们起初更容易实现，可以快速产生结果，并且对于命令式程序员在概念上更简单。</p><p>过去，许多人还成功地实现了数据驱动的系统（其中有存储用于更改应用程序行为的元数据的控制表）-当控制仍然非常有限时，这些表可以很好地工作。但是，如果扩展太多，它们可能很快失去控制（这样，只有原始创建者才能更改应用程序的行为），或者由于应用程序过于僵化而导致应用程序停滞。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e229"></a> 1.2.5。强而弱的耦合</h3></div></div></div><p>毫无疑问，您在系统设计中听说过“紧密耦合”和“松散耦合”之类的术语。通常，人们断言在设计上“松散”或“弱化”耦合是可取的，因为它提供了更多的灵活性。同样，您可以具有“强耦合”和“弱耦合”规则。从这个意义上说，强耦合意味着一个规则“触发”将明显导致另一个规则被触发，依此类推；换句话说，有一个清晰（可能很明显）的逻辑链。如果您的规则都是紧密耦合的，则很有可能会变得僵化，更重要的是，规则引擎是一种过大的杀伤力。可以对硬链进行硬编码，也可以使用决策树来实现。这并不是说强耦合本质上是不好的，但是在考虑规则引擎和捕获规则的方式时要牢记这一点。 “松散”耦合的规则应导致系统允许更改，删除和添加规则，而无需更改其他不相关的规则。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e237"></a>第2章。快速开始</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e240">2.1。基础</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e243">2.1.1。无状态知识会议</a></span></dt><dt><span class="section"><a href="#d0e390">2.1.2。有状态知识会议</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">2.2。一点理论</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e565">2.2.1。方法与规则</a></span></dt><dt><span class="section"><a href="#d0e597">2.2.2。交叉产品</a></span></dt><dt><span class="section"><a href="#d0e622">2.2.3。激活，议程和冲突集。</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e788">2.3。有关构建和部署的更多信息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e791">2.3.1。使用变更集的配置知识库</a></span></dt><dt><span class="section"><a href="#d0e819">2.3.2。知识代理</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e240"></a> 2.1。基础</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e243"></a> 2.1.1。无状态知识会议</h3></div></div></div><p>因此，我们从何处开始，规则引擎（例如Drools）中有如此多的用例和如此多的功能，因此变得令人迷惑。不用担心我的勇敢冒险家，它的复杂性是分层的，您可以使用简单的用例轻松解决。</p><p>不使用推理的无状态会话形成最简单的用例。可以像调用函数一样将无状态会话传递给它一些数据，然后再接收一些结果。无状态会话的一些常见用例包括但不限于：</p><div class="itemizedlist"><ul><li><p>验证方式</p><div class="itemizedlist"><ul><li><p>这个人有资格抵押吗？</p></li></ul></div></li><li><p>计算方式</p><div class="itemizedlist"><ul><li><p>计算抵押贷款溢价。</p></li></ul></div></li><li><p>路由和过滤</p><div class="itemizedlist"><ul><li><p>将传入消息（例如电子邮件）过滤到文件夹中。</p></li><li><p>将传入消息发送到目的地。</p></li></ul></div></li></ul></div><p>因此，让我们从一个使用驾驶执照应用程序的非常简单的示例开始。</p><pre class="programlisting">public class Applicant {
    private String name;
    private int age;
    private boolean valid;
    // getter and setter methods here
}
</pre><p>现在我们有了数据模型，我们可以编写第一个规则了。我们假设应用程序使用规则来驳斥无效的应用程序。由于这是一个简单的验证用例，我们将添加一条规则以取消任何未满18岁的申请人的资格。</p><pre class="programlisting">package com.company.license

rule "Is of valid age"
when
    $a : Applicant( age &lt; 18 )
then
    $a.setValid( false );
end</pre><p>为了使引擎知道数据，以便可以根据规则对其进行处理，我们必须像<span class="emphasis"><em>插入</em></span>数据库一样<span class="emphasis"><em>插入</em></span>数据。当将Applicant实例插入引擎中时，将根据规则的约束对其进行评估，在这种情况下，一个规则只有两个约束。我们说<span class="emphasis"><em>两个</em></span>是因为类型Applicant是第一个对象类型约束，并且<code class="code">age < 18</code>是第二个字段约束。对象类型约束加上其零个或多个字段约束称为模式。当插入的实例同时满足对象类型约束和所有字段约束时，就称为匹配。的<code class="code">$a</code>是一个绑定变量，它允许我们在结果中引用匹配的对象。在那里可以更新其属性。美元字符（'$'）是可选的，但有助于区分变量名和字段名。毫无疑问，将模式与插入的数据进行匹配的过程通常称为<span class="emphasis"><em>模式匹配</em></span> 。</p><p>假设规则与类位于同一文件夹中，因此我们可以使用类路径资源加载器来构建第一个<code class="code">KnowledgeBase</code> 。知识库就是我们称为已编译规则的集合，这些规则是使用<code class="code">KnowledgeBuilder</code> 。</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "licenseApplication.drl", getClass() ),
              ResourceType.DRL );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );</pre><p>上面的代码段在类路径上查找<code class="filename">licenseApplication.drl</code>文件，使用方法<code class="code">newClassPathResource()</code> 。资源类型为DRL，是“ Drools规则语言”的缩写。添加DRL文件后，我们可以检查Knowledge Builder对象是否存在任何错误。如果没有错误，我们可以将结果包添加到我们的知识库中。现在我们准备建立会话并针对一些数据执行：</p><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
assertTrue( applicant.isValid() );
ksession.execute( applicant );
assertFalse( applicant.isValid() );
</pre><p>前面的代码将根据规则执行数据。由于申请人未满18岁，因此该申请被标记为无效。</p><p>到目前为止，我们仅使用了一个实例，但是如果我们要使用多个实例又该怎么办？我们可以针对实现Iterable的任何对象（例如集合）执行。让我们添加另一个名为<code class="code">Application</code> ，其中包含申请日期，我们还将布尔有效字段移至<code class="code">Application</code>类。</p><pre class="programlisting">public class Applicant {
    private String name;
    private int age;
    // getter and setter methods here
}

public class Application {
    private Date dateApplied;
    private boolean valid;
    // getter and setter methods here
}</pre><p>我们还可以添加另一条规则来验证该应用程序是在一段时间内完成的。</p><pre class="programlisting">package com.company.license

rule "Is of valid age"
when
    Applicant( age &lt; 18 )
    $a : Application()     
then
    $a.setValid( false );
end

rule "Application was made this year"
when
    $a : Application( dateApplied &gt; "01-jan-2009" )     
then
    $a.setValid( false );
end
</pre><p>不幸的是，Java数组未实现<code class="code">Iterable</code>接口，所以我们必须使用JDK转换器方法<code class="code">Arrays.asList(...)</code> 。下面显示的代码针对一个可迭代的列表执行，在该列表中，所有匹配元素在触发任何匹配的规则之前都会插入。</p><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
Application application = new Application();
assertTrue( application() );
ksession.execute( Arrays.asList( new Object[] { application, applicant } ) );
assertFalse( application() );
</pre><p>两种执行方法<code class="code">execute(Object object)</code>和<code class="code">execute(Iterable objects)</code>实际上是界面的便捷方法<code class="code">BatchExecutor</code>的方法<code class="code">execute(Command command)</code> 。</p><p>一种<code class="code">CommandFactory</code>用于创建命令，因此以下等效于<code class="code">execute(Iterable it)</code> ：</p><pre class="programlisting">ksession.execute( CommandFactory.newInsertIterable( new Object[] { application, applicant } ) );
</pre><p>当使用多个命令并使用输出标识符来获取结果时，批处理执行器和命令工厂特别有用。</p><pre class="programlisting">List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();
cmds.add( CommandFactory.newInsert( new Person( "Mr John Smith" ), "mrSmith" );
cmds.add( CommandFactory.newInsert( new Person( "Mr John Doe" ), "mrDoe" );
BatchExecutionResults results = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
assertEquals( new Person( "Mr John Smith" ), results.getValue( "mrSmith" ) );
</pre><p><code class="code">CommandFactory</code>支持许多其他可以在<code class="code">BatchExecutor</code>喜欢<code class="code">StartProcess</code> ， <code class="code">Query</code>和<code class="code">SetGlobal</code> 。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e390"></a> 2.1.2。有状态知识会议</h3></div></div></div><p>有状态会话的寿命更长，并且允许随着时间的推移进行迭代更改。有状态会话的一些常见用例包括但不限于：</p><div class="itemizedlist"><ul><li><p>监控方式</p><div class="itemizedlist"><ul><li><p>半自动购买的股票市场监视和分析。</p></li></ul></div></li><li><p>诊断程序</p><div class="itemizedlist"><ul><li><p>故障查找，医疗诊断</p></li></ul></div></li><li><p>后勤</p><div class="itemizedlist"><ul><li><p>包裹追踪和配送</p></li></ul></div></li><li><p>合规</p><div class="itemizedlist"><ul><li><p>验证市场交易的合法性。</p></li></ul></div></li></ul></div><p>与无状态会话相比， <code class="code">dispose()</code>此后必须调用方法，以确保不存在内存泄漏，因为知识库包含在创建有状态知识会话时的引用。
      <code class="code">StatefulKnowledgeSession</code>也支持<code class="code">BatchExecutor</code>界面，如<code class="code">StatelessKnowledgeSession</code> ，唯一的区别是<code class="code">FireAllRules</code>最终状态会话不会自动调用该命令。</p><p>我们以引发火灾警报的示例来说明监视用例。仅使用四个类，我们就代表一间屋子的房间，每个房间都有一个洒水器。如果房间里起火了，我们用一个<code class="code">Fire</code>实例。</p><pre class="programlisting">public class Room {
    private String name
    // getter and setter methods here
}
public classs Sprinkler {
    private Room room;
    private boolean on;
    // getter and setter methods here
}
public class Fire {
    private Room room;
    // getter and setter methods here
}
public class Alarm {
}
</pre><p>在上一节“无状态会话”中，介绍了对数据进行插入和匹配的概念。该示例假定只插入了每种对象类型的单个实例，因此仅使用了文字约束。但是，房屋有许多房间，因此规则必须表达对象之间的关系，例如某个房间中的洒水器。最好通过将绑定变量用作模式中的约束来完成。这种“连接”过程产生了所谓的交叉乘积，将在下一节中介绍。</p><p>发生火灾时， <code class="code">Fire</code>为此房间创建了class，并将其插入到会话中。该规则在<code class="code">room</code>的领域<code class="code">Fire</code>对象以限制与该房间（目前已关闭）的洒水装置的匹配。当该规则触发并执行结果时，喷淋头将打开。</p><pre class="programlisting">rule "When there is a fire turn on the sprinkler"
when
    Fire($room : room)
    $sprinkler : Sprinkler( room == $room, on == false )
then
    modify( $sprinkler ) { setOn( true ) };
    System.out.println( "Turn on the sprinkler for room " + $room.getName() );
end</pre><p>无状态会话使用标准Java语法修改字段，而在上述规则中，我们使用<strong class="kw"><code>modify</code></strong>语句，它充当一种“ with”语句。它可能包含一系列用逗号分隔的Java表达式，即，对由Java对象选择的对象的setter的调用。 <strong class="kw"><code>modify</code></strong>语句的控制表达式。这会修改数据，并使引擎知道这些更改，以便可以再次对它们进行推理。此过程称为推断，对于有状态会话的工作而言至关重要。无状态会话通常不使用推断，因此引擎不需要知道数据更改。也可以使用<span class="emphasis"><em>顺序模式</em></span>显式关闭推断。</p><p>到目前为止，我们有规则告诉我们何时存在匹配数据，但是什么时候<span class="emphasis"><em>不</em></span>存在呢？我们如何确定火已熄灭，即没有火<code class="code">Fire</code>反对了吗？以前，根据命题逻辑，约束条件是句子，其中引擎针对单个实例进行约束。Drools还支持一阶逻辑，该逻辑使您可以查看数据集。关键字下的模式<strong class="kw"><code>not</code></strong>不存在时匹配。当房间里的火消失后，下面给出的规则将自动关闭洒水装置。</p><pre class="programlisting">rule "When the fire is gone turn off the sprinkler"
when
    $room : Room( )
    $sprinkler : Sprinkler( room == $room, on == true )
    not Fire( room == $room )
then
    modify( $sprinkler ) { setOn( false ) };
    System.out.println( "Turn off the sprinkler for room " + $room.getName() );
end</pre><p>虽然每个房间只有一个洒水装置，但建筑物只有一个警报。一个<code class="code">Alarm</code>发生火灾时创建对象，但只有一个<code class="code">Alarm</code>无论发生多少火灾，整个建筑物都需要使用。先前<strong class="kw"><code>not</code></strong>被引入以匹配事实的缺失；现在我们用它的补码<strong class="kw"><code>exists</code></strong>与某个类别的一个或多个实例匹配。</p><pre class="programlisting">rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert( new Alarm() );
    System.out.println( "Raise the alarm" );
end</pre><p>同样，当没有火灾发生时，我们要删除警报，因此<strong class="kw"><code>not</code></strong>关键字可以再次使用。</p><pre class="programlisting">rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    retract( $alarm );
    System.out.println( "Cancel the alarm" );
end

</pre><p>最后，在应用程序首次启动时以及在删除警报并关闭所有洒水装置之后，会打印一条常规的健康状态消息。</p><pre class="programlisting">rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler( on === true ) 
then
    System.out.println( "Everything is ok" );
end</pre><p>以上规则应放在单个DRL文件中，并使用文件名保存到类路径的某个目录中<code class="filename">fireAlarm.drl</code> ，如无状态会话示例中所示。然后，我们可以像以前一样使用新名称来建立知识库<code class="filename">fireAlarm.drl</code> 。不同之处在于，这一次我们从知识库创建一个有状态会话，而在我们创建无状态会话之前。</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "fireAlarm.drl", getClass() ),
              ResourceType.DRL );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();</pre><p>创建会话后，现在就可以随着时间的推移反复使用它。四个<code class="code">Room</code>创建并插入对象，以及一个<code class="code">Sprinkler</code>每个房间的对象。此时，引擎已完成所有匹配，但尚未触发任何规则。呼唤<code class="code">ksession.fireAllRules()</code>允许匹配的规则触发，但不会触发只会产生运行状况消息的触发。</p><pre class="programlisting">String[] names = new String[]{"kitchen", "bedroom", "office", "livingroom"};
Map&lt;String,Room&gt; name2room = new HashMap&lt;String,Room&gt;();
for( String name: names ){
    Room room = new Room( name );
    name2room.put( name, room );
    ksession.insert( room );
    Sprinkler sprinkler = new Sprinkler( room );
    ksession.insert( sprinkler );
}

ksession.fireAllRules()
</pre><pre class="programlisting">&gt; Everything is ok</pre><p>现在，我们创建两个火并将其插入；这次保留了返回的参考<code class="code">FactHandle</code> 。事实句柄是对插入实例的内部引擎引用，它允许实例在以后的某个时间点撤回或修改。现在，引擎起火了<code class="code">fireAllRules()</code>调用时，将发出警报并打开相应的洒水装置。</p><pre class="programlisting">Fire kitchenFire = new Fire( name2room.get( "kitchen" ) );
Fire officeFire = new Fire( name2room.get( "office" ) );

FactHandle kitchenFireHandle = ksession.insert( kitchenFire );
FactHandle officeFireHandle = ksession.insert( officeFire );

ksession.fireAllRules();</pre><pre class="programlisting">&gt; Raise the alarm
&gt; Turn on the sprinkler for room kitchen
&gt; Turn on the sprinkler for room office</pre><p>一段时间后，将扑灭大火， <code class="code">Fire</code>实例已撤消。这样会导致喷头关闭，警报被取消，并最终再次打印健康信息。</p><pre class="programlisting">ksession.retract( kitchenFireHandle );
ksession.retract( officeFireHandle );

ksession.fireAllRules();</pre><pre class="programlisting">&gt; Turn on the sprinkler for room office
&gt; Turn on the sprinkler for room kitchen
&gt; Cancel the alarm
&gt; Everything is ok</pre><p>每个人还和我在一起吗？并不是那么困难，我已经希望您可以开始看到声明性规则系统的价值和力量。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e562"></a> 2.2。一点理论</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e565"></a> 2.2.1。方法与规则</h3></div></div></div><p>人们经常会混淆方法和规则，新规则用户经常会问：“我怎么称呼规则？“在上一节之后，您现在感觉像是一个规则专家，答案很明显，但是尽管如此，还是让我们总结一下区别。</p><pre class="programlisting">public void helloWorld(Person person) {
    if ( person.getName().equals( "Chuck" ) ) {
        System.out.println( "Hello Chuck" );
    }
}</pre><div class="itemizedlist"><ul><li><p>方法被直接调用。</p></li><li><p>传递了特定实例。</p></li><li><p>一个调用导致一次执行。</p></li></ul></div><pre class="programlisting">rule "Hello World"
    when
        Person( name == "Chuck" )
    then
        System.out.println( "Hello Chuck" );
        end</pre><div class="itemizedlist"><ul><li><p>只要将数据插入引擎中，规则就会通过匹配任何数据来执行。</p></li><li><p>规则永远不能直接调用。</p></li><li><p>特定实例无法传递到规则。</p></li><li><p>根据比赛的不同，规则可能会触发一次或多次，甚至根本不会触发。</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e597"></a> 2.2.2。交叉产品</h3></div></div></div><p>前面提到了“叉积”一词，这是联接的结果。想象一下，将火灾警报示例中的数据与以下规则结合使用，其中没有字段约束：</p><pre class="programlisting">rule
when
    $room : Room()
    $sprinkler : Sprinkler()
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</pre><p>用SQL术语来说，这就像<code class="code">select * from Room, Sprinkler</code> Room表中的每一行将与Sprinkler表中的每一行连接在一起，从而产生以下输出：</p><pre class="programlisting">room:office sprinker:office
room:office sprinkler:kitchen
room:office sprinkler:livingroom
room:office sprinkler:bedroom
room:kitchen sprinkler:office
room:kitchen sprinkler:kitchen
room:kitchen sprinkler:livingroom
room:kitchen sprinkler:bedroom
room:livingroom sprinkler:office
room:livingroom sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:livingroom sprinkler:bedroom
room:bedroom sprinkler:office
room:bedroom sprinkler:kitchen
room:bedroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</pre><p>这些交叉乘积显然会变得巨大，并且很可能包含虚假数据。对于新规则作者而言，交叉产品的大小通常是性能问题的根源。由此可见，总是需要约束叉积，这是通过变量约束来完成的。</p><pre class="programlisting">rule
when
    $room : Room()
    $sprinkler : Sprinkler( room == $room )
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</pre><p>这样仅产生四行数据，每个房间都有正确的自动喷水灭火器。在SQL（实际上是HQL）中，相应的查询为<code class="code">select * from Room, Sprinkler where Room == Sprinkler.room</code> 。</p><pre class="programlisting">room:office sprinkler:office
room:kitchen sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e622"></a> 2.2.3。激活，议程和冲突集。</h3></div></div></div><p>到目前为止，数据和匹配过程非常简单而且很小。为了使事情更加复杂，将探索一个新示例，该示例处理日期期间的现金流量计算。发动机状态将在关键阶段进行说明性显示，以帮助您更好地了解发动机罩下实际发生的情况。如下所示，将使用三个类。</p><pre class="programlisting">public class CashFlow {
    private Date   date;
    private double amount;
    private int    type;
    long           accountNo;
    // getter and setter methods here
}

public class Account {
    private long   accountNo;
    private double balance;
    // getter and setter methods here
}

public AccountPeriod {
    private Date start;
    private Date end;
    // getter and setter methods here
}</pre><p>到目前为止，您已经知道如何创建知识库以及如何实例化事实以填充知识库。 <code class="code">StatefulKnowledgeSession</code> ，因此表格将用于显示插入数据的状态，因为为了说明起见，它使事情变得更加清晰。下表显示了为<code class="code">Account</code> 。还插入了一系列借方和贷方，例如<code class="code">CashFlow</code>该帐户的对象，扩展了两个季度。</p><div class="figure"><a id="d0e640"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Quick_Start/tables1.png" width="100%" alt="现金流量和账户"></td></tr></tbody></table></div></div><p class="title"><b>图2.1。现金流量和账户</b></p></div><br class="figure-break"><p>可以使用两个规则来确定该季度的借方和贷方并更新帐户余额。以下两个规则限制了给定时间段内帐户的现金流量。请注意，“ &&”使用快捷语法来避免重复两次字段名称。</p><table frame="void"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">rule "increase balance for credits"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end,
    $amount : amount )
then
  acc.balance  += $amount;
end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">rule "decrease balance for debits" 
when 
  ap : AccountPeriod() 
  acc : Account( $accountNo : accountNo ) 
  CashFlow( type == DEBIT, 
    accountNo == $accountNo,
    date &gt;= ap.start &amp;&amp; &lt;= ap.end, 
    $amount : amount ) 
then 
  acc.balance -= $amount; 
end</pre>
            </td>
          </tr></tbody></table><p>如果<code class="code">AccountPeriod</code>设置为第一季度，我们将规则“增加贷方余额”应用于两行数据，将“减少借方余额余额”应用于单行数据。</p><div class="figure"><a id="d0e669"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables2.png" alt="会计期间，现金流量和帐户"></div></div><p class="title"><b>图2.2。会计期间，现金流量和帐户</b></p></div><br class="figure-break"><p>上面的两个现金流量表代表两个规则的匹配数据。数据在插入阶段是匹配的，正如您在上一章中发现的那样，不会立即触发，而只会在之后<code class="code">fireAllRules()</code>叫做。同时，规则及其匹配数据被放在议程中，称为激活。议程是一个激活表，一旦调用fireAllRules（），就可以触发并执行其后果。议程中的激活依次执行。注意，到目前为止，执行顺序被认为是任意的。</p><div class="figure"><a id="d0e680"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables7.png" alt="现金流量和账户"></div></div><p class="title"><b>图2.3。现金流量和账户</b></p></div><br class="figure-break"><p>触发所有上述激活后，帐户的余额为-25。</p><div class="figure"><a id="d0e688"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables3.png" alt="现金流量和账户"></div></div><p class="title"><b>图2.4。现金流量和账户</b></p></div><br class="figure-break"><p>如果<code class="code">AccountPeriod</code>更新到第二季度，我们只有一行匹配的数据，因此议程上只有一次激活。</p><div class="figure"><a id="d0e699"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables4.png" alt="现金流量和账户"></div></div><p class="title"><b>图2.5。现金流量和账户</b></p></div><br class="figure-break"><p>触发该激活会导致余额为25。</p><div class="figure"><a id="d0e707"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables5.png" alt="现金流量和账户"></div></div><p class="title"><b>图2.6。现金流量和账户</b></p></div><br class="figure-break"><p>如果您不希望激活执行的顺序是任意的怎么办？如果议程上有一个或多个激活，则称它们处于冲突状态，并且使用冲突解决程序策略来确定执行顺序。在最简单的级别上，默认策略使用显着性来确定规则优先级。每个规则的默认值为0，该值越高，优先级越高。为了说明这一点，我们添加了一个规则来打印帐户余额，我们希望在所有借项和贷项都应用到所有帐户之后执行该规则。我们通过为该规则分配负的显着性来实现，以便在所有规则的默认显着性为0时触发。</p><table border="0" id="d0e715"><tbody><tr>
            <td>
              <pre class="programlisting">rule "Print balance for AccountPeriod"
        salience -50
    when
        ap : AccountPeriod()
        acc : Account()        
    then
        System.out.println( acc.accountNo + " : " + acc.balance );    
end</pre>
            </td>
          </tr></tbody></table><p>下表描述了由此产生的议程。这三个借记和贷记规则显示为任意顺序，而打印规则排在最后，然后执行。</p><div class="figure"><a id="d0e727"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Quick_Start/tables6.png" alt="现金流量和账户"></div></div><p class="title"><b>图2.7。现金流量和账户</b></p></div><br class="figure-break"><p>前面我们展示了规则如何等同于SQL，这通常可以帮助具有SQL背景的人理解规则。上面的两个规则可以用两个视图和每个视图的触发器来表示，如下所示：</p><table border="0" id="d0e735"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">select * from Account acc,
              Cashflow cf,
              AccountPeriod ap      
where acc.accountNo == cf.accountNo and 
      cf.type == CREDIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">select * from Account acc, 
              Cashflow cf,
              AccountPeriod ap 
where acc.accountNo == cf.accountNo and 
      cf.type == DEBIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</pre>
            </td>
          </tr><tr>
            <td align="left" valign="top">
              <pre class="programlisting">trigger : acc.balance += cf.amount</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">trigger : acc.balance -= cf.amount</pre>
            </td>
          </tr></tbody></table><p>Drools还具有ruleflow-group属性，该属性允许工作流图以声明方式指定允许规则触发的时间。下面的屏幕快照是使用Drools插件从Eclipse中获取的。它具有两个Ruleflow-Group节点，可确保计算规则在报告规则之前执行。</p><div class="mediaobject"><img src="images/Chapter-Quick_Start/ruleflow.png"></div><p>下面显示了规则中ruleflow-group属性的使用。</p><table border="0" id="d0e772"><tbody><tr>
            <td align="left" valign="top">
              <pre class="programlisting">rule "increase balance for credits"
  ruleflow-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</pre>
            </td>

            <td align="left" valign="top">
              <pre class="programlisting">rule "Print balance for AccountPeriod"
  ruleflow-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</pre>
            </td>
          </tr></tbody></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e788"></a> 2.3。有关构建和部署的更多信息</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e791"></a> 2.3.1。使用变更集的配置知识库</h3></div></div></div><p>到目前为止，程序化API已用于构建知识库。通常，更希望通过配置来执行此操作。为此，Drools支持“变更集”功能。文件<code class="filename">changeset.xml</code>包含资源列表，它也可以递归指向另一个变更集XML文件。当前，变更集只有一个“添加”元素，但是将来会添加对删除和修改的支持，以便随着时间的推移进行更强大的增量更改。当前，变更集XML没有XML模式，但我们希望尽快添加一个XML模式。将显示一些示例，让您了解要点。使用资源方法，该资源方法使用前缀来指示协议。提供的所有协议<code class="code">java.net.URL</code>支持，例如“文件”和“ http”，以及附加的“类路径”。当前，必须始终为资源指定type属性，因为它不是从文件扩展名中推断出来的。这是一个简单的示例，指向一些规则的http位置。</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre><p>要使用上述XML，代码与以前几乎相同，只是我们将资源类型更改为<code class="code">CHANGE_SET</code> 。</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClasspathResource( "myChangeSet.xml", getClass() ),
              ResourceType.CHANGE_SET );
if ( kbuilder.hasErrors() ) {
    System.err.println( builder.getErrors().toString() );
}</pre><p>变更集可以包含任何数量的资源，并且它们甚至还支持其他配置信息，当前仅决策表需要这些信息。扩展了以下示例，以从http URL位置加载规则，并从类路径加载Excel决策表。</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
       &lt;resource source='classpath:data/IntegrationExampleTest.xls' type="DTABLE"&gt;
           &lt;decisiontable-conf input-type="XLS" worksheet-name="Tables_2" /&gt;
       &lt;/resource&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre><p>还可以指定一个目录，以添加该目录的内容。由于尚未从文件扩展名中推断出类型，因此预期所有文件都是指定的类型。</p><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
       &lt;resource source='file://myfolder/' type='DRL' /&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e819"></a> 2.3.2。知识代理</h3></div></div></div><p>Knowlege代理可自动加载，缓存和重新加载资源，并通过属性文件进行配置。知识代理可以在其使用的资源发生更改时更新或重建此知识库。此策略由提供给工厂的配置确定，但通常使用常规轮询基于拉动。我们希望在将来的版本中添加基于推送的更新和重建。</p><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
kagent.applyChangeSet( ResourceFactory.newUrlResource( url ) );
KnowledgeBase kbase = kagent.getKnowledgeBase();</pre><p>一种<code class="code">KnowledgeAgent</code>对象将使用60秒的默认轮询间隔连续扫描所有添加的资源，并且在更新最后修改日期时，它将使用新资源重建缓存的知识库。注意前面<code class="code">KnowledgeBase</code>参考仍然存在，您必须致电<code class="code">getKnowledgeBase()</code>访问新建的<code class="code">KnowledgeBase</code> 。如果将目录指定为更改集的一部分，则将扫描该目录的全部内容以查找更改。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e840"></a>第3章。用户指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e843">3.1。建造</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e852">3.1.1。使用代码构建</a></span></dt><dt><span class="section"><a href="#d0e933">3.1.2。使用Configuration和ChangeSet XML构建</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e989">3.2。部署中</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e992">3.2.1。知识包和知识定义</a></span></dt><dt><span class="section"><a href="#d0e1005">3.2.2。知识库</a></span></dt><dt><span class="section"><a href="#d0e1055">3.2.3。进程内构建和部署</a></span></dt><dt><span class="section"><a href="#d0e1070">3.2.4。在单独的流程中构建和部署</a></span></dt><dt><span class="section"><a href="#d0e1109">3.2.5。状态知识会话和知识库修改</a></span></dt><dt><span class="section"><a href="#d0e1123">3.2.6。知识代理商</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1248">3.3。跑步</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1252">3.3.1。知识库</a></span></dt><dt><span class="section"><a href="#d0e1271">3.3.2。有状态知识会话</a></span></dt><dt><span class="section"><a href="#d0e1293">3.3.3。知识运行时</a></span></dt><dt><span class="section"><a href="#d0e1560">3.3.4。议程</a></span></dt><dt><span class="section"><a href="#d0e1666">3.3.5。事件模型</a></span></dt><dt><span class="section"><a href="#d0e1781">3.3.6。KnowledgeRuntimeLogger</a></span></dt><dt><span class="section"><a href="#d0e1797">3.3.7。无状态知识会话</a></span></dt><dt><span class="section"><a href="#d0e1992">3.3.8。管道</a></span></dt><dt><span class="section"><a href="#d0e2250">3.3.9。命令和CommandExecutor</a></span></dt><dt><span class="section"><a href="#d0e2593">3.3.10。编组</a></span></dt><dt><span class="section"><a href="#d0e2668">3.3.11。持久性和交易</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e843"></a> 3.1。建造</h2></div></div></div><div class="figure"><a id="d0e846"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/builder.png" alt="org.drools.builder"></div></div><p class="title"><b>图3.1。 org.drools.builder</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e852"></a> 3.1.1。使用代码构建</h3></div></div></div><p>KnowledgeBuilder负责获取源文件（例如DRL文件或Excel文件），并将它们转换为知识库可以使用的规则和流程定义的知识包。类的对象<code class="code">ResourceType</code>指示要求其构建的资源类型。</p><p>的<code class="code">ResourceFactory</code>提供从多种来源（例如Reader，ClassPath，URL，File或ByteArray）加载资源的功能。诸如决策表（Excel .xls文件）之类的二进制文件不应使用基于Reader的资源处理程序，后者仅适用于基于文本的资源。</p><div class="figure"><a id="d0e865"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeBuilder.png" width="100%" alt="知识构建者"></td></tr></tbody></table></div></div><p class="title"><b>图3.2。知识构建者</b></p></div><br class="figure-break"><p>KnowlegeBuilder是使用KnowledgeBuilderFactory创建的。</p><div class="figure"><a id="d0e873"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeBuilderFactory.png" width="100%" alt="KnowledgeBuilderFactory"></td></tr></tbody></table></div></div><p class="title"><b>图3.3。KnowledgeBuilderFactory</b></p></div><br class="figure-break"><p>可以使用默认配置创建KnowledgeBuilder。</p><div class="example"><a id="d0e881"></a><p class="title"><b>示例3.1创建一个新的KnowledgeBuilder</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();</pre></div></div><br class="example-break"><p>可以使用<code class="code">KnowledgeBuilderFactory</code> 。这样就可以修改Knowledge Builder的行为。最常见的用法是提供一个自定义类加载器，以便<code class="code">KnowledgeBuilder</code>对象可以解析不在默认类路径中的类。第一个参数用于属性，并且是可选的，即，可以将其保留为null，在这种情况下，将使用默认选项。options参数可用于诸如更改方言或注册新的累加器功能之类的事情。</p><div class="example"><a id="d0e894"></a><p class="title"><b>示例3.2使用自定义的ClassLoader创建新的KnowledgeBuilder</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilderConfiguration kbuilderConf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null, classLoader );
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(kbuilderConf);
</pre></div></div><br class="example-break"><p>任何类型的资源都可以迭代添加。在下面，添加了DRL文件。与Drools 4.0 Package Builder不同，Knowledge Builder现在可以处理多个名称空间，因此您可以不考虑名称空间而继续添加资源。</p><div class="example"><a id="d0e901"></a><p class="title"><b>示例3.3添加DRL资源</b></p><div class="example-contents"><pre class="programlisting">kbuilder.add( ResourceFactory.newFileResource( "/project/myrules.drl" ),
              ResourceType.DRL);
</pre></div></div><br class="example-break"><p>最佳做法是始终检查<code class="code">hasErrors()</code>加法后的方法。如果有错误，则不应添加更多资源或检索知识包。 <code class="code">getKnowledgePackages()</code>如果有错误，则返回一个空列表。</p><div class="example"><a id="d0e914"></a><p class="title"><b>示例3.4证实</b></p><div class="example-contents"><pre class="programlisting">if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}
</pre></div></div><br class="example-break"><p>添加完所有资源并且没有错误后，就可以检索知识包的集合。这是一个集合，因为每个包名称空间都有一个知识包。这些知识包是可序列化的，通常用作部署单元。</p><div class="example"><a id="d0e921"></a><p class="title"><b>示例3.5获取知识包</b></p><div class="example-contents"><pre class="programlisting">Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();
</pre></div></div><br class="example-break"><p>最后一个示例将所有内容放在一起。</p><div class="example"><a id="d0e928"></a><p class="title"><b>示例3.6放在一起</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}

KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newFileResource( "/project/myrules1.drl" ),
              ResourceType.DRL);
kbuilder.add( ResourceFactory.newFileResource( "/project/myrules2.drl" ),
              ResourceType.DRL);

if( kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
    return;
}

Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e933"></a> 3.1.2。使用Configuration和ChangeSet XML构建</h3></div></div></div><p>除了添加资源来以编程方式创建定义外，还可以通过ChangeSet XML通过配置来实现。简单的XML文件支持三个元素：添加，删除和修改，每个<resource>元素都有<resource>定义配置实体的一系列<resource>子元素。以下XML模式<span class="emphasis"><em>不是</em></span>规范性的，仅用于说明目的。</resource></resource></resource></p><div class="example"><a id="d0e941"></a><p class="title"><b>示例3.7ChangeSet XML的XML模式（非规范）</b></p><div class="example-contents"><pre class="programlisting">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://drools.org/drools-5.0/change-set"
           targetNamespace="http://drools.org/drools-5.0/change-set"&gt;

  &lt;xs:element name="change-set" type="ChangeSet"/&gt;

  &lt;xs:complexType name="ChangeSet"&gt;
    &lt;xs:choice maxOccurs="unbounded"&gt;
      &lt;xs:element name="add"    type="Operation"/&gt;
      &lt;xs:element name="remove" type="Operation"/&gt;
      &lt;xs:element name="modify" type="Operation"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Operation"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="resource" type="Resource"
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="Resource"&gt;
    &lt;xs:sequence&gt;
      
      &lt;xs:element name="decisiontable-conf" type="DecTabConf"
                  minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    
    &lt;xs:attribute name="source" type="xs:string"/&gt;
    &lt;xs:attribute name="type"   type="ResourceType"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="DecTabConf"&gt;
    &lt;xs:attribute name="input-type"     type="DecTabInpType"/&gt;
    &lt;xs:attribute name="worksheet-name" type="xs:string"
                  use="optional"/&gt;
  &lt;/xs:complexType&gt;

  
  &lt;xs:simpleType name="ResourceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="DRL"/&gt;
      &lt;xs:enumeration value="XDRL"/&gt;
      &lt;xs:enumeration value="DSL"/&gt;
      &lt;xs:enumeration value="DSLR"/&gt;
      &lt;xs:enumeration value="DRF"/&gt;
      &lt;xs:enumeration value="DTABLE"/&gt;
      &lt;xs:enumeration value="PKG"/&gt;
      &lt;xs:enumeration value="BRL"/&gt;
      &lt;xs:enumeration value="CHANGE_SET"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  
  &lt;xs:simpleType name="DecTabInpType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="XLS"/&gt;
      &lt;xs:enumeration value="CSV"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</pre></div></div><br class="example-break"><p>当前仅支持add元素，但将实现其他元素以支持迭代更改。以下示例加载单个DRL文件。</p><div class="example"><a id="d0e956"></a><p class="title"><b>示例3.8简单的ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/project/myrules.drl' type='DRL' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"><p>注意<code class="code">file:</code>前缀，表示资源协议。变更集支持java.net提供的所有协议。URL，例如“文件”和“ http”，以及附加的“ classpath”。当前，必须始终为资源指定type属性，因为它不是从文件扩展名中推断出来的。使用Java中的ClassPath资源加载器，可以指定用于定位资源的类加载器，但这在XML中是不可能的。取而代之的是，除非ChangeSet XML本身由ClassPath资源加载，否则Class Loader将默认为知识生成器使用的那种，在这种情况下，它将使用为该资源指定的Class Loader。</p><p>当前，您仍然需要使用API来加载该ChangeSet，但是将来我们将添加对诸如Spring之类的容器的支持，以便可以通过XML配置完全完成创建知识库的过程。使用XML文件加载资源再简单不过了，因为它只是另一种资源类型。</p><div class="example"><a id="d0e968"></a><p class="title"><b>示例3.9加载ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting">kbuilder.add( ResourceFactory.newUrlResource( url ), ResourceType.CHANGE_SET );
</pre></div></div><br class="example-break"><p>ChangeSet可以包含任何数量的资源，它们甚至支持其他配置信息，当前仅决策表需要这些信息。下面，示例被展开以从http URL位置加载规则，并从类路径加载Excel决策表。</p><div class="example"><a id="d0e975"></a><p class="title"><b>示例3.10具有资源配置的ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting"> &lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
             xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
             xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
  &lt;add&gt;
       &lt;resource source='http:org/domain/myrules.drl' type='DRL' /&gt;
       &lt;resource source='classpath:data/IntegrationExampleTest.xls' type="DTABLE"&gt;
           &lt;decisiontable-conf input-type="XLS" worksheet-name="Tables_2" /&gt;
       &lt;/resource&gt;
   &lt;/add&gt;
 &lt;/change-set&gt;
</pre></div></div><br class="example-break"><p>ChangeSet与知识代理一起使用时特别有用，因为它允许更改通知和知识库的自动重建，这在知识代理的“部署”部分中有更详细的介绍。</p><p>还可以指定目录，以将所有资源添加到该文件夹中。当前，预计该文件夹中的所有资源都属于同一类型。如果使用知识代理，它将连续扫描添加，修改或删除的资源，并重建缓存的知识库。KnowledgeAgent提供了有关此的更多信息。</p><div class="example"><a id="d0e984"></a><p class="title"><b>示例3.11ChangeSet XML，用于添加目录的内容</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/projects/myproject/myrules' type='DRL' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e989"></a> 3.2。部署中</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e992"></a> 3.2.1。知识包和知识定义</h3></div></div></div><p>知识包是知识定义的集合，例如规则和流程。它由知识生成器创建，如“构建”一章中所述。知识包是独立的且可序列化的，并且当前构成基本的部署单元。</p><div class="figure"><a id="d0e997"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgePackage.png" alt="知识包"></div></div><p class="title"><b>图3.4。知识包</b></p></div><br class="figure-break"><p>知识包已添加到知识库。但是，知识包实例一旦添加到知识库中就无法重用。如果需要将其添加到另一个知识库中，请尝试首先对其进行序列化，然后使用“克隆的”结果。我们希望在将来的Drools版本中解决此限制。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1005"></a> 3.2.2。知识库</h3></div></div></div><p>知识库库是所有应用程序知识定义的存储库。它可能包含规则，流程，功能和类型模型。知识库本身不包含实例数据，即事实。而是从知识库创建会话，可以在其中插入数据并可以在其中启动流程实例。创建知识库的过程可能很繁重，而会话创建的过程却很轻松，因此建议在可能的地方缓存知识库，以允许重复的会话创建。</p><div class="figure"><a id="d0e1010"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeBase.png" width="100%" alt="知识库"></td></tr></tbody></table></div></div><p class="title"><b>图3.5。知识库</b></p></div><br class="figure-break"><p>一种<code class="code">KnowledgeBase</code>对象也是可序列化的，有些人可能更喜欢先构建然后存储一个<code class="code">KnowledgeBase</code> ，而不是知识包，也将其视为部署的单位。</p><p>KnowlegeBase是使用KnowledgeBaseFactory创建的。</p><div class="figure"><a id="d0e1026"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeBaseFactory.png" width="100%" alt="知识库工厂"></td></tr></tbody></table></div></div><p class="title"><b>图3.6。知识库工厂</b></p></div><br class="figure-break"><p>可以使用默认配置创建知识库。</p><div class="example"><a id="d0e1034"></a><p class="title"><b>示例3.12创建一个新的知识库</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();</pre></div></div><br class="example-break"><p>如果自定义类加载器与<code class="code">KnowledgeBuilder</code>解析默认类加载器中没有的类型，则还必须在<code class="code">KnowledgeBase</code> 。该技术与<code class="code">KnowledgeBuilder</code> 。</p><div class="example"><a id="d0e1050"></a><p class="title"><b>示例3.13使用自定义的ClassLoader创建新的知识库</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration kbaseConf =
    KnowledgeBaseFactory.createKnowledgeBaseConfiguration( null, cl );
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1055"></a> 3.2.3。进程内构建和部署</h3></div></div></div><p>这是最简单的部署形式。它编译知识定义，并将它们添加到同一JVM中的知识库中。这种方法要求drools-core.jar和drools-compiler.jar位于类路径中。</p><div class="example"><a id="d0e1060"></a><p class="title"><b>示例3.14将KnowledgePackages添加到知识库</b></p><div class="example-contents"><pre class="programlisting">Collection&lt;KnowledgePackage&gt; kpkgs = kbuilder.getKnowledgePackages();

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kpkgs );</pre></div></div><br class="example-break"><p>请注意<code class="code">addKnowledgePackages(kpkgs)</code>可以迭代调用此方法以添加其他知识。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1070"></a> 3.2.4。在单独的流程中构建和部署</h3></div></div></div><p>这俩<code class="code">KnowledgeBase</code>和<code class="code">KnowledgePackage</code>是部署和可序列化的单元。这意味着您可以让一台机器进行任何必要的构建， <code class="filename">drools-compiler.jar</code> ，并让另一台机器部署并执行所有操作，只需要<code class="filename">drools-core.jar</code> 。</p><p>尽管序列化是标准Java，但是我们提供一个示例，说明一台计算机如何写出部署单元以及另一台计算机如何读入和使用该部署单元。</p><div class="example"><a id="d0e1089"></a><p class="title"><b>示例3.15将KnowledgePackage写入OutputStream</b></p><div class="example-contents"><pre class="programlisting">ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream( fileName ) );
out.writeObject( kpkgs );
out.close();
</pre></div></div><br class="example-break"><div class="example"><a id="d0e1094"></a><p class="title"><b>示例3.16从InputStream读取KnowledgePackage</b></p><div class="example-contents"><pre class="programlisting">ObjectInputStream in = new ObjectInputStream( new FileInputStream( fileName ) );
// The input stream might contain an individual
// package or a collection.
@SuppressWarnings( "unchecked" )
Collection&lt;KnowledgePackage&gt; kpkgs =
    ()in.readObject( Collection&lt;KnowledgePackage&gt; );
in.close();

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kpkgs );
</pre></div></div><br class="example-break"><p>的<code class="code">KnowledgeBase</code>也可以序列化，有些人可能更喜欢先构建然后再存储<code class="code">KnowledgeBase</code>本身，而不是知识包。</p><p>我们的服务器端管理系统Drools Guvnor使用此部署方法。在Guvnor在URL上编译并发布了序列化的知识包之后，Drools可以使用URL资源类型来加载它们。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1109"></a> 3.2.5。状态知识会话和知识库修改</h3></div></div></div><p>有状态知识会话将在“运行”部分中详细讨论。的<code class="code">KnowledgeBase</code>创建并返回<code class="code">StatefulKnowledgeSession</code>对象，并且可以选择保留对这些对象的引用。什么时候<code class="code">KnowledgeBase</code>会发生修改，这些修改将应用于会话中的数据。此引用是弱引用，也是可选的，由布尔标志控制。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1123"></a> 3.2.6。知识代理商</h3></div></div></div><p>的<code class="code">KnowlegeAgent</code>提供自动加载，缓存和重新加载资源，并通过属性文件进行配置。知识代理可以在其使用的资源发生更改时更新或重建此知识库。此策略由提供给工厂的配置确定，但通常使用常规轮询基于拉动。我们希望在将来的版本中添加基于推送的更新和重建。知识代理将使用60秒的默认轮询间隔连续扫描所有添加的资源。如果他们的上次修改日期已更新，它将使用新资源重建缓存的知识库。</p><div class="figure"><a id="d0e1131"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeAgent.png" width="100%" alt="知识代理商"></td></tr></tbody></table></div></div><p class="title"><b>图3.7。知识代理商</b></p></div><br class="figure-break"><p>的<code class="code">KnowlegeBuilder</code>是使用<code class="code">KnowledgeBuilderFactory</code>宾语。代理必须指定一个名称，该名称在日志文件中用于将日志条目与相应的代理关联。</p><div class="example"><a id="d0e1145"></a><p class="title"><b>示例3.17创建知识代理</b></p><div class="example-contents"><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
</pre></div></div><br class="example-break"><div class="figure"><a id="d0e1150"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeAgentFactory.png" width="100%" alt="知识代理商工厂"></td></tr></tbody></table></div></div><p class="title"><b>图3.8。知识代理商工厂</b></p></div><br class="figure-break"><p>下面的示例构造一个代理，该代理将根据指定的ChangeSet构建新的KnowledgeBase。（有关ChangeSet格式的更多详细信息，请参见“构建”部分。）请注意，可以反复调用此方法以随时间增加新资源。目前，尚未实现ChangeSet XML的remove和Modify元素，但以后的版本也将提供此功能，从而使您可以更好地控制这些增量更改。知识代理每60秒（默认间隔）轮询一次从ChangeSet添加的资源，以查看它们是否已更新。每当发现更改时，它将构建一个新的知识库。如果更改集指定的资源是目录，则其内容也会被扫描以查找更改。</p><div class="example"><a id="d0e1158"></a><p class="title"><b>示例3.18将KnowledgePackage写入OutputStream</b></p><div class="example-contents"><pre class="programlisting">KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent" );
kagent.applyChangeSet( ResourceFactory.newUrlResource( url ) );
KnowledgeBase kbase = kagent.getKnowledgeBase();
</pre></div></div><br class="example-break"><p>资源扫描默认情况下不处于启用状态，它是一项服务，必须启动，并且通知也是如此。两者都可以通过ResourceFactory完成。</p><div class="example"><a id="d0e1165"></a><p class="title"><b>示例3.19启动扫描和通知服务</b></p><div class="example-contents"><pre class="programlisting">ResourceFactory.getResourceChangeNotifierService().start();
ResourceFactory.getResourceChangeScannerService().start();
</pre></div></div><br class="example-break"><p>默认的资源扫描时间可以通过<code class="code">ResourceChangeScannerService</code> 。适当更新<code class="code">ResourceChangeScannerConfiguration</code>对象被传递到服务的<code class="code">configure()</code>方法，该服务允许按需重新配置服务。</p><div class="example"><a id="d0e1181"></a><p class="title"><b>示例3.20更改扫描间隔</b></p><div class="example-contents"><pre class="programlisting">ResourceChangeScannerConfiguration sconf =
    ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();
// Set the disk scanning interval to 30s, default is 60s.
sconf.setProperty( "drools.resource.scanner.interval", "30" ); 
ResourceFactory.getResourceChangeScannerService().configure( sconf );
</pre></div></div><br class="example-break"><p>知识代理可以选择一个空的知识库或一个已填充的知识库。如果提供了填充的知识库，则知识代理将运行知识库中的迭代器并订阅其找到的资源。虽然Knowledge Builder可以构建在目录中找到的所有资源，但是Knowledge Builder会丢失该信息，因此不会连续扫描这些目录。仅将目录指定为<code class="code">applyChangeSet(Resource)</code>方法受到监视。</p><p>提供的优势之一<code class="code">KnowledgeBase</code>作为起点，您可以为其提供一个<code class="code">KnowledgeBaseConfiguration</code> 。当检测到资源变化并且有新资源变化时<code class="code">KnowledgeBase</code>对象被实例化，它将使用<code class="code">KnowledgeBaseConfiguration</code>以前的<code class="code">KnowledgeBase</code>宾语。</p><div class="example"><a id="d0e1208"></a><p class="title"><b>示例3.21。使用现有的知识库</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration kbaseConf =
    KnowledgeBaseFactory.createKnowledgeBaseConfiguration( null, cl );
KnowledgeBase kbase KnowledgeBaseFactory.newKnowledgeBase( kbaseConf );
// Populate kbase with resources here.

KnowledgeAgent kagent =
    KnowledgeAgentFactory.newKnowledgeAgent( "MyAgent", kbase );
KnowledgeBase kbase = kagent.getKnowledgeBase();
</pre></div></div><br class="example-break"><p>在上面的例子中<code class="code">getKnowledgeBase()</code>将返回相同的提供的kbase实例，直到检测到资源更改并建立新的知识库为止。建立新的知识库后，将使用<code class="code">KnowledgeBaseConfiguration</code>提供给前一个<code class="code">KnowledgeBase</code> 。</p><p>如前所述，ChangeSet XML可以指定目录，并将添加其所有内容。如果此ChangeSet XML与<code class="code">applyChangeSet()</code>方法它还将所有目录添加到扫描过程中。当目录扫描检测到其他文件时，它将被添加到知识库中。从知识库中删除所有已删除的文件，并且像往常一样，修改后的文件将强制使用最新版本来构建新的知识库。</p><div class="example"><a id="d0e1229"></a><p class="title"><b>示例3.22用于添加目录内容的ChangeSet XML</b></p><div class="example-contents"><pre class="programlisting">&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
            xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
            xs:schemaLocation='http://drools.org/drools-5.0/change-set.xsd' &gt;
   &lt;add&gt;
      &lt;resource source='file:/projects/myproject/myrules' type='PKG' /&gt;
   &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><br class="example-break"><p>请注意，对于资源类型PKG，不需要drools-compiler依赖项，因为知识代理能够处理那些仅有drools-core的依赖项。</p><p>的<code class="code">KnowledgeAgentConfiguration</code>可用于修改知识代理的默认行为。您可以使用它从目录中加载资源，同时禁止连续扫描该目录的更改。</p><div class="example"><a id="d0e1241"></a><p class="title"><b>示例3.23更改扫描行为</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();

KnowledgeAgentConfiguration kaconf =
    KnowledgeAgentFactory.newKnowledgeAgentConfiguation();
// Do not scan directories, just files.
kaconf.setProperty( "drools.agent.scanDirectories", "false" );
KnowledgeAgent kagent =
    KnowledgeAgentFactory.newKnowledgeAgent( "test agent", kaconf );
</pre></div></div><br class="example-break"><p>前面我们提到了Drools Guvnor，以及它如何在URL上构建和发布序列化的知识包，以及ChangeSet XML可以处理URL和包。总之，这形成了知识代理的重要部署方案。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1248"></a> 3.3。跑步</h2></div></div></div><p></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1252"></a> 3.3.1。知识库</h3></div></div></div><p>的<code class="code">KnowlegeBase</code>是所有应用程序知识定义的存储库。它将包含规则，流程，功能和类型模型。知识库本身不包含数据。而是从<code class="code">KnowledgeBase</code>可以在其中插入数据以及可以从中启动流程实例。创建<code class="code">KnowlegeBase</code>可能很重，而会话创建非常轻巧，因此建议在可能的地方缓存Knowle Bases，以允许重复创建会话。</p><div class="example"><a id="d0e1266"></a><p class="title"><b>示例3.24创建一个新的知识库</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1271"></a> 3.3.2。有状态知识会话</h3></div></div></div><p>的<code class="code">StatefulKnowledgeSession</code>存储并在运行时数据上执行。它是从<code class="code">KnowledgeBase</code> 。</p><div class="figure"><a id="d0e1282"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/StatefulKnowledgeSession.png" width="100%" alt="有状态知识会话"></td></tr></tbody></table></div></div><p class="title"><b>图3.9。有状态知识会话</b></p></div><br class="figure-break"><div class="example"><a id="d0e1288"></a><p class="title"><b>示例3.25从知识库创建一个StatefulKnowledgeSession</b></p><div class="example-contents"><pre class="programlisting">StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1293"></a> 3.3.3。知识运行时</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1296"></a> 3.3.3.1。WorkingMemoryEntryPoint</h4></div></div></div><p>的<code class="code">WorkingMemoryEntryPoint</code>提供有关插入，更新和检索事实的方法。术语“入口点”与以下事实有关：工作内存中有多个分区，您可以选择要插入的分区，尽管此用例是针对事件处理的，并且在Fusion手册中有更详细的介绍。大多数基于规则的应用程序都可以单独使用默认入口点。</p><p>的<code class="code">KnowledgeRuntime</code>接口提供了与引擎的主要交互。在规则后果和流程操作中可用。在本手册中，重点是与规则相关的方法和接口，而与流程相关的方法现在将被忽略。但您会注意到<code class="code">KnowledgeRuntime</code>从两个继承方法<code class="code">WorkingMemory</code>和<code class="code">ProcessRuntime</code> ，从而提供一个统一的API来处理流程和规则。使用规则时，三个接口构成了<code class="code">KnowledgeRuntime</code> ： <code class="code">WorkingMemoryEntryPoint</code> ， <code class="code">WorkingMemory</code>和<code class="code">KnowledgeRuntime</code>本身。</p><div class="figure"><a id="d0e1330"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/WorkingMemoryEntryPoint.png" alt="WorkingMemoryEntryPoint"></div></div><p class="title"><b>图3.10。WorkingMemoryEntryPoint</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1336"></a> 3.3.3.1.1。插入</h5></div></div></div><p>插入是告诉<code class="code">WorkingMemory</code>关于一个事实，你这样做<code class="code">ksession.insert(yourObject)</code> ， 例如。插入事实时，将检查事实是否符合规则。这意味着， <span class="emphasis"><em>所有</em></span>决定有关解雇或不触发规则插入过程中所做的工作;在您致电之前，不会执行任何规则<code class="code">fireAllRules()</code> ，在您插入事实后调用。人们通常会误以为在您打电话时会进行病情评估<code class="code">fireAllRules()</code> 。专家系统通常使用术语<span class="emphasis"><em>断言</em></span>或<span class="emphasis"><em>断言</em></span>来指代可供系统使用的事实。但是，由于“ assert”是大多数语言中的关键字，因此我们决定使用<strong class="kw"><code>insert</code></strong>关键词;因此希望听到两者互换使用的声音。</p><p>插入对象后，它返回一个<code class="code">FactHandle</code> 。这个<code class="code">FactHandle</code>是用于表示您在其中插入的对象的令牌<code class="code">WorkingMemory</code> 。也可用于与<code class="code">WorkingMemory</code>当您希望收回或修改对象时。</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );      </pre><p>如知识库部分所述，工作内存可以两种声明模式运行，即相等或身份，默认身份是身份。</p><p><span class="emphasis"><em>身份</em></span>意味着工作记忆使用<code class="code">IdentityHashMap</code>存储所有声明的对象。新的实例断言总是导致返回新的<code class="code">FactHandle</code> ，但是如果再次声明一个实例，则它将返回原始事实句柄，即，它将忽略针对同一事实的重复插入。</p><p><span class="emphasis"><em>平等</em></span>意味着工作记忆使用<code class="code">HashMap</code>存储所有声明的对象。新实例断言只会返回一个新的<code class="code">FactHandle</code>如果没有相等的对象被断言。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1404"></a> 3.3.3.1.2。缩回</h5></div></div></div><p>撤回是从工作内存中删除事实，这意味着它将不再跟踪和匹配该事实，并且任何激活并依赖于该事实的规则都将被取消。请注意，可能有一些规则取决于事实的不存在，在这种情况下，撤回事实可能会导致规则被激活。（请参阅<code class="code">not</code>和<code class="code">exist</code>关键字。）缩回使用<code class="code">FactHandle</code>是通过插入调用返回的。</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );
....
ksession.retract( stiltonHandle );            </pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1420"></a> 3.3.3.1.3。更新资料</h5></div></div></div><p>必须将修改后的事实通知规则引擎，以便可以对其进行重新处理。在内部，修改实际上是一个撤回操作，然后进行插入操作。规则引擎将事实从<code class="code">WorkingMemory</code>并再次插入。您必须使用<code class="code">update()</code>通知方法<code class="code">WorkingMemory</code>无法通知对象的那些对象的更改对象<code class="code">WorkingMemory</code>他们自己。注意<code class="code">update()</code>始终将修改后的对象作为第二个参数，这使您可以为不可变对象指定新实例。的<code class="code">update()</code>该方法只能与启用了阴影代理的对象一起使用。更新方法仅在Java代码中可用。在规则的右侧， <strong class="kw"><code>modify</code></strong>支持statement，提供对对象的setter的简化调用。</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1448"></a> 3.3.3.2。工作记忆</h4></div></div></div><p>WorkingMemory提供对议程的访问，允许查询执行，并允许您访问名为Enty Points的点。</p><div class="figure"><a id="d0e1453"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/WorkingMemory.png" width="100%" alt="工作记忆"></td></tr></tbody></table></div></div><p class="title"><b>图3.11。工作记忆</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1459"></a> 3.3.3.2.1。询问</h5></div></div></div><p>查询用于规则中的基于模式的事实集。模式可以使用可选参数。可以在Knowlege Base中定义查询，从那里可以调用查询以返回匹配结果。在结果集合上进行迭代时，可以使用get（String identifier）方法访问查询中的任何绑定标识符，并且可以使用getFactHandle（String identifier）检索该标识符的任何FactHandle。</p><div class="figure"><a id="d0e1464"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/QueryResults.png" alt="查询结果"></div></div><p class="title"><b>图3.12。查询结果</b></p></div><br class="figure-break"><div class="figure"><a id="d0e1470"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/QueryResultsRow.png" alt="QueryResultsRow"></div></div><p class="title"><b>图3.13。QueryResultsRow</b></p></div><br class="figure-break"><div class="example"><a id="d0e1476"></a><p class="title"><b>示例3.26简单查询示例</b></p><div class="example-contents"><pre class="programlisting">QueryResults results =
    ksession.getQueryResults( "my query", new Object[] { "string" } );
for ( QueryResultsRow row : results ) {
    System.out.println( row.get( "varName" ) );
}</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1481"></a> 3.3.3.3。知识运行时</h4></div></div></div><p>的<code class="code">KnowledgeRuntime</code>提供适用于规则和过程的其他方法，例如设置全局变量和注册<code class="code">ExitPoints</code> 。</p><div class="figure"><a id="d0e1492"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntime.png" alt="知识运行时"></div></div><p class="title"><b>图3.14。知识运行时</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1498"></a> 3.3.3.3.1。全球</h5></div></div></div><p>全局变量是可以传递到规则引擎而无需插入它们的命名对象。通常，它们用于静态信息，或用于规则的RHS中的服务，或者可能用作从规则引擎返回对象的方法。如果在规则的LHS上使用全局，请确保它是不可变的。必须先在规则文件中声明全局变量，然后才能在会话上进行设置。</p><pre class="programlisting">global java.util.List list</pre><p>现在，知识库知道全局标识符及其类型，现在可以调用<code class="code">ksession.setGlobal()</code>对于任何会话。如果不首先声明全局类型和标识符，将导致引发异常。设置会话的全局使用<code class="code">ksession.setGlobal(identifier, value)</code> ：</p><pre class="programlisting">List list = new ArrayList();
ksession.setGlobal("list", list);           </pre><p>如果在设置前对全局规则求值，则会得到一个<code class="code">NullPointerException</code> 。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1520"></a> 3.3.3.4。StatefulRuleSession</h4></div></div></div><p>的<code class="code">StatefulRuleSession</code>是由<code class="code">StatefulKnowledgeSession</code>并提供与引擎外部相关的规则相关方法。</p><div class="figure"><a id="d0e1531"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/StatefulRuleSession.png" alt="StatefulRuleSession"></div></div><p class="title"><b>图3.15。StatefulRuleSession</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1537"></a> 3.3.3.4.1。议程过滤器</h5></div></div></div><div class="figure"><a id="d0e1540"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-User_Guide/AgendaFilter.png" align="middle" alt="议程过滤器"></div></div><p class="title"><b>图3.16。议程过滤器</b></p></div><br class="figure-break"><p><code class="code">AgendaFilter</code>对象是过滤器接口的可选实现，用于允许或拒绝激活触发。您过滤的内容完全取决于实现。Drools 4.0用于提供一些现成的过滤器，在Drools 5.0 drools-api中没有公开这些过滤器，但它们易于实现，可以参考Drools 4.0代码库。</p><p>要使用过滤器，请在调用时指定它<code class="code">fireAllRules()</code> 。以下示例仅允许以字符串结尾的规则<code class="code">"Test"</code> 。其他所有内容将被过滤掉。</p><pre class="programlisting">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1560"></a> 3.3.4。议程</h3></div></div></div><p>议程是一项<span class="emphasis"><em>Rete</em></span>功能。在行动期间<code class="code">WorkingMemory</code> ，规则可能会完全匹配并有资格执行；一个工作记忆操作可以产生多个合格规则。完全匹配规则后，将创建一个激活，将引用规则和匹配的事实，并将其放在议程中。议程使用冲突解决策略控制这些激活的执行顺序。</p><p>引擎反复循环经过两个阶段：</p><div class="orderedlist"><ol type="1"><li><p>工作记忆动作。这是大多数工作的结果，无论是结果（RHS本身）还是主要的Java应用程序过程。后果完成后或主要Java应用程序流程调用<code class="code">fireAllRules()</code>引擎将切换到“议程评估”阶段。</p></li><li><p>议程评估。这将尝试选择要触发的规则。如果未找到任何规则，则退出，否则将激发找到的规则，并将阶段切换回“工作内存操作”。</p></li></ol></div><div class="figure"><a id="d0e1583"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-Rule_Engine/Two_Phase.png" align="middle" width="100%" alt="两阶段执行"></td></tr></tbody></table></div></div><p class="title"><b>图3.17。两阶段执行</b></p></div><br class="figure-break"><p>重复该过程，直到清除议程为止，在这种情况下，控制权返回到调用应用程序。当进行“工作记忆操作”时，不会触发任何规则。</p><div class="figure"><a id="d0e1591"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/Agenda.png" alt="议程"></div></div><p class="title"><b>图3.18。议程</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1597"></a> 3.3.4.1。解决冲突</h4></div></div></div><p>当议程上有多个规则时，需要解决冲突。（有关基本知识，请参见“快速入门”一章。）由于触发规则可能会对工作内存产生副作用，因此规则引擎需要知道规则应按什么顺序触发（例如，触发规则A可能导致将规则B从议程中删除）。</p><p>Drools使用的默认冲突解决策略是：Salience和LIFO（后进先出）。</p><p>最明显的是<span class="emphasis"><em>显着性</em></span> （或优先级），在这种情况下，用户可以指定某个规则比其他规则具有更高的优先级（通过给其更高的编号）。在那种情况下，具有较高显着性的规则将是首选。LIFO优先级基于分配的“工作内存操作”计数器值，在同一操作期间创建的所有规则均接收相同的值。具有相同优先级值的一组触发的执行顺序是任意的。</p><p>作为一般规则，最好不要依赖以任何特定顺序触发的规则，并且在编写规则时不必担心“流程”。</p><p>Drools 4.0支持自定义冲突解决策略；尽管该功能在Drools中仍然存在，但尚未通过Drools 5.0中的drools-api向最终用户公开。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1613"></a> 3.3.4.2。议程集团</h4></div></div></div><div class="figure"><a id="d0e1616"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/AgendaGroup.png" alt="议程集团"></div></div><p class="title"><b>图3.19。议程集团</b></p></div><br class="figure-break"><p>议程组是划分议程上的规则（实际上是激活）的一种方法。在任何时候，只有一个组具有“焦点”，这意味着激活该组中的规则只会生效。您还可以使用带有“自动聚焦”的规则，这意味着当该规则的条件为真时，焦点将集中在其议程组中。</p><p>议程组在CLIPS术语中称为“模块”。它们提供了一种方便的方法来在分组规则之间创建“流程”。您可以从规则引擎内部或通过API切换具有焦点的组。如果您的规则明确需要处理的多个“阶段”或“顺序”，请考虑为此目的使用议程组。</p><p>每一次<code class="code">setFocus()</code>被称为将议程组推入堆栈。当焦点组为空时，将从堆栈中弹出焦点组，并评估现在位于顶部的焦点组。议程组可以出现在堆栈中的多个位置。默认的议程组是“ MAIN”，所有未指定议程组的规则都在该组中。在默认情况下，它始终始终是堆栈中的第一个组，最初会给予焦点。</p><pre class="programlisting">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1634"></a> 3.3.4.3。激活组</h4></div></div></div><div class="figure"><a id="d0e1637"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ActivationGroup.png" alt="激活组"></div></div><p class="title"><b>图3.20。激活组</b></p></div><br class="figure-break"><p>激活组是由相同的“激活组”规则属性绑定在一起的一组规则。在该组中，只有一个规则可以触发，并且在该规则触发后，所有其他规则都将从议程中删除。的<code class="code">clear()</code>可以随时调用方法，该方法会在有机会触发之前取消所有激活。
      </p><pre class="programlisting">ksession.getAgenda().getActivationGroup( "Group B" ).clear();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1650"></a> 3.3.4.4。RuleFlowGroup</h4></div></div></div><div class="figure"><a id="d0e1653"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/RuleFlowGroup.png" alt="RuleFlowGroup"></div></div><p class="title"><b>图3.21。RuleFlowGroup</b></p></div><br class="figure-break"><p>规则流组是由“ ruleflow-group”规则属性关联的一组规则。这些规则仅在激活该组后才能触发。仅当规则流图的详细说明到达代表该组的节点时，该组本身才能变为活动状态。在这里， <code class="code">clear()</code>可以随时调用方法取消仍保留在议程中的所有激活。
      </p><pre class="programlisting">ksession.getAgenda().getRuleFlowGroup( "Group C" ).clear();</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1666"></a> 3.3.5。事件模型</h3></div></div></div><p>事件包提供了用于通知规则引擎事件的方法，包括规则触发，声明的对象等。例如，这使您可以将日志记录和审核活动与应用程序的主要部分（以及规则）分开。</p><p>的<code class="code">KnowlegeRuntimeEventManager</code>接口由<code class="code">KnowledgeRuntime</code>它提供了两个接口， <code class="code">WorkingMemoryEventManager</code>和<code class="code">ProcessEventManager</code> 。我们将只涵盖<code class="code">WorkingMemoryEventManager</code>这里。</p><div class="figure"><a id="d0e1688"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntimeEventManager.png" alt="KnowledgeRuntimeEventManager"></div></div><p class="title"><b>图3.22。KnowledgeRuntimeEventManager</b></p></div><br class="figure-break"><p>的<code class="code">WorkingMemoryEventManager</code>允许添加和删除侦听器，以便可以侦听工作内存和议程的事件。</p><div class="figure"><a id="d0e1699"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/WorkingMemoryEventManager.png" width="100%" alt="WorkingMemoryEventManager"></td></tr></tbody></table></div></div><p class="title"><b>图3.23。WorkingMemoryEventManager</b></p></div><br class="figure-break"><p>以下代码段显示了如何声明简单的议程侦听器并将其附加到会话。激活后将打印激活。</p><div class="example"><a id="d0e1707"></a><p class="title"><b>示例3.27添加一个AgendaEventListener</b></p><div class="example-contents"><pre class="programlisting">ksession.addEventListener( new DefaultAgendaEventListener() {                            
   public void afterActivationFired(AfterActivationFiredEvent event) {
       super.afterActivationFired( event );
       System.out.println( event );
   }
});     </pre></div></div><br class="example-break"><p>流口水还提供<code class="code">DebugWorkingMemoryEventListener</code>和<code class="code">DebugAgendaEventListener</code>使用调试打印语句实现每种方法。要打印所有工作内存事件，请添加一个侦听器，如下所示：</p><div class="example"><a id="d0e1720"></a><p class="title"><b>示例3.28创建一个新的KnowledgeBuilder</b></p><div class="example-contents"><pre class="programlisting">ksession.addEventListener( new DebugWorkingMemoryEventListener() );     </pre></div></div><br class="example-break"><p>所有发出的事件都实现了<code class="code">KnowlegeRuntimeEvent</code>可以用来检索实际的接口<code class="code">KnowlegeRuntime</code>事件起源。</p><div class="figure"><a id="d0e1733"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/KnowledgeRuntimeEvent.png" alt="KnowlegeRuntimeEvent"></div></div><p class="title"><b>图3.24。KnowlegeRuntimeEvent</b></p></div><br class="figure-break"><p>当前支持的事件是：</p><div class="itemizedlist"><ul><li><p>ActivationCreatedEvent</p></li><li><p>ActivationCancelledEvent</p></li><li><p>BeforeActivationFiredEvent</p></li><li><p>AfterActivationFiredEvent</p></li><li><p>AgendaGroupPushedEvent</p></li><li><p>AgendaGroupPoppedEvent</p></li><li><p>ObjectInsertEvent</p></li><li><p>ObjectRetractedEvent</p></li><li><p>ObjectUpdatedEvent</p></li><li><p>ProcessCompletedEvent</p></li><li><p>ProcessNodeLeftEvent</p></li><li><p>ProcessNodeTriggeredEvent</p></li><li><p>ProcessStartEvent</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1781"></a> 3.3.6。KnowledgeRuntimeLogger</h3></div></div></div><p>KnowledgeRuntimeLogger使用Drools中的综合事件系统来创建审核日志，该日志可用于记录应用程序的执行情况，以供以后使用Eclipse审核查看器进行检查。</p><div class="figure"><a id="d0e1786"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/KnowledgeRuntimeLoggerFactory.png" width="100%" alt="KnowledgeRuntimeLoggerFactory"></td></tr></tbody></table></div></div><p class="title"><b>图3.25。KnowledgeRuntimeLoggerFactory</b></p></div><br class="figure-break"><div class="example"><a id="d0e1792"></a><p class="title"><b>示例3.29文件记录器</b></p><div class="example-contents"><pre class="programlisting">KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "logdir/mylogfile");
...
logger.close();</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1797"></a> 3.3.7。无状态知识会话</h3></div></div></div><p>的<code class="code">StatelessKnowledgeSession</code>包装<code class="code">StatefulKnowledgeSession</code> ，而不是扩展它。它的主要重点是决策服务类型方案。它避免了打电话的需要<code class="code">dispose()</code> 。无状态会话不支持迭代插入和方法调用<code class="code">fireAllRules()</code>来自Java代码；打电话的行为<code class="code">execute()</code>是单次使用的方法，将在内部实例化一个<code class="code">StatefulKnowledgeSession</code> ，添加所有用户数据并执行用户命令，然后调用<code class="code">fireAllRules()</code> ，然后致电<code class="code">dispose()</code> 。虽然使用此类的主要方法是通过<code class="code">BatchExecution</code> （的子接口<code class="code">Command</code> ）（由<code class="code">CommandExecutor</code>接口，当需要简单的对象插入时，提供了两种便捷的方法。的<code class="code">CommandExecutor</code>和<code class="code">BatchExecution</code>在各自的部分中进行了详细讨论。</p><div class="figure"><a id="d0e1841"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/StatelessKnowledgeSession.png" width="100%" alt="无状态知识会话"></td></tr></tbody></table></div></div><p class="title"><b>图3.26。无状态知识会话</b></p></div><br class="figure-break"><p>我们的简单示例显示了使用便捷API执行给定Java对象集合的无状态会话。它将迭代集合，依次插入每个元素。</p><div class="example"><a id="d0e1849"></a><p class="title"><b>示例3.30带有集合的简单StatelessKnowledgeSession执行</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newFileSystemResource( fileName ), ResourceType.DRL );
if (kbuilder.hasErrors() ) {
    System.out.println( kbuilder.getErrors() );
} else {
    KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
    kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
    StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
    ksession.execute( collection );
}</pre></div></div><br class="example-break"><p>如果将其作为单个命令完成，则将如下所示：</p><div class="example"><a id="d0e1856"></a><p class="title"><b>示例3.31使用InsertElements命令简单执行StatelessKnowledgeSession</b></p><div class="example-contents"><pre class="programlisting">ksession.execute( CommandFactory.newInsertElements( collection ) );  </pre></div></div><br class="example-break"><p>如果要插入集合本身以及集合的各个元素，则<code class="code">CommandFactory.newInsert(collection)</code>会做的工作。</p><p>方法<code class="code">CommandFactory</code>创建受支持的命令，所有命令都可以使用XStream和<code class="code">BatchExecutionHelper</code> 。<code class="code">BatchExecutionHelper</code>提供有关XML格式的详细信息，以及如何使用Drools Pipeline自动整理<code class="code">BatchExecution</code>和<code class="code">ExecutionResults</code> 。</p><p><code class="code">StatelessKnowledgeSession</code>支持全局变量，范围有很多种。我将首先介绍非命令方式，因为命令的作用域是特定的执行调用。全局变量可以通过三种方式解决。</p><div class="itemizedlist"><ul><li><p>无状态知识会话方法<code class="code">getGlobals()</code>返回一个Globals实例，该实例提供对会话的Globals的访问。这些将为<span class="emphasis"><em>所有</em></span>执行调用共享。请注意有关可变全局变量的注意事项，因为执行调用可以在不同线程中同时执行。</p><div class="example"><a id="d0e1897"></a><p class="title"><b>示例3.32全球范围的会议</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.  
ksession.execute( collection ); </pre></div></div><br class="example-break"></li><li><p>使用委托是全局解决的另一种方法。为全局值分配<code class="code">setGlobal(String, Object)</code> ）导致值存储在内部集合中，这些标识符将标识符映射到值。此内部集合中的标识符将优先于任何提供的委托。仅当在此内部集合中找不到标识符时，才使用全局委托（如果有）。</p></li><li><p>解决全局变量的第三种方法是使执行范围全局变量。在这里<code class="code">Command</code>设置全局传递给<code class="code">CommandExecutor</code> 。</p></li></ul></div><p>的<code class="code">CommandExecutor</code>界面还提供了通过“输出”参数导出数据的功能。插入的事实，全局变量和查询结果都可以返回。</p><div class="example"><a id="d0e1922"></a><p class="title"><b>示例3.33输出标识符</b></p><div class="example-contents"><pre class="programlisting">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1927"></a> 3.3.7.1。顺序模式</h4></div></div></div><p>使用Rete，您可以进行有状态的会话，可以随着时间的推移声明和修改对象，还可以添加和删除规则。现在，如果我们假设一个无状态会话会发生什么，在该会话中，在初始数据集之后不能再声明或修改任何数据，并且不能添加或删除规则了？当然，不必重新评估规则，并且引擎将能够以简化的方式运行。</p><div class="orderedlist"><ol type="1"><li><p>通过显着性和在规则集中的位置对规则进行排序（通过在规则终端节点上设置序列属性）。</p></li><li><p>创建一个数组，每个可能的规则激活都使用一个元素；元素位置指示点火顺序。</p></li><li><p>关闭所有节点存储器，右输入对象存储器除外。</p></li><li><p>断开左输入适配器节点的传播，并在命令对象中引用该对象和该节点，然后将其添加到工作内存上的列表中以供以后执行。</p></li><li><p>声明所有对象，并在完成所有断言并填充右输入节点存储器后，检查“命令”列表并依次执行每个命令。</p></li><li><p>根据确定的规则序号，所有产生的激活应放置在阵列中。记录第一个和最后一个填充的元素，以减小迭代范围。</p></li><li><p>迭代激活数组，依次执行填充的元素。</p></li><li><p>如果我们有最大数量的允许执行规则，则可以提早退出网络评估以触发阵列中的所有规则。</p></li></ol></div><p>的<code class="code">LeftInputAdapterNode</code>不再创建元组，添加对象，然后传播元组-而是创建一个Command对象并将其添加到工作内存中的列表中。该Command对象包含对<code class="code">LeftInputAdapterNode</code>和传播的对象。这会在插入时停止所有左输入传播，因此我们知道右输入传播将永远不需要尝试与左输入进行联接（无需使用左输入内存）。所有节点的内存都已关闭，包括左输入Tuple存储器，但右输入对象存储器除外，这意味着记住插入传播的唯一节点是右输入对象存储器。一旦所有的断言都完成并且所有的右输入存储器都被填充，我们就可以迭代列表。 <code class="code">LeftInputAdatperNode</code>命令对象依次调用每个对象。它们将在试图与右输入对象连接的网络中传播，但不会在左输入中被记住，因为我们知道不会再有其他对象断言，因此会传播到右输入存储器中。</p><p>不再有议程，有了优先队列来安排元组。相反，仅存在一个用于规则数量的数组。的序号<code class="code">RuleTerminalNode</code>表示数组中放置激活的元素。一旦所有Command对象完成，我们就可以迭代数组，依次检查每个元素，并触发激活（如果存在）。为了提高性能，我们记住数组中的第一个和最后一个填充的单元格。网络建设，每个<code class="code">RuleTerminalNode</code>根据显着性编号及其被添加到网络的顺序，被赋予序列号。</p><p>通常，右输入节点的内存是散列图，用于快速收回对象。在这里，我们知道不会有对象缩回，因此可以在未为对象的值建立索引时使用列表。对于更多的对象，使用索引的哈希图可以提高性能；如果我们知道一个对象类型只有几个实例，那么索引可能就没有优势，可以使用一个列表。</p><p>顺序模式只能与无状态会话一起使用，并且默认情况下处于关闭状态。要打开它，请致电<code class="code">RuleBaseConfiguration.setSequential(true)</code> ，或设置rulebase配置属性<code class="code">drools.sequential</code>真实。顺序模式可以通过调用<code class="code">setSequentialAgenda</code>与<code class="code">SequentialAgenda.DYNAMIC</code> 。您也可以将“ drools.sequential.agenda”属性设置为“ sequential”或“ dynamic”。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1992"></a> 3.3.8。管道</h3></div></div></div><p>的<code class="code">PipelineFactory</code>以及相关的类可以帮助自动化将信息进出Drools，特别是在使用诸如Java消息服务（JMS）和非Java对象的其他数据源之类的服务时。带有Smooks，JAXB，XStream和jXLS的变压器。Smooks是一个ETL（提取，转换，加载）工具，可以使用多种数据源。JAXB是用于XML绑定的Java标准，能够与XML模式一起使用。XStream是一个简单而快速的XML序列化框架。 jXLS最终允许从Excel电子表格中加载Java对象。这里将提供有关这些技术的最少信息。除此以外，您还应该参考有关每个工具的用户指南。</p><div class="figure"><a id="d0e2000"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/PipelineFactory.png" width="100%" alt="管道工厂"></td></tr></tbody></table></div></div><p class="title"><b>图3.27。管道工厂</b></p></div><br class="figure-break"><p>管道并不能替代功能更强大的Apache Camel之类的产品。这是一个针对特定Drools用例的简单框架。</p><p>在Drools中，管道是一系列阶段，它们在给定的有效载荷上进行操作并传播。通常，此操作以<code class="code">Pipeline</code>负责获取有效负载，创建一个<code class="code">PipelineContext</code>为此，并将其传播到接收器的第一阶段。的两个子类型<code class="code">Pipeline</code>提供，两者都要求不同<code class="code">PipelineContext</code> ： <code class="code">StatefulKnowledgeSessionPipeline</code>和<code class="code">StatelessKnowledgeSessionPipeline</code> 。
    <code class="code">PipelineFactory</code>提供创建两者的方法<code class="code">Pipeline</code>亚型。请注意，这两个工厂方法都将相关会话作为参数。建设一个<code class="code">StatefulKnowledgeSessionPipeline</code>如下所示，其中还设置了接收器。</p><div class="example"><a id="d0e2037"></a><p class="title"><b>示例3.34StatefulKnowledgeSessionPipeline</b></p><div class="example-contents"><pre class="programlisting">Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( receiver );</pre></div></div><br class="example-break"><p>然后，管道由一系列<code class="code">Stage</code>同时实现<code class="code">Emitter</code>和<code class="code">Receiver</code>接口。的<code class="code">Emitter</code>界面启用<code class="code">Stage</code>传播有效载荷，并且<code class="code">Receiver</code>接口使其可以接收有效载荷。这就是为什么<code class="code">Pipeline</code>接口仅实现<code class="code">Emitter</code>和<code class="code">Stage</code>并不是<code class="code">Receiver</code> ，因为它是链中的第一个实例。的<code class="code">Stage</code>接口允许在上设置自定义异常处理程序<code class="code">Stage</code>宾语。</p><div class="example"><a id="d0e2080"></a><p class="title"><b>示例3.35StageExceptionHandler</b></p><div class="example-contents"><pre class="programlisting">Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setStageExceptionHandler( new StageExceptionHandler() { .... } );
</pre></div></div><br class="example-break"><p>的<code class="code">Transformer</code>接口扩展<code class="code">Stage</code> ， <code class="code">Emitter</code>和<code class="code">Receiver</code> ，以单一类型提供这些接口方法。它的另一个目的是标记接口的目的，它指示实现类的特殊角色。（我们还有其他几个标记器接口，例如<code class="code">Expression</code>和<code class="code">Action</code> ，两者也都扩展了<code class="code">Stage</code> ， <code class="code">Emitter</code>和<code class="code">Receiver</code> ）其中一个阶段应负责在计算机上设置结果值<code class="code">PipelineContext</code> 。这是<code class="code">ResultHandler</code>由用户实现的界面，以处理这些结果。它可以通过将它们插入某个合适的对象中来实现，从而用户代码可以检索它们。</p><div class="example"><a id="d0e2120"></a><p class="title"><b>示例3.36StageExceptionHandler</b></p><div class="example-contents"><pre class="programlisting">ResultHandler resultHandler = new ResultHandlerImpl();
pipeline.insert( factHandle, resultHandler );  
System.out.println( resultHandler );
...
public class ResultHandlerImpl implements ResultHandler {
    Object result;

    public void handleResult(Object result) {
        this.result = result;
    }

    public Object getResult() {
        return this.result;
    }
}
</pre></div></div><br class="example-break"><p>尽管上面的示例显示了一个简单的处理程序，该处理程序仅将结果分配给用户可以访问的字段，但它可以执行更复杂的工作，例如将对象作为消息发送。</p><p>管道提供了一个适配器，用于插入有效负载并在内部创建正确的管道上下文。</p><p>通常，反向构造管道比较容易。在下面的示例中，XML数据从磁盘加载，用XStream转换，最后插入到会话中。</p><div class="example"><a id="d0e2131"></a><p class="title"><b>示例3.37建立管道</b></p><div class="example-contents"><pre class="programlisting">// Make the results (here: FactHandles) available to the user 
Action executeResultHandler = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session
// associated with the PipelineContext
KnowledgeRuntimeCommand insertStage =
  PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( executeResultHandler );
       
// Create the transformer instance and the Transformer Stage,
// to transform from Xml to a Java object.
XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setReceiver( insertStage );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( transformer );

// Instantiate a simple result handler and load and insert the XML
ResultHandlerImpl resultHandler = new ResultHandlerImpl();
pipeline.insert( ResourceFactory.newClassPathResource( "path/facts.xml", getClass() ),
                 resultHandler );
</pre></div></div><br class="example-break"><p>尽管上面的示例用于从磁盘加载资源，但是也可以从正在运行的消息传递服务中进行工作。Drools当前为JMS提供了一项单一服务，称为<code class="code">JmsMessenger</code> 。稍后将添加对其他服务的支持。以下代码显示了单元测试的一部分，该部分说明了<code class="code">JmsMessenger</code>实际上：</p><div class="example"><a id="d0e2144"></a><p class="title"><b>示例3.38将JMS与管道一起使用</b></p><div class="example-contents"><pre class="programlisting">// As this is a service, it's more likely that
// the results will be logged or sent as a return message.
Action resultHandlerStage = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session associated with the PipelineContext
KnowledgeRuntimeCommand insertStage = PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( resultHandlerStage );

// Create the transformer instance and create the Transformer stage where we are
// going from XML to Pojo. JAXB needs an array of the available classes.
JAXBContext jaxbCtx = KnowledgeBuilderHelper.newJAXBContext( classNames,
                                                              kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( insertStage );

// Payloads for JMS arrive in a Message wrapper: we need to unwrap this object.
Action unwrapObjectStage = PipelineFactory.newJmsUnwrapMessageObject();
unwrapObjectStage.setReceiver( transformer );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( unwrapObjectStage );

// Services, like JmsMessenger take a ResultHandlerFactory implementation.
// This is because a result handler must be created for each incoming message.
ResultHandlerFactory factory = new ResultHandlerFactoryImpl();
Service messenger = PipelineFactory.newJmsMessenger( pipeline,
                                                     props,
                                                     destinationName,
                                                     factory );
messenger.start();
</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2149"></a> 3.3.8.1。Xstream变形金刚</h4></div></div></div><div class="example"><a id="d0e2153"></a><p class="title"><b>示例3.39XStream FromXML转换器阶段</b></p><div class="example-contents"><pre class="programlisting">XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamFromXmlTransformer( xstream );
transformer.setReceiver( nextStage );</pre></div></div><p><br class="example-break"> </p><div class="example"><a id="d0e2159"></a><p class="title"><b>示例3.40XStream ToXML转换器阶段</b></p><div class="example-contents"><pre class="programlisting">XStream xstream = new XStream();
Transformer transformer = PipelineFactory.newXStreamToXmlTransformer( xstream );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2164"></a> 3.3.8.2。JAXB变压器</h4></div></div></div><p>变形金刚对象是<code class="code">JaxbFromXmlTransformer</code>和<code class="code">JaxbToXmlTransformer</code> 。前者使用<code class="code">javax.xml.bind.Unmarshaller</code>用于将XML文档转换为内容树；后者通过将内容树传递给XML，将内容树序列化为XML <code class="code">javax.xml.bind.Marshaller</code> 。这两个对象都可以从<code class="code">JAXBContext</code>宾语。</p><p>JAXBContext维护绑定到XML元素的Java类集。通过使用JAXB的模式编译器<span class="command"><strong>xjc</strong></span>进行编译，可以从XML模式生成此类。另外，手写类可以使用来自<code class="code">jaxb.xml.bind.annotation</code> 。</p><p>解组XML文档将生成对象树。可以通过遍历树并适当插入节点来将事实中的树中的对象作为事实插入会话中。这可以通过定制的Transformer在管道的上下文中完成，该Transformer将节点一个接一个地发送到其接收器。</p><div class="example"><a id="d0e2195"></a><p class="title"><b>示例3.41JAXB XSD生成到KnowlegeBuilder中</b></p><div class="example-contents"><pre class="programlisting">Options xjcOpts = new Options();
xjcOpts.setSchemaLanguage( Language.XMLSCHEMA );
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
 
String[] classNames =
  KnowledgeBuilderHelper.addXsdModel(
    ResourceFactory.newClassPathResource( "order.xsd", getClass() ),
    kbuilder,
    xjcOpts,
    "xsd" );</pre></div></div><p><br class="example-break"> </p><div class="example"><a id="d0e2201"></a><p class="title"><b>示例3.42从XML转换阶段开始的JAXB</b></p><div class="example-contents"><pre class="programlisting">JAXBContext jaxbCtx =
  KnowledgeBuilderHelper.newJAXBContext( classNames, kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( receiver );
 </pre></div></div><p><br class="example-break"> </p><div class="example"><a id="d0e2207"></a><p class="title"><b>示例3.43JAXB到XML转换阶段</b></p><div class="example-contents"><pre class="programlisting">Marshaller marshaller = jaxbCtx.createMarshaller();
Transformer transformer = PipelineFactory.newJaxbToXmlTransformer( marshaller );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2212"></a> 3.3.8.3。烟雾变压器</h4></div></div></div><div class="example"><a id="d0e2216"></a><p class="title"><b>示例3.44从Source变压器阶段冒烟</b></p><div class="example-contents"><pre class="programlisting">Smooks smooks = new Smooks( getClass().getResourceAsStream( "smooks-config.xml" ) );
Transformer transformer =
  PipelineFactory.newSmooksFromSourceTransformer( smooks, "orderItem" );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"> </p><div class="example"><a id="d0e2222"></a><p class="title"><b>示例3.45闻到ToSource变压器阶段</b></p><div class="example-contents"><pre class="programlisting">Smooks smooks = new Smooks( getClass().getResourceAsStream( "smooks-config.xml" ) );
Transformer transformer = PipelineFactory.newSmooksToSourceTransformer( smooks );
transformer.setReceiver( receiver );</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2227"></a> 3.3.8.4。 jXLS（Excel / Calc / CSV）变压器</h4></div></div></div><p>该转换器使用jXLS从Excel电子表格转换为Java对象的映射，并将所得的映射设置为传播对象。您可能需要使用拆分器和MVEL表达式来拆分转换，以插入单个Java对象。请注意，您必须提供一个XLSReader，它引用映射文件，还提供一个将实例化地图的MVEL字符串。MVEL表达式是预编译的，但会在每次转换时执行。</p><div class="example"><a id="d0e2232"></a><p class="title"><b>示例3.46JXLS变压器台</b></p><div class="example-contents"><pre class="programlisting">XLSReader mainReader =
  ReaderBuilder.buildFromXML( ResourceFactory.newClassPathResource( "departments.xml", getClass() ).getInputStream() );
String expr = "[ 'departments' : new java.util.ArrayList()," +
              "  'company' : new org.drools.runtime.pipeline.impl.Company() ]";
Transformer transformer = PipelineFactory.newJxlsTransformer(mainReader, expr );</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2237"></a> 3.3.8.5。JMS Messenger</h4></div></div></div><p>这个变压器创造了一个新的<code class="code">JmsMessenger</code>作为服务在其自己的线程中运行。它期望“ ConnectionFactory”的现有JNDI条目用于创建MessageConsumer，该条目将馈入指定的管道。</p><div class="example"><a id="d0e2245"></a><p class="title"><b>示例3.47JMS Messenger阶段</b></p><div class="example-contents"><pre class="programlisting">// As this is a service, it's more likely the results will be logged
// or sent as a return message.
Action resultHandlerStage = PipelineFactory.newExecuteResultHandler();

// Insert the transformed object into the session associated with the PipelineContext
KnowledgeRuntimeCommand insertStage = PipelineFactory.newStatefulKnowledgeSessionInsert();
insertStage.setReceiver( resultHandlerStage );

// Create the transformer instance and create the Transformer stage,
// where we are going from XML to Java object.
// JAXB needs an array of the available classes
JAXBContext jaxbCtx = KnowledgeBuilderHelper.newJAXBContext( classNames, kbase );
Unmarshaller unmarshaller = jaxbCtx.createUnmarshaller();
Transformer transformer = PipelineFactory.newJaxbFromXmlTransformer( unmarshaller );
transformer.setReceiver( insertStage );

// Payloads for JMS arrive in a Message wrapper, we need to unwrap this object.
Action unwrapObjectStage = PipelineFactory.newJmsUnwrapMessageObject();
unwrapObjectStage.setReceiver( transformer );

// Create the start adapter Pipeline for StatefulKnowledgeSessions
Pipeline pipeline = PipelineFactory.newStatefulKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( unwrapObjectStage );

// Services like JmsMessenger take a ResultHandlerFactory implementation.
// This is so because a result handler must be created for each incoming message.
ResultHandleFactoryImpl factory = new ResultHandleFactoryImpl();
Service messenger = PipelineFactory.newJmsMessenger( pipeline,
                                                     props,
                                                     destinationName,
                                                     factory );
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2250"></a> 3.3.9。命令和CommandExecutor</h3></div></div></div><p>Drools具有状态会话或无状态会话的概念。我们已经介绍了有状态会话，该会话使用标准的工作内存，该内存可以随着时间的推移进行迭代处理。无状态是具有提供的数据集的工作存储器的一次性执行。它可能会返回一些结果，而会话将被置于末尾，从而禁止进一步的迭代交互。您可以将无状态视为将规则引擎视为具有可选返回结果的函数调用。</p><p>在Drools 4中，我们支持这两种范例，但是用户与它们交互的方式是不同的。StatelessSession使用了execute（...）该方法将事实插入对象的集合。StatefulSession没有这种方法，而insert使用了更传统的方法<code class="code">insert(...)</code>方法。另一个问题是StatelessSession不返回任何结果，因此用户自己必须映射全局变量才能获得结果，并且除了插入对象外无法执行任何其他操作。用户无法启动流程或执行查询。</p><p>Drools 5.0解决了所有这些问题以及更多问题。其基础是<code class="code">CommandExecutor</code>接口，有状态接口和无状态接口都将其扩展，从而创建一致性和<code class="code">ExecutionResults</code> ：</p><div class="figure"><a id="d0e2268"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/CommandExecutor.png" alt="CommandExecutor"></div></div><p class="title"><b>图3.28。CommandExecutor</b></p></div><br class="figure-break"><div class="figure"><a id="d0e2274"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ExecutionResults.png" alt="执行结果"></div></div><p class="title"><b>图3.29。执行结果</b></p></div><br class="figure-break"><p>的<code class="code">CommandFactory</code>允许在这些会话上执行命令，唯一的区别是无状态知识会话执行<code class="code">fireAllRules()</code>最后，在安排会议之前。当前支持的命令是：</p><div class="itemizedlist"><ul><li><p>FireAllRules</p></li><li><p>GetGlobal</p></li><li><p>SetGlobal</p></li><li><p>插入对象</p></li><li><p>InsertElements</p></li><li><p>询问</p></li><li><p>启动过程</p></li><li><p>批处理</p></li></ul></div><p><code class="code">InsertObject</code>将插入一个带有可选“出”标识符的对象。 <code class="code">InsertElements</code>将迭代一个Iterable，插入每个元素。这意味着无状态知识会话不再仅限于插入对象，它现在可以启动进程或执行查询，并且可以按任何顺序执行。</p><div class="example"><a id="d0e2320"></a><p class="title"><b>示例3.48插入命令</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
ExecutionResults bresults =
  ksession.execute( CommandFactory.newInsert( new Cheese( "stilton" ), "stilton_id" ) );
Stilton stilton = bresults.getValue( "stilton_id" );
</pre></div></div><br class="example-break"><p>execute方法始终返回一个<code class="code">ExecutionResults</code>实例，如果它们指定了out标识符，例如上面的“ stilton_id”，则可以访问任何命令结果。</p><div class="example"><a id="d0e2330"></a><p class="title"><b>示例3.49InsertElements命令</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();
Command cmd = CommandFactory.newInsertElements( Arrays.asList( Object[] { 
                  new Cheese( "stilton" ),
                  new Cheese( "brie" ),
                  new Cheese( "cheddar" ),
              });
ExecutionResults bresults = ksession.execute( cmd );
</pre></div></div><br class="example-break"><p>execute方法仅允许单个命令。那边<code class="code">BatchExecution</code>进来，它表示从命令列表创建的复合命令。现在，execute将遍历列表并依次执行每个命令。这意味着您可以插入一个对象，启动一个流程，调用fireAllRules并执行一个查询<code class="code">execute(...)</code>通话，功能非常强大。</p><p>如前所述，无状态知识会议将执行<code class="code">fireAllRules()</code>自动结束。但是，敏锐的读者可能已经注意到<code class="code">FireAllRules</code>命令，并想知道如何与StatelessKnowledgeSession一起使用。的<code class="code">FireAllRules</code>命令是允许的，使用它会在最后禁用自动执行；考虑将其用作一种手动替代功能。</p><p>命令支持标识符。任何设置了out标识符的命令都将其结果添加到返回的ExecutionResults实例中。让我们看一个简单的例子，看看它是如何工作的。</p><div class="example"><a id="d0e2356"></a><p class="title"><b>示例3.50BatchExecution命令</b></p><div class="example-contents"><pre class="programlisting">StatelessKnowledgeSession ksession = kbase.newStatelessKnowledgeSession();

List cmds = new ArrayList();        
cmds.add( CommandFactory.newInsertObject( new Cheese( "stilton", 1), "stilton") );
cmds.add( CommandFactory.newStartProcess( "process cheeses" ) );
cmds.add( CommandFactory.newQuery( "cheeses" ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( "stilton" );
QueryResults qresults = ( QueryResults ) bresults.getValue( "cheeses" );
</pre></div></div><br class="example-break"><p>在上面的示例中，执行了多个命令，其中两个填充了<code class="code">ExecutionResults</code> 。默认情况下，查询命令使用与查询名称相同的标识符，但是也可以将其映射到其他标识符。</p><p>定制的XStream编组器可以与Drools Pipeline一起使用，以实现XML脚本编制，这对于服务是完美的。这是两个简单的XML示例，一个用于BatchExecution，另一个用于<code class="code">ExecutionResults</code> 。</p><div class="example"><a id="d0e2371"></a><p class="title"><b>示例3.51简单的BatchExecution XML</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert out-identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;price&gt;25&lt;/price&gt;
         &lt;oldPrice&gt;0&lt;/oldPrice&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><div class="example"><a id="d0e2376"></a><p class="title"><b>示例3.52简单的ExecutionResults XML</b></p><div class="example-contents"><pre class="programlisting">&lt;execution-results&gt;
   &lt;result identifier='outStilton'&gt;
      &lt;org.drools.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;oldPrice&gt;25&lt;/oldPrice&gt;        
         &lt;price&gt;30&lt;/price&gt;
      &lt;/org.drools.Cheese&gt;
   &lt;/result&gt;
&lt;/execution-results&gt;
</pre></div></div><br class="example-break"><p>前面提到的管道允许一系列Stage对象，这些对象组合在一起可以帮助将数据传入和传出会话。有一个阶段实施<code class="code">CommandExecutor</code>接口，允许管道对有状态或无状态会话进行脚本编写。管道设置很简单：</p><div class="example"><a id="d0e2386"></a><p class="title"><b>示例3.53CommandExecutor的管道</b></p><div class="example-contents"><pre class="programlisting">Action executeResultHandler = PipelineFactory.newExecuteResultHandler();

Action assignResult = PipelineFactory.newAssignObjectAsResult();
assignResult.setReceiver( executeResultHandler );

Transformer outTransformer =
  PipelineFactory.newXStreamToXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
outTransformer.setReceiver( assignResult );

KnowledgeRuntimeCommand cmdExecution = PipelineFactory.newCommandExecutor();
batchExecution.setReceiver( cmdExecution );

Transformer inTransformer =
  PipelineFactory.newXStreamFromXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
inTransformer.setReceiver( batchExecution );

Pipeline pipeline = PipelineFactory.newStatelessKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( inTransformer );
</pre></div></div><br class="example-break"><p>这里要注意的关键是使用<code class="code">BatchExecutionHelper</code>为具有特殊配置的XStream提供针对我们的Command对象和新对象的自定义转换器<code class="code">BatchExecutor</code>阶段。</p><p>使用管道非常简单。您必须提供自己的<code class="code">ResultHandler</code>当管道执行<code class="code">ExecuteResultHandler</code>阶段。</p><div class="figure"><a id="d0e2407"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-User_Guide/ResultHandler.png" alt="管道ResultHandler"></div></div><p class="title"><b>图3.30。管道ResultHandler</b></p></div><br class="figure-break"><div class="example"><a id="d0e2413"></a><p class="title"><b>示例3.54简单管道ResultHandler</b></p><div class="example-contents"><pre class="programlisting">public static class ResultHandlerImpl implements ResultHandler {
    Object object;

    public void handleResult(Object object) {
       this.object = object;
    }

    public Object getObject() {
        return this.object;
    }
}
</pre></div></div><br class="example-break"><div class="example"><a id="d0e2418"></a><p class="title"><b>示例3.55使用管道</b></p><div class="example-contents"><pre class="programlisting">
InputStream inXml = ...;
ResultHandler resultHandler = new ResultHandlerImpl();
pipeline.insert( inXml, resultHandler );
</pre></div></div><br class="example-break"><p>较早的<code class="code">BatchExecution</code>是使用Java创建的，用于插入一些对象并执行查询。该示例将与该管道一起使用的XML表示如下所示，并将参数添加到查询中。</p><div class="example"><a id="d0e2428"></a><p class="title"><b>示例3.56将BatchExecution编组为XML</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
  &lt;insert out-identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;1&lt;/price&gt;
      &lt;oldPrice&gt;0&lt;/oldPrice&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/insert&gt;
  &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
    &lt;string&gt;stilton&lt;/string&gt;
    &lt;string&gt;cheddar&lt;/string&gt;
  &lt;/query&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>的<code class="code">CommandExecutor</code>返回一个<code class="code">ExecutionResults</code> ，这也由管道代码段处理。<batch-execution>上面</batch-execution>的<batch-execution>XML示例的</batch-execution>类似输出为<batch-execution>：</batch-execution></p><div class="example"><a id="d0e2441"></a><p class="title"><b>示例3.57ExecutionResults编组到XML</b></p><div class="example-contents"><pre class="programlisting">&lt;execution-results&gt;
  &lt;result identifier="stilton"&gt;
    &lt;org.drools.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;2&lt;/price&gt;
    &lt;/org.drools.Cheese&gt;
  &lt;/result&gt;        
  &lt;result identifier='cheeses2'&gt;
    &lt;query-results&gt;
      &lt;identifiers&gt;
        &lt;identifier&gt;cheese&lt;/identifier&gt;
      &lt;/identifiers&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;2&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;org.drools.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;1&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.Cheese&gt;
      &lt;/row&gt;
    &lt;/query-results&gt;
  &lt;/result&gt;
&lt;/execution-results&gt;
</pre></div></div><br class="example-break"><p>的<code class="code">BatchExecutionHelper</code>提供了一个配置的XStream实例来支持批处理执行的封送处理，其中生成的XML可以用作消息格式，如上所示。配置的转换器仅适用于通过命令工厂支持的命令。用户可以为其用户对象添加其他转换器。这对于编写无状态或有状态知识会话的脚本非常有用，尤其是在涉及服务时。</p><p>当前没有支持架构验证的XML架构。此处概述了基本格式，并且drools-transformer-xstream模块在<code class="code">XStreamBatchExecutionTest</code>单元测试。根元素是<batch-execution>并且它可以包含零个或多个command元素。</batch-execution></p><div class="example"><a id="d0e2456"></a><p class="title"><b>示例3.58根XML元素</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
...
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>它包含代表命令的元素的列表，受支持的命令仅限于命令工厂提供的命令。其中最基本的是<insert>元素，它插入对象。插入元素的内容是用户对象，由XStream指示。</insert></p><div class="example"><a id="d0e2463"></a><p class="title"><b>示例3.59插入</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert&gt;
      ...&lt;!-- any user object --&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>insert元素具有“ out-identifier”属性，要求插入的对象也将作为结果有效内容的一部分返回。</p><div class="example"><a id="d0e2470"></a><p class="title"><b>示例3.60使用输出标识符命令插入</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert out-identifier='userVar'&gt;
      ...
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>也可以使用<insert-elements>元素插入对象的<insert-elements>集合。该命令不支持输出标识符。的<code class="code">org.domain.UserClass</code>只是XStream序列化的一个说明性用户对象。</insert-elements></insert-elements></p><div class="example"><a id="d0e2480"></a><p class="title"><b>示例3.61插入元素命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;insert-elements&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/insert-elements&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>接下来，有<code class="code"><set-global></code>元素，用于设置会话的全局值。</p><div class="example"><a id="d0e2490"></a><p class="title"><b>示例3.62插入元素命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p><code class="code"><set-global></code>还支持其他两个可选属性， <strong class="kw"><code>out</code></strong>和<strong class="kw"><code>out-identifier</code></strong> 。布尔值的真实值<strong class="kw"><code>out</code></strong>将全局添加到<code class="code"><batch-execution-results></code>有效负载，使用<strong class="kw"><code>identifier</code></strong>属性。 <strong class="kw"><code>out-identifier</code></strong>像<strong class="kw"><code>out</code></strong>但除此之外，您还可以覆盖在<code class="code"><batch-execution-results></code>有效载荷。</p><div class="example"><a id="d0e2523"></a><p class="title"><b>示例3.63设置全局命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;set-global identifier='userVar1' out='true'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
   &lt;set-global identifier='userVar2' out-identifier='alternativeUserVar2'&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/set-global&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>还有一个<code class="code"><get-global></code>元素，没有内容，只有一个<strong class="kw"><code>out-identifier</code></strong>属性。（不需要<strong class="kw"><code>out</code></strong>属性，因为获取值是唯一的目的<code class="code"><get-global></code>元件。</p><div class="example"><a id="d0e2542"></a><p class="title"><b>示例3.64获取全局命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;get-global identifier='userVar1' /&gt;
   &lt;get-global identifier='userVar2' out-identifier='alternativeUserVar2'/&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>而<strong class="kw"><code>out</code></strong>属性在返回特定实例作为结果有效负载时很有用，我们通常希望运行实际查询。支持参数查询和无参数查询。的<strong class="kw"><code>name</code></strong> attribute是要调用的查询的名称，并且<strong class="kw"><code>out-identifier</code></strong>是要用于查询结果的标识符<code class="code"><execution-results></code>有效载荷。</p><div class="example"><a id="d0e2561"></a><p class="title"><b>示例3.65查询命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;query out-identifier='cheeses' name='cheeses'/&gt;
   &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
      &lt;string&gt;stilton&lt;/string&gt;
      &lt;string&gt;cheddar&lt;/string&gt;
   &lt;/query&gt;
&lt;/batch-execution&gt;
</pre></div></div><br class="example-break"><p>的<code class="code"><start-process></code>命令接受可选参数。稍后将添加其他与过程相关的方法，例如与工作项进行交互。</p><div class="example"><a id="d0e2571"></a><p class="title"><b>示例3.66启动过程命令</b></p><div class="example-contents"><pre class="programlisting">&lt;batch-execution&gt;
   &lt;startProcess processId='org.drools.actions'&gt;
      &lt;parameter identifier='person'&gt;
         &lt;org.drools.TestVariable&gt;
            &lt;name&gt;John Doe&lt;/name&gt;
         &lt;/org.drools.TestVariable&gt;
      &lt;/parameter&gt;
   &lt;/startProcess&gt;
&lt;/batch-execution
</pre></div></div><br class="example-break"><div class="example"><a id="d0e2576"></a><p class="title"><b>示例3.67信号事件命令</b></p><div class="example-contents"><pre class="programlisting">&lt;signal-event process-instance-id='1' event-type='MyEvent'&gt;
   &lt;string&gt;MyValue&lt;/string&gt;
&lt;/signal-event&gt;
</pre></div></div><br class="example-break"><div class="example"><a id="d0e2581"></a><p class="title"><b>示例3.68完成工作项命令</b></p><div class="example-contents"><pre class="programlisting">&lt;complete-work-item id='" + workItem.getId() + "' &gt;
   &lt;result identifier='Result'&gt;
      &lt;string&gt;SomeOtherString&lt;/string&gt;
   &lt;/result&gt;
&lt;/complete-work-item&gt;
</pre></div></div><br class="example-break"><div class="example"><a id="d0e2586"></a><p class="title"><b>示例3.69中止工作项目命令</b></p><div class="example-contents"><pre class="programlisting">&lt;abort-work-item id='21' /&gt;
</pre></div></div><br class="example-break"><p>随着时间的推移，将增加对更多命令的支持。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2593"></a> 3.3.10。编组</h3></div></div></div><p>的<code class="code">MarshallerFactory</code>用于编组和取消编组状态知识会议。</p><div class="figure"><a id="d0e2601"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-User_Guide/MarshallerFactory.png" width="100%" alt="马歇尔工厂"></td></tr></tbody></table></div></div><p class="title"><b>图3.31。马歇尔工厂</b></p></div><br class="figure-break"><p>最简单的<code class="code">MarshallerFactory</code>可以如下使用：</p><div class="example"><a id="d0e2612"></a><p class="title"><b>示例3.70简单的Marshaller示例</b></p><div class="example-contents"><pre class="programlisting">// ksession is the StatefulKnowledgeSession
// kbase is the KnowledgeBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"><p>但是，通过编组，在处理引用的用户数据时需要更大的灵活性。为此，我们拥有<code class="code">ObjectMarshallingStrategy</code>接口。提供了两种实现，但用户可以实现自己的实现。提供的两种策略是<code class="code">IdentityMarshallingStrategy</code>和<code class="code">SerializeMarshallingStrategy</code> 。
    <code class="code">SerializeMarshallingStrategy</code>是上面示例中使用的默认设置，它只是调用<code class="code">Serializable</code>要么<code class="code">Externalizable</code>用户实例上的方法。
    <code class="code">IdentityMarshallingStrategy</code>而是为每个用户对象创建一个整数ID，并将其存储在Map中，同时将ID写入流中。当解组时，它访问<code class="code">IdentityMarshallingStrategy</code>映射以检索实例。这意味着如果您使用<code class="code">IdentityMarshallingStrategy</code> ，它在Marshaller实例的生命期内是有状态的，并将创建ID并保留对其尝试编组的所有对象的引用。以下是他使用身份编组策略的代码。</p><div class="example"><a id="d0e2646"></a><p class="title"><b>示例3.71身份编组策略</b></p><div class="example-contents"><pre class="programlisting">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategy oms = MarshallerFactory.newIdentityMarshallingStrategy()
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"><p>为了增加灵活性，我们不能认为单一策略是合适的。因此，我们添加了<code class="code">ObjectMarshallingStrategyAcceptor</code>每个对象编组策略所包含的接口。编组器具有一系列策略，当尝试读取或写入用户对象时，它将迭代这些策略，询问它们是否接受将用户对象编组的责任。提供的实现之一是<code class="code">ClassFilterAcceptor</code> 。这允许使用字符串和通配符来匹配类名。默认值为“ *。*”，因此在上面的示例中，使用的身份编组策略具有默认的“ *。*”接受器。</p><p>假设我们要序列化除一个给定包以外的所有类，在该包中将使用身份查找，我们可以执行以下操作：</p><div class="example"><a id="d0e2661"></a><p class="title"><b>示例3.72与接受者的身份编组策略</b></p><div class="example-contents"><pre class="programlisting">ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategyAcceptor identityAcceptor =
  MarshallerFactory.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStrategy =
  MarshallerFactory.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = MarshallerFactory.newSerializeMarshallingStrategy();
Marshaller marshaller =
  MarshallerFactory.newMarshaller( kbase,
                                   new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><br class="example-break"><p>请注意，验收检查顺序是所提供阵列的自然顺序。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2668"></a> 3.3.11。持久性和交易</h3></div></div></div><p>Drools可以实现Java Persistence API（JPA）的长期开箱即用的持久性。您将需要安装Java事务API（JTA）的某些实现。出于开发目的，我们建议您使用Bitronix事务管理器，因为它易于设置并且可以嵌入式工作，但建议在生产中使用JBoss Transactions。</p><div class="example"><a id="d0e2673"></a><p class="title"><b>示例3.73使用交易的简单示例</b></p><div class="example-contents"><pre class="programlisting">Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
         Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );
          
// KnowledgeSessionConfiguration may be null, and a default will be used
StatefulKnowledgeSession ksession =
  JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );
int sessionId = ksession.getId();
 
UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( "process1" );
ut.commit();
</pre></div></div><br class="example-break"><p>要使用JPA，必须同时设置环境<code class="code">EntityManagerFactory</code>和<code class="code">TransactionManager</code> 。如果发生回滚，则ksession状态也会回滚，因此您可以在回滚后继续使用它。要加载以前持久的状态知识会话，您将需要id，如下所示：</p><div class="example"><a id="d0e2686"></a><p class="title"><b>示例3.74加载一个StatefulKnowledgeSession</b></p><div class="example-contents"><pre class="programlisting">StatefulKnowledgeSession ksession =
  JPAKnowledgeService.loadStatefulKnowledgeSession( sessionId, kbase, null, env );
</pre></div></div><br class="example-break"><p>要启用持久性，必须将几个类添加到persistence.xml中，如下例所示：</p><div class="example"><a id="d0e2693"></a><p class="title"><b>示例3.75配置JPA</b></p><div class="example-contents"><pre class="programlisting">&lt;persistence-unit name="org.drools.persistence.jpa" transaction-type="JTA"&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;       
   &lt;class&gt;org.drools.persistence.session.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceEventInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.processinstance.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;            
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
         &lt;property name="hibernate.show_sql" value="true" /&gt;
         &lt;property name="hibernate.transaction.manager_lookup_class"
                      value="org.hibernate.transaction.BTMTransactionManagerLookup" /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</pre></div></div><br class="example-break"><p>必须首先配置jdbc JTA数据源。Bitronix提供了多种方法，有关详细信息，请查阅其文档。为了快速入门，以下是编程方法：</p><div class="example"><a id="d0e2700"></a><p class="title"><b>示例3.76配置JTA数据源</b></p><div class="example-contents"><pre class="programlisting">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( "jdbc/BitronixJTADataSource" );
ds.setClassName( "org.h2.jdbcx.JdbcDataSource" );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( "user", "sa" );
ds.getDriverProperties().put( "password", "sasa" );
ds.getDriverProperties().put( "URL", "jdbc:h2:mem:mydb" );
ds.init();
</pre></div></div><br class="example-break"><p>Bitronix还提供简单的嵌入式JNDI服务，非常适合测试。要使用它，请将jndi.properties文件添加到您的META-INF并向其中添加以下行：</p><div class="example"><a id="d0e2707"></a><p class="title"><b>示例3.77JNDI属性</b></p><div class="example-contents"><pre class="programlisting">java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</pre></div></div><br class="example-break"></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2712"></a>第四章规则语言</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2715">4.1。总览</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2723">4.1.1。规则文件</a></span></dt><dt><span class="section"><a href="#d0e2756">4.1.2。什么是规则</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2792">4.2。关键词</a></span></dt><dt><span class="section"><a href="#d0e3005">4.3。评论</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3010">4.3.1。单行注释</a></span></dt><dt><span class="section"><a href="#d0e3023">4.3.2。多行评论</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3036">4.4。错误讯息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3045">4.4.1。讯息格式</a></span></dt><dt><span class="section"><a href="#d0e3076">4.4.2。错误信息说明</a></span></dt><dt><span class="section"><a href="#d0e3231">4.4.3。其他讯息</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3236">4.5。包</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3259">4.5.1。进口</a></span></dt><dt><span class="section"><a href="#d0e3273">4.5.2。全球</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3316">4.6。功能</a></span></dt><dt><span class="section"><a href="#d0e3350">4.7。类型声明</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3378">4.7.1。声明新类型</a></span></dt><dt><span class="section"><a href="#d0e3500">4.7.2。声明元数据</a></span></dt><dt><span class="section"><a href="#d0e3571">4.7.3。声明现有类型的元数据</a></span></dt><dt><span class="section"><a href="#d0e3614">4.7.4。从应用程序代码访问声明的类型</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3663">4.8。规则</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3705">4.8.1。规则属性</a></span></dt><dt><span class="section"><a href="#RuleLanguage-ConditionalElements">4.8.2。左侧（当）条件元素</a></span></dt><dt><span class="section"><a href="#d0e5216">4.8.3。右侧（然后）</a></span></dt><dt><span class="section"><a href="#d0e5455">4.8.4。关于自动装箱和原始类型的注释</a></span></dt></dl></dd><dt><span class="section"><a href="#sec.query">4.9。询问</a></span></dt><dt><span class="section"><a href="#d0e5495">4.10。领域特定语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5506">4.10.1。何时使用DSL</a></span></dt><dt><span class="section"><a href="#d0e5515">4.10.2。编辑和管理DSL</a></span></dt><dt><span class="section"><a href="#d0e5569">4.10.3。在规则中使用DSL</a></span></dt><dt><span class="section"><a href="#d0e5595">4.10.4。给事实增加约束</a></span></dt><dt><span class="section"><a href="#d0e5628">4.10.5。怎么运行的</a></span></dt><dt><span class="section"><a href="#d0e5637">4.10.6。从头开始创建DSL</a></span></dt><dt><span class="section"><a href="#d0e5665">4.10.7。范围和关键字</a></span></dt><dt><span class="section"><a href="#d0e5670">4.10.8。BRMS和IDE中的DSL</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5679">4.11。XML规则语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5688">4.11.1。何时使用XML</a></span></dt><dt><span class="section"><a href="#d0e5699">4.11.2。XML格式</a></span></dt><dt><span class="section"><a href="#d0e5745">4.11.3。旧版Drools 2.x XML规则格式</a></span></dt><dt><span class="section"><a href="#d0e5750">4.11.4。在格式之间自动转换（XML和DRL）</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2715"></a> 4.1。总览</h2></div></div></div><p>Drools有一种“本机”规则语言。这种格式在标点符号方面非常轻巧，并且通过“扩展器”支持自然语言和特定于领域的语言，该扩展器允许该语言转变为您的问题领域。本章主要与本机规则格式配合使用。用于表示语法的图称为“铁路”图，它们基本上是语言术语的流程图。技术上非常热衷的人也可以指<code class="filename">DRL.g</code>这是规则语言的Antlr3语法。如果使用Rule Workbench，则可以在内容帮助下为您完成很多规则结构，例如，键入“ ru”并按ctrl + space，它将为您构建规则结构。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2723"></a> 4.1.1。规则文件</h3></div></div></div><p>规则文件通常是扩展名为.drl的文件。在DRL文件中，您可以具有多个规则，查询和函数，以及一些由规则和查询分配和使用的资源声明，例如导入，全局和属性。但是，您也可以将规则分布在多个规则文件中（在这种情况下，建议使用扩展名.rule，但不是必需的）-在文件中分布规则可以帮助管理大量规则。DRL文件只是一个文本文件。</p><p>规则文件的整体结构为：</p><div class="example"><a id="d0e2730"></a><p class="title"><b>示例4.1规则文件</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>package </strong></span><em class="replaceable"><code>package-name</code></em>

<em class="replaceable"><code>imports</code></em>

<em class="replaceable"><code>globals</code></em>

<em class="replaceable"><code>functions</code></em>

<em class="replaceable"><code>queries</code></em>

<em class="replaceable"><code>rules</code></em>
</pre></div></div><br class="example-break"><p>声明元素的顺序并不重要，但包名称必须声明为规则文件中的第一个元素，但包名称除外。所有元素都是可选的，因此您将仅使用所需的元素。我们将在以下各节中对它们进行讨论。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2756"></a> 4.1.2。什么是规则</h3></div></div></div><p>对于住院患者，就像早期的观点一样，规则具有以下大致结构：</p><pre class="programlisting"><span class="bold"><strong>rule</strong></span> <em class="replaceable"><code>"name"</code></em>
    <em class="replaceable"><code>attributes</code></em>
    <span class="bold"><strong>when</strong></span>
        <em class="replaceable"><code>LHS</code></em>
    <span class="bold"><strong>then</strong></span>
        <em class="replaceable"><code>RHS</code></em>
<span class="bold"><strong>end</strong></span>
</pre><p>真的就是这么简单。通常不需要标点符号，甚至“名称”的双引号和换行符都是可选的。属性是简单的（总是可选的）提示规则的行为。LHS是规则的条件部分，它遵循下面介绍的某些语法。RHS基本上是一个块，允许执行方言特定的语义代码。</p><p>重要的是要注意，空格并不重要， <span class="emphasis"><em>除非</em></span>是特定于领域的语言，其中一行一行地处理行，并且空格对于领域语言可能很重要。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2792"></a> 4.2。关键词</h2></div></div></div><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>
        <em class="replaceable"><code>(updated to Drools 5.0)</code></em>
      </p></div><p>Drools 5引入了<span class="emphasis"><em>硬</em></span>关键字和<span class="emphasis"><em>软</em></span>关键字的概念。</p><p>保留硬关键字，在命名规则文本中使用的域对象，属性，方法，函数和其他元素时，您不能使用任何硬关键字。</p><p>这是在编写规则时必须避免作为标识符的硬关键字的列表：</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>true</code></strong></p></li><li><p><strong class="kw"><code>false</code></strong></p></li><li><p><strong class="kw"><code>accumulate</code></strong></p></li><li><p><strong class="kw"><code>collect</code></strong></p></li><li><p><strong class="kw"><code>from</code></strong></p></li><li><p><strong class="kw"><code>null</code></strong></p></li><li><p><strong class="kw"><code>over</code></strong></p></li><li><p><strong class="kw"><code>then</code></strong></p></li><li><p><strong class="kw"><code>when</code></strong></p></li></ul></div><p>软关键字仅在其上下文中被识别，使您可以在任何其他需要的位置使用这些单词。这是软关键字的列表：</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>lock-on-active</code></strong></p></li><li><p><strong class="kw"><code>date-effective</code></strong></p></li><li><p><strong class="kw"><code>date-expires</code></strong></p></li><li><p><strong class="kw"><code>no-loop</code></strong></p></li><li><p><strong class="kw"><code>auto-focus</code></strong></p></li><li><p><strong class="kw"><code>activation-group</code></strong></p></li><li><p><strong class="kw"><code>agenda-group</code></strong></p></li><li><p><strong class="kw"><code>ruleflow-group</code></strong></p></li><li><p><strong class="kw"><code>entry-point</code></strong></p></li><li><p><strong class="kw"><code>duration</code></strong></p></li><li><p><strong class="kw"><code>package</code></strong></p></li><li><p><strong class="kw"><code>import</code></strong></p></li><li><p><strong class="kw"><code>dialect</code></strong></p></li><li><p><strong class="kw"><code>salience</code></strong></p></li><li><p><strong class="kw"><code>enabled</code></strong></p></li><li><p><strong class="kw"><code>attributes</code></strong></p></li><li><p><strong class="kw"><code>rule</code></strong></p></li><li><p><strong class="kw"><code>extend</code></strong></p></li><li><p><strong class="kw"><code>template</code></strong></p></li><li><p><strong class="kw"><code>query</code></strong></p></li><li><p><strong class="kw"><code>declare</code></strong></p></li><li><p><strong class="kw"><code>function</code></strong></p></li><li><p><strong class="kw"><code>global</code></strong></p></li><li><p><strong class="kw"><code>eval</code></strong></p></li><li><p><strong class="kw"><code>not</code></strong></p></li><li><p><strong class="kw"><code>in</code></strong></p></li><li><p><strong class="kw"><code>or</code></strong></p></li><li><p><strong class="kw"><code>and</code></strong></p></li><li><p><strong class="kw"><code>exists</code></strong></p></li><li><p><strong class="kw"><code>forall</code></strong></p></li><li><p><strong class="kw"><code>action</code></strong></p></li><li><p><strong class="kw"><code>reverse</code></strong></p></li><li><p><strong class="kw"><code>result</code></strong></p></li><li><p><strong class="kw"><code>end</code></strong></p></li><li><p><strong class="kw"><code>init</code></strong></p></li></ul></div><p>当然，在驼峰式的情况下，您可以将这些（硬性和软性）词作为方法名称的一部分，例如notSomething（）或accumulateSomething（）-这种情况没有问题。</p><p>DRL语言的另一个改进是可以在规则文本中转义硬关键字。此功能使您可以使用现有的域对象，而不必担心关键字冲突。要转义一个单词，只需用重音将其括起来，如下所示：</p><pre class="programlisting">Holiday( `when` == "july" )</pre><p>除在LHS或RHS代码块的代码表达式内外，在规则文本中的所有地方都应使用转义符。以下是正确用法的示例：</p><pre class="programlisting">rule "validate holiday by eval" 
dialect "mvel"
when
    h1 : Holiday( )
    eval( h1.when == "july" )
then
    System.out.println(h1.name + ":" + h1.when);
end
</pre><pre class="programlisting">rule "validate holiday" 
dialect "mvel"
when
    h1 : Holiday( `when` == "july" )
then
    System.out.println(h1.name + ":" + h1.when);
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3005"></a> 4.3。评论</h2></div></div></div><p>注释是规则引擎忽略的文本部分。遇到规则时，它们会被删除，除了内部语义代码块（如规则的RHS）外。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3010"></a> 4.3.1。单行注释</h3></div></div></div><div class="figure"><a id="d0e3013"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/single_line_comment.png" align="middle" alt="单行注释"></div></div><p class="title"><b>图4.1。单行注释</b></p></div><br class="figure-break"><p>要创建单行注释，可以使用“＃”或“ //”。解析器将忽略注释符号后一行中的任何内容。例：</p><pre class="programlisting">rule "Testing Comments"
when
    # this is a single line comment
    // this is also a single line comment
    eval( true ) # this is a comment in the same line of a pattern
then
    // this is a comment inside a semantic code block
    # this is another comment in a semantic code block
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3023"></a> 4.3.2。多行评论</h3></div></div></div><div class="figure"><a id="d0e3026"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/multi_line_comment.png" align="middle" alt="多行评论"></div></div><p class="title"><b>图4.2。多行评论</b></p></div><br class="figure-break"><p>多行注释用于在语义代码块内外注释文本块。例：</p><pre class="programlisting">rule "Test Multi-line Comments"
when
    /* this is a multi-line comment
       in the left hand side of a rule */
    eval( true )
then
    /* and this is a multi-line comment
       in the right hand side of a rule */
end </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3036"></a> 4.4。错误讯息</h2></div></div></div><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p><em class="replaceable"><code>(updated to Drools 5.0)</code></em></p></div><p>Drools 5引入了标准化的错误消息。该标准化旨在帮助用户以更轻松，更快捷的方式查找和解决问题。在本节中，您将学习如何识别和解释这些错误消息，并且还将获得有关如何解决与它们相关的问题的一些技巧。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3045"></a> 4.4.1。讯息格式</h3></div></div></div><p>标准化包括错误消息格式，为了更好地解释该格式，让我们使用以下示例：</p><div class="figure"><a id="d0e3050"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/error_message.png" align="middle" alt="错误讯息格式"></div></div><p class="title"><b>图4.3。错误讯息格式</b></p></div><br class="figure-break"><p><span class="bold"><strong>第一块：</strong></span>此区域标识错误代码。</p><p><span class="bold"><strong>第二块：</strong></span>行和列信息。</p><p><span class="bold"><strong>第三块：</strong></span>描述问题的一些文字。</p><p><span class="bold"><strong>第四区：</strong></span>这是第一个背景。通常指示发生错误的规则，函数，模板或查询。此块不是必需的。</p><p><span class="bold"><strong>第5块：</strong></span>标识发生错误的模式。此块不是必需的。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3076"></a> 4.4.2。错误信息说明</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3079"></a> 4.4.2.1。101：没有可行的选择</h4></div></div></div><p>指示最常见的错误，解析器到达决策点但无法识别替代项。这里有些例子：</p><div class="example"><a id="d0e3084"></a><p class="title"><b>示例4.2</b></p><div class="example-contents"><pre class="programlisting">1: rule one
2:   when
3:     exists Foo()
4:     <span class="bold"><strong>exits</strong></span> Bar()
5:   then
6: end
</pre></div></div><br class="example-break"><p>上面的示例生成此消息：</p><div class="itemizedlist"><ul><li><p>[ERR 101]第4：4行，规则一的输入“出口”没有可行的选择</p></li></ul></div><p>乍一看，这似乎是有效的语法，但事实并非如此（退出！=存在）。让我们看下一个例子：</p><div class="example"><a id="d0e3098"></a><p class="title"><b>示例4.3</b></p><div class="example-contents"><pre class="programlisting">1: package org.drools;
2: rule
3:   when
4:     Object()
5:   then
6:     System.out.println("A RHS");
7: end
</pre></div></div><br class="example-break"><p>现在，上面的代码生成此消息：</p><div class="itemizedlist"><ul><li><p>[ERR 101]第3：2行，输入“何时”没有其他选择</p></li></ul></div><p>该消息表示解析器遇到了令牌<span class="bold"><strong>WHEN</strong></span> ，实际上是一个硬关键字，但是由于缺少规则名称，因此它位于错误的位置。</p><p>当您犯一个简单的词汇错误时，也会出现错误“没有可行的选择”。这是一个词汇问题的示例：</p><div class="example"><a id="d0e3114"></a><p class="title"><b>示例4.4</b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     Student( name == "Andy )
4:   then
5: end
</pre></div></div><br class="example-break"><p>上面的代码未能关闭引号，因此解析器将生成以下错误消息：</p><div class="itemizedlist"><ul><li><p>[ERR 101]行0：-1 <eof>在模式Student中的规则simple_rule中的</eof>输入' <eof>'</eof>处没有可行的选择</p></li></ul></div><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>通常，“行”和“列”信息是准确的，但是在某些情况下（如未封闭的引号），解析器会生成0：-1位置。在这种情况下，您应该检查是否没有忘记关闭引号，撇号或括号。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3127"></a> 4.4.2.2。102：输入不匹配</h4></div></div></div><p>该错误表明解析器正在寻找一个未在当前输入位置找到的特定符号。以下是一些示例：</p><div class="example"><a id="d0e3132"></a><p class="title"><b>示例4.5</b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     foo3 : Bar(
</pre></div></div><br class="example-break"><p>上面的示例生成此消息：</p><div class="itemizedlist"><ul><li><p>[ERR 102]第0：-1 <eof>行在模式栏中的规则simple_rule中的</eof>输入' <eof>'期望'）'</eof>不匹配</p></li></ul></div><p>若要解决此问题，有必要完成规则语句。</p><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>通常，当您获得0：-1位置时，这意味着解析器到达了源的末尾。</p></div><p>以下代码生成多个错误消息：</p><div class="example"><a id="d0e3148"></a><p class="title"><b>示例4.6</b></p><div class="example-contents"><pre class="programlisting">1: package org.drools;
2:
3: rule "Avoid NPE on wrong syntax"
4:   when
5:     not( Cheese( ( type == "stilton", price == 10 ) || ( type == "brie", price == 15 ) ) from $cheeseList )
6:   then
7:     System.out.println("OK");
8: end
</pre></div></div><br class="example-break"><p>这些是与此来源相关的错误：</p><div class="itemizedlist"><ul><li><p>[ERR 102]第5:36行，奶酪中的规则“避免语法错误避免NPE”中的输入'，'期望为'）'不匹配</p></li><li><p>[ERR 101]行5:57在规则“避免错误语法的NPE”的输入“类型”上没有可行的选择</p></li><li><p>[ERR 102]行5：106输入'）'不匹配，期望规则“避免使用错误语法的NPE”中的“然后”</p></li></ul></div><p>请注意，第二个问题与第一个有关。要解决此问题，只需用AND运算符（'&&'）替换逗号（'，'）。</p><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>在某些情况下，您可以获得多个错误消息。尝试从第一个开始一个一个地修复。某些错误消息只是作为其他错误的结果而生成的。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3168"></a> 4.4.2.3。103：谓词失败</h4></div></div></div><p>验证语义谓词评估为false。通常，这些语义谓词用于识别软关键字。该示例准确显示了这种情况：</p><div class="example"><a id="d0e3173"></a><p class="title"><b>示例4.7</b></p><div class="example-contents"><pre class="programlisting"> 1: package nesting;
 2: dialect "mvel"
 3:
 4: import org.drools.Person
 5: import org.drools.Address
 6: 
 7: <span class="bold"><strong>fdsfdsfds</strong></span>
 8: 
 9: rule "test something"
10:   when
11:     p: Person( name=="Michael" )
12:   then
13:     p.name = "other";
14:     System.out.println(p.name);
15: end
</pre></div></div><br class="example-break"><p>通过此示例，我们得到以下错误消息：</p><div class="itemizedlist"><ul><li><p>[ERR 103]第7：0行规则'rule_key'的谓词失败：{（validateIdentifierKey（DroolsSoftKeywords。规则））}？在规则上</p></li></ul></div><p><span class="bold"><strong>fdsfdsfds</strong></span>文本无效，并且解析器无法将其识别为软关键字<strong class="kw"><code>rule</code></strong> 。</p><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>此错误非常类似于102：输入不匹配，但通常涉及软关键字。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3196"></a> 4.4.2.4。104：不允许使用尾部分号</h4></div></div></div><p>此错误与<strong class="kw"><code>eval</code></strong>子句，其表达式不能以分号结尾。检查以下示例：</p><div class="example"><a id="d0e3204"></a><p class="title"><b>示例4.8</b></p><div class="example-contents"><pre class="programlisting">1: rule simple_rule
2:   when
3:     eval(abc();)
4:   then
5: end
</pre></div></div><br class="example-break"><p>由于eval中的尾部分号，我们收到此错误消息：</p><div class="itemizedlist"><ul><li><p>[ERR 104]第3：4行，在规则simple_rule中不允许使用尾部分号</p></li></ul></div><p>这个问题很容易解决：只需删除分号即可。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3215"></a> 4.4.2.5。105：提早退出</h4></div></div></div><p>识别器出现在语法中的子规则中，该子规则必须至少匹配一个替代项，但是该子规则不匹配任何内容。简而言之：解析器已经进入了没有分支的分支。这个例子说明了这一点：</p><div class="example"><a id="d0e3220"></a><p class="title"><b>示例4.9</b></p><div class="example-contents"><pre class="programlisting">1: template test_error
2:   aa s  11;
3: end
</pre></div></div><br class="example-break"><p>这是与以上示例相关的消息：</p><div class="itemizedlist"><ul><li><p>[ERR 105]所需的行2：2（...）+循环与模板test_error中的输入'aa'上的任何内容都不匹配</p></li></ul></div><p>要解决此问题，必须删除数字值，因为它既不是有效的数据类型，它可能不会开始新的模板插槽，也不可能是任何其他规则文件构造的开始。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3231"></a> 4.4.3。其他讯息</h3></div></div></div><p>任何其他消息都意味着发生了不好的事情，因此请与开发团队联系。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3236"></a> 4.5。包</h2></div></div></div><p>包是规则和其他相关构造（例如，导入和全局）的集合。包成员通常彼此相关-例如，可能是HR规则。包代表一个命名空间，理想情况下，它对于给定的规则分组保持唯一。程序包名称本身就是名称空间，与文件或文件夹没有任何关系。</p><p>可以从多个规则源组合规则，并具有一个顶层程序包配置，所有规则都保留在该规则下（组合规则时）。但是，不可能合并到以不同名称声明的相同包资源中。但是，一个规则库可能包含基于其构建的多个程序包。一个通用的结构是将包的所有规则与包声明放在同一个文件中（这样就完全独立了）。</p><p>下图显示了组成包装的所有组件。请注意，程序包<span class="emphasis"><em>必须</em></span>具有名称空间，并使用标准Java约定来声明程序包名称。即，没有空格，与允许空格的规则名称不同。就元素的顺序而言，它们可以以任何顺序出现在规则文件中，但<strong class="kw"><code>package</code></strong>语句，该语句必须位于文件的顶部。在所有情况下，分号都是可选的。</p><div class="figure"><a id="d0e3251"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/package.png" align="middle" alt="包"></div></div><p class="title"><b>图4.4。包</b></p></div><br class="figure-break"><p>注意，任何规则属性（如“规则属性”一节中所述）也可以在包级别编写，以取代属性的默认值。修改后的默认值仍可以替换为规则中的属性设置。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3259"></a> 4.5.1。进口</h3></div></div></div><div class="figure"><a id="d0e3262"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Rule_Language/import.png" alt="进口"></div></div><p class="title"><b>图4.5。进口</b></p></div><br class="figure-break"><p>导入语句的工作方式类似于Java中的导入语句。您需要为要在规则中使用的任何对象指定完全限定的路径并键入名称。Drools会从同名的Java包以及包中自动导入类<code class="code">java.lang</code> 。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3273"></a> 4.5.2。全球</h3></div></div></div><div class="figure"><a id="d0e3276"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Rule_Language/global.png" alt="全球"></div></div><p class="title"><b>图4.6。全球</b></p></div><br class="figure-break"><p>用<strong class="kw"><code>global</code></strong>您定义全局变量。它们用于使应用程序对象可用于规则。通常，它们用于提供规则使用的数据或服务，尤其是用于规则结果的应用程序服务，并从规则返回数据，例如在规则结果中添加的日志或值，或用于与应用程序进行交互的规则，做回调。全局变量没有插入到工作存储器中，因此，除非具有恒定不变的值，否则永远不要使用全局变量在规则中建立条件。无法通知引擎有关全局变量值的更改，并且不跟踪其更改。在约束中错误使用全局变量可能会产生令人惊讶的结果-以一种不好的方式令人惊讶。</p><p>如果多个程序包使用相同的标识符声明全局变量，则它们必须具有相同的类型，并且它们都将引用相同的全局值。</p><p>为了使用全局变量，您必须：</p><div class="orderedlist"><ol type="1"><li><p>在规则文件中声明全局变量，然后在规则中使用它。例：</p><pre class="programlisting">global java.util.List myGlobalList;

rule "Using a global"
when
    eval( true )
then
    myGlobalList.add( "Hello World" );
end
</pre></li><li><p>在工作内存上设置全局值。最佳做法是在将任何事实断言到工作内存之前设置所有全局值。例：</p><pre class="programlisting">List list = new ArrayList();
WorkingMemory wm = rulebase.newStatefulSession();
wm.setGlobal( "myGlobalList", list );
</pre></li></ol></div><p>请注意，这些只是您从应用程序传递到工作内存的对象的命名实例。这意味着您可以传递任何想要的对象：您可以传递服务定位器，或者服务本身。随着新<strong class="kw"><code>from</code></strong>元素，现在通常将Hibernate会话作为全局传递，以允许<strong class="kw"><code>from</code></strong>从命名的Hibernate查询中提取数据。</p><p>一个示例可以是电子邮件服务的实例。在调用规则引擎的集成代码中，获取您的emailService对象，然后将其设置在工作内存中。在DRL中，您声明您具有类型为EmailService的全局变量，并将其命名为“ email”。然后，在规则后果中，您可以使用诸如email.sendSMS（number，message）之类的东西。</p><p>全局变量不是为了在规则之间共享数据而设计的，切勿将它们用于此目的。规则始终会推理并对工作内存状态做出反应，因此，如果要在规则之间传递数据，请将数据作为事实断言到工作内存中。</p><p>强烈建议您从规则内部设置或更改全局值。我们建议您始终使用工作内存接口从应用程序中设置值。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3316"></a> 4.6。功能</h2></div></div></div><div class="figure"><a id="d0e3319"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/function.png" align="middle" alt="功能"></div></div><p class="title"><b>图4.7。功能</b></p></div><br class="figure-break"><p>与普通的Java类相反，函数是一种将语义代码放入规则源文件中的方法。他们不能做的比您使用帮助程序类能做的更多。（实际上，编译器会在后台为您生成帮助器类。）在规则中使用函数的主要优点是可以将逻辑全都放在一个位置，并且可以根据需要更改函数（这可以是好事也可以是坏事）。函数对于对结果调用动作最有用（ <strong class="kw"><code>then</code></strong> ）作为规则的一部分，尤其是如果一遍又一遍地使用该特定操作时，也许每个规则的参数可能不同。</p><p>典型的函数声明如下：</p><pre class="programlisting">function String hello(String name) {
    return "Hello "+name+"!";
}
</pre><p>请注意<strong class="kw"><code>function</code></strong>使用了关键字，即使它不是Java的真正组成部分。函数的参数是为方法定义的，如果不需要，则不必具有参数。返回类型的定义与常规方法一样。</p><p>或者，您可以在帮助程序类中使用静态方法，例如， <code class="code">Foo.hello()</code> 。Drools支持使用函数导入，因此您所需要做的就是：</p><pre class="programlisting">import function my.package.Foo.hello</pre><p>无论定义或导入函数的方式如何，都可以通过在结果中或在语义代码块内按其名称调用函数来使用它。例：</p><pre class="programlisting">rule "using a static function"
when 
    eval( true )
then
    System.out.println( hello( "Bob" ) );
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3350"></a> 4.7。类型声明</h2></div></div></div><div class="figure"><a id="d0e3353"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/meta_data.png" align="middle" alt="meta_data"></div></div><p class="title"><b>图4.8。 meta_data</b></p></div><br class="figure-break"><div class="figure"><a id="d0e3359"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/type_declaration.png" align="middle" alt="type_declaration"></div></div><p class="title"><b>图4.9。 type_declaration</b></p></div><br class="figure-break"><p>类型声明在规则引擎中有两个主要目标：允许声明新类型，并允许声明类型的元数据。</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>声明新的类型：</strong></span> Drools开箱即用，将普通的Java对象作为事实。但是，有时，用户可能希望直接在规则引擎中定义模型，而不必担心使用Java之类的低级语言创建模型。在其他时候，已经建立了一个领域模型，但是最终用户希望或需要用主要在推理过程中使用的其他实体来补充该模型。</p></li><li><p><span class="bold"><strong>声明元数据：</strong></span>事实可能具有与之关联的元信息。元信息的示例包括事实属性未表示并且在该事实类型的所有实例之间一致的任何类型的数据。该元信息可以在运行时由引擎查询并在推理过程中使用。</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3378"></a> 4.7.1。声明新类型</h3></div></div></div><p>要声明一个新类型，您所要做的就是使用关键字<strong class="kw"><code>declare</code></strong> ，然后是字段列表和关键字<strong class="kw"><code>end</code></strong> 。</p><div class="example"><a id="d0e3389"></a><p class="title"><b>示例4.10声明新的事实类型：地址</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> Address
   number : int
   streetName : String
   city : String
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"><p>前面的示例声明了一个新的事实类型，称为<code class="code">Address</code> 。此事实类型将具有三个属性： <code class="code">number</code> ， <code class="code">streetName</code>和<code class="code">city</code> 。每个属性的类型都可以是任何有效的Java类型，包括用户创建的任何其他类，甚至是先前声明的其他事实类型。</p><p>例如，我们可能要声明另一个事实类型<code class="code">Person</code> ：</p><div class="example"><a id="d0e3419"></a><p class="title"><b>示例4.11声明新的事实类型：人员</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : java.util.Date
    address : Address
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break">如上例所示， <code class="code">dateOfBirth</code>是类型<code class="code">java.util.Date</code> ，来自Java API，而<code class="code">address</code>具有先前定义的事实类型地址。</p><p>您可以避免每次使用类编写全限定名时都必须使用<strong class="kw"><code>import</code></strong>如前所述。</p><div class="example"><a id="d0e3445"></a><p class="title"><b>示例4.12通过使用import避免使用完全限定的类名</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><p><br class="example-break"></p><p>当您声明新的事实类型时，Drools将在编译时生成字节代码，该字节代码实现表示该事实类型的Java类。生成的Java类将是类型定义的一对一Java Bean映射。因此，对于前面的示例，生成的Java类将是：</p><div class="example"><a id="d0e3460"></a><p class="title"><b>示例4.13为先前的Person事实类型声明生成Java类</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>public</strong></span> <span class="bold"><strong>class</strong></span> Person implements Serializable {
    <span class="bold"><strong>private</strong></span> String name;
    <span class="bold"><strong>private</strong></span> java.util.Date dateOfBirth;
    <span class="bold"><strong>private</strong></span> Address address;

    // getters and setters
    // equals/hashCode
    // toString
}
</pre></div></div><p><br class="example-break">由于生成的类是简单的Java类，因此可以像其他任何事实一样在规则中透明地使用它。</p><div class="example"><a id="d0e3481"></a><p class="title"><b>示例4.14在规则中使用声明的类型</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>rule</strong></span> "Using a declared Type"
<span class="bold"><strong>when</strong></span> 
    $p : Person( name == "Bob" )
<span class="bold"><strong>then</strong></span>
    <span class="emphasis"><em>// Insert Mark, who is Bob's mate.</em></span>
    Person mark = new Person();
    mark.setName("Mark");
    insert( mark );
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3500"></a> 4.7.2。声明元数据</h3></div></div></div><p>在Drools中，元数据可以分配给几种不同的构造：事实类型，事实属性和规则。Drools使用at符号（'@'）引入元数据，并且始终使用以下形式：</p><pre class="programlisting">@<span class="emphasis"><em>metadata_key</em></span>( <span class="emphasis"><em>metadata_value</em></span> )</pre><p>带括号的<span class="emphasis"><em>metadata_value</em></span>是可选的。</p><p>例如，如果您想声明一个元数据属性，例如<code class="code">author</code> ，其值为<span class="emphasis"><em>Bob</em></span> ，您可以简单地编写：</p><div class="example"><a id="d0e3526"></a><p class="title"><b>示例4.15声明元数据属性</b></p><div class="example-contents"><pre class="programlisting">@author( Bob )</pre></div></div><br class="example-break"><p>Drools允许声明任何任意的元数据属性，但是其中一些对引擎具有特殊的意义，而其他一些则可以在运行时查询。Drools允许为事实类型和事实属性声明元数据。在事实类型的字段之前声明的任何元数据都被分配给事实类型，而在属性之后声明的元数据则被分配给该特定属性。</p><div class="example"><a id="d0e3533"></a><p class="title"><b>示例4.16声明事实类型和属性的元数据属性</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )

    name : String <span class="emphasis"><em>@key @maxLength</em></span>( 30 )
    dateOfBirth : Date 
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"><p>在上一个示例中，为事实类型声明了两个元数据项（ <code class="code">@author</code>和<code class="code">@dateOfCreation</code> ），还为name属性定义了两个（ <code class="code">@key</code>和<code class="code">@maxLength</code> ）。请注意<code class="code">@key</code>元数据没有值，因此省略了括号和值。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3571"></a> 4.7.3。声明现有类型的元数据</h3></div></div></div><p>Drools允许以与声明新事实类型的元数据属性相同的方式声明现有类型的元数据属性。唯一的区别是该声明中没有字段。</p><p>例如，如果存在org.drools.examples类。人员，并且想要为其声明元数据，可以编写以下代码：</p><div class="example"><a id="d0e3578"></a><p class="title"><b>示例4.17声明现有类型的元数据</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> org.drools.examples.Person

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"><p>除了使用导入之外，还可以通过其完全限定的名称来引用该类，但是由于该类也将在规则中被引用，因此添加导入并在所有地方使用短类名通常会更短。</p><div class="example"><a id="d0e3599"></a><p class="title"><b>示例4.18使用完全限定的类名声明元数据</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> org.drools.examples.Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3614"></a> 4.7.4。从应用程序代码访问声明的类型</h3></div></div></div><p>声明的类型通常用于规则文件中，而Java模型则用于在规则和应用程序之间共享模型时使用。尽管有时应用程序可能需要访问和处理已声明类型的事实，尤其是当应用程序包装规则引擎并为规则管理提供更高级别的特定于域的用户界面时。</p><p>在这种情况下，可以使用Java Reflection API照常处理生成的类，但是，众所周知，通常需要大量工作才能获得较小的结果。因此，Drools为处理应用程序可能想要做的最常见的事实提供了简化的API。</p><p>首先要意识到的是，声明的事实将属于声明它的包。因此，例如，在下面的示例中， <code class="code">Person</code>将属于<code class="code">org.drools.examples</code>包，因此生成的类的完全限定名称为<code class="code">org.drools.examples.Person</code> 。</p><div class="example"><a id="d0e3632"></a><p class="title"><b>示例4.19在org.drools.examples包中声明类型</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>package</strong></span> org.drools.examples

<span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"><p>如前所述，声明的类型是在知识库编译时生成的，即，应用程序只能在应用程序运行时对其进行访问。因此，这些类不可用于直接从应用程序中引用。</p><p>然后Drools提供一个接口，用户可以通过该接口处理应用程序代码中声明的类型： <code class="code">org.drools.definition.type.FactType</code> 。通过此接口，用户可以实例化，读取和写入声明的事实类型的字段。</p><div class="example"><a id="d0e3654"></a><p class="title"><b>示例4.20通过API处理声明的事实类型</b></p><div class="example-contents"><pre class="programlisting">// get a reference to a knowledge base with a declared type:
KnowledgeBase kbase = ...

// get the declared FactType
FactType personType = kbase.getFactType( "org.drools.examples",
                                         "Person" );

// handle the type as necessary:
// create instances:
Object bob = personType.newInstance();

// set attributes values
personType.set( bob,
                "name",
                "Bob" );
personType.set( bob,
                "age",
                42 );

// insert fact into a session
StatefulKnowledgeSession ksession = ...
ksession.insert( bob );
ksession.fireAllRules();

// read attributes
String name = personType.get( bob, "name" );
int age = personType.get( bob, "age" );

</pre></div></div><br class="example-break"><p>该API还包括其他有用的方法，例如一次设置所有属性，从Map读取值或一次将所有属性读取到Map中。</p><p>尽管该API与Java反射类似（使用起来更简单），但它并没有在下面使用反射，而是依赖于在生成的字节码中实现的性能更高的访问器。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3663"></a> 4.8。规则</h2></div></div></div><div class="figure"><a id="d0e3666"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/rule.png" align="middle" alt="规则"></div></div><p class="title"><b>图4.10。规则</b></p></div><br class="figure-break"><p>一条规则指定， <span class="emphasis"><em>当</em></span>发生一组特定条件时（在左侧（LHS）中指定）， <span class="emphasis"><em>然后</em></span>执行在右侧（RHS）中指定为动作列表的操作。用户的一个常见问题是“为什么使用when而不是if？之所以选择“何时”而不是“如果”，是因为“如果”通常是过程执行流程的一部分，在此过程中，应在特定时间点检查条件。相反，“何时”表示状态评估与特定的评估顺序或时间点无关，而是在发动机使用寿命内的任何时间连续发生；只要满足条件，便会执行操作。</p><p>规则必须在其规则包中具有唯一的名称。如果您在同一DRL中两次定义规则，则在加载时会产生错误。如果添加的DRL中已包含软件包中已存在的规则名称，则它将替换先前的规则。如果规则名称要有空格，则需要将其括在双引号中（最好始终使用双引号）。</p><p>属性-如下所述-是可选的。最好每行写一篇。</p><p>该规则的LHS遵循<strong class="kw"><code>when</code></strong>关键字（最好在新行上），类似RHS遵循<strong class="kw"><code>then</code></strong>关键字（同样，最好在换行符上）。规则以关键字终止<strong class="kw"><code>end</code></strong> 。规则不能嵌套。</p><div class="example"><a id="d0e3695"></a><p class="title"><b>示例4.21。规则语法概述</b></p><div class="example-contents"><pre class="programlisting">rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"><div class="example"><a id="d0e3700"></a><p class="title"><b>示例4.22一个简单的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3705"></a> 4.8.1。规则属性</h3></div></div></div><p>规则属性提供了一种声明性的方式来影响规则的行为。有些非常简单，而另一些则是诸如规则流之类的复杂子系统的一部分。要充分利用Drools，您应该确保对每个属性都有正确的了解。</p><div class="figure"><a id="d0e3710"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/rule_attributes.png" align="middle" alt="规则属性"></div></div><p class="title"><b>图4.11。规则属性</b></p></div><br class="figure-break"><div class="variablelist"><dl><dt><span class="term"><strong class="kw"><code>no-loop</code></strong></span></dt><dd><p>默认值：false</p><p>类型：布尔型</p><p>当规则的结果修改了事实后，可能导致规则再次激活，从而导致递归。将no-loop设置为true意味着将忽略为当前数据集创建激活的尝试。</p></dd><dt><span class="term"><strong class="kw"><code>ruleflow-group</code></strong></span></dt><dd><p>默认值：不适用</p><p>类型：字符串</p><p>Ruleflow是Drools的一项功能，使您可以控制规则的触发。由相同的规则流组标识符组合的规则只有在其组处于活动状态时才会触发。</p></dd><dt><span class="term"><strong class="kw"><code>lock-on-active</code></strong></span></dt><dd><p>默认值：false</p><p>类型：布尔型</p><p>每当规则流组变为活动状态或议程组获得焦点时，该组中任何将活动锁定设置为true的规则将不再被激活；无论更新的起源如何，都将放弃激活匹配规则。这是无环的更强版本，因为现在更改不仅可以由规则本身引起。对于具有许多修改事实的规则并且您不希望任何规则重新匹配并再次触发的计算规则而言，它是理想的选择。只有当规则流组不再处于活动状态或议程组失去焦点时，那些将活动锁定设置为true的规则才有资格再次将其激活置于议程中。</p></dd><dt><span class="term"><strong class="kw"><code>salience</code></strong></span></dt><dd><p>默认值：0</p><p>类型：整数</p><p>每个规则都有一个显着性属性，可以为该属性分配一个整数，该整数默认为零，可以为负也可以为正。显着性是优先级的一种形式，在激活队列中对具有较高显着性值的规则进行排序时，将赋予它们较高的优先级。</p></dd><dt><span class="term"><strong class="kw"><code>agenda-group</code></strong></span></dt><dd><p>默认值：MAIN</p><p>类型：字符串</p><p>议程组允许用户对议程进行分区，以提供更多执行控制。只有议程组中已获得焦点的规则才可以执行。</p></dd><dt><span class="term"><strong class="kw"><code>auto-focus</code></strong></span></dt><dd><p>默认值：false</p><p>类型：布尔型</p><p>激活规则后， <code class="code">auto-focus</code>值是正确的并且规则的议程组还没有焦点，则将其赋予焦点，从而使规则有可能被触发。</p></dd><dt><span class="term"><strong class="kw"><code>activation-group</code></strong></span></dt><dd><p>默认值：不适用</p><p>类型：字符串</p><p>由该属性的字符串值标识的属于同一个激活组的规则将仅被触发。换句话说，要激活的激活组中的第一个规则将取消其他规则的激活，即停止激活它们。</p><p>注意：这以前称为Xor组，但从技术上讲，它不是Xor。您可能仍然听到有人提到Xor小组；只需将您的想法与激活组互换即可。</p></dd><dt><span class="term"><strong class="kw"><code>dialect</code></strong></span></dt><dd><p>默认值：由软件包指定</p><p>类型：字符串</p><p>可能的值：“ java”或“ mvel”</p><p>该方言在LHS或RHS代码块中的任何代码表达式中都使用了该语言。当前有两种方言，Java和MVEL。虽然可以在包级别指定方言，但此属性允许包定义被规则覆盖。</p></dd><dt><span class="term"><strong class="kw"><code>date-effective</code></strong></span></dt><dd><p>默认值：不适用</p><p>类型：字符串，包含日期和时间定义</p><p>仅当当前日期和时间在日期生效属性之后时，规则才能激活。</p></dd><dt><span class="term"><strong class="kw"><code>date-expires</code></strong></span></dt><dd><p>默认值：不适用</p><p>类型：字符串，包含日期和时间定义</p><p>如果当前日期和时间在date-expires属性之后，则无法激活规则。</p></dd><dt><span class="term"><strong class="kw"><code>duration</code></strong></span></dt><dd><p>默认值：无默认值</p><p>类型：长</p><p>持续时间表明规则将在指定的持续时间后继续触发（如果它仍然为真）。</p></dd></dl></div><div class="example"><a id="d0e3845"></a><p class="title"><b>示例4.23一些属性示例</b></p><div class="example-contents"><pre class="programlisting">rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="RuleLanguage-ConditionalElements"></a> 4.8.2。左侧（当）条件元素</h3></div></div></div><p>左侧（LHS）是规则条件部分的通用名称。它由零个或多个条件元素组成。如果LHS为空，则将其重写为<code class="code">eval(true)</code> ，这表示规则的条件始终为true。创建新的工作内存会话后，它将被激活一次。</p><div class="figure"><a id="d0e3858"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/lhs.png" align="middle" alt="左手边"></div></div><p class="title"><b>图4.12。左手边</b></p></div><br class="figure-break"><div class="example"><a id="d0e3864"></a><p class="title"><b>示例4.24没有条件元素的规则</b></p><div class="example-contents"><pre class="programlisting">rule "no CEs"
when
then
    &lt;action&gt;*
end

# The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"><p>条件元素适用于一种或多种<span class="emphasis"><em>模式</em></span> （如下所述）。最常见的是<strong class="kw"><code>and</code></strong> ，当规则的LHS中有多个未以任何方式连接的模式时，这是隐式的。请注意<strong class="kw"><code>and</code></strong>不能有像这样的前导声明绑定<strong class="kw"><code>or</code></strong> 。这很明显，因为声明只能引用单个事实，并且当<strong class="kw"><code>and</code></strong>是否满足于匹配多个事实-声明将绑定到哪个事实？</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3886"></a> 4.8.2.1。图案</h4></div></div></div><p>模式元素是最重要的条件元素。下面的实体关系图概述了组成模式约束的各个部分以及它们如何协同工作。然后用铁路图和示例更详细地介绍每一个。</p><div class="figure"><a id="d0e3891"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/patternER.png" align="middle" alt="模式实体关系图"></div></div><p class="title"><b>图4.13。模式实体关系图</b></p></div><br class="figure-break"><p>在ER图的顶部，您可以看到该模式由零个或多个约束组成，并且具有可选的模式绑定。下面的铁路图显示了此语法。</p><div class="figure"><a id="d0e3899"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/pattern.png" align="middle" alt="图案"></div></div><p class="title"><b>图4.14。图案</b></p></div><br class="figure-break"><p>在没有约束的最简单形式中，模式与给定类型的事实匹配。在以下情况下，类型为<code class="code">Cheese</code> ，这意味着该模式将与所有<code class="code">Cheese</code>工作存储器中的对象。</p><p>注意，类型不必是某个事实对象的实际类。模式可以引用超类甚至接口，从而可能匹配来自许多不同类的事实。</p><div class="example"><a id="d0e3915"></a><p class="title"><b>示例4.25简单模式</b></p><div class="example-contents"><pre class="programlisting">Cheese()</pre></div></div><br class="example-break"><p>要引用匹配的对象，请使用模式绑定变量，例如<code class="code">$c</code> 。带前缀的美元符号（'$'）是可选的；它在复杂的规则中很有用，它有助于更轻松地区分变量和字段。</p><div class="example"><a id="d0e3925"></a><p class="title"><b>示例4.26具有绑定变量的模式</b></p><div class="example-contents"><pre class="programlisting">$c : Cheese()</pre></div></div><br class="example-break"><p>模式括号内是所有动作发生的地方。约束可以是“字段约束”，“内联评估”或“约束组”。约束可以用以下符号分隔：“，”，“ &&”或“ ||”。</p><div class="figure"><a id="d0e3932"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraints.png" align="middle" alt="约束条件"></div></div><p class="title"><b>图4.15。约束条件</b></p></div><br class="figure-break"><div class="figure"><a id="d0e3938"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraint.png" align="middle" alt="约束"></div></div><p class="title"><b>图4.16。约束</b></p></div><br class="figure-break"><div class="figure"><a id="d0e3944"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/constraintGroup.png" align="middle" alt="约束组"></div></div><p class="title"><b>图4.17。约束组</b></p></div><br class="figure-break"><p>逗号字符（'，'）用于分隔约束组。它具有隐式和连接语义。</p><div class="example"><a id="d0e3952"></a><p class="title"><b>示例4.27约束组连接词“，”</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</pre></div></div><p><br class="example-break">上面的示例包含三个约束组，每个约束组都有一个约束：</p><div class="itemizedlist"><ul><li><p>第1组- <code class="code">type == "stilton"</code>要求类型为斯蒂尔顿。</p></li><li><p>第2组- <code class="code">price < 10</code>要求价格低于10。</p></li><li><p>第3组- <code class="code">age == "mature"</code>仅接受成熟的奶酪。</p></li></ul></div><p>“ &&”（和）和“ ||” （或）约束连接词允许约束组具有多个约束。例：</p><div class="example"><a id="d0e3979"></a><p class="title"><b>示例4.28 &&和||约束连接词</b></p><div class="example-contents"><pre class="programlisting">// Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" )
// Cheese type is "stilton" or price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" )</pre></div></div><br class="example-break"><p>上面的示例有两个约束组。第一个有两个约束，第二个有一个约束。</p><p>从头到尾按以下顺序评估连接词：</p><div class="orderedlist"><ol type="1"><li><p>&&</p></li><li><p>||</p></li><li><p>，</p></li></ol></div><p>与任何逻辑或数学表达式一样，可以通过使用括号来更改评估优先级。例：</p><div class="example"><a id="d0e4001"></a><p class="title"><b>示例4.29使用括号更改评估优先级</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </pre></div></div><p><br class="example-break">在上面的示例中，使用括号评估了连接词“ ||”连词“ &&”之前。</p><p>同样，重要的是要注意，除了具有相同的语义外，连接词“ &&”和“，”还具有不同的优先级，并且“，”不能嵌入复合约束表达式中。</p><div class="example"><a id="d0e4009"></a><p class="title"><b>示例4.30不等效的连接词</b></p><div class="example-contents"><pre class="programlisting">// invalid as ',' cannot be embedded in an expression:
Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" )
// valid as '&amp;&amp;' can be embedded in an expression:
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature")</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4014"></a> 4.8.2.1.1。场约束</h5></div></div></div><p>字段约束指定要在命名字段上使用的限制；字段名称可以具有可选的变量绑定。</p><div class="figure"><a id="d0e4019"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/fieldConstraint.png" align="middle" alt="fieldConstraint"></div></div><p class="title"><b>图4.18。 fieldConstraint</b></p></div><br class="figure-break"><p>有三种类型的限制：单值限制，复合值限制和多限制。</p><div class="figure"><a id="d0e4027"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/restriction.png" align="middle" alt="限制"></div></div><p class="title"><b>图4.19。限制</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4033"></a> 4.8.2.1.1.1。JavaBean作为事实</h6></div></div></div><p>字段是从对象的可访问方法派生的。如果您的模型对象遵循Java Bean模式，则使用“ getXXX”或“ isXXX”方法公开字段，这些方法不带任何参数并返回某些内容。在模式内，可以使用Bean命名约定来访问字段，以便将“ getType”作为“类型”进行访问。Drools使用标准的JDK Introspector类进行此映射。</p><p>例如，参考我们的奶酪类<code class="code">Cheese(type == "brie")</code>将getType（）方法应用于Cheese实例。如果找不到字段名称，则编译器将诉诸使用该名称作为不带参数的方法。因此，该方法<code class="code">toString()</code>由于约束而被调用<code class="code">Cheese(toString == "cheddar")</code> 。在这种情况下，请使用正确的大小写但不带括号的方法的全名。请确保您正在访问的方法没有参数，并且实际上是<span class="emphasis"><em>访问器</em></span> ，它们不会以可能影响规则的方式更改对象的状态。请记住，规则引擎在两次调用之间有效地缓存了其匹配的结果，以使其更快。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4052"></a> 4.8.2.1.1.2。价值观</h6></div></div></div><p>字段约束可以采用多个值。包括文字，qualifiedIdentifier（枚举），变量和returnValue。</p><div class="figure"><a id="d0e4057"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/literal.png" align="middle" alt="文字"></div></div><p class="title"><b>图4.20。文字</b></p></div><br class="figure-break"><div class="figure"><a id="d0e4063"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/qualifiedIdentifier.png" align="middle" alt="qualifiedIdentifier"></div></div><p class="title"><b>图4.21。 qualifiedIdentifier</b></p></div><br class="figure-break"><div class="figure"><a id="d0e4069"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/identifier.png" align="middle" alt="变量"></div></div><p class="title"><b>图4.22。变量</b></p></div><br class="figure-break"><div class="figure"><a id="d0e4075"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/returnValue.png" align="middle" alt="returnValue"></div></div><p class="title"><b>图4.23。 returnValue</b></p></div><br class="figure-break"><p>您可以使用'=='和'！来检查是否为空的字段。='和您预期的一样<strong class="kw"><code>null</code></strong>关键字，如<code class="code">Cheese(type != null)</code> ，其中值不为null时，评估程序将不会引发异常并返回true。如果字段和值的类型不同，则总是尝试强制类型转换。如果尝试强制强制，则会引发异常。例如，如果在数字求值器中以字符串形式提供“十”，则会引发异常，而“ 10”将强制为数字10。强制总是支持字段类型，而不是值类型。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4089"></a> 4.8.2.1.1.3。单一价值限制</h6></div></div></div><div class="figure"><a id="d0e4092"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/singleValueRestriction.png" align="middle" alt="singleValueRestriction"></div></div><p class="title"><b>图4.24。 singleValueRestriction</b></p></div><br class="figure-break"><p>单一值限制是一种二进制关系，将二进制运算符应用于字段值和另一个值，该值可以是文字，变量，带括号的表达式（“返回值”）或合格标识符（即枚举常量） 。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4100"></a> 4.8.2.1.1.3.1。经营者</h6></div></div></div><div class="figure"><a id="d0e4103"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/operator.png" align="middle" alt="经营者"></div></div><p class="title"><b>图4.25。经营者</b></p></div><br class="figure-break"><p>运算符'=='和'！='对所有类型均有效。只要对类型值进行排序，就可以使用其他关系运算符。对于日期字段，“ <”表示“之前”。这对<strong class="kw"><code>matches</code></strong>和<strong class="kw"><code>not matches</code></strong>仅适用于字符串字段， <strong class="kw"><code>contains</code></strong>和<strong class="kw"><code>not contains</code></strong>要求该字段具有某种“收集”类型。如“值”部分中所述，将尝试强制将值强制为评估器和字段的正确值。</p><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4123"></a>运营商<strong class="kw"><code>matches</code></strong></h6></div></div></div><p>将字段与任何有效的Java匹配<a id="d0e4130" class="indexterm"></a>正则表达式。通常，该regexp是字符串文字，但是也可以使用解析为有效regexp的变量。需要特别注意的是， <span class="emphasis"><em>与Java不同</em></span> ，在以字符串文字形式编写的正则表达式中， <span class="emphasis"><em>您无需转义'\'</em></span> 。例：</p><div class="example"><a id="d0e4140"></a><p class="title"><b>示例4.31正则表达式约束</b></p><div class="example-contents"><pre class="programlisting">Cheese( type matches "(Buffalo)?\S*Mozarella" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4145"></a>运营商<strong class="kw"><code>not matches</code></strong></h6></div></div></div><p>如果字符串与正则表达式不匹配，则运算符返回true。相同的规则适用于<strong class="kw"><code>matches</code></strong>操作员。例：</p><div class="example"><a id="d0e4155"></a><p class="title"><b>示例4.32正则表达式约束</b></p><div class="example-contents"><pre class="programlisting">Cheese( type not matches "(Buffulo)?\S*Mozarella" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4160"></a>运营商<strong class="kw"><code>contains</code></strong></h6></div></div></div><p>运营商<strong class="kw"><code>contains</code></strong>用于检查字段是否为<a id="d0e4170" class="indexterm"></a>集合或数组包含指定的值。</p><div class="example"><a id="d0e4174"></a><p class="title"><b>示例4.33包含收藏</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4179"></a>运营商<strong class="kw"><code>not contains</code></strong></h6></div></div></div><p>运营商<strong class="kw"><code>not contains</code></strong>用于检查字段是否为<a id="d0e4189" class="indexterm"></a>集合或数组<span class="emphasis"><em>不</em></span>包含指定的值。</p><div class="example"><a id="d0e4196"></a><p class="title"><b>示例4.34具有集合的文字约束</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</pre></div></div><br class="example-break"><div class="blockquote"><blockquote class="blockquote"><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>为了向后兼容， <strong class="kw"><code>excludes</code></strong>支持将运算符作为的同义词<strong class="kw"><code>not contains</code></strong> 。</p></div></blockquote></div></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4211"></a>运营商<strong class="kw"><code>memberOf</code></strong></h6></div></div></div><p>运营商<strong class="kw"><code>memberOf</code></strong>用于检查字段是否为集合或数组的成员；该集合必须是一个变量。</p><div class="example"><a id="d0e4221"></a><p class="title"><b>示例4.35具有集合的文字约束</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese memberOf $matureCheeses )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4226"></a>运营商<strong class="kw"><code>not memberOf</code></strong></h6></div></div></div><p>运营商<strong class="kw"><code>not memberOf</code></strong>用于检查字段是否不是集合或数组的成员；该集合必须是一个变量。</p><div class="example"><a id="d0e4236"></a><p class="title"><b>示例4.36具有集合的文字约束</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese not memberOf $matureCheeses )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4241"></a>运营商<strong class="kw"><code>soundslike</code></strong></h6></div></div></div><p>该运算符类似于<strong class="kw"><code>matches</code></strong> ，但它会检查一个单词的发音（使用英语发音）是否与给定值几乎相同。这基于Soundex算法（请参阅<code class="code">http://en.wikipedia.org/wiki/Soundex</code> ）。</p><div class="example"><a id="d0e4254"></a><p class="title"><b>示例4.37听起来像测试</b></p><div class="example-contents"><pre class="programlisting">// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4259"></a> 4.8.2.1.1.3.2。字面限制</h6></div></div></div><p>文字限制是限制的最简单形式，它根据指定的文字来评估字段，该文字可以是数字或日期，字符串或布尔值。</p><div class="figure"><a id="d0e4264"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/literalRestriction.png" align="middle" alt="文字限制"></div></div><p class="title"><b>图4.26。文字限制</b></p></div><br class="figure-break"><p>使用运算符'=='的文字限制提供了更快的执行速度，因为我们可以使用散列索引来提高性能。</p><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4272"></a>数字</h6></div></div></div><p>支持所有标准Java数字原语。</p><div class="example"><a id="d0e4277"></a><p class="title"><b>示例4.38数字文字限制</b></p><div class="example-contents"><pre class="programlisting">Cheese( quantity == 5 )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4282"></a>日期</h6></div></div></div><p>默认情况下支持日期格式“ dd-mmm-yyyy”。您可以通过提供备用日期格式掩码作为System属性命名来自定义此属性<code class="code">drools.dateformat</code> 。如果需要更多控制，请使用内联评估约束。</p><div class="example"><a id="d0e4290"></a><p class="title"><b>示例4.39日期文字限制</b></p><div class="example-contents"><pre class="programlisting">Cheese( bestBefore &lt; "27-Oct-2009" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4295"></a>串</h6></div></div></div><p>允许使用任何有效的Java字符串。</p><div class="example"><a id="d0e4300"></a><p class="title"><b>示例4.40字符串文字限制</b></p><div class="example-contents"><pre class="programlisting">Cheese( type == "stilton" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4305"></a>布尔型</h6></div></div></div><p>只要<code class="code">true</code>要么<code class="code">false</code>可以使用0和1是不可接受的。一个布尔字段（如<code class="code">Cheese( smelly )</code>不允许您必须将此与布尔文字进行比较。</p><div class="example"><a id="d0e4319"></a><p class="title"><b>示例4.41布尔文字限制</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == true )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4324"></a>合格标识符</h6></div></div></div><p>枚举也可以使用，同时支持JDK 1.4和5样式枚举。对于后者，您必须在JDK 5环境上执行。</p><div class="example"><a id="d0e4329"></a><p class="title"><b>示例4.42布尔文字限制</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == SomeClass.TRUE )</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4334"></a> 4.8.2.1.1.3.3。绑定变量限制</h6></div></div></div><div class="figure"><a id="d0e4337"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/variableRestriction.png" align="middle" alt="variableRestriction"></div></div><p class="title"><b>图4.27。 variableRestriction</b></p></div><br class="figure-break"><p>变量可以绑定到事实及其字段，然后在后续的字段约束中使用。绑定变量称为<a id="d0e4345" class="indexterm"></a>宣言。有效的运算符由要约束的字段的类型确定。在可能的情况下将尝试胁迫。使用运算符'=='的绑定变量限制提供了非常快的执行速度，因为我们可以使用哈希来提高性能。</p><div class="example"><a id="d0e4349"></a><p class="title"><b>示例4.43使用运算符'=='的绑定域</b></p><div class="example-contents"><pre class="programlisting">Person( likes : favouriteCheese )
Cheese( type == likes )</pre></div></div><br class="example-break"><p>这里， <code class="code">likes</code>是在其声明中绑定到字段的变量<code class="code">favouriteCheese</code>任何匹配的Person实例。然后将其用于按照以下模式限制奶酪的类型。可以使用任何有效的Java变量名称，并且可以在其前面加上“ $”前缀，您将经常看到该名称以帮助区分声明和字段。下面的示例显示了一个声明<code class="code">$stilton</code> ，绑定到与第一个模式匹配的对象，并与<code class="code">contains</code>操作员。 -注意“ $”的可选用法。</p><div class="example"><a id="d0e4368"></a><p class="title"><b>示例4.44使用“包含”运算符的约束事实</b></p><div class="example-contents"><pre class="programlisting">$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4373"></a> 4.8.2.1.1.3.4。返回值限制</h6></div></div></div><div class="figure"><a id="d0e4376"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/returnValueRestriction.png" align="middle" alt="returnValueRestriction"></div></div><p class="title"><b>图4.28。 returnValueRestriction</b></p></div><br class="figure-break"><p>一种<a id="d0e4384" class="indexterm"></a>返回值限制是一个带括号的表达式，由文字，任何有效的Java原语或对象，先前绑定的变量，函数调用和运算符组成。返回值中使用的函数必须返回不依赖时间的结果。</p><div class="example"><a id="d0e4388"></a><p class="title"><b>示例4.45返回值限制</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4393"></a> 4.8.2.1.1.4。复合价值限制</h6></div></div></div><p>复合值限制用于存在多个可能匹配的值的情况。目前只有<strong class="kw"><code>in</code></strong>和<strong class="kw"><code>not in</code></strong>评估人员对此表示支持。此运算符的第二个操作数必须是用逗号分隔的值列表，并用括号括起来。值可以作为变量，文字，返回值或合格标识符给出。这两个评估器实际上都是“语法糖”，使用运算符'！在内部重写为多个限制的列表。='和'=='。</p><div class="figure"><a id="d0e4404"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/compoundValueRestriction.png" align="middle" alt="复合值限制"></div></div><p class="title"><b>图4.29。复合值限制</b></p></div><br class="figure-break"><p></p><div class="example"><a id="d0e4411"></a><p class="title"><b>示例4.46复合限制使用“ in”</b></p><div class="example-contents"><pre class="programlisting">Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e4416"></a> 4.8.2.1.1.5。多重限制</h6></div></div></div><p>多重限制允许您使用限制连接词“ &&”或“ ||”在一个字段上放置多个限制。允许通过括号分组，从而产生递归语法模式。</p><div class="figure"><a id="d0e4421"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/multiRestriction.png" align="middle" alt="多重限制"></div></div><p class="title"><b>图4.30。多重限制</b></p></div><br class="figure-break"><div class="figure"><a id="d0e4427"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/restrictionGroup.png" align="middle" alt="限制集团"></div></div><p class="title"><b>图4.31。限制集团</b></p></div><br class="figure-break"><p></p><div class="example"><a id="d0e4434"></a><p class="title"><b>示例4.47多重限制</b></p><div class="example-contents"><pre class="programlisting">// Simple multi restriction using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )
// Complex multi restriction using groupings of multi restrictions
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )
// Mixing muti restrictions with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4439"></a> 4.8.2.1.2。内联评估约束</h5></div></div></div><div class="figure"><a id="d0e4442"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/inlineEvalConstraint.png" align="middle" alt="内联评估表达式"></div></div><p class="title"><b>图4.32。内联评估表达式</b></p></div><br class="figure-break"><p>一个<a id="d0e4450" class="indexterm"></a>内联eval约束可以使用任何有效的方言表达式，只要其结果是原始布尔值即可。该表达式必须随时间恒定。可以使用来自当前或先前模式的任何先前绑定的变量； autovivification也用于自动创建字段绑定变量。当找到不是当前变量的标识符时，构建器将查看该标识符是否是当前对象类型上的字段，如果是，则字段绑定将自动创建为同名变量。这称为内联评估中字段变量的自动生存。</p><p>此示例将查找所有男性-女性对，其中男性比女性大2岁；变量<code class="code">age</code>通过自动生存过程以第二种模式自动创建。</p><div class="example"><a id="d0e4459"></a><p class="title"><b>示例4.48返回值运算符</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' )
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4464"></a> 4.8.2.1.3。嵌套访问器</h5></div></div></div><p>Drools使用MVEL访问器图符号在字段约束中允许<span class="emphasis"><em>嵌套访问</em></span>器。实际上，涉及嵌套访问器的字段约束将重新编写为MVEL方言内联评估。使用嵌套访问器时应格外小心，因为工作内存不知道任何嵌套值，也不知道它们何时更改；当它们的任何父引用插入工作存储器时，它们应被视为不可变的。如果要修改嵌套值，则应先删除父对象，然后再重新声明。如果在图的根部只有一个父级，则使用MVEL方言时，可以使用<strong class="kw"><code>modify</code></strong>构造及其块设置程序，以便在根据需要撤回和插入根父对象时编写嵌套的访问器分配。嵌套访问器可以在运算符符号的任一侧使用。</p><div class="example"><a id="d0e4475"></a><p class="title"><b>示例4.49嵌套访问器</b></p><div class="example-contents"><pre class="programlisting">// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age )</pre><p>这在内部被重写为MVEL内联评估：</p><pre class="programlisting">// Find a pet older than its owners first-born child
$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) </pre></div></div><br class="example-break"><p class="remark"><i><span class="remark"><span class="bold"><strong>注意：</strong></span>嵌套访问器的性能成本要比直接字段访问高得多，因此请谨慎使用它们。</span></i></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4488"></a> 4.8.2.2。条件元素<strong class="kw"><code>and</code></strong></h4></div></div></div><p>条件元素<strong class="kw"><code>and</code></strong>用于将其他条件元素分组为逻辑合取。LHS的根元素是隐式前缀<strong class="kw"><code>and</code></strong>无需指定。Drools支持两个前缀<strong class="kw"><code>and</code></strong>和中缀<strong class="kw"><code>and</code></strong> ，但前缀是首选选项，因为其隐式分组可避免混淆。</p><div class="figure"><a id="d0e4507"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/prefixAnd.png" align="middle" alt="prefixAnd"></div></div><p class="title"><b>图4.33。 prefixAnd</b></p></div><br class="figure-break"><p></p><div class="example"><a id="d0e4514"></a><p class="title"><b>示例4.50 prefixAnd</b></p><div class="example-contents"><pre class="programlisting">(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</pre></div></div><br class="example-break"><div class="example"><a id="d0e4519"></a><p class="title"><b>示例4.51隐式根前缀And</b></p><div class="example-contents"><pre class="programlisting">when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</pre></div></div><br class="example-break"><p>中缀<strong class="kw"><code>and</code></strong>如果需要，还可以使用括号将其与显式分组一起支持。符号“ &&”，替代<strong class="kw"><code>and</code></strong>不推荐使用，尽管出于传统支持的原因在语法中仍然支持。</p><div class="figure"><a id="d0e4532"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/infixAnd.png" align="middle" alt="infixAnd"></div></div><p class="title"><b>图4.34。 infixAnd</b></p></div><br class="figure-break"><div class="example"><a id="d0e4538"></a><p class="title"><b>示例4.52 infixAnd</b></p><div class="example-contents"><pre class="programlisting">//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )
//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4543"></a> 4.8.2.3。条件元素<strong class="kw"><code>or</code></strong></h4></div></div></div><p>条件元素<strong class="kw"><code>or</code></strong>用于将其他条件元素分组为逻辑分离。Drools支持两个前缀<strong class="kw"><code>or</code></strong>和中缀<strong class="kw"><code>or</code></strong> ，但前缀是首选选项，因为其隐式分组可避免混淆。条件元素的行为<strong class="kw"><code>or</code></strong>与连词“ ||”不同对于约束和字段约束的约束。引擎实际上不了解条件元素<strong class="kw"><code>or</code></strong> ;相反，通过许多不同的逻辑转换， <strong class="kw"><code>or</code></strong>被重写为许多子规则。此过程最终导致一条规则具有单个<strong class="kw"><code>or</code></strong>作为其每个CE的根节点和一个子规则。每个子规则都可以像任何正常规则一样激活和触发；这些子规则之间没有特殊的行为或相互作用。 -这可能会使新规则作者感到困惑。</p><div class="figure"><a id="d0e4571"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/prefixOr.png" align="middle" alt="prefixOr"></div></div><p class="title"><b>图4.35。 prefixOr</b></p></div><br class="figure-break"><div class="example"><a id="d0e4577"></a><p class="title"><b>示例4.53 prefixOr</b></p><div class="example-contents"><pre class="programlisting">(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</pre></div></div><br class="example-break"><p>中缀<strong class="kw"><code>or</code></strong>如果需要，还可以使用括号将其与显式分组一起支持。符号“ ||”，替代<strong class="kw"><code>or</code></strong>不推荐使用，尽管出于传统支持的原因在语法中仍然支持。</p><div class="figure"><a id="d0e4590"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/infixOr.png" align="middle" alt="infixOr"></div></div><p class="title"><b>图4.36。 infixOr</b></p></div><br class="figure-break"><div class="example"><a id="d0e4596"></a><p class="title"><b>示例4.54 infixOr</b></p><div class="example-contents"><pre class="programlisting">//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )
//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</pre></div></div><br class="example-break"><p>条件元素<strong class="kw"><code>or</code></strong>还允许可选的模式绑定。这意味着每个结果子规则会将其模式绑定到模式绑定。每个模式必须使用同义变量分别绑定：</p><div class="example"><a id="d0e4606"></a><p class="title"><b>示例4.55或绑定</b></p><div class="example-contents"><pre class="programlisting">(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</pre></div></div><br class="example-break"><p>由于条件元素<strong class="kw"><code>or</code></strong>结果产生多个子规则，每个可能的逻辑结果一个，上面的示例将内部产生两个规则。这两个规则在工作记忆中独立工作，这意味着它们都可以匹配，激活和触发-没有捷径。</p><p>考虑条件要素的最佳方法<strong class="kw"><code>or</code></strong>是生成两个或更多相似规则的捷径。当您以这种方式考虑时，很明显，如果两个或多个析取项为真，则对于单个规则可能会有多个激活。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4621"></a> 4.8.2.4。条件元素<strong class="kw"><code>eval</code></strong></h4></div></div></div><div class="figure"><a id="d0e4626"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/eval.png" align="middle" alt="评估"></div></div><p class="title"><b>图4.37。评估</b></p></div><br class="figure-break"><p>行政长官<strong class="kw"><code>eval</code></strong>本质上是一个包罗万象的东西，它允许执行任何语义代码（返回原始布尔值）。该代码可以引用规则的LHS中绑定的变量，以及规则包中的函数。过度使用eval会降低规则的声明性，并可能导致引擎性能下降。而<strong class="kw"><code>eval</code></strong>可以在模式的任何地方使用，最佳实践是将其添加为规则的LHS中的最后一个条件元素。</p><p>评估无法建立索引，因此效率不如字段约束。但是，这使它们成为函数返回随时间变化的值（字段约束中不允许使用）的理想选择。</p><p>对于熟悉Drools 2.x世系的人们，旧的Drools参数和条件标记等效于将变量绑定到适当的类型，然后在eval节点中使用它。</p><div class="example"><a id="d0e4644"></a><p class="title"><b>示例4.56评估</b></p><div class="example-contents"><pre class="programlisting">p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
// call function isValid in the LHS
eval( isValid(p1, p2) )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4649"></a> 4.8.2.5。条件元素<strong class="kw"><code>not</code></strong></h4></div></div></div><div class="figure"><a id="d0e4654"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/not.png" align="middle" alt="不"></div></div><p class="title"><b>图4.38。不</b></p></div><br class="figure-break"><p>行政长官<strong class="kw"><code>not</code></strong>是一阶逻辑的不存在量词，用于检查工作内存中是否存在某物。将“ not”理解为“必须不存在...”。</p><p>关键字<strong class="kw"><code>not</code></strong>后面加上适用于CE的括号。在单个模式的最简单情况下（如下所示），您可以选择省略括号。</p><div class="example"><a id="d0e4670"></a><p class="title"><b>示例4.57没有巴士</b></p><div class="example-contents"><pre class="programlisting">not Bus()</pre></div></div><br class="example-break"><div class="example"><a id="d0e4675"></a><p class="title"><b>示例4.58没有红色巴士</b></p><div class="example-contents"><pre class="programlisting">// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <strong class="kw"><code>and</code></strong> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4683"></a> 4.8.2.6。条件元素<strong class="kw"><code>exists</code></strong></h4></div></div></div><div class="figure"><a id="d0e4688"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/exists.png" align="middle" alt="存在"></div></div><p class="title"><b>图4.39。存在</b></p></div><br class="figure-break"><p>行政长官<strong class="kw"><code>exists</code></strong>是一阶逻辑的存在量词，用于检查工作内存中是否存在某些内容。认为“存在”是指“至少有一个..”。它与仅拥有模式不同，后者更像是说“针对……中的每一个”。如果您使用<strong class="kw"><code>exists</code></strong>如果使用模式，则该规则最多只会激活一次，无论工作内存中有多少数据与内部条件相匹配<strong class="kw"><code>exists</code></strong>图案。由于仅存在很重要，因此不会建立任何绑定。</p><p>关键字<strong class="kw"><code>exists</code></strong>必须在适用的CE后面加上括号。在单个模式的最简单情况下（如下所示），您可以选择省略括号。</p><div class="example"><a id="d0e4710"></a><p class="title"><b>示例4.59至少一辆巴士</b></p><div class="example-contents"><pre class="programlisting">exists Bus()</pre></div></div><br class="example-break"><div class="example"><a id="d0e4715"></a><p class="title"><b>示例4.60至少一辆红色巴士</b></p><div class="example-contents"><pre class="programlisting">exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <strong class="kw"><code>and</code></strong>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4723"></a> 4.8.2.7。条件元素<strong class="kw"><code>forall</code></strong></h4></div></div></div><div class="figure"><a id="d0e4728"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/forall.png" align="middle" alt="对所有人"></div></div><p class="title"><b>图4.40。对所有人</b></p></div><br class="figure-break"><p>条件元素<strong class="kw"><code>forall</code></strong>完成了Drools中的一阶逻辑支持。条件元素<strong class="kw"><code>forall</code></strong>当与第一个模式匹配的所有事实与所有其余模式匹配时，计算结果为true。例：</p><pre class="programlisting">rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</pre><p>在上述规则中，我们“选择”所有类型为“英语”的Bus对象。然后，对于与该模式匹配的每个事实，我们将评估以下模式，如果它们匹配，则所有CE都将评估为true。</p><p>要声明工作内存中给定类型的所有事实都必须与一组约束匹配， <strong class="kw"><code>forall</code></strong>为了简单起见，可以用单个模式编写。例：</p><div class="example"><a id="d0e4752"></a><p class="title"><b>示例4.61单一模式</b></p><div class="example-contents"><pre class="programlisting">rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</pre></div></div><p><br class="example-break"></p><p>另一个示例显示了<strong class="kw"><code>forall</code></strong> ：</p><div class="example"><a id="d0e4762"></a><p class="title"><b>示例4.62多模式</b></p><div class="example-contents"><pre class="programlisting">rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</pre></div></div><p><br class="example-break"></p><p>Forall可以嵌套在其他CE内以实现完整的表达。例如， <strong class="kw"><code>forall</code></strong>可以在内部使用<strong class="kw"><code>not</code></strong> CE。请注意，只有单个模式具有可选的括号，因此必须使用嵌套的所有括号：</p><div class="example"><a id="d0e4775"></a><p class="title"><b>示例4.63将Forall与Not CE相结合</b></p><div class="example-contents"><pre class="programlisting">rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</pre></div></div><p><br class="example-break"></p><p>作为旁注， <code class="code">not( forall( p1 p2 p3...))</code>等同于写作：</p><pre class="programlisting">not(p1 and not(and p2 p3...))</pre><p>另外，请务必注意<strong class="kw"><code>forall</code></strong>是<span class="emphasis"><em>范围定界符</em></span> 。因此，它可以使用任何先前绑定的变量，但是在其内部没有绑定的变量将无法在其外部使用。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4795"></a> 4.8.2.8。条件元素<strong class="kw"><code>from</code></strong></h4></div></div></div><div class="figure"><a id="d0e4800"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/from.png" align="middle" alt="从"></div></div><p class="title"><b>图4.41。从</b></p></div><br class="figure-break"><p>条件元素<strong class="kw"><code>from</code></strong>使用户能够为LHS模式匹配的数据指定任意来源。这使引擎可以推理不在工作内存中的数据。数据源可以是绑定变量上的子字段，也可以是方法调用的结果。它是一种强大的结构，可以与其他应用程序组件和框架进行现成的集成。一个常见的示例是与使用休眠命名查询从数据库按需检索的数据集成。</p><p>用于定义对象源的表达式是遵循常规MVEL语法的任何表达式。因此，它使您可以轻松地使用对象属性导航，执行方法调用以及访问映射和集合元素。</p><p>这是在另一个模式子字段上进行推理和绑定的简单示例：</p><pre class="programlisting">rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</pre><p>凭借Drools引擎新的表现力所带来的全部灵活性，您可以通过多种方式将这个问题切成小方块。这是相同的，但是显示了如何在'from'中使用图形符号：</p><pre class="programlisting">rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</pre><p>先前的示例是使用单个模式的评估。行政长官<strong class="kw"><code>from</code></strong>还支持返回对象集合的对象源。在这种情况下， <strong class="kw"><code>from</code></strong>将遍历集合中的所有对象，并尝试分别匹配每个对象。例如，如果我们想要一个对订单中的每个商品应用10％折扣的规则，我们可以这样做：</p><pre class="programlisting">rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</pre><p>上面的示例将使规则针对每个给定订单的值大于100的每个商品触发一次。</p><p>但是，使用时必须小心<strong class="kw"><code>from</code></strong> ，尤其是与<strong class="kw"><code>lock-on-active</code></strong>规则属性，因为它可能会产生意外的结果。考虑前面提供的示例，但现在进行了如下修改：</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>在上面的示例中，应将北卡罗来纳州罗利市的人员分配到销售区域1并获得折扣；也就是说，您希望这两个规则都可以激活并触发。相反，您会发现只有第二条规则触发。</p><p>如果要打开审核日志，则还会看到第二条规则触发时，它会停用第一条规则。由于规则属性<strong class="kw"><code>lock-on-active</code></strong>防止一组事实发生变化时规则创建新的激活，第一个规则无法重新激活。尽管事实没有改变，但使用<strong class="kw"><code>from</code></strong>每次评估时都会出于所有意图和目的返回一个新事实。
	  </p><p>首先，回顾为什么要使用上述模式很重要。您可能在不同的规则流组中有许多规则。当规则修改工作记忆并且需要重新评估RuleFlow下游（在不同规则流组中）的其他规则时，使用<strong class="kw"><code>modify</code></strong>至关重要。但是，您不希望同一规则流组中的其他规则将激活递归地放置在一起。在这种情况下， <strong class="kw"><code>no-loop</code></strong>属性无效，因为它只会阻止规则递归激活自身。因此，您诉诸<strong class="kw"><code>lock-on-active</code></strong> 。</p><p>有几种方法可以解决此问题：</p><div class="itemizedlist"><ul><li><p>避免使用<strong class="kw"><code>from</code></strong>您可以将所有事实断言到工作内存中，或者在约束表达式中使用嵌套的对象引用（如下所示）。</p></li><li><p>将在修改块中使用的已分配变量放在条件（LHS）中的最后一句。</p></li><li><p>避免使用<strong class="kw"><code>lock-on-active</code></strong>您可以显式管理同一规则流组中的规则如何相互激活（如下所述）。</p></li></ul></div><p>首选解决方案是尽量减少使用<strong class="kw"><code>from</code></strong>您可以将所有事实直接声明到工作记忆中。在上面的示例中，可以将Person和Address实例声明为工作内存。在这种情况下，因为图形非常简单，所以一个更简单的解决方案是按如下所示修改规则：</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>现在，您将发现这两个规则均按预期启动。但是，并非总是能够如上所述访问嵌套事实。考虑一个示例，其中一个人拥有一个或多个地址，并且您希望使用一个存在量词来匹配具有至少一个满足某些条件的地址的人。在这种情况下，您将不得不诉诸于<strong class="kw"><code>from</code></strong>对收集进行推理。</p><p>有几种使用方法<strong class="kw"><code>from</code></strong>为了实现这一目标，并非所有人都在使用<strong class="kw"><code>lock-on-active</code></strong> 。例如下面的用法<strong class="kw"><code>from</code></strong>导致两个规则均按预期触发：</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} #Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} #Apply discount to person in a modify block
end
</pre><p>但是，以下略有不同的方法确实会出现此问题：</p><pre class="programlisting">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} #Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} #Modify assessment in a modify block
end</pre><p>在上面的示例中，$ addresses变量是通过使用返回的<strong class="kw"><code>from</code></strong> 。该示例还引入了一个新的评估对象，以突出显示这种情况下的一种可能解决方案。如果将条件（LHS）中分配的$ assessment变量移到每个规则中的最后一个条件，则两个规则均会按预期触发。
	  </p><p>尽管以上示例演示了如何结合使用<strong class="kw"><code>from</code></strong>与<strong class="kw"><code>lock-on-active</code></strong>在没有丢失规则激活的情况下，它们的缺点是依赖于LHS的条件顺序。另外，就跟踪哪些条件可能产生问题而言，解决方案为规则作者带来了更大的复杂性。</p><p>更好的选择是将更多事实断言保存在工作记忆中。在这种情况下，可以将一个人的地址声明为工作记忆并使用<strong class="kw"><code>from</code></strong>没必要。</p><p>但是，在某些情况下，将所有数据声明到工作内存中是不切实际的，我们需要找到其他解决方案。另一种选择是重新评估<strong class="kw"><code>lock-on-active</code></strong> 。的替代品<strong class="kw"><code>lock-on-active</code></strong>通过在每个规则中包含防止修改工作存储器时规则相互递归激活的条件，来直接管理同一规则流组中的规则如何相互激活。例如，在以上将折扣应用于罗利公民的情况下，可以将条件添加到检查折扣是否已经被应用的规则中。如果是这样，则规则不会激活。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4943"></a> 4.8.2.9。条件元素<strong class="kw"><code>collect</code></strong></h4></div></div></div><div class="figure"><a id="d0e4948"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/collect.png" align="middle" alt="搜集"></div></div><p class="title"><b>图4.42。搜集</b></p></div><br class="figure-break"><p>条件元素<strong class="kw"><code>collect</code></strong>允许规则对从给定源或工作内存中获得的对象集合进行推理。用第一阶逻辑的术语来说，这是基数量词。一个简单的例子：</p><pre class="programlisting">import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</pre><p>在上面的示例中，规则将在每个给定系统的工作内存中查找所有待处理的警报，并将它们分组在ArrayLists中。如果为给定系统找到3个或更多警报，该规则将触发。</p><p>的结果模式<strong class="kw"><code>collect</code></strong>可以是实现<code class="code">java.util.Collection</code>接口并提供默认的无参数公共构造函数。这意味着您可以使用ArrayList，LinkedList，HashSet等Java集合或您自己的类，只要它实现了<code class="code">java.util.Collection</code>接口并提供默认的无参数公共构造函数。</p><p>源和结果模式都可以像其他任何模式一样受到约束。</p><p>变量绑定在<strong class="kw"><code>collect</code></strong> CE属于源模式和结果模式，因此可以使用它们来约束源模式和结果模式。但请注意<strong class="kw"><code>collect</code></strong>是绑定的范围定界符，因此在其内部进行的任何绑定都不能在其外部使用。</p><p>收集接受嵌套<strong class="kw"><code>from</code></strong> CE。以下示例是对“ collect”的有效使用：</p><pre class="programlisting">import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4991"></a> 4.8.2.10。条件元素<strong class="kw"><code>accumulate</code></strong></h4></div></div></div><div class="figure"><a id="d0e4996"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/accumulate.png" align="middle" alt="积累"></div></div><p class="title"><b>图4.43。积累</b></p></div><br class="figure-break"><p>条件元素<strong class="kw"><code>accumulate</code></strong>是一种更灵活，更强大的形式<strong class="kw"><code>collect</code></strong> ，它可以用来做什么的感觉<strong class="kw"><code>collect</code></strong>做到并且也实现了CE的目标<strong class="kw"><code>collect</code></strong>无法胜任。基本上，它的作用是允许规则迭代对象的集合，为每个元素执行自定义操作，最后返回结果对象。</p><p>的一般语法<strong class="kw"><code>accumulate</code></strong> CE是：</p><pre class="programlisting"><em class="replaceable"><code>&lt;result pattern&gt;</code></em> <strong class="kw"><code>from accumulate(</code></strong> <em class="replaceable"><code>&lt;source pattern&gt;</code></em><strong class="kw"><code>,</code></strong>
                                  <strong class="kw"><code>init(</code></strong> <em class="replaceable"><code>&lt;init code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>action(</code></strong> <em class="replaceable"><code>&lt;action code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>reverse(</code></strong> <em class="replaceable"><code>&lt;reverse code&gt;</code></em> <strong class="kw"><code>),</code></strong>
                                  <strong class="kw"><code>result(</code></strong> <em class="replaceable"><code>&lt;result expression&gt;</code></em> <strong class="kw"><code>) )</code></strong>
</pre><p>每个元素的含义如下：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em><source pattern=""></em></span> ：源模式是引擎将尝试与每个源对象匹配的常规模式。</p></li><li><p><span class="emphasis"><em><init></init></em></span> ：这是所选方言中的语义代码块，在遍历源对象之前，将对每个元组执行一次。</p></li><li><p><span class="emphasis"><em><action></action></em></span> ：这是所选方言中的语义代码块，将为每个源对象执行。</p></li><li><p><span class="emphasis"><em><reverse></reverse></em></span> ：这是所选方言中的一个可选语义代码块，如果存在，将为与该源模式不再匹配的每个源对象执行该代码块。该代码块的目的是撤销在<span class="emphasis"><em><action></action></em></span>块，以便引擎可以在修改或缩回源对象时进行减量计算，从而极大地提高了这些操作的性能。</p></li><li><p><span class="emphasis"><em><result expression=""></result></em></span> ：这是所选方言中的语义表达式，在所有源对象都经过迭代之后执行。</p></li><li><p><span class="emphasis"><em><result pattern=""></result></em></span> ：这是一种常规模式，引擎会尝试将其与从中返回的对象进行匹配<span class="emphasis"><em><result expression=""></result></em></span> 。如果匹配，则<strong class="kw"><code>accumulate</code></strong>条件元素的评估结果为<span class="emphasis"><em>true</em></span> ，引擎将继续评估规则中的下一个CE。如果不匹配，则<strong class="kw"><code>accumulate</code></strong> CE评估为<span class="emphasis"><em>假</em></span> ，引擎停止评估该规则的CE。</p></li></ul></div><p>如果看一个例子，更容易理解：</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</pre><p>在上面的示例中，对于每个<code class="code">Order</code>在工作内存中，引擎将执行<span class="emphasis"><em>初始化代码，</em></span>将总变量初始化为零。然后它将遍历所有对象<code class="code">OrderItem</code>顺序的对象，对每个对象执行该<span class="emphasis"><em>操作</em></span> （在示例中，它将所有项目的值加到total变量中）。遍历所有之后<code class="code">OrderItem</code>对象，它将返回与<span class="emphasis"><em>结果表达式</em></span>相对应的值（在上面的示例中，变量的值<code class="code">total</code> ）。最后，引擎将尝试将结果与<code class="code">Number</code>模式，如果double值大于100，则规则将触发。</p><p>该示例使用Java作为语义方言，因此，请注意在初始化，操作和反向代码块中，必须使用分号作为语句定界符。结果是一个表达式，因此，它不接受“;”。如果用户使用任何其他方言，则他必须遵守该方言的特定语法。</p><p>如前所述， <span class="emphasis"><em>反向代码</em></span>是可选的，但是强烈建议用户编写<span class="emphasis"><em>反向代码</em></span> ，以便从<span class="emphasis"><em>update和retract</em></span>的<span class="emphasis"><em>改进性能中</em></span>受益。</p><p>的<strong class="kw"><code>accumulate</code></strong> CE可用于对源对象执行任何操作。下面的示例实例化并填充一个自定义对象：</p><pre class="programlisting">rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e5167"></a> 4.8.2.10.1。积累功能</h5></div></div></div><p>累积CE是一个非常强大的CE，但是在使用称为“累积函数”的预定义函数时，它具有真正的声明性和易用性。它们的工作方式与累加完全相同，但是用户不必在每个累加的CE中显式编写自定义代码，而是可以将预定义的代码用于常见操作。</p><p>例如，可以使用累积功能以以下方式编写对上一节中编写的订单应用折扣的规则：</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</pre><p>在上面的示例中，sum是一个累加函数，它将所有OrderItems的$ value相加并返回结果。</p><p>Drools随附以下内置的累加功能：</p><div class="itemizedlist"><ul><li><p>平均</p></li><li><p>分</p></li><li><p>最高</p></li><li><p>计数</p></li><li><p>和</p></li></ul></div><p>这些通用函数接受任何表达式作为输入。例如，如果某人想要计算订单所有项目的平均利润，则可以使用平均值函数编写一条规则：</p><pre class="programlisting">rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</pre><p>累计功能都是可插拔的。这意味着，如果需要，可以轻松地将自定义的，特定于域的功能添加到引擎中，并且规则可以不受任何限制地开始使用它们。要实现新的“累积函数”，所有需要做的就是创建一个Java类，该类实现<code class="code">org.drools.base.acumulators.AccumulateFunction</code>界面，并在配置文件中添加一行或设置系统属性，以使引擎了解新功能。作为“累积函数”实现的示例，以下是<strong class="kw"><code>average</code></strong>功能：</p><pre class="programlisting">/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 * 
 * @author etirelli
 *
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object,
     * java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object,
     * java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</pre><p>如我们所料，该函数的代码非常简单，因为所有“脏”集成工作都是由引擎完成的。最后，要将功能插入引擎，我们将其添加到配置文件中：</p><pre class="programlisting">drools.accumulate.function.average =
   org.drools.base.accumulators.AverageAccumulateFunction
</pre><p>此处为“ drools.accumulate.function”。是必须始终使用的前缀，“平均值”是在规则文件和“ org.drools.base.accumulators”中如何使用该函数。AverageAccumulateFunction”是实现函数行为的类的完全限定名称。</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5216"></a> 4.8.3。右侧（然后）</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5219"></a> 4.8.3.1。用法</h4></div></div></div><p>右侧（RHS）是规则的结果或操作部分的通用名称；这部分应包含要执行的动作的列表。在规则的RHS中使用命令性代码或条件代码是一种不好的做法。通常来说，本质上应该是原子的-“何时执行此操作”，而不是“何时执行此操作”。规则的RHS部分也应保持较小，从而使其具有声明性和可读性。如果发现在RHS中需要命令性和/或条件性代码，则可能应该将该规则分解为多个规则。RHS的主要目的是插入，牵开修改工作内存数据。为了帮助实现这一点，您可以使用一些便捷的方法来修改工作内存。无需先引用工作内存实例。</p><p><strong class="kw"><code>update(</code></strong> <span class="emphasis"><em>对象，句柄</em></span> <strong class="kw"><code>);</code></strong>会告诉引擎一个对象已更改（一个对象已绑定到LHS上的某个对象），并且可能需要重新考虑规则。</p><p><strong class="kw"><code>update(</code></strong> <span class="emphasis"><em>宾语</em></span> <strong class="kw"><code>);</code></strong>也可以使用在这里，知识帮手将通过身份检查为您查找传递的对象的事实处理。（请注意，如果您为要插入到引擎中的Java Bean提供属性更改侦听器，则可以避免调用<code class="code">update()</code>当对象改变时。）</p><p><strong class="kw"><code>insert(new</code></strong> <span class="emphasis"><em>东西</em></span> <strong class="kw"><code>());</code></strong>会将您创建的新对象放入工作记忆。</p><p><strong class="kw"><code>insertLogical(new</code></strong> <span class="emphasis"><em>东西</em></span> <strong class="kw"><code>());</code></strong>与insert类似，但是当没有更多事实支持当前触发规则的真相时，对象将自动缩回。</p><p><strong class="kw"><code>retract(</code></strong> <span class="emphasis"><em>处理</em></span> <strong class="kw"><code>);</code></strong>从工作内存中删除一个对象。</p><p>这些便利方法基本上是宏，可为<code class="code">KnowledgeHelper</code>实例，使您可以从规则文件访问工作内存。预定义变量<code class="code">drools</code>类型的<code class="code">KnowledgeHelper</code>让您调用其他几种有用的方法。（请参阅<code class="code">KnowledgeHelper</code>界面文档进行更高级的操作）。</p><div class="itemizedlist"><ul><li><p>通话<code class="code">drools.halt()</code>立即终止规则执行。这是将控制权返回到当前会话所处的位置所必需的<code class="code">fireUntilHalt()</code> 。</p></li><li><p>方法<code class="code">insert(Object o)</code> ， <code class="code">update(Object o)</code>和<code class="code">retract(Object o)</code>可以调用<code class="code">drools</code>同样，但是由于它们的频繁使用，可以在没有对象引用的情况下调用它们。</p></li><li><p><code class="code">drools.getWorkingMemory()</code>返回<code class="code">WorkingMemory</code>宾语。</p></li><li><p><code class="code">drools.setFocus( String s)</code>将焦点设置到指定的议程组。</p></li><li><p><code class="code">drools.getRule().getName()</code>从规则的RHS调用，返回规则的名称。</p></li><li><p><code class="code">drools.getTuple()</code>返回与当前执行的规则匹配的元组，并且<code class="code">drools.getActivation()</code>提供相应的激活。（这些调用对于记录和调试目的很有用。）</p></li></ul></div><p>完整的Knowlege Runtime API通过另一个预定义变量公开， <code class="code">kcontext</code> ，类型<code class="code">KnowledgeContext</code> 。它的方法<code class="code">getKnowledgeRuntime()</code>提供一个类型的对象<code class="code">KnowledgeRuntime</code>依次提供了许多方法，其中许多方法对于RHS逻辑编码非常有用。

      </p><div class="itemizedlist"><ul><li><p>通话<code class="code">kcontext.getKnowledgeRuntime().halt()</code>立即终止规则执行。</p></li><li><p>存取器<code class="code">getAgenda()</code>返回对该会话的引用<code class="code">Agenda</code> ，进而可以访问各种规则组：激活组，议程组和规则流组。一个相当常见的范例是某个议程组的激活，这可以通过冗长的调用来完成：</p><pre class="programlisting">
// give focus to the agenda group CleanUp
kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</pre><p>（您可以使用<code class="code">drools.setFocus( "CleanUp" )</code> ）
          </p></li><li><p>要运行查询，请致电<code class="code">getQueryResults(String query)</code> ，然后您可以处理结果，如“ <span class="quote"><a class="link" href="#sec.query" title="4.9。询问">查询</a></span> ”部分中所述。
          </p></li><li><p>一组用于事件管理的方法使您可以为工作记忆库和议程添加和删除事件侦听器。</p></li><li><p>方法<code class="code">getKnowledgeBase()</code>返回<code class="code">KnowledgeBase</code>对象，系统中所有知识的骨干以及当前会话的发起者。</p></li><li><p>您可以使用<code class="code">setGlobal(...)</code> ， <code class="code">getGlobal(...)</code>和<code class="code">getGlobals()</code> 。</p></li><li><p>方法<code class="code">getEnvironment()</code>返回运行时的<code class="code">Environment</code>它的工作方式与您所知道的操作系统环境非常相似。</p></li></ul></div><p>
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5413"></a> 4.8.3.2。的<strong class="kw"><code>modify</code></strong>声明</h4></div></div></div><p>此语言扩展提供了一种用于事实更新的结构化方法。它将更新操作与许多setter调用结合在一起，以更改对象的字段。这是<strong class="kw"><code>modify</code></strong>声明：</p><pre class="programlisting"><strong class="kw"><code>modify ( </code></strong><em class="replaceable"><code>&lt;fact-expression&gt;</code></em><strong class="kw"><code> ) {</code></strong>
    <em class="replaceable"><code>&lt;expression&gt;</code></em> [ <strong class="kw"><code>,</code></strong> <em class="replaceable"><code>&lt;expression&gt;</code></em> ]*
<strong class="kw"><code>}</code></strong></pre><p>括号内<span class="emphasis"><em><fact-expression></fact-expression></em></span>必须产生一个事实对象引用。块中的表达式列表应包含对给定对象的setter调用，这些调用将在没有常规对象引用的情况下编写，该引用由编译器自动添加。</p><p>该示例说明了一个简单的事实修改。</p><div class="example"><a id="d0e5450"></a><p class="title"><b>示例4.64修改语句</b></p><div class="example-contents"><pre class="programlisting">rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5455"></a> 4.8.4。关于自动装箱和原始类型的注释</h3></div></div></div><p>Drools尝试将数字保留为原始或对象包装形式，因此绑定到int原语的变量在代码块或表达式中使用时，将不再需要手动拆箱。与Drools 3.0不同，在Drools 3.0中所有原语都自动装箱，需要手动拆箱。绑定到对象包装器的变量将保留为对象。在这种情况下，将使用现有的处理自动装箱和拆箱的JDK 1.5和JDK 5规则。在评估字段约束时，系统尝试将其中一个值强制转换为可比较的格式。因此基元可与对象包装器相提并论。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec.query"></a> 4.9。询问</h2></div></div></div><div class="figure"><a id="d0e5463"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Language/query.png" align="middle" alt="询问"></div></div><p class="title"><b>图4.44。询问</b></p></div><br class="figure-break"><p>查询是一种简单的方法，可以在工作存储器中搜索符合指定条件的事实。因此，它仅包含规则的LHS的结构，因此您既不指定“ when”，也不指定“ then”。查询具有一组可选参数，每个参数都可以选择键入。如果未提供类型，则假定为对象类型。引擎将尝试根据需要强制更改这些值。查询名称是知识库的全局名称；因此，请勿将相同名称的查询添加到同一RuleBase的不同包中。</p><p>要返回结果，请使用<code class="code">ksession.getQueryResults("name")</code> ，其中“名称”是查询的名称。这将返回查询结果列表，使您可以检索与查询匹配的对象。</p><p>第一个示例为30岁以上的所有人提供了一个简单的查询。第二个参数使用参数将年龄限制与位置组合在一起。</p><div class="example"><a id="d0e5478"></a><p class="title"><b>示例4.65查询30岁以上的人</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of 30" 
    person : Person( age &gt; 30 )
end</pre></div></div><br class="example-break"><div class="example"><a id="d0e5483"></a><p class="title"><b>示例4.66查询x岁以上，y岁以下人士</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of x"  (int x, String y)
    person : Person( age &gt; x, location == y )
end</pre></div></div><br class="example-break"><p>我们使用标准的“ for”循环遍历返回的QueryResults。每个元素都是一个QueryResultsRow，我们可以使用它访问元组中的每个列。可以通过绑定声明名称或索引位置访问这些列。</p><div class="example"><a id="d0e5490"></a><p class="title"><b>示例4.67查询30岁以上的人</b></p><div class="example-contents"><pre class="programlisting">QueryResults results = ksession.getQueryResults( "people over the age of 30" );
System.out.println( "we have " + results.size() + " people over the age  of 30" );

System.out.println( "These people are are over 30:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5495"></a> 4.10。领域特定语言</h2></div></div></div><p>如前所述， <a id="d0e5500" class="indexterm"></a> （或DSL）是一种将规则语言扩展到您的问题域的方法。它们为您连接到规则语言，并且可以利用所有基础规则语言和引擎功能。</p><p>在IDE和基于Web的BRMS中都使用DSL。当然，由于规则是文本，因此即使没有此工具也可以使用它们。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5506"></a> 4.10.1。何时使用DSL</h3></div></div></div><p>DSL可以充当规则创作（和规则创作者）与引擎所操作的域对象之间的隔离层。DSL还可以充当在规则中反复使用的条件或操作的“模板”，也许每次参数都只更改一次。如果需要较少技术人员（例如业务分析师）阅读和验证您的规则，则DSL绝对适合您。如果规则的条件或后果遵循可在模板中表达的相似模式。您希望隐藏您的实施细节，并专注于业务规则。您想提供一种基于预定义模板的受控方式来编辑规则。</p><p>DSL在运行时对规则没有影响，它们只是解析/编译时功能。</p><p>请注意，Drools 4 DSL与基于Drools 2 XML的DSL完全不同。仍然可以使用Drools 2样式的XML语言-如果需要，请看一下Drools 4 XML规则语言，并考虑使用XSLT从XML语言映射到Drools 4 XML语言。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5515"></a> 4.10.2。编辑和管理DSL</h3></div></div></div><p>像大多数事物一样，DSL的配置以纯文本存储。如果使用IDE，您将获得一个不错的图形编辑器（经过验证），但是文件的格式非常简单，并且基本上是一个属性文件。</p><p>请注意，自Drools 4.0起，DSL变得更加强大，可让您自定义语言的几乎任何部分，包括关键字。如果需要，也可以使用正则表达式来匹配单词/句子（这是为增强本地化能力而提供的）。但是，并非所有工具都支持所有功能（尽管您可以使用它们，但是在某些情况下，内容帮助可能并非100％准确）。</p><div class="example"><a id="d0e5522"></a><p class="title"><b>示例4.68例<a id="d0e5525" class="indexterm"></a>映射</b></p><div class="example-contents"><pre class="programlisting">[when]This is {something}=Something(something=={something})</pre></div></div><br class="example-break"><p>参考上面的示例，[when]表示表达式的范围：即它属于规则的LHS还是RHS。[scope]之后的部分是您在规则中使用的表达式（通常是自然语言表达式，但不一定必须如此）。“ =”右边的部分是到规则语言的映射（当然，其形式取决于您是在谈论RHS还是LHS-如果是LHS，则是常规LHS语法，如果其RHS，然后是其Java代码片段）。</p><p>解析器将采用您指定的表达式，并提取与输入中{something}（命名令牌）出现的位置匹配的值。然后，将与令牌匹配的值与映射（规则引擎实际使用的目标表达式）右侧的相应{something}（称为令牌）进行插值。</p><p>还请注意，上面的“句子”可以是正则表达式。这意味着解析器将匹配与表达式匹配的句子片段。这意味着您可以使用（例如）“？'表示可选字符之前的字符（将每个句子视为正则表达式模式-这意味着如果您要使用正则表达式字符-当然，您需要使用'\'对其进行转义。</p><p>重要的是要注意，DSL表达式一次只能处理一行。这意味着在上面的示例中，当将“ This is”之后的所有文本插入到目标字符串中时，该行之后的所有文本都将作为“ {something}”的值包括在内。这可能不完全是您想要的，因为您可能希望将不同的DSL表达式“链接”在一起以生成目标表达式。解决此问题的最佳方法是确保{tokens}用字符或单词括起来。这意味着解析器将沿着句子进行扫描，并提取出字符之间的值（在下面的示例中，它们是双引号）。请注意，插值时不包括标记周围的字符，只是它们之间的内容（而不是一直到行尾的情况，否则是这样）。</p><p>根据经验，对规则编辑器可能要输入的文本数据使用引号。您还可以在{tokens}周围加上单词，以确保封装了要捕获的数据（请参见其他示例）。</p><div class="example"><a id="d0e5541"></a><p class="title"><b>示例4.69带引号的示例</b></p><div class="example-contents"><pre class="programlisting">[when]This is "{something}" and "{another}"=Something(something=="{something}", another=="{another}")
[when]This is {also} valid=Another(something=="{also}")</pre></div></div><br class="example-break"><p>尽量避免在DSL表达式中出现标点符号（包括引号等），这是一个好主意-保持简单，事情会变得更容易。初次建立规则时，使用DSL会使调试变得稍微困难一些，但可以使维护更加容易（当然还有规则的可读性）。</p><p>只能在映射（表达式）的左侧使用“ {”和“}”字符来标记标记。在右侧，您可以根据需要自行使用“ {”和“}”，例如</p><pre class="programlisting">if (foo) \{
    doSomething();\ }</pre><p>以及上面显示的令牌名称。</p><p>请注意，如果希望花括号在字面上显示为花括号，请使用后缀（\）将其转义。否则，它可能会认为这是要替换的令牌。
  </p><p>别忘了，如果要捕获用户的字符串，则就像常规规则一样，您还将需要映射右侧的引号，因为映射结果必须是规则语言中的有效表达式。</p><div class="example"><a id="d0e5557"></a><p class="title"><b>示例4.70更多例子</b></p><div class="example-contents"><pre class="programlisting">#This is a comment to be ignored.
[when]There is a Person with name of "{name}"=Person(name=="{name}")
[when]Person is at least {age} years old and lives in "{location}"=Person(age &gt; {age}, location=="{location}")
[then]Log "{message}"=System.out.println("{message}");
[when]And = and</pre></div></div><br class="example-break"><p>参考上面的示例，这将呈现以下输入，如下所示：</p><div class="example"><a id="d0e5564"></a><p class="title"><b>示例4.71一些例子处理</b></p><div class="example-contents"><pre class="programlisting">There is a Person with name of "kitty" ---&gt; Person(name="kitty")
Person is at least 42 years old and lives in "atlanta" ---&gt; Person(age &gt; 42, location="atlanta")
Log "boo" ---&gt; System.out.println("boo");
There is a Person with name of "bob" and Person is at least 30 years old and lives in "atlanta" 
          ---&gt; Person(name="kitty") and Person(age &gt; 30, location="atlanta")</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5569"></a> 4.10.3。在规则中使用DSL</h3></div></div></div><p>如果您不熟悉规则（和DSL），一个很好的入门方法就是按照您通常针对对象模型编写规则。您可以随时进行单元测试（就像一个优秀的敏捷公民！）。一旦感到舒适，您就可以考虑提取一种域语言来表达您在规则中所做的事情。请注意，一旦开始使用“ expander”关键字，如果解析器无法识别其中的表达式，则会出现错误-您需要将所有内容移至DSL。作为一种解决方法，您可以在每行前面加上“>”作为前缀，它会告诉解析器按原样接受该行，而不是尝试对其进行扩展（如果您要调试为什么某些行不通，这也很方便）。</p><p>另外，最好在开始使用DSL时将规则文件的扩展名从“ .drl”重命名为“ .dslr”，因为这将使IDE正确识别并使用规则文件。</p><p>在构建DSL的过程中，您会发现DSL配置能够很快稳定下来，并且在添加新规则和编辑规则时，您会一遍又一遍地重复使用相同的DSL表达式。目的是使事情尽可能流畅。</p><p>要在要编译和运行规则时使用DSL，需要将DSL配置源与规则源一起传递。
    </p><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( source, dsl );
//source is a reader for the rule source, dsl is a reader for the DSL configuration
</pre><p>您还需要在规则源文件中通过名称指定扩展器：</p><pre class="programlisting">expander your-expander.dsl
</pre><p>通常，您将DSL与规则保存在同一目录中，但是如果您使用上述API，则不需要这样做（只需传递阅读器即可）。否则，一切都是一样的。</p><p>只要解析器可以清楚知道{tokens}是什么，就可以将DSL表达式链接在一起（否则，您可能会冒读太多文本直到行尾的风险）。DSL表达式按照从上到下的映射文件进行处理。您还可以使结果规则表达式跨行显示-这意味着您可以执行以下操作：</p><div class="example"><a id="d0e5588"></a><p class="title"><b>示例4.72链接DSL表达式</b></p><div class="example-contents"><pre class="programlisting">There is a person called Bob who is happy
  Or
There is a person called Mike who is sad
</pre></div></div><br class="example-break"><p>当然，这假定“ Or”被映射到“ or”条件元素（这是明智的做法）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5595"></a> 4.10.4。给事实增加约束</h3></div></div></div><p>编写规则条件时的一个常见要求是能够向事实声明添加许多约束。一个事实可能有很多（几十个）字段，所有这些字段在不同时间都可以使用或不使用。在许多情况下，将每种组合作为单独的DSL语句来提出是不可行的。</p><p>DSL功能允许您通过一个简单的约定来实现这一目标。如果您的DSL表达式以“-”开头，那么它将被认为是一个字段约束，它将被添加到它上面的声明中（每行一个）。</p><p>用一个例子更容易解释。让我们看一下奶酪类，其中包含以下字段：类型，价格，年龄，国家/地区。我们可以在正常DRL中表达一些LHS条件，如下所示</p><pre class="programlisting">Cheese(age &lt; 5, price == 20, type=="stilton", country=="ch")</pre><p>如果您提前知道您将一直使用所有字段，那么使用上述技术进行映射很容易。但是，您可能会拥有许多字段和许多组合。在这种情况下，您可以这样设置映射：</p><pre class="programlisting">[when]There is a Cheese with=Cheese()
[when]- age is less than {age}=age&lt;{age}
[when]- type is '{type}'=type=='{type}'
[when]- country equal to '{country}'=country=='{country}'</pre><p><span class="bold"><strong>重要说明：</strong></span>在<span class="bold"><strong>累积</strong></span>语句之后无法使用“-”功能向累积模式添加约束。以后将取消此限制。</p><p>然后，您可以使用以下条件编写规则：</p><pre class="programlisting">There is a Cheese with
        - age is less than 42
        - type is 'stilton'</pre><p>解析器将选择“-”行（它们必须在自己的行上），并将它们作为约束添加到上面的声明中。因此，在这种特定情况下，使用上面的映射等效于（在DRL中）：</p><pre class="programlisting">Cheese(age&lt;42, type=='stilton')</pre><p>解析器将为您完成所有工作，这意味着您只需为单个约束定义映射，并可以按自己的喜好将它们组合起来（如果使用的是上下文助手，如果按“-”，然后按CTRL +空格，它将为您提供便利带有过滤条件的字段约束列表供您选择。</p><p>为了更进一步，在更改DSL后[when] [org.drools]。奶酪]-年龄小于{age} ...（并且与上面示例中的所有项目类似）。</p><p>额外的[org.drools。奶酪]表示该句子仅适用于其上方的主约束句子（在这种情况下，“有一个奶酪搭配”）。例如，如果您有一个名为“奶酪”的类-那么如果您向规则添加约束（通过键入“-”并等待内容帮助），那么它将知道只有标记为对象范围为“ com.yourcompany。某事”是有效的，仅建议他们。这是完全可选的（如果需要，您可以忽略该部分，或者可以将其留空）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5628"></a> 4.10.5。怎么运行的</h3></div></div></div><p>解析规则后，DSL就会加入。读取DSL配置并将其提供给解析器，因此解析器可以将DSL表达式“扩展”为实际规则语言表达式。</p><p>当解析器处理规则时，它将检查是否启用了表示DSL的“扩展器”，如果已启用，它将尝试根据规则所在的上下文扩展表达式。如果无法扩展表达式，则将在结果中添加错误，并记录行号（这可确保在使用DSL编辑规则时避免输入错误）。当前，DSL扩展器对空间非常敏感，但是在将来的版本中将更加容忍（包括对各种标点符号的容忍度）。</p><p>扩展本身的工作方式是尝试将一行与DSL配置中的表达式匹配。对应于令牌占位符的值基于令牌的名称存储在映射中，然后插值到目标映射。通过搜索直到行尾，或者直到匹配令牌占位符之后的字符或单词，才能提取与令牌占位符匹配的值。“ {”和“}”不包括在提取的值中，它们仅用于划分标记-您不应在DSL表达式中使用这些字符（但可以在目标中使用）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5637"></a> 4.10.6。从头开始创建DSL</h3></div></div></div><p>如果规则是众所周知的，则DSL可以帮助捕获规则，只是没有任何技术上可用的格式（即，坐在人们的大脑中）。直到我们能够像Matrix中那样在我们的脖子上插上那些小插座之前，我们将东西放入计算机的方法仍然是老式的方法。</p><p>规则引擎需要对象或数据模型进行操作-在许多情况下，您可能事先就知道这一点。在其他情况下，将使用规则来发现模型。无论如何，规则通常与较简单的扁平对象模型一起使用时效果更好。在某些情况下，这可能意味着拥有一个规则对象模型，该模型是主要应用程序模型的子集（可能是从其映射的）。对象模型中通常可以具有复杂的关系和层次结构-对于规则，您将希望在可能的情况下简化和展平模型，并让规则引擎推断关系（因为它提供了未来的灵活性）。如前所述，DSL具有在对象模型和规则语言之间提供某种隔离的优势。</p><p>对于技术专家和领域专家而言，提出DSL是一种协作方法。从历史上看，有一个称为“知识工程师”的角色，他既擅长规则技术，又擅长捕获规则。在短时间内，您的DSL应该会稳定下来，这意味着规则的更改完全是使用DSL完成的。如果您从头开始，建议的方法是以下工作流程：</p><div class="itemizedlist"><ul><li><p>将规则捕获为宽松的“ if if”语句-这实际上是为了了解大小和复杂性（可能在文本文档中）。</p></li><li><p>在捕获的规则中查找重复的语句。还要查找规则对象/字段（并使它们与对象模型可能已经知道的匹配）。</p></li><li><p>创建一个新的DSL，并从上述步骤开始添加语句。为要编辑的数据提供“漏洞”（因为许多语句将是相似的，只有一些数据会发生变化）。</p></li><li><p>使用上面的DSL，并尝试编写规则，就像第一步和第二步的“ if then”语句中显示的一样。重复此过程，直到出现模式并且一切稳定为止。在此阶段，您不必担心下面的规则语言，而只需担心DSL。</p></li><li><p>在此阶段，您将需要查看对象和规则所需的字段，并将其与数据模型进行协调。</p></li><li><p>根据对象模型将DSL语句映射到规则语言。然后重复该过程。显然，最好一步一步完成，以确保事情步入正轨。</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5665"></a> 4.10.7。范围和关键字</h3></div></div></div><p>如果您正在使用GUI编辑DSL或以文本形式编辑DSL，则会注意到在每个映射行的开头都有一个[scope]项。这表明句子/单词是适用于LHS，RHS还是关键字。有效值是[condition]，[consequence]和[keyword]（[when]和[then]分别与[condition]和[conequence]相同）。当使用[keyword]时，它意味着您可以将任何语言（例如“ rule”或“ end”）映射到其他关键字。通常，仅当您希望使用非英语规则语言时才使用此选项（并且最好将其映射为单个单词）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5670"></a> 4.10.8。BRMS和IDE中的DSL</h3></div></div></div><p>您可以在BRMS中的引导编辑器规则和使用dsl的文本规则中使用DSL。（实际上，同样适用于IDE）。</p><p>在向导式编辑器中-DSL通常必须更简单-您正在做的是定义小的“表格”以捕获文本字段中用户的数据（即，当您选择DSL表达式时-它将在GUI中添加一项，仅允许您在DSL表达式的{token}部分中输入数据）。您不能使用复杂的正则表达式来匹配文本。但是，在文本规则（在IDE中具有.dslr扩展名）中，您可以根据需要自由使用全部功能。</p><p>在BRMS中-构建软件包时，已经包含DSL，并且所有工作已为您完成。在IDE（或任何IDE）中-您将需要使用drools-ant任务，或者使用上面各节中显示的代码。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5679"></a> 4.11。XML规则语言</h2></div></div></div><p>作为一种选择，Drools还支持“本机” <a id="d0e5684" class="indexterm"></a>规则语言替代DRL。这使您可以将规则捕获和管理为XML数据。就像非XML DRL格式一样，将XML格式解析为内部“ AST”表示-尽快（使用SAX解析器）。无需外部转换步骤。DRL可以使用XML提供的所有功能。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5688"></a> 4.11.1。何时使用XML</h3></div></div></div><p>有几种需要XML的方案。但是，我们建议您不要将它作为默认选择，因为XML并不容易被人阅读（除非您喜欢头痛），并且可以创建视觉上ated肿的规则。</p><p>如果您确实想手工编辑XML，请使用一个良好的模式感知编辑器，该编辑器可以提供理想的XML层次结构视图，最好在视觉上（XMLSpy，Oxygen等商业工具虽然不错，但要花钱，但令人头痛的平板电脑也可以）。</p><p>其他可能需要使用XML格式的场景是，如果您有一个从某些输入生成规则的工具（以编程方式生成的规则），或者可以与另一种规则语言互换，或者与另一种发出XML的工具互换（使用XSLT，则可以在XML格式之间转换）。请注意，您也始终可以生成普通DRL。</p><p>或者，您可能将Drools嵌入到已经使用XML进行配置的产品中，因此您希望规则采用XML格式。您可能正在XML上创建自己的规则语言-请注意，您始终可以直接使用AST对象来直接创建自己的规则语言（由于开放的体系结构，因此选项很多）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5699"></a> 4.11.2。XML格式</h3></div></div></div><p>提供了完整的符合W3C标准（XMLSchema）的XSD，用于描述XML语言，在此不再逐字重复。语言摘要如下。</p><div class="example"><a id="d0e5704"></a><p class="title"><b>示例4.73XML规则<a id="d0e5707" class="indexterm"></a></b></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;package name="com.sample"
         xmlns="http://drools.org/drools-4.0"
         xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         xs:schemaLocation="http://drools.org/drools-4.0 drools-4.0.xsd"&gt;

&lt;import name="java.util.HashMap" /&gt;
&lt;import name="org.drools.*" /&gt;

&lt;global identifier="x" type="com.sample.X" /&gt;
&lt;global identifier="yada" type="com.sample.Yada" /&gt;

&lt;function return-type="void" name="myFunc"&gt;
    &lt;parameter identifier="foo" type="Bar" /&gt;
    &lt;parameter identifier="bada" type="Bing" /&gt;

    &lt;body&gt;
     System.out.println("hello world");
    &lt;/body&gt;
&lt;/function&gt;

&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
		&lt;pattern identifier="foo2" object-type="Bar" &gt;
            &lt;or-constraint-connective&gt;
                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&gt;" value="60" /&gt;
                                &lt;literal-restriction evaluator="&lt;" value="70" /&gt;
                            &lt;/and-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&lt;" value="50" /&gt;
                                &lt;literal-restriction evaluator="&gt;" value="55" /&gt;
                            &lt;/and-restriction-connective&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="black" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="40" /&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="pink" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="12"/&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;literal-restriction evaluator="==" value="yellow"/&gt;
                            &lt;literal-restriction evaluator="==" value="blue" /&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;
            &lt;/or-constraint-connective&gt;
        &lt;/pattern&gt;

        &lt;not&gt;
            &lt;pattern object-type="Person"&gt;
                &lt;field-constraint field-name="likes"&gt;
                    &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;exists&gt;
                &lt;pattern object-type="Person"&gt;
                    &lt;field-constraint field-name="likes"&gt;
                        &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                    &lt;/field-constraint&gt;
                &lt;/pattern&gt;                
            &lt;/exists&gt;
        &lt;/not&gt;

        &lt;or-conditional-element&gt;
            &lt;pattern identifier="foo3" object-type="Bar" &gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;or-restriction-connective&gt;
                        &lt;literal-restriction evaluator="==" value="3" /&gt;
                        &lt;literal-restriction evaluator="==" value="4" /&gt;
                    &lt;/or-restriction-connective&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a3"&gt;
                    &lt;literal-restriction evaluator="==" value="hello" /&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a4"&gt;
                    &lt;literal-restriction evaluator="==" value="null" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;pattern identifier="foo4" object-type="Bar" &gt;
                &lt;field-binding field-name="a" identifier="a4" /&gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;literal-restriction evaluator="!=" value="4" /&gt;
                    &lt;literal-restriction evaluator="!=" value="5" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;
        &lt;/or-conditional-element&gt;

        &lt;pattern identifier="foo5" object-type="Bar" &gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;or-restriction-connective&gt;
                    &lt;return-value-restriction evaluator="==" &gt;a4 + 1&lt;/return-value-restriction&gt;
                    &lt;variable-restriction evaluator="&gt;" identifier="a4" /&gt;
                    &lt;qualified-identifier-restriction evaluator="=="&gt;
                        org.drools.Bar.BAR_ENUM_VALUE
                    &lt;/qualified-identifier-restriction&gt;
                &lt;/or-restriction-connective&gt;
            &lt;/field-constraint&gt;            
        &lt;/pattern&gt;

        &lt;pattern identifier="foo6" object-type="Bar" &gt;
            &lt;field-binding field-name="a" identifier="a4" /&gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;literal-restriction evaluator="==" value="6" /&gt;
            &lt;/field-constraint&gt;
        &lt;/pattern&gt;
  &lt;/lhs&gt;
 &lt;rhs&gt;
    if ( a == b ) {
      assert( foo3 );
    } else {
      retract( foo4 );
    }
    System.out.println( a4 );
   &lt;/rhs&gt;
&lt;/rule&gt;

&lt;/package&gt;
	
</pre></div></div><br class="example-break"><p>在前面的XML文本中，您将看到典型的XML元素，包声明，导入，全局变量，函数以及规则本身。如果您对Drools功能有所了解，那么大多数元素都是不言而喻的。</p><p>的<code class="code">import</code>元素导入您希望在规则中使用的类型。</p><p>的<code class="code">global</code>元素定义可以在规则中引用的全局对象。</p><p>的<code class="code">function</code>包含一个函数声明，用于规则中使用的函数。您必须在主体中指定一个返回类型，一个唯一的名称和参数，其中包含一段代码。</p><p>该规则将在下面讨论。</p><div class="example"><a id="d0e5731"></a><p class="title"><b>示例4.74规则元素的详细信息</b></p><div class="example-contents"><pre class="programlisting">&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
    &lt;pattern identifier="cheese" object-type="Cheese"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern object-type="Person"&gt;&lt;/pattern&gt;
                &lt;init&gt;
                    int total = 0;
                &lt;/init&gt;
                &lt;action&gt;
                    total += $cheese.getPrice();
                &lt;/action&gt;
                &lt;result&gt;
                    new Integer( total ) );
                &lt;/result&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;

    &lt;pattern identifier="max" object-type="Number"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern identifier="cheese" object-type="Cheese"&gt;&lt;/pattern&gt;
                &lt;external-function evaluator="max" expression="$price"/&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;
&lt;/lhs&gt;
&lt;rhs&gt;
    list1.add( $cheese );
&lt;/rhs&gt;
&lt;/rule&gt;
	</pre></div></div><br class="example-break"><p>在规则的上述详细信息中，我们看到该规则包含LHS和RHS（条件和结果）部分。RHS很简单，它只是激活规则时将执行的语义代码块。LHS稍微复杂一点，因为它包含用于条件元素，约束和约束的嵌套元素。</p><p>LHS的关键元素是样式元素。这使您可以指定类型（类），并且可以将变量绑定到该类的实例。嵌套在模式对象下的是必须满足的约束和限制。谓词和返回值约束允许嵌入Java表达式。</p><p>这样就留下了条件元素，不存在，不存在，等等。它们的工作方式与DRL对应项相同。嵌套在其下的元素和一个“与”元素在逻辑上“与”在一起。同样使用“或”（您可以进一步嵌套）。 “存在”和“不”围绕模式进行工作，以检查是否存在符合模式约束的事实。</p><p>Eval元素允许执行有效的Java代码段-只要它评估为布尔值（不要以分号结尾，因为它只是一个片段）-这可以包括调用函数。Eval的效率不及列，因为规则引擎必须每次对其进行评估，但它是“全部捕获”功能，可用于表达需要对列约束进行的操作。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5745"></a> 4.11.3。旧版Drools 2.x XML规则格式</h3></div></div></div><p>Drools XML解析器不再支持Drools 2.x传统XML格式</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5750"></a> 4.11.4。在格式之间自动转换（XML和DRL）</h3></div></div></div><p>Drools带有一些实用程序类，可以在格式之间进行转换。通过将规则从源格式解析为AST，然后“转储”为适当的目标格式，可以起作用。例如，这使您可以用DRL编写规则，并在需要时在将来的某个时候导出为XML（如果需要）。</p><p>如果需要这样做，可以查看的类是：</p><pre class="programlisting">XmlDumper - for exporting XML.
DrlDumper - for exporting DRL.
DrlParser - reading DRL.
XmlPackageReader - reading XML.
</pre><p>通过使用上述组合，可以在任何格式（包括往返）之间进行转换。请注意，不会保留DSL（从使用DSL的DRL中保留）-但可以将其转换。</p><p>随意使用XSLT为XML提供各种可能性，XSLT及其类似特性使XML变得强大。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5762"></a>第五章创作</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5765">5.1。电子表格中的决策表</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5777">5.1.1。何时使用决策表</a></span></dt><dt><span class="section"><a href="#d0e5789">5.1.2。总览</a></span></dt><dt><span class="section"><a href="#d0e5827">5.1.3。决策表如何工作</a></span></dt><dt><span class="section"><a href="#d0e5900">5.1.4。关键字和语法</a></span></dt><dt><span class="section"><a href="#d0e6103">5.1.5。创建和集成基于电子表格的决策表</a></span></dt><dt><span class="section"><a href="#d0e6116">5.1.6。在决策表中管理业务规则。</a></span></dt><dt><span class="section"><a href="#d0e6161">5.1.7。规则模板</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6212">5.2。范本</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6225">5.2.1。规则模板文件</a></span></dt><dt><span class="section"><a href="#d0e6322">5.2.2。扩展模板</a></span></dt><dt><span class="section"><a href="#d0e6376">5.2.3。例</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5765"></a> 5.1。电子表格中的决策表</h2></div></div></div><p>决策表是“精确而紧凑的”（参考Wikipedia）表示条件逻辑的方式，非常适合<span class="emphasis"><em>业务</em></span>级别规则。</p><p>Drools支持以电子表格格式管理规则。支持的格式为Excel（XLS）和CSV，这意味着可以使用各种电子表格程序（例如Microsoft Excel，OpenOffice.org Calc等）。预计在不久的将来版本中将包含基于Web的决策表编辑器。</p><p>决策表（从软件角度而言）是一个古老的概念，但多年来已证明是有用的。简而言之，在Drools中，决策表是一种根据输入电子表格的数据生成规则的方法。可以利用电子表格中用于数据捕获和处理的所有常规功能。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5777"></a> 5.1.1。何时使用决策表</h3></div></div></div><p>如果存在可以表示为规则模板和数据的规则，则决策表可能希望被视为行动方针。在决策表的每一行中，将收集与模板组合以生成规则的数据。</p><p>许多企业已经使用电子表格来管理数据，进行计算等。如果您愿意继续使用这种方式，则也可以通过这种方式来管理您的业务规则。这也假设您很乐意在.xls或.csv文件中管理规则包。对于不遵循模板集的规则，或者规则数量少（或者对Excel或Open Office等软件不满意的规则），不建议使用决策表。它们是理想的，因为可以控制规则的哪些<span class="emphasis"><em>参数</em></span>可以编辑，而无需直接暴露规则。</p><p>决策表还提供了与基础对象模型的隔离度。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5789"></a> 5.1.2。总览</h3></div></div></div><p>以下是现实世界中决策表的一些示例（为保护无辜者而进行了轻微编辑）。</p><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/excel.png" width="100%"></td></tr></tbody></table></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/actions.png"></div></div><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/open_office.png" width="100%"></td></tr></tbody></table></div></div><p>在以上示例中，决策表的技术方面已被折叠（使用标准电子表格功能）。</p><p>规则从第17行开始，每行生成一条规则。条件在C，D，E等列中，操作不在屏幕上。单元格中的值非常简单，其含义由第16行中的标题指示。B列仅是描述。通常使用颜色使表的不同区域的含义显而易见。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>请注意，尽管决策表看起来像是自上而下处理的，但不一定是这种情况。理想情况下，编写规则时无需考虑行的顺序，这仅仅是因为这使维护更加容易，因为行不需要一直移动。</p></div><p>由于每一行都是一条规则，因此适用相同的原则。在规则引擎处理事实时，可能会触发任何匹配的规则。（一些人对此感到困惑。可以在规则触发时清除议程，并模拟存在第一个匹配项的非常简单的决策表。）另请注意，一个电子表格上可以有多个表。这样，可以将规则共享共同的模板的位置分组，但最终将它们全部组合到一个规则包中。决策表本质上是自动生成DRL规则的工具。</p><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/multi_table.png" width="100%"></td></tr></tbody></table></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5827"></a> 5.1.3。决策表如何工作</h3></div></div></div><p>要记住的关键点是，在决策表中，每一行都是一条规则，而该行中的每一列都是该规则的条件或动作。</p><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/row_col.png" width="100%"></td></tr></tbody></table></div></div><p>电子表格将查找<em class="firstterm">RuleTable</em>关键字，以指示规则表的开始（起始行和列）。其他关键字也用于定义其他程序包级别属性（稍后介绍）。重要的是将关键字保持在一列中。按照惯例，第二列（“ B”）用于此目的，但可以是任何一列（习惯上在笔记的左边留有一个空白）。在下图中，C实际上是它开始的列。左侧的所有内容都将被忽略。</p><p>如果我们扩展隐藏的部分，它将开始更有意义。请注意列C中的关键字。</p><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/expanded.png" width="100%"></td></tr></tbody></table></div></div><p>现在可以看到使之起作用的隐藏魔法。RuleSet关键字指示将在包含所有规则的<span class="emphasis"><em>规则包</em></span>中使用的名称。该名称是可选的，使用默认名称，但是在紧靠右侧的单元格中<span class="emphasis"><em>必须</em></span>具有<span class="emphasis"><em>RuleSet</em></span>关键字。</p><p>C列中其他可见的关键字是Import和Sequential，稍后将介绍。RuleTable关键字很重要，因为它表明将基于某些规则模板遵循大量规则。RuleTable关键字之后有一个名称，用于为生成的规则的名称加上前缀。附加行号以保证唯一的规则名称。RuleTable的列指示规则开始的列；左侧的列将被忽略。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>通常，关键字组成名称/值对。</p></div><p>参考第14行（RuleTable之后的行），关键字CONDITION和ACTION表示以下各列中的数据适用于规则的LHS或RHS部分。规则上还有其他属性，也可以选择通过这种方式设置。</p><p>第15行包含<em class="firstterm">ObjectTypes的声明</em> 。该行中的内容是可选的，但是如果未使用此选项，则该行必须留为空白；但是，通常发现此选项非常有用。使用此行时，下面的单元格（第16行）中的值成为该对象类型的约束。在上述情况下，它将生成<code class="code">Person(age=="42")</code>和<code class="code">Cheese(type=="stilton")</code> ，其中42和“ stilton”来自第18行。在上面的示例中，“ ==”是隐式的；如果只给出一个字段名，它将假定它是寻找精确匹配。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>ObjectType声明可以跨列（通过合并的单元格），这意味着合并范围以下的所有列都将合并为一组约束。</p></div><p>第16行包含规则模板本身。他们可以使用“ $ para”占位符来指示将填充下面单元格中的数据的位置（可以使用$ param或$ 1，$ 2等来指示来自下面单元格中逗号分隔列表的参数）。第17行将被忽略，因为它是规则模板的文字描述。</p><p>第18和19行显示数据，这些数据将与第15行中的模板结合（插值）以生成规则。如果单元格不包含任何数据，则将忽略其模板。（这意味着某些条件或操作不适用于该规则行。）读取规则行，直到出现空白行。一个工作表中可以存在多个RuleTable。第20行包含另一个关键字和一个值。这样的关键字的行位置无关紧要（大多数人将其放在顶部），但是其列应与应显示RuleTable或RuleSet关键字的列相同。在我们的情况下，C列被选择为重要的列，但可以使用A列来代替。</p><p>在上面的示例中，规则将如下所示呈现（因为它使用“ ObjectType”行）：</p><pre class="screen">//row 18
			rule "Cheese_fans_18"
			when
			Person(age=="42")
			Cheese(type=="stilton")
			then
			list.add("Old man stilton");
			end
</pre><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>禁忌<code class="code">age=="42"</code>和<code class="code">type=="stilton"</code>被解释为单个约束，将被添加到上方单元格中的相应ObjectType中。如果上面的单元格是跨度的，则一个“列”上可能存在多个约束。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5900"></a> 5.1.4。关键字和语法</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5903"></a> 5.1.4.1。模板的语法</h4></div></div></div><p>模板中内容的语法取决于它是CONDITION列还是ACTION列。在大多数情况下，分别与LHS或RHS的“香草” DRL相同。这意味着在LHS中，必须使用约束语言，而在RHS中，这是要执行的代码片段。</p><p>的<code class="code">$param</code>模板中使用占位符来指示将插入单元格数据的位置。您也可以使用<code class="code">$1</code>达到同样的效果。如果单元格包含逗号分隔的值列表。符号$ 1，$ 2等可用于指示将使用单元格中值列表中的哪个位置参数。</p><div class="example"><a id="d0e5916"></a><p class="title"><b>示例5.1内插单元数据</b></p><div class="example-contents"><p>如果模板为[Foo（bar == $ param）]，并且单元格为[42]，则结果将为[Foo（bar == 42）]。</p><p>如果模板为[Foo（bar <$ 1，baz == $ 2）]，单元格为[42,42]，则结果将为[Foo（bar> 42，baz == 42）]</p></div></div><br class="example-break"><p>对于条件：片段的呈现方式取决于上一行中可能存在ObjectType声明的条目。如果存在此类条目，则将这些片段呈现为对该ObjectType的单独约束。如果没有，则它们将按原样呈现（替换值）。如果仅输入一个纯字段（如上例所示），则它将假定这意味着相等。如果将另一个运算符放在代码段的末尾，则将在约束的末尾插入值，否则它将寻找<code class="code">$param</code>如前所述。</p><p>后果：片段的呈现方式还取决于紧靠其上方的行中条目的存在。如果没有条目，则输出仅是插值片段。如果存在某物（在上面的示例中通常是绑定变量或全局变量），则它将作为方法调用附加到该对象上（请参见上面的示例）。</p><p>通过下面给出的一些示例，这可能最容易理解。
        </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/spanned_column.png"></div></div><p>上面显示了Person ObjectType声明如何跨越电子表格中的2列，因此这两个约束都将显示为Person（age == ...，type == ...）。和以前一样，由于代码段中仅存在字段名称，因此它们意味着进行相等性测试。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/with_param.png"></div></div><p>上面的条件示例显示了如何使用插值将值放置在代码段中（在这种情况下，这将导致Person（age ==“ 42”））。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/operator_completion.png"></div></div><p>上面的条件示例表明，如果您自己将运算符放在最后，则这些值将自动放在运算符之后。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/with_binding.png"></div></div><p>可以在列之前放置一个绑定（约束将从下面的单元格中添加）。任何东西都可以放在ObjectType行中。（例如，这可能是后续电子表格列中各列的先决条件）。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/consequence.png"></div></div><p>这显示了如何通过简单的插值来完成结果：只需将单元格留空即可。（条件列也是如此。）使用这种样式，任何结果都可以放在结果中，而不仅仅是一个方法调用。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5957"></a> 5.1.4.2。关键词</h4></div></div></div><p>下表描述了与规则表结构相关的关键字。</p><div class="table"><a id="d0e5962"></a><p class="title"><b>表5.1。关键词</b></p><div class="table-contents"><table border="1" summary="Keywords"><colgroup><col><col><col></colgroup><thead><tr><th>关键词</th><th>描述</th><th>收录状态</th></tr></thead><tbody><tr><td>规则集</td><td>右边的单元格包含规则集名称。</td><td>仅一个;如果省略，它将默认。</td></tr><tr><td>顺序的</td><td>右边的单元格可以为true或false。如果为true，则使用显着性来确保规则从上到下触发。</td><td>可选的</td></tr><tr><td>进口</td><td>右侧的单元格包含用逗号分隔的要导入的Java类列表。</td><td>可选的</td></tr><tr><td>规则表</td><td>以RuleTable开头的单元格指示规则表定义的开始。实际规则表从下一行开始。规则表从左到右，从上到下读取，直到下一个空白行。</td><td>最后一个;如果还有更多，则将它们全部添加到一个规则集中。</td></tr><tr><td>条件</td><td>指示此列将用于规则条件。</td><td>每个规则表至少一个</td></tr><tr><td>行动</td><td>指示此列将用于规则后果。</td><td>每个规则表至少一个</td></tr><tr><td>优先</td><td>指示此列的值将设置规则行的“显着性”值。覆盖“顺序”标志。</td><td>可选的</td></tr><tr><td>持续时间</td><td>指示此列的值将设置规则行的持续时间值。</td><td>可选的</td></tr><tr><td>名称</td><td>指示此列的值将设置从该行生成的规则的名称。</td><td>可选的</td></tr><tr><td>功能</td><td>右边的单元格可以包含可以在规则摘要中使用的功能。Drools支持DRL中定义的功能，允许将逻辑嵌入规则中，并且无需进行硬编码即可更改，请谨慎使用。与常规DRL的语法相同。</td><td>可选的</td></tr><tr><td>变数</td><td>右边的单元格可以包含Drools支持的全局声明。这是一种类型，后跟一个变量名。（如果需要多个变量，请用逗号分隔。）</td><td>可选的</td></tr><tr><td>无回路或无回路</td><td>放在表的标题中，无循环或无循环都将完成相同的功能，即不允许规则（行）循环。为了使此选项正常运行，单元格中必须有一个值（true或false）才能使该选项生效。如果该单元格留空，则不会为该行设置此选项。</td><td>可选的</td></tr><tr><td>异或组</td><td>此列中的单元格值表示规则行属于给定的激活组。激活组意味着将仅触发命名组中的一个规则（即，第一个激活的规则将取消其他规则的激活）。</td><td>可选的</td></tr><tr><td>议程组</td><td>此列中的单元格值表示规则行属于给定的议程组。（这是控制规则组之间的流的一种方法-另请参见“规则流”）。</td><td>可选的</td></tr><tr><td>粗花丛</td><td>此列中的单元格值表示规则行属于给定的规则流组。</td><td>可选的</td></tr><tr><td>工作表</td><td>默认情况下，仅在第一个工作表中查找决策表。</td><td>不适用</td></tr></tbody></table></div></div><br class="table-break"><p>在下面，您将找到使用HEADER关键字的示例，这会影响为每一行生成的规则。请注意，标题名称在大多数情况下很重要。如果在其下面的单元格中未显示任何值，则该属性将不适用于该特定行（将被忽略）。</p><div class="screenshot"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Decision_Tables/Key.png" width="100%"></td></tr></tbody></table></div></div><p>以下是导入（以逗号分隔），变量（gloabls）（也以逗号分隔）和一个功能块（可以是多个功能-仅是普通的drl语法）的示例。它可以与“ RuleSet”关键字显示在同一列中，并且如果需要，可以显示在所有规则行的下方。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/keywords.png"></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6103"></a> 5.1.5。创建和集成基于电子表格的决策表</h3></div></div></div><p>使用基于电子表格的决策表的API在drools-decisiontables模块中。实际上只需要看一类：SpreadsheetCompiler。此类将采用各种格式的电子表格，并以DRL（然后可以按常规方式使用）生成规则。如果需要，可以仅使用SpreadsheetComiler生成部分规则文件，然后在事实完成后将其组合为完整的规则包（如果需要，可以将规则的技术和非技术方面分开）。</p><p>首先，可以将示例电子表格用作基础。或者，如果正在使用插件（Rule Workbench IDE），则向导可以从模板生成电子表格（要对其进行编辑，将需要使用与xls兼容的电子表格编辑器）。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/wizard.png"></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6116"></a> 5.1.6。在决策表中管理业务规则。</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6119"></a> 5.1.6.1。工作流程和协作。</h4></div></div></div><p>电子表格是完善的业务工具（已使用25年以上）。决策表可以使IT与领域专家之间保持紧密的协作，同时使业务分析师可以清楚地了解业务规则，这是关注点之间的理想分离。</p><p>通常，编写规则的整个过程（连同新的决策表）如下所示：</p><div class="orderedlist"><ol type="1"><li><p>业务分析师（从存储库或从IT）获取模板决策表</p></li><li><p>决策表业务语言描述输入到表中</p></li><li><p>大致输入决策表规则（行）</p></li><li><p>决策表将交给技术资源，后者将业务语言（描述）映射到脚本（当然，这可能涉及软件开发，如果它是新的应用程序或数据模型）</p></li><li><p>技术人员退回并与业务分析师一起审查修改。</p></li><li><p>业务分析师可以根据需要继续编辑规则行（也可以在列周围移动等）。</p></li><li><p>同时，技术人员可以开发规则的测试用例（与业务分析师联系），因为一旦系统运行，这些测试用例就可以用来验证规则和规则更改。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6148"></a> 5.1.6.2。使用电子表格功能</h4></div></div></div><p>Excel等应用程序的功能可用于协助将数据输入到电子表格中，例如验证字段。存储在其他工作表中的列表可以用于为单元格提供有效的值列表，如下图所示。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/lists.png"></div></div><p>某些应用程序提供的更改历史记录功能有限，但是建议也使用替代版本控制方法。随着时间的推移对规则进行更改时，将存档较旧的版本（为此存在许多解决方案，它们也是开源的，例如Subversion）。http://www.drools.org/Business+rules+in+decision+tables+解释</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6161"></a> 5.1.7。规则模板</h3></div></div></div><p>与决策表相关的（但不一定需要电子表格）是“规则模板”（在drools-templates模块中）。它们使用任何表格数据源作为规则数据源-填充模板以生成许多规则。例如，这既可以使用更灵活的电子表格，也可以使用现有数据库中的规则（以预先开发模板以生成规则为代价）。</p><p>使用规则模板，数据与规则是分离的，并且对规则的哪个部分由数据驱动没有限制。因此，尽管您可以做决策表中可以做的所有事情，但是您还可以执行以下操作：</p><div class="itemizedlist"><ul><li><p>将您的数据存储在数据库（或任何其他格式）中</p></li><li><p>根据数据中的值有条件地生成规则</p></li><li><p>将数据用于规则的任何部分（例如条件运算符，类名，属性名）</p></li><li><p>对同一数据运行不同的模板</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6181"></a> 5.1.7.1。类似于决策表的示例</h4></div></div></div><p>例如，显示了一个更经典的决策表，但没有任何隐藏的规则元数据行（因此，电子表格仅包含用于生成规则的原始数据）。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Decision_Tables/template1.png"></div></div><p>请参阅上述电子表格的示例下载中的“ ExampleCheese.xls”。</p><p>如果这是一个常规决策表，则在第1行之前以及第1和2行之间将包含隐藏的行，其中包含规则元数据。使用规则模板，数据与规则完全分开。这有两个方便的结果-您可以将多个规则模板应用于相同的数据，而您的数据完全不依赖于规则。那么模板是什么样的？</p><pre class="programlisting">
1  template header
2  age
3  type
4  log
5
6  package org.drools.examples.templates;
7
8  global java.util.List list;
9
10 template "cheesefans"
11
12 rule "Cheese fans_@{row.rowNumber}"
13 when
14    Person(age == @{age})
15    Cheese(type == "@{type}")
16 then
17    list.add("@{log}");
18 end
19
20 end template
	</pre><p>参考以上内容：</p><pre class="programlisting">
Line 1: all rule templates start with "template header"
Lines 2-4: following the header is the list of columns in the order they appear in the data. In this case we are calling the first column "age", the second "type" and the third "log".
Lines 5: empty line signifying the end of the column definitions
Lines 6-9: standard rule header text. This is standard rule DRL and will appear at the top of the generated DRL. Put the package statement and any imports and global definitions
Line 10: The "template" keyword signals the start of a rule template. There can be more than one template in a template file. The template should have a unique name.
Lines 11-18: The rule template - see below
Line 20: "end template" signifies the end of the template.
</pre><p>规则模板依靠MVEL使用@ {token_name}语法进行替换。当前有一个内置表达式@ {row.rowNumber}，它为每行数据提供唯一的编号，并使您能够生成唯一的规则名称。对于每行数据，将生成一条规则，其中数据中的值将替换模板中的标记。对于上面的示例数据，将生成以下规则文件：</p><pre class="programlisting">
package org.drools.examples.templates;

global java.util.List list;

rule "Cheese fans_1"
when
  Person(age == 42)
  Cheese(type == "stilton")
then
  list.add("Old man stilton");
end

rule "Cheese fans_2"
when
  Person(age == 21)
  Cheese(type == "cheddar")
then
  list.add("Young man cheddar");
end
</pre><p>运行此代码很简单：</p><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
DecisionTableConfiguration dtconf = KnowledgeBuilderFactory.newDecisionTableConfiguration();
dtconf.setInputType( DecisionTableInputType.XLS );
dtconf.setWorksheetName( "Tables_2" );
kbuilder.add( ResourceFactory.newInputStreamResource( getSpreadsheetStream() ),
              ResourceType.DTABLE,
              dtconf );

Collection&lt;KnowlegePackage&gt; kpkg = kbuilder.getKnowlegePackages();
</pre><p>我们创建一个ExternalSpreadsheetCompiler对象，并使用它来将电子表格与规则合并。这两个整数参数指示数据实际开始的列和行-在我们的示例中为第2列，第2行（即B2）</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6212"></a> 5.2。范本</h2></div></div></div><p>如果发现有一组规则遵循RHS上的模式，约束和动作的相同排列，只是对象或字段的常量或名称不同，那么您可能会考虑采用Drool的规则模板功能来生成实际规则。您将编写一个<span class="emphasis"><em>规则模板</em></span>文件，其中包含<span class="emphasis"><em>规则</em></span>的文本框架，并将Drools模板编译器与一系列对象结合使用，这些对象提供了规则“实例化”规则的实际值。</p><p>该机制与宏处理器的功能非常相似。模板扩展提供的主要优点是，它可以很好地集成到知识资源的整体处理中。</p><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>这是一项实验功能。特别是，API可能会发生变化。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6225"></a> 5.2.1。规则模板文件</h3></div></div></div><p>规则模板文件以定义占位符的头开始，或者为实例化期间要插入的字符串定义<span class="emphasis"><em>正式的模板参数</em></span> 。第一行之后，总是包含<strong class="kw"><code>template header</code></strong> ，您应该编写多行，每行包含一个参数名称。</p><div class="example"><a id="d0e6236"></a><p class="title"><b>示例5.2规则模板文件：模板头</b></p><div class="example-contents"><pre class="programlisting">
<span class="bold"><strong>template header</strong></span>
<span class="emphasis"><em>parameter-name-1</em></span>
...
<span class="emphasis"><em>parameter-name-n</em></span>
...</pre></div></div><br class="example-break"><p>模板标题后跟要复制的文本，并插入实际参数。它可能以<strong class="kw"><code>package</code></strong>语句，然后添加一些其他行。这些可以分为一个或多个模板，每个模板在一对匹配项之间<strong class="kw"><code>template</code></strong>和<strong class="kw"><code>end template</code></strong>陈述。的<strong class="kw"><code>template</code></strong>接受一个参数，该参数为模板添加名称。该名称可以是简单的未加引号的名称，也可以是用双引号引起来的任意字符串。这些行之间的模板文本可能包含一个或多个规则，构成了扩展的“原始材料”。</p><div class="example"><a id="d0e6264"></a><p class="title"><b>示例5.3规则模板文件：模板</b></p><div class="example-contents"><pre class="programlisting">
<span class="bold"><strong>template header</strong></span>
<span class="bold"><strong><span class="emphasis"><em>parameter-name-1</em></span></strong></span>
...
<span class="emphasis"><em>parameter-name-n</em></span>
<span class="bold"><strong>package ...</strong></span>     # optional
<span class="emphasis"><em>header text</em></span>    # optional
<span class="bold"><strong>template</strong></span> <span class="emphasis"><em>template-name</em></span>
...
// template text
...
<span class="bold"><strong>end template</strong></span>
...</pre></div></div><br class="example-break"><p>产生的文本将从包装行开始，并在包装行之后加上标题文本（如果有）。然后，将分别扩展每个模板文本，从而为每个实际参数集生成一组规则。因此，模板部分的结构会影响所生成规则的顺序，因为生成器会在部分上进行迭代，然后在一组实际参数上进行迭代。</p><p>任何插值都发生在一对<strong class="kw"><code>template</code></strong>和<strong class="kw"><code>end template</code></strong>语句，扩展此模板时。扫描模板文本中是否出现根据以下内容编写的<span class="emphasis"><em>参数扩展</em></span> ：</p><pre class="programlisting">
<span class="bold"><strong>@{<span class="emphasis"><em>parameter-name</em></span>}</strong></span></pre><p>“ @ {”和“}”之间的名称应该是模板标题中定义的参数名称之一。替换在任何地方都有效，即使在字符串文字中也是如此。</p><p>一个重要的参数可用，而不必包含在提供实际值的数据源中。参数替换</p><pre class="programlisting">
<span class="bold"><strong>@{row.rowNumber}</strong></span></pre><p>扩展为整数0、1、2等，从而为从参数集派生的实例化提供了唯一的区别。您将使用它作为每个规则名称的一部分，因为如果没有这种预防措施，将会有重复的规则名称。（当然，您可以自由使用自己的标识作为附加参数。）</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6322"></a> 5.2.2。扩展模板</h3></div></div></div><p>要扩展模板，您必须准备一个数据源。如上一节所述，它可以是电子表格。在这里，我们将专注于Java对象驱动的扩展。有两种直接的方法可以为一组固定的名称提供值：JavaBeans风格的Java对象和Maps。他们都可以安排在一个<code class="code">Collection</code> ，其元素将在扩展期间进行处理，从而为每个元素实例化。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6330"></a> 5.2.2.1。从Java对象实例化</h4></div></div></div><p>您可以使用Java对象，该对象提供与模板文件的所有参数名称相对应的getter方法。例如，如果您已定义标题</p><pre class="programlisting">
template header
type
limit
word</pre><p>可以使用以下Java类：</p><pre class="programlisting">
public class ParamSet {
    //...
    public ParamSet( String t, int l, boolean w ) {
        //...
    }
    public String  getType(){...}
    public int     getLimit(){...}
    public boolean isWord(){...}
}</pre><p>尽管插值是纯文本操作，但提供的实际值可以是任何类型，只要该类型提供了合理的<code class="code">toString()</code>方法。（对于简单类型，来自的相关类的同名静态方法<code class="code">java.lang</code>用来。）</p><p>假设我们已经创建了一个<code class="code">Collection<ParamSet></code>用于模板文件<code class="code">template.drl</code> ，我们现在可以请求扩展它。</p><pre class="programlisting">
Collection&lt;ParamSet&gt; paramSets = new ArrayList&lt;ParamSet&gt;();
// populate paramSets
paramSets.add( new ParamSet( "Foo", 42, true ) );
paramSets.add( new ParamSet( "Bar", 13, false ) );
ObjectDataCompiler converter = new ObjectDataCompiler();
InputStream templateStream =
    this.getClass().getResourceAsStream( "template.drl" );
String drl = converter.compile( objs, templateStream );</pre>结果字符串包含扩展的规则文本。您可以将其写入文件并照常进行，但也可以将其提供给<code class="code">KnowledgeBuilder</code>并继续生成的知识包。

        <pre class="programlisting">
KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();
KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
Reader rdr = new StringReader( drl );
kBuilder.add( ResourceFactory.newReaderResource( rdr ), ResourceType.DRL );
if( kBuilder.hasErrors() ){
    // ...
    throw new IllegalStateException( "DRL errors" );
}
kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6363"></a> 5.2.2.2。地图实例化</h4></div></div></div><p>一种<code class="code">Map</code>提供用于替代模板参数的值的键集应与所有参数名称匹配。同样，价值可以来自任何类别，只要它们能提供良好的<code class="code">toString()</code>方法。扩展将使用相同的方法，只是组成地图集合的方式不同。</p><pre class="programlisting">
Collection&lt;Map&lt;String,Object&gt;&gt; paramMaps = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();
// populate paramMaps
ObjectDataCompiler converter = new ObjectDataCompiler();
InputStream templateStream =
    this.getClass().getResourceAsStream( "template.drl" );
String drl = converter.compile( objs, templateStream );</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6376"></a> 5.2.3。例</h3></div></div></div><p>以下示例说明了模板扩展。它基于类的简单对象<code class="code">Item</code>包含几个整数字段和一个<code class="code">enum</code>类型字段<code class="code">ItemCode</code> 。</p><pre class="programlisting">
public class Item {
    // ...
    public Item( String n, int p, int w, ItemCode c ){...}

    public String   getName() {...}
    public int      getWeight() {...}
    public int      getPrice() {...}
    public ItemCode getCode() {...}
}

public enum ItemCode {
    LOCK,
    STOCK,
    BARREL;
}</pre><p>规则模板包含一个规则。注意，范围测试的字段名称是一个参数，它使我们能够为不同字段实例化模板。</p><pre class="programlisting">
template header
field
lower
upper
codes

package range;
template "inRange"
rule "is in range @{row.rowNumber}"
when
    Item( $name : name, $v : @{field} &gt;= @{lower} &amp;&amp; &lt;= @{upper}, $code : code @{codes} )
then
    System.out.println( "Item " + $name + " @{field} in range: " + $v + " code: " + $code );
end
end template</pre><p>下一个代码段来自应用程序，其中必须设置几个参数集。首先，有课<code class="code">ParamSet</code> ，用于存储一组实际参数。</p><pre class="programlisting">
public class ParamSet {
    //...
    private EnumSet&lt;ItemCode&gt; codeSet;
	
    public ParamSet( String f, int l, int u, EnumSet&lt;ItemCode&gt; cs ){...}

    public String getField() { return field; }
    public int getLower() { return lower; }
    public int getUpper() { return upper; }

    public String getCodes(){
        StringBuilder sb = new StringBuilder();
        String conn = "";
        for( ItemCode ic: codeSet ){
             sb.append( conn ).append( " == ItemCode." ).append( ic );
             conn = " ||";
        }
        return sb.toString();
    }	
}</pre><p>注意方法<code class="code">getCodes()</code>确实返回了<code class="code">EnumSet<ItemCode></code>字段值作为<code class="code">String</code>表示多重限制的值，即测试值列表中的一个。</p><p>扩展模板，将生成的DRL文本传递给Knowledge Builder以及将生成的知识包添加到知识库的任务是通用的。实用类<code class="code">Expander</code>使用知识库来解决这个问题<code class="code">InputStream</code>与规则模板和参数集的集合。</p><pre class="programlisting">
public class Expander {
	
    public void expand( KnowledgeBase kBase, InputStream is, Collection&lt;?&gt; act )
        throws Exception {
        ObjectDataCompiler converter = new ObjectDataCompiler();		
        String drl = converter.compile( act, is );
        
        KnowledgeBuilder kBuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
        Reader rdr = new StringReader( drl );
        kBuilder.add( ResourceFactory.newReaderResource( rdr ), ResourceType.DRL );
        if( kBuilder.hasErrors() ){
            for( KnowledgeBuilderError err: kBuilder.getErrors() ){
                System.err.println( err.toString() );
            }
            throw new IllegalStateException( "DRL errors" );
        }
        kBase.addKnowledgePackages( kBuilder.getKnowledgePackages() );
    }
}</pre><p>现在，我们已经准备好使用一些生成的规则来准备知识库。首先，我们定义几个参数集<code class="code">ParamSet</code>对象，并将其添加到<code class="code">List</code> ，这将传递给<code class="code">expand</code>上面显示的方法。然后我们启动一个有状态的会话，插入一些<code class="code">Item</code> ，然后观察会发生什么。</p><pre class="programlisting">
Collection&lt;ParamSet&gt; cfl = new ArrayList&lt;ParamSet&gt;();
cfl.add( new ParamSet( "weight",  10,  99, EnumSet.of( ItemCode.LOCK, ItemCode.STOCK ) ) );
cfl.add( new ParamSet( "price",   10,  50, EnumSet.of( ItemCode.BARREL ) ) );

KnowledgeBase kBase = KnowledgeBaseFactory.newKnowledgeBase();
Expander ex = new Expander();
InputStream dis = new FileInputStream( new File( "rangeTemp.drl" ) );
ex.expand( kBase, dis, cfl );
        
StatefulKnowledgeSession session = kBase.newStatefulKnowledgeSession();
session.insert( new Item( "A", 130,  42, ItemCode.LOCK ) );
session.insert( new Item( "B",  44, 100, ItemCode.STOCK ) );
session.insert( new Item( "C", 123, 180, ItemCode.BARREL ) );
session.insert( new Item( "D",  85,   9, ItemCode.LOCK ) );
        
session.fireAllRules();</pre><p>请注意，这两个结果规则涉及<span class="emphasis"><em>不同的</em></span>字段，一个涉及项目的重量，另一个涉及其价格。 -以下是输出。</p><pre class="programlisting">
Item E price in range: 25 code: BARREL
Item A weight in range: 42 code: LOCK</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6447"></a>第六章Java规则引擎API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e6450">6.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e6465">6.2。如何使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6470">6.2.1。建立和注册RuleExecutionSets</a></span></dt><dt><span class="section"><a href="#d0e6503">6.2.2。使用有状态和无状态RuleSession</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6538">6.3。参考文献</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6450"></a> 6.1。介绍</h2></div></div></div><p>Drools提供了Java Rule Engine API（称为JSR94）的实现，该实现允许从单个API支持多个规则引擎。 JSR94不以任何方式处理规则语言本身。W3C正在研究<a class="ulink" href="http://www.w3.org/TR/2006/WD-rif-ucr-20060323/">规则交换格式（RIF）</a> ，而OMG已开始研究基于<a class="ulink" href="http://ruleml.org/">RuleML</a>的标准。最近，Haley Systems还提出了一种称为RML的规则语言标准。</p><p>应当记住，JSR94标准代表跨规则引擎的功能中的“最小公分母”。这意味着JSR94 API中的功能少于标准Drools API中的功能。因此，通过使用JSR94，您将失去使用Drools规则引擎的全部功能的优势。由于JSR94的非常基本的功能集，有必要通过属性映射公开其他功能，例如全局性，以及对DRL，DSL和XML的支持。这引入了不可移植的功能。此外，由于JSR94不提供规则语言，因此您只解决了切换规则引擎复杂性的很小一部分而却获得很少的收益。因此，尽管我们支持JSR94，但对于那些坚持使用JSR94的人，我们强烈建议您根据Drools API进行编程。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6465"></a> 6.2。如何使用</h2></div></div></div><p>使用JSR94有两个部分。第一部分是管理API，用于构建和注册RuleExecutionSet对象，第二部分是这些RuleExecutionSet的运行时会话执行。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6470"></a> 6.2.1。建立和注册RuleExecutionSets</h3></div></div></div><p>RuleServiceProviderManager管理RuleServiceProvider的注册和检索。使用Class.forNamem加载类时，将通过静态块自动注册Drools RuleServiceProvider实现，其方式与JDBC驱动程序大致相同。</p><div class="example"><a id="d0e6476"></a><p class="title"><b>示例6.1自动RuleServiceProvider注册</b></p><div class="example-contents"><pre class="programlisting">// RuleServiceProviderImpl is registered to "http://drools.org/"
// via a static initialization block
Class.forName("org.drools.jsr94.rules.RuleServiceProviderImpl");

// Get the rule service provider from the provider manager.
RuleServiceProvider ruleServiceProvider =
  RuleServiceProviderManager.getRuleServiceProvider("http://drools.org/");</pre></div></div><p><br class="example-break">RuleServiceProvider提供对RuleRuntime和RuleAdministrator API的访问。 RuleAdministrator提供了一个用于管理RuleExecutionSet对象的管理API，从而可以注册一个RuleExecutionSet，然后可以通过RuleRuntime对其进行检索。</p><p>首先，您需要先创建RuleExecutionSet，然后才能注册它。 RuleAdministrator提供工厂方法以返回空的LocalRuleExecutionSetProvider或RuleExecutionSetProvider。应该使用LocalRuleExecutionSetProvider从不可序列化的本地源（例如Streams）加载RuleExecutionSet。RuleExecutionSetProvider可用于从可序列化的源（例如DOM元素或包）中加载RuleExecutionSet。两者均为“ ruleAdministrator.getLocalRuleExecutionSetProvider（null）;”和“ ruleAdministrator.getRuleExecutionSetProvider（null）;”将null作为参数，因为当前未使用这些方法的属性映射。</p><div class="example"><a id="d0e6484"></a><p class="title"><b>示例6.2使用RuleAdministrator API注册LocalRuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministrator ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider =
  ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create the RuleExecutionSet for the drl
RuleExecutionSet ruleExecutionSet =
  ruleExecutionSetProvider.createRuleExecutionSet( drlReader, null );
</pre></div></div><br class="example-break"><p>上例中的“ ruleExecutionSetProvider.createRuleExecutionSet（reader，null）”对属性映射采用null参数；但是，它实际上可以用于为传入源提供配置。传递null时，将使用默认值将输入作为drl加载。映射的允许键为“源”和“ dsl”。键“ source”采用“ drl”或“ xml”作为其值；您将“源”设置为“ drl”以加载DRL，或者将“源”设置为“ xml”以加载XML源； “ xml”将忽略任何“ dsl”键/值设置。“ dsl”键可以将Reader或String（dsl的内容）作为值。</p><div class="example"><a id="d0e6491"></a><p class="title"><b>示例6.3注册LocalRuleExecutionSet时指定DSL</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministration ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider =
  ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create a Reader for the dsl and a put in the properties map
URL dslUrl = new URL("http://mydomain.org/sources/myrules.dsl");
Reader dslReader = new InputStreamReader( dslUrl.openStream()  );
Map properties = new HashMap();
properties.put( "source", "drl" );
properties.put( "dsl", dslReader );

// Create the RuleExecutionSet for the drl and dsl
RuleExecutionSet ruleExecutionSet =
  ruleExecutionSetProvider.createRuleExecutionSet( reader, properties );
</pre></div></div><br class="example-break"><p>注册RuleExecutionSet时，必须指定用于检索它的名称。还有一个用于传递属性的字段，当前尚未使用-因此只需传递null。</p><div class="example"><a id="d0e6498"></a><p class="title"><b>示例6.4注册RuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Register the RuleExecutionSet with the RuleAdministrator
String uri = ruleExecutionSet.getName();
ruleAdministrator.registerRuleExecutionSet(uri, ruleExecutionSet, null);</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6503"></a> 6.2.2。使用有状态和无状态RuleSession</h3></div></div></div><p>从RuleServiceProvider获得的运行时用于创建有状态和无状态规则引擎会话。</p><div class="example"><a id="d0e6508"></a><p class="title"><b>示例6.5获取RuleRuntime</b></p><div class="example-contents"><pre class="programlisting">RuleRuntime ruleRuntime = ruleServiceProvider.getRuleRuntime();</pre></div></div><br class="example-break"><p>要创建规则会话，必须使用两个RuleRuntime公共常量之一。这些是“ RuleRuntime。STATEFUL_SESSION_TYPE”和“ RuleRuntime。STATELESS_SESSION_TYPE”，将URI随附到您要为其实例化RuleSession的RuleExecutionSet。属性映射可以为null，也可以用于指定全局变量，如下一节所示。createRuleSession（...）方法返回一个RuleSession实例，然后必须将其强制转换为StatefulRuleSession或StatelessRuleSession。</p><div class="example"><a id="d0e6515"></a><p class="title"><b>示例6.6有状态的规则</b></p><div class="example-contents"><pre class="programlisting">(StatefulRuleSession) session =
  ruleRuntime.createRuleSession( uri,
                                 null,
                                 RuleRuntime.STATEFUL_SESSION_TYPE );
session.addObject( new PurchaseOrder( "lots of cheese" ) );
session.executeRules();</pre></div></div><br class="example-break"><p>StatelessRuleSession有一个非常简单的API。您只能通过传递对象列表和可选过滤器来调用executeRules（List list），然后返回生成的对象。</p><div class="example"><a id="d0e6522"></a><p class="title"><b>示例6.7无状态</b></p><div class="example-contents"><pre class="programlisting">(StatelessRuleSession) session =
  ruleRuntime.createRuleSession( uri,
                                 null,
                                 RuleRuntime.STATELESS_SESSION_TYPE );
List list = new ArrayList();
list.add( new PurchaseOrder( "even more cheese" ) );

List results = new ArrayList();
results = session.executeRules( list );</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6527"></a> 6.2.2.1。全球</h4></div></div></div><p>通过使用传递给RuleSession工厂方法的属性映射，可以使用不可移植的方式通过JSR94支持全局变量。必须先在DRL或XML文件中定义全局变量，否则将引发异常。键代表在DRL或XML中声明的标识符，并且值是您希望在执行中使用的实例。在以下示例中，结果收集在java.util中。用作全局的列表：</p><pre class="programlisting">java.util.List globalList = new java.util.ArrayList( );
java.util.Map map = new java.util.HashMap( );
map.put( "list", globalList ); 
//Open a stateless Session
StatelessRuleSession srs =
  (StatelessRuleSession) runtime.createRuleSession( "SistersRules",
                                                    map,
                                                    RuleRuntime.STATELESS_SESSION_TYPE );
...
// Persons added to List
// call executeRules( ) giving a List of Objects as parameter
// There are rules which will put Objects in the List
// fetch the list from the map
List list = (java.util.List) map.get("list");</pre><p>不要忘记在DRL中声明全局“列表”：</p><pre class="programlisting">package SistersRules; 
import org.drools.jsr94.rules.Person; 
global java.util.List list
rule FindSisters 
when 
    $person1 : Person ( $name1:name ) 
    $person2 : Person ( $name2:name ) 
    eval( $person1.hasSister($person2) ) 
then 
    list.add($person1.getName() + " and " + $person2.getName() +" are sisters"); 
    assert( $person1.getName() + " and " + $person2.getName() +" are sisters"); 
end</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6538"></a> 6.3。参考文献</h2></div></div></div><p>如果您需要有关JSR 94的更多信息，请参考以下参考</p><div class="orderedlist"><ol type="1"><li><p>Java规则引擎API的官方JCP规范（JSR 94）</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.jcp.org/en/jsr/detail?id=94">http://www.jcp.org/en/jsr/detail?id=94</a></p></li></ul></div></li><li><p>Java Rule Engine API文档</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.javarules.org/api_doc/api/index.html">http://www.javarules.org/api_doc/api/index.html</a></p></li></ul></div></li><li><p>底线的逻辑：Drools项目简介。由N. Alex Rupp撰写，于2004年在TheServiceSide.com上发布</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Drools">http://www.theserverside.com/articles/article.tss?l=Drools</a></p></li></ul></div></li><li><p>Java Rule Engine API（JSR 94）入门：转向基于规则的应用程序。由Qusay H. Mahmoud博士于2005年在Sun Developer Network上发布</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html">http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html</a></p></li></ul></div></li><li><p>Jess和javax.rules API。由Ernest Friedman-Hill于2003年在TheServerSide.com上发布</p><div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Jess">http://www.theserverside.com/articles/article.tss?l=杰西</a></p></li></ul></div></li></ol></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6584"></a>第7章。规则IDE（Eclipse）</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e6602">7.1。功能概述</a></span></dt><dt><span class="section"><a href="#d0e6658">7.2。创建规则项目</a></span></dt><dt><span class="section"><a href="#d0e6681">7.3。创建新规则和向导</a></span></dt><dt><span class="section"><a href="#d0e6702">7.4。文字规则编辑器</a></span></dt><dt><span class="section"><a href="#d0e6725">7.5。指导编辑器（规则GUI）</a></span></dt><dt><span class="section"><a href="#d0e6742">7.6。流口水的意见</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6759">7.6.1。工作记忆视图</a></span></dt><dt><span class="section"><a href="#d0e6773">7.6.2。议程视图</a></span></dt><dt><span class="section"><a href="#d0e6787">7.6.3。全局数据视图</a></span></dt><dt><span class="section"><a href="#d0e6801">7.6.4。审核视图</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6885">7.7。领域特定语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6892">7.7.1。编辑语言</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6915">7.8。Rete视图</a></span></dt><dt><span class="section"><a href="#d0e6931">7.9。大DRL文件</a></span></dt><dt><span class="section"><a href="#d0e6947">7.10。调试规则</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6958">7.10.1。创建断点</a></span></dt><dt><span class="section"><a href="#d0e6972">7.10.2。调试规则</a></span></dt></dl></dd></dl></div><p>基于Eclipse的IDE为开发人员（以及技术含量很高的用户）提供了一种环境，可以编辑和测试各种格式的规则，并将其与他们的应用程序深度集成。如果您更喜欢业务规则和Web工具，则需要查看BRMS（但同时使用BRMS和IDE并不罕见）。</p><p>Drools IDE是作为Eclipse插件提供的，它使您可以在Eclipse中编写和管理规则，以及将规则与应用程序集成。这是一个可选工具，并非所有组件都需要使用，您可以使用与您相关的组件。Drools IDE还是Red Hat Developer Studio（以前称为JBoss IDE）的一部分。</p><p>本指南将涵盖JBoss Drools的一些功能，涉及到IDE所涉及的范围（假定读者对规则引擎，特别是Drools有所了解）。重要的是要注意，规则引擎的基础功能都不依赖于Eclipse，并且集成商可以像往常一样自由使用他们选择的工具！例如，许多人将IntelliJ与规则一起使用。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>您可以从zip下载或从更新站点获得该插件。请参阅有关安装的章节。</p></div><div class="figure"><a id="d0e6596"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-IDE/all.jpg" width="100%" alt="总览"></td></tr></tbody></table></div></div><p class="title"><b>图7.1。总览</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6602"></a> 7.1。功能概述</h2></div></div></div><p>规则IDE具有以下功能</p><div class="orderedlist"><ol type="1"><li><p>文字/图形规则编辑器</p><div class="orderedlist"><ol type="a"><li><p>知道DRL语法并提供内容帮助（包括轮廓视图）的编辑器</p></li><li><p>知道DSL（域特定语言）扩展的编辑器，并提供内容帮助。</p></li></ol></div></li><li><p>RuleFlow图形编辑器</p><p>您可以编辑表示流程（规则流）的可视图。然后可以将RuleFlow应用于您的规则包以进行命令式控制。</p></li><li><p>快速创建向导</p><div class="orderedlist"><ol type="a"><li><p>一个“规则”项目</p></li><li><p>规则资源，无论是DRL文件还是“指导规则编辑器”文件（.brl）</p></li><li><p>特定领域的语言</p></li><li><p>决策表</p></li><li><p>规则流</p></li></ol></div></li><li><p>特定领域的语言编辑器</p><div class="orderedlist"><ol type="a"><li><p>创建和管理从用户语言到规则语言的映射</p></li></ol></div></li><li><p>规则验证</p><div class="orderedlist"><ol type="a"><li><p>输入规则后，规则将在后台“构建”，并在可能的情况下通过问题视图报告错误</p></li></ol></div></li></ol></div><p>以上功能利用了Eclipse基础结构和功能，并且具有Eclipse的所有功能。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6658"></a> 7.2。创建规则项目</h2></div></div></div><p>新项目向导的目的是建立一个可执行的脚手架项目，以立即开始使用规则。这将设置一个基本结构，类路径，示例规则和测试用例，以帮助您入门。</p><div class="figure"><a id="d0e6663"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_project1.jpg" align="middle" alt="新规则项目脚手架"></div></div><p class="title"><b>图7.2。新规则项目脚手架</b></p></div><br class="figure-break"><p>选择创建新的“规则项目”时，您可以选择向其中添加一些默认工件，例如规则，决策表，规则流等。这些可以作为起点，并几乎立即为您提供可执行文件，然后可以对其进行修改并根据需要进行调整。最简单的情况（世界规则）如下所示。此时，请随时尝试使用该插件。</p><div class="figure"><a id="d0e6671"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_project2.png" align="middle" alt="新规则项目结果"></div></div><p class="title"><b>图7.3。新规则项目结果</b></p></div><br class="figure-break"><p>新创建的项目在src / rules目录中包含一个示例规则文件（Sample.drl）和一个示例Java文件（DroolsTest.java），可用于在Drools引擎中执行规则。您可以在com.sample软件包的src / java文件夹中找到它。在执行过程中所需的所有其他jar也会添加到名为Drools Library的自定义类路径容器中的类路径中。规则根本不必保留在“ Java”项目中，对于已经使用Eclipse作为其Java IDE的人们来说，这只是一个方便。</p><p>重要说明：Drools插件为您的Eclipse实例添加了“ Drools Builder”功能。这意味着您可以在任何将在资源更改时构建和验证规则的项目上启用构建器。使用“规则项目向导”会自动发生这种情况，但是您也可以在任何项目上手动启用它。这样做的一个缺点是，如果您的规则文件包含大量规则（每个文件超过500条规则），则意味着后台构建器可能会做大量工作来为每个更改构建规则。这里的一个选项是关闭构建器，或将大规则放入.rule文件，您仍可以在其中使用规则编辑器，但不会在后台构建它们。要完全验证规则，您当然需要在单元测试中运行它们。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6681"></a> 7.3。创建新规则和向导</h2></div></div></div><p>您可以创建一个简单的规则（如空文本“ .drl”文件），或使用向导来创建规则。可以使用Control + N调用向导菜单，也可以通过从工具栏中选择向导菜单来调用该向导菜单，该菜单中带有JBoss Drools图标。</p><div class="figure"><a id="d0e6686"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/wizards.jpg" align="middle" alt="向导菜单"></div></div><p class="title"><b>图7.4。向导菜单</b></p></div><br class="figure-break"><p>该向导将询问用于生成规则资源的一些基本选项。这些只是提示-您以后可以改变主意。为了存储规则文件，通常将创建目录src / rules并创建适当命名的子目录。软件包名称是强制性的，类似于Java中的软件包名称。即，它建立了一个用于对相关规则进行分组的名称空间。</p><div class="figure"><a id="d0e6694"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/new_rule.jpg" align="middle" alt="新规则向导"></div></div><p class="title"><b>图7.5。新规则向导</b></p></div><br class="figure-break"><p>该向导的结果是一个规则框架，供您扩展。与所有向导一样，它们是可选的帮助-如果您不需要，则不必使用它们。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6702"></a> 7.4。文字规则编辑器</h2></div></div></div><p>规则编辑器是规则管理者和开发人员将花费大部分时间的地方。规则编辑器遵循Eclipse中普通文本编辑器的模式，具有文本编辑器的所有惯用功能。最重要的是，规则编辑器提供了弹出内容帮助。您可以通过按Control + Space的“常规”方式调用弹出式内容帮助。</p><div class="figure"><a id="d0e6707"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/editor1.jpg" align="middle" alt="运行中的规则编辑器"></div></div><p class="title"><b>图7.6。运行中的规则编辑器</b></p></div><br class="figure-break"><p>规则编辑器适用于扩展名为.drl（或.rule）的文件。通常，这些规则包含相关规则，但也可以在单个文件中包含规则，如果愿意，可以将它们放在同一包“名称空间”中进行分组。这些DRL文件是纯文本文件。</p><p>您可以从上面的示例中看到规则组正在使用域特定语言。注意expander关键字，它告诉规则编译器查找具有该名称的dsl文件，以解析规则语言。即使使用域特定语言（DSL），规则仍会以纯文本的形式存储（如您在屏幕上看到的那样），这可以简化规则和版本的管理，例如，比较规则的版本。</p><p>编辑器具有大纲视图，该大纲视图与规则的结构保持同步；它会在保存时更新。这提供了一种快速浏览名称的规则的方法，即使在可能包含数百个规则的文件中也是如此。默认情况下，项目按字母顺序排序。</p><div class="figure"><a id="d0e6719"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/outline.jpg" align="middle" alt="规则大纲视图"></div></div><p class="title"><b>图7.7。规则大纲视图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6725"></a> 7.5。指导编辑器（规则GUI）</h2></div></div></div><p>Drools IDE（从版本4开始）的一项新功能是规则的引导式编辑器。这类似于BRMS中可用的基于Web的编辑器。它允许您基于对象模型以GUI驱动的方式构建规则。</p><div class="figure"><a id="d0e6730"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/guidededitor1.png" align="middle" alt="指导编辑"></div></div><p class="title"><b>图7.8。指导编辑</b></p></div><br class="figure-break"><p>要以这种方式创建规则，请使用向导菜单。它将创建一个.brl文件的实例，并在向导编辑器中将其打开。该编辑器基于与.brl文件位于同一目录中的.package文件工作。在此“包”文件中，您具有包名称和导入语句-就像在普通DRL文件顶部一样。第一次创建brl规则时，将需要用您感兴趣的事实类填充软件包文件。一旦掌握了这些信息，向导编辑器将可以提示您有关事实及其字段，以便您可以以图形方式构建规则。</p><p>指导的编辑器可以处理您配置的模型类（或事实类）。然后，它可以将您以图形方式输入的规则“呈现”到DRL。您可以直观地执行此操作-并将其用作学习DRL的基础，也可以使用它直接构建Brl的规则。一种实现方法是使用drools-ant模块，它是一个ant任务，它将作为规则包在文件夹中创建所有规则资产，以便您随后可以将其部署为二进制文件。另外，您可以使用以下代码片段将brl转换为drl规则。</p><pre class="programlisting">BRXMLPersitence read = BRXMLPersitence.getInstance();
BRDRLPersistence write = BRDRLPersistence.getInstance();
String brl = ... // read from the .brl file as needed...
String outputDRL = write.marshall(read.unmarshal(brl));
// Pass the outputDRL to the PackageBuilder, as usual</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6742"></a> 7.6。流口水的意见</h2></div></div></div><p>使用Drools引擎调试应用程序时，这些视图可用于检查Drools引擎本身的状态：工作内存视图，议程视图和全局数据视图。为了能够使用这些视图，请在调用工作内存的代码中创建断点。例如，您在其中调用workingMemory.fireAllRules（）的行就是不错的选择。如果调试器在该连接点处停止，则应在调试变量视图中选择工作内存变量。然后可用的视图可用于显示所选工作存储器的详细信息：</p><div class="orderedlist"><ol type="1"><li><p>工作记忆视图显示了Drools工作记忆的所有元素。</p></li><li><p>议程视图显示了议程上的所有元素。对于议程中的每个规则，都会显示规则名称和绑定变量。</p></li><li><p>全局数据视图显示了当前在Drools工作存储器中定义的所有全局数据。</p></li></ol></div><p>审核视图可用于以树形式显示包含在规则引擎执行期间记录的事件的审核日志。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6759"></a> 7.6.1。工作记忆视图</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/workingMemory.png"></div><p>工作内存视图显示Drools引擎的工作内存中的所有元素。</p><p>将在视图的右侧添加一个操作，以自定义显示的内容：</p><div class="orderedlist"><ol type="1"><li><p>“显示逻辑结构”切换显示工作存储器中元素的逻辑结构或所有详细信息。逻辑结构允许以更明显的方式可视化元素集。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6773"></a> 7.6.2。议程视图</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/agenda.png"></div><p>议程视图显示了议程上的所有元素。对于议程中的每个规则，都会显示规则名称和绑定变量。</p><p>将在视图的右侧添加一个操作，以自定义显示的内容：</p><div class="orderedlist"><ol type="1"><li><p>显示逻辑结构切换显示议程项目的逻辑结构或其所有详细信息。逻辑结构允许例如以更明显的方式可视化元素集。AgendaItems的逻辑结构显示了由AgendaItem表示的规则，以及该规则中使用的所有参数的值。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6787"></a> 7.6.3。全局数据视图</h3></div></div></div><div class="mediaobject"><img src="images/Chapter-IDE/globals.png"></div><p>全局数据视图显示了当前在Drools引擎中定义的所有全局数据。</p><p>将在视图的右侧添加一个操作，以自定义显示的内容：</p><div class="orderedlist"><ol type="1"><li><p>“显示逻辑结构”切换显示工作存储器中元素的逻辑结构或所有详细信息。逻辑结构允许例如以更明显的方式可视化元素集。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6801"></a> 7.6.4。审核视图</h3></div></div></div><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-IDE/audit.jpg" width="100%"></td></tr></tbody></table></div><p>审核视图可显示审核日志，该日志可以在执行规则引擎时选择创建。要创建审核日志，请使用以下代码：</p><pre class="programlisting">WorkingMemory workingMemory = ruleBase.newWorkingMemory();
// Create a new Working Memory Logger, that logs to file.
WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger(workingMemory);
// An event.log file is created in the subdirectory log (which must exist)
// of the working directory.
logger.setFileName( "log/event" );

workingMemory.assertObject(...);
workingMemory.fireAllRules();

// stop logging
logger.writeToDisk();</pre><p>通过单击“打开日志”操作（“审核视图”中的第一个图标）打开日志，然后选择文件。现在，“审核视图”显示了在规则执行期间记录的所有事件。有不同类型的事件，每种事件都有不同的图标：</p><div class="orderedlist"><ol type="1"><li><p>插入对象，绿色方块：<span class="inlinemediaobject"><img src="images/Chapter-IDE/greensquare.GIF"></span></p></li><li><p>对象已更新，黄色正方形：<span class="inlinemediaobject"><img src="images/Chapter-IDE/yellowsquare.GIF"></span></p></li><li><p>删除了对象，红色方块：<span class="inlinemediaobject"><img src="images/Chapter-IDE/redsquare.GIF"></span></p></li><li><p>激活已创建，向右箭头：<span class="inlinemediaobject"><img src="images/Chapter-IDE/arrowright.GIF"></span></p></li><li><p>激活已取消，向左箭头：<span class="inlinemediaobject"><img src="images/Chapter-IDE/arrowleft.GIF"></span></p></li><li><p>执行激活，蓝色菱形：<span class="inlinemediaobject"><img src="images/Chapter-IDE/bluediamond.GIF"></span></p></li><li><p>Ruleflow开始或结束，“过程”图标：<span class="inlinemediaobject"><img src="images/Chapter-IDE/process.gif"></span></p></li><li><p>Ruleflow组的激活或停用，“活动”图标：<span class="inlinemediaobject"><img src="images/Chapter-IDE/activity.gif"></span></p></li><li><p>规则包的添加或删除，Drools图标：<span class="inlinemediaobject"><img src="images/Chapter-IDE/drools.gif"></span></p></li><li><p>规则添加或删除，Drools图标：<span class="inlinemediaobject"><img src="images/Chapter-IDE/drools.gif"></span></p></li></ol></div><p>所有这些事件都显示与该事件有关的额外信息，例如工作内存事件（插入，修改和撤回）时对象的id和toString表示形式，规则名称以及激活时绑定在激活中的所有变量。激活事件（创建，取消或执行）。如果执行激活时发生事件，该事件将显示为激活执行事件的子级。对于某些事件，您可以检索“原因”：</p><div class="orderedlist"><ol type="1"><li><p>对象修改或撤回事件的原因是该对象的最后一个对象事件。这是对象断言事件，或者是该对象的最后一个对象修改事件。</p></li><li><p>激活取消或执行事件的原因是相应的激活创建事件。</p></li></ol></div><p>选择事件时，该事件的原因在审核视图中以绿色显示（当然，如果可见）。您也可以右键单击该操作，然后选择“显示原因”菜单项。这将使您滚动到选定事件的原因。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6885"></a> 7.7。领域特定语言</h2></div></div></div><p>域特定语言（DSL）使您可以创建一种语言，使您的规则看起来像-规则！通常，特定领域的语言读起来就像自然语言。通常，您将研究业务分析师如何用自己的话语描述规则，然后通过规则构造将其映射到您的对象模型。这样做的一个附带好处是，它可以在您的域对象和规则本身之间提供一个隔离层（我们知道您想重构）。特定于域的语言将随着规则的增长而增长，并且当在over上使用具有不同参数的通用术语时，其效果最佳。</p><p>为此，规则工作台提供了特定于域的语言的编辑器。它们以纯文本格式存储，因此您可以使用任何选择的编辑器。这种格式只是“属性”文件格式的略微增强版本。该编辑器将在任何扩展名为.dsl的文件上调用。还有一个向导可以创建示例DSL。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6892"></a> 7.7.1。编辑语言</h3></div></div></div><div class="figure"><a id="d0e6895"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-IDE/dsl_editor.jpg" align="middle" width="100%" alt="域特定语言编辑器"></td></tr></tbody></table></div></div><p class="title"><b>图7.9。域特定语言编辑器</b></p></div><br class="figure-break"><p>DSL编辑器提供了语言到规则表达式的映射的表格视图。规则中使用语言表达。这也为规则编辑器提供了内容帮助，因此它可以从DSL配置中建议语言表达。（当加载规则资源进行编辑时，规则编辑器将加载DSL配置。）规则语言映射定义了规则的“代码”，规则引擎编译器会将语言表达编译到该代码中。此规则语言表达的形式取决于它是用于规则的条件还是动作部分。（例如，对于RHS，它可能是Java的摘要）。“范围”项表示该表达式所属的位置，“何时”表示LHS，“则”表示RHS，“ *”表示任意位置。也可以为关键字创建别名。</p><p>通过选择一个映射项（表中的一行），您可以在表下方的文本字段中查看表达式和映射。双击或按下编辑按钮将打开编辑对话框。其他按钮可让您删除和添加映射。不要删除仍在使用的映射。</p><div class="figure"><a id="d0e6905"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-IDE/mapping_editor.jpg" align="middle" alt="语言映射编辑器对话框"></div></div><p class="title"><b>图7.10。语言映射编辑器对话框</b></p></div><br class="figure-break"><p>这是DSL转换过程的简短描述。解析器逐行读取DSL中的规则文本，并尝试根据范围匹配某些“语言表达式”。匹配后，从规则源中提取与花括号（例如{age}）之间的占位符相对应的值。相应的“规则表达式”中的占位符将替换为其相应的值。在上面的示例中，自然语言表达式根据“年龄”和“位置”字段映射到“人”类型事实的两个约束，并且从原始规则文本中提取了{age}和{location}值。</p><p>如果您不希望在drl中为特定规则使用语言映射，请在表达式前面加上>，编译器将不会尝试根据语言定义来翻译它。另请注意，特定领域语言是可选的。编译规则时，.dsl文件也将需要可用。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6915"></a> 7.8。Rete视图</h2></div></div></div><p>Rete树视图为您显示DRL文件的当前Rete网络。您可以通过单击DRL编辑器窗口底部的“ Rete Tree”选项卡来显示它。打开Rete Network可视化后，您可以在各个节点上进行拖放来安排最佳的网络概览。您也可以通过在其上拖动一个矩形来选择多个节点。然后整个小组就可以移动了。可以按常规方式使用用于放大和缩小的Eclips工具栏图标。</p><p>在当前版本中，没有导出功能来创建gif或jpeg文件。同时，请使用ctrl + alt + print创建当前Eclipse窗口的副本，并将其剪切掉。</p><div class="mediaobject"><img src="images/Chapter-IDE/thereteview.jpg"></div><p>Rete View是一项高级功能，它充分利用了Eclipse图形编辑框架（GEF）。</p><p>Rete视图仅在Drools Rule Projects中起作用，在Drools Rule Projects中，在项目的属性中设置了Drools Builder。</p><p>如果您在另一种类型的项目中使用Drools，而没有使用适当的Drools Builder的Drools Rule Project，则可以使用一种解决方法：在其旁边设置一个Drools Rule Project，将所需的库放入其中，您要使用Rete View检查的DRL。只需在DRL编辑器中单击下面的右侧选项卡，然后单击“生成Rete视图”。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6931"></a> 7.9。大DRL文件</h2></div></div></div><p>根据您使用的JDK，可能有必要增加永久生成的最大大小。SUN和IBM JDK都有永久的一代，而BEA JRockit却没有。</p><p>要增加永久生成，请使用-XX：MaxPermSize = ### m启动Eclipse。</p><p>示例：c：\ Eclipse \ Eclipse.exe -XX：MaxPermSize = 128m</p><p>4,000条或更多规则的规则集应将永久代设置为至少128Mb。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>通常，这也可能适用于编译大量规则，因为每个规则通常有一个或多个类。</p></div><p>作为上述替代方案，您可以将规则放在带有“ .rule”扩展名的文件中，并且后台构建器将不会尝试对每次更改进行编译，如果您的IDE变得非常笨拙，则可能会提高性能。的规则。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6947"></a> 7.10。调试规则</h2></div></div></div><div class="figure"><a id="d0e6950"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-IDE/debug-overview.png" align="middle" width="100%" alt="调试"></td></tr></tbody></table></div></div><p class="title"><b>图7.11。调试</b></p></div><br class="figure-break"><p>您可以在Drools应用程序执行期间调试规则。您可以在规则的后果中添加断点，并且在规则执行期间只要遇到这样的断点，就会中止执行。然后，您可以检查当时已知的变量，并使用任何默认的调试操作来决定下一步将发生什么：逐步执行，继续执行等等。您还可以使用调试视图检查工作存储器和议程的内容。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6958"></a> 7.10.1。创建断点</h3></div></div></div><p>您可以通过两种方式在DRL文件中添加和删除规则断点，类似于向Java文件中添加断点：</p><div class="orderedlist"><ol type="1"><li><p>在要添加断点的行上双击DRL编辑器的标尺。请注意，只能根据规则创建规则断点。双击不允许断点的行将无济于事。再次双击标尺可以删除断点。
          </p></li><li><p>如果右键单击标尺，将显示一个弹出菜单，其中包含“切换断点”操作。请注意，只能根据规则创建规则断点。如果该行不允许规则断点，则该操作将自动禁用。单击该操作将在所选行上添加一个断点，或者如果已存在该断点，则将其删除。</p></li></ol></div><p>Debug Perspective包含一个Breakpoints视图，可用于查看所有已定义的断点，获取其属性，启用/禁用或删除它们，等等。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6972"></a> 7.10.2。调试规则</h3></div></div></div><p>仅当您将应用程序调试为Drools应用程序时，才会启用Drools断点。您可以这样做：</p><div class="figure"><a id="d0e6977"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-IDE/debugAsDrools.png" align="middle" width="100%" alt="作为Drools应用程序进行调试"></td></tr></tbody></table></div></div><p class="title"><b>图7.12。作为Drools应用程序进行调试</b></p></div><br class="figure-break"><div class="orderedlist"><ol type="1"><li><p>选择应用程序的主类。右键单击它，然后选择“调试为>”子菜单，然后选择“ Drools应用程序”。另外，您也可以选择“ Debug ...”菜单项以打开一个新对话框，用于创建，管理和运行调试配置（请参见下面的屏幕截图）。</p></li><li><p>选择左侧树中的“ Drools应用程序”项，然后单击“新启动配置”按钮（树上方工具栏中最左侧的图标）。根据开始时选择的主类，这将创建一个新的配置，其中已经填充了一些属性（如项目和主类）。此处显示的所有属性与任何标准Java程序相同。</p></li><li><p>将调试配置的名称更改为有意义的名称。您可以接受所有其他属性的默认值。有关这些属性的更多信息，请检查Eclipse JDT文档。</p></li><li><p>单击底部的“调试”按钮以开始调试应用程序。您只需要定义一次调试配置。下次运行Drools应用程序时，不必创建新的应用程序，而是在左侧的树中选择先前定义的应用程序作为“ Drools应用程序”树节点的子元素，然后单击调试按钮。Eclipse工具栏还包含快捷按钮，用于快速重新执行您以前的配置之一（至少在选择了Java，Java Debug或Drools透视图之一时）。</p></li></ol></div><div class="figure"><a id="d0e6996"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-IDE/debug_rules_configuration.png" align="middle" width="100%" alt="作为Drools应用程序配置进行调试"></td></tr></tbody></table></div></div><p class="title"><b>图7.13。作为Drools应用程序配置进行调试</b></p></div><br class="figure-break"><p>单击“调试”按钮后，该应用程序开始执行，如果遇到任何断点，它将停止。这可以是Drools规则断点，也可以是任何其他标准Java断点。每当遇到Drools规则断点时，就会打开相应的DRL文件并突出显示活动行。“变量”视图还包含所有规则参数及其值。然后，您可以使用默认的Java调试操作来决定下一步要执行的操作：恢复，终止，跳过等。调试视图也可以用来同时检查工作存储器和议程的内容。您无需立即选择工作内存，因为当前正在执行的工作内存会自动显示。</p><div class="figure"><a id="d0e7004"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-IDE/debug.png" align="middle" width="100%" alt="调试"></td></tr></tbody></table></div></div><p class="title"><b>图7.14。调试</b></p></div><br class="figure-break"></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7010"></a>第八章例子</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e7013">8.1。得到例子</a></span></dt><dt><span class="section"><a href="#d0e7018">8.2。你好，世界</a></span></dt><dt><span class="section"><a href="#d0e7283">8.3。状态示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7288">8.3.1。了解状态示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7566">8.4。斐波那契示例</a></span></dt><dt><span class="section"><a href="#d0e7769">8.5。银行教程</a></span></dt><dt><span class="section"><a href="#d0e8093">8.6。定价规则决策表示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8114">8.6.1。执行示例</a></span></dt><dt><span class="section"><a href="#d0e8156">8.6.2。决策表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8221">8.7。宠物店的例子</a></span></dt><dt><span class="section"><a href="#d0e8780">8.8。诚实的政客例子</a></span></dt><dt><span class="section"><a href="#d0e8905">8.9。数独示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8926">8.9.1。数独概述</a></span></dt><dt><span class="section"><a href="#d0e8940">8.9.2。运行示例</a></span></dt><dt><span class="section"><a href="#d0e9026">8.9.3。Java源代码和规则概述</a></span></dt><dt><span class="section"><a href="#d0e9144">8.9.4。数独验证器规则（validatorSudoku.drl）</a></span></dt><dt><span class="section"><a href="#d0e9174">8.9.5。数独求解规则（solverSudoku.drl）</a></span></dt><dt><span class="section"><a href="#d0e9282">8.9.6。对未来发展的建议</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9337">8.10。猜数字</a></span></dt><dt><span class="section"><a href="#d0e9627">8.11。礼貌小姐和标杆管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9646">8.11.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e9732">8.11.2。深入讨论</a></span></dt><dt><span class="section"><a href="#d0e9942">8.11.3。输出汇总</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9997">8.12。康威的人生游戏</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7013"></a> 8.1。得到例子</h2></div></div></div><p>确保已安装Drools Eclipse插件，该插件需要首先安装图形编辑框架（GEF）依赖项。然后下载并提取drools-examples zip文件，其中包括一个已经创建的Eclipse项目。将该项目导入到新的Eclipse工作区中。规则均具有执行规则的示例类。如果您想在另一个项目（或另一个IDE）中尝试这些示例，那么您当然需要手动设置依赖项。请享受下面的许多（但不是全部）示例！</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7018"></a> 8.2。你好，世界</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Hello World
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HelloWorldExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HelloWorld.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate basic rules in use</pre><p>“ Hello World”示例显示了规则用法以及MVEL和Java方言的简单示例。</p><p>本示例演示如何构建知识库和会话。此外，还显示了审计日志记录和调试输出，由于它们非常相似，因此在其他示例中都将其省略。一种<code class="code">KnowledgeBuilder</code>用于将DRL源文件转换为<code class="code">Package</code>知识库可以消耗的对象。add方法需要一个<code class="code">Resource</code>接口和资源类型作为参数。的<code class="code">Resource</code>可用于从各个位置检索DRL源文件；在这种情况下，将使用以下命令从类路径中检索DRL文件： <code class="code">ResourceFactory</code> ，但可能来自磁盘文件或URL。在这里，我们仅添加一个DRL源文件，但是可以添加多个DRL文件。此外，可以添加具有不同名称空间的DRL文件，其中Knowledge Builder为每个名称空间创建一个包。可以将具有不同名称空间的多个程序包添加到同一知识库中。添加所有DRL文件后，我们应该检查构建器是否存在错误。虽然知识库将验证程序包，但它只能以字符串形式访问错误信息，因此，如果要调试错误信息，则应在程序包上进行操作。 <code class="code">KnowledgeBuilder</code>实例。知道构建器没有错误后，请获取<code class="code">Package</code>集合，实例化一个<code class="code">KnowledgeBase</code>来自<code class="code">KnowledgeBaseFactory</code>并添加软件包集合。</p><div class="example"><a id="d0e7068"></a><p class="title"><b>示例8.1HelloWorld：创建知识库和会话</b></p><div class="example-contents"><pre class="programlisting">final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

// this will parse and compile in one step
kbuilder.add(ResourceFactory.newClassPathResource("HelloWorld.drl",
				HelloWorldExample.class), ResourceType.DRL);

// Check the builder for errors
if (kbuilder.hasErrors()) {
    System.out.println(kbuilder.getErrors().toString());
    throw new RuntimeException("Unable to compile \"HelloWorld.drl\".");
}

// get the compiled packages (which are serializable)
final Collection&lt;KnowledgePackage&gt; pkgs = kbuilder.getKnowledgePackages();

// add the packages to a knowledgebase (deploy the knowledge packages).
final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages(pkgs);

final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();</pre></div></div><br class="example-break"><p>Drools有一个事件模型，可以揭示内部发生的许多事情。提供了两个默认的调试侦听器， <code class="code">DebugAgendaEventListener</code>和<code class="code">DebugWorkingMemoryEventListener</code>将调试事件信息打印到<code class="code">System.err</code>控制台窗口中显示的流。如下所示，向会话添加侦听器很简单。的<code class="code">KnowledgeRuntimeLogger</code>提供执行审计，其结果可以在图形查看器中查看。记录器实际上是建立在议程和工作记忆侦听器上的专用实现。引擎执行完毕后， <code class="code">logger.close()</code>必须被调用。</p><p>大多数示例使用Drools的Audit日志记录功能来记录执行流，以供以后检查。</p><div class="example"><a id="d0e7092"></a><p class="title"><b>示例8.2HelloWorld：事件记录和审核</b></p><div class="example-contents"><pre class="programlisting">// setup the debug listeners
ksession.addEventListener( new DebugAgendaEventListener() );
ksession.addEventListener( new DebugWorkingMemoryEventListener() );
        
// setup the audit logging
KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "log/helloworld");</pre></div></div><br class="example-break"><p>本示例中使用的单个类非常简单。它有两个字段：消息（它是一个字符串）和状态（可以是两个整数之一） <code class="code">HELLO</code>要么<code class="code">GOODBYE</code> 。</p><div class="example"><a id="d0e7105"></a><p class="title"><b>示例8.3HelloWorld示例：消息类</b></p><div class="example-contents"><pre class="programlisting">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status; 
    ...
}</pre></div></div><br class="example-break"><p>一个<code class="code">Message</code>使用消息文本“ Hello World”和状态创建对象<code class="code">HELLO</code>然后插入引擎中<code class="code">fireAllRules()</code>被执行。请记住，所有网络评估都是在插入时间内完成的，因此在程序执行到<code class="code">fireAllRules()</code>引擎方法调用已经知道哪些规则完全匹配并且能够触发。</p><div class="example"><a id="d0e7124"></a><p class="title"><b>示例8.4HelloWorld：执行</b></p><div class="example-contents"><pre class="programlisting">final Message message = new Message();
message.setMessage("Hello World");
message.setStatus(Message.HELLO);
ksession.insert(message);

ksession.fireAllRules();

logger.close();

ksession.dispose();    </pre></div></div><br class="example-break"><p>要将示例作为Java应用程序执行：</p><div class="orderedlist"><ol type="1"><li><p>打开类org.drools.examples。Eclipse IDE中的HelloWorldExample</p></li><li><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>如果我们在<code class="code">fireAllRules()</code>方法，然后选择<code class="code">ksession</code>变量，我们可以看到“ Hello World”规则已被激活，并且已在议程上确认了在插入过程中所有模式匹配工作已经完成。</p><div class="figure"><a id="d0e7146"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/HelloWorldExample/helloworld_agenda1.png" width="100%" alt="你好世界：fireAllRules议程视图"></td></tr></tbody></table></div></div><p class="title"><b>图8.1。你好世界：fireAllRules议程视图</b></p></div><br class="figure-break"><p>may应用程序的打印输出转到System.out，而调试侦听器的打印输出转到System.err。</p><div class="example"><a id="d0e7154"></a><p class="title"><b>示例8.5HelloWorld：“控制台”窗口中的System.out</b></p><div class="example-contents"><pre class="programlisting">Hello World
Goodbye cruel world</pre></div></div><br class="example-break"><div class="example"><a id="d0e7159"></a><p class="title"><b>示例8.6HelloWorld：“控制台”窗口中的System.err</b></p><div class="example-contents"><pre class="programlisting">==&gt;[ActivationCreated(0): rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                 object=org.drools.examples.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                old_object=org.drools.examples.HelloWorldExample$Message@17cec96; 
                new_object=org.drools.examples.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]  </pre></div></div><br class="example-break"><p>LHS（后<strong class="kw"><code>when</code></strong> ）部分指出，该规则将针对每个<code class="code">Message</code>插入工作存储器的对象，其状态为<code class="code">Message.HELLO</code> 。除此之外，还创建了两个变量绑定： <code class="code">message</code>绑定到<code class="code">message</code>属性和变量<code class="code">m</code>绑定到匹配项<code class="code">Message</code>对象本身。</p><p>RHS（之后<strong class="kw"><code>then</code></strong> ）或规则的结果部分使用MVEL表达式语言（由规则的属性声明）编写<code class="code">dialect</code> 。打印完绑定变量的内容后<code class="code">message</code>至<code class="code">System.out</code> ，该规则会更改<code class="code">message</code>和<code class="code">status</code>的属性<code class="code">Message</code>绑定对象<code class="code">m</code> 。这是MVEL的<strong class="kw"><code>modify</code></strong>语句，它使您可以在一个语句中应用分配的块，并在该块的末尾自动将更改通知引擎。</p><div class="example"><a id="d0e7216"></a><p class="title"><b>示例8.7HelloWorld：规则“ Hello World”</b></p><div class="example-contents"><pre class="programlisting">rule "Hello World"
      dialect "mvel"
  when
      m : Message( status == Message.HELLO, message : message )
  then
      System.out.println( message ); 
      modify ( m ) { message = "Goodbyte cruel world",
                     status = Message.GOODBYE };
end</pre></div></div><br class="example-break"><p>我们可以在DRL上设置一个断点<strong class="kw"><code>modify</code></strong>调用，并在规则结果执行期间再次检查“议程”视图。这次我们通过“调试为”和“ Drools应用程序”开始执行，而不是通过运行“ Java应用程序”开始执行：</p><div class="orderedlist"><ol type="1"><li><p>开课<code class="code">org.drools.examples.HelloWorld</code>在您的Eclipse IDE中。</p></li><li><p>右键单击该类，然后选择“调试为...”，然后选择“ Drools应用程序”。</p></li></ol></div><p>现在我们可以看到另一条规则<code class="code">"Good Bye"</code>使用Java语言的，被激活并放在议程中。</p><div class="figure"><a id="d0e7241"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/HelloWorldExample/helloworld_agenda2.png" alt="你好世界：规则" hello="" worl="=" =""></div></div><p class="title"><b>图8.2。Hello World：规则“ Hello World”议程视图</b></p></div><br class="figure-break"><p>指定“ java”方言的“再见”规则与“ Hello World”规则相似，只不过它匹配<code class="code">Message</code>状态为<code class="code">Message.GOODBYE</code> 。</p><div class="example"><a id="d0e7255"></a><p class="title"><b>示例8.8HelloWorld：规则“再见”</b></p><div class="example-contents"><pre class="programlisting">rule "Good Bye"
      dialect "java"
  when
      Message( status == Message.GOODBYE, message : message )
  then
      System.out.println( message ); 
end</pre></div></div><br class="example-break"><p>记住我们使用过的Java代码<code class="code">KnowledgeRuntimeLoggerFactory</code>方法<code class="code">newFileLogger</code>创建一个<code class="code">KnowledgeRuntimeLogger</code>并称<code class="code">logger.close()</code>在最后。这将创建一个审核日志文件，该文件可以显示在“审核”视图中。我们在许多示例中使用Audit视图来演示示例执行流程。在下面的视图屏幕快照中，我们可以看到已插入对象，从而为“ Hello World”规则创建了一个激活。然后执行激活，更新<code class="code">Message</code>导致“再见”规则激活的对象；最后，“再见”规则也将执行。在“审核”视图中选择一个事件，以绿色突出显示该原始事件；因此，“激活已创建”事件以绿色突出显示为“激活已执行”事件的来源。</p><div class="figure"><a id="d0e7277"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/HelloWorldExample/helloworld_auditview1.png" width="100%" alt="Hello World：审核视图"></td></tr></tbody></table></div></div><p class="title"><b>图8.3。Hello World：审核视图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7283"></a> 8.3。状态示例</h2></div></div></div><p>本示例以三种不同版本实现，以演示实现相同基本行为的不同方式：正向链接，即引擎必须基于工作内存中事实的变化按顺序评估，激活和触发规则的能力。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7288"></a> 8.3.1。了解状态示例</h3></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> State Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.StateExampleUsingSalience
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> StateExampleUsingSalience.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates basic rule use
  and Conflict Resolution for rule firing priority.</pre><p>每<code class="code">State</code>该类具有用于其名称和当前状态的字段（请参阅该类<code class="code">org.drools.examples.State</code> ）。每个对象的两种可能状态是：</p><div class="itemizedlist"><ul><li><p><code class="code">NOTRUN</code></p></li><li><p><code class="code">FINISHED</code></p></li></ul></div><div class="example"><a id="d0e7324"></a><p class="title"><b>示例8.9州级</b></p><div class="example-contents"><pre class="programlisting">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>忽略<code class="code">PropertyChangeSupport</code> ，这将在后面解释，我们看到创建了四个<code class="code">State</code>对象名为A，B，C和D。最初，它们的状态设置为<code class="code">NOTRUN</code> ，这是所用构造函数的默认值。每个实例依次在Session中声明，然后<code class="code">fireAllRules()</code>叫做。</p><div class="example"><a id="d0e7343"></a><p class="title"><b>示例8.10显着状态：执行</b></p><div class="example-contents"><pre class="programlisting">State a = new State( "A" );
State b = new State( "B" );
State c = new State( "C" );
final State d = new State( "D" );

// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
boolean dynamic = true;

session.insert( a, dynamic );
session.insert( b, dynamic );
session.insert( c, dynamic );
session.insert( d, dynamic );

session.fireAllRules();
session.dispose(); // Stateful rule session must always be disposed when finished</pre></div></div><br class="example-break"><p>要执行该应用程序：</p><div class="orderedlist"><ol type="1"><li><p>开课<code class="code">org.drools.examples.StateExampleUsingSalience</code>在您的Eclipse IDE中。</p></li><li><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>您将在Eclipse控制台窗口中看到以下输出：</p><div class="example"><a id="d0e7362"></a><p class="title"><b>示例8.11显着状态：控制台输出</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
</pre></div></div><br class="example-break"><p>共有四个规则。首先， <code class="code">Bootstrap</code>规则触发，将A设置为state <code class="code">FINISHED</code> ，然后导致B将其状态更改为<code class="code">FINISHED</code> 。C和D都依赖于B，从而导致冲突，该冲突由显着性值解决。让我们看看它的执行方式。</p><p>了解发生情况的最佳方法是使用“审核日志记录”功能以图形方式查看每个操作的结果。要查看此示例的运行生成的审核日志：</p><div class="orderedlist"><ol type="1"><li><p>如果看不到审计视图，请单击“窗口”，然后选择“显示视图”，然后选择“其他...”和“流口水”，最后选择“审计视图”。</p></li><li><p>在“审核视图”中，单击“打开日志”按钮，然后选择文件“ <drools-examples-drl-dir>/log/state.log”。</drools-examples-drl-dir></p></li></ol></div><p>之后，“审核视图”将类似于以下屏幕截图：</p><div class="figure"><a id="d0e7389"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/StateExample/state_example_audit1.png" width="100%" alt="显着性状态示例审核视图"></td></tr></tbody></table></div></div><p class="title"><b>图8.4。显着性状态示例审核视图</b></p></div><br class="figure-break"><p>从上至下阅读“审核视图”中的日志，我们会看到每个操作以及工作内存中的相应更改。这样，我们观察到状态中状态对象A的断言<code class="code">NOTRUN</code>激活<code class="code">Bootstrap</code>规则，而另一方的断言<code class="code">State</code>对象没有立竿见影的效果。</p><div class="example"><a id="d0e7406"></a><p class="title"><b>示例8.12显着状态：规则“引导程序”</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>规则Bootstrap的执行将A的状态更改为<code class="code">FINISHED</code> ，依次激活规则“ A至B”。</p><div class="example"><a id="d0e7416"></a><p class="title"><b>示例8.13显着状态：规则“ A至B”</b></p><div class="example-contents"><pre class="programlisting">rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>规则“ A到B”的执行将B的状态更改为<code class="code">FINISHED</code> ，这会激活规则“ B到C”和“ B到D”，并将它们的激活置于议程中。从这一刻起，两条规则都可能启动，因此，它们被称为“冲突中”。冲突解决策略使引擎的议程可以决定要触发的规则。由于规则“ B到C”具有<span class="bold"><strong>更高的显着性值</strong></span> （10相对于默认显着性值0），因此它将首先触发，将对象C修改为状态<code class="code">FINISHED</code> 。上面显示的“审核”视图反映了对<code class="code">State</code>规则“ A到B”中的“对象”，则导致两次激活发生冲突。议程视图还可以用于调查议程的状态，将调试点放置在规则本身中，并打开议程视图。下面的屏幕快照显示了规则“ A至B”中的断点以及具有两个冲突规则的议程状态。</p><div class="figure"><a id="d0e7435"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/StateExample/state_example_agenda1.png" alt="状态示例议程视图"></div></div><p class="title"><b>图8.5。状态示例议程视图</b></p></div><br class="figure-break"><div class="example"><a id="d0e7441"></a><p class="title"><b>示例8.14显着状态：规则“ B到C”</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>规则“ B to D”最后触发，将对象D修改为状态<code class="code">FINISHED</code> 。</p><div class="example"><a id="d0e7451"></a><p class="title"><b>示例8.15显着状态：规则“ B到D”</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>没有更多要执行的规则，因此引擎停止了。</p><p>在这个例子中另一个值得注意的概念是使用<span class="emphasis"><em>动态事实</em></span>的基础上， <code class="code">PropertyChangeListener</code>对象。如文档中所述，为了使引擎能够查看事实属性的变化并对变化做出反应，应用程序必须告知引擎发生了变化。可以在规则中使用<strong class="kw"><code>modify</code></strong>语句，或通过让引擎知道事实实现来隐式<code class="code">PropertyChangeSupport</code>由<span class="emphasis"><em>JavaBeans规范</em></span>定义。这个例子演示了如何使用<code class="code">PropertyChangeSupport</code>避免需要明确<strong class="kw"><code>modify</code></strong>规则中的声明。要使用此功能，请确保您的事实得以实现<code class="code">PropertyChangeSupport</code> ，与上课方式相同<code class="code">org.drools.example.State</code>并使用以下代码将事实插入工作内存中：</p><div class="example"><a id="d0e7487"></a><p class="title"><b>示例8.16插入动态事实</b></p><div class="example-contents"><pre class="programlisting">// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call modify or update().
final boolean dynamic = true;

session.insert( fact, dynamic );
</pre></div></div><br class="example-break"><p>使用时<code class="code">PropertyChangeListener</code>对象，每个设置器必须为通知实现一些额外的代码。这是二传手<code class="code">state</code>在课堂里<code class="code">org.drools.examples</code> ：</p>：<div class="example"><a id="d0e7504"></a><p class="title"><b>示例8.17具有PropertyChangeSupport的Setter示例</b></p><div class="example-contents"><pre class="programlisting">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</pre></div></div><br class="example-break"><p>此示例中还有另外两个类： <code class="code">StateExampleUsingAgendGroup</code>和<code class="code">StateExampleWithDynamicRules</code> 。两者都从A到B到C到D执行，如图所示。的<code class="code">StateExampleUsingAgendGroup</code>使用议程组控制规则冲突，首先触发哪个规则。 <code class="code">StateExampleWithDynamicRules</code>说明如何在运行时将所有现有数据应用到已运行的工作内存中的附加规则。</p><p>议程组是一种将议程划分为组并控制可以执行的组的方法。默认情况下，所有规则都在议程组“ MAIN”中。通过“议程组”属性，您可以为规则指定其他议程组。最初，工作记忆将重点放在议程组“ MAIN”上。只有当小组获得焦点时，小组的规则才会触发。ny可以使用<code class="code">setFocus()</code>或规则属性<strong class="kw"><code>auto-focus</code></strong> 。 “自动聚焦”是指当规则被匹配并激活时，规则自动将焦点设置到其议程组。正是这种“自动聚焦”使规则“ B至C”在“ B至D”之前触发。</p><div class="example"><a id="d0e7531"></a><p class="title"><b>示例8.18议程组状态示例：规则“ B到C”</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</pre></div></div><br class="example-break"><p>规则“ B到C”调用<code class="code">setFocus()</code>议程组“ B to D”上的规则，从而激活其活动规则，从而激活规则“ B to D”。</p><div class="example"><a id="d0e7541"></a><p class="title"><b>示例8.19议程组状态示例：规则“ B到D”</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>这个例子<code class="code">StateExampleWithDynamicRules</code>之后在规则库中添加另一个规则<code class="code">fireAllRules()</code> 。添加的规则只是另一个状态转换。</p><div class="example"><a id="d0e7554"></a><p class="title"><b>示例8.20动态状态示例：规则“ D到E”</b></p><div class="example-contents"><pre class="programlisting">rule "D to E"
  when
      State(name == "D", state == State.FINISHED )      
      e : State(name == "E", state == State.NOTRUN )
  then
      System.out.println(e.getName() + " finished" );
      e.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>这将产生以下预期输出：</p><div class="example"><a id="d0e7561"></a><p class="title"><b>示例8.21。动态状态示例输出</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
E finished
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7566"></a> 8.4。斐波那契示例</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Fibonacci 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.FibonacciExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> Fibonacci.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates Recursion,
  the CE <strong class="kw"><code>not</code></strong> and cross product matching</pre><p>比萨的莱昂纳多（Leonardo）发现的斐波那契数字（参见<a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a> ）（参见<a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci">http://en.wikipedia.org/wiki/Fibonacci</a> ）是一个以0和1开头的序列。通过将两个前面的斐波那契数相加来获得下一个斐波那契数。斐波那契数列以0、1、1、2、3、5、8、13、21、34、55、89、144、233、377、610、987、1597、2584、4181、6765、10946开始。 ..Fibonacci示例演示了具有显着性值的递归和冲突解决方案。</p><p>单一事实类<code class="code">Fibonacci</code>在此示例中使用。它具有两个字段，顺序和值。序列字段用于指示对象在斐波那契数列中的位置。值字段显示该斐波那契对象对该序列位置的值，使用-1指示仍需要计算的值。</p><div class="example"><a id="d0e7601"></a><p class="title"><b>示例8.22斐波那契级</b></p><div class="example-contents"><pre class="programlisting">public static class Fibonacci {
    private int  sequence;
    private long value;

    public Fibonacci( final int sequence ) {
        this.sequence = sequence;
        this.value = -1;
    }

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>执行示例：</p><div class="orderedlist"><ol type="1"><li><p>开课<code class="classname">org.drools.examples.FibonacciExample</code>在您的Eclipse IDE中。</p></li><li><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>Eclipse在其控制台窗口中显示以下输出（“ ... snip ...”指示已删除以节省空间的行）：</p><div class="example"><a id="d0e7620"></a><p class="title"><b>示例8.23Fibonacci示例：控制台输出</b></p><div class="example-contents"><pre class="programlisting">recurse for 50
recurse for 49
recurse for 48
recurse for 47
...snip...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...snip...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025
</pre></div></div><br class="example-break"><p>为了从Java开始，我们只插入一个Fibonacci对象，其序列字段为50。然后使用递归规则插入其他49 <code class="code">Fibonacci</code>对象。这个例子不使用<code class="code">PropertyChangeSupport</code> 。它使用MVEL方言，这意味着我们可以使用<strong class="kw"><code>modify</code></strong>关键字，它允许执行块设置程序操作，该操作还通知引擎更改。</p><div class="example"><a id="d0e7636"></a><p class="title"><b>示例8.24斐波那契示例：执行</b></p><div class="example-contents"><pre class="programlisting">ksession.insert( new Fibonacci( 50 ) );
ksession.fireAllRules();</pre></div></div><br class="example-break"><p>规则递归非常简单。它匹配每个断言<code class="code">Fibonacci</code>值为-1的对象，创建并声明一个新的<code class="code">Fibonacci</code>序列比当前匹配的对象少一个的对象。每次添加Fibonacci对象时，不存在序列字段等于1的对象，规则都会重新匹配并重新触发。的<strong class="kw"><code>not</code></strong>一旦我们在内存中存储了全部50个Fibonacci对象，就可以使用条件元素停止规则的匹配。该规则也具有显着性值，因为我们需要将所有50 <code class="code">Fibonacci</code>在执行Bootstrap规则之前断言的对象。</p><div class="example"><a id="d0e7655"></a><p class="title"><b>示例8.25斐波那契示例：规则“递归”</b></p><div class="example-contents"><pre class="programlisting">rule Recurse
    salience 10
    when
        f : Fibonacci ( value == -1 )
        not ( Fibonacci ( sequence == 1 ) )
    then
        insert( new Fibonacci( f.sequence - 1 ) );
        System.out.println( "recurse for " + f.sequence );
end</pre></div></div><br class="example-break"><p>审核视图显示了原始的断言<code class="code">Fibonacci</code>序列字段为50的对象（通过Java代码完成）。从那里开始，“审核”视图显示规则的连续递归，其中每个已断言<code class="code">Fibonacci</code>对象导致“递归”规则被激活并再次触发。</p><div class="figure"><a id="d0e7668"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/FibonacciExample/fibonacci1.png" width="100%" alt="斐波那契示例：" recurs="=" =""></td></tr></tbody></table></div></div><p class="title"><b>图8.6。Fibonacci示例：“递归”审核视图1</b></p></div><br class="figure-break"><p>当一个<code class="code">Fibonacci</code>断言序列字段为2的对象“ Bootstrap”规则与“ Recurse”规则一起被激活。请注意对字段的多重限制<code class="code">sequence</code> ，测试1或2的相等性。</p><div class="example"><a id="d0e7682"></a><p class="title"><b>示例8.26斐波那契示例：规则“引导程序”</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction
    then 
        modify ( f ){ value = 1 };
        System.out.println( f.sequence + " == " + f.value );
end</pre></div></div><br class="example-break"><p>此时，议程如下所示。但是，“ Bootstrap”规则不会触发，因为“ Recurse”规则的显着性更高。</p><div class="figure"><a id="d0e7689"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci_agenda1.png" alt="斐波那契示例：" recurs="=" =""></div></div><p class="title"><b>图8.7。斐波那契示例：“递归”议程视图1</b></p></div><br class="figure-break"><p>当一个<code class="code">Fibonacci</code>断言序列为1的对象再次与Bootstrap规则匹配，从而导致对该规则的两次激活。请注意，“递归”规则不匹配并无法激活，因为<strong class="kw"><code>not</code></strong>条件元素会在<code class="code">Fibonacci</code>存在序列为1的对象。</p><div class="figure"><a id="d0e7706"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci_agenda2.png" alt="斐波那契示例：" recurs="=" =""></div></div><p class="title"><b>图8.8。斐波那契示例：“递归”议程视图2</b></p></div><br class="figure-break"><p>一旦我们有两个<code class="code">Fibonacci</code>值不等于-1的对象，则“计算”规则可以匹配。正是“引导程序”规则将序列1和2的对象设置为值1。此时，工作记忆中有50个斐波那契对象。现在我们需要选择一个合适的三元组依次计算它们的每个值。在没有字段约束的规则中使用三个斐波那契模式来限制可能的叉积会导致50x49x48的可能组合，导致大约125,000个可能的规则触发，其中大多数不正确。“计算”规则使用字段约束以正确的顺序正确约束您的斐波那契模式；这种技术称为<span class="emphasis"><em>跨产品匹配</em></span> 。第一个模式找到具有值的任何斐波那契！= -1并绑定模式和字段。第二个斐波那契也这样做，但是它添加了一个额外的字段约束，以确保其序列比绑定到的斐波那契序列大一个<code class="code">f1</code> 。首次触发此规则时，我们知道只有序列1和2的值为1，并且两个约束确保<code class="code">f1</code>引用序列1和<code class="code">f2</code>参考序列2。最终模式找到值为-1且序列大于1的斐波那契<code class="code">f2</code> 。至此，我们有三个<code class="code">Fibonacci</code>从可用的叉积中正确选择的对象，我们可以计算出第三个对象的值<code class="code">Fibonacci</code>绑定到的对象<code class="code">f3</code> 。</p><div class="example"><a id="d0e7741"></a><p class="title"><b>示例8.27斐波那契示例：规则“计算”</b></p><div class="example-contents"><pre class="programlisting">rule Calculate
    when
        // Bind f1 and s1
        f1 : Fibonacci( s1 : sequence, value != -1 )
        // Bind f2 and v2; refer to bound variable s1
        f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 )
        // Bind f3 and s3; alternative reference of f2.sequence
        f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )      
    then
        // Note the various referencing rechniques.
        modify ( f3 ) { value = f1.value + v2 };
        System.out.println( s3 + " == " + f3.value );
end 
</pre></div></div><br class="example-break"><p>的<strong class="kw"><code>modify</code></strong>语句更新了<code class="code">Fibonacci</code>绑定对象<code class="code">f3</code> 。这意味着我们现在有了另一个值不等于-1的新斐波那契对象，该对象允许“计算”规则重新匹配并计算下一个斐波那契数。下面的“审核”视图显示了最后一个“引导程序”的触发如何修改<code class="code">Fibonacci</code>对象，使“计算”规则匹配，然后修改另一个斐波那契对象，使“计算”规则再次匹配。一直持续到为所有值设置<code class="code">Fibonacci</code>对象。</p><div class="figure"><a id="d0e7763"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/FibonacciExample/fibonacci4.png" alt="斐波那契示例：" bootstra="=" =""></div></div><p class="title"><b>图8.9。Fibonacci示例：“引导程序”审核视图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7769"></a> 8.5。银行教程</h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> BankingTutorial
<span class="bold"><strong>Main class:</strong></span> org.drools.tutorials.banking.Example*.java
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> org.drools.tutorials.banking.*.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate pattern matching, basic sorting and calculation rules.</pre><p>本教程演示了开发完整的个人银行业务应用程序以处理多个帐户上的贷方和借方的过程。它使用为该过程创建的一组设计模式。</p><p>班级<code class="code">RuleRunner</code>是一种简单的工具，可以针对一组数据执行一个或多个DRL文件。它编译软件包并为每次执行创建知识库，从而使我们能够轻松执行每种方案并检查输出。实际上，对于生产系统来说，这不是一个好的解决方案，在生产系统中，知识库仅应构建一次并进行缓存，但是就本教程而言，它就足够了。</p><div class="example"><a id="d0e7795"></a><p class="title"><b>示例8.28银行教程：RuleRunner</b></p><div class="example-contents"><pre class="programlisting">public class RuleRunner {

    public RuleRunner() {
    }

    public void runRules(String[] rules,
                         Object[] facts) throws Exception {

        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        for ( int i = 0; i &lt; rules.length; i++ ) {
            String ruleFile = rules[i];
            System.out.println( "Loading file: " + ruleFile );
            kbuilder.add( ResourceFactory.newClassPathResource( ruleFile,
                                                                RuleRunner.class ),
                          ResourceType.DRL );
        }

        Collection&lt;KnowledgePackage&gt; pkgs = kbuilder.getKnowledgePackages();
        kbase.addKnowledgePackages( pkgs );
        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

        for ( int i = 0; i &lt; facts.length; i++ ) {
            Object fact = facts[i];
            System.out.println( "Inserting fact: " + fact );
            ksession.insert( fact );
        }

        ksession.fireAllRules();
    }
}</pre></div></div><br class="example-break"><p>我们的第一个示例Java类加载并执行一个DRL文件， <code class="filename">Example.drl</code> ，但不插入任何数据。</p><div class="example"><a id="d0e7805"></a><p class="title"><b>示例8.29银行业务教程：Java Example1</b></p><div class="example-contents"><pre class="programlisting">public class Example1 {
    public static void main(String[] args) throws Exception {
        new RuleRunner().runRules( new String[] { "Example1.drl" },
                                   new Object[0] );
    }
}</pre></div></div><br class="example-break"><p>第一条简单执行的规则只有一条<strong class="kw"><code>eval</code></strong>条件始终为真，因此该规则将在开始后匹配并触发一次。</p><div class="example"><a id="d0e7815"></a><p class="title"><b>示例8.30银行业务教程：Example1.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 01"   
    when
        eval( 1==1 )
    then
        System.out.println( "Rule 01 Works" );
endh</pre></div></div><br class="example-break"><p>规则的输出如下所示，显示该规则匹配并执行单个print语句。</p><div class="example"><a id="d0e7822"></a><p class="title"><b>示例8.31银行业务教程：Example1.java的输出</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example1.drl
Rule 01 Works</pre></div></div><br class="example-break"><p>下一步是断言一些简单的事实并打印出来。</p><div class="example"><a id="d0e7829"></a><p class="title"><b>示例8.32银行业务教程：Java Example2</b></p><div class="example-contents"><pre class="programlisting">public class Example2 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example2.drl" },
                                   numbers );
    }
    
    private static Integer wrap( int i ) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>这不使用任何特定事实，而是断言一组<code class="code">java.lang.Integer</code>对象。这不是“最佳实践”，因为数字不是有用的事实，但是我们在这里使用它来演示基本技术，然后再添加更多复杂性。</p><p>现在，我们将创建一个简单的规则来打印这些数字。</p><div class="example"><a id="d0e7841"></a><p class="title"><b>示例8.33银行业务教程：Example2.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 02"   
    when
        Number( $intValue : intValue )
    then
        System.out.println( "Number found with value: " + $intValue ); 
end</pre></div></div><br class="example-break"><p>再一次，这个规则没有什么特别的。它确定了任何事实<code class="code">Number</code>对象并打印出值。注意抽象类的使用<code class="code">Number</code> ：我们插入了<code class="code">Integer</code>对象，但我们现在寻找任何类型的数字。模式匹配引擎能够匹配断言对象的接口和超类。</p><p>输出显示正在加载的DRL，已插入的事实，然后是已匹配并已触发的规则。我们可以看到，每个插入的数字都被匹配并触发并因此打印出来。</p><div class="example"><a id="d0e7859"></a><p class="title"><b>示例8.34银行业务教程：Example2.java的输出</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example2.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 5
Number found with value: 1
Number found with value: 4
Number found with value: 1
Number found with value: 3
</pre></div></div><br class="example-break"><p>当然，还有比使用规则更好的数字排序方法，但是由于当我们开始查看银行业规则时，需要按日期顺序应用一些现金流量，因此我们将开发基于规则的简单排序技术。</p><div class="example"><a id="d0e7866"></a><p class="title"><b>示例8.35银行业务教程：Example3.java</b></p><div class="example-contents"><pre class="programlisting">public class Example3 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example3.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>再次，我们插入我们的<code class="code">Integer</code>对象，但这次的规则略有不同：</p><div class="example"><a id="d0e7876"></a><p class="title"><b>示例8.36银行业务教程：Example3.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 03"
    when
        $number : Number( )
        not Number( intValue &lt; $number.intValue )
    then
        System.out.println("Number found with value: " + $number.intValue() ); 
        retract( $number );
end</pre></div></div><br class="example-break"><p>规则的第一行标识<code class="code">Number</code>并提取值。第二行确保不存在小于第一个模式找到的数目的数字。我们可能希望只匹配一个数字-集合中最小的数字。但是，在打印完数字后撤回该数字意味着已删除最小数字，显示下一个最小数字，依此类推。</p><p>结果输出显示数字现在已按数字排序。</p><div class="example"><a id="d0e7888"></a><p class="title"><b>示例8.37银行业务教程：Example3.java的输出</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example3.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 1
Number found with value: 1
Number found with value: 3
Number found with value: 4
Number found with value: 5
</pre></div></div><br class="example-break"><p>我们准备开始迈向我们的个人会计准则。第一步是创建一个<code class="code">Cashflow</code>宾语。</p><div class="example"><a id="d0e7898"></a><p class="title"><b>示例8.38银行教程：类现金流</b></p><div class="example-contents"><pre class="programlisting">public class Cashflow {
    private Date   date;
    private double amount;

    public Cashflow() {
    }

    public Cashflow(Date date, double amount) {
        this.date = date;
        this.amount = amount;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String toString() {
        return "Cashflow[date=" + date + ",amount=" + amount + "]";
    }
}</pre></div></div><br class="example-break"><p>类<code class="code">Cashflow</code>有两个简单的属性，日期和金额。（请注意，使用类型<code class="code">double</code>货币单位通常<span class="emphasis"><em>不是</em></span>一个好主意，因为浮点数不能准确表示大多数数字。）还有一个重载的构造函数来设置值和方法<code class="code">toString</code>打印现金流量。的Java代码<code class="filename">Example4.java</code>插入五个具有不同日期和金额的Cashflow对象。</p><div class="example"><a id="d0e7920"></a><p class="title"><b>示例8.39银行业务教程：Example4.java</b></p><div class="example-contents"><pre class="programlisting">public class Example4 {    
    public static void main(String[] args) throws Exception {
        Object[] cashflows = {
            new Cashflow(new SimpleDate("01/01/2007"), 300.00),
            new Cashflow(new SimpleDate("05/01/2007"), 100.00),
            new Cashflow(new SimpleDate("11/01/2007"), 500.00),
            new Cashflow(new SimpleDate("07/01/2007"), 800.00),
            new Cashflow(new SimpleDate("02/01/2007"), 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example4.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>便利班<code class="code">SimpleDate</code>延伸<code class="code">java.util.Date</code> ，提供以String作为输入并定义日期格式的构造函数。该代码在下面列出</p><div class="example"><a id="d0e7933"></a><p class="title"><b>示例8.40银行业务教程：SimpleDate类</b></p><div class="example-contents"><pre class="programlisting">public class SimpleDate extends Date {
    private static final SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
    
    public SimpleDate(String datestr) throws Exception {             
        setTime(format.parse(datestr).getTime());
    }
}</pre></div></div><br class="example-break"><p>现在，让我们看一下<code class="filename">Example4.drl</code>看看我们如何打印排序<code class="code">Cashflow</code>对象：</p><div class="example"><a id="d0e7946"></a><p class="title"><b>示例8.41银行业务教程：Example4.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 04"   
    when
        $cashflow : Cashflow( $date : date, $amount : amount )
        not Cashflow( date &lt; $date)
    then
        System.out.println("Cashflow: "+$date+" :: "+$amount);  
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>在这里，我们确定一个<code class="code">Cashflow</code>并提取日期和金额。在规则的第二行中，我们确保没有现金流的日期早于找到的现金流。结果，我们打印了<code class="code">Cashflow</code>满足规则然后撤消它，为下一个最早的方法<code class="code">Cashflow</code> 。因此，我们生成的输出为：</p><div class="example"><a id="d0e7962"></a><p class="title"><b>示例8.42银行业务教程：Example4.java的输出</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example4.drl
Inserting fact: Cashflow[date=Mon Jan 01 00:00:00 GMT 2007,amount=300.0]
Inserting fact: Cashflow[date=Fri Jan 05 00:00:00 GMT 2007,amount=100.0]
Inserting fact: Cashflow[date=Thu Jan 11 00:00:00 GMT 2007,amount=500.0]
Inserting fact: Cashflow[date=Sun Jan 07 00:00:00 GMT 2007,amount=800.0]
Inserting fact: Cashflow[date=Tue Jan 02 00:00:00 GMT 2007,amount=400.0]
Cashflow: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Cashflow: Tue Jan 02 00:00:00 GMT 2007 :: 400.0
Cashflow: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Cashflow: Sun Jan 07 00:00:00 GMT 2007 :: 800.0
Cashflow: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>接下来，我们扩展我们的<code class="code">Cashflow</code> ，导致<code class="code">TypedCashflow</code>可以是贷记或借记操作。（通常，我们将其添加到<code class="code">Cashflow</code>类型，但我们使用扩展名来保留该类的先前版本。）</p><div class="example"><a id="d0e7978"></a><p class="title"><b>示例8.43银行业务教程：类TypedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class TypedCashflow extends Cashflow {
    public static final int CREDIT = 0;
    public static final int DEBIT  = 1;

    private int             type;

    public TypedCashflow() {
    }

    public TypedCashflow(Date date, int type, double amount) {
        super( date, amount );
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String toString() {
        return "TypedCashflow[date=" + getDate() +
               ",type=" + (type == CREDIT ? "Credit" : "Debit") +
               ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>有很多方法可以改进此代码，但是出于示例的目的，这可以做到。</p><p>现在让我们创建Example5，这是一个用于运行代码的类。</p><div class="example"><a id="d0e7987"></a><p class="title"><b>示例8.44银行业务教程：Example5.java</b></p><div class="example-contents"><pre class="programlisting">public class Example5 {    
    public static void main(String[] args) throws Exception {      
        Object[] cashflows = {
            new TypedCashflow(new SimpleDate("01/01/2007"),    
                              TypedCashflow.CREDIT, 300.00),
            new TypedCashflow(new SimpleDate("05/01/2007"),
                              TypedCashflow.CREDIT, 100.00),
            new TypedCashflow(new SimpleDate("11/01/2007"),
                              TypedCashflow.CREDIT, 500.00),
            new TypedCashflow(new SimpleDate("07/01/2007"),
                              TypedCashflow.DEBIT, 800.00),
            new TypedCashflow(new SimpleDate("02/01/2007"),
                              TypedCashflow.DEBIT, 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example5.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>在这里，我们只需创建一组<code class="code">Cashflow</code>贷项或借项操作的对象。我们提供它们， <code class="filename">Example5.drl</code>到RuleEngine。</p><p>现在，让我们看一下打印排序的规则<code class="code">Cashflow</code>对象。</p><div class="example"><a id="d0e8005"></a><p class="title"><b>示例8.45银行业务教程：Example5.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 05"  
    when
        $cashflow : TypedCashflow( $date : date,
                                   $amount : amount,
                                   type == TypedCashflow.CREDIT )
        not TypedCashflow( date &lt; $date,
                           type == TypedCashflow.CREDIT )
    then
        System.out.println("Credit: "+$date+" :: "+$amount);   
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>在这里，我们确定一个<code class="code">Cashflow</code>一种类型的事实<code class="code">CREDIT</code>并提取日期和金额。在规则的第二行中，我们确保没有<code class="code">Cashflow</code>相同类型的日期早于找到的日期。结果，我们打印出满足模式的现金流量，然后将其收回，为下一最早的现金流量类型腾出空间<code class="code">CREDIT</code> 。</p><p>因此，我们生成的输出是</p><div class="example"><a id="d0e8026"></a><p class="title"><b>示例8.46银行业务教程：Example5.java的输出</b></p><div class="example-contents"><pre class="screen">Loading file: Example5.drl
Inserting fact: TypedCashflow[date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: TypedCashflow[date=Fri Jan 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: TypedCashflow[date=Thu Jan 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: TypedCashflow[date=Sun Jan 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: TypedCashflow[date=Tue Jan 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Credit: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Credit: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>继续我们的银行业务，我们现在将处理两个银行帐户上的贷方和借方，以计算帐户余额。为此，我们创建两个单独的<code class="code">Account</code>对象并将其注入<code class="code">Cashflows</code>对象，然后再将它们传递给规则引擎。这样做的原因是可以轻松访问正确的帐户，而不必求助于助手类。让我们来看看<code class="code">Account</code>全班第一这是一个简单的Java对象，具有帐号和余额：</p><div class="example"><a id="d0e8042"></a><p class="title"><b>示例8.47银行教程：班级账户</b></p><div class="example-contents"><pre class="programlisting">public class Account {
    private long   accountNo;
    private double balance = 0;

    public Account() {
    }

    public Account(long accountNo) {
        this.accountNo = accountNo;
    }

    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account[" + "accountNo=" + accountNo + ",balance=" + balance + "]";
    }
}</pre></div></div><br class="example-break"><p>现在让我们扩展我们的<code class="code">TypedCashflow</code> ， 导致<code class="code">AllocatedCashflow</code> ，包括一个<code class="code">Account</code>参考。</p><div class="example"><a id="d0e8058"></a><p class="title"><b>示例8.48银行业务教程：类AllocatedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class AllocatedCashflow extends TypedCashflow {
    private Account account;

    public AllocatedCashflow() {
    }

    public AllocatedCashflow(Account account, Date date, int type, double amount) {
        super( date, type, amount );
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public String toString() {
        return "AllocatedCashflow[" +
               "account=" + account +
               ",date=" + getDate() + 
               ",type=" + (getType() == CREDIT ? "Credit" : "Debit") + 
               ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>的Java代码<code class="filename">Example5.java</code>创建两个<code class="code">Account</code>对象，并在构造函数调用中将其中之一传递到每个现金流中。</p><div class="example"><a id="d0e8071"></a><p class="title"><b>示例8.49银行业务教程：Example5.java</b></p><div class="example-contents"><pre class="programlisting">public class Example6 {    
    public static void main(String[] args) throws Exception {      
        Account acc1 = new Account(1);
        Account acc2 = new Account(2);
           
        Object[] cashflows = {
            new AllocatedCashflow(acc1,new SimpleDate("01/01/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/02/2007"),
                                  TypedCashflow.CREDIT, 100.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/03/2007"),
                                  TypedCashflow.CREDIT, 500.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/02/2007"),
                                  TypedCashflow.DEBIT,  800.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/03/2007"),
                                  TypedCashflow.DEBIT,  400.00),
            new AllocatedCashflow(acc1,new SimpleDate("01/04/2007"),    
                                  TypedCashflow.CREDIT, 200.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/04/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/05/2007"),
                                  TypedCashflow.CREDIT, 700.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/05/2007"),
                                  TypedCashflow.DEBIT,  900.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/05/2007"),
                                  TypedCashflow.DEBIT,  100.00)           
        };
        
        new RuleRunner().runRules( new String[] { "Example6.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>现在，让我们来看一下<code class="filename">Example6.drl</code>了解我们如何按日期顺序应用每个现金流量，并计算和打印余额。</p><div class="example"><a id="d0e8081"></a><p class="title"><b>示例8.50银行业务教程：Example6.drl中的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 06 - Credit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                                       $date : date,
                                       $amount : amount,
                                       type == TypedCashflow.CREDIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Credit: " + $date + " :: " + $amount);     
        $account.setBalance($account.getBalance()+$amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());          
        retract($cashflow);
end

rule "Rule 06 - Debit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                            $date : date,
                            $amount : amount,
                            type == TypedCashflow.DEBIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Debit: " + $date + " :: " + $amount);      
        $account.setBalance($account.getBalance() - $amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());           
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>尽管我们对贷方和借方有单独的规则，但是在检查较早的现金流量时我们没有指定类型。这样，所有现金流量都按日期顺序应用，而不管现金流量类型如何。在条件下，我们确定要使用的帐户，在后果中，我们用现金流量金额对其进行更新。</p><div class="example"><a id="d0e8088"></a><p class="title"><b>示例8.51银行业务教程：Example6.java的输出</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example6.drl
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0]
Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0
Account: 2 - new balance: -400.0
Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0
Account: 2 - new balance: 100.0
Debit: Wed May 02 00:00:00 BST 2007 :: 100.0
Account: 2 - new balance: 0.0
Credit: Fri May 11 00:00:00 BST 2007 :: 700.0
Account: 2 - new balance: 700.0
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Account: 1 - new balance: 300.0
Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0
Account: 1 - new balance: 400.0
Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0
Account: 1 - new balance: -400.0
Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0
Account: 1 - new balance: -200.0
Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0
Account: 1 - new balance: 100.0
Debit: Mon May 07 00:00:00 BST 2007 :: 900.0
Account: 1 - new balance: -800.0
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8093"></a> 8.6。定价规则决策表示例</h2></div></div></div><p>定价规则决策表演示了电子表格中决策表在Excel的XLS格式中的用法，用于计算保险单的零售成本。提供一组规则的目的是为申请特定策略的汽车驾驶员计算基本价格和折扣。驾驶员的年龄，历史和保单类型都对基本保费产生了影响，另外还有很多规则以折扣率来完善。</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Example Policy Pricing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PricingRuleDTExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> ExamplePolicyPricing.xls
<span class="bold"><strong>Objective:</strong></span> demonstrate spreadsheet-based decision tables.</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8114"></a> 8.6.1。执行示例</h3></div></div></div><p>开启档案<code class="filename">PricingRuleDTExample.java</code>并将其作为Java应用程序执行。它应该在“控制台”窗口中产生以下输出：</p><pre class="programlisting">Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20     </pre><p>执行该示例的代码遵循通常的模式。加载规则，插入事实并创建无状态会话。区别在于如何添加规则。</p><pre class="programlisting">DecisionTableConfiguration dtableconfiguration =
    KnowledgeBuilderFactory.newDecisionTableConfiguration();
        dtableconfiguration.setInputType( DecisionTableInputType.XLS );

        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        Resource xlsRes = ResourceFactory.newClassPathResource( "ExamplePolicyPricing.xls",
                                                                getClass() );
        kbuilder.add( xlsRes,
                      ResourceType.DTABLE,
                      dtableconfiguration );
</pre><p>注意使用<code class="code">DecisionTableConfiguration</code>宾语。其输入类型设置为<code class="code">DecisionTableInputType.XLS</code> 。如果您使用BRMS，那么所有这些当然都会为您解决。</p><p>在此示例中使用了两种事实类型： <code class="code">Driver</code>和<code class="code">Policy</code> 。两者都使用其默认值。的<code class="code">Driver</code>年龄30岁，之前没有索偿要求，目前的风险状况为<code class="code">LOW</code> 。的<code class="code">Policy</code>正在申请的是<code class="code">COMPREHENSIVE</code> ，并且尚未被批准。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8156"></a> 8.6.2。决策表</h3></div></div></div><p>在此决策表中，每一行都是一条规则，每一列都是一个条件或一个动作。</p><div class="figure"><a id="d0e8161"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Config.png" width="100%" alt="决策表配置"></td></tr></tbody></table></div></div><p class="title"><b>图8.10。决策表配置</b></p></div><br class="figure-break"><p>参考上面显示的电子表格，我们有<code class="code">RuleSet</code>声明，提供包名称。您还可以在这里拥有其他可选项，例如<code class="code">Variables</code>用于全局变量，以及<code class="code">Imports</code>用于导入课程。在这种情况下，规则的名称空间与我们使用的事实类相同，因此我们可以忽略它。</p><p>再往下走，我们可以看到<code class="code">RuleTable</code>宣言。此后的名称（“价格”括号）用作所有生成的规则的前缀。在其下，我们具有“ CONDITION或ACTION”，指示该列的用途，即，它是构成条件的一部分还是要生成的规则的结果。</p><p>您可以看到有一个驱动程序，其数据跨越三个单元格，这意味着其下方的模板表达式适用于该事实。我们观察驾驶员的年龄范围（ <code class="code">$1</code>和<code class="code">$2</code> （以逗号分隔的值）， <code class="code">locationRiskProfile</code>和<code class="code">priorClaims</code>在相应的列中。在操作列中，我们设置了策略基本价格并记录了一条消息。</p><div class="figure"><a id="d0e8197"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Table1.png" width="100%" alt="底价计算"></td></tr></tbody></table></div></div><p class="title"><b>图8.11。底价计算</b></p></div><br class="figure-break"><p>在前面的电子表格部分中，有最广泛的类别括号，由最左边一栏中的注释指示。据我们所知，我们的司机及其政策的细节，我们可以（稍加思索）告诉他们，他们应该与第18行匹配，因为他们以前没有发生过事故，并且已经30岁了。这使我们的基本价格为120。</p><div class="figure"><a id="d0e8205"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/PricingExample/DT_Table2.png" width="100%" alt="折扣计算"></td></tr></tbody></table></div></div><p class="title"><b>图8.12。折扣计算</b></p></div><br class="figure-break"><p>上一节包含了我们可能给予驾驶员折扣的条件。折扣来自<code class="code">Age</code>括号，在先索赔的数量和保单类型。在我们的案例中，司机是30岁，没有任何先前的要求，并且正在申请<code class="code">COMPREHENSIVE</code>政策，这意味着我们可以给予20％的折扣。请注意，这实际上是一个单独的表，但是在同一工作表中，因此可以应用不同的模板。</p><p>重要的是要注意决策表会生成规则。这意味着它们不仅仅是简单的自上而下的逻辑，而是一种捕获产生规则的数据的方法。这是一个细微的差异，使某些人感到困惑。规则的评估不一定按给定的顺序进行，因为规则引擎的所有常规机制仍然适用。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8221"></a> 8.7。宠物店的例子</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Pet Store 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PetStore
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> PetStore.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Agenda Groups, Global Variables and integration with a GUI,
including callbacks from within the rules
</pre><p>宠物商店示例显示了如何将规则与GUI（在本例中为基于Swing的桌面应用程序）集成在一起。在规则文件中，它演示了如何使用议程组和自动对焦来控制允许在任何给定时间触发一组规则中的哪一个。它还说明了规则中Java和MVEL方言的混合，累加函数的使用以及从规则集中调用Java函数的方式。</p><p>所有Java代码都包含在一个文件中， <code class="filename">PetStore.java</code> ，定义了以下主要类（除了几个用于处理Swing事件的类）：</p><div class="itemizedlist"><ul><li><p><code class="code">Petstore</code>包含<code class="code">main()</code>我们将很快介绍的方法。</p></li><li><p><code class="code">PetStoreUI</code>负责创建和显示基于Swing的GUI。它包含几个较小的类，主要用于响应各种GUI事件，例如鼠标单击。</p></li><li><p><code class="code">TableModel</code>保存表数据。将其视为扩展了Swing类的JavaBean <code class="code">AbstractTableModel</code> 。</p></li><li><p><code class="code">CheckoutCallback</code>允许GUI与规则进行交互。</p></li><li><p><code class="code">Ordershow</code>保留我们要购买的物品。</p></li><li><p><code class="code">Purchase</code>存储订单的详细信息以及我们要购买的产品。</p></li><li><p><code class="code">Product</code>是JavaBean，其中包含可购买的产品的详细信息及其价格。</p></li></ul></div><p>许多Java代码是纯JavaBean或基于Swing的。本节仅讨论与Swing相关的几点，但是可以在Sun的Swing网站上找到有关Swing组件的很好的教程，网址为： <a class="ulink" href="???"><code class="uri">http://java.sun.com/docs/books/tutorial/uiswing/</code></a> 。</p><p>中的Java代码片段<code class="filename">Petstore.java</code>与规则和事实有关的内容如下所示。</p><div class="example"><a id="d0e8302"></a><p class="title"><b>示例8.52在PetStore.main中创建PetStore RuleBase</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

kbuilder.add( ResourceFactory.newClassPathResource( "PetStore.drl",
                                                    PetStore.class ),
              ResourceType.DRL );
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );

// Create the stock.
Vector&lt;Product&gt; stock = new Vector&lt;Product&gt;();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the
// Working Memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kbase ) );
ui.createAndShowGUI();
</pre></div></div><br class="example-break"><p>上面显示的代码从类路径上的DRL文件加载规则。与其他事实被断言并立即触发的其他示例不同，此示例将这一步骤推迟到以后。这样做的方式是通过倒数第二行<code class="code">PetStoreUI</code>对象是使用接受<code class="code">Vector</code>宾语<code class="code">stock</code>收集我们的产品，以及<code class="code">CheckoutCallback</code>包含我们刚刚加载的Rule Base的类。</p><p>触发规则的Java代码位于<code class="code">CheckoutCallBack.checkout()</code>方法。（最终）当用户按下“签出”按钮时触发。</p><div class="example"><a id="d0e8326"></a><p class="title"><b>示例8.53触发规则-从CheckoutCallBack.checkout（）中提取</b></p><div class="example-contents"><pre class="programlisting">public String checkout(JFrame frame, List&lt;Product&gt; items) {
    Order order = new Order();

    // Iterate through list and add to cart
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction

    StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );
    ksession.fireAllRules();

    // Return the state of the cart
    return order.toString();
}
</pre></div></div><br class="example-break"><p>有两项传递给此方法。一个是处理<code class="code">JFrame</code>在GUI底部，围绕输出文本框的Swing组件。第二个是订单项列表；这来自<code class="code">TableModel</code>存储来自GUI右上角“表格”区域的信息。</p><p>for循环将来自GUI的订单项列表转换为<code class="code">Order</code> JavaBean，也包含在文件中<code class="filename">PetStore.java</code> 。请注意，可以直接在规则内引用Swing数据集，但是更好的编码实践是使用简单的Java对象以这种方式进行操作。这意味着如果我们想将样本转换为Web应用程序，我们就不会受到Swing的束缚。</p><p>重要的是要注意， <span class="emphasis"><em>此示例</em></span>中的<span class="emphasis"><em>所有状态都存储在Swing组件中，并且规则实际上是无状态的。</em></span> 每次按下“签出”按钮，此代码都会复制Swing的内容<code class="code">TableModel</code>进入会议的工作记忆。</p><p>在此代码中，有9个对工作内存的调用。其中的第一个创建新的工作记忆，作为知识库中的有状态知识会话。请记住，当我们创建<code class="code">CheckoutCallBack</code>中的课程<code class="code">main()</code>方法。接下来的两个调用传入两个我们将作为规则中的全局变量保存的对象：Swing文本区域和用于编写消息的Swing框架。</p><p>更多插入将有关产品的信息以及订单列表放入工作存储器中。最终通话是标准<code class="code">fireAllRules()</code> 。接下来，我们看一下该方法导致规则文件中发生什么。</p><div class="example"><a id="d0e8368"></a><p class="title"><b>示例8.54打包，导入，全局和方言：从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">package org.drools.examples

import org.drools.WorkingMemory
import org.drools.examples.PetStore.Order
import org.drools.examples.PetStore.Purchase
import org.drools.examples.PetStore.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame 
global javax.swing.JTextArea textArea</pre></div></div><br class="example-break"><p>文件的第一部分<code class="filename">PetStore.drl</code>包含标准的package和import语句，以使各种Java类可用于规则。对我们来说新来的是两个全球<code class="code">frame</code>和<code class="code">textArea</code> 。它们包含对Swing组件的引用<code class="code">JFrame</code>和<code class="code">JTextArea</code>之前由Java代码传递的组件<code class="code">setGlobal()</code>方法。不同于规则中的变量（规则触发后立即失效），全局变量在会话的生命周期内保留其值。</p><p>文件的下一个摘录<code class="filename">PetStore.drl</code>包含两个函数，这些规则将在稍后介绍。</p><div class="example"><a id="d0e8398"></a><p class="title"><b>示例8.55规则中的Java函数：从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">function void doCheckout(JFrame frame, WorkingMemory workingMemory) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
        "Would you like to checkout?",
        "",
        JOptionPane.YES_NO_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null,
        options,
        options[0]);

    if (n == 0) {
        workingMemory.setFocus( "checkout" );
    }   
}

function boolean requireTank(JFrame frame, WorkingMemory workingMemory, Order order, Product fishTank, int total) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
        "Would you like to buy a tank for your " + total + " fish?",
        "Purchase Suggestion",
        JOptionPane.YES_NO_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null,
        options,
        options[0]);
                                             
    System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                      + total + " fish? - " );

    if (n == 0) {
        Purchase purchase = new Purchase( order, fishTank );
        workingMemory.insert( purchase );
        order.addItem( purchase );
        System.out.println( "Yes" );
    } else {
        System.out.println( "No" );
    }      
    return true;
}
</pre></div></div><br class="example-break"><p>在rules文件中具有这些功能只会使Pet Store示例更加紧凑。在现实生活中，您可能会将这些函数保存在自己的文件中，在相同的规则包内，或者作为标准Java类上的静态方法，然后使用以下命令将其导入<code class="code">import function my.package.Foo.hello</code> 。</p><p>这两个功能的目的是：</p><div class="itemizedlist"><ul><li><p><code class="code">doCheckout()</code>显示一个对话框，询问用户是否要结帐。如果这样做，则将焦点设置为<code class="code">checkOut</code>议程组，从而允许该组中的规则（可能）触发。</p></li><li><p><code class="code">requireTank()</code>显示一个对话框，询问用户是否要购买坦克。如果是这样，新的鱼缸<code class="code">Product</code>被添加到工作存储器中的订单列表中。</p></li></ul></div><p>稍后我们将看到调用这些函数的规则。下一组示例来自Pet Store规则本身。第一个提取物是最先点火的，部分原因是它具有<strong class="kw"><code>auto-focus</code></strong>属性设置为true。</p><div class="example"><a id="d0e8432"></a><p class="title"><b>示例8.56将项目放入工作内存：从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">// Insert each item in the shopping cart into the Working Memory 
// Insert each item in the shopping cart into the Working Memory
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end</pre></div></div><br class="example-break"><p>此规则与所有尚无订单的订单匹配<code class="code">grossTotal</code>计算的。它针对该订单中的每个购买项目循环。应该熟悉“爆炸车”规则的某些部分：规则名称，显着性（建议触发规则的顺序）以及将方言设置为<code class="code">"java"</code> 。新增了三个功能：</p><div class="itemizedlist"><ul><li><p><strong class="kw"><code>agenda-group</code></strong> <code class="code">"init"</code>定义议程组的名称。在这种情况下，组中只有一个规则。但是，Java代码和规则结果都不会将焦点放在此组上，因此，它有赖于下一个目标来激发它的机会。</p></li><li><p><strong class="kw"><code>auto-focus</code></strong> <code class="code">true</code>确保此规则虽然是议程组中的唯一规则，但有机会在<code class="code">fireAllRules()</code>从Java代码中调用。</p></li><li><p><code class="code">kcontext....setFocus()</code>将重点放在<code class="code">"show items"</code>和<code class="code">"evaluate"</code>反过来，让他们的规则被解散。实际上，我们遍历订单上的所有项目，将它们插入内存，然后在每次插入后触发其他规则。</p></li></ul></div><p>接下来的两个清单显示了<code class="code">"show items"</code>和<code class="code">evaluate</code>议程小组。我们按照它们被调用的顺序查看它们。</p><div class="example"><a id="d0e8484"></a><p class="title"><b>示例8.57在GUI中显示项目-从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
</pre></div></div><br class="example-break"><p>的<code class="code">"show items"</code>议程组只有一个规则，称为“显示项目”（注意大小写不同）。对于当前在工作内存（或会话）中的订单的每次购买，它将详细信息记录到GUI底部的文本区域。的<code class="code">textArea</code>用于执行此操作的变量是我们前面介绍的全局变量之一。</p><p>的<code class="code">evaluate</code>议程小组也从<code class="code">"Explode Cart"</code>之前列出的规则。该议程组有两个规则， <code class="code">"Free Fish Food Sample"</code>和<code class="code">"Suggest Tank"</code> ，如下所示。</p><div class="example"><a id="d0e8511"></a><p class="title"><b>示例8.58评估议程组：从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">// Free Fish Food sample when we buy a Gold Fish if we haven't already bought 
// Fish Food and don't already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate"
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;amp;&amp;amp; Purchase( product == $p ) )
    not ( $p : Product( name == "Fish Food Sample") &amp;amp;&amp;amp; Purchase( product == $p ) )
    exists ( $p : Product( name == "Gold Fish") &amp;amp;&amp;amp; Purchase( product == $p ) )
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

// Suggest a tank if we have bought more than 5 gold fish and don't already have one
rule "Suggest Tank"
    agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;amp;&amp;amp; Purchase( product == $p ) )
    ArrayList( $total : size &amp;gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) )
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, drools.getWorkingMemory(), $order, $fishTank, $total); 
end
</pre></div></div><br class="example-break"><p>规则<code class="code">"Free Fish Food Sample"</code>只会在以下情况下触发</p><div class="itemizedlist"><ul><li><p>我们<span class="emphasis"><em>还没有</em></span>任何鱼类食品， <span class="emphasis"><em>并且</em></span></p></li><li><p>我们<span class="emphasis"><em>还没有</em></span>免费的鱼类食品样品， <span class="emphasis"><em>并且</em></span></p></li><li><p>我们的订单中<span class="emphasis"><em>确实</em></span>有一条金鱼。</p></li></ul></div><p>如果该规则触发，它将创建一个新产品（鱼类食品样品），并将其添加到工作记忆库中的订单中。</p><p>规则<code class="code">"Suggest Tank"</code>只会在以下情况下触发</p><div class="itemizedlist"><ul><li><p>我们的订单中<span class="emphasis"><em>还没有</em></span>鱼缸， <span class="emphasis"><em>并且</em></span></p></li><li><p>我们的订单中<span class="emphasis"><em>确实</em></span>有超过5种金鱼产品。</p></li></ul></div><p>如果该规则确实触发，它将调用<code class="code">requireTank()</code>我们之前看过的功能（向用户显示一个对话框，并在确认后将Tank添加到订单/工作记忆中）。调用<span class="italic">requireTank</span> （）函数时，规则将传递全局<span class="italic">框架</span>变量，以便该函数具有Swing GUI的句柄。</p><p>我们要看的下一条规则是<code class="code">"do checkout"</code> 。</p><div class="example"><a id="d0e8582"></a><p class="title"><b>示例8.59执行结帐-从PetStore.drl中提取（6）</b></p><div class="example-contents"><pre class="programlisting">rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, drools.getWorkingMemory());
end</pre></div></div><br class="example-break"><p>规则<code class="code">"do checkout"</code> <span class="bold"><strong>没有设置议程组，也没有自动对焦属性</strong></span> 。因此，被视为默认（MAIN）议程组的一部分。默认情况下，当议程组中的所有规则均已集中执行时，该组将成为焦点。</p><p>规则没有LHS，因此RHS始终会调用<code class="code">doCheckout()</code>功能。致电时<code class="code">doCheckout()</code>功能，规则通过全局<code class="code">frame</code>变量，为该函数提供Swing GUI的句柄。如我们先前所见， <code class="code">doCheckout()</code>功能向用户显示一个确认对话框。如果确认，该功能会将焦点设置到<span class="italic">结帐</span>议程组，从而触发下一组规则。</p><div class="example"><a id="d0e8612"></a><p class="title"><b>示例8.60结帐规则：从PetStore.drl中提取</b></p><div class="example-contents"><pre class="programlisting">rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue )
       from accumulate( Purchase( $price : product.price ), sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 10 &amp;amp;&amp;amp; &amp;lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
</pre></div></div><br class="example-break"><p><span class="italic">结帐</span>议程组中有三个规则：</p><div class="itemizedlist"><ul><li><p>如果我们还没有计算出总数， <code class="code">Gross Total</code>将产品价格累加起来，将其累加到工作内存中，并通过Swing显示<code class="code">JTextArea</code> ， 使用<code class="code">textArea</code>全局变量了。</p></li><li><p>如果我们的总数在10到20之间， <code class="code">"Apply 5% Discount"</code>计算折扣后的总额并将其添加到工作记忆中并显示在文本区域中。</p></li><li><p>如果我们的总数不少于20， <code class="code">"Apply 10% Discount"</code>计算折扣后的总额并将其添加到工作记忆中并显示在文本区域中。</p></li></ul></div><p>现在我们已经遍历了代码中发生的一切，让我们看一下实际运行代码时发生的情况。文件<code class="filename">PetStore.java</code>包含一个<code class="code">main()</code>方法，以便可以从命令行或通过IDE作为标准Java应用程序运行。假设您正确设置了类路径。（有关更多信息，请参见示例部分的开头。）</p><p>我们看到的第一个屏幕是Pet Store Demo。它具有可用产品列表（左上方），空白产品列表（右上方），签出和重设按钮（中间）以及空白系统消息区域（底部）。</p><div class="figure"><a id="d0e8657"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/1-PetStore-Start-Screen.png" alt="发布后的PetStore演示"></div></div><p class="title"><b>图8.13。发布后的PetStore演示</b></p></div><br class="figure-break"><p>为了达到这一点，发生了以下事情：</p><div class="orderedlist"><ol type="1"><li><p>的<code class="code">main()</code>方法已运行并加载了规则库， <span class="emphasis"><em>但尚未触发规则</em></span> 。到目前为止，这是与已运行的规则有关的唯一代码。</p></li><li><p>一个新的<code class="code">PetStoreUI</code>对象已创建，并具有规则库的句柄，以备后用。</p></li><li><p>各种Swing组件都在工作，上面的屏幕显示出来并<span class="emphasis"><em>等待用户输入</em></span> 。</p></li></ol></div><p>单击列表中的各种产品可能会给您一个类似于以下屏幕的画面。</p><div class="figure"><a id="d0e8689"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/2-stock-added-to-order-list.png" alt="带有选定产品的PetStore演示"></div></div><p class="title"><b>图8.14。带有选定产品的PetStore演示</b></p></div><br class="figure-break"><p>请注意， <span class="emphasis"><em>此处未触发任何规则代码</em></span> 。这只是Swing代码，侦听鼠标单击事件，并将一些选定的产品添加到<code class="code">TableModel</code>显示在右上角的对象。（顺便说一句，请注意，这是Model View Controller设计模式的经典用法）。</p><p>只有当我们按下“签出”按钮时，我们才以与前面遍历代码大致相同的顺序触发业务规则。</p><div class="orderedlist"><ol type="1"><li><p>方法<code class="code">CheckOutCallBack.checkout()</code> （最终）由Swing类调用，以等待单击“签出”按钮。这将从<code class="code">TableModel</code>对象（在GUI的右上角），并将其插入到会话的工作内存中。然后触发规则。</p></li><li><p>的<code class="code">"Explode Cart"</code>规则是第一个被解雇的人<strong class="kw"><code>auto-focus</code></strong>设置为true。它遍历购物车中的所有产品，确保产品在工作内存中，然后提供<code class="code">"Show Items"</code>和<code class="code">Evaluation</code>议程小组有解雇的机会。这些组中的规则将购物车中的内容添加到文本区域（在窗口底部），确定是否给我们免费的鱼类食品，并询问我们是否要购买鱼缸。如下图所示。</p></li></ol></div><div class="figure"><a id="d0e8730"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/3-purchase-suggestion.png" alt="我们要买鱼缸吗？"></div></div><p class="title"><b>图8.15。我们要买鱼缸吗？</b></p></div><br class="figure-break"><div class="orderedlist"><ol type="1"><li><p>“ <span class="italic">执行结帐”</span>规则是下一个<span class="italic">可行的</span>规则，因为它（a）当前没有其他议程组具有焦点，并且（b）它是默认（MAIN）议程组的一部分。它总是调用<span class="italic">doCheckout（）函数</span> ，该<span class="italic">函数</span>显示“您要结帐吗？' 对话框。</p></li><li><p>的<code class="code">doCheckout()</code>功能将焦点设置为<code class="code">checkout</code>议程组，为该组中的规则提供触发选项。</p></li><li><p>中的规则<code class="code">checkout</code>议程组显示购物车中的物品并应用适当的折扣。</p></li><li><p><span class="emphasis"><em>然后，Swing等待用户输入</em></span>以签出更多产品（并导致规则再次触发）或关闭GUI-参见下图。</p></li></ol></div><div class="figure"><a id="d0e8766"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/PetStoreExample/4-Petstore-final-screen.png" alt="触发所有规则后，Petstore演示。"></div></div><p class="title"><b>图8.16。触发所有规则后，Petstore演示。</b></p></div><br class="figure-break"><p>我们可以添加更多System.out调用来演示事件流。下面的列表中给出了当前显示在“控制台”窗口中的输出。</p><div class="example"><a id="d0e8774"></a><p class="title"><b>示例8.61运行PetStore GUI的控制台（System.out）</b></p><div class="example-contents"><pre class="programlisting">Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8780"></a> 8.8。诚实的政客例子</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Honest Politician
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HonestPoliticianExample 
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HonestPoliticianExample.drl
<span class="bold"><strong>Objective:</strong></span> Illustrate the concept of "truth maintenance" based on the logical insertion of facts
</pre><p>诚实的政治家示例演示了使用逻辑断言维护真相的方法。基本前提是对象只能在语句为真时存在。规则的结果可以在逻辑上插入带有<code class="code">insertLogical()</code>方法。这意味着只要逻辑上将其插入的规则保持为真，该对象将仅保留在工作内存中。当规则不再适用时，对象将自动缩回。</p><p>在这个例子中有<code class="code">Politician</code> ，具有诚实的名称和布尔值。插入了四个将诚实状态设置为true的政治人物。</p><div class="example"><a id="d0e8810"></a><p class="title"><b>示例8.62班级政治家</b></p><div class="example-contents"><pre class="programlisting">public class Politician {
    private String name;
    private boolean honest;
    ...
}</pre></div></div><p><br class="example-break"></p><div class="example"><a id="d0e8815"></a><p class="title"><b>示例8.63诚实的政客：处决</b></p><div class="example-contents"><pre class="programlisting">Politician blair = new Politician("blair", true);
Politician bush = new Politician("bush", true);
Politician chirac = new Politician("chirac", true);
Politician schroder = new Politician("schroder", true);
    
ksession.insert( blair );
ksession.insert( bush );
ksession.insert( chirac );
ksession.insert( schroder );

ksession.fireAllRules();</pre></div></div><p><br class="example-break">控制台窗口的输出显示，尽管至少有一位诚实的政治家，但民主仍然存在。但是，由于每个政客又被一家邪恶的公司腐败，以致所有政客变得不诚实，民主就死了。</p><div class="example"><a id="d0e8821"></a><p class="title"><b>示例8.64诚实的政客：控制台输出</b></p><div class="example-contents"><pre class="programlisting">Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted schroder
I'm an evil corporation and I have corrupted chirac
I'm an evil corporation and I have corrupted bush
I'm an evil corporation and I have corrupted blair
We are all Doomed!!! Democracy is Dead
</pre></div></div><p><br class="example-break">只要工作记忆中至少有一位诚实的政治家， <code class="code">Hope</code>对象在逻辑上被断言。只有在至少有一位诚实的政治家时，该对象才会存在。一旦所有政客都不诚实， <code class="code">Hope</code>物体将自动缩回。此规则的显着性为10，以确保它在其他任何规则之前触发，因为在此阶段，“希望死了”规则实际上是正确的。</p><div class="example"><a id="d0e8833"></a><p class="title"><b>示例8.65诚实的政客：统治“我们有一个诚实的政客”</b></p><div class="example-contents"><pre class="programlisting">rule "We have an honest Politician"
    salience 10
    when
        exists( Politician( honest == true ) )
    then
        insertLogical( new Hope() );
end</pre></div></div><br class="example-break"><p>尽快<code class="code">Hope</code>对象存在“希望生命”规则匹配并触发。它的显着性为10，因此优先于“诚实的腐败”。</p><div class="example"><a id="d0e8843"></a><p class="title"><b>示例8.66诚实的政客：统治“希望生活”</b></p><div class="example-contents"><pre class="programlisting">rule "Hope Lives"
    salience 10
        when
            exists( Hope() )
        then
            System.out.println("Hurrah!!! Democracy Lives");
end</pre></div></div><br class="example-break"><p>现在有了希望，我们一开始就有四个诚实的政治家，我们有四个针对这一规则的激励措施，但都处于冲突之中。他们将依次解雇，使每位政客腐败，使他们不再诚实。当所有四个政治人物都被腐败时，我们就没有财产的政治人物<code class="code">honest == true</code> 。因此，“我们有一个诚实的政治家”规则不再是正确的，并且它在逻辑上插入了该对象（由于最后一次执行<code class="code">new Hope()</code> ）会自动缩回。</p><div class="example"><a id="d0e8856"></a><p class="title"><b>示例8.67诚实的政客：统治“廉洁”</b></p><div class="example-contents"><pre class="programlisting">rule "Corrupt the Honest"
    when
        politician : Politician( honest == true )   
        exists( Hope() )
    then
        System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
        modify ( politician ) { honest = false };
end</pre></div></div><br class="example-break"><p>随着<code class="code">Hope</code>通过真相维护系统自动撤回有条件的物体<strong class="kw"><code>not</code></strong>应用于<code class="code">Hope</code>不再适用，因此以下规则将匹配并触发。</p><div class="example"><a id="d0e8872"></a><p class="title"><b>示例8.68诚实的政客：规则“希望已死”</b></p><div class="example-contents"><pre class="programlisting">rule "Hope is Dead"
    when
        not( Hope() )
    then
        System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</pre></div></div><br class="example-break"><p>让我们看一下该应用程序的审计跟踪：</p><div class="figure"><a id="d0e8879"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/HonestPoliticianExample/honest_politician_audit.png" width="100%" alt="诚实的政客示例审计视图"></td></tr></tbody></table></div></div><p class="title"><b>图8.17。诚实的政客示例审计视图</b></p></div><br class="figure-break"><p>插入第一位政治人物的那一刻，我们有两次激活。对于第一个插入的政治人物，“我们有一个诚实的政治人物”规则仅被激活一次，因为它使用了<strong class="kw"><code>exists</code></strong>条件元素，该元素一次匹配任何数字。由于我们尚未插入“希望已死”规则，因此在此阶段也已激活<code class="code">Hope</code>宾语。首先触发“我们有一个诚实的政治家”规则，因为它比“希望死了”具有更高的显着性，该规则插入了<code class="code">Hope</code>宾语。（该操作以绿色突出显示。）的插入<code class="code">Hope</code>对象激活“希望生命”并取消激活“希望已死”；它还会为每个插入的诚实政客激活“诚实廉正”。执行“希望生活”规则，并打印“ Hurrah !!!！民主生活”。然后，对每个政治家，规则“ Corrupt the Honest”都将被执行，并打印“我是一家邪恶的公司，我已经破坏了X”，其中X是政治家的名字，并将该政治家的诚实价值修改为false。当最后一个诚实的政治家遭到破坏时， <code class="code">Hope</code>被真相维护系统自动收回，如蓝色突出显示的区域所示。绿色突出显示区域显示了当前选中的蓝色突出显示区域的来源。一旦<code class="code">Hope</code>事实撤回，“希望已死”激活并触发打印“我们都注定了！！！民主已死”。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8905"></a> 8.9。数独示例</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Sudoku
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.sudoku.Main
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> sudokuSolver.drl, sudokuValidator.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates the solving of logic problems, and complex pattern matching.
</pre><p>此示例演示了如何根据大量约束在大量潜在解决方案空间中使用Drools查找解决方案。我们使用数独的流行难题。此示例还显示了如何将Drools集成到图形界面中，以及如何使用回调与正在运行的Drools规则引擎进行交互，以便基于运行时工作内存中的更改来更新图形界面。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8926"></a> 8.9.1。数独概述</h3></div></div></div><p>数独是一个基于逻辑的数字放置难题。目的是填充一个9x9的网格，以便每一列，每一行以及9个3x3区域中的每一个都包含1到9的数字，一次且仅一次。</p><p>拼图设置器提供了部分完成的网格，拼图求解器的任务是在这些约束条件下完成网格。</p><p>解决该问题的一般策略是确保在插入新数字时，该数字在其特定的3x3区域，行和列中应该是唯一的。</p><p>看到</p><pre class="programlisting">URL: http://en.wikipedia.org/wiki/Sudoku</pre><p>以获得更详细的描述。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8940"></a> 8.9.2。运行示例</h3></div></div></div><p>如上所述下载并安装drools-examples，然后执行<code class="filename">java org.drools.examples.sudoku.Main</code> 。本示例需要Java 5。</p><p>将显示一个带有相对简单的部分填充网格的窗口。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku1.png"></div></div><p>单击“解决”按钮，基于Drools的引擎将填写剩余的值。“控制台”窗口将以人类可读的形式显示有关为解决难题而执行的规则的详细信息。</p><pre class="screen">Rule #3 determined the value at (4,1) could not be 4 as this value already exists in the same column at (8,1)
Rule #3 determined the value at (5,5) could not be 2 as this value already exists in the same row at (5,6)
Rule #7 determined (3,5) is 2 as this is the only possible cell in the column that can have this value
Rule #1 cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of 2 exists for this cell.
Rule #1 cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of 2 exists for this cell.
... 
Rule #3 determined the value at (1,1) could not be 1 as this value already  exists in the same zone at (2,1)
Rule #6 determined (1,7) is 1 as this is the only possible cell in the row that can have this value
Rule #1 cleared the other PossibleCellValues for (1,7) as a ResolvedCellValue of 1 exists for this cell.
Rule #6 determined (1,1) is 8 as this is the only possible cell in the row that can have this value</pre><p>一旦求解逻辑的所有激活规则均已执行，引擎将执行第二个规则库以检查解决方案是否完整和有效。在这种情况下，“解决”按钮被禁用并显示类似<code class="code">"Solved (1052ms)"</code> 。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku2.png"></div></div><p>该示例带有许多可以加载和求解的网格。单击“文件”，然后单击“样本”和“中”以加载更具挑战性的网格。请注意，在加载新网格时，启用了“求解”按钮。
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku3.png"></div></div><p>再次单击“解决”按钮以解决此新网格。
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku4.png"></div></div><p>现在，让我们加载一个故意无效的Sudoku网格。单击“文件”，“样本”和“！故意破碎！”。请注意，此网格从某些问题开始，例如，值5在第一行中出现两次。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku5.png"></div></div><p>但是，单击“解决”按钮可将求解规则应用于此无效网格。请注意，“解决”按钮被重新标记以指示所得解决方案无效。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku6.png"></div></div><p>此外，验证规则集会将发现的所有问题输出到控制台。</p><pre class="programlisting">
There are two cells on the same column with the same value at (6,0) and (4,0)
There are two cells on the same column with the same value at (4,0) and (6,0)
There are two cells on the same row with the same value at (2,4) and (2,2)
There are two cells on the same row with the same value at (2,2) and (2,4)
There are two cells on the same row with the same value at (6,3) and (6,8)
There are two cells on the same row with the same value at (6,8) and (6,3)
There are two cells on the same column with the same value at (7,4) and (0,4)
There are two cells on the same column with the same value at (0,4) and (7,4)
There are two cells on the same row with the same value at (0,8) and (0,0)
There are two cells on the same row with the same value at (0,0) and (0,8)
There are two cells on the same column with the same value at (1,2) and (3,2)
There are two cells on the same column with the same value at (3,2) and (1,2)
There are two cells in the same zone with the same value at (6,3) and (7,3)
There are two cells in the same zone with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (6,3) and (7,3)</pre><p>我们将在本节的后面部分讨论求解规则集，但是目前我们应该注意，某些理论上可解决的解决方案无法由引擎按现状进行解决。单击“文件”，“样本”，然后单击“硬3”以加载稀疏填充的网格。
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku7.png"></div></div><p>现在，单击“解决”按钮，请注意，即使（如果您是Sudoku爱好者）您可能也可以看到解决方案的前进方向，但当前规则无法完成表格。
      </p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Examples/SodukiExample/sudoku8.png"></div></div><p>目前，已经通过使用十个规则来实现求解功能。可以扩展此规则集，以使引擎能够处理更复杂的逻辑来填充此类网格。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9026"></a> 8.9.3。Java源代码和规则概述</h3></div></div></div><p>Java源代码可以在/ src / main / java / org / drools / examples / sudoku目录中找到，其中两个DRL文件定义了位于/ src / main / rules / org / drools / examples / sudoku中的规则目录。</p><p>包装<code class="code">org.drools.examples.sudoku.swing</code>包含一组实现Sudoku拼图框架的类。请注意，该软件包对Drools库没有任何依赖关系。<code class="code">SudokuGridModel</code>定义一个可以实现将Sudoku拼图存储为9x9网格的接口<code class="code">Integer</code>值，其中一些可能为null，表示该单元的值尚未解析。
      <code class="code">SudokuGridView</code>是一个Swing组件，可以可视化实现<code class="code">SudokuGridModel</code> 。 <code class="code">SudokuGridEvent</code>和<code class="code">SudokuGridListener</code>用于在模型和视图之间传递状态更改：解析或更改单元格的值时会触发事件。如果您熟悉其他Swing组件中的模型视图控制器模式，例如<code class="code">JTable</code>那么这种模式应该很熟悉。
      <code class="code">SudokuGridSamples</code>为演示目的提供了一些部分填充的数独难题。</p><p>包<code class="code">org.drools.examples.sudoku.rules</code>包含的实现<code class="code">SudokuGridModel</code>基于Drools。使用了两个Java对象，它们都扩展了<code class="code">AbstractCellValue</code>并代表网格中特定单元格的值，包括该单元格的行和列位置，该单元格所在的3x3区域的索引以及该单元格的值。
      <code class="code">PossibleCellValue</code>表示我们目前尚不确定单元格中的值是什么。给定单元格可能有2到9个可能的单元格值。 <code class="code">ResolvedCellValue</code>表示我们已确定单元格的值必须是多少。给定单元格只能有一个解析的单元格值。 <code class="code">DroolsSudokuGridModel</code>贯彻<code class="code">SudokuGridModel</code>并负责将部分指定单元格的初始二维数组转换为一组<code class="code">CellValue</code> Java对象，基于创建一个工作内存<code class="filename">solverSudoku.drl</code>并插入<code class="code">CellValue</code>对象进入工作记忆。当。。。的时候<code class="code">solve()</code>方法被调用，它依次调用<code class="code">fireAllRules()</code>在此工作记忆中尝试解决难题。 <code class="code">DroolsSudokuGridModel</code>附加一个<code class="code">WorkingMemoryListener</code>到工作记忆中，当难题解开时，它可以在插入和缩回事件中被调用。当一个新的<code class="code">ResolvedCellValue</code>插入到工作内存中，此回调允许实现触发<code class="code">SudokuGridEvent</code>对其<code class="code">SudokuGridListener</code>客户，然后可以实时更新自己。一旦求解器工作内存触发的所有规则都执行完毕， <code class="code">DroolsSudokuGridModel</code>根据以下内容运行第二组规则<code class="filename">validatorSudoku.drl</code>可以与同一组Java对象一起使用，以确定结果网格是否是有效的完整解决方案。</p><p>班级<code class="code">org.drools.examples.sudoku.Main</code>实现一个Java应用程序，将所需的组件组合在一起。</p><p>Packae <code class="code">org.drools.examples.sudoku</code>包含两个DRL文件。 <code class="filename">solverSudoku.drl</code>定义尝试解决数独难题的规则，并且<code class="filename">validator.drl</code>定义确定工作内存的当前状态是否代表有效解决方案的规则。两者都使用<code class="code">PossibleCellValue</code>和<code class="code">ResolvedCellValue</code>对象作为事实，并且在规则触发时都将信息输出到控制台窗口。在实际情况下，我们将插入日志记录信息并使用<code class="code">WorkingMemoryListener</code>向用户显示此信息，而不是以这种方式使用控制台。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9144"></a> 8.9.4。数独验证器规则（validatorSudoku.drl）</h3></div></div></div><p>我们从验证器规则开始，因为此规则集比求解器规则集更短，更简单。</p><p>第一条规则只是检查是否<code class="code">PossibleCellValue</code>对象保留在工作存储器中。解决难题后，只有<code class="code">ResolvedCellValue</code>对象应该存在，每个单元格一个。</p><p>其他三个规则均与所有<code class="code">ResolvedCellValue</code>对象并将其绑定到变量<code class="code">$resolved1</code> 。然后他们寻找<code class="code">ResolvedCellValues</code>包含相同值且分别位于相同的行，列或3x3区域中。如果这些规则被触发，它们会将消息添加到全局字符串列表中，以描述解决方案无效的原因。
      <code class="code">DroolsSudokoGridModel</code>在运行规则集之前注入此列表，并在调用后检查列表是否为空<code class="code">fireAllRules()</code> 。如果不为空，则它将打印列表中的所有字符串，并设置一个标志以指示未解决网格。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9174"></a> 8.9.5。数独求解规则（solverSudoku.drl）</h3></div></div></div><p>现在让我们看一下用于解决数独难题的更复杂的规则集。</p><p>规则＃1基本上是簿记规则。插入其他一些规则<code class="code">ResolvedCellValues</code>在确定给定单元格必须具有特定值之后，将它们放入特定行和列的工作存储器中。在这一点上，重要的是清除所有插入的工作存储器<code class="code">PossibleCellValues</code>在同一行和列中具有无效值。因此，此规则的显着性高于其余规则，以确保一旦LHS成立，对规则的激活就会移至议程的顶部并被解雇。反过来，这可以防止由于<code class="code">ResolvedCellValue</code>和一个或多个<code class="code">PossibleCellValues</code>存在于同一单元格中。这条规则也称<code class="code">update()</code>在<code class="code">ResolvedCellValue</code> ，即使实际上其值尚未修改以确保Drools向任何人触发事件<code class="code">WorkingMemoryListeners</code>附加到工作内存，以便他们可以自我更新-在这种情况下，以便GUI可以显示网格的新状态。</p><p>规则2标识网格中只有一个可能值的像元。第一行<strong class="kw"><code>when</code></strong>子句与所有<code class="code">PossibleCellValue</code>工作存储器中的对象。第二行演示了<strong class="kw"><code>not</code></strong>关键词。只有在没有其他条件的情况下，此规则才会触发<code class="code">PossibleCellValue</code>对象在工作存储器中位于同一行和同一列，但具有不同的值。当规则触发时， <code class="code">PossibleCellValue</code>行和列中的行从工作存储器中收回，并被新的<code class="code">ResolvedCellValue</code>在相同的行和列中具有相同的值。</p><p>规则3删除<code class="code">PossibleCellValues</code>当它们具有与<code class="code">ResolvedCellValue</code> 。换句话说，当一个单元格充满解析值时，我们需要消除同一行上任何其他单元格都具有该值的可能性。when子句的第一行匹配所有<code class="code">ResolvedCellValue</code>工作存储器中的对象。第二行匹配<code class="code">PossibleCellValues</code>与它们具有相同的行和相同的值<code class="code">ResolvedCellValue</code>对象。如果找到任何规则，则会激活该规则，并在触发后撤回该规则<code class="code">PossibleCellValue</code>不再是该单元的解决方案。</p><p>规则＃4和＃5的行为与规则＃3相同，但要检查是否有多余<code class="code">PossibleCellValues</code>在网格的给定列和给定区域中<code class="code">ResolvedCellValue</code>分别。</p><p>规则6检查可能的单元格值在给定行中仅出现一次的情况。LHS的第一行与所有<code class="code">PossibleCellValue</code>工作记忆中的事实，将结果存储在多个局部变量中。第二行检查没有其他<code class="code">PossibleCellValue</code>具有相同值的对象存在于此行。第三到第五行检查是否没有<code class="code">ResolvedCellValue</code>在相同的区域，行或列中使用相同的值，这样该规则就不会过早触发。有趣的是，我们可以删除第3至5行，并给规则＃3，＃4和＃5更高的显着性，以确保它们始终在规则＃6，＃7和＃8之前触发。当规则触发时，我们知道<code class="code">$possible</code>必须代表该单元格的值；因此，按照规则2 <code class="code">$possible</code>并将其替换为等效的新<code class="code">ResolvedCellValue</code> 。</p><p>规则＃7和＃8的行为与规则＃2相同，但检查单个<code class="code">PossibleCellValues</code>分别在给定的列和网格的给定区域中。</p><p>规则＃9代表当前执行的最复杂的规则。该规则实现了以下逻辑：如果我们知道一对给定值只能出现在特定行的两个单元格中（例如，我们确定4和6的值只能出现在单元格的第一行[0 ，3]和[0,5]），并且这对单元格不能包含其他值，那么，尽管我们不知道该对单元格中的哪个包含四个，哪个包含六个，我们确实知道这两个值必须是在这两个单元格中，因此我们可以消除它们在同一行中其他任何地方发生的可能性。</p><p>规则＃10和＃11的行为与规则＃9相同，但是分别检查给定列和区域中是否只有两个可能的值。</p><p>为了解决更困难的网格，需要使用封装了更复杂推理的更复杂规则进一步扩展规则集。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9282"></a> 8.9.6。对未来发展的建议</h3></div></div></div><p>有许多方法可以开发此示例。鼓励读者将其视为练习。</p><div class="itemizedlist"><ul><li><p>议程组是分阶段执行的出色声明工具。在此示例中，很容易看出我们有两个阶段：“解决”和“验证”。现在，通过创建两个单独的规则库来执行它们，每个规则库都用于一个“作业”。可能最好为所有规则定义议程组，将它们分为“解析”规则和“验证”规则，所有这些规则组都加载在单个规则库中。引擎执行解析，然后立即执行验证。</p></li><li><p>自动聚焦是一种处理常规规则执行异常的好方法。在我们的情况下，如果我们在输入数据或解决规则中检测到不一致，那么如果它仍然无效，为什么还要花些时间继续执行呢？最好立即发现并立即报告不一致情况。为此，由于我们现在具有包含所有规则的单个规则库，因此我们只需要为所有验证拼图一致性的规则定义自动聚焦属性。</p></li><li><p>逻辑插入：仅当工作存储器中的数据错误时才存在不一致。因此，我们可以声明验证规则在逻辑上插入了不一致之处，并且一旦违规数据被撤回，不一致就不再存在。</p></li><li><p><code class="code">session.iterateObjects()</code> ：尽管一个有效的用例有一个全局列表来添加发现的问题，但我认为通过使用所需的问题列表来请求有状态会话会更有趣<code class="code">session.iterateObjects( new ClassObjectFilter( Inconsistency.class ) ).</code>拥有不一致类也可以使我们在GUI中用红色绘制有害单元。</p></li><li><p><code class="code">kcontext.getKnowledgeRuntime().halt()</code> ：甚至在发现错误后立即报告错误，我们还需要一种方法来告知引擎停止评估规则。我们可以创建一条规则，在存在不一致的情况下调用<code class="code">halt()</code>停止评估。</p></li><li><p>查询：看方法<code class="code">getPossibleCellValues(int row, int col)</code>在<code class="code">DroolsSudokuGridModel</code> ，我们看到遍历所有对象<code class="code">CellValue</code>对象，寻找它想要的几个。这是演示Drools查询的绝佳机会。我们只是定义一个查询以返回我们想要的对象，并干净利落地对其进行迭代。可以根据需要定义其他查询。</p></li><li><p>全球服务即服务：此更改的主要目标是参加下一个建议的更改，但它本身很不错。为了教您将全局变量用作服务，最好设置一个回调，以便每个找到<code class="code">ResolvedCellValue</code>对于给定的小区，可以调用，通知和更新GUI中的相应小区，从而为用户提供即时反馈。同样，最后找到的单元格可以用不同的颜色涂上其数字，以方便识别规则的结论。</p></li><li><p>逐步执行：现在，我们已经收到了用户的即时反馈，我们可以使用Drools中的受限运行功能，即，可以在GUI中添加一个按钮，该按钮在激活时将导致执行单个规则，方法是：呼唤<code class="code">fireAllRules( 1 )</code> 。这样，用户将逐步看到引擎在做什么。</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9337"></a> 8.10。猜数字</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Number Guess 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.NumberGuessExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> NumberGuess.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Rule Flow to organise Rules
</pre><p>“数字猜测”示例显示了规则流的使用，这是一种控制规则触发顺序的方法。它使用广泛理解的工作流图来定义规则组的执行顺序。</p><div class="example"><a id="d0e9358"></a><p class="title"><b>示例8.69创建数字猜测规则规则库：NumberGuessExample.main（）-第1部分</b></p><div class="example-contents"><pre class="programlisting">final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.drl",
                                                    ShoppingExample.class ),
              ResourceType.DRL );
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.rf",
                                                    ShoppingExample.class ),
              ResourceType.DRF );

final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );</pre></div></div><br class="example-break"><p>包的创建和规则的加载（使用<code class="code">add()</code>方法）与前面的示例相同。还有一行添加规则流（ <code class="filename">NumberGuess.rf</code> ），它提供了为同一知识库指定不同规则流的选项。否则，将以与以前相同的方式创建知识库。</p><div class="example"><a id="d0e9371"></a><p class="title"><b>示例8.70启动RuleFlow：NumberGuessExample.main（）-第2部分</b></p><div class="example-contents"><pre class="programlisting">final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "log/numberguess");

ksession.insert( new GameRules( 100, 5 ) );
ksession.insert( new RandomNumber() );
ksession.insert( new Game() );

ksession.startProcess( "Number Guess" );
ksession.fireAllRules();

logger.close();

ksession.dispose();</pre></div></div><br class="example-break"><p>一旦有了知识库，我们就可以使用它来获得有状态的会话。在我们的会话中，我们插入事实，即标准Java对象。（为简单起见，在此示例中，这些类都包含在我们的<code class="filename">NumberGuessExample.java</code>文件。类<code class="code">GameRules</code>提供最大范围和允许的猜测数量。类<code class="code">RandomNumber</code>通过插入，自动生成0到100之间的数字并将其提供给我们的规则<code class="code">getValue()</code>方法。类<code class="code">Game</code>跟踪我们之前所做的猜测及其数量。</p><p>请注意，在我们称为标准之前<code class="code">fireAllRules()</code>方法，我们还可以通过来启动之前加载的过程<code class="code">startProcess()</code>方法。当我们在下面讨论规则流文件和图形化的规则流编辑器时，我们将学习从何处获取传递的参数（“数字猜测”，即规则流的标识符）。</p><p>在结束对Java代码的讨论之前，我们注意到在某些实际应用程序中，我们将检查对象的最终状态。（在这里，我们可以检索猜测的数量，将其添加到高分表中。）对于此示例，我们很高兴通过调用以下命令来确保清除“工作内存”会话<code class="code">dispose()</code>方法。</p><div class="figure"><a id="d0e9406"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/NumberGuessExample/numberguess-ruleflow.png" width="100%" alt="NumberGuess示例的RuleFlow"></td></tr></tbody></table></div></div><p class="title"><b>图8.18。NumberGuess示例的RuleFlow</b></p></div><br class="figure-break"><p>如果您打开<code class="filename">NumberGuess.rf</code>在Drools IDE中提供文件（前提是您已在Eclipse中正确安装了JBoss Rules扩展），您应该看到上面的图表，类似于标准流程图。其图标与JBoss jBPM工作流产品中的图标相似（但不完全相同）。如果您希望编辑该图，则在IDE中该图的左侧应该有一个可用组件的菜单，称为<span class="emphasis"><em>调色板</em></span> 。此图使用XStream以（几乎）人类可读的格式保存为XML。</p><p>如果尚未打开，请确保“属性视图”在IDE中可见。可以通过单击“窗口”，然后单击“显示视图”和“其他”来打开它，您可以在其中选择“属性”视图。如果您<span class="emphasis"><em>在</em></span>选择规则流中的任何项目<span class="emphasis"><em>之前</em></span>执行此操作（或单击规则流中的空白），则应该看到以下属性集。</p><div class="figure"><a id="d0e9425"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/NumberGuessExample/numberguess-ruleflow-properties.png" width="100%" alt="数字猜测规则流的属性"></td></tr></tbody></table></div></div><p class="title"><b>图8.19。数字猜测规则流的属性</b></p></div><br class="figure-break"><p>在我们查看示例的规则流时，请密切注意“属性视图”，因为它会提供有价值的信息。在这种情况下，当我们调用时，它为我们提供了在先前代码段中使用的规则流过程的标识<code class="code">session.startProcess()</code> 。</p><p>在“数字猜测”规则流中，我们遇到几种节点类型，其中许多由图标标识。</p><p>
    </p><div class="itemizedlist"><ul><li><p>“开始”节点（绿色圆圈中的白色箭头）和“结束”节点（红色框）标记了规则流的开始和结束。</p></li><li><p>“规则流组”框（黄色，无图标）表示在我们的规则（DRL）文件中定义的“规则流组”，我们将在以后查看。例如，当流到达规则流组“太高”时，只有那些标记为属性的规则<strong class="kw"><code>ruleflow-group</code></strong> <code class="code">"Too High"</code>可能会开火。</p></li><li><p>动作节点（黄色，呈齿轮状的图标）执行标准的Java方法调用。在此示例调用中，大多数操作节点<code class="code">System.out.println()</code> ，向用户指示程序的进度。</p></li><li><p>拆分和合并节点（蓝色椭圆形，无图标），例如“猜对了吗？”和“更多猜测加入”标记位置，控制流可以根据各种条件进行拆分，然后分别重新加入</p></li><li><p>箭头指示各个节点之间的流。</p></li></ul></div><p>
  </p><p>各种节点与规则结合使Number Guess游戏发挥作用。例如，“猜测”规则流组仅允许触发“获取用户猜测”规则，因为只有该规则的匹配属性为<strong class="kw"><code>ruleflow-group</code></strong> <code class="code">"Guess"</code> 。</p><div class="example"><a id="d0e9474"></a><p class="title"><b>示例8.71仅在规则流中的特定点触发规则：NumberGuess.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Get user Guess"
    ruleflow-group "Guess"
    no-loop
    when
        $r : RandomNumber()
        rules : GameRules( allowed : allowedGuesses )
        game : Game( guessCount &lt; allowed )
        not ( Guess() )
    then
        System.out.println( "You have " + ( rules.allowedGuesses - game.guessCount )
                            + " out of " + rules.allowedGuesses
                            + " guesses left.\nPlease enter your guess from 0 to "
                            + rules.maxRange );
        br = new BufferedReader( new InputStreamReader( System.in ) );
        i = br.readLine();        
        modify ( game ) { guessCount = game.guessCount + 1 }
        insert( new Guess( i ) );
end</pre></div></div><br class="example-break"><p>该规则的其余部分相当标准。LHS部分（之后<strong class="kw"><code>when</code></strong> ）的规则指出，它将针对每个<code class="code">RandomNumber</code>对象插入工作存储器中的位置<code class="code">guessCount</code>小于<code class="code">allowedGuesses</code>来自<code class="code">GameRules</code>对象以及用户未猜到正确数字的位置。</p><p>RHS部分（或结果，之后<strong class="kw"><code>then</code></strong> ）向用户显示一条消息，然后等待用户输入<code class="code">System.in</code> 。获得此输入后（ <code class="code">readLine()</code>方法调用将阻塞，直到按下返回键为止），它会修改猜测计数并插入新的猜测，从而使两者都可用于工作内存。</p><p>规则文件的其余部分相当标准：该程序包将方言声明为MVEL，并导入了各种Java类。此文件中总共有五个规则：</p><div class="orderedlist"><ol type="1"><li><p>获取用户猜测，即我们上面检查过的规则。</p></li><li><p>记录最高猜测的规则。</p></li><li><p>记录最低猜测的规则。</p></li><li><p>用于检查猜测并从内存中撤回猜测的规则。</p></li><li><p>通知用户所有猜测已用尽的规则。</p></li></ol></div><p>标准规则和RuleFlow之间的集成点是通过<strong class="kw"><code>ruleflow-group</code></strong>属性，如上文所述。<span class="emphasis"><em>规则（.drl）文件和规则流.rf文件之间集成</em></span>的<span class="emphasis"><em>第二点</em></span>是，拆分节点（蓝色椭圆形）可以使用工作内存（由规则更新）中的值来决定采取哪种行动采取。要查看其工作原理，请单击“猜测正确的节点”。然后在“属性”视图中，通过单击“约束”属性行上出现的右侧按钮，打开约束编辑器。您应该看到类似于下图的内容。</p><div class="figure"><a id="d0e9533"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/NumberGuessExample/numberguess-editconstraints.png" alt="编辑约束" guess="" correc="=" =""></div></div><p class="title"><b>图8.20。编辑“猜测正确”节点的约束</b></p></div><br class="figure-break"><p>单击“到节点太高”旁边的“编辑”按钮，您将看到类似以下的对话框。“文本编辑器”窗口中的值遵循LHS的标准规则格式，并且可以引用工作存储器中的对象。结果（RHS）是：如果LHS表达式的计算结果为true，则控制流遵循此节点（即，“到节点太高”）。</p><div class="figure"><a id="d0e9541"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/NumberGuessExample/numberguess-constraint-toohigh.png" alt="约束编辑器" value="" guess="" correc="=" =""></div></div><p class="title"><b>图8.21。“猜测正确”节点的约束编辑器：值太高</b></p></div><br class="figure-break"><p>自文件<code class="filename">NumberGuess.java</code>包含一个<code class="code">main()</code>方法，它可以从命令行或通过IDE作为标准Java应用程序运行。一个典型的游戏可能会导致下面的互动。粗体数字由用户输入。</p><div class="example"><a id="d0e9555"></a><p class="title"><b>示例8.72在数字猜想示例击败人类的示例控制台输出中！</b></p><div class="example-contents"><pre class="programlisting">You have 5 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>50</strong></span>
Your guess was too high
You have 4 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>25</strong></span>
Your guess was too low
You have 3 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>37</strong></span>
Your guess was too low
You have 2 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>44</strong></span>
Your guess was too low
You have 1 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>47</strong></span>
Your guess was too low
You have no more guesses
The correct guess was 48 

</pre></div></div><br class="example-break"><p>此样本中发生的情况的摘要是：</p><div class="orderedlist"><ol type="1"><li><p>的<code class="code">main()</code>的方法<code class="filename">NumberGuessExample.java</code>加载规则库，创建有状态会话并插入<code class="code">Game</code> ， <code class="code">GameRules</code>和<code class="code">RandomNumber</code> （包含目标编号）对象。该方法还设置了我们将要使用的流程，并触发了所有规则。控制权传递给规则流。</p></li><li><p>文件<code class="filename">NumberGuess.rf</code> ，规则流，从“开始”节点开始。</p></li><li><p>控制（通过“更多猜测”连接节点）传递到Guess节点。</p></li><li><p>在Guess节点上，启用了适当的Rule Flow Group（“获取用户Guess”）。在这种情况下，“猜测”规则（在<code class="filename">NumberGuess.drl</code>文件）被触发。该规则向用户显示一条消息，获取响应，并将其放入“工作内存”中。流传递到下一个“规则流节点”。</p></li><li><p>在下一个节点“猜测正确”处，约束条件检查当前会话并决定采用哪个路径。</p><p>如果步骤4中的猜测过高或过低，流程将沿着一条路径前进，该路径具有一个动作节点，该动作节点具有打印适当消息的正常Java代码和一个规则流组，从而触发最高猜测或最低猜测规则。流程从这些节点转到步骤6。</p><p>如果第4步中的猜测是正确的，那么我们将沿着规则流的结尾继续前进。在到达那里之前，具有常规Java代码的操作节点将打印一条语句“您猜对了”。这里（在规则流结束之前）有一个连接节点，因此我们的猜测路径（步骤7）也可以终止规则流。</p></li><li><p>控制根据规则流通过连接节点，将不正确的猜测流组（触发规则以从工作内存中撤回猜测）传递到“更多猜测”决策节点上。</p></li><li><p>“更多猜测”决策节点（在规则流的右侧）使用约束，再次查看规则已放入工作内存中的值，以确定是否有更多猜测，如果有，则转到步骤3。如果不是，我们通过一个规则流组来触发规则流，该规则流组将触发一条规则，指出“您没有更多的猜测”。</p></li><li><p>继续执行第3步到第7步的循环，直到正确猜出该数字为止，否则我们用完所有的猜测。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9627"></a> 8.11。礼貌小姐和标杆管理</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Miss Manners
<span class="bold"><strong>Main class:</strong></span> org.drools.benchmark.manners.MannersBenchmark
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> manners.drl
<span class="bold"><strong>Objective:</strong></span> Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth.</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9646"></a> 8.11.1。介绍</h3></div></div></div><p>Manners小姐正在举办一个聚会，作为一个好主持人，她想安排好座位。她最初的设计使每个人都成对布置，但后来她担心人们有话要说。好的主人是做什么的？她决定记下每个客人的爱好，这样她不仅可以根据交替的性别安排他们的配对，而且可以确保一个客人至少在一侧有共同的爱好。</p><div class="figure"><a id="d0e9651"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-Examples/MannersExample/guests_at_table.png" align="middle" width="100%" alt="礼仪小姐的客人"></td></tr></tbody></table></div></div><p class="title"><b>图8.22。礼仪小姐的客人</b></p></div><br class="figure-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9657"></a> 8.11.1.1。基准测试</h4></div></div></div><p>1991年，David Brant，Timothy Grose，Bernie Lofaso和Daniel P. Miranker在论文“数据库大小对规则系统性能的影响：五个案例研究”中建立了五个基准：</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>礼节</strong></span>采用深度优先的搜索方法来确定男女交替的座位安排，并确保邻居的共同爱好。</p></li><li><p><span class="bold"><strong>Waltz</strong></span>通过约束传播的线标注来建立线图的三维解释。</p></li><li><p><span class="bold"><strong>WaltzDB</strong></span>是Waltz的更通用版本，支持多于三行的结点并使用数据库。</p></li><li><p><span class="bold"><strong>ARP</strong></span>是使用A *搜索算法来实现最低成本的机器人飞行器路线规划器。</p></li><li><p><span class="bold"><strong>Weaver</strong></span> VLSI路由器使用黑板技术，用于通道和盒。</p></li></ul></div><p>礼节已经成为事实上的规则引擎基准。但是，它的行为现已众所周知，许多引擎对此进行了优化，从而否定了它作为基准的有用性，这就是为什么Waltz变得越来越受欢迎的原因。这五个基准测试也已在德克萨斯大学（ <a class="ulink" href="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/）上发布</a> 。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9693"></a> 8.11.1.2。礼仪小姐执行流程</h4></div></div></div><p>在分配了第一个座位安排之后，将进行深度优先递归，该递归会重复分配正确的座位安排，直到分配了最后一个座位。礼节使用<code class="code">Context</code>实例来控制执行流程。活动图被分区以显示规则执行与当前关系<code class="code">Context</code>州。</p><div class="figure"><a id="d0e9704"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="images/Chapter-Examples/MannersExample/manners_activity_diagram.png" align="middle" width="100%" alt="礼节活动图"></td></tr></tbody></table></div></div><p class="title"><b>图8.23。礼节活动图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9710"></a> 8.11.1.3。数据与结果</h4></div></div></div><p>在深入研究规则之前，让我们首先看一下所断言的数据以及由此产生的座位安排。数据是一组简单的五位客人，应该安排这些客人，以便性别交替和邻居有共同的爱好。</p><p><span class="bold"><strong>数据</strong></span></p><p>数据以OPS5语法给出，并带有括号的每个属性的名称和值对列表。每个人只有一个爱好。</p><div class="literallayout"><p>（客人（名字n1）（性别m）（爱好h1））<br>（客人（名字n2）（性别f）（爱好h1））<br>（客人（名字n2）（性别f）（爱好h3））<br>（客人（名字n3）（性别m）（爱好h3））<br>（客人（名字n4）（性别m）（爱好h1））<br>（客人（名字n4）（性别f）（爱好h2））<br>（客人（名字n4）（性别f）（爱好h3））<br>（客人（名字n5）（性别f）（爱好h2））<br>（客人（名字n5）（性别f）（爱好h1））<br>（last_seat（seat 5））</p></div><p><span class="bold"><strong>结果</strong></span></p><p>结果列表的每一行都是按照“分配席位”规则执行的。他们要注意的关键一点是，每行的“ pid”值都比最后一行大一。（其重要性将在规则“分配座位”中进行解释。）“ ls”，“ rs”，“ ln”和“ rn”分别是指左右座位和邻居的名字。实际的实现使用更长的属性名称（例如， <code class="code">leftGuestName</code> ，但在这里我们将坚持原始实现的表示法。</p><div class="literallayout"><p>[就座id = 1，pid = 0，完成= true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4]<br>[座位ID = 3，pid = 2，完成= false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[座位ID = 4，pid = 3，完成=假，ls = 3，rn = n3，rs = 4，rn = n2]<br>[座位ID = 5，pid = 4，完成=假，ls = 4，ln = n2，rs = 5，rn = n1]</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9732"></a> 8.11.2。深入讨论</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9735"></a> 8.11.2.1。作弊</h4></div></div></div><p>礼节旨在进行跨产品联接和议程活动。许多人不了解此调整示例以获得更好的性能，使他们的方式礼貌基准毫无意义。礼貌小姐的作弊或移植错误是：</p><div class="itemizedlist"><ul><li><p>将数组用于来宾爱好，而不是将每个数组都声明为单个事实，从而大大减少了叉积。</p></li><li><p>更改数据顺序还可以减少匹配量，提高执行速度。</p></li><li><p>可以更改<strong class="kw"><code>not</code></strong>条件元素，以便测试算法仅使用“第一最佳匹配”，这基本上是将测试算法转换为反向链接。结果仅可与其他向后链接规则引擎或礼节港口相提并论。</p></li><li><p>删除上下文，以便规则引擎过早地匹配来宾和座位。正确的端口将防止使用上下文开头匹配事实。</p></li><li><p>有可能阻止规则引擎执行组合模式匹配。</p></li><li><p>如果在推理周期中没有撤回任何事实，则由于<strong class="kw"><code>not</code></strong> CE，端口错误。</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9765"></a> 8.11.2.2。解决冲突</h4></div></div></div><p>方式基准是针对OPS5编写的，该基准具有两种冲突解决策略，即LEX和MEA。 LEX是一系列策略的链，包括显着性，新近度和复杂性。策略的新近度部分驱动深度优先（LIFO）触发顺序。CLIPS手册记录了新近度策略，如下所示：</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>每个事实和实例在内部都标记有“时间标记”，以指示其相对于系统中其他每个事实和实例的相对新近度。与每个规则激活关联的模式实体按降序排序，以确定放置位置。具有较新模式实体的激活被置于具有较新模式实体的激活之前。要确定两个激活的放置顺序，请从最大的时间标记开始一一比较两个激活的排序时间标记。比较应继续进行，直到一个激活的时间标签大于另一个激活的相应时间标签为止。具有较大时间标签的激活被放在议程上的其他激活之前。如果一个激活比另一个激活具有更多的模式实体，并且比较的时间标签都相同，则将具有更多时间标签的激活放在议程上的另一个激活之前。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top"><span class="attribution">-CLIPS参考手册</span></td></tr></tbody></table></div><p>但是，Jess和CLIPS都使用深度策略，该策略更简单，更轻便，Drools也采用了这种策略。CLIPS手册将深度策略记录为：</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>新激活的规则置于具有相同显着性的所有规则之上。例如，假设事实a激活规则1和规则2，事实b激活规则3和规则4，则如果在事实b之前声明事实a，则规则3和规则4将成为事实。在议程上的规则1和规则2之上。但是，rule-1相对于rule-2的位置和rule-3相对于rule-4的位置将是任意的。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top"><span class="attribution">-CLIPS参考手册</span></td></tr></tbody></table></div><p>不使用“ make_path”规则的显着性，深度策略的初始Drools实现将不适用于礼节。CLIPS支持团队这样说：</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>CLIPS的默认冲突解决策略Depth与OPS5使用的默认冲突解决策略不同。因此，如果您将OPS5程序直接转换为CLIPS，但使用默认的深度冲突解决策略，则仅可能通过巧合获得正确的行为。CLIPS中提供了LEX和MEA冲突解决策略，使您可以在CLIPS中快速转换并正确运行OPS5程序。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">- <span class="attribution">剪辑支持论坛</span></td></tr></tbody></table></div><p>对CLIPS代码的调查表明，深度策略中有未记录的功能。此策略中使用了累积的时间标签；它不是像新近策略那样通过事实进行广泛的事实比较，它只是将每次激活的所有时间标签的总和相加并进行比较。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9791"></a> 8.11.2.3。规则“ assignFirstSeat”</h4></div></div></div><p>一旦上下文更改为<code class="code">START_UP</code> ，将为所有断言的来宾创建激活。由于所有激活都是通过单个“工作记忆”操作创建的，因此它们都具有相同的激活时间标签。最后断言<code class="code">Guest</code>对象将具有较高的事实时间标记，并且会激活它，因为它具有最高的累积事实时间标记。此规则中的执行顺序重要性不高，但对“分配席位”规则有很大影响。激活触发并断言第一个<code class="code">Seating</code>安排和<code class="code">Path</code> ，然后设置<code class="code">Context</code>属性<code class="code">state</code>创建规则激活<code class="code">findSeating</code> 。</p><pre class="programlisting">rule assignFirstSeat
    when
        context : Context( state == Context.START_UP )
        guest : Guest()
        count : Count()
    then
        String guestName = guest.getName();
        
        Seating seating =
          new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName);
        insert( seating );
        
        Path path = new Path( count.getValue(), 1, guestName );
        insert( path );
        
        modify( count ) { setValue ( count.getValue() + 1 )  }

    System.out.println( "assign first seat :  " + seating + " : " + path );

        modify( context ) {
            setState( Context.ASSIGN_SEATS )
        } 
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9819"></a> 8.11.2.4。规则“ findSeating”</h4></div></div></div><p>此规则确定每个<code class="code">Seating</code>安排。该规则为<span class="emphasis"><em>所有</em></span>断言创建跨产品解决方案<code class="code">Seating</code>针对<span class="emphasis"><em>所有</em></span>声称的客人的安排，除了针对自己或任何已分配的选定解决方案的客人。</p><pre class="programlisting">rule findSeating
   when 
       context : Context( state == Context.ASSIGN_SEATS )
       $s      : Seating( pathDone == true )
       $g1     : Guest( name == $s.rightGuestName )
       $g2     : Guest( sex != $g1.sex, hobby == $g1.hobby )

       count   : Count()

       not ( Path( id == $s.id, guestName == $g2.name) )
       not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) )
   then
       int rightSeat = $s.getRightSeat();
       int seatId = $s.getId();
       int countValue = count.getValue();
       
       Seating seating =
         new Seating( countValue, seatId, false, rightSeat,
                      $s.getRightGuestName(), rightSeat + 1, $g2.getName() );
       insert( seating );
                            
       Path path = new Path( countValue, rightSeat + 1, $g2.getName()  );
       insert( path );
       
       Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() );
       insert( chosen  );

       System.err.println( "find seating : " + seating + " : " + path +
                           " : " + chosen);

       modify( count ) {setValue(  countValue + 1 )}
       modify( context ) {setState( Context.MAKE_PATH )}
end</pre><p>但是，从前面显示的打印结果可以看出，只有<code class="code">Seating</code>最高的<code class="code">pid</code>选择交叉产品。如果我们几乎所有现有的标签都具有相同时间标签的激活，那怎么可能<code class="code">Seating</code>和<code class="code">Guest</code>对象？例如，在<code class="code">findDeating</code>产生的激活将如下所示。请记住，这是从很小的数据集中获得的，而对于更大的数据集，将会有更多的可能被激活<code class="code">Seating</code>解决方案，每个解决方案有多个<code class="code">pid</code> ：</p><div class="literallayout"><p>=> [ActivationCreated（35）：rule = findSeating<br>[fid：19：33]：[座位ID = 3，pid = 2，done = true，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3]<br>[fid：3：3]：[来宾姓名= n2，性别= f，兴趣爱好= h3]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]</p></div><p>所有这些冗余激活的创建似乎都是毫无意义的，但必须记住，礼节并不是关于良好的规则设计的；它是关于规则设计的。故意将其设计为不好的规则集，以对跨产品匹配过程和议程进行充分的压力测试，这显然是这样做的。请注意，每次激活都具有相同的时间标记35，因为它们都是通过更改<code class="code">Context</code>反对<code class="code">ASSIGN_SEATS</code> 。使用OPS5和LEX，可以使用<code class="code">Seating</code>最后声明。使用深度，累积的事实时间标签可确保使用最后声明的激活<code class="code">Seating</code>火灾。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9877"></a> 8.11.2.5。规则“ makePath”和“ pathDone”</h4></div></div></div><p>规则<code class="code">makePath</code>必须始终开火<code class="code">pathDone</code> 。一种<code class="code">Path</code>每个对象都被断言<code class="code">Seating</code>安排，直到最后声明<code class="code">Seating</code> 。请注意，条件在<code class="code">pathDone</code>是这些中的一部分<code class="code">makePath</code> -那么我们如何确保<code class="code">makePath</code>先开火？</p><pre class="programlisting">rule makePath
    when 
        Context( state == Context.MAKE_PATH )
        Seating( seatingId:id, seatingPid:pid, pathDone == false )
        Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat )
        not Path( id == seatingId, guestName == pathGuestName )
    then
        insert( new Path( seatingId, pathSeat, pathGuestName ) );
end</pre><pre class="programlisting">rule pathDone
    when
        context : Context( state == Context.MAKE_PATH ) 
        seating : Seating( pathDone == false ) 
    then
        modify( seating ) {setPathDone( true )} 
        
    modify( context ) {setState( Context.CHECK_DONE)}
end</pre><div class="figure"><a id="d0e9910"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Examples/MannersExample/make_path.png" align="middle" alt="网状图"></div></div><p class="title"><b>图8.24。网状图</b></p></div><br class="figure-break"><p>两条规则都在议程中冲突，并且具有相同的激活时间标签。但是，“ Make Path”的累积事实时间标签更大，因此它具有优先级。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9918"></a> 8.11.2.6。规则“继续”和“ areWeDone”</h4></div></div></div><p>规则<code class="code">areWeDone</code>仅在分配了最后一个席位时激活，这时将同时激活两个规则。出于同样的原因<code class="code">makePath</code>总是赢<code class="code">path Done</code> ， <code class="code">areWeDone</code>将优先于规则<code class="code">continue</code> 。</p><pre class="programlisting">rule areWeDone
    when
        context : Context( state == Context.CHECK_DONE ) 
        LastSeat( lastSeat: seat )
        Seating( rightSeat == lastSeat ) 
    then
        modify( context ) {setState(Context.PRINT_RESULTS )}
end
</pre><pre class="programlisting">rule continue
    when
        context : Context( state == Context.CHECK_DONE ) 
    then
        modify( context ) {setState( Context.ASSIGN_SEATS )}
end
</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9942"></a> 8.11.3。输出汇总</h3></div></div></div><div class="literallayout"><p><span class="bold"><strong>分配第一个席位</strong></span><br>=> [fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>=> [fid：14：14]：[路径ID = 1，座位= 1，访客= n5]<br>
<br>==> [ActivationCreated（16）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>==> [ActivationCreated（16）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1] *<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：15：17]：[座位ID = 2，pid = 1，完成=假，ls = 1，lg = n5，rs = 2，rn = n4]<br>=> [fid：16：18]：[路径ID = 2，座位= 2，访客= n4]<br>=> [fid：17：19]：[选择的ID = 1，名称= n4，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（21）：rule = makePath<br>[fid：15：17]：[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：14：14]：[路径ID = 1，座位= 1，访客= n5] *<br>
<br>==> [ActivationCreated（21）：rule = pathDone<br>[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：18：22：[路径ID = 2，座位= 1，访客= n5]]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续进行</strong></span><br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：7：7]：[来宾姓名= n4，性别= f，兴趣爱好= h3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3] *<br>
<br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]，[fid：12：20]：[计数值= 3]<br>
<br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：19：26]：[座位ID = 3，pid = 2，完成= false，ls = 2，lnn4，rs = 3，rn = n3]]<br>=> [fid：20：27]：[路径ID = 3，座位= 3，访客= n3]]<br>=> [fid：21：28]：[选择的ID = 2，名称= n3，兴趣爱好= h3}]<br>
<br>=> [ActivationCreated（30）：rule = makePath<br>[fid：19：26]：[座位ID = 3，pid = 2，done = false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：18：22]：[路径ID = 2，座位= 1，访客= n5] *<br>
<br>=> [ActivationCreated（30）：rule = makePath<br>[fid：19：26]：[座位ID = 3，pid = 2，done = false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：16：18]：[路径ID = 2，座位= 2，访客= n4] *<br>
<br>=> [ActivationCreated（30）：规则=完成<br>[fid：19：26]：[座位ID = 3，pid = 2，完成= false，ls = 2，ln = n4，rs = 3，rn = n3] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：22：31]：[路径ID = 3，座位= 1，访客= n5]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：23：32] [路径ID = 3，座位= 2，访客= n4]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续处理</strong></span><br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：19：33]：[座位ID = 3，pid = 2，done = true，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3]<br>[fid：3：3]：[来宾姓名= n2，性别= f，兴趣爱好= h3]，[fid：12：29] *<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，爱好= h1]，[fid：1：1]：[来宾姓名= n1，性别= m，爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：24：36]：[座位ID = 4，pid = 3，完成= false，ls = 3，ln = n3，rs = 4，rn = n2]]<br>=> [fid：25：37]：[路径ID = 4，座位= 4，访客= n2]]<br>=> [fid：26：38]：[选择的ID = 3，名称= n2，兴趣爱好= h3]<br>
<br>==> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：23：32]：[路径ID = 3，座位= 2，访客= n4] *<br>
<br>==> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：20：27]：[路径ID = 3，座位= 3，访客= n3] *<br>
<br>=> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：22：31]：[路径ID = 3，座位= 1，访客= n5] *<br>
<br>=> [ActivationCreated（40）：规则=完成<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：27：41：[路径ID = 4，座位= 2，访客= n4]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：28：42]：[路径ID = 4，座位= 1，访客= n5]]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：29：43]：[路径ID = 4，座位= 3，访客= n3]]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续处理</strong></span><br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]，[fid：2：2]<br>[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：24：44]：[座位ID = 4，pid = 3，done = true，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1] *<br>
<br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：30：47]：[座位ID = 5，pid = 4，完成=假，ls = 4，ln = n2，rs = 5，rn = n1]<br>=> [fid：31：48]：[路径ID = 5，座位= 5，访客= n1]<br>=> [fid：32：49]：[选择的ID = 4，名称= n1，兴趣爱好= h1]<br>
</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9997"></a> 8.12。康威的人生游戏</h2></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Conway's Game Of Life
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.conway.ConwayAgendaGroupRun
            org.drools.examples.conway.ConwayRuleFlowGroupRun
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> conway-ruleflow.drl conway-agendagroup.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates 'accumulate', 'collect' and 'from'</pre><p>在<a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a>和<a class="ulink" href="http://www.math.com/students/wonders/life/life.html">http://www.math.com/students/wonders/life/life.html中</a>描述的Conway的“生命游戏”是一种著名的蜂窝自动机。在1970年代初由数学家约翰·康威（John Conway）创作。虽然该系统被称为“ Conway的生活游戏”，但它实际上根本不是游戏。康威的系统更像是一种生活形式的模拟。不要被吓到该系统非常简单，而且非常有趣。数学和计算机科学专业的学生都对Conway的系统赞叹不已，已有30多年的历史了。这里介绍的应用程序是Conway的《生命游戏》的基于Swing的实现。使用Drools将管理系统的规则作为业务规则实施。本文档将解释驱动仿真的规则，并讨论实现的Drools部分。</p><p>我们将首先介绍为游戏的可视化设计的网格视图，如下所示，其中显示了模拟生活的“竞技场”。最初，网格是空的，这意味着系统中没有活动单元。每个细胞要么活着要么死了，活细胞显示一个绿色的球。可以从“模式”下拉列表中选择活细胞的预选模式。或者，可以双击单个单元格以在活动状态和死亡状态之间切换。重要的是要了解每个单元都与其相邻的单元相关，这对于游戏规则至关重要。邻居不仅包括左侧，右侧，顶部和底部的单元，还包括对角连接的单元，因此每个单元共有8个邻居。四个角单元只有三个邻居，并且沿四个边界的单元各有五个邻居，这是个例外。</p><div class="figure"><a id="d0e10026"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway1.png" width="100%" alt="康威的人生游戏：开始一个新游戏"></td></tr></tbody></table></div></div><p class="title"><b>图8.25。康威的人生游戏：开始一个新游戏</b></p></div><br class="figure-break"><p>那么，控制该游戏的基本规则是什么？它的目标是显示一代又一代人口的发展。基于对所有单元格的同时评估，每一代都是从前一个生成的。这是控制下一代外观的简单规则集：</p><div class="itemizedlist"><ul><li><p>如果一个活细胞的活邻居少于2个，它将死于寂寞。</p></li><li><p>如果一个活细胞有三个以上的活细胞，则死于拥挤。</p></li><li><p>如果一个死细胞正好有3个活着的邻居，那么它就可以复活。</p></li></ul></div><p>这就是全部。不满足任何这些条件的任何单元将保留给下一代。牢记这些简单的规则，然后回过头来玩一点系统，一次又一次地经历几代人，然后注意这些规则开始生效。</p><p>下面的屏幕快照显示了一个示例世代，其中包含许多活动单元格。不必担心匹配屏幕快照中显示的确切模式。只需将一些单元格组添加到网格即可。一旦在网格中有几组活动单元，或者选择了预先设计的模式，请单击“ Next Generation”按钮，然后注意会发生什么。一些活细胞被杀死（绿色球消失），一些死细胞复活（出现绿色球）。历经几代人，看看是否注意到任何模式。如果单击“开始”按钮，系统将自行发展，因此您无需反复单击“下一代”按钮。稍微玩一下系统，然后返回此处以获取有关应用程序工作方式的更多详细信息。</p><div class="figure"><a id="d0e10048"></a><div class="figure-contents"><div class="mediaobject"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway2.png" width="100%" alt="康威的人生游戏：跑步游戏"></td></tr></tbody></table></div></div><p class="title"><b>图8.26。康威的人生游戏：跑步游戏</b></p></div><br class="figure-break"><p>现在让我们深入研究代码。因为这是一个高级示例，所以我们假设到现在为止您已经了解了Drools框架，并且能够连接呈现的重点内容，因此我们将只专注于高层概述。该示例有两种执行方式，一种使用议程组来管理执行流，另一种使用规则流组来管理执行流。这两个版本在<code class="code">ConwayAgendaGroupRun</code>和<code class="code">ConwayRuleFlowGroupRun</code> ， 分别。在这里，我们将讨论Rule Flow版本，因为这是大多数人会使用的版本。</p><p>所有的<code class="code">Cell</code>对象被插入到Session中，并且规则<strong class="kw"><code>ruleflow-group</code></strong>规则流程允许“注册邻居”执行。这四个规则组创建<code class="code">Neighbor</code>某个单元与其东北，北部，西北和西部邻居之间的关系。这种关系是双向的，它负责其他四个方向。边界单元不需要任何特殊处理-它们根本不会与没有任何边界单元的相邻单元配对。到所有激活均已激活这些规则时，所有单元格都与其所有相邻单元格相关。</p><div class="example"><a id="d0e10073"></a><p class="title"><b>示例8.73康威的人生游戏：注册细胞邻居关系</b></p><div class="example-contents"><pre class="programlisting">rule "register north east"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )            
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )    
then                    
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );        
end

rule "register north"
    ruleflow-group "register neighbor"  
when
    $cell: Cell( $row : row, $col : col )   
    $north : Cell( row  == ($row - 1), col == $col )    
then        
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );        
end

rule "register north west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )           
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )                        
then        
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );        
end

rule "register west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )          
    $west : Cell( row  == $row, col == ( $col - 1 ) )                       
then        
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );         
end</pre></div></div><br class="example-break"><p>插入所有单元格后，一些Java代码将模式应用于网格，将某些单元格设置为Live。然后，当用户单击“开始”或“下一代”时，它将执行“生成”规则流。此规则流负责管理每个生成周期中单元的所有更改。</p><div class="figure"><a id="d0e10080"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Examples/ConwaysGameOfLifeExample/conway_ruleflow_generation.png" alt="康威的人生游戏：规则流程" generatio="" =""></div></div><p class="title"><b>图8.27。康威的人生游戏：规则流“生成”</b></p></div><br class="figure-break"><p>规则流过程首先进入“评估”组，这意味着该组中的任何活动规则都可以触发。该组中的规则应用示例开头讨论的生命游戏规则，确定要杀死的细胞和要赋予生命的细胞。我们使用“阶段”属性通过特定的规则组来驱动单元的推理；通常，该阶段与“规则流”流程定义中的“规则流组”相关。请注意，它实际上并没有改变任何状态<code class="code">Cell</code>在这一点上反对这是因为它依次评估网格，并且必须完成完整评估，直到可以应用这些更改。为此，它将单元格设置为“阶段”，即<code class="code">Phase.KILL</code>要么<code class="code">Phase.BIRTH</code> ，稍后用于控制应用于<code class="code">Cell</code>宾语。</p><div class="example"><a id="d0e10100"></a><p class="title"><b>示例8.74康威的人生游戏：通过状态变化评估细胞</b></p><div class="example-contents"><pre class="programlisting">rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has fewer than 2 live neighbors
    theCell: Cell( liveNeighbors &lt; 2, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has more than 3 live neighbors
    theCell: Cell( liveNeighbors &gt; 3, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
when
#   A dead cell has 3 live neighbors
    theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        theCell.setPhase( Phase.BIRTH );
    }
end
</pre></div></div><br class="example-break"><p>全部一次<code class="code">Cell</code>网格中的对象已经过评估，我们首先清除任何先前数据更改引起的任何计算激活。这是通过“重置计算”规则完成的，该规则清除了“计算”组中的所有激活。然后，我们在规则流中输入一个拆分，该拆分允许“ kill”和“ birth”组中的任何激活都被触发。这些规则负责应用状态更改。</p><div class="example"><a id="d0e10110"></a><p class="title"><b>示例8.75康威的人生游戏：应用状态更改</b></p><div class="example-contents"><pre class="programlisting">rule "reset calculate"
    ruleflow-group "reset calculate"
when
then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
when
    theCell: Cell( phase == Phase.KILL )
then
    modify( theCell ){
        setCellState( CellState.DEAD ),
        setPhase( Phase.DONE );   
    }
end 
 
rule "birth"
    ruleflow-group "birth"
    no-loop
when
    theCell: Cell( phase == Phase.BIRTH )
then
    modify( theCell ){
        setCellState( CellState.LIVE ),
        setPhase( Phase.DONE );
    }
end </pre></div></div><br class="example-break"><p>在这个阶段， <code class="code">Cell</code>对象已被修改，状态更改为<code class="code">LIVE</code>要么<code class="code">DEAD</code> 。现在我们来看看<code class="code">Neighbor</code>定义细胞关系的事实。当一个单元变成活的或死的时，我们使用<code class="code">Neighbor</code>遍历所有周围细胞的关系，增加或减少<code class="code">liveNeighbor</code>计数。任何其计数已更改的单元也将设置为<code class="code">EVALUATE</code>阶段，以确保在规则流过程的评估阶段将其包括在推理中。注意，我们不必自己进行任何迭代；只需通过在规则中应用关系，我们就可以使规则引擎用最少的代码为我们完成所有艰苦的工作。确定并设置所有单元的实时计数后，“规则流过程”就会结束。如果用户最初单击“开始”按钮，则引擎将重新启动规则流；否则，引擎将重新启动规则流。否则，用户可以请求另一代。</p><div class="example"><a id="d0e10138"></a><p class="title"><b>示例8.76康威的生命游戏：用状态变化评估细胞</b></p><div class="example-contents"><pre class="programlisting">rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.LIVE )
    Neighbor( cell == theCell, $neighbor : neighbor ) 
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ),
        setPhase( Phase.EVALUATE );   
    }
end 

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.DEAD )
    Neighbor( cell == theCell, $neighbor : neighbor )
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ),
        setPhase( Phase.EVALUATE );
    }
end </pre></div></div><br class="example-break"></div></div></div></body></html>