<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Hibernate搜索5.11.4。最终版：参考指南</title>
<link rel="stylesheet" href="asset?aid=0">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="css/font-awesome/css/font-awesome.min.css">
<!-- HibernateDoc.Meta -->
<meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation">
<meta name="keywords" content="hibernate, search, hibernate search, full text, lucene, elasticsearch">
<link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/">
<!-- /HibernateDoc.Meta -->

<link rel="stylesheet" href="css/hibernate.css" type="text/css">


<div id="header">
<h1>Hibernate搜索5.11.4。最终版：参考指南</h1>
<div class="details">
<span id="revdate">2019-11-21</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#preface">前言</a></li>
<li><a href="#getting-started">1。入门</a>
<ul class="sectlevel2">
<li><a href="#_system_requirements">1.1。系统要求</a></li>
<li><a href="#_migration_notes">1.2。迁移说明</a></li>
<li><a href="#_required_libraries">1.3。所需的库</a></li>
<li><a href="#_deploying_on_wildfly">1.4。在WildFly上部署</a></li>
<li><a href="#_configuration">1.5。组态</a></li>
<li><a href="#_indexing">1.6。索引编制</a></li>
<li><a href="#_searching">1.7。正在搜寻</a></li>
<li><a href="#_analyzer">1.8。分析仪</a></li>
<li><a href="#_what_s_next">1.9。下一步是什么</a></li>
</ul>
</li>
<li><a href="#search-architecture">2。建筑</a>
<ul class="sectlevel2">
<li><a href="#_overview">2.1。总览</a></li>
<li><a href="#_backend">2.2。后端</a></li>
<li><a href="#search-architecture-readerstrategy">2.3。读者策略</a></li>
</ul>
</li>
<li><a href="#search-configuration">3。组态</a>
<ul class="sectlevel2">
<li><a href="#search-configuration-event">3.1。启用Hibernate搜索和自动索引</a></li>
<li><a href="#configuration-indexmanager">3.2。配置IndexManager</a></li>
<li><a href="#search-configuration-directory">3.3。目录配置</a></li>
<li><a href="#configuration-worker">3.4。工作人员配置</a></li>
<li><a href="#configuration-reader-strategy">3.5。阅读器策略配置</a></li>
<li><a href="#_serialization">3.6。序列化</a></li>
<li><a href="#exception-handling">3.7。异常处理</a></li>
<li><a href="#_lucene_configuration">3.8。Lucene配置</a></li>
<li><a href="#_metadata_api">3.9。元数据API</a></li>
<li><a href="#search-configuration-deploy-on-wildfly">3.10。Hibernate Search作为WildFly模块</a></li>
</ul>
</li>
<li><a href="#search-mapping">4。将实体映射到索引结构</a>
<ul class="sectlevel2">
<li><a href="#search-mapping-entity">4.1。映射实体</a></li>
<li><a href="#section-boosting">4.2。助推</a></li>
<li><a href="#_analysis">4.3。分析</a></li>
<li><a href="#search-mapping-bridge">4.4。桥梁</a></li>
<li><a href="#search-mapping-indexinginterceptor">4.5。条件索引</a></li>
<li><a href="#provided-id">4.6。提供自己的身份证</a></li>
<li><a href="#hsearch-mapping-programmaticapi">4.7。程序化API</a></li>
</ul>
</li>
<li><a href="#search-query">5，查询方式</a>
<ul class="sectlevel2">
<li><a href="#section-building-lucene-queries">5.1。建立查询</a></li>
<li><a href="#_retrieving_the_results">5.2。检索结果</a></li>
<li><a href="#query-filter">5.3。筛选器</a></li>
<li><a href="#query-faceting">5.4。刻面</a></li>
<li><a href="#_optimizing_the_query_process">5.5。优化查询过程</a></li>
</ul>
</li>
<li><a href="#manual-index-changes">6。手动更改索引</a>
<ul class="sectlevel2">
<li><a href="#_adding_instances_to_the_index">6.1。将实例添加到索引</a></li>
<li><a href="#_deleting_instances_from_the_index">6.2。从索引中删除实例</a></li>
<li><a href="#search-batchindex">6.3。重建整个索引</a></li>
<li><a href="#jsr352-integration">6.4。与JSR-352集成</a></li>
</ul>
</li>
<li><a href="#search-optimize">7。指标优化</a>
<ul class="sectlevel2">
<li><a href="#_automatic_optimization">7.1。自动优化</a></li>
<li><a href="#_manual_optimization">7.2。手动优化</a></li>
<li><a href="#_adjusting_optimization">7.3。调整优化</a></li>
</ul>
</li>
<li><a href="#search-monitoring">8。监控方式</a>
<ul class="sectlevel2">
<li><a href="#_jmx">8.1。JMX</a></li>
</ul>
</li>
<li><a href="#spatial">9。空间空间</a>
<ul class="sectlevel2">
<li><a href="#spatial-indexing">9.1。启用空间坐标索引</a></li>
<li><a href="#spatial-queries">9.2。执行空间查询</a></li>
<li><a href="#spatial-multiplecoordinates">9.3。多个坐标对</a></li>
<li><a href="#spatial-behind-curtain">9.4。透视：空间哈希索引的实现细节</a></li>
</ul>
</li>
<li><a href="#search-lucene-native">10。高级功能</a>
<ul class="sectlevel2">
<li><a href="#AccessingSearchFactory">10.1。访问<code>SearchFactory</code></a></li>
<li><a href="#AccessingSearchIntegrator">10.2。访问<code>SearchIntegrator</code></a></li>
<li><a href="#IndexReaders">10.3。使用<code>IndexReader</code></a></li>
<li><a href="#_accessing_a_lucene_directory">10.4。访问Lucene目录</a></li>
<li><a href="#advanced-features-sharding">10.5。分片索引</a></li>
<li><a href="#section-sharing-indexes">10.6。共享索引</a></li>
<li><a href="#section-services">10.7。使用外部服务</a></li>
<li><a href="#section-custom-similarity">10.8。自定义Lucene的评分公式</a></li>
<li><a href="#section-multi-tenancy">10.9。多租户</a></li>
</ul>
</li>
<li><a href="#elasticsearch-integration">11。与Elasticsearch集成</a>
<ul class="sectlevel2">
<li><a href="#_status">11.1。状态</a></li>
<li><a href="#_goal_of_the_elasticsearch_integration">11.2。Elasticsearch集成的目标</a></li>
<li><a href="#_getting_started_and_configuration">11.3。入门和配置</a></li>
<li><a href="#_mapping_and_indexing">11.4。映射和索引</a></li>
<li><a href="#_queries">11.5。查询</a></li>
<li><a href="#_index_optimization">11.6。索引优化</a></li>
<li><a href="#elasticsearch-client-access">11.7。直接访问Elasticsearch客户端</a></li>
<li><a href="#elasticsearch-limitations">11.8。局限性</a></li>
<li><a href="#_specific_versions_of_elasticsearch_to_avoid">11.9。避免使用特定版本的Elasticsearch</a></li>
<li><a href="#_acknowledgment">11.10。致谢</a></li>
</ul>
</li>
<li><a href="#_further_reading">12进一步阅读</a></li>
<li><a href="#credits">13学分</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>诸如Apache Lucene之类的全文搜索引擎是非常强大的技术，可以为应用程序添加有效的免费文本搜索功能。但是，Lucene在处理对象域模型时会遇到一些不匹配的情况。除其他事项外，索引必须保持最新，并且索引结构和域模型之间的不匹配以及查询的不匹配必须避免。</p>
</div>
<div class="paragraph">
<p>Hibernate Search解决了这些缺点-它在一些注释的帮助下为您的域模型建立了索引，负责数据库/索引同步，并从自由文本查询中恢复了常规托管对象。为了实现这一目标，Hibernate Search结合了<a href="http://www.hibernate.org">Hibernate</a>和<a href="http://lucene.apache.org">Apache Lucene</a>的强大功能。</p>
</div>
<div class="paragraph">
<p>自版本<code>5.6</code> Hibernate Search与<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch进行</a>了实验性集成。Elasticsearch基于Apache Lucene构建，因此我们现在可以公开非常相似的功能，从而使大多数参考文档成为这两种方法的有效指南。有关特定于Elasticsearch的详细信息，请跳至<a href="#elasticsearch-integration">与Elasticsearch集成</a> 。本指南的其他部分将假定您使用的是不带Elasticsearch间接调用的Lucene。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a> 1。入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎使用Hibernate搜索。下一章将指导您完成将Hibernate Search集成到现有的启用Hibernate ORM的应用程序所需的初始步骤。如果您是Hibernate新计时器，我们建议您从<a href="http://hibernate.org/quick-start.html">此处</a>开始。</p>
</div>
<div class="sect2">
<h3 id="_system_requirements"><a class="anchor" href="#_system_requirements"></a> 1.1。系统要求</h3>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表格1。系统要求</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java运行时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要Java版本<em>8</em>或更高版本。您可以<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">在此处</a>下载适用于Windows / Linux / Solaris的Java运行时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate搜索</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate-search-5.11.4.Final.jar</code>以及所有运行时依赖项。您可以从<code>dist/lib</code> <a href="http://sourceforge.net/projects/hibernate/files/hibernate-search/">Hibernate Search发行版的</a>目录，也可以从Maven Central存储库下载它们。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HibernateORM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你会需要<code>hibernate-core-5.4.9.Final.jar</code>及其依赖项（来自<a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/">分发包</a>或Maven存储库）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JPA 2.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以在没有JPA的情况下使用Hibernate Search，但以下说明将使用JPA批注进行基本的实体配置（ <code>@Entity</code> ， <code>@Id</code> ， <code>@OneToMany</code> ，...）。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_migration_notes"><a class="anchor" href="#_migration_notes"></a> 1.2。迁移说明</h3>
<div class="paragraph">
<p>如果要将现有应用程序从早期版本的Hibernate Search升级到最新版本，请确保签出<a href="http://hibernate.org/search/documentation/migrate/">迁移指南</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_required_libraries"><a class="anchor" href="#_required_libraries"></a> 1.3。所需的库</h3>
<div class="paragraph">
<p>Hibernate Search库分为几个模块，以允许您选择所需的最少依赖项。它需要Apache Lucene，Hibernate ORM和一些标准API，例如Java Persistence API和Java Transactions API。其他依赖项是可选的，提供了更多的集成点。为了在类路径上获取正确的jar文件，我们强烈建议使用依赖管理器（例如<a href="http://maven.apache.org/">Maven</a> ）或类似的工具（例如<a href="http://www.gradle.org/">Gradle</a>或<a href="http://ant.apache.org/ivy/">Ivy）</a> 。这些替代方案也可以使用“ <a href="#search-download-via-maven">使用Maven”</a>部分中的工件。</p>
</div>
<div class="sect3">
<h4 id="search-download-via-maven"><a class="anchor" href="#search-download-via-maven"></a> 1.3.1。使用Maven</h4>
<div class="paragraph">
<p>Hibernate Search工件可以在Maven的<a href="http://central.sonatype.org/">中央存储库中</a>找到，但首先在<a href="http://repository.jboss.org/nexus/content/groups/public-jboss/">JBoss Maven存储库</a>中发布。另请参见<a href="https://community.jboss.org/wiki/MavenGettingStarted-Users">Maven入门Wiki页面</a>以使用JBoss存储库。</p>
</div>
<div class="paragraph">
<p>您需要添加到pom.xml中的所有内容是：</p>
</div>
<div class="exampleblock">
<div class="title">范例1。Hibernate Search的Maven工件标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.11.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例2Hibernate Search的可选Maven依赖项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;!-- Infinispan integration: --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;9.2.2.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只有<em>hibernate-search-orm</em>依赖性是强制性的。仅当您要使用Infinispan来存储Lucene索引时，才需要<em>infinispan-directory-provider</em> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_manual_library_management"><a class="anchor" href="#_manual_library_management"></a> 1.3.2。手动库管理</h4>
<div class="paragraph">
<p>您可以从Sourceforge下载包含所有必需的<a href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.11.4.Final/">Hibernate Search</a>依赖项的zip捆绑包。除其他外，这包括Hibernate ORM的最新兼容版本。但是，仅包括您需要开始进行实验的基本部分。您可能需要将其与其他项目的下载结合起来，例如<a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.4.9.Final/">Sourceforge上</a>的<a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.4.9.Final/">Hibernate ORM发行版</a>还提供了启用缓存或使用连接池的模块。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_on_wildfly"><a class="anchor" href="#_deploying_on_wildfly"></a> 1.4。在WildFly上部署</h3>
<div class="paragraph">
<p>如果您要创建要在WildFly上部署的应用程序，那么您会很幸运：Hibernate Search包含在应用程序服务器中。这意味着您不需要将其与应用程序打包在一起，除非您要使用与随附版本不同的版本。从WildFly版本10开始，当您的应用程序使用Hibernate Search的嵌入式版本时，它会自动激活。有关详细信息，请参见<a href="#search-configuration-deploy-on-wildfly">Hibernate Search作为WildFly模块</a> 。</p>
</div>
<div class="paragraph">
<p>如果您要使用WildFly中包含的版本以外的其他版本，请查看<a href="#search-configuration-deploy-on-wildfly">Hibernate Search作为WildFly模块</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuration"><a class="anchor" href="#_configuration"></a> 1.5。组态</h3>
<div class="paragraph">
<p>将所有必需的依赖项添加到应用程序后，您必须在Hibernate配置文件中添加几个属性。如果您直接使用Hibernate，则可以在<code>hibernate.properties</code>要么<code>hibernate.cfg.xml</code> 。如果您通过JPA使用Hibernate，则还可以将属性添加到<code>persistence.xml</code> 。好消息是，对于标准用途，大多数属性提供合理的默认值。一个例子<code>persistence.xml</code>配置看起来像这样：</p>
</div>
<div class="exampleblock">
<div class="title">范例3。基本配置选项要添加到<code>hibernate.properties</code> ， <code>hibernate.cfg.xml</code>要么<code>persistence.xml</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">...
&lt;property name="hibernate.search.default.directory_provider"
          value="filesystem"/&gt;

&lt;property name="hibernate.search.default.indexBase"
          value="/var/lucene/indexes"/&gt;
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>首先，您必须告诉Hibernate Search哪个<code>DirectoryProvider</code>使用。这可以通过设置<code>hibernate.search.default.directory_provider</code>属性。Apache Lucene的概念是<code>Directory</code>存储索引文件。Hibernate Search处理Lucene的初始化和配置<code>Directory</code>通过一个实例<code>DirectoryProvider</code> 。在本教程中，我们将使用目录提供程序将索引存储在文件系统上。这将使我们能够检查由Hibernate Search创建的Lucene索引（例如，通过<a href="https://github.com/DmitryKey/luke/">Luke</a> ）。一旦有了有效的配置，就可以开始尝试其他目录提供程序（请参阅<a href="#search-configuration-directory">目录配置</a> ）。您还必须通过以下命令为所有索引指定默认的基本目录<code>hibernate.search.default.indexBase</code> 。这定义了存储索引的路径。</p>
</div>
<div class="paragraph">
<p>假设您的应用程序包含Hibernate托管类<code>example.Book</code>和<code>example.Author</code>并且您想要向应用程序添加自由文本搜索功能，以搜索数据库中包含的书籍。</p>
</div>
<div class="exampleblock">
<div class="title">示例4在添加特定于Hibernate Search的注释之前，示例实体Book和Author</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;

  public Book() {}

  // standard getters/setters follow
  ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {}

  // standard getters/setters follow
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为此，您必须在其中添加一些注释<code>Book</code>和<code>Author</code>类。第一个注释<code>@Indexed</code>分数<code>Book</code>作为可索引的。通过设计，Hibernate Search需要在索引中存储一个未<em>令牌化的</em> ID，以确保给定实体的索引唯一性（现在不用担心，如果您不知道未<em>令牌化的</em>含义，很快就会清楚）。</p>
</div>
<div class="paragraph">
<p>接下来，您必须标记要搜索的字段。让我们开始<code>title</code>和<code>subtitle</code>并同时用<code>@Field</code> 。参数<code>index=Index.YES</code>将确保对文本进行索引，而<code>analyze=Analyze.YES</code>确保使用默认的Lucene分析器分析文本。通常，分析或标记化意味着将句子分块为单个单词，并可能排除常见单词（例如“ a”或“ the”）。稍后我们将详细讨论分析器。我们指定的第三个参数是<code>store=Store.NO</code> ，以确保实际数据不会存储在索引中。数据是否存储在索引中与搜索它的能力无关。不必在索引中存储字段以允许Lucene搜索它们：存储它们的好处是能够通过投影检索它们（请参阅<a href="#projections">Projection</a> ）。</p>
</div>
<div class="paragraph">
<p>如果没有投影，Hibernate Search将默认执行Lucene查询，以查找与查询条件匹配的实体的数据库标识符，并使用这些标识符从数据库中检索托管对象。是否支持投影的决定必须视具体情况而定。</p>
</div>
<div class="paragraph">
<p>注意<code>index=Index.YES</code> ， <code>analyze=Analyze.YES</code>和<code>store=Store.NO</code>是这些参数的默认值，可以省略。</p>
</div>
<div class="paragraph">
<p>在引擎盖下进行了短暂浏览之后，让我们回到注释<code>Book</code>类。我们尚未讨论的另一个注释是<code>@DateBridge</code> 。该注释是Hibernate Search中的内置字段桥之一。Lucene索引主要基于字符串，并特别支持编码数字。Hibernate Search必须将索引字段的数据类型转换为其各自的Lucene编码，反之亦然。为此，提供了一系列预定义的桥，包括<code>DateBridge</code>这将转换一个<code>java.util.Date</code>转换成数值（a <code>long</code> ），并具有指定的分辨率。有关更多详细信息，请参见<a href="#section-built-in-bridges">内置桥</a> 。</p>
</div>
<div class="paragraph">
<p>这给我们留下了<code>@IndexedEmbedded</code> 。此注释用于索引关联的实体（ <code>@ManyToMany</code> ， <code>@*ToOne</code> ， <code>@Embedded</code>和<code>@ElementCollection</code> ）作为拥有实体的一部分。这是必需的，因为Lucene索引文档是一个平面数据结构，对对象关系一无所知。为了确保作者姓名可搜索，您必须确保姓名被索引为本书本身的一部分。在之上<code>@IndexedEmbedded</code>您还必须用标记要包含在索引中的关联实体的字段<code>@Field</code> 。有关更多详细信息，请参见<a href="#search-mapping-associated">嵌入式和关联的对象</a> 。</p>
</div>
<div class="paragraph">
<p>这些设置现在应该足够了。有关实体映射的更多详细信息，请参阅<a href="#search-mapping-entity">映射实体</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例5添加Hibernate Search注释后的示例实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
@Indexed
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String title;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String subtitle;

  @Field(index = Index.YES, analyze=Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();
  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  @Field
  private String name;

  public Author() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indexing"><a class="anchor" href="#_indexing"></a> 1.6。索引编制</h3>
<div class="paragraph">
<p>Hibernate Search将透明地索引通过Hibernate ORM持久，更新或删除的每个实体。但是，您必须为数据库中已经存在的数据创建初始Lucene索引。添加了以上属性和注释后，就该触发书籍的初始批次索引了。您可以使用以下代码片段之一来实现此目的（另请参见<a href="#search-batchindex">重建整个索引</a> ）：</p>
</div>
<div class="exampleblock">
<div class="title">范例6。使用Hibernate Session索引数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = org.hibernate.search.Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">范例7。使用JPA索引数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行完上面的代码后，您应该可以在下面看到一个Lucene索引<code>/var/lucene/indexes/example.Book</code> （或基于不同的路径，具体取决于您配置属性的方式<code>hibernate.search.default.directory_provider</code> ）。</p>
</div>
<div class="paragraph">
<p>继续使用<a href="https://github.com/DmitryKey/luke/">Luke</a>检查该索引：它将帮助您了解Hibernate Search的工作方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_searching"><a class="anchor" href="#_searching"></a> 1.7。正在搜寻</h3>
<div class="paragraph">
<p>现在该执行第一次搜索了。通用方法是通过Lucene API（ <a href="#search-query-lucene-api">使用</a> Lucene API <a href="#search-query-lucene-api">构建Lucene查询</a> ）或Hibernate Search查询DSL（使用Hibernate Search查询DSL <a href="#search-query-querydsl">构建Lucene查询）创建Lucene查询</a> ，然后包装该查询变成一个<code>org.hibernate.Query</code>为了从Hibernate API获得习惯的所有功能。以下代码将针对索引字段准备查询，执行该查询并返回以下内容的列表<code>Book</code>实例。</p>
</div>
<div class="exampleblock">
<div class="title">范例8。使用Hibernate Session创建和执行搜索</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery =
    fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();

tx.commit();
session.close();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">范例9。使用JPA创建和执行搜索</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery =
    fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_analyzer"><a class="anchor" href="#_analyzer"></a> 1.8。分析仪</h3>
<div class="paragraph">
<p>现在让我们变得更加有趣。假设您已索引的书中的一个实体的标题为“重构：改进现有代码的设计”，并且您希望获得以下所有查询的匹配项：“重构”，“重构”，“重构”和“重构”。在Lucene中，这可以通过选择一个分析器类来实现，该类在索引<strong>以及</strong>搜索过程中应用词干。Hibernate Search提供了几种方法来配置要使用的分析器（请参阅<a href="#analyzer">默认分析器和按类分析器</a> ）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>设置<code>hibernate.search.analyzer</code>配置文件中的属性。然后，指定的类将成为默认分析器。</p>
</li>
<li>
<p>设置<code>@Analyzer</code>实体级别的注释。</p>
</li>
<li>
<p>设置<code>@Analyzer</code>字段级别的注释。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用时<code>@Analyzer</code>注解可以指定要使用的分析仪的完全合格的类名，也可以引用由分析仪定义的分析仪定义。 <code>@AnalyzerDef</code>注解。在后一种情况下，将使用带有工厂方法的分析器框架。</p>
</div>
<div class="paragraph">
<p>要查找有关可用的工厂类的更多信息，可以浏览Lucene JavaDoc或阅读<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr Wiki</a>上的相应部分。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@AnalyzerDef</code>任何：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Indexed</code>实体，无论将分析器应用于何处；</p>
</li>
<li>
<p>的父类<code>@Indexed</code>实体;</p>
</li>
<li>
<p>包含以下内容的软件包的package-info.java <code>@Indexed</code>实体。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着分析器定义是全局的，并且它们的名称必须唯一。的<code>@AnalyzerDef</code>是可重复的注释，因此您可以在这些类型的每一个上声明多个分析器定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为什么要引用Apache Solr Wiki？</p>
</div>
<div class="paragraph">
<p>分析器工厂框架最初是在Apache Solr项目中创建的。这些实现中的大多数已移至Apache Lucene，但仍可以在Solr Wiki中找到这些其他分析器的文档。您可能会发现其他文档，它们引用了“ Solr Analyzer框架”。请记住，您不再需要依赖Apache Solr：所需的类是核心Lucene发行版的一部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在下面的示例中<code>StandardTokenizerFactory</code>被两个过滤器工厂使用， <code>LowerCaseFilterFactory</code>和<code>SnowballPorterFilterFactory</code> 。标准标记器将单词按标点符号和连字符分隔。这是一个很好的通用令牌生成器。对于索引电子邮件地址或互联网主机名，它不是最合适的选择，因为它将它们分开。您可以使用Lucene的<code>ClassicTokenizerFactory</code>在这种情况下，或实施自定义令牌生成器和工厂。小写过滤器将每个标记中的字母转换为小写，而雪球过滤器最终应用了特定于语言的词干。</p>
</div>
<div class="paragraph">
<p>通常，在使用分析器框架时，您必须从标记器开始，后跟任意数量的过滤器。</p>
</div>
<div class="exampleblock">
<div class="title">示例10使用<code>@AnalyzerDef</code>和分析器框架来定义和使用分析器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "customanalyzer",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
      @Parameter(name = "language", value = "English")
    })
  })
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String title;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String subtitle;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  @Field(index = Index.YES, analyze = Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用<code>@AnalyzerDef</code>仅定义分析器，您仍然必须使用以下命令将其应用于实体和/或属性<code>@Analyzer</code> 。像上面的例子一样<code>customanalyzer</code>已定义但未应用于实体：已应用于<code>title</code>和<code>subtitle</code>仅属性。分析器定义是全局的，因此您可以在任何实体上定义它，并在其他实体上重用该定义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_s_next"><a class="anchor" href="#_what_s_next"></a> 1.9。下一步是什么</h3>
<div class="paragraph">
<p>上面的段落帮助您大致了解了Hibernate Search。本教程之后的下一步是更熟悉Hibernate Search的整体体系结构（ <a href="#search-architecture">体系结构</a> ）并更详细地探索基本功能。在本教程中仅简要涉及的两个主题是分析器配置（ <a href="#analyzer">默认分析器和按类划分的分析器</a> ）和现场桥接器（ <a href="#search-mapping-bridge">Bridges</a> ）。两者都是更细粒度索引所需的重要功能。更高级的主题包括集群（ <a href="#jms-backend">JMS主/从后端</a> ， <a href="#infinispan-directories">Infinispan目录配置</a> ）和大型索引处理（分片<a href="#advanced-features-sharding">索引</a> ）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-architecture"><a class="anchor" href="#search-architecture"></a> 2。建筑</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a> 2.1。总览</h3>
<div class="paragraph">
<p>Hibernate Search由索引组件和索引搜索组件组成。两者默认都由Apache Lucene支持，或者可以使用Elasticsearch。</p>
</div>
<div class="paragraph">
<p>每次在数据库中插入，更新实体或从数据库中删除实体时，Hibernate Search都会跟踪该事件（通过Hibernate事件系统）并安排索引更新。无需直接与Apache Lucene API进行交互即可处理所有这些更新（请参阅“ <a href="#search-configuration-event">启用Hibernate搜索和自动索引”</a> ）。相反，与基础Lucene索引的交互是通过所谓的IndexManagers处理的。</p>
</div>
<div class="paragraph">
<p>每个Lucene索引由一个由名称唯一标识的索引管理器管理。在大多数情况下，索引实体和单个IndexManager之间也存在一对一的关系。索引分片和索引共享的用例除外。当单个实体的索引太大而索引操作使应用程序变慢时，可以应用前者。在这种情况下，单个实体被索引为多个索引，每个索引都有其自己的索引管理器（请参阅分片<a href="#advanced-features-sharding">索引</a> ）。后者是索引共享，是将多个实体索引到同一个Lucene索引中的能力（请参阅<a href="#section-sharing-indexes">共享索引</a> ）。</p>
</div>
<div class="paragraph">
<p>索引管理器从特定的索引配置中抽象出来。对于默认的索引管理器，这包括有关所选后端，配置的读取器策略和所选DirectoryProvider的详细信息。这些组件将在后面详细讨论。建议您从默认的索引管理器开始，该管理器使用不同的Lucene目录类型来管理索引（请参阅<a href="#search-configuration-directory">目录配置</a> ）。但是，您也可以提供自己的IndexManager实现（请参阅<a href="#configuration-indexmanager">配置IndexManager</a> ）。</p>
</div>
<div class="paragraph">
<p>创建索引后，您可以搜索实体并返回托管实体的列表，从而将繁琐的对象保存到Lucene Document映射中。Hibernate和Hibernate Search之间共享相同的持久性上下文。事实上， <code>FullTextSession</code>在Hibernate会话之上构建，因此应用程序代码可以使用统一的org.hibernate。查询或javax.persistence。查询API与HQL，JPA-QL或本机查询完全相同。</p>
</div>
<div class="paragraph">
<p>为了提高效率，Hibernate Search使用Lucene索引对写入交互进行批处理。当前有两种类型的批处理。</p>
</div>
<div class="paragraph">
<p>在事务之外，在实际数据库操作之后立即执行索引更新操作。这实际上是一个没有批处理的设置。</p>
</div>
<div class="paragraph">
<p>在正在进行的事务中，索引更新操作被安排在事务提交阶段，在事务回滚的情况下被丢弃。批处理范围是事务。有两个直接好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>性能：批量执行操作时，Lucene索引可以更好地工作。</p>
</li>
<li>
<p>ACIDity：执行的工作与数据库事务执行的工作具有相同的作用域，并且仅在提交事务后才执行。从严格意义上讲，这不是ACID，但是ACID行为对于全文搜索索引很少有用，因为它们可以随时从源中重建。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以将这两种批处理模式（无作用域与事务处理）视为（臭名昭著的）自动提交与事务处理行为的等效方式。从性能角度来看，建议使用<em>事务处理</em>模式。范围选择是透明进行的。Hibernate Search检测到事务的存在并调整作用域（请参阅<a href="#configuration-worker">Worker配置</a> ）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于数据库和Hibernate Search，建议在JDBC或JTA事务中执行事务。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search在Hibernate / EntityManager长对话模式（又名）中工作得很好。原子对话。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_backend"><a class="anchor" href="#_backend"></a> 2.2。后端</h3>
<div class="paragraph">
<p>Hibernate Search提供了使批处理的工作由不同的后端处理的功能。开箱即用提供了多个后端，您可以选择插入自己的后端。重要的是要了解，在这种情况下，后端不仅仅包含配置选项<code>hibernate.search.default.worker.backend</code> 。此属性仅指定<code>BackendQueueProcessor</code>接口（或<code>Backend</code>界面，请参阅<a href="#table-backend-configuration">配置选项</a> ），它是后端配置的一部分。但是，在大多数情况下，需要其他配置设置才能成功配置特定的后端设置，例如JMS后端。</p>
</div>
<div class="sect3">
<h4 id="_lucene"><a class="anchor" href="#_lucene"></a> 2.2.1。Lucene</h4>
<div class="paragraph">
<p>在这种模式下，应用于给定节点（JVM）的所有索引更新操作将由同一节点（通过目录提供程序）执行到Lucene目录。此模式通常用于非群集环境或共享目录存储的群集环境中。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/lucene-backend.png" alt="Lucene后端配置">
</div>
</div>
<div class="paragraph">
<p>此模式针对非群集应用程序，或目录正在使用锁定策略的群集应用程序。</p>
</div>
<div class="paragraph">
<p>主要优点是Lucene查询中更改的简单性和即时可见性（某些应用程序中的要求）。</p>
</div>
<div class="paragraph">
<p>适用于非群集和非共享索引配置的备用后端是近实时后端。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-architecture-jms"><a class="anchor" href="#search-architecture-jms"></a> 2.2.2。JMS</h4>
<div class="paragraph">
<p>应用于给定节点的所有索引更新操作都将发送到JMS队列。然后，唯一的读取器将处理队列并更新主索引。然后，将主索引定期复制到从属副本。这称为主/从模式。主人是唯一负责更新Lucene索引的人。从机可以接受读和写操作。但是，当他们在其本地索引副本上处理读取操作时，会将更新操作委派给主服务器。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jms-backend.png" alt="JMS后端配置">
</div>
</div>
<div class="paragraph">
<p>此模式针对吞吐量至关重要且索引更新延迟可承受的群集环境。JMS提供程序和从属服务器在索引的本地副本上工作可确保可靠性。</p>
</div>
<div class="paragraph">
<p>JMS集成可以是事务性的。有了这个后端（目前只有这个后端），您可以让Hibernate Search将索引工作发送到同一事务中的队列中，并将更改应用于关系数据库。此选项要求您使用XA事务。</p>
</div>
<div class="paragraph">
<p>默认情况下，此后端的事务处理功能是禁用的：与其他后端一致，邮件将作为事务后事件入队。要更改此配置，另请参阅<a href="#configuration-worker">工作程序配置</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-architecture-jgroups"><a class="anchor" href="#search-architecture-jgroups"></a> 2.2.3。JGroups</h4>
<div class="paragraph">
<p>基于JGroups的后端的工作方式与JMS类似，并且是按照相同的主/从模式设计的。但是，代替了JMS，JGroups工具包被用作复制机制。当响应时间很关键，但是JNDI服务不可用时，该后端可以用作JMS的替代方法。</p>
</div>
<div class="paragraph">
<p>请注意，尽管通常可以将JMS配置为使用持久性队列，但JGroups可以直接与网络上的其他节点对话。协议保证将消息传递到其他可到达的节点，但是如果没有主节点可用，则索引操作将被静默丢弃。同样，如果发送节点在执行传递之前崩溃，则事件可能会丢失。可以将此后端配置为使用异步消息，或者等待返回之前在远程节点上完成每个索引操作。</p>
</div>
<div class="paragraph">
<p>JGroups后端可以配置有静态的主角色或从角色，或者可以设置为执行自动选择主角色。此模式对于使系统在出现故障的情况下自动选择新的主服务器特别有用，但是在重新选择过程中，可能会丢失一些索引操作。因此，此模式不适用于需要强一致性保证的用例。当配置为执行自动选举时，主节点被定义为索引名称上的哈希：因此，每个索引或分片的角色可能不同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_elasticsearch"><a class="anchor" href="#_elasticsearch"></a> 2.2.4。弹性搜索</h4>
<div class="paragraph">
<p>在这种模式下，索引不在应用程序服务器上，而是在Elasticsearch集群中。更新操作将发送到集群并在远程执行，搜索查询也是如此。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elasticsearch-backend.png" alt="Elasticsearch后端配置">
</div>
</div>
<div class="paragraph">
<p>此模式允许轻松设置集群应用程序，而无需JMS和JGroups模式所需的高级配置。</p>
</div>
<div class="paragraph">
<p>可以在<a href="#elasticsearch-integration">Elasticsearch集成部分中</a>找到更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-architecture-readerstrategy"><a class="anchor" href="#search-architecture-readerstrategy"></a> 2.3。读者策略</h3>
<div class="paragraph">
<p>执行查询时，Hibernate Search通过阅读器策略与Apache Lucene索引进行交互。选择阅读器策略将取决于应用程序的配置文件（频繁更新，大部分读取，异步索引更新等）。另请参阅<a href="#configuration-reader-strategy">阅读器策略配置</a></p>
</div>
<div class="sect3">
<h4 id="_shared"><a class="anchor" href="#_shared"></a> 2.3.1。共享</h4>
<div class="paragraph">
<p>通过这种策略，只要IndexReader仍是最新的，Hibernate Search将在多个查询和线程之间为给定的Lucene索引共享相同的IndexReader。如果IndexReader不是最新的，则打开并提供一个新的。每个IndexReader由几个SegmentReader组成。此策略仅重新打开上次打开后已修改或创建的段，并共享前一个实例中已加载的段。这种方法非常有效，并且可以确保每个查询都在最新的索引快照上运行；缺点是，对于每个查询，该策略都必须验证IndexReader是否仍然新鲜，如果不执行刷新，则必须这样做；这样的刷新通常是一种廉价的操作，但是如果同时发生大量写入和查询，则可能会首选其他策略。此策略是默认策略。</p>
</div>
<div class="paragraph">
<p>该策略的名称是<code>shared</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_not_shared"><a class="anchor" href="#_not_shared"></a> 2.3.2。不共享</h4>
<div class="paragraph">
<p>每次执行查询时，都会打开Lucene IndexReader。该策略效率不高，因为打开和预热IndexReader可能是一个相对昂贵的操作，但是它是非常简单的代码。如果您想了解Hibernate Search内部或想要扩展它，可以将其用作示例实现。</p>
</div>
<div class="paragraph">
<p>该策略的名称是<code>not-shared</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_async"><a class="anchor" href="#_async"></a> 2.3.3。异步的</h4>
<div class="paragraph">
<p>此实现使IndexReader保持打开状态，并准备好供所有查询使用，而后台线程则定期验证是否需要打开一个新的索引，替换活动的索引并处置过期的索引。此后台线程的检查和刷新频率是可配置的，但默认为5000毫秒。这种设计的缺点是查询是在索引快照上有效地运行的，该快照可能已过时约5秒（假定未重新配置刷新时间）。好处是，如果您的应用程序频繁地向索引写入，则查询性能将更加一致。</p>
</div>
<div class="paragraph">
<p>该策略的名称是<code>async</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom"><a class="anchor" href="#_custom"></a> 2.3.4。自订</h4>
<div class="paragraph">
<p>您可以通过实现org.hibernate.search.reader来编写适合您的应用程序的阅读器策略。ReaderProvider。该实现必须是线程安全的。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-configuration"><a class="anchor" href="#search-configuration"></a> 3。组态</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="search-configuration-event"><a class="anchor" href="#search-configuration-event"></a> 3.1。启用Hibernate搜索和自动索引</h3>
<div class="paragraph">
<p>让我们从最基本的配置问题开始-如何启用Hibernate Search？</p>
</div>
<div class="sect3">
<h4 id="_enabling_hibernate_search"><a class="anchor" href="#_enabling_hibernate_search"></a> 3.1.1。启用Hibernate搜索</h4>
<div class="paragraph">
<p>好消息是，当Hibernate ORM在类路径上检测到Hibernate Search时，即开即用。如果由于某种原因需要禁用它<code>hibernate.search.autoregister_listeners</code>虚假。请注意，启用侦听器但没有将任何实体注释为索引时，不会降低性能。</p>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_indexing"><a class="anchor" href="#_automatic_indexing"></a> 3.1.2。自动索引</h4>
<div class="paragraph">
<p>默认情况下，每次通过Hibernate插入，更新或删除对象时，Hibernate Search都会更新相应的Lucene索引。如果您的索引是只读的或以批处理方式完成索引更新，则有时最好禁用这些功能（请参阅<a href="#search-batchindex">重建整个索引</a> ）。</p>
</div>
<div class="paragraph">
<p>要禁用基于事件的索引，请设置</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.indexing_strategy = manual</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在大多数情况下，JMS后端提供了两全其美的优势，基于轻量级事件的系统可以跟踪系统中的所有更改，而重量级索引过程则由单独的过程或机器完成。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-indexmanager"><a class="anchor" href="#configuration-indexmanager"></a> 3.2。配置IndexManager</h3>
<div class="paragraph">
<p><a href="#search-architecture">架构中</a>描述了索引管理器组件的作用。Hibernate Search为该接口提供了两种可能的实现方式供您选择。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>directory-based</code> ：使用Lucene Directory抽象管理索引文件的默认实现。</p>
</li>
<li>
<p><code>near-real-time</code> ：避免在每次提交时刷新写入磁盘。该索引管理器也是基于目录的，但也利用了Lucene的NRT功能。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要选择替代项，请指定属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directory_based"><a class="anchor" href="#_directory_based"></a> 3.2.1。基于目录</h4>
<div class="paragraph">
<p>默认的IndexManager实现。这是本文档中最常提及的一种。它是高度可配置的，允许您为读取器策略，后端和目录提供程序选择不同的设置。有关更多详细信息，请参阅<a href="#search-configuration-directory">目录配置</a> ， <a href="#configuration-worker">工作程序配置</a>和<a href="#configuration-reader-strategy">读取器策略配置</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_near_real_time"><a class="anchor" href="#_near_real_time"></a> 3.2.2。近实时</h4>
<div class="paragraph">
<p>NRTIndexManager是默认IndexManager的扩展，利用Lucene NRT（近实时）功能实现极低延迟的索引写入。作为权衡，它需要非聚集且非共享的索引。换句话说，它将忽略其他后端的配置设置<code>lucene</code>并将在目录上获得排他写锁定。</p>
</div>
<div class="paragraph">
<p>为了实现这些低延迟写入，IndexWriter不会刷新磁盘的所有更改。查询将被允许从未刷新的索引写入器缓冲区中读取更新的状态；该策略的缺点是，如果应用程序崩溃或以其他方式杀死IndexWriter，则由于某些更新可能会丢失，因此您必须重建索引。</p>
</div>
<div class="paragraph">
<p>由于存在这些缺点，并且由于群集中的主节点也可以配置为具有良好的性能，因此仅建议将NRT配置用于数据量有限的非群集网站。</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_2"><a class="anchor" href="#_custom_2"></a> 3.2.3。自订</h4>
<div class="paragraph">
<p>也可以通过指定自定义实现的完全限定的类名来配置自定义IndexManager实现。此实现必须具有无参数的构造函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您的自定义索引管理器实现不需要使用与默认实现相同的组件。例如，您可以委派给不公开目录接口的远程索引服务。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-configuration-directory"><a class="anchor" href="#search-configuration-directory"></a> 3.3。目录配置</h3>
<div class="paragraph">
<p>正如我们在<a href="#configuration-indexmanager">配置IndexManager中</a>所看到<a href="#configuration-indexmanager">的那样</a> ，默认索引管理器使用Lucene的目录概念来存储索引文件。可以自定义Directory的实现，Lucene与文件系统和内存实现捆绑在一起。DirectoryProvider是围绕Lucene目录的Hibernate Search抽象，并处理基础Lucene资源的配置和初始化。<a href="#directory-provider-table">内置的DirectoryProvider</a>列表显示了Hibernate Search中可用的目录提供程序的列表及其相应的选项。</p>
</div>
<div class="paragraph">
<p>要配置DirectoryProvider，您必须了解每个索引实体都与Lucene索引相关联（多个实体共享相同索引的情况除外- <a href="#section-sharing-indexes">共享索引</a> ）。索引的名称由@Indexed批注的index属性给出。如果未指定index属性，则将使用索引类的全限定名作为名称（推荐）。</p>
</div>
<div class="paragraph">
<p>知道索引名称后，您可以使用前缀配置目录提供程序和任何其他选项<code>hibernate.search.<indexname></code> 。名称默认（ <code>hibernate.search.default</code> ）保留，可用于定义适用于所有索引的属性。
<a href="#example-configuring-directory-providers">配置目录提供程序</a>显示了如何<code>hibernate.search.default.directory_provider</code>用于将默认目录提供程序设置为文件系统之一。<code>hibernate.search.default.indexBase</code>然后设置索引的默认基本目录。结果，在以下位置创建了实体状态的索引<code>/usr/lucene/indexes/org.hibernate.example.Status</code> 。</p>
</div>
<div class="paragraph">
<p>但是，Rule实体的索引使用的是内存中目录，因为此实体的默认目录提供程序被属性覆盖<code>hibernate.search.Rules.directory_provider</code> 。</p>
</div>
<div class="paragraph">
<p>最后，Action实体使用自定义目录提供程序<code>CustomDirectoryProvider</code>通过指定<code>hibernate.search.Actions.directory_provider</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例11指定索引名称</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</code></pre>
</div>
</div>
</div>
</div>
<div id="example-configuring-directory-providers" class="exampleblock">
<div class="title">范例12。配置目录提供程序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Rules.directory_provider = local-heap
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用所描述的配置方案，您可以轻松定义常见规则，例如目录提供者和基本目录，并在以后基于每个索引覆盖这些默认值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table id="directory-provider-table" class="tableblock frame-all grid-all spread">
<caption class="title">表2。内置DirectoryProvider的列表</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称和说明</th>
<th class="tableblock halign-left valign-top">性质</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local-heap：使用本地JVM堆的目录。</p>
<p class="tableblock"><strong>JVM关闭时，本地堆目录和所有包含的索引都会丢失。</strong></p>
<p class="tableblock">仅提供此选项用于<strong>测试</strong> <strong>索引较小（琐碎）</strong>且<strong>并发性较低的</strong> <strong>配置</strong> ，该<strong>配置</strong>可能会略微提高性能。在需要较大索引和/或高并发性的设置中，基于文件系统的目录（请参见下文）将获得更好的性能。</p>
<p class="tableblock">该目录将通过以下方式唯一标识（在同一部署单元中） <code>@Indexed.index</code>元件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem：基于文件系统的目录。</p>
<p class="tableblock">使用的目录将是<indexbase>/<indexname></indexname></indexbase></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code> ：基本目录<code>indexName</code> ：覆盖@ Indexed.index（对于分片索引很有用） <code>locking_strategy</code> ：可选，请参见<a href="#search-configuration-directory-lockfactories">LockFactory配置</a> <code>filesystem_access_type</code> ：允许确定此DirectoryProvider使用的FSDirectory实现的确切类型。允许值为<code>auto</code> （默认值，在非Windows系统上选择NIOFSDirectory，在Windows上选择SimpleFSDirectory）， <code>simple</code> （SimpleFSDirectory）， <code>nio</code> （NIOFSDirectory）， <code>mmap</code> （MMapDirectory）。在更改此设置之前，请确保参考这些Directory实现的Javadocs。即使NIOFSDirectory或MMapDirectory可以带来实质性的性能提升，但它们也存在问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem-master：基于文件系统的目录。</p>
<p class="tableblock">喜欢<code>filesystem</code> 。它还定期将索引复制到源目录（即复制目录）。</p>
<p class="tableblock">刷新周期的建议值比复制信息的时间至少高50％（默认值3600秒-60分钟）。</p>
<p class="tableblock">请注意，复制基于增量复制机制，可减少平均复制时间。</p>
<p class="tableblock">DirectoryProvider通常在JMS后端群集的主节点上使用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code> ：基本目录<code>indexName</code> ：覆盖@ Indexed.index（对于分片索引很有用） <code>sourceBase</code> ：源（复制）基本目录。
<code>source</code> ：源目录后缀（默认为<code>@Indexed.index</code> ）。实际的源目录名称为<em><sourcebase>/ <source></sourcebase></em> <code>refresh</code> ：刷新时间（以秒为单位）（复制将在每刷新秒发生一次）。如果在接下来的刷新周期过后仍在进行复制，则将跳过第二次复制操作。
<code>locking_strategy</code> ：可选，请参见<a href="#search-configuration-directory-lockfactories">LockFactory配置</a> <code>filesystem_access_type</code> ：允许确定此DirectoryProvider使用的FSDirectory实现的确切类型。允许值为<code>auto</code> （默认值，在非Windows系统上选择NIOFSDirectory，在Windows上选择SimpleFSDirectory）， <code>simple</code> （SimpleFSDirectory）， <code>nio</code> （NIOFSDirectory）， <code>mmap</code> （MMapDirectory）。在更改此设置之前，请确保参考这些Directory实现的Javadocs。即使NIOFSDirectory或MMapDirectory可以带来实质性的性能提升，但它们也存在问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem-slave：基于文件系统的目录。</p>
<p class="tableblock">喜欢<code>filesystem</code> ，但会定期检索主版本（源）。为避免锁定和搜索结果不一致，将保留2个本地副本。</p>
<p class="tableblock">刷新周期的建议值比复制信息的时间至少高50％（默认值3600秒-60分钟）。</p>
<p class="tableblock">请注意，复制基于增量复制机制，可减少平均复制时间。如果经过刷新时间后仍在进行复制，则将跳过第二次复制操作。</p>
<p class="tableblock">DirectoryProvider通常在使用JMS后端的从属节点上使用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code> ：基本目录<code>indexName</code> ：覆盖@ Indexed.index（对于分片索引很有用） <code>sourceBase</code> ：源（复制）基本目录。
<code>source</code> ：源目录后缀（默认为<code>@Indexed.index</code> ）。实际的源目录名称为<em><sourcebase>/ <source></sourcebase></em> <code>refresh</code> ：刷新时间（以秒为单位）（副本将在每刷新秒发生一次）。
<code>locking_strategy</code> ：可选，请参见<a href="#search-configuration-directory-lockfactories">LockFactory配置</a> <code>retry_marker_lookup</code> ：可选，默认为0。定义失败之前在源目录中查找标记文件的次数。每次尝试之间等待5秒。
<code>retry_initialize_period</code> ：可选，设置一个整数值（以秒为单位）以启用重试初始化功能：如果从属设备找不到主索引，它将再次尝试直到在后台找到它为止，而不会阻止应用程序启动：在查询之前执行全文查询初始化索引不会被阻止，但将返回空结果。当不启用该选项或将其显式设置为零时，它将失败并抛出异常，而不是安排重试计时器。为防止应用程序在没有无效索引的情况下启动但仍控制初始化超时，请参见<code>retry_marker_lookup</code>代替。
<code>filesystem_access_type</code> ：允许确定此DirectoryProvider使用的FSDirectory实现的确切类型。允许值为<code>auto</code> （默认值，在非Windows系统上选择NIOFSDirectory，在Windows上选择SimpleFSDirectory）， <code>simple</code> （SimpleFSDirectory）， <code>nio</code> （NIOFSDirectory）， <code>mmap</code> （MMapDirectory）。在更改此设置之前，请确保参考这些Directory实现的Javadocs。即使NIOFSDirectory或MMapDirectory可以带来实质性的性能提升，但它们也存在问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">infinispan：基于Infinispan的目录。</p>
<p class="tableblock">使用它可以将索引存储在分布式网格中，从而使索引更改对于群集的所有元素都非常快速可见。另请参阅<a href="#infinispan-directories">Infinispan目录配置</a>以了解其他要求和配置设置。Infinispan需要全局配置和其他依赖性。此处定义的设置适用于每个不同的索引。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>locking_cachename</code> ：用于存储锁的Infinispan缓存的名称。
<code>data_cachename</code> ：Infinispan缓存的名称，用于存储最大的数据块；该区域将包含最大的对象，如果您有足够的内存，请使用复制或切换到分发。
<code>metadata_cachename</code> ：Infinispan缓存的名称，用于存储与索引有关的元数据；此数据非常小且经常读取，建议使用复制来设置此缓存。
<code>chunk_size</code> ：索引的大文件被分成较小的块，您可能需要设置网络有效处理的最大值。网络调整可能会很有用。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果内置目录提供程序不符合您的需求，则可以通过实施<code>org.hibernate.store.DirectoryProvider</code>接口。在这种情况下，请将提供程序的完全合格的类名称传递到<code>directory_provider</code>属性。您可以传递任何其他属性来使用前缀配置您的自定义实现<code>hibernate.search.<indexname></code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="infinispan-directories"><a class="anchor" href="#infinispan-directories"></a> 3.3.1。Infinispan目录配置</h4>
<div class="paragraph">
<p>Infinispan是一个分布式的，可伸缩的，云友好的数据网格平台，Hibernate Search可以使用它来存储Lucene索引。您的应用程序可以从Infinispan的分发功能中受益，该功能可在所有延迟短的节点上提供索引更新。</p>
</div>
<div class="paragraph">
<p>本节介绍如何配置Hibernate Search以使用Infinispan Lucene目录。</p>
</div>
<div class="paragraph">
<p>使用Infinispan目录时，索引存储在内存中并在多个节点之间共享。它被视为分布在所有参与节点上的单个目录：如果一个节点更新索引，那么所有其他节点也将更新。可以立即在整个群集中搜索一个节点上的更新。</p>
</div>
<div class="paragraph">
<p>默认配置会复制所有数据，这些数据定义了所有节点之间的索引，从而消耗了大量内存，但提供了最佳的查询性能。对于大型索引，建议启用数据分发，以便将每条信息复制到所有集群成员的子集。分发选项将减少每个节点所需的内存量，但效率较低，因为它将导致节点之间的网络使用率很高。</p>
</div>
<div class="paragraph">
<p>也可以将部分或大部分信息卸载到<code>CacheStore</code> ，例如普通文件系统，Amazon S3，Cassandra，MongoDB或标准关系数据库。您可以将其配置为具有<code>CacheStore</code>在每个节点上，或者每个节点共享一个集中的节点。</p>
</div>
<div class="paragraph">
<p>一种流行的选择是使用复制索引以将整个索引保留在内存中，并结合使用<code>CacheStore</code>作为安全阀，以防指数大于预期。</p>
</div>
<div class="paragraph">
<p>有关所有Infinispan配置选项，请参见<a href="http://infinispan.org/documentation/">Infinispan文档</a> 。</p>
</div>
<div class="sect4">
<h5 id="_requirements"><a class="anchor" href="#_requirements"></a>要求</h5>
<div class="paragraph">
<p>要通过Maven使用Infinispan目录，请添加以下依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">范例13。使用Infinispan进行Hibernate Search的Maven依赖</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.11.4.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;9.2.2.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在Hibernate Search 5.2版中此依赖项已更改。</p>
</div>
<div class="paragraph">
<p>以前，DirectoryProvider是由Hibernate Search项目提供的，并且具有Maven坐标“ org.hibernate：hibernate-search-infinispan”，但是Infinispan团队现在正在维护此扩展点，因此，由于该版本，请使用上一个示例中的Maven定义。 。</p>
</div>
<div class="paragraph">
<p>上面打印的版本是发布此Hibernate Search版本时已知的最新兼容版本：很可能已经发布了与该Hibernate Search版本兼容的Infinispan的最新改进版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_architecture"><a class="anchor" href="#_architecture"></a>建筑</h5>
<div class="paragraph">
<p>即使使用Infinispan目录，仍建议使用JMS Master / Slave或JGroups后端，因为在Infinispan中，所有节点都将共享相同的索引，并且很可能<code>IndexWriter</code>在不同节点上处于活动状态的实例将尝试获取同一索引上的锁。因此，与其直接将更新发送到索引，不如将更新发送到JMS队列或JGroups通道，并让单个节点代表所有其他节点应用所有更改。</p>
</div>
<div class="paragraph">
<p>配置非默认后端不是必需的，而是性能优化，因为启用了锁定以具有单个节点写入功能。</p>
</div>
<div class="paragraph">
<p>要配置JMS从属服务器，仅必须替换后端，必须将目录提供程序设置为<code>infinispan</code> ;在主服务器上设置相同的目录提供程序时，它们将连接，而无需跨节点设置复制作业。使用JGroups后端非常相似-只需将后端配置与<code>infinispan</code>目录提供商。</p>
</div>
</div>
<div class="sect4">
<h5 id="_infinispan_configuration"><a class="anchor" href="#_infinispan_configuration"></a> Infinispan配置</h5>
<div class="paragraph">
<p>最简单的配置仅需要启用后端：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.[default|&lt;indexname&gt;].directory_provider = infinispan</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这就是获取集群复制的索引所需的全部内容，但是默认配置不会为索引启用任何形式的永久性持久性。要启用此功能，应提供Infinispan配置文件。</p>
</div>
<div class="paragraph">
<p>要使用Infinispan，Hibernate Search需要CacheManager。它可以通过JNDI查找和重用现有的CacheManager，或者启动和管理新的CacheManager。在后一种情况下，Hibernate Search将启动和停止它（关闭Hibernate SessionFactory时将发生关闭）。</p>
</div>
<div class="paragraph">
<p>要通过JNDI使用和现有CacheManager（可选参数）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.cachemanager_jndiname = [jndiname]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要从配置文件（可选参数）启动新的CacheManager：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果同时定义了两个参数，则JNDI将具有优先权。如果未定义这些内容，则Hibernate Search将使用包含在其中的默认Infinispan配置<code>infinispan-directory-provider.jar</code> 。在大多数情况下，此配置应该可以正常工作，但不能将索引存储在持久性高速缓存存储中。</p>
</div>
<div class="paragraph">
<p>如<a href="#directory-provider-table">内置DirectoryProvider的列表中</a>所述，每个索引都使用三个缓存，因此应配置三个不同的缓存，如<code>default-hibernatesearch-infinispan.xml</code>在提供<code>infinispan-directory-provider.jar</code> 。多个索引可以共享相同的缓存。</p>
</div>
<div class="paragraph">
<p>Infinispan的网络功能依赖于JGroups，因此，除非您在单个节点上使用Infinispan，否则Infinispan配置文件将引用JGroups配置文件。这种耦合并不总是可行的，我们提供了一个属性来覆盖使用的JGroups配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.configuration.transport_override_resourcename = jgroups-ec2.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这允许仅切换JGroups配置，同时保留其余Infinispan配置。</p>
</div>
<div class="paragraph">
<p>文件<code>jgroups-ec2.xml</code>上例中使用的是Infinispan中包含的几个JGroups配置之一。这是在Amazon EC2网络上运行的一个很好的起点。有关更多详细信息和示例，请参见《 Infinispan配置指南》 <a href="http://infinispan.org/docs/9.0.x/user_guide/user_guide.html#use_one_of_the_pre_configured_jgroups_files">中预配置JGroups堆栈的用法</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-worker"><a class="anchor" href="#configuration-worker"></a> 3.4。工作人员配置</h3>
<div class="paragraph">
<p>通过工作程序配置，可以优化Hibernate Search与Lucene的交互方式。存在几个体系结构组件和可能的扩展点。让我们仔细看看。</p>
</div>
<div class="paragraph">
<p>首先有一个工人。Worker接口的实现负责接收所有实体更改，通过上下文对它们进行排队，并在上下文结束后应用它们。最直观的上下文（尤其是与ORM关联的上下文）是事务。因此，默认情况下，Hibernate Search将使用TransactionalWorker来确定每个事务的所有更改的范围。但是，可以想象一种场景，其中上下文取决于例如实体更改的数量或某些其他应用程序（生命周期）事件。因此，可以如<a href="#table-worker-configuration">Scope配置中</a>所示配置Worker实现。</p>
</div>
<table id="table-worker-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">表3。范围配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.worker.scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的Worker实现的完全限定的类名。如果未设置此属性，则为空或<code>transaction</code>使用默认的TransactionalWorker。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.default.worker。*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有配置属性均以前缀<code>hibernate.search.default.worker</code>在初始化期间被传递给Worker。这允许添加自定义的，特定于工作程序的参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.worker.enlist_in_transaction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认为<code>false</code> 。设置为<code>true</code>将所有索引工作发送到与Hibernate ORM会话相同的事务中的队列。仅当所有后端都使用JMS并且队列配置为事务性，启用XA时，才应启用此选项。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>上下文结束后，就可以准备并应用索引更改了。可以从新线程内同步或异步完成此操作。同步更新的优点是索引始终与数据库同步。另一方面，异步更新可以帮助最小化用户响应时间。缺点是数据库状态和索引状态之间可能存在差异。让我们看一下<a href="#table-work-execution-configuration">执行配置中</a>显示的配置选项。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个索引的以下选项可以不同；实际上，他们需要indexName前缀或使用<code>default</code>为所有索引设置默认值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table id="table-work-execution-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">表4。执行配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.execution</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sync</code> ：同步执行（默认）</p>
<p class="tableblock"><code>async</code> ：异步执行</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>到目前为止，无论哪种执行模式，所有工作都在同一虚拟机（VM）中完成。单个VM的总工作量未更改。幸运的是，有更好的方法，即授权。通过配置hibernate.search.default.worker.backend，可以将索引工作发送到其他服务器-请参阅<a href="#table-backend-configuration">后端配置</a> 。同样，可以为每个索引配置不同的此选项。</p>
</div>
<table id="table-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">表5。后端配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.backend</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local</code> ：在同一JVM中运行索引更新的默认后端。当属性未定义或为空时也使用。</p>
<p class="tableblock"><code>jms</code> ：JMS后端。索引更新被发送到JMS队列以由索引主机处理。有关其他配置选项，请参见<a href="#table-jms-backend-configuration">JMS后端配置</a> ；有关此设置的更详细说明，请参见<a href="#table-jms-backend-configuration">JMS</a> <a href="#jms-backend">主/从后端</a> 。</p>
<p class="tableblock"><code>jgroupsMaster</code> ， <code>jgroupsSlave</code>要么<code>jgroups</code> ：使用<a href="http://www.jgroups.org/">JGroups</a>作为通讯层的后端。有关此设置的详细说明，请参见<a href="#jgroups-backend">JGroups主/从后端</a> 。</p>
<p class="tableblock"><code>blackhole</code> ：主要是测试/开发人员设置，会忽略所有索引工作</p>
<p class="tableblock">您还可以指定实现的类的全限定名称<code>BackendQueueProcessor</code> 。这样，您可以实现自己的通信层：队列处理器将接收所有要发送给索引管理器的索引作品。</p>
<p class="tableblock">请注意， <code>BackendQueueProcessor</code>只会在创建索引管理器后立即创建，并且可能会延迟创建（例如，当索引使用<a href="#advanced-features-dynamic-sharding">动态分片时</a> ）。如果要急于初始化一些资源，则可以指定实现的类的完全限定名称。 <code>Backend</code> 。此类将在启动时实例化并初始化，然后将要求产生<code>BackendQueueProcessor</code>实例根据需要。</p></td>
</tr>
</tbody>
</table>
<table id="table-jms-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">表6。JMS后端配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.jms.connection_factory</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于JMS后端是必需的。定义JNDI名称以从（查找JMS连接工厂<code>/ConnectionFactory</code>在WildFly中默认情况下）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.jms.queue</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于JMS后端是必需的。定义要从中查找JMS队列的JNDI名称。该队列将用于发布工作消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.jms.login</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于JMS从属服务器是可选的。当队列需要登录凭据来定义登录时，请使用它。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.worker.jms.login</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于JMS从属服务器是可选的。当队列需要登录凭据来定义密码时，请使用它。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>由于这些组件使用JNDI，因此请不要忘记为初始上下文查找配置Hibernate ORM属性。</p>
</div>
<table id="table-enable-jndi" class="tableblock frame-all grid-all spread">
<caption class="title">表7。启用Hibernate ORM的JNDI查找功能</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.jndi.class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">javax.naming的名称。要使用的InitialContext实现类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.jndi.url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JNDI InitialContext连接URL的名称</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另请参见<a href="http://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#jndi/">Hibernate ORM中</a>的<a href="http://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#jndi/">JNDI配置</a> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可能已经注意到，某些显示的属性是相关的，这意味着并非所有的属性值组合都有意义。实际上，您最终可能会遇到无法正常使用的配置。对于您提供自己的某些所示接口的实现的情况尤其如此。在编写自己的Worker或BackendQueueProcessor实现之前，请确保研究现有代码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="jms-backend"><a class="anchor" href="#jms-backend"></a> 3.4.1。JMS主/从后端</h4>
<div class="paragraph">
<p>本节将详细介绍如何配置主/从Hibernate Search体系结构。</p>
</div>
<div class="paragraph">
<p>JMS后端配置。</p>
</div>
<div class="sect4">
<h5 id="_slave_nodes"><a class="anchor" href="#_slave_nodes"></a>从节点</h5>
<div class="paragraph">
<p>每个索引更新操作都发送到JMS队列。索引查询操作在本地索引副本上执行。</p>
</div>
<div class="exampleblock">
<div class="title">范例14。JMS从站配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optionally authentication credentials:
hibernate.search.default.worker.jms.login = myname
hibernate.search.default.worker.jms.password = wonttellyou
#optional jndi configuration (check your JMS provider for more information)

## Enqueue indexing tasks within an XA transaction with the database (optional)
hibernate.search.worker.enlist_in_transaction = true</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>enlist_in_transaction</code>如果需要严格保证将索引工作存储在数据库更改的同一事务中的队列中，则可以启用该选项，但是这将要求RDBMs数据源和JMS队列都启用XA。</p>
</div>
<div class="paragraph">
<p>在谈论协调事务系统时，请确保使用XA JMS队列，并且您的数据库支持XA。</p>
</div>
<div class="paragraph">
<p>的默认<code>enlist_in_transaction</code>是<code>false</code>通常，如果索引存在问题，最好不要使数据库事务失败。</p>
</div>
<div class="paragraph">
<p>通过实现自定义，可以将补偿操作应用于索引<code>ErrorHandler</code> （请参阅<a href="#exception-handling">异常处理</a> ），或者通过启动MassIndexer来简单地重新同步整个索引状态（请参阅<a href="#search-batchindex-massindexer">使用MassIndexer</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建议使用文件系统本地副本以获得更快的搜索结果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_master_node"><a class="anchor" href="#_master_node"></a>主节点</h5>
<div class="paragraph">
<p>每个索引更新操作均从JMS队列中获取并执行。主索引会定期复制。</p>
</div>
<div class="exampleblock">
<div class="title">示例15JMS Master配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#The backend is not set: use the default one which is 'local'</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建议刷新时间长于预期的复制时间。如果在下次刷新触发时仍在执行复制操作，则将跳过第二次刷新：即使不知道复制时间，也可以将该值设置为较低。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了Hibernate Search框架配置之外，还必须编写并设置一个消息驱动Bean，以通过JMS处理索引工作队列。</p>
</div>
<div class="exampleblock">
<div class="title">示例16。消息驱动Bean处理索引队列</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.jms.MessageListener;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;

import org.hibernate.search.backend.jms.spi.AbstractJMSHibernateSearchController;
import org.hibernate.search.orm.spi.SearchIntegratorHelper;
import org.hibernate.search.spi.SearchIntegrator;

@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {

    @PersistenceUnit EntityManagerFactory emf;

    @Override
    protected SearchIntegrator getSearchIntegrator() {
        return SearchIntegratorHelper.extractFromEntityManagerFactory( emf );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该示例继承自Hibernate Search源代码中提供的抽象JMS控制器类，并实现了JavaEE MDB。该实现作为示例给出，可以进行调整以使用非Java EE消息驱动的Bean。本质上，您需要做的是将特定的JMS队列与<code>SearchFactory</code> EntityManager的实例。作为高级替代方案，您可以通过不扩展来实现自己的逻辑<code>AbstractJMSHibernateSearchController</code>而是将其用作实现示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jgroups-backend"><a class="anchor" href="#jgroups-backend"></a> 3.4.2。JGroups主/从后端</h4>
<div class="paragraph">
<p>本节描述如何配置JGroups主/从后端。主角色和从角色类似于<a href="#jms-backend">JMS主/从后端中</a>所示的角色，只需要设置一个不同的后端（hibernate.search.default.worker.backend）。</p>
</div>
<div class="paragraph">
<p>可以将特定的后端配置为充当从属服务器<code>jgroupsSlave</code> ，作为大师使用<code>jgroupsMaster</code> ，或者可以通过使用来根据需要在角色之间自动切换<code>jgroups</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以指定一个<code>jgroupsMaster</code>和一组<code>jgroupsSlave</code>实例，或者您将所有实例指定为<code>jgroups</code> 。切勿混用两种方法！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置为使用JGroups的所有后端共享同一通道。JGroups JChannel是参与同一集群组的所有节点之间的主要通信链接。由于在所有后端之间共享一个通道很方便，因此通道配置属性不是在每个工作人员部分定义的，而是全局定义的。请参见<a href="#jgroups-channel-configuration">JGroups通道配置</a> 。</p>
</div>
<div class="paragraph">
<p>表<a href="#table-jgroups-backend-configuration">JGroups后端配置属性</a>包含可以在每个索引后端上独立设置的所有配置选项。这些适用于后端的所有三个变体： <code>jgroupsSlave</code> ， <code>jgroupsMaster</code> ， <code>jgroups</code> 。您不太可能需要更改它们的默认值。</p>
</div>
<table id="table-jgroups-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">表8。JGroups后端配置属性</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>属性</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.jgroups.block_waiting_ack</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置为<code>true</code>要么<code>false</code> 。False效率更高，但不会等待将操作传递给对等方。默认为<code>true</code>当后端是同步的时， <code>false</code>当后端是<code>async</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.jgroups.messages_timeout</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待单个命令被确认并在以下时间执行的超时<code>block_waiting_ack</code>是<code>true</code> ，或以其他方式确认。值（以毫秒为单位），默认为<code>20000</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。 <indexname>.jgroups.delegate_backend</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接收索引操作的主节点将它们转发到要执行的标准后端。默认为<code>lucene</code> 。另请参阅<a href="#table-backend-configuration">后端配置</a> ，但唯一有用的选项可能是<code>blackhole</code>或自定义实施，以帮助隔离网络延迟问题。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_slave_nodes_2"><a class="anchor" href="#_slave_nodes_2"></a>从节点</h5>
<div class="paragraph">
<p>每个索引更新操作都通过JGroups通道发送到主节点。索引查询操作在本地索引副本上执行。启用JGroups worker只能确保将索引操作发送到主服务器，您仍然必须同步配置适当的目录（请参见<code>filesystem-master</code> ， <code>filesystem-slave</code>要么<code>infinispan</code> <a href="#search-configuration-directory">目录配置中的</a>选项）。</p>
</div>
<div class="exampleblock">
<div class="title">示例17JGroups从站配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### slave configuration
hibernate.search.default.worker.backend = jgroupsSlave</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_master_node_2"><a class="anchor" href="#_master_node_2"></a>主节点</h5>
<div class="paragraph">
<p>每个索引更新操作都从JGroups通道获取并执行。主索引会定期复制。</p>
</div>
<div class="exampleblock">
<div class="title">示例18JGroups Master配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### master configuration
hibernate.search.default.worker.backend = jgroupsMaster</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_automatic_master_election"><a class="anchor" href="#_automatic_master_election"></a>自动大师选举</h5>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此功能被认为是实验性的。特别是在重选过程中，有一小段时间会丢失索引请求。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种模式下，不同的节点将自动选举一个主节点。当主节点发生故障时，将自动选择一个新节点。</p>
</div>
<div class="paragraph">
<p>设置此后端时，期望同一集群中的所有Hibernate Search实例为每个特定索引使用相同的后端：此配置是静态的替代方案<code>jgroupsMaster</code>和<code>jgroupsSlave</code>方法，因此请确保不要混用它们。</p>
</div>
<div class="paragraph">
<p>要在此配置中同步索引，请避免<code>filesystem-master</code>和<code>filesystem-slave</code>目录提供者的行为无法动态切换；使用Infinispan <code>Directory</code>相反，它不需要在每个实例上使用不同的配置，并允许动态切换编写器；另请参阅<a href="#infinispan-directories">Infinispan目录配置</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例19JGroups配置用于自动主配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### automatic configuration
hibernate.search.default.worker.backend = jgroups</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你应该使用<code>jgroups</code>或夫妻<code>jgroupsMaster</code> ， <code>jgroupsSlave</code> ？</p>
</div>
<div class="paragraph">
<p>动态的<code>jgroups</code>后端更适合于您的主服务器更有可能需要故障转移到其他计算机（如云）的环境。静态配置的好处是可以将主机保持在众所周知的位置：您的体系结构可以通过将大多数写请求发送到已知主机来利用它。此外，还需要在主节点上触发优化和MassIndexer操作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="jgroups-channel-configuration"><a class="anchor" href="#jgroups-channel-configuration"></a> JGroups频道配置</h5>
<div class="paragraph">
<p>配置JGroups通道实质上需要根据网络协议栈指定传输方式。要配置JGroups传输，请将配置属性hibernate.search.services.jgroups.configurationFile指向一个JGroups配置文件；这可以是文件路径或Java资源名称。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果未明确指定任何属性，则假定JGroups默认配置文件<code>flush-udp.xml</code>用来。已知此示例配置可在大多数情况下使用，但值得注意的是Amazon AWS。有关更多示例和协议配置的详细信息，请参考<a href="http://www.jgroups.org/manual-3.x/html/">JGroups手册</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认群集名称为<code>Hibernate Search Cluster</code>可以按照<a href="#example-jgroups-cluster-name">JGroups集群名称配置中的说明进行配置</a> 。</p>
</div>
<div id="example-jgroups-cluster-name" class="exampleblock">
<div class="title">示例20JGroups集群名称配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.services.jgroups.clusterName = My-Custom-Cluster-Id</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>集群名称是标识一个组的名称：通过更改名称，您可以隔离地在同一网络中运行不同的集群。</p>
</div>
<div class="sect5">
<h6 id="_jgroups_channel_instance_injection"><a class="anchor" href="#_jgroups_channel_instance_injection"></a> JGroups通道实例注入</h6>
<div class="paragraph">
<p>对于编程配置，可以使用一个附加选项来配置JGroups通道：使用该属性将现有通道实例直接传递给Hibernate Search <code>hibernate.search.services.jgroups.providedChannel</code> ，如以下示例所示。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.backend.impl.jgroups.JGroupsChannelProvider;

org.jgroups.JChannel channel = ...
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( JGroupsChannelProvider.CHANNEL_INJECT, channel );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-reader-strategy"><a class="anchor" href="#configuration-reader-strategy"></a> 3.5。阅读器策略配置</h3>
<div class="paragraph">
<p>读者策略中描述了不同的读者<a href="#search-architecture-readerstrategy">策略</a> 。开箱即用的策略是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shared</code> ：在多个查询中共享索引阅读器。此策略非常有效。</p>
</li>
<li>
<p><code>not-shared</code> ：为每个查询创建索引阅读器。实现非常简单。</p>
</li>
<li>
<p><code>async</code> ：仅定期打开一个新的索引读取器。这是最有效的实现，但是查询可能返回过期的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认的阅读器策略是<code>shared</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过更改<code>.reader.strategy</code>配置属性，范围为“默认”索引或特定索引。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].reader.strategy = async
hibernate.search.[default|&lt;indexname&gt;].reader.async_refresh_period_ms = 8000</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将以上属性开关添加到<code>async</code>策略，并将其配置为每8秒刷新一次索引读取器。</p>
</div>
<div class="paragraph">
<p>或者，您可以使用自定义实现<code>org.hibernate.search.indexes.spi.ReaderProvider</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在my.corp.myapp。CustomReaderProvider是自定义策略的实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="_serialization"><a class="anchor" href="#_serialization"></a> 3.6。序列化</h3>
<div class="paragraph">
<p>使用集群功能时，Hibernate Search需要找到以下实现： <code>SerializationProvider</code>类路径上的服务。</p>
</div>
<div class="paragraph">
<p>可以使用以下GAV坐标找到基于<a href="https://avro.apache.org">Apache Avro</a>的服务的实现：</p>
</div>
<div class="paragraph">
<p><code>org.hibernate:hibernate-search-serialization-avro:5.11.4.Final</code></p>
</div>
<div class="paragraph">
<p>您可以将坐标添加到pom文件中，或下载所有必需的依赖项并将它们添加到类路径中。Hibernate Search将找到服务实现，而无需任何其他配置。</p>
</div>
<div class="paragraph">
<p>或者，您可以创建一个自定义服务实现：</p>
</div>
<div id="example-serialization-provider" class="exampleblock">
<div class="title">示例21序列化策略定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example.provider.serializer

import org.hibernate.search.indexes.serialization.spi.Deserializer;
import org.hibernate.search.indexes.serialization.spi.SerializationProvider;
import org.hibernate.search.indexes.serialization.spi.Serializer;

public class ExampleOfSerializationProvider implements SerializationProvider {

    @Override
    public Serializer getSerializer() {
        Serializer serializer = ...
        return serializer;
    }

    @Override
    public Deserializer getDeserializer() {
        Deserializer deserializer = ...
        return deserializer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate Search使用Java ServiceLoader机制来透明地发现服务。在这种情况下，您将在类路径中添加以下文件：</p>
</div>
<div class="exampleblock">
<div class="title">示例22SerializationProvider服务的服务文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>/META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例23/META-INF/services/org.hibernate.search.indexes.serialization.spi的内容。序列化提供者</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>example.provider.serializer.ExampleOfSerializationProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<a href="#section-services">使用外部服务</a>一节中找到有关服务的更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="exception-handling"><a class="anchor" href="#exception-handling"></a> 3.7。异常处理</h3>
<div class="paragraph">
<p>Hibernate Search允许您配置索引过程中如何处理异常。如果未提供任何配置，则默认情况下会将异常记录到日志输出中。可以显式声明异常日志记录机制，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.error_handler = log</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同步和异步索引都会发生默认的异常处理。Hibernate Search提供了一种简单的机制来覆盖默认的错误处理实现。</p>
</div>
<div class="paragraph">
<p>为了提供自己的实现，必须实现ErrorHandler接口，该接口提供handle（ErrorContext context）方法。ErrorContext提供对主要LuceneWork实例，基础异常以及由于主要异常而无法处理的任何后续LuceneWork实例的引用。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface ErrorContext {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在Hibernate Search中注册此错误处理程序，必须在配置属性中声明ErrorHandler实现的标准类名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.error_handler = CustomerErrorHandler</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，可以通过以编程方式引导Hibernate Search时使用的配置值映射来传递ErrorHandler实例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_lucene_configuration"><a class="anchor" href="#_lucene_configuration"></a> 3.8。Lucene配置</h3>
<div class="paragraph">
<p>即使Hibernate Search会尝试使您尽可能避免使用Lucene细节，但是出于性能原因或满足特定用例，可以直接配置一些Lucene细节。以下各节讨论这些配置选项。</p>
</div>
<div class="sect3">
<h4 id="lucene-indexing-performance"><a class="anchor" href="#lucene-indexing-performance"></a> 3.8.1。调整索引编制性能</h4>
<div class="paragraph">
<p>Hibernate Search允许您通过指定一组传递给基础Lucene的参数来调整Lucene索引的性能。 <code>IndexWriter</code>如<code>mergeFactor</code> ， <code>maxMergeDocs</code>和<code>maxBufferedDocs</code> 。您可以将这些参数指定为适用于所有索引的默认值（基于每个索引，甚至每个分片）。</p>
</div>
<div class="paragraph">
<p>有几个低层次<code>IndexWriter</code>可以针对不同用例进行调整的设置。这些参数按<code>indexwriter</code>关键词：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有为<code>indexwriter</code>值在特定分片配置中，Hibernate Search将先查看索引部分，然后再查看默认部分。</p>
</div>
<div id="example-performance-option-configuration" class="exampleblock">
<div class="title">示例24性能选项配置示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.Animals.2.indexwriter.max_merge_docs = 10
hibernate.search.Animals.2.indexwriter.merge_factor = 20
hibernate.search.Animals.2.indexwriter.max_buffered_docs = default
hibernate.search.default.indexwriter.max_merge_docs = 100
hibernate.search.default.indexwriter.ram_buffer_size = 64</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>“ <a href="#example-performance-option-configuration">示例性能”选项配置中的配置</a>将导致以下设置应用到动物索引的第二个分片上：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max_merge_docs</code> = 10</p>
</li>
<li>
<p><code>merge_factor</code> = 20</p>
</li>
<li>
<p><code>ram_buffer_size</code> = 64MB</p>
</li>
<li>
<p><code>max_buffered_docs</code> = Lucene默认</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有其他值将使用Lucene中定义的默认值。</p>
</div>
<div class="paragraph">
<p>所有值的默认值是保留它们为Lucene自己的默认值。因此<a href="#table-performance-parameters">，索引性能和行为属性列表中</a>列出的值取决于您使用的Lucene版本。显示的值是相对于版本的<code>2.4</code> 。有关Lucene索引性能的更多信息，请参考Lucene文档。</p>
</div>
<table id="table-performance-parameters" class="tableblock frame-all grid-all spread">
<caption class="title">表9。索引性能和行为属性列表</caption>
<colgroup>
<col style="width:40%">
<col style="width:40%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .exclusive_index_use</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调成<code>true</code>当没有其他进程需要写入相同的索引时。这将使Hibernate Search可以在索引上以独占模式工作，并在将更改写入索引时提高性能。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> （提高的性能，仅在关机时释放锁）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .max_queue_length</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个索引都有一个单独的“管道”，其中包含要应用于索引的更新。当此队列已满时，向该队列添加更多操作将成为阻塞操作。除非使用<code>worker.execution</code>配置为<code>async</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .index_flush_interval</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">两次刷新操作到索引存储之间的时间间隔（以毫秒为单位）。除非被忽略<code>worker.execution</code>配置为<code>async</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.max_buffered_delete_terms</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">确定在应用和刷新缓冲的内存中删除条款之前所需的最少删除条款数量。如果此时内存中有文档缓冲，则将它们合并并创建一个新的段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用（因RAM使用情况而变化）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.max_buffered_docs</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制索引期间在内存中缓冲的文档数量。越大，消耗的RAM越多。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用（因RAM使用情况而变化）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.max_merge_docs</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义段中允许的最大文档数。较小的值在频繁更改的索引上表现更好，如果索引不经常更改，则较大的值提供更好的搜索性能。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无限（整数。MAX_VALUE）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.merge_factor</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制段合并频率和大小。确定插入时合并段索引的频率。值越小，索引时使用的RAM越少，未优化索引的搜索速度更快，但索引速度较慢。值较大时，在索引编制过程中会使用更多的RAM，而对未优化索引的搜索会较慢，而索引编制会更快。因此，较大的值（> 10）最适合用于批处理索引的创建，较小的值（<10）用于交互式维护的索引。该值不能小于2。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.merge_min_size</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制段合并频率和大小。小于此大小（以MB为单位）的段将始终用于下一个段合并操作。将此值设置得太大可能会导致昂贵的合并操作，即使合并操作不太频繁也是如此。也可以看看<code>org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 MB（实际上〜1K）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.merge_max_size</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制段合并频率和大小。大于此大小（以MB为单位）的段永远不会合并到较大的段中。这有助于减少内存需求，并避免以最佳搜索速度为代价的某些合并操作。优化索引时，将忽略此值。也可以看看<code>org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无限</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.merge_max_optimize_size</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制段合并频率和大小。即使优化索引，大于此大小（以MB为单位）的段也不会合并到较大的段中（请参见<code>merge_max_size</code>设置）。应用于<code>org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无限</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.merge_calibrate_by_deletes</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制段合并频率和大小。调成<code>false</code>估计合并策略时不要考虑已删除的文档。应用于<code>org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.ram_buffer_size</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制专用于文档缓冲区的RAM量（以MB为单位）。与max_buffered_docs一起使用时，无论哪个事件首先发生，都会发生刷新。通常，为了获得更快的索引性能，最好按RAM使用率进行刷新，而不要按文档计数进行刷新，并尽可能使用较大的RAM缓冲区。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16兆字节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.enable_dirty_check</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">并非所有实体更改都需要更新Lucene索引。如果未为所有更新的实体属性（脏属性）建立索引，则Hibernate Search将跳过重新建立索引的工作。如果使用自定义，请禁用此选项<code>FieldBridge</code>每个更新事件都需要调用该属性（即使配置了字段桥的属性没有更改）。此优化将不适用于使用<code>@ClassBridge</code>或一个<code>@DynamicBoost</code> 。布尔参数，使用“ true”或“ false”。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search。[默认| <indexname>] .indexwriter.infostream</indexname></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用有关Lucene内部组件的低级跟踪信息。将导致严重的性能下降：仅应用于故障排除。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您的架构允许，请始终保持<code>hibernate.search.default.exclusive_index_use=true</code>因为它大大提高了索引编写的效率。这是自Hibernate Search版本4起的默认设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要调整索引速度，对从数据库中加载对象的时间进行计时（与对索引的写操作隔离）可能会很有用。为了达到这个目的<code>blackhole</code>作为工作人员后端并启动索引例程。这个后端不会禁用Hibernate Search：它仍然会为索引生成所需的变更集，但是会丢弃它们而不是将其刷新到索引中。与设置<code>hibernate.search.indexing_strategy</code>至<code>manual</code> ，使用<code>blackhole</code>因为关联的实体也会重新建立索引，因此可能会从数据库中加载更多数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre>
</div>
</div>
<div class="paragraph">
<p>推荐的方法是首先着重于通过启用<code>blackhole</code>后端，然后将获得的时间用作基准来调整索引编制过程。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>blackhole</code>后端不打算用于生产中，而仅用作识别索引瓶颈的工具。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="lucene-segment-size"><a class="anchor" href="#lucene-segment-size"></a>控制段尺寸</h5>
<div class="paragraph">
<p>选项<code>merge_max_size</code> ， <code>merge_max_optimize_size</code> ， <code>merge_calibrate_by_deletes</code>可以控制要创建的段的最大大小，但是您需要了解它们如何影响文件大小。如果您需要严格限制大小，请考虑合并细分是将其与另一个现有细分一起添加以形成更大的细分，因此您可能需要设置<code>max_size</code>合并操作的数量不到硬限制的一半。同样，在最初合并时，段的初始生成可能会大于您的预期大小。细分永远不会创建得比<code>ram_buffer_size</code> ，但将阈值作为估计值进行检查。</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用Infinispan目录对索引进行聚类时，请确保您的细分小于<code>chunk_size</code>这样就可以避免在网格中分割片段。请注意<code>chunk_size</code> Infinispan目录的“索引”以字节表示，而索引调整选项以MB为单位。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="lucene-infostream"><a class="anchor" href="#lucene-infostream"></a>故障排除：启用Lucene的信息流</h5>
<div class="paragraph">
<p>Apache Lucene允许使用称为“信息流”的功能从其内部记录非常详细的跟踪日志。要访问这些详细信息，可以将Hibernate Search配置为从Apache Lucene捕获此内部跟踪并将其重定向到您的记录器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启用<code>TRACE</code>类别的级别日志记录<code>org.hibernate.search.backend.lucene.infostream</code></p>
</li>
<li>
<p>在要检查的索引上激活功能：<code>hibernate.search.[default|<indexname>].indexwriter.infostream=true</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请记住，此功能会降低性能，尽管大多数记录器框架都允许<code>TRACE</code>级别在运行时重新配置，从而启用<code>infostream</code>即使禁用了记录器，此属性也会使您减速。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="search-configuration-directory-lockfactories"><a class="anchor" href="#search-configuration-directory-lockfactories"></a> 3.8.2。LockFactory配置</h4>
<div class="paragraph">
<p>Lucene目录具有默认的锁定策略，通常在大多数情况下都可以正常工作，但是可以为Hibernate Search管理的每个索引指定要使用的特定LockingFactory。通常不需要这样做，但可能有用。</p>
</div>
<div class="paragraph">
<p>其中一些锁定策略需要文件系统级锁定。它们可能与<code>local-heap</code>目录提供程序，但在这种情况下<code>indexBase</code>配置选项（通常在使用<code>local-heap</code>目录提供程序）必须指定为指向将存储锁定标记文件的文件系统位置。</p>
</div>
<div class="paragraph">
<p>要选择锁定工厂，请设置<code>hibernate.search.<index>.locking_strategy</code>选项之一<code>simple</code> ， <code>native</code> ， <code>single</code>要么<code>none</code> 。或者，将其设置为以下实现的完全限定名称： <code>org.hibernate.search.store.LockFactoryProvider</code> 。</p>
</div>
<table id="search-configuration-directory-lockfactories-table" class="tableblock frame-all grid-all spread">
<caption class="title">表10。可用LockFactory实现的列表</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">简单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store。SimpleFSLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基于Java的File API的安全实现，它通过创建标记文件来标记索引的使用。</p>
<p class="tableblock">如果由于某种原因不得不终止应用程序，则需要在重新启动该文件之前将其删除。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">本机</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store。NativeFSLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一样<code>simple</code>这也通过创建标记文件来标记索引的用法，但是这使用的是本机OS文件锁，因此即使JVM终止，锁也将被清除。</p>
<p class="tableblock">此实现在NFS上存在已知问题，请避免在网络共享上使用。</p>
<p class="tableblock"><code>native</code>是默认的实现<code>filesystem</code> ， <code>filesystem-master</code>和<code>filesystem-slave</code>目录提供程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store。SingleInstanceLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个LockFactory不使用文件标记，而是一个保存在内存中的Java对象锁。因此，只有在确定索引不会被任何其他进程共享时才可以使用它。</p>
<p class="tableblock">这是默认的实现<code>local-heap</code>目录提供商。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store。NoLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对该索引的所有更改均不受任何锁定的协调；仔细测试您的应用程序，并确保您知道它的含义。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>配置示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Infinispan目录使用自定义实现；仍然可以覆盖它，但是请确保您了解它是如何工作的，尤其是对于聚集索引。</p>
</div>
</div>
<div class="sect3">
<h4 id="_index_format_compatibility"><a class="anchor" href="#_index_format_compatibility"></a> 3.8.3。索引格式兼容性</h4>
<div class="paragraph">
<p>尽管Hibernate Search努力提供向后兼容的API，以便轻松地将您的应用程序移植到较新的版本，但它仍委托Apache Lucene来处理索引的编写和搜索。这将创建对Lucene索引格式的依赖性。Lucene开发人员当然会尝试保持稳定的索引格式，但是有时无法避免格式的更改。在这些情况下，您要么必须重新索引所有数据，要么使用索引升级工具。有时，Lucene还能读取旧格式，因此您无需执行特定操作（除了备份索引外）。</p>
</div>
<div class="paragraph">
<p>尽管索引格式不兼容是一种罕见的事件，但它的发生频率更高，因为Lucene的Analyzer实现可能会略微改变其行为。这可能导致较差的召回得分，可能会从结果中丢失许多匹配项。</p>
</div>
<div class="paragraph">
<p>Hibernate Search公开了一个配置属性<code>hibernate.search.lucene_version</code>指示分析器和其他Lucene类遵循（较旧的）特定版本的Lucene中定义的行为。也可以看看<code>org.apache.lucene.util.Version</code>包含在<em>lucene-core.jar中</em> 。根据您使用的Lucene的特定版本，您可能有不同的选择。如果未指定此选项，则Hibernate Search将指示Lucene使用默认版本，这通常是新项目的最佳选择。仍然建议您在配置中明确定义要使用的版本，以便在您升级Lucene时，分析仪不会改变行为。然后，您可以选择以后再更新此值，例如，当您有机会从头开始重建索引时。</p>
</div>
<div class="exampleblock">
<div class="title">示例25强制分析器与Lucene 4.7创建的索引兼容</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.lucene_version = LUCENE_47</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此选项对于已配置的SearchFactory是全局的，并且会影响所有具有此类参数的Lucene API，因为应始终应用此参数。因此，如果您还利用Lucene绕过Hibernate Search，请确保也应用相同的值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metadata_api"><a class="anchor" href="#_metadata_api"></a> 3.9。元数据API</h3>
<div class="paragraph">
<p>在查看了所有这些不同的配置选项之后，是时候查看一个API，该API允许您以编程方式访问部分配置。通过元数据API，您可以确定索引类型，还可以验证如何将它们映射<a href="#search-mapping">到索引结构</a> （请参阅将<a href="#search-mapping">实体映射到索引结构</a> ）。</p>
</div>
<div class="paragraph">
<p>该API的入口点是SearchFactory。它提供两种方法，即<code>getIndexedTypes()</code>和<code>getIndexedTypeDescriptor(Class<?>)</code> 。前者返回一组所有索引类型，而后者则允许检索给定类型的所谓IndexedTypeDescriptor。该描述符允许您确定是否对类型进行了索引，如果是，则确定例如是否对索引进行了分片（请参阅分片<a href="#advanced-features-sharding">索引</a> ）。它还允许您确定类型的静态提升（请参阅<a href="#section-boost-annotation">静态索引时间提升</a> ）及其动态提升策略（请参阅<a href="#section-dynamic-boost">动态索引时间提升</a> ）。但是，最重要的是，您获得有关索引属性和生成的Lucene Document字段的信息。这分别通过PropertyDescriptors和FieldDescriptors公开。了解该API的最简单方法是通过IDE或其javadocs对其进行探索。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>元数据API的所有描述符实例都是只读的。它们不允许更改任何运行时配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="search-configuration-deploy-on-wildfly"><a class="anchor" href="#search-configuration-deploy-on-wildfly"></a> 3.10。Hibernate Search作为WildFly模块</h3>
<div class="paragraph">
<p>Hibernate Search包含在WildFly应用程序服务器中，并且从WildFly 10开始，如果您使用的是Hibernate ORM并且具有任何索引实体，则该模块会自动激活（添加到部署的类路径中）。</p>
</div>
<div class="paragraph">
<p>WildFly 17包含较旧的Hibernate Search版本；如果要使用它，则无需下载其他任何内容，可以停止阅读本章；但是，您可能会错过一些新功能和改进。在决定使用旧版本时，请确保阅读本指南的版本与应用服务器中包含的Hibernate Search版本相匹配：本指南适用于<code>5.11.4.Final</code>只。</p>
</div>
<div class="paragraph">
<p>我们强烈建议您使用最新版本。这样做并不难：使用专用工具配置WildFly服务器，然后设置<code>wildfly.jpa.hibernate.search.module</code>您的财产<code>persistence.xml</code>到所选版本。下面提供了更多详细信息。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search分发的模块<code>5.11.4.Final</code>适用于WildFly 17.0.1。最后。</p>
</div>
<div class="paragraph">
<p>WildFly通常会包含较旧版本的Hibernate Search依赖项，因此，为了更新Hibernate Search，您还需要升级依赖项，否则应用程序将无法启动。幸运的是，有一些工具可以自动执行此操作：有关更多信息，请参见<a href="#updating-wildfly-hibernatesearch-versions">更新并在WildFly中选择最新的Hibernate Search版本</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="using-wildfly-provided-hibernatesearch-versions"><a class="anchor" href="#using-wildfly-provided-hibernatesearch-versions"></a> 3.10.1。使用WildFly中包含的Hibernate Search版本</h4>
<div class="paragraph">
<p>假设您至少有一个带有注释的实体，则WildFly中的Hibernate Search模块自动激活<code>org.hibernate.search.annotations.Indexed</code> 。</p>
</div>
<div class="paragraph">
<p>您可以显式控制JPA子系统的这种行为。例如，即使您没有注释任何实体，也要确保Hibernate Search和Apache Lucene类可用于您的应用程序，请在您的应用程序中设置以下属性<code>persistence.xml</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:main</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-wildfly-hibernatesearch-versions"><a class="anchor" href="#updating-wildfly-hibernatesearch-versions"></a> 3.10.2。在WildFly中更新并选择最新的Hibernate Search版本</h4>
<div class="paragraph">
<p>要在WildFly中使用Hibernate Search的更新版本，您需要执行以下两个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#provisioning-wildfly-maven">通过Maven</a>或<a href="#provisioning-wildfly-nonmaven">通过其他工具</a>为WildFly服务器配置Hibernate Search的更新版本。</p>
</li>
<li>
<p><a href="#selecting-updated-hibernate-search-version">选择</a>更新的Hibernate Search版本</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="provisioning-wildfly-maven"><a class="anchor" href="#provisioning-wildfly-maven"></a>通过Maven进行服务器配置</h5>
<div class="paragraph">
<p>Maven用户可以使用<code>wildfly-server-provisioning-maven-plugin</code>创建包括Hibernate Search模块的自定义WildFly服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;plugins&gt;
    &lt;plugin&gt;
    &lt;groupId&gt;org.wildfly.build&lt;/groupId&gt;
    &lt;artifactId&gt;wildfly-server-provisioning-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.2.6.Final&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
        &lt;id&gt;server-provisioning&lt;/id&gt;
        &lt;goals&gt;
            &lt;goal&gt;build&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;phase&gt;compile&lt;/phase&gt;
        &lt;configuration&gt;
            &lt;config-file&gt;server-provisioning.xml&lt;/config-file&gt;
            &lt;server-name&gt;wildfly-with-updated-hibernate-search&lt;/server-name&gt;
        &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还需要一个<code>server-provisioning.xml</code>在项目的根目录中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;server-provisioning xmlns="urn:wildfly:server-provisioning:1.1"&gt;
    &lt;feature-packs&gt;

        &lt;feature-pack
            groupId="org.hibernate"
            artifactId="hibernate-search-jbossmodules-orm"
            version="5.11.4.Final"/&gt;

        &lt;feature-pack
            groupId="org.wildfly"
            artifactId="wildfly-feature-pack"
            version="17.0.1.Final" /&gt;

    &lt;/feature-packs&gt;
&lt;/server-provisioning&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将使用Hibernate Search ORM集成以及每个所需模块的更新版本填充服务器：Hibernate Search引擎，Lucene，Hibernate ORM，...</p>
</div>
<div class="paragraph">
<p>您可能还希望包括其他可选模块。如果是这样，请查看<a href="#hibernatesearch-jboss-modules-feature-packs">可用功能包</a>的<a href="#hibernatesearch-jboss-modules-feature-packs">列表</a>并添加一个<code><feature-pack></code>标记所需的功能部件包的坐标。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据您选择的WildFly功能包，某些传递依赖项可能在Maven Central中不可用。在这种情况下，您应该<a href="https://developer.jboss.org/wiki/MavenGettingStarted-Users">设置JBoss Nexus存储库</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="provisioning-wildfly-nonmaven"><a class="anchor" href="#provisioning-wildfly-nonmaven"></a>通过其他构建工具进行服务器配置</h5>
<div class="paragraph">
<p>供应工具主要是为Maven用户开发的，但其他构建工具的用户也可以选择。</p>
</div>
<div class="paragraph">
<p>Gradle用户可以使用官方Gradle插件门户上提供的<a href="https://plugins.gradle.org/plugin/org.wildfly.build.provision">org.wildfly.build.provision</a>插件。</p>
</div>
<div class="paragraph">
<p>Maven和Gradle插件都只是调用独立调配库的精简包装，因此您还可以将此库与任何其他基于JVM的工具集成。</p>
</div>
<div class="paragraph">
<p>另请参见<a href="https://github.com/wildfly/wildfly-build-tools">WildFly供应构建工具</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="selecting-updated-hibernate-search-version"><a class="anchor" href="#selecting-updated-hibernate-search-version"></a>在WildFly中选择更新的Hibernate ORM / Hibernate Search版本</h5>
<div class="paragraph">
<p>接下来，您将需要确保WildFly的JPA子系统为您提供所选的版本，而不是与应用程序服务器捆绑在一起的默认版本。</p>
</div>
<div class="paragraph">
<p>首先，您必须选择Hibernate ORM的更新版本。如果您按照上述说明进行操作，则服务器将仅包含正确版本的Hibernate ORM：5.4.9。最后。您只需要通过在您的设置以下属性来选择它<code>persistence.xml</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>jboss.as.jpa.providerModule=org.hibernate.orm:5.4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后通过设置此其他属性来选择Hibernate Search的更新版本：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:5.11.4.Final</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>设置这些属性还可以防止WildFly使用服务器中包含的Hibernate ORM和Hibernate Search的较早版本污染您的类路径。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关在WildFly中配置Hibernate ORM和Hibernate Search的更多信息，请参见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide">WildFly JPA参考指南</a> ；</p>
</li>
<li>
<p><a href="https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide#JPAReferenceGuide-UsingHibernateSearch">有关Hibernate Search的特定部分</a> 。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hibernatesearch-jboss-modules-feature-packs"><a class="anchor" href="#hibernatesearch-jboss-modules-feature-packs"></a> 3.10.3。Hibernate Search WildFly / JBoss功能包列表</h4>
<div class="sect4">
<h5 id="_engine_feature_pack"><a class="anchor" href="#_engine_feature_pack"></a>引擎功能包</h5>
<div class="paragraph">
<p>此功能包包括所有主要模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>org.hibernate.search.engine</em> ，用于依赖于内部索引引擎的项目，这些项目不需要Hibernate的其他依赖项。</p>
</li>
<li>
<p><em>org.hibernate.search.backend-jms</em> ，以防您要使用<a href="#search-architecture-jms">JMS Architecture中</a>描述的JMS后端。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还包括其他几个模块，但是您无需直接参考其他模块。</p>
</div>
<div class="paragraph">
<p>该功能包以<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-engine~{hibernateSearchVersion}~~">org.hibernate：hibernate-search-jbossmodules-engine：5.11.4的形式发布在JBoss Nexus资源库和Maven Central中</a><a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-engine~{hibernateSearchVersion}~~">。最终：zip</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_jgroups_feature_pack"><a class="anchor" href="#_jgroups_feature_pack"></a> JGroups功能包</h5>
<div class="paragraph">
<p>该功能包包括模块<em>org.hibernate.search.backend-jgroups</em> ，以使用<a href="#search-architecture-jgroups">JGroups Architecture中</a>描述的JGroups后端。</p>
</div>
<div class="paragraph">
<p>该功能包以<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-backend-jgroups~{hibernateSearchVersion}~~">org.hibernate：hibernate-search-jbossmodules-orm：5.11.4的形式发布在JBoss Nexus资源库和Maven Central中</a><a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-backend-jgroups~{hibernateSearchVersion}~~">。最终：zip</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_orm_feature_pack"><a class="anchor" href="#_orm_feature_pack"></a> ORM功能包</h5>
<div class="paragraph">
<p>该功能包包括以下模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>org.hibernate.search.orm</em> ，适用于使用Hibernate ORM的Hibernate Search用户。</p>
</li>
<li>
<p><em>org.hibernate.search.jsr352</em> ，以使用JSR-352集成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该功能包以<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-orm~{hibernateSearchVersion}~~">org.hibernate：hibernate-search-jbossmodules-orm：5.11.4的形式发布在JBoss Nexus资源库和Maven Central中</a><a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-orm~{hibernateSearchVersion}~~">。最终：zip</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_elasticsearch_feature_pack"><a class="anchor" href="#_elasticsearch_feature_pack"></a> Elasticsearch功能包</h5>
<div class="paragraph">
<p>该功能部件包包括模块<em>org.hibernate.search.elasticsearch</em> ，以使用Elasticsearch集成。</p>
</div>
<div class="paragraph">
<p>该功能包以<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-elasticsearch~{hibernateSearchVersion}~~">org.hibernate：hibernate-search-jbossmodules-elasticsearch：5.11.4的形式发布在JBoss Nexus存储库和Maven Central上</a><a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-elasticsearch~{hibernateSearchVersion}~~">。最终：zip</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_elasticsearch_aws_feature_pack"><a class="anchor" href="#_elasticsearch_aws_feature_pack"></a> Elasticsearch-AWS功能包</h5>
<div class="paragraph">
<p>该软件包包括一个内部模块，该模块在连接到Elasticsearch集群时启用<a href="#elasticsearch-integration-configuration-aws">AWS身份验证机制</a> 。</p>
</div>
<div class="paragraph">
<p>该功能包以<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-elasticsearch~{hibernateSearchVersion}~~">org.hibernate：hibernate-search-jbossmodules-elasticsearch-aws：5.11.4的形式发布在JBoss Nexus资源库和Maven Central上</a><a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-jbossmodules-elasticsearch~{hibernateSearchVersion}~~">。最终：zip</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_more_about_modules"><a class="anchor" href="#_more_about_modules"></a> 3.10.4。有关模块的更多信息</h4>
<div class="paragraph">
<p>有关WildFly中模块配置的更多信息<a href="https://docs.jboss.org/author/display/WFLY/Class+Loading+in+WildFly">，请参见WildFly</a> Wiki中的“ <a href="https://docs.jboss.org/author/display/WFLY/Class+Loading+in+WildFly">类加载”</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>模块化类加载也是JBoss EAP 7的功能，但是，如果您使用的是JBoss EAP，那么您会读错用户指南！JBoss EAP订阅包括对Hibernate Search的官方支持，并附带专门针对EAP用户量身定制的本指南的不同版本。</p>
</div>
<div class="paragraph">
<p>请参阅《 <a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html/development_guide/hibernate_search">Red Hat JBoss企业应用平台7开发指南》</a>的<a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html/development_guide/hibernate_search">第13章</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="modules-tika"><a class="anchor" href="#modules-tika"></a> 3.10.5。将Apache Tika和其他扩展与WildFly模块一起使用</h4>
<div class="paragraph">
<p>Apache Tika需要其他依赖项，具体取决于所需的媒体格式。由于将您可能需要的所有可能扩展都打包到Hibernate Search模块中是不切实际的，因此我们让用户自行定义“ org.apache.tika”模块，在其中可以添加您可能需要的任何扩展。</p>
</div>
<div class="paragraph">
<p>这个版本的Hibernate Search需要Apache Tika版本<code>1.4</code>因此模块应定义为：</p>
</div>
<div class="exampleblock">
<div class="title">示例26。定制Tika模块的示例定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;module xmlns="urn:jboss:module:1.1" name="org.apache.tika" slot="1.4"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在模块中包括Apache Tika 1.4以及Tika可能需要的任何扩展和依赖项。</p>
</div>
<div class="paragraph">
<p>接下来，您还需要使您的应用程序也依赖于同一模块：</p>
</div>
<div class="exampleblock">
<div class="title">示例27要在您的应用程序中添加的清单头</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Dependencies: org.apache.tika:1.4</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_infinispan_with_hibernate_search_on_wildfly"><a class="anchor" href="#_using_infinispan_with_hibernate_search_on_wildfly"></a> 3.10.6。在WildFly上将Infinispan与Hibernate搜索结合使用</h4>
<div class="paragraph">
<p>如果您要按照上一段所述在WildFly中更新Hibernate Search的版本，则可能还需要更新Infinispan。流程非常相似：从<a href="http://infinispan.org/download/">Infinispan项目下载中下载</a>模块，选择兼容版本，然后将模块解压缩到<code>modules</code>您的WildFly安装目录。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-mapping"><a class="anchor" href="#search-mapping"></a> 4。将实体映射到索引结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="search-mapping-entity"><a class="anchor" href="#search-mapping-entity"></a> 4.1。映射实体</h3>
<div class="paragraph">
<p>在<a href="#getting-started">入门中，</a>您已经看到通过注释描述了索引实体所需的所有元数据信息。不需要XML映射文件。您仍然可以将Hibernate映射文件用于基本的Hibernate配置，但是特定于Hibernate Search的配置必须通过注释来表示。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search没有可用的XML配置，但是我们提供了一个程序化映射API，可以优雅地替代这种部署形式（有关更多信息，请参见<a href="#hsearch-mapping-programmaticapi">Programmatic API</a> ）。</p>
</div>
<div class="paragraph">
<p>如果您想贡献XML映射实现，请参阅<a href="https://hibernate.atlassian.net/browse/HSEARCH-210">HSEARCH-210</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="basic-mapping"><a class="anchor" href="#basic-mapping"></a> 4.1.1。基本映射</h4>
<div class="paragraph">
<p>让我们从映射实体时最常用的注释开始。</p>
</div>
<div class="sect4">
<h5 id="indexed-annotation"><a class="anchor" href="#indexed-annotation"></a> @索引</h5>
<div class="paragraph">
<p>首先，您必须通过使用注释类来将持久类声明为可索引的类<code>@Indexed.</code>所有未带注释的实体<code>@Indexed</code>将被索引过程忽略。</p>
</div>
<div class="exampleblock">
<div class="title">示例28。使类可索引<code>@Indexed</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Essay {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以选择指定<code>Indexed.index</code>属性以更改索引的默认名称。有关索引命名的更多信息，请参见<a href="#search-configuration-directory">目录配置</a> 。</p>
</div>
<div class="paragraph">
<p>您还可以指定一个可选的索引拦截器。有关更多信息，请参见<a href="#search-mapping-indexinginterceptor">条件索引</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="field-annotation"><a class="anchor" href="#field-annotation"></a> @领域</h5>
<div class="paragraph">
<p>对于实体的每个属性，您都可以描述是否以及如何对其进行索引。添加<code>@Field</code>批注将属性声明为已索引，并允许您配置索引过程的各个方面。不带<code>@Field</code>索引过程将忽略该属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search尝试确定将属性自动转换为可索引值的最佳方法。有关默认情况下如何转换属性值的更多信息，请参见<a href="#section-built-in-bridges">内置桥</a> 。 <code>bridge</code>的属性<code>@Field</code>下面的注释，以获取有关如何自定义转化的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下属性<code>@Field</code>注释可帮助您控制索引结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code> ：描述属性应以哪种名称存储在Lucene文档中。缺省值是遵循JavaBeans约定的属性名称（特别是将其去大写）。</p>
</li>
<li>
<p><a id="field-annotation-store"></a><code>store</code> ：描述属性是否存储在Lucene索引中。您可以存储值<code>Store.YES</code> （在索引中占用更多空间，但允许<a href="#projections">投影</a> ），以压缩方式存储<code>Store.COMPRESS</code> （这会消耗更多的CPU），或者避免任何存储空间<code>Store.NO</code> （这是默认值）。存储属性后，可以从Lucene文档中检索其原始值。存储属性不会影响该值是否可搜索。</p>
</li>
<li>
<p><code>index</code> ：描述是否对属性建立索引。不同的值是<code>Index.NO</code> （无索引，这意味着查询无法找到该值）， <code>Index.YES</code> （该元素被索引并且可以搜索）。默认值为<code>Index.YES</code> 。 <code>Index.NO</code>在不要求属性可搜索但需要投影的情况下很有用。</p>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Index.NO</code>与...结合<code>Analyze.YES</code>要么<code>Norms.YES</code>这是没有用的，因为分析和规范要求对属性进行索引</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><code>analyze</code> ：确定是否分析属性（ <code>Analyze.YES</code> ） 或不 （ <code>Analyze.NO</code> ）。默认值为<code>Analyze.YES</code> 。</p>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>是否要分析属性取决于您是按原样还是按包含的单词搜索元素。分析文本字段很有意义，但可能不分析日期字段。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>不得</em>分析用于构面的字段。</p>
</div>
<div class="paragraph">
<p><em>可以</em>对用于排序的字段进行分析，但<em>不能</em>将其标记化，因此您应该在这些字段上使用<a href="#section-normalizers">归一化器</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><a id="field-annotation-norms"></a><code>norms</code> ：描述是否应存储索引时间评分信息（ <code>Norms.YES</code> ） 或不 （ <code>Norms.NO</code> ）。不存储规范可以节省大量内存，但是在这种情况下（特别是）索引时间提升将不可用。默认值为<code>Norms.YES</code> 。</p>
</li>
<li>
<p><code>termVector</code> ：描述术语-频率对的集合。通过此属性，可以在建立索引期间将术语向量存储在文档中。默认值为<code>TermVector.NO</code> 。</p>
<div class="paragraph">
<p>此属性的不同值是：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.YES</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储每个文档的术语向量。这将产生两个同步的数组，一个包含文档术语，另一个包含术语的频率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.NO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不要存储术语向量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_OFFSETS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储术语向量和令牌偏移量信息。这和<code>TermVector.YES</code>加上它包含这些术语的开始和结束偏移位置信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_POSITIONS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储术语向量和令牌位置信息。这和<code>TermVector.YES</code>加上它包含文档中每个术语出现的顺序位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_POSITION_OFFSETS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储术语向量，令牌位置和偏移信息。这是<code>YES</code> ， <code>WITH_OFFSETS</code>和<code>WITH_POSITIONS</code> 。</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a id="field-annotation-indexNullAs"></a><code>indexNullAs</code> ：默认情况下，空值将被忽略并且不会被索引。但是，使用<code>indexNullAs</code>您可以指定一个字符串，该字符串将作为空值的令牌插入。默认情况下，此值设置为<code>org.hibernate.search.annotations.Field.DO_NOT_INDEX_NULL</code>指示不应索引空值。您可以将此值设置为<code>DEFAULT_NULL_TOKEN</code>指示应使用默认的空令牌。可以在配置中使用以下指定默认的空令牌<code>hibernate.search.default_null_token</code> 。如果未设置此属性，则字符串<code>_null_</code>将用作默认值。当字段为数字类型（请参阅<a href="#numeric-field-annotation">@NumericField</a> ）时，令牌将被编码为相应的数字类型： <code>indexNullAs</code>需要将value设置为一个可以解析为匹配类型的数字的值，例如“ -1”。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>什么时候<code>indexNullAs</code>使用时，在搜索查询中使用所选的空标记（请参阅<a href="#search-query">Querying</a> ）以找到空值很重要。还建议仅对未分析的字段使用此功能（ <code>analyze=Analyze.NO</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实施自定义时<code>FieldBridge</code>要么<code>TwoWayFieldBridge</code>由开发人员决定是否处理空值的索引（请参阅JavaDocs of <code>LuceneOptions.indexNullAs()</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><code>boost</code> ：请参阅有关<a href="#section-boosting">增强的</a>部分</p>
</li>
<li>
<p><code>bridge</code> ：请参阅有关<a href="#section-custom-bridges">场桥的</a>部分</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="numeric-field-annotation"><a class="anchor" href="#numeric-field-annotation"></a> @NumericField</h5>
<div class="paragraph">
<p><code>@NumericField</code>是一个伴随注释<code>@Field</code> 。可以在与以下相同的范围内指定<code>@Field</code> ，但仅适用于数字类型的属性，例如byte，short，int，long，double和float（以及它们各自的Java包装器类型）。它允许定义一个自定义<code>precisionStep</code>用于属性值的数字编码。</p>
</div>
<div class="paragraph">
<p><code>@NumericField</code>接受以下参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forField</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（可选）指定相关名称<code>@Field</code>将以数字方式索引。仅当该属性包含多个<code>@Field</code>宣言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>precisionStep</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（可选）更改Trie结构在索引中的存储方式。较小的<code>precisionSteps</code>导致更多的磁盘空间使用和更快的范围和排序查询。较大的值导致使用的空间更少，并且范围查询性能更接近于使用字符串编码的范围查询。预设值为4。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Lucene支持数字类型： <code>Double</code> ， <code>Long</code> ， <code>Integer</code>和<code>Float</code> 。对于类型的属性<code>Byte</code>和<code>Short</code> ， <code>Integer</code>字段将用于索引。其他数字类型应使用默认的字符串编码（通过<code>@Field</code> ），除非应用程序可以处理潜在的精度损失，否则在这种情况下， <code>TwoWayFieldBridge</code>可以使用。请参阅为以下主题<a href="#example-custom-numericfieldbridge">定义自定义FieldBridge： <code>BigDecimal</code></a> 。</p>
</div>
<div id="example-custom-numericfieldbridge" class="exampleblock">
<div class="title">示例29。为以下项定义自定义FieldBridge<code>BigDecimal</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BigDecimalNumericFieldBridge implements TwoWayFieldBridge {

    private static final BigDecimal storeFactor = BigDecimal.valueOf( 100 );

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        if ( value != null ) {
            BigDecimal decimalValue = (BigDecimal) value;
            Long indexedValue = decimalValue.multiply( storeFactor ).longValue();
            luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
        }
    }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

    @Override
    public String objectToString(Object object) {
        return object.toString();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您将使用此自定义桥，如<a href="#example-useof-custom-numericfieldbridge">使用中</a>所见<a href="#example-useof-custom-numericfieldbridge"><code>BigDecimalNumericFieldBridge</code></a> 。在这种情况下，使用了三个注释- <code>@Field</code> ， <code>@NumericField</code>和<code>@FieldBridge</code> 。 <code>@Field</code>需要标记要索引的属性（独立<code>@NumericField</code>绝对不允许）。</p>
</div>
<div id="example-useof-custom-numericfieldbridge" class="exampleblock">
<div class="title">示例30用于<code>BigDecimalNumericFieldBridge</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Item {
    @Id
    @GeneratedValue
    private int id;

    @Field
    @NumericField
    @FieldBridge(impl = BigDecimalNumericFieldBridge.class)
    private BigDecimal price;

    public int getId() {
        return id;
    }

    public BigDecimal getPrice() {
       return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另外，您可以通过执行以下操作直接从网桥中定义此字段的类型<code>MetadataProvidingFieldBridge</code> ，如为<a href="#example-useof-custom-numericfieldbridge-metadataproviding">定义自定义FieldBridge中所示<code>BigDecimal</code>和实施<code>MetadataProvidingFieldBridge</code></a>然后<code>@NumericField</code>使用网桥时，不再需要注释。</p>
</div>
<div id="example-useof-custom-numericfieldbridge-metadataproviding" class="exampleblock">
<div class="title">示例31。为以下项定义自定义FieldBridge <code>BigDecimal</code>和实施<code>MetadataProvidingFieldBridge</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BigDecimalNumericFieldBridge implements MetadataProvidingFieldBridge, TwoWayFieldBridge {

    private static final BigDecimal storeFactor = BigDecimal.valueOf( 100 );

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        if ( value != null ) {
            BigDecimal decimalValue = (BigDecimal) value;
            Long indexedValue = decimalValue.multiply( storeFactor ).longValue();
            luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
        }
    }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

    @Override
    public String objectToString(Object object) {
        return object.toString();
    }

    @Override
    public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
        builder.field( name, FieldType.LONG );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>MetadataProvidingFieldBridge</code>该合同正在积极开发中，目前还处于试验阶段。在将来的修订版中可能会对其进行更改，例如通过添加其他方法，从而破坏现有的实现。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sortablefield-annotation"><a class="anchor" href="#sortablefield-annotation"></a> @SortableField</h5>
<div class="paragraph">
<p>从Lucene 5（以及Hibernate Search 5.5）开始，强烈建议为要排序的每个字段创建一个所谓的“文档值字段”。Hibernate Search提供了<code>@SortableField</code>为此目的的注释。这是对的扩展注释<code>@Field</code>并将一个字段标记为可排序（内部，所需的doc值字段将添加到索引中）。</p>
</div>
<div id="example-useof-sortablefield" class="exampleblock">
<div class="title">示例32用于<code>@SortableField</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Book {

    @Id
    @GeneratedValue
    private int id;

    @Field(name="Abstract", analyze=Analyze.NO)
    @SortableField
    private String summary;

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果有一个<code>@Field</code>声明给定的财产， <code>@SortableField</code>隐式适用于此字段。如果单个属性存在多个字段，则<code>@Field</code>可以通过以下方式指定要标记为可排序<code>@SortableField#forField()</code> 。可以将几个可排序字段定义为<code>@SortableField</code>注释是可重复的。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>标记为可排序的字段不得标记，因此您应禁用对此字段的分析或使用<a href="#section-normalizers">规范化器</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，如果未显式标记属性，则排序也适用<code>@SortableField</code> 。但是，这会对运行时性能和内存消耗产生负面影响。因此，强烈建议明确标记要用于排序的每个字段。</p>
</div>
<div class="paragraph">
<p>如果您想让一个属性可排序但不可搜索，仍然可以<code>@Field</code>需要声明（以便其场桥配置可以被继承）。可以用<code>store = Store.NO</code>和<code>index = Index.NO</code> ，仅导致添加排序所需的doc值字段，而不添加常规索引字段。</p>
</div>
<div class="paragraph">
<p><a id="metadata-providing-field-bridge"></a>通过类级别桥或自定义字段级别桥添加的字段（不使用默认字段名称时）不能通过以下方式标记为可排序<code>@SortableField</code>注解。相反，字段桥本身除了要添加的文档字段外，还必须添加必需的doc值字段。此外，这种桥梁需要实施<code>MetadataProvidingFieldBridge</code>定义方法的接口<code>configureFieldMetadata()</code>用于将该桥创建的字段标记为可排序的：</p>
</div>
<div id="example-adding-docvaluefield" class="exampleblock">
<div class="title">例子33。通过自定义字段桥将字段标记为可排序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/***
  * Custom field bridge for a Map property which creates sortable fields
  * with the values of two keys from the map.
  */
public class MyClassBridge implements MetadataProvidingFieldBridge {

  @Override
  public void set(String name, Object value,
          Document document, LuceneOptions luceneOps) {

      Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) value;

      String firstName = map.get( "firstName" );
      String lastName = map.get( "lastName" );

      // add regular document fields
      luceneOps.addFieldToDocument( name + "_firstName", lastName, document );
      luceneOps.addFieldToDocument( name + "_lastName", lastName, document );

      // add doc value fields to allow for sorting
      document.addSortedDocValuesFieldToDocument( name + "_firstName", firstName );
      document.addSortedDocValuesFieldToDocument( name + "_lastName", lastName );
  }

  @Override
  public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
      builder
          .field( name + "_firstName", FieldType.STRING )
              .sortable( true )
          .field( name + "_lastName", FieldType.STRING )
              .sortable( true );
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过以下方式配置的元数据<code>configureFieldMetadata()</code>将在查询执行时用于排序验证。传递给方法的名称是默认字段名称，也传递给<code>set()</code> 。它需要与<code>set()</code> ，例如作为所有添加的自定义字段的前缀。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>MetadataProvidingFieldBridge</code>该合同正在积极开发中，目前还处于试验阶段。在将来的修订版中可能会对其进行更改，例如通过添加其他方法，从而破坏现有的实现。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="flagging-uncovered-sorts"><a class="anchor" href="#flagging-uncovered-sorts"></a>标记发现的排序</h6>
<div class="paragraph">
<p>默认情况下，当运行查询时，如上文所述配置的可排序字段未涵盖的排序，Hibernate Search将引发异常。</p>
</div>
<div class="paragraph">
<p>因此，您可以选择建议Hibernate Search在检测到未发现的排序时透明地创建同相索引读取器。请注意，尽管这允许执行查询，但依赖于索引不变不会对性能产生负面影响。</p>
</div>
<div class="paragraph">
<p>为此，请指定以下选项：</p>
</div>
<div class="exampleblock">
<div class="title">示例34对未发现的排序启用自动索引反转</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.index_uninverting_allowed = true</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，您可以将其保留为默认值（ <code>false</code> ），以识别查询所需的可排序字段并将其设置为<code>true</code>在生产环境中，由于偶然遗留的未发现的种类而退回到索引不变。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="id-annotation"><a class="anchor" href="#id-annotation"></a>文件识别码：@DocumentId或@Id</h5>
<div class="paragraph">
<p>最后，文档标识符是Hibernate Search使用的特殊字段，以确保索引中每个实体永远只有一个文档，并在应删除文档时标识它们。通过设计，必须存储文档标识符，并且不能将其标记。即使id是数字，它也始终是字符串编码的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>我们强烈建议避免对id字段进行排序，因为这会导致行为不稳定。如果您想对文档ID进行排序，建议您声明另一个字段，专门用于使用<code>@Field</code>注解。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用JPA，并且使用<code>@Id</code> ，默认情况下，Hibernate Search会将这个实体标识符用作文档标识符。
<a href="#example-document-id-default-orm">将ORM实体标识符用作文档标识符可</a>利用以下优势： <code>@Id</code>注释：文档标识符将是<code>id</code>属性。</p>
</div>
<div id="example-document-id-default-orm" class="exampleblock">
<div class="title">示例35使用ORM实体标识符作为文档标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Essay {
    ...

    @Id
    public Long getId() { return id; }

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不使用JPA，或者需要将文档ID设置为实体ID以外的其他属性，则可以使用<code>@DocumentId</code>注解。此注释还允许显式设置文档标识符字段名称。
<a href="#example-document-id-explicit">明确指定文档标识符可</a>利用<code>@DocumentId</code>注释：文档标识符将从<code>orderNumber</code>属性并存储到<code>id_order_number</code>领域。</p>
</div>
<div id="example-document-id-explicit" class="exampleblock">
<div class="title">示例36。明确指定文档标识符</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Order {
    ...

    @Id
    @GeneratedValue
    public Long getId() { return id; }

    @DocumentId(name = "id_order_number")
    @NaturalId
    public String orderNumber;

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_supported_identifier_types"><a class="anchor" href="#_supported_identifier_types"></a>支持的标识符类型</h6>
<div class="paragraph">
<p>默认情况下，Hibernate Search可以处理“ <a href="#section-built-in-bridges">内置桥”</a>部分提到的任何类型的文档标识符。对于这些类型，除了使用来选择属性外，您无需做其他任何事情。 <code>@Id</code>要么<code>@DocumentId</code> 。</p>
</div>
<div class="paragraph">
<p>如果您的标识符具有其他类型，例如因为您使用的是JPA <code>@EmbeddedId</code> ，您将必须编写一个自定义的双向桥，并使用<code>@FieldBridge</code>注释在您的财产上， <a href="#section-two-way-bridge">如下文所述</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fields-annotation"><a class="anchor" href="#fields-annotation"></a> 4.1.2。多次映射属性</h4>
<div class="paragraph">
<p>有时，每个索引必须多次映射一个属性，而索引策略略有不同。例如，按字段对查询进行排序要求不对字段进行分析。如果要在该属性中按单词搜索并仍然对其进行排序，则需要对它进行两次索引-一次被分析并且一次未被分析。的<code>@Field</code>是可重复的，允许实现此目标。或者，您可以使用传统的显式复数形式<code>@Fields</code> 。</p>
</div>
<div id="example-fields-annotation" class="exampleblock">
<div class="title">示例37。使用<code>@Field</code>反复多次映射属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(index = "Book")
public class Book {

    @Field
    @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
    @SortableField(forField = "summary_forSort")
    public String getSummary() {
        return summary;
    }

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#example-fields-annotation">使用中<code>@Field</code>重复地多次映射属性</a> <code>summary</code>被索引两次，一次为<code>summary</code>以标记化的方式<code>summary_forSort</code>以一种没有标记的方式。
<code>@Field</code>支持两个属性，在重复注释时这些属性特别有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>analyzer</code> ：定义一个<code>@Analyzer</code>每个字段而不是每个属性的注释</p>
</li>
<li>
<p><code>normalizer</code> ：定义一个<code>@Normalizer</code>给定字段的注释，而不是分析器。
<code>analyzer</code>和<code>normalizer</code>是互斥的：您只能使用两者之一。</p>
</li>
<li>
<p><code>bridge</code> ：定义一个<code>@FieldBridge</code>每个字段而不是每个属性的注释</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关分析器/归一化器和场桥的更多信息，请参见下文。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-mapping-associated"><a class="anchor" href="#search-mapping-associated"></a> 4.1.3。嵌入式和关联对象</h4>
<div class="paragraph">
<p>关联的对象以及嵌入的对象都可以作为根实体索引的一部分进行索引。如果您希望根据关联对象的属性搜索给定的实体，这将很有用。</p>
</div>
<div class="paragraph">
<p>在示例<a href="#example-indexing-associations">索引关联中</a> ，目标是返回关联城市为亚特兰大的地方（以Lucene查询解析器语言，它将转换为<code>address.city:Atlanta</code> ）。所有地点字段均已添加到<code>Place</code>索引，还有地址相关字段<code>address.street</code>和<code>address.city</code>将被添加并使其可查询。嵌入式对象ID， <code>address.id</code> ，默认情况下不会添加。要包含它，您还需要设置<code>@IndexedEmbedded(includeEmbeddedObjectId=true, …​)</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅实际的索引字段（用注释的属性<code>@Field</code>索引嵌入的对象时，）被添加到根实体索引中。嵌入式对象标识符的处理方式有所不同，需要明确地包括在内。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="example-indexing-associations" class="exampleblock">
<div class="title">示例38。索引关联</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;
    ....
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>小心。由于使用时，数据会在Lucene索引中被反规范化<code>@IndexedEmbedded</code>技术，Hibernate Search需要知道<code>Place</code>对象和任何变化<code>Address</code>对象以保持索引为最新。为了确保<code>Place</code> Lucene文档在其更新时<code>Address</code>更改时，您需要用标记双向关系的另一端<code>@ContainedIn</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@ContainedIn</code>在指向实体的关联和嵌入式（集合）对象上都是有用的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>让我们通过嵌套使<a href="#example-indexing-associations">索引关联</a>更加复杂<code>@IndexedEmbedded</code>如<a href="#example-nested-index-embedded">嵌套使用<code>@IndexedEmbedded</code>和<code>@ContainedIn</code></a> 。</p>
</div>
<div id="example-nested-index-embedded" class="exampleblock">
<div class="title">示例39。的嵌套用法<code>@IndexedEmbedded</code>和<code>@ContainedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_")
    private Owner ownedBy;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public class Owner {
    @Field
    private String name;
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，任何<code>@*ToMany</code> ， <code>@*ToOne</code>要么<code>@Embedded</code>属性可以用<code>@IndexedEmbedded</code> 。然后，关联类的属性将添加到主实体索引中。在<a href="#example-nested-index-embedded">嵌套使用中<code>@IndexedEmbedded</code>和<code>@ContainedIn</code></a>索引将包含以下字段</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>address.street</code></p>
</li>
<li>
<p><code>address.city</code></p>
</li>
<li>
<p><code>address.ownedBy_name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认前缀是<code>propertyName.</code> ，遵循传统的对象导航约定。您可以使用<code>prefix</code>属性显示在<code>ownedBy</code>属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>前缀不能设置为空字符串。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>depth</code>当对象图包含类（而非实例）的循环依赖关系时，此属性是必需的。例如，如果<code>Owner</code>指着<code>Place</code> 。达到预期深度（或达到对象图边界）后，Hibernate Search将停止包含索引的嵌入式属性。具有自引用的类是循环依赖的一个示例。在我们的示例中，因为<code>depth</code>设置为1，任何<code>@IndexedEmbedded</code>归因于<code>Owner</code> （如果有）将被忽略。</p>
</div>
<div class="paragraph">
<p>使用<code>@IndexedEmbedded</code> for对象关联允许您表达查询（使用Lucene的查询语法），例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>返回名称包含JBoss且地址城市为Atlanta的地方。在Lucene查询中，这将是</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>+name:jboss +address.city:atlanta</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>返回名称包含JBoss且所有者名称包含Joe的地方。在Lucene查询中，这将是</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>+name:jboss +address.ownedBy_name:joe</pre>
</div>
</div>
<div class="paragraph">
<p>在某种程度上，它以更有效的方式模仿关系联接操作（以数据复制为代价）。请记住，Lucene索引开箱即用，没有关联的概念，联接操作根本不存在。受益于全文索引速度和功能丰富性，这可能有助于保持关系模型正常化。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关联对象本身可以（但不一定）是<code>@Indexed</code></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>什么时候<code>@IndexedEmbedded</code>指向一个实体，关联必须是双向的，另一端必须带有注释<code>@ContainedIn</code> 。否则，当关联的实体更新时，Hibernate Search无法更新根索引（在我们的示例中， <code>Place</code>关联时，索引文件必须更新<code>Address</code>实例已更新）。</p>
</div>
<div class="paragraph">
<p>有时，用注释的对象类型<code>@IndexedEmbedded</code>不是Hibernate和Hibernate Search定位的对象类型。当使用接口代替其实现时，尤其如此。因此，您可以使用来覆盖Hibernate Search定位的对象类型<code>targetElement</code>参数。</p>
</div>
<div class="exampleblock">
<div class="title">示例40使用<code>targetElement</code>的财产<code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", targetElement = Owner.class)
    @Target(Owner.class)
    private Person ownedBy;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public class Owner implements Person { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="search-mapping-associated-viapaths"><a class="anchor" href="#search-mapping-associated-viapaths"></a>限制对象嵌入到特定路径</h5>
<div class="paragraph">
<p>的<code>@IndexedEmbedded</code>注释还提供了一个属性<code>includePaths</code>可以用来替代<code>depth</code> ，或与其结合使用。</p>
</div>
<div class="paragraph">
<p>仅在使用时<code>depth</code>嵌入类型的所有索引字段将以相同的深度递归添加；这使得仅选择特定路径而不同时不添加所有其他字段变得更加困难，而这可能是不必要的。</p>
</div>
<div class="paragraph">
<p>为了避免不必要地加载和索引实体，您可以精确指定所需的路径。典型的应用程序可能需要不同深度的不同路径，或者换句话说，它可能需要明确指定路径，如<a href="#indexedembedded-includePath">使用指南中所示。 </a><a href="#indexedembedded-includePath"><code>includePaths</code>的财产<code>@IndexedEmbedded</code></a></p>
</div>
<div id="indexedembedded-includePath" class="exampleblock">
<div class="title">示例41。使用<code>includePaths</code>的财产<code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(includePaths = { "name" })
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

   // ... other fields omitted</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用映射中的<a href="#indexedembedded-includePath">使用</a>映射<a href="#indexedembedded-includePath"><code>includePaths</code>的财产<code>@IndexedEmbedded</code></a> ，您将可以搜索<code>Person</code>通过<code>name</code>和/或<code>surname</code>和/或<code>name</code>父母的它不会索引<code>surname</code> ，因此无法搜索父母的姓氏，但可以加快索引编制，节省空间并提高整体性能。</p>
</div>
<div class="paragraph">
<p>的<code>@IndexedEmbedded.includePaths</code> <em>除了</em>您通常会为深度指定极限值的索引<em>之外，</em>还将包括指定的路径。使用<code>includePaths</code>具有未定义（默认）的值<code>depth</code>相当于设置<code>depth=0</code> ：仅索引包含的路径。</p>
</div>
<div id="indexedembedded-includePathsAndDepth" class="exampleblock">
<div class="title">示例42。使用<code>includePaths</code>的财产<code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    // ... other fields omitted</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#indexedembedded-includePathsAndDepth">使用<code>includePaths</code>的财产<code>@IndexedEmbedded</code></a> ，每个人都将为其姓名和姓氏属性建立索引。父母的名字和姓氏也会被索引，因为<code>depth</code>属性。可以通过姓名或姓氏直接搜索此人，其父母或祖父母。除了第二级，我们还将另外索引一个级别，但仅索引名称，而不是姓氏。</p>
</div>
<div class="paragraph">
<p>这将在索引中产生以下字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> -作为主键</p>
</li>
<li>
<p><code>_hibernate_class</code> -存储实体类型</p>
</li>
<li>
<p><code>name</code> -作为直接领域</p>
</li>
<li>
<p><code>surname</code> -作为直接领域</p>
</li>
<li>
<p><code>parents.name</code> -作为深度1处的嵌入式字段</p>
</li>
<li>
<p><code>parents.surname</code> -作为深度1处的嵌入式字段</p>
</li>
<li>
<p><code>parents.parents.name</code> -作为深度2的嵌入式字段</p>
</li>
<li>
<p><code>parents.parents.surname</code> -作为深度2的嵌入式字段</p>
</li>
<li>
<p><code>parents.parents.parents.name</code> -作为includePaths指定的附加路径。首先<code>parents.</code>从字段名称推断，其余路径是includePaths的属性</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用显式包含嵌入对象的ID <code>includePath</code> ， 例如<code>@IndexedEmbedded(includePaths = { "parents.id" })</code> 。不管<code>includeEmbeddedObjectId</code>属性。但是，建议只设置<code>includeEmbeddedObjectId=true</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果通过先定义所需的查询来设计应用程序，则对索引路径的显式控制可能会更容易，因为到那时，您可能确切地知道需要哪些字段，以及哪些其他字段对于实现用例而言是不必要的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_indexing_null_embeddeds"><a class="anchor" href="#_indexing_null_embeddeds"></a>索引空嵌入</h5>
<div class="paragraph">
<p>默认情况下，空值将被忽略并且不会被索引。但是，使用<code>indexNullAs</code>您可以指定当嵌入为null时，应添加一个具有您选择的值的字段。</p>
</div>
<div class="paragraph">
<p>默认情况下<code>indexNullAs</code>被设定为<code>org.hibernate.search.annotations.IndexedEmbedded.DO_NOT_INDEX_NULL</code> ，指示不应索引空值。您可以将此值设置为<code>IndexedEmbedded.DEFAULT_NULL_TOKEN</code>指示应使用默认的空令牌。可以在配置中使用以下指定默认的空令牌<code>hibernate.search.default_null_token</code> 。如果未设置此属性，则字符串<code>_null_</code>将用作默认值。</p>
</div>
<div class="paragraph">
<p>索引空值时使用的字段名称取决于<code>prefix</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果<code>prefix</code>未设置，字段名称将为Java属性名称</p>
</li>
<li>
<p>如果<code>prefix</code>设置后，字段名称将是前缀，并删除尾随点（如果有）。例如带有前缀<code>my_embedded.</code> ，空字段名称将为<code>my_embedded</code> （不带点）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>什么时候<code>indexNullAs</code>使用时，在搜索查询中使用所选的空标记（请参阅<a href="#search-query">Querying</a> ）以找到空值很重要。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_associated_objects_building_a_dependency_graph_with_containedin"><a class="anchor" href="#_associated_objects_building_a_dependency_graph_with_containedin"></a> 4.1.4。关联对象：使用@ContainedIn构建依赖关系图</h4>
<div class="paragraph">
<p>而<code>@ContainedIn</code>通常被视为<code>@IndexedEmbedded</code> ，也可以单独使用它来建立索引依赖图。</p>
</div>
<div class="paragraph">
<p>重新为实体建立索引后，由指向的所有实体<code>@ContainedIn</code>也将重新编制索引。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-boosting"><a class="anchor" href="#section-boosting"></a> 4.2。助推</h3>
<div class="paragraph">
<p>Lucene具有<em>增强</em>的概念，该概念使您可以赋予某些文档或字段比其他文档或字段更多或更少的重要性。Lucene区分索引和搜索时间的增加。以下各节向您展示如何使用Hibernate Search实现索引时间提升。</p>
</div>
<div class="sect3">
<h4 id="section-boost-annotation"><a class="anchor" href="#section-boost-annotation"></a> 4.2.1。静态索引时间提升</h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用索引时间提升：自版本7起，将在Apache Lucene中删除对这种方法的支持。</p>
</div>
<div class="paragraph">
<p>我们建议改为使用查询时间提升：请参阅<a href="#search-query">查询</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要为索引的类或属性定义静态提升值，可以使用<code>@Boost</code>注解。您可以在<code>@Field</code>或直接在方法或类级别上指定它。</p>
</div>
<div id="example-boost" class="exampleblock">
<div class="title">例子43。不同的使用方式<code>@Boost</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@Boost(1.7f)
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=@Boost(2f))
    @Boost(1.5f)
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=@Boost(1.2f))
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以<a href="#example-boost">不同的使用方式<code>@Boost</code></a> ，Essay到达搜索列表顶部的可能性将乘以1.7。摘要字段将为3.0（2 * 1.5，因为<code>@Field.boost</code>和<code>@Boost</code>财产上的累积）比<code>isbn</code>领域。文本字段的重要性将是文本字段的1.2倍<code>isbn</code>领域。请注意，从最严格的意义上讲，这种解释是错误的，但是对于所有实际目的而言，它都是简单且接近现实的。请查阅Lucene文档或Otis Gospodnetic和Erik Hatcher提供的出色的Lucene In Action。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-dynamic-boost"><a class="anchor" href="#section-dynamic-boost"></a> 4.2.2。动态索引时间提升</h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用索引时间提升：自版本7起，将在Apache Lucene中删除对这种方法的支持。</p>
</div>
<div class="paragraph">
<p>我们建议改为使用查询时间提升：请参阅<a href="#search-query">查询</a> 。</p>
</div>
<div class="paragraph">
<p>如果查询时间提升不足以满足您的用例，则可以使用<a href="#section-custom-similarity">自定义相似性</a> （高级用法）实现动态提升。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@Boost</code> <a href="#section-boost-annotation">静态索引时间提升中</a>使用的注释定义了静态提升因子，该因子与运行时索引实体的状态无关。但是，在某些情况下，提升因子可能取决于实体的实际状态。在这种情况下，您可以使用<code>@DynamicBoost</code>注释以及随附的自定义<code>BoostStrategy</code> 。</p>
</div>
<div id="example-dynamic-boosting" class="exampleblock">
<div class="title">例子44。动态升压示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public enum PersonType {
    NORMAL,
    VIP
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@DynamicBoost(impl = VIPBoostStrategy.class)
public class Person {
    private PersonType type;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class VIPBoostStrategy implements BoostStrategy {
    public float defineBoost(Object value) {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#example-dynamic-boosting">动态增强示例中，</a>在类级别定义了动态增强，指定<code>VIPBoostStrategy</code>作为实施<code>BoostStrategy</code>索引编制时使用的接口。您可以将<code>@DynamicBoost</code>无论是在班级还是在现场。根据注释的位置，整个实体都将传递给<code>defineBoost</code>方法或仅带注释的字段/属性值。由您决定将传递的对象转换为正确的类型。在该示例中，VIP人员的所有索引值将是普通人员的值的两倍。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指定的<code>BoostStrategy</code>实现必须定义一个公共的无参数构造函数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然可以混搭<code>@Boost</code>和<code>@DynamicBoost</code>您实体中的注释。所有定义的提升因子都是累积的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_analysis"><a class="anchor" href="#_analysis"></a> 4.3。分析</h3>
<div class="paragraph">
<p>分析是将文本转换为单个术语（单词）的过程，可以被视为全文搜索引擎的关键功能之一。Lucene使用分析器的概念来控制此过程。在以下部分中，我们介绍了Hibernate Search提供的多种配置分析器的方法。</p>
</div>
<div class="sect3">
<h4 id="analyzer"><a class="anchor" href="#analyzer"></a> 4.3.1。默认分析器和按类分类的分析器</h4>
<div class="paragraph">
<p>可通过以下方式配置用于索引标记化字段的默认分析器类： <code>hibernate.search.analyzer</code>属性。此属性的默认值为<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以按实体，属性甚至每个实体定义分析器类<code>@Field</code> （在从单个属性为多个字段建立索引时很有用）。</p>
</div>
<div class="exampleblock">
<div class="title">示例45@Analyzer的不同使用方式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@Analyzer(impl = EntityAnalyzer.class)
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    @Analyzer(impl = PropertyAnalyzer.class)
    private String summary;

    @Field(analyzer = @Analyzer(impl = FieldAnalyzer.class)
    private String body;

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中<code>EntityAnalyzer</code>用于索引所有标记化属性（例如<code>name</code> ）， 除<code>summary</code>和<code>body</code>被索引<code>PropertyAnalyzer</code>和<code>FieldAnalyzer</code>分别。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在大多数情况下，在同一实体中混合使用不同的分析器是一种不好的做法。它使查询的建立更加复杂，结果的可预测性（对于新手而言）尤其如此，如果您使用的是<code>QueryParser</code> （对于整个查询，它使用相同的分析器）。根据经验，对于任何给定的字段，应使用同一分析器进行索引和查询。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="section-named-analyzers"><a class="anchor" href="#section-named-analyzers"></a> 4.3.2。命名分析仪</h4>
<div class="paragraph">
<p>分析器可能变得非常复杂。因此，Hibernate Search引入了分析器定义的概念。分析器定义可以被许多人重用<code>@Analyzer</code>声明，由以下内容组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>名称：用于引用定义的唯一字符串</p>
</li>
<li>
<p>字符过滤器列表：每个字符过滤器负责在标记化之前预处理输入字符。字符过滤器可以添加，更改或删除字符；一种常见用法是字符归一化</p>
</li>
<li>
<p>标记器：负责将输入流标记为单个单词</p>
</li>
<li>
<p>过滤器列表：每个过滤器负责删除，修改甚至有时将单词添加到令牌生成器提供的流中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>任务的分离（一个char过滤器列表，一个标记器以及一个过滤器列表）使您可以轻松地重用每个组件，并使您以非常灵活的方式构建自定义的分析器（就像Lego一样）。一般来说，char过滤器会在字符输入中进行一些预处理，然后Tokenizer通过将字符输入转换为令牌来启动令牌化过程，然后由TokenFilters对其进行进一步处理。Hibernate Search通过利用Lucene提供的高级分析器来支持此基础结构。这通常称为分析器框架。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>过滤器和char过滤器按照分析器定义中提到的顺序应用。订单很重要！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些分析器和过滤器将需要其他依赖项。例如，要使用雪球茎，您还必须包括<code>lucene-snowball</code>罐子和<code>PhoneticFilterFactory</code>您需要<a href="http://commons.apache.org/codec">commons编解码器</a> jar。您的Hibernate Search发行版在其<em>lib / optional</em>目录中提供了这些依赖关系。看一下<a href="#table-available-tokenizers">可用标记</a> <a href="#table-available-filters">器的示例和可用过滤器的示例，</a>以查看哪些分析器和过滤器具有其他依赖性</p>
</div>
<div class="paragraph">
<p>在Hibernate Search 5之前，还需要将Apache Solr依赖项添加到您的项目中。这不再是必需的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_analyzer_definition_through_annotations"><a class="anchor" href="#_analyzer_definition_through_annotations"></a>通过注释定义分析器</h5>
<div class="paragraph">
<p>定义分析器的第一种方法是通过应用<code>@AnalyzerDef</code>索引类的注释。选择在哪个类上添加批注无关紧要：这些定义是全局范围的，因此您可以从任何实体映射中引用它们。</p>
</div>
<div class="paragraph">
<p>现在让我们看一个具体的示例- <a href="#example-analyzer-def">使用@AnalyzerDef批注的Analyzer定义</a> 。首先，char过滤器由其工厂定义。在我们的示例中，使用了一个映射char过滤器，它将根据映射文件中指定的规则替换输入中的字符。接下来定义一个标记器。本示例使用标准标记器。最后但并非最不重要的一点是，过滤器列表由其工厂定义。在我们的示例中，构建了StopFilter过滤器以读取专用单词属性文件。过滤器也应忽略大小写。</p>
</div>
<div id="example-analyzer-def" class="exampleblock">
<div class="title">示例46。使用@AnalyzerDef批注的分析器定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="section-programmatic-analyzer-definition"><a class="anchor" href="#section-programmatic-analyzer-definition"></a>程序分析器定义</h5>
<div class="paragraph">
<p>定义分析器的另一种方法是编程方式。您当然可以使用<a href="#hsearch-mapping-programmaticapi">程序化映射API</a>来这样做，但是更简单的方法可能是使用<code>hibernate.search.lucene.analysis_definition_provider</code>配置属性。</p>
</div>
<div class="paragraph">
<p>可以将该属性设置为应用程序中带有公共，无参数构造函数的类的完全限定名称。此类必须实现<code>org.hibernate.search.analyzer.definition.LuceneAnalysisDefinitionProvider</code>直接或暴露<code>@Factory</code> -带注释的方法，返回该实现。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此功能被认为是实验性的。特别是建造者将来可能会改变。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="example-programmatic-analyzer-def" class="exampleblock">
<div class="title">示例47使用LuceneAnalysisDefinitionProvider的分析器定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomAnalyzerProvider implements LuceneAnalysisDefinitionProvider {
    @Override
    public void register(LuceneAnalyzerDefinitionRegistryBuilder builder) {
        builder
                .analyzer( "myAnalyzer" )
                        .tokenizer( StandardTokenizerFactory.class )
                        .charFilter( MappingCharFilterFactory.class )
                                .param( "mapping", "org/hibernate/search/test/analyzer/mapping-chars.properties" )
                        .tokenFilter( ASCIIFoldingFilterFactory.class )
                        .tokenFilter( LowerCaseFilterFactory.class )
                        .tokenFilter( StopFilterFactory.class )
                                .param( "mapping", "org/hibernate/search/test/analyzer/stoplist.properties" )
                                .param( "ignoreCase", "true" );
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_referencing_named_analyzers"><a class="anchor" href="#_referencing_named_analyzers"></a>引用命名分析器</h5>
<div class="paragraph">
<p>定义后，分析器定义可以由<code>@Analyzer</code>如<a href="#example-referencing-analyzer-def">按名称引用分析器中</a>所示的声明。</p>
</div>
<div id="example-referencing-analyzer-def" class="exampleblock">
<div class="title">示例48通过名称引用分析器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field
    @Analyzer(definition = "customanalyzer")
    private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>分析器定义也可以通过名称在<code>SearchFactory</code>这在构建查询时非常有用。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询中的字段应使用与用于对该字段建立索引的分析器相同的分析器进行分析，以便它们说出一种通用的“语言”：在查询和索引编制过程之间重用相同的标记。该规则有一些例外，但大多数时候都是如此。尊重它，除非您知道自己在做什么。</p>
</div>
</div>
<div class="sect4">
<h5 id="section-normalizers"><a class="anchor" href="#section-normalizers"></a>规范化器</h5>
<div class="paragraph">
<p>当您需要在文本文档中进行搜索时，分析器非常有用，但是如果要对分析的文本进行排序怎么办？然后，您会有些麻烦，因为分析的文本是多值的：在为书名加上索引时<code>"Refactoring: Improving the Design of Existing Code"</code> ，则分析的标题实际上是（无序）集合<code>{"refactoring", "improving", "design", "existing", "code"}</code> 。如果您在进行此类分析后尝试对标题进行排序，则可以使用这些单词中的任何一个，因此您的书可能以D（由于“设计”）或R（因“重构”）而告终，或在E等中</p>
</div>
<div class="paragraph">
<p>因此，最后，您可能不希望在对这些字段进行排序时对字段进行标记。规范化工具正好解决了这个问题：它们是分析器，但没有标记器，并且带有一些运行时检查，阻止了分析产生多个标记，从而确保您的排序始终保持一致。</p>
</div>
<div class="paragraph">
<p>Hibernate Search为相关的分析器注释提供了等效的规范化器： <code>@Normalizer</code> ， <code>@NormalizerDef</code> ， <code>@NormalizerDefs</code> 。与分析器一样，您可以直接使用实现（例如<code>@Normalizer(impl = MyCollactionKeyAnalyzer.class)</code> ）或命名规范化器（例如<code>@Normalizer(definition = "myNormalizer")</code>与<code>@NormalizerDef(filters = @TokenFilterDef(factory = LowerCaseFilterFactory.class))</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您不能定义“类级别”，“属性级别”或“默认”规范化器：必须使用以下命令为每个需要规范化的字段明确分配规范化器<code>@Field.normalizer</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_available_analysis_components"><a class="anchor" href="#_available_analysis_components"></a>可用的分析组件</h5>
<div class="paragraph">
<p>Apache Lucene附带了许多有用的默认char过滤器，令牌生成器和过滤器。您可以在<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters中</a>找到char过滤器工厂，令牌生成器工厂和过滤器工厂的完整列表。让我们检查其中的一些。</p>
</div>
<table id="table-available-char-filters" class="tableblock frame-all grid-all spread">
<caption class="title">表11。可用字符过滤器的示例</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">厂</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">参量</th>
<th class="tableblock halign-left valign-top">其他依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根据资源文件中指定的映射，用一个或多个字符替换一个或多个字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapping</code> ：使用以下格式指向包含映射的资源文件：“á”⇒“ a”<br>“ñ”⇒“ n”<br>“ø”⇒“ o”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HTMLStripCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除HTML标准标签，保留文本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
</tbody>
</table>
<table id="table-available-tokenizers" class="tableblock frame-all grid-all spread">
<caption class="title">表12。可用令牌生成器的示例</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">厂</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">参量</th>
<th class="tableblock halign-left valign-top">其他依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StandardTokenizerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Lucene StandardTokenizer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HTMLStripCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除HTML标签，保留文本并将其传递给<code>StandardTokenizer</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternTokenizerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以指定的正则表达式模式中断文本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pattern</code> ：用于标记化的正则表达式</p>
<p class="tableblock">组：说出要提取到令牌中的模式组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
</tbody>
</table>
<table id="table-available-filters" class="tableblock frame-all grid-all spread">
<caption class="title">表13。可用过滤器的示例</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">厂</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">参量</th>
<th class="tableblock halign-left valign-top">其他依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StandardFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除缩写词中的点和单词中的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LowerCaseFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小写所有单词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StopFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除与停用词列表匹配的词（标记）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>words</code> ：指向包含停用词的资源文件</p>
<p class="tableblock"><code>ignoreCase</code> ：如果为true <code>case</code>比较停用词时应忽略， <code>false</code>除此以外</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SnowballPorterFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将给定语言的单词还原为词根。 （例如。保护，保护，保护共享同一根）。使用这样的过滤器允许搜索匹配相关词。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>language</code> ：丹麦文，荷兰文，英文，芬兰文，法文，德文，意大利文，挪威文，葡萄牙文，俄文，西班牙文，瑞典文等</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASCIIFoldingFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除法语等语言的重音符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PhoneticFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将语音相似的令牌插入令牌流</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encoder</code> ：其中之一<code>DoubleMetaphone</code> ， <code>Metaphone</code> ， <code>Soundex</code>要么<code>RefinedSoundex</code></p>
<p class="tableblock"><code>inject</code> ：true将向流中添加令牌，false将替换现有令牌</p>
<p class="tableblock"><code>maxCodeLength</code> ：设置要生成的代码的最大长度。仅支持Metaphone和DoubleMetaphone编码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-phonetic</code>和<code>commons-codec</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CollationKeyFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将每个令牌转换为其<code>java.text.CollationKey</code> ，然后对<code>CollationKey</code>与<code>IndexableBinaryStringTools</code> ，以将其存储为索引项。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>custom</code> ， <code>language</code> ， <code>country</code> ， <code>variant</code> ， <code>strength</code> ， <code>decomposition</code>有关更多信息，请参见Lucene的CollationKeyFilter javadocs。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code>和<code>commons-io</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们建议检查一下的实现<code>org.apache.lucene.analysis.util.TokenizerFactory</code>和<code>org.apache.lucene.analysis.util.TokenFilterFactory</code>在您的IDE中查看可用的实现。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_analyzer_selection"><a class="anchor" href="#_dynamic_analyzer_selection"></a> 4.3.3。动态分析仪选择</h4>
<div class="paragraph">
<p>到目前为止，所有介绍分析仪的方法都是静态的。但是，在某些情况下，例如，在多语言应用程序中，根据要索引的实体的当前状态选择分析器是有用的。为<code>BlogEntry</code>例如，分析器类可能取决于条目的语言属性。根据此属性，应选择正确的语言特定词干对实际文本进行索引。</p>
</div>
<div class="paragraph">
<p>为了启用此动态分析器选择，Hibernate Search引入了<code>@AnalyzerDiscriminator</code>注解。<a href="#example-analyzer-discriminator">用法<code>@AnalyzerDiscriminator</code></a>演示此注释的用法。</p>
</div>
<div id="example-analyzer-discriminator" class="exampleblock">
<div class="title">示例49。用法<code>@AnalyzerDiscriminator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class
    )
  })
@AnalyzerDef(name = "de",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;

    @Field
    private String text;

    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;

    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用的前提条件<code>@AnalyzerDiscriminator</code>是所有将动态使用的<a href="#section-named-analyzers">分析器</a>都被预先定义为<a href="#section-named-analyzers">命名分析器</a> 。如果是这种情况，可以将<code>@AnalyzerDiscriminator</code>动态选择分析器的实体的类或特定属性上的注释。通过<code>impl</code>的参数<code>@AnalyzerDiscriminator</code>您指定的具体实现<code>Discriminator</code>接口。您需要为此接口提供一个实现。您唯一需要实现的方法是<code>getAnalyzerDefinitionName()</code>将为添加到Lucene文档中的每个字段调用该方法。被索引的实体也被传递给接口方法。的<code>value</code>仅当<code>AnalyzerDiscriminator</code>放在属性级别而不是类级别。在这种情况下，该值表示此属性的当前值。</p>
</div>
<div class="paragraph">
<p>一个的实现<code>Discriminator</code>接口必须返回现有分析器定义的名称；如果不应覆盖默认分析器，则返回null。
<a href="#example-analyzer-discriminator">用法<code>@AnalyzerDiscriminator</code></a>假设language参数是与分析器名称匹配的'de'或'en'。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>没有等效的<code>@AnalyzerDiscriminator</code>对于<a href="#section-normalizers">规范化工具</a> ，至少目前是这样。参见<a href="https://hibernate.atlassian.net/browse/HSEARCH-2738">HSEARCH-2738</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="analyzer-retrievinganalyzer"><a class="anchor" href="#analyzer-retrievinganalyzer"></a> 4.3.4。检索分析仪</h4>
<div class="paragraph">
<p>在某些情况下，检索分析仪会很方便。例如，如果您的域模型使用多个分析器（可能会受益于词干分析，使用语音逼近等），则在构建查询时需要确保使用相同的分析器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该规则可以被打破，但是您需要一个很好的理由。如果不确定，请使用相同的分析仪。如果您使用Hibernate Search查询DSL（请参阅使用Hibernate Search查询DSL <a href="#search-query-querydsl">构建Lucene查询</a> ），则无需考虑。查询DSL确实为您透明地使用了正确的分析器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>无论您使用的是Lucene编程API还是Lucene查询解析器，都可以检索给定实体的作用域分析器。范围分析器是一种根据被索引的字段应用正确的分析器的分析器。请记住，可以在给定实体上定义多个分析器，每个分析器都在一个单独的字段上工作。范围分析器将所有这些分析器统一为上下文感知分析器。虽然理论似乎有些复杂，但在查询中使用正确的分析器非常容易。</p>
</div>
<div class="exampleblock">
<div class="title">示例50建立全文查询时使用范围分析器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.apache.lucene.queryparser.classic.QueryParser parser = new QueryParser(
    "title",
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery =
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，歌曲标题在两个字段中进行了索引：在该字段中使用了标准分析器<code>title</code>并且在现场使用了词干分析仪<code>title_stemmed</code> 。通过使用搜索工厂提供的分析器，查询将根据目标字段使用适当的分析器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还可以使用以下方式按其定义名称检索<a href="#section-named-analyzers">命名的分析器</a> ： <code>searchFactory.getAnalyzer(String)</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-mapping-bridge"><a class="anchor" href="#search-mapping-bridge"></a> 4.4。桥梁</h3>
<div class="paragraph">
<p>到目前为止，在讨论实体的基本映射时，一个重要事实被忽略了。在Lucene中，所有索引字段都必须表示为字符串。所有带有注释的实体属性<code>@Field</code>必须转换为要索引的字符串。到目前为止，我们之所以没有提及它，是因为大多数内置Hibernate Search都借助一组内置的桥为您完成了翻译工作。但是，在某些情况下，您需要对翻译过程进行更精细的控制。</p>
</div>
<div class="sect3">
<h4 id="section-built-in-bridges"><a class="anchor" href="#section-built-in-bridges"></a> 4.4.1。内置桥</h4>
<div class="paragraph">
<p>Hibernate Search捆绑了Java属性类型与其全文表示之间的一组内置桥。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>null</code></dt>
<dd>
<p>默认情况下<code>null</code>元素未编制索引。Lucene不支持<code>null</code>元素。但是，在某些情况下，插入代表<code>null</code>值。有关更多信息，请参见<a href="#field-annotation">@Field</a> 。</p>
</dd>
<dt class="hdlist1"><code>java.lang.String</code></dt>
<dd>
<p>字符串按原样编制索引。</p>
</dd>
<dt class="hdlist1"><code>boolean</code> ，<code>Boolean</code></dt>
<dd>
<p>转换为其字符串表示形式并进行索引。</p>
</dd>
<dt class="hdlist1"><code>char</code> ，<code>Character</code></dt>
<dd>
<p>转换为其字符串表示形式并进行索引。</p>
</dd>
<dt class="hdlist1"><code>int</code> ， <code>Integer</code> ， <code>long</code> ， <code>Long</code> ， <code>float</code> ， <code>Float</code> ， <code>double</code> ，<code>Double</code></dt>
<dd>
<p>默认情况下，使用<a href="http://en.wikipedia.org/wiki/Trie">Trie结构</a>对索引进行数字索引，该<a href="http://en.wikipedia.org/wiki/Trie">结构</a>允许有效的范围查询和排序，从而缩短查询响应时间。您需要使用<code>NumericRangeQuery</code>搜索值。另请参见<a href="#field-annotation">@Field</a>和<a href="#numeric-field-annotation">@NumericField</a> 。</p>
</dd>
</dl>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在Hibernate Search 5之前，仅当通过明确请求时才选择数字字段编码<code>@NumericField</code> 。从Hibernate Search 5开始，将自动为上述数字类型选择此编码。</p>
</div>
<div class="paragraph">
<p>为了避免数字编码，您可以通过以下方式显式指定非数字字段桥<code>@Field.bridge</code>要么<code>@FieldBridge</code> 。包装<code>org.hibernate.search.bridge.builtin</code>包含一组将数字编码为字符串的桥，例如<code>org.hibernate.search.bridge.builtin.IntegerBridge</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>byte</code> ， <code>Byte</code> ， <code>short</code> ，<code>Short</code></dt>
<dd>
<p>转换为其字符串表示形式并进行索引。如果明确标记为<code>@NumericField</code>批注（请参阅<a href="#numeric-field-annotation">@NumericField</a> ）。</p>
</dd>
<dt class="hdlist1"><code>BigInteger</code> ，<code>BigDecimal</code></dt>
<dd>
<p>转换为其字符串表示形式并进行索引。请注意，以这种形式，Lucene不能使用例如a来比较值。 <code>TermRangeQuery</code> 。为此，将需要填充字符串表示形式。在<a href="#example-custom-numericfieldbridge">定义自定义FieldBridge为<code>BigDecimal</code></a> 。</p>
</dd>
<dt class="hdlist1"><code>java.util.Date</code> ，<code>java.util.Calendar</code></dt>
<dd>
<p>日期被索引为<code>long</code>代表自<em>1970</em>年<em>1月1日格林尼治标准时间00:00:00</em>以来的毫秒数的值。您不应该真正为内部格式而烦恼。但是，重要的是要通过<code>NumericRangeQuery</code> 。</p>
<div class="paragraph">
<p>通常，不需要存储最多毫秒的日期。
<code>@DateBridge</code>和<code>@CalendarBridge</code>允许定义您愿意存储在索引中的适当分辨率。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)
    @DateBridge(resolution=Resolution.MINUTE)
    private Date date;
    // ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以选择使用将日期编码为字符串<code>encoding=EncodingType.STRING</code>的<code>@DateBridge</code>和<code>@CalendarBridge</code> 。在这种情况下，日期以<em>yyyyMMddHHmmssSSS</em>格式存储（使用GMT时间）。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认日期桥使用Lucene的<code>DateTools</code>从...转换<code>Date</code>要么<code>Calendar</code>达到其索引值。这意味着所有日期均以格林尼治标准时间表示。如果您的要求是将日期存储在固定时区中，则必须实现自定义日期桥。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1"><code>java.time.Year</code></dt>
<dd>
<p>将年份转换为整数表示形式。</p>
</dd>
<dt class="hdlist1"><code>java.time.Duration</code></dt>
<dd>
<p>将持续时间转换为以纳秒为单位的总长度。</p>
</dd>
<dt class="hdlist1"><code>java.time.Instant</code></dt>
<dd>
<p>将瞬间转换为从纪元开始的毫秒数。请注意，这些值的索引精度为毫秒。</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，必须有可能将<code>Instant</code>或者<code>Duration</code>到一个<code>Long</code> 。如果这些值太大或太小，则会引发异常。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LocalDate</code> ， <code>LocalTime</code> ， <code>LocalDateTime</code> ， <code>MonthDay</code> ， <code>OffsetDateTime</code> ， <code>OffsetTime</code> ， <code>Period</code> ， <code>YearMonth</code> ， <code>ZoneDateTime</code> ， <code>ZoneId</code> ，<code>ZoneOffset</code></dt>
<dd>
<p>这些课程中的桥梁<code>java.time</code>打包时将值存储为字符串，并在需要排序时用0填充。</p>
</dd>
<dt class="hdlist1"><code>java.net.URI</code> ，<code>java.net.URL</code></dt>
<dd>
<p><code>URI</code>和<code>URL</code>转换为其字符串表示形式</p>
</dd>
<dt class="hdlist1"><code>java.lang.Class</code></dt>
<dd>
<p>类将转换为其完全限定的类名称。当类重新水化时，使用线程上下文类加载器</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="mapping-tika-bridge"><a class="anchor" href="#mapping-tika-bridge"></a> 4.4.2。蒂卡桥</h4>
<div class="paragraph">
<p>Hibernate Search允许您使用内置的文档从各种文档类型中提取文本<code>TikaBridge</code>它利用<a href="http://tika.apache.org">Apache Tika</a>从提供的文档中提取文本和元数据。</p>
</div>
<div class="paragraph">
<p>的<code>@TikaBridge</code>注释可以与<code>String</code> ， <code>URI</code> ， <code>byte[]</code>要么<code>java.sql.Blob</code>属性。如果是<code>String</code>和<code>URI</code>桥将这些值解释为文件路径，并尝试打开文件以解析文档。如果是<code>byte[]</code>和<code>Blob</code>这些值将直接传递给Tika进行解析。</p>
</div>
<div class="paragraph">
<p>解析值时，Tika使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>文档内容作为输入</p>
</li>
<li>
<p>元数据作为输入和输出</p>
</li>
<li>
<p>一种<code>ParseContext</code>作为输入</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在<a href="http://tika.apache.org/1.1/parser.html#apiorgapachetikametadataMetadata.html">解析器界面中</a>找到有关解析过程的更多信息。通过Hibernate Search Tika桥，您可以将三个接口的实现传递给<code>TikaBridge</code> 。</p>
</div>
<div class="paragraph">
<p>第一个界面是<code>TikaParserProvider</code> 。它定义了将在文档内容上使用的解析器，即应如何解释文档。默认行为应涵盖大多数用例，因为它使用了Tika的<code>AutoDetectParser</code>来检测内容类型并使用适当的解析器，但是使用自定义提供程序仍然有用，例如使用自定义Tika配置文件。</p>
</div>
<div class="paragraph">
<p>第二个界面是<code>TikaMetadataProcessor</code>有两种方法- <code>prepareMetadata()</code>和<code>set(String, Object, Document, LuceneOptions, Metadata metadata)</code> 。前者允许向解析过程添加其他元数据（例如文件名），而后者则允许您索引在解析过程中发现的元数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">Tika的可排序字段</div>
<div class="paragraph">
<p>如果要在您的网站中添加多个字段<code>TikaMetadataProcessor</code> ，并且还希望使这些字段可排序，则应使处理器实现<code>MetadataProvidingTikaMetadataProcessor</code> 。这类似于实施<code>MetadataProvidingFieldBridge</code>在常规场桥上：参见<a href="#sortablefield-annotation">@SortableField</a> 。</p>
</div>
<div class="paragraph">
<p>喜欢<code>MetadataProvidingFieldBridge</code> ， <code>MetadataProvidingTikaMetadataProcessor</code>该合同正在积极开发中，目前还处于试验阶段。在将来的修订版中可能会对其进行更改，例如通过添加其他方法，从而破坏现有的实现。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第三个界面是<code>TikaParseContextProvider</code> 。它允许您创建一个自定义<code>ParseContext</code>用于文档解析。</p>
</div>
<div class="paragraph">
<p>通过在接口上指定其类作为参数，将上述接口的实现传递给TikaBridge。 <code>TikaBridge</code>注解。</p>
</div>
<div id="example-tika-mapping" class="exampleblock">
<div class="title">例子51。使用Apache Tika映射的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Song {
    @Id
    @GeneratedValue
    long id;

    @Field
    @TikaBridge(metadataProcessor = Mp3TikaMetadataProcessor.class)
    String mp3FileName;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder queryBuilder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
    .forEntity( Song.class )
    .get();
Query query = queryBuilder.keyword()
    .onField( "mp3FileName" )
    .ignoreFieldBridge() //mandatory
    .matching( "Apes" )
    .createQuery();
List result = fullTextSession.createFullTextQuery( query ).list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#example-tika-mapping">示例中使用Apache Tika映射</a>属性<code>mp3FileName</code>表示MP3文件的路径；该文件的标题将被索引，因此执行的查询将能够匹配MP3元数据。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>TikaBridge</code>没有实现<code>TwoWayFieldBridge</code> ：使用DSL构建的查询（如<a href="#example-tika-mapping">使用Apache Tika</a>的<a href="#example-tika-mapping">示例映射</a> ）需要显式启用选项ignoreFieldBridge（）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用<code>@TikaBridge</code>与WildFly模块结合使用时，请确保按照将<a href="#modules-tika">Apache Tika和其他扩展与WildFly模块一起使用中</a>所述打包Tika扩展。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="section-custom-bridges"><a class="anchor" href="#section-custom-bridges"></a> 4.4.3。定制桥</h4>
<div class="paragraph">
<p>有时，Hibernate Search的内置网桥无法覆盖您的某些媒体资源类型，或者<code>String</code>桥使用的表示形式不符合您的要求。以下段落描述了此问题的几种解决方案。</p>
</div>
<div class="sect4">
<h5 id="_stringbridge"><a class="anchor" href="#_stringbridge"></a>弦桥</h5>
<div class="paragraph">
<p>最简单的自定义解决方案是为Hibernate Search提供您期望的实现<code>Object</code>至<code>String</code>桥。为此，您需要实施<code>org.hibernate.search.bridge.StringBridge</code>接口。所有实现必须同时使用，因此必须是线程安全的。</p>
</div>
<div id="example-custom-string-bridge" class="exampleblock">
<div class="title">示例52。自订<code>StringBridge</code>实作</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements StringBridge {

    private int padding = 5;

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定在<a href="#example-custom-string-bridge">Custom</a>中<a href="#example-custom-string-bridge">定义</a>的字符串桥<a href="#example-custom-string-bridge"><code>StringBridge</code>实现中</a> ，由于<code>@FieldBridge</code>注解：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@FieldBridge(impl = PaddedIntegerBridge.class)
private Integer length;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_parameterized_bridge"><a class="anchor" href="#_parameterized_bridge"></a>参数化桥梁</h6>
<div class="paragraph">
<p>还可以将参数传递给网桥实现，使其更加灵活。
<a href="#example-passing-bridge-parameters">将参数传递给网桥实现可</a>实现<code>ParameterizedBridge</code>接口和参数通过<code>@FieldBridge</code>注解。</p>
</div>
<div id="example-passing-bridge-parameters" class="exampleblock">
<div class="title">示例53。将参数传递给网桥实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PaddedIntegerBridge implements StringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map&lt;String,String&gt; parameters) {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder( );
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//on the property:
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
            )
private Integer length;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>ParameterizedBridge</code>接口可以通过以下方式实现<code>StringBridge</code> ， <code>TwoWayStringBridge</code> ， <code>FieldBridge</code>实现。</p>
</div>
<div class="paragraph">
<p>所有实现都必须是线程安全的，但是参数是在初始化期间设置的，在此阶段不需要特别注意。</p>
</div>
</div>
<div class="sect5">
<h6 id="_type_aware_bridge"><a class="anchor" href="#_type_aware_bridge"></a>类型识别桥</h6>
<div class="paragraph">
<p>有时，获取应用桥的类型很有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字段/获取者级别桥的属性的返回类型</p>
</li>
<li>
<p>类级桥的类类型</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个例子是一个以自定义方式处理枚举但需要访问实际枚举类型的桥。任何实现的桥梁<code>AppliedOnTypeAwareBridge</code>将获得桥应用于注入的类型。像参数一样，注入的类型在线程安全性方面不需要特别注意。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="section-field-bridge"><a class="anchor" href="#section-field-bridge"></a>现场桥</h5>
<div class="paragraph">
<p>在将属性映射到Lucene索引时，某些用例需要的不仅仅是字符串转换的简单对象。为了给您最大的灵活性，您还可以将网桥作为<code>FieldBridge</code> 。此接口为您提供属性值，并让您在Lucene中以所需的方式映射它<code>Document</code> 。例如，您可以将属性存储在两个不同的文档字段中。该接口的概念与Hibernate ORM非常相似<code>UserTypes</code> 。</p>
</div>
<div id="example-field-bridge" class="exampleblock">
<div class="title">示例54实现FieldBridge接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Store the date in 3 different fields - year, month, day - to ease the creation of RangeQuery per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    public void set(String name, Object value, Document document,
                    LuceneOptions luceneOptions) {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);

        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );

        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );

        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//property
@FieldBridge(impl = DateSplitBridge.class)
private Date date;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#example-field-bridge">实现FieldBridge界面中</a> ，未将字段直接添加到<code>Document</code> 。而是将添加委托给<code>LuceneOptions</code>帮手;该帮助程序将应用您选择的选项<code>@Field</code> ， 喜欢<code>Store</code>要么<code>TermVector</code> ，或应用所选的<code>@Boost</code>值。封装复杂性特别有用<code>COMPRESS</code>实现。即使建议委托给<code>LuceneOptions</code>将字段添加到<code>Document</code> ，没有什么可以阻止您编辑<code>Document</code>直接，并在需要时忽略LuceneOptions。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>像<code>LuceneOptions</code>被创建来保护您的应用程序免受Lucene API的更改并简化您的代码。如果可以，请使用它们，但是如果您需要更大的灵活性，则不需要。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_classbridge"><a class="anchor" href="#_classbridge"></a>类桥</h5>
<div class="paragraph">
<p>有时将给定实体的多个属性组合在一起并以特定方式将此组合索引到Lucene索引中会很有用。的<code>@ClassBridge</code>和<code>@ClassBridges</code>注释可以在类级别（相对于属性级别）进行定义。在这种情况下，定制字段网桥实现将实体实例作为值参数而不是特定属性接收。尽管在<a href="#example-class-bridge">实现类桥中</a>未显示， <code>@ClassBridge</code>支持<code>termVector</code> <a href="#basic-mapping">基本映射</a>部分中讨论的属性。</p>
</div>
<div id="example-class-bridge" class="exampleblock">
<div class="title">例子55。搭建课堂桥梁</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@ClassBridge(name="branchnetwork",
             store=Store.YES,
             impl = CatFieldsClassBridge.class,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    public void set(
        String name, Object value, Document document, LuceneOptions luceneOptions) {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        luceneOptions.addFieldToDocument( name, fieldValue, document );
   }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， <code>CatFieldsClassBridge</code>适用于<code>department</code>例如，现场网桥然后将分支和网络连接起来并为连接建立索引。</p>
</div>
<div class="sect5">
<h6 id="section-two-way-bridge"><a class="anchor" href="#section-two-way-bridge"></a>两通桥</h6>
<div class="paragraph">
<p>如果希望从索引中检索值（例如，在使用<a href="#projections">projections时</a> ），则需要使用Hibernate Search所谓的“双向桥”。特别是应用于文档标识符的桥必须是双向桥。</p>
</div>
<div class="paragraph">
<p>这些桥通过以下方式应用于您的模型<code>@FieldBridge</code>注释与任何其他桥梁一样，但是它们的实现略有不同。</p>
</div>
<div class="paragraph">
<p>更简单的双向桥接接口， <code>TwoWayStringBridge</code> ， 类似于<code>StringBridge</code>但是公开了两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>String objectToString(Object)</code>方法将属性值转换为String。这使Hibernate Search可以在建立索引时生成字段的值。该方法还用于在字段上进行过滤时生成搜索查询。</p>
</li>
<li>
<p>的<code>Object stringToObject(String)</code>方法将存储在索引中的值转换回关联的实体属性的值。这使Hibernate Search可以在投影时获取值。对于文档标识符，它还允许在获取搜索结果时从索引文档加载实体。</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">例子56。实施<code>TwoWayStringBridge</code>可用于id属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get(PADDING_PROPERTY);
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding ; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }

    public Object stringToObject(String stringValue) {
        return new Integer(stringValue);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//On an id property:
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
private Integer id;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更强大<code>TwoWayFieldBridge</code>接口允许您将多个字段存储到索引中，这对于复合属性很有用，但实现起来较为复杂：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>void set(String name, Object value, Document document, LuceneOptions luceneOptions)</code>方法将属性值转换为一个或多个字段。这使Hibernate Search可以在建立索引时生成文档。</p>
</li>
<li>
<p>的<code>Object get(String name, Document document)</code>方法将存储在索引中的值转换回关联的实体属性的值。这使Hibernate Search可以在投影时获取值。对于文档标识符，它还允许在获取搜索结果时从索引文档加载实体。</p>
</li>
<li>
<p>的<code>String objectToString(Object)</code>方法将属性值转换为String。在主字段（名称被传递到<code>get</code> / <code>set</code>方法）。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>双向过程必须是幂等的，即：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于<code>TwoWayStringBridge</code> ： <code>object.equals(stringToObject(objectToString(object)))</code> 。</p>
</li>
<li>
<p>对于<code>TwoWayFieldBridge</code> ：对于给定的文档，由返回的对象<code>get()</code>必须与原始传递给的相同<code>set()</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外，为了<code>TwoWayFieldBridge</code>实现用于在文档标识符， <code>void set(String name, Object value, Document document, LuceneOptions luceneOptions)</code>方法<strong>必须</strong>遵循以下约定将字段添加到文档中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字段名称必须是<code>name</code>参数</p>
</li>
<li>
<p>字段值必须编码为字符串</p>
</li>
<li>
<p>字段值必须是给定值的唯一<code>value</code>参数</p>
</li>
<li>
<p>字段值必须与<code>objectToString</code>方法将返回给定的<code>value</code>参数。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bridgeprovider_associate_a_bridge_to_a_given_return_type"><a class="anchor" href="#_bridgeprovider_associate_a_bridge_to_a_given_return_type"></a> 4.4.4。BridgeProvider：将桥与给定的返回类型相关联</h4>
<div class="paragraph">
<p>自定义字段桥接非常灵活，但是应用相同的自定义字段可能很繁琐且容易出错<code>@FieldBridge</code>每当域模型中存在给定类型的属性时，便会添加注释。那就是BridgeProviders的目的。</p>
</div>
<div class="paragraph">
<p>假设您有一个类型<code>Currency</code>在您的应用程序中，并且您想要应用自己的<code>CurrencyFieldBridge</code>每次索引属性返回<code>Currency</code> 。您可以用困难的方式做到这一点：</p>
</div>
<div class="exampleblock">
<div class="title">例子57。应用相同<code>@FieldBridge</code>对于一种困难的方式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class User {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getCurrency();

    // ...
}

// continue to add @FieldBridge(impl=CurrencyFieldBridge.class) everywhere Currency is</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者你也可以自己写<code>BridgeProvider</code>实施<code>Currency</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例58。写一个<code>BridgeProvider</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CurrencyBridgeProvider implements BridgeProvider {

    //needs a default no-arg constructor

    @Override
    public FieldBridge provideFieldBridge(BridgeContext bridgeProviderContext) {
        if ( bridgeProviderContext.getReturnType().equals( Currency.class ) ) {
            return CurrencyFieldBridge.INSTANCE;
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre># service file named META-INF/services/org.hibernate.search.bridge.spi.BridgeProvider
com.acme.myapps.hibernatesearch.CurrencyBridgeProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您需要实施<code>BridgeProvider</code>并创建一个名为<em>META-INF / services / org.hibernate.search.bridge.spi的服务文件<em>。BridgeProvider</em> 。该文件必须包含以下内容的完全限定的类名： <code>BridgeProvider</code>实现。这是经典的Service Loader发现机制。</em></p><em>
</em></div><em>
<div class="paragraph">
<p>现在，任何类型的索引属性<code>Currency</code>将使用<code>CurrencyFieldBridge</code>自动。</p>
</div>
<div class="exampleblock">
<div class="title">范例59。一个明确的<code>@FieldBridge</code>不再需要</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class User {

    @Field
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {

    @Field
    public Currency getCurrency();

    // ...
}

//CurrencyFieldBridge is applied automatically everywhere Currency is found on an indexed property</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还需要了解几件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>BridgeProvider</code>必须有一个无参数的构造函数</p>
</li>
<li>
<p>如果一个<code>BridgeProvider</code>只返回<code>FieldBridge</code>实例，如果它对调用上下文有意义。否则为空。在我们的示例中，返回类型必须为<code>Currency</code>对我们的提供商有意义。</p>
</li>
<li>
<p>如果两个或多个网桥提供商返回一个<code>FieldBridge</code>给定返回类型的实例，将引发异常。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">什么是调用上下文</div>
<div class="paragraph">
<p>调用上下文由<code>BridgeProviderContext</code>对象并代表我们正在寻找桥梁的环境。 <code>BridgeProviderContext</code>允许访问索引属性的返回类型以及<code>ServiceManager</code>可以访问<code>ClassLoaderService</code>与所有与类加载器相关的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ClassLoaderService classLoaderService = serviceManager.getClassLoaderService();
CustomBridge cb = classLoaderService.classForName( "com.package.CustomBridge" );</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</em></div><em>
<div class="sect3">
<h4 id="section-bridge-dependency-injection"><a class="anchor" href="#section-bridge-dependency-injection"></a> 4.4.5。桥梁中的依赖注入</h4>
<div class="paragraph">
<p>Hibernate Search提供的SPI允许在实例化自定义网桥时使用依赖项注入框架，从而在网桥中启用依赖项注入。</p>
</div>
<div class="paragraph">
<p>使用Hibernate Search ORM集成时，Hibernate Search已连接到Hibernate ORM的依赖项注入支持，这意味着，如果您的框架已经向Hibernate ORM提供了依赖项注入（特别是对于EntityListener和AttributeConverter），则依赖项注入应自动也适用于Hibernate Search网桥。</p>
</div>
<div class="paragraph">
<p>为了注入网桥，您只需要使用依赖项注入框架提供的所有功能来实现网桥（ <code>@Inject</code> ，…），并将其注册到依赖项注入上下文中。然后，您可以像往常一样使用实现类或唯一标识的超级接口来引用桥，以应用桥。Hibernate Search将尝试使用依赖项注入框架来检索网桥，如果未找到，它将默认为基于反射的实例化（使用公共的无参数构造函数）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请谨慎定义桥接的范围。例如，如果桥实现<code>AppliedOnTypeAwareBridge</code> ，单例桥将不起作用，因为该桥可能会在具有不同类型的不同属性的多个地方使用。在这种情况下，您需要的是“原型”（Spring术语）或“从属”（CDI术语）范围，通常这是最安全的选择。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</em></div><em>
<div class="sect2">
<h3 id="search-mapping-indexinginterceptor"><a class="anchor" href="#search-mapping-indexinginterceptor"></a> 4.5。条件索引</h3>
<div class="paragraph">
<p>在某些情况下，您只想在实体处于给定状态时为其建立索引，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅索引标记为已发布的博客条目</p>
</li>
<li>
<p>标记为已存档的发票时不再为其编制索引</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这既满足功能需求又满足技术需求。您不希望您的博客读者找到您的草稿条目，并将其从查询中过滤掉有点烦人。实际上，很少需要对实体进行索引，并且您希望限制索引开销并保持索引的大小和速度。</p>
</div>
<div class="paragraph">
<p>Hibernate Search使您可以拦截实体索引操作并覆盖它们。这很简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>写一个<code>EntityIndexingInterceptor</code>您的基于实体状态的逻辑的类</p>
</li>
<li>
<p>将实体标记为被此实现拦截</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们看一下<a href="#example-search-mapping-indexinginterceptor-blog">索引博客条目时</a>的博客示例（ <a href="#example-search-mapping-indexinginterceptor-blog">仅当它们发布时），而当它们处于不同状态时将其删除</a></p>
</div>
<div id="example-search-mapping-indexinginterceptor-blog" class="exampleblock">
<div class="title">示例60仅在博客条目发布时对其进行索引，而在它们处于不同状态时将其删除</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Only index blog when it is in published state
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 */
public class IndexWhenPublishedInterceptor implements EntityIndexingInterceptor&lt;Blog&gt; {
    @Override
    public IndexingOverride onAdd(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.APPLY_DEFAULT;
        }
        return IndexingOverride.SKIP;
    }

    @Override
    public IndexingOverride onUpdate(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.UPDATE;
        }
        return IndexingOverride.REMOVE;
    }

    @Override
    public IndexingOverride onDelete(Blog entity) {
        return IndexingOverride.APPLY_DEFAULT;
    }

    @Override
    public IndexingOverride onCollectionUpdate(Blog entity) {
        return onUpdate(entity);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(interceptor=IndexWhenPublishedInterceptor.class)
public class Blog {
    @Id
    @GeneratedValue
    public Integer getId() { return id; }
    public void setId(Integer id) {  this.id = id; }
    private Integer id;

    @Field
    public String getTitle() { return title; }
    public void setTitle(String title) {  this.title = title; }
    private String title;

    public BlogStatus getStatus() { return status; }
    public void setStatus(BlogStatus status) {  this.status = status; }
    private BlogStatus status;

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们标记<code>Blog</code>与实体<code>@Indexed.interceptor</code> 。如你看到的， <code>IndexWhenPublishedInterceptor</code>贯彻<code>EntityIndexingInterceptor</code>并接受<code>Blog</code>实体（它也可以接受超类-例如<code>Object</code>如果创建通用拦截器。</p>
</div>
<div class="paragraph">
<p>您可以对几个计划的索引事件做出反应：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将实体添加到您的数据存储区时</p>
</li>
<li>
<p>实体在您的数据存储中更新时</p>
</li>
<li>
<p>从您的数据存储中删除实体时</p>
</li>
<li>
<p>当此实体拥有的集合在您的数据存储区中更新时</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于每个发生的事件，您可以通过以下操作之一进行响应：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>APPLY_DEFAULT</code> ：这是让Hibernate Search按预期更新索引的基本操作-创建，更新或删除文档</p>
</li>
<li>
<p><code>SKIP</code> ：要求Hibernate Search对此事件的索引不执行任何操作-不会以任何方式创建，更新或从索引中删除数据</p>
</li>
<li>
<p><code>REMOVE</code> ：要求Hibernate Search删除有关该实体的索引数据-您可以放心地要求<code>REMOVE</code>即使该实体尚未被索引</p>
</li>
<li>
<p><code>UPDATE</code> ：要求Hibernate Search为该实体建立索引或更新索引-可以安全地查询<code>UPDATE</code>即使该实体从未被索引过</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意，并非每种组合都有意义：例如，要求<code>UPDATE</code> onDelete上的索引。请注意，您可以要求<code>SKIP</code>在这种情况下，节省索引时间对您来说至关重要。不过，这种情况很少发生。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，没有拦截器应用于实体。您必须通过明确定义拦截器<code>@Indexed</code>注释（请参阅<a href="#indexed-annotation">@Indexed</a> ）或以编程方式（请参阅<a href="#hsearch-mapping-programmaticapi">Programmatic API</a> ）。该类及其所有子类将被拦截。您可以通过重写来停止或更改子类中使用的拦截器<code>@Indexed.interceptor</code> 。Hibernate Search提供<code>DontInterceptEntityInterceptor</code>显然不会拦截任何呼叫。这对于重置类层次结构中的侦听很有用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用拦截器时，禁用脏检查优化。脏检查优化会检查实体中发生了什么更改，并且仅在索引属性发生更改时才触发索引更新。原因很简单，您的拦截器可能依赖于非索引属性，该优化将忽略该属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一个<code>EntityIndexingInterceptor</code>永远不能覆盖显式索引操作，例如<code>index(T)</code> ， <code>purge(T, id)</code>要么<code>purgeAll(class)</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="provided-id"><a class="anchor" href="#provided-id"></a> 4.6。提供自己的身份证</h3>
<div class="paragraph">
<p>如果您要扩展内部结构，则可以为Hibernate Search提供自己的ID。您将必须生成一个唯一值，以便可以将其提供给Lucene进行索引。当您创建一个<code>org.hibernate.search.Work</code> object-构造函数中需要文档ID。</p>
</div>
<div class="sect3">
<h4 id="ProvidedId"><a class="anchor" href="#ProvidedId"></a> 4.6.1。ProvidedId批注</h4>
<div class="paragraph">
<p>不像<code>@DocumentId</code>应用于现场<code>@ProvidedId</code>在班级使用。（可选）您可以使用bridge属性指定自己的桥实现。另外，如果您用<code>@ProvidedId</code> ，您的子类也会获得注释-但这不是通过使用<code>java.lang.annotations.@Inherited</code> 。但是请确保<em>不要</em>将此注释与<code>@DocumentId</code>因为您的系统会崩溃。</p>
</div>
<div class="exampleblock">
<div class="title">例子61。提供自己的身份证</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@ProvidedId(bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hsearch-mapping-programmaticapi"><a class="anchor" href="#hsearch-mapping-programmaticapi"></a> 4.7。程序化API</h3>
<div class="paragraph">
<p>尽管建议的用于映射索引实体的方法是使用批注，但有时使用其他方法更为方便：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>相同的实体根据部署需求（客户端的自定义）进行不同的映射</p>
</li>
<li>
<p>某些自动化过程需要动态映射具有共同特征的许多实体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管过去一直很流行，但是Hibernate团队从来没有发现XML替代注释的想法具有吸引力，原因是它的重复量大，缺乏代码重构安全性，因为它没有涵盖所有用例范围，并且因为在21世纪:)</p>
</div>
<div class="paragraph">
<p>程序化API的想法更具吸引力，现已成为现实。您可以使用编程API以编程方式定义映射：通过使用映射类将实体和字段定义为可索引的，该映射类有效地反映了Hibernate Search中的注释概念。请注意，XML方法的支持者可以设计自己的架构，并在分析XML流的同时使用编程API创建映射。</p>
</div>
<div class="paragraph">
<p>为了使用程序化模型，您必须首先构造一个<code>SearchMapping</code>您可以通过两种方式来实现对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>直</p>
</li>
<li>
<p>通过工厂</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过属性键直接传递SearchMapping对象<code>hibernate.search.model_mapping</code>或常数<code>Environment.MODEL_MAPPING</code> 。使用配置API或<code>Map</code>传递给JPA Persistence引导程序方法。</p>
</div>
<div class="exampleblock">
<div class="title">例子62。程序化映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Configuration config = new Configuration();
config.getProperties().put( Environment.MODEL_MAPPING, mapping );
SessionFactory sf = config.buildSessionFactory();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例63。使用JPA进行程序映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Map props = new HashMap();
props.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", props );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以创建一个工厂类（即，托管带有注释的方法<code>@Factory</code> ），其工厂方法返回<code>SearchMapping</code>宾语。工厂类必须具有no-arg构造函数，并且其完全限定的类名称将传递给属性键<code>hibernate.search.model_mapping</code>或其类型安全的表示形式<code>Environment.MODEL_MAPPING</code> 。当您不必像Java EE，CDI或Spring Framework容器中那样控制引导过程时，此方法很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例64。使用映射工厂</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class MyAppSearchMappingFactory {
    @Factory
    public SearchMapping getSearchMapping() {
        SearchMapping mapping = new SearchMapping();
        mapping
                .analyzerDef( "ngram", StandardTokenizerFactory.class )
                    .filter( LowerCaseFilterFactory.class )
                    .filter( NGramFilterFactory.class )
                        .param( "minGramSize", "3" )
                        .param( "maxGramSize", "3" );
        return mapping;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;persistence ...&gt;
    &lt;persistence-unit name="users"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.search.model_mapping"
                      value="com.acme.MyAppSearchMappingFactory"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>SearchMapping</code>是包含所有必需的可索引实体和字段的根对象。从那里开始<code>SearchMapping</code>对象公开了一种流畅（因而直观）的API来表达您的映射：它以类型安全的方式在上下文中公开了相关的映射选项。只需让您的IDE自动完成功能指导您完成操作即可。</p>
</div>
<div class="paragraph">
<p>如今，程序化API不能用于带有Hibernate Search注释，选择一种方法或另一种方法的类。还要注意，相同的默认值适用于注释和程序化API。例如， <code>@Field.name</code>默认为属性名称，不必设置。</p>
</div>
<div class="paragraph">
<p>编程API的每个核心概念都有一个对应的示例，以描述使用批注显示相同定义的外观。因此，看到编程方法的注释示例应该可以使您清楚地了解Hibernate Search将使用标记的实体和相关属性来构建什么。</p>
</div>
<div class="sect3">
<h4 id="_mapping_an_entity_as_indexable"><a class="anchor" href="#_mapping_an_entity_as_indexable"></a> 4.7.1。将实体映射为可索引的</h4>
<div class="paragraph">
<p>程序化API的第一个概念是将实体定义为可索引的。使用注释方法，用户会将实体标记为<code>@Indexed</code> ，以下示例演示了如何以编程方式实现这一目标。</p>
</div>
<div class="exampleblock">
<div class="title">示例65。标记可索引的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index") //optional
               .interceptor(IndexWhenPublishedInterceptor.class); //optional

cfg.getProperties().put("hibernate.search.model_mapping", mapping);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，您必须先创建一个<code>SearchMapping</code>对象，它是根对象，然后作为属性传递给配置对象。您必须声明一个实体，如果要使该实体可索引，则必须调用<code>indexed()</code>方法。的<code>indexed()</code>方法有一个可选的<code>indexName(String indexName)</code>可以用来更改由Hibernate Search创建的默认索引名称。同样， <code>interceptor(Class<? extends EntityIndexedInterceptor>)</code>可用。使用注释模型，可以通过以下方式实现上述目的：</p>
</div>
<div class="exampleblock">
<div class="title">例子66。索引实体的注释示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(index="Address_Index", interceptor=IndexWhenPublishedInterceptor.class)
public class Address {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_documentid_to_indexed_entity"><a class="anchor" href="#_adding_documentid_to_indexed_entity"></a> 4.7.2。将DocumentId添加到索引实体</h4>
<div class="paragraph">
<p>要将属性设置为文档ID：</p>
</div>
<div class="exampleblock">
<div class="title">例子67。使用程序化模型启用文档ID</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上等同于将实体中的属性注释为<code>@DocumentId</code>如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例68。 <code>@DocumentId</code>注释定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_analyzers"><a class="anchor" href="#_defining_analyzers"></a> 4.7.3。定义分析仪</h4>
<div class="paragraph">
<p>可以使用<code>analyzerDef(String analyzerDef, Class<? extends TokenizerFactory> tokenizerFactory)</code>方法。此方法还使您可以为分析器定义定义过滤器。您定义的每个过滤器都可以选择接受参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例69。使用程序模型定义分析器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面定义的分析器映射等效于使用的注释模型<code>@AnalyzerDef</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例70。使用注释的分析器定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Indexed
@Entity
@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize",value = "3"),
        @Parameter(name = "maxGramSize",value = "3")
     })
 })
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@AnalyzerDef(name = "de",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = GermanStemFilterFactory.class)
})
public class Address {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_normalizers"><a class="anchor" href="#_defining_normalizers"></a> 4.7.4。定义规范化器</h4>
<div class="paragraph">
<p>与分析器类似，可以使用<code>normalizerDef(String name)</code>方法。</p>
</div>
<div class="exampleblock">
<div class="title">例子71。使用程序模型定义规范化器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .normalizerDef( "lowercase" )
        .filter( ASCIIFoldingFilterFactory.class )
        .filter( LowerCaseFilterFactory.class )
    .normalizerDef( "charmapping" )
        .charFilter( MappingChar.class )
            .param( "mapping", "com/example/myapplication/lucene/mapping.properties" )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_full_text_filter_definitions"><a class="anchor" href="#_defining_full_text_filter_definitions"></a> 4.7.5。定义全文过滤器定义</h4>
<div class="paragraph">
<p>编程API提供了用于定义全文过滤器定义的简便机制，该机制可通过以下方式获得<code>@FullTextFilterDef</code> （请参阅<a href="#query-filter">过滤器</a> ）。下一个示例描述了使用<code>fullTextFilterDef</code>方法。</p>
</div>
<div class="exampleblock">
<div class="title">例子72。以编程方式定义全文定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例可以有效地看作是使用<code>@FullTextFilterDef</code>如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例73。使用注释定义全文过滤器定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getAddressId() {...};

 @Field(store=Store.YES, analyzer=@Analyzer(definition="en"))
 @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 public String getAddress1() {...};

 // ...

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_fields_for_indexing"><a class="anchor" href="#_defining_fields_for_indexing"></a> 4.7.6。定义索引字段</h4>
<div class="paragraph">
<p>使用编程API定义用于索引的字段时，请调用<code>field()</code>在<code>property(String propertyName, ElementType elementType)</code>方法。从<code>field()</code>您可以指定<code>name</code> ， <code>index</code> ， <code>store</code> ， <code>bridge</code> ， <code>analyzer</code>和<code>normalizer</code>参数，以及使用<code>.sortableField()</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例74。使用程序化API索引字段</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .normalizerDef( "lowercase" )
        .filter( ASCIIFoldingFilterFactory.class )
        .filter( LowerCaseFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
            .field()
                .name("address_sort")
                .sortableField()
                .normalizer("lowercase");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面将字段标记为可索引的示例等同于使用定义字段<code>@Field</code>如下图所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子75。使用注释为字段建立索引</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@NormalizerDef(name = "lowercase",
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class)
  }
 )
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Field(store=Store.YES, analyzer=@Analyzer(definition="en"))
 @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 @Field(name="address_sort", normalizer=@Normalizer(definition="lowercase"))
 @SortableField(forField="address_sort")
 public String getAddress1() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对给定类型使用程序化映射时<code>X</code> ，您只能引用在上定义的字段<code>X</code> 。从超类型继承的字段或方法是不可配置的。如果需要配置超类属性，则需要在其中覆盖该属性<code>X</code>或为超类创建程序化映射。这模仿了注释的用法，在注释中您也不能注释超类的字段或方法，除非在给定类型中对其进行了重新定义。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_programmatically_defining_embedded_entities"><a class="anchor" href="#_programmatically_defining_embedded_entities"></a> 4.7.7。以编程方式定义嵌入式实体</h4>
<div class="paragraph">
<p>在本节中，您将看到如何以编程方式定义要嵌入到索引实体中的实体，类似于使用<code>@IndexedEmbedded</code>模型。为了定义它，您必须将属性标记为<code>indexEmbedded</code> 。有一个选项可以向嵌入式实体定义添加前缀，可以通过调用前缀来完成，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子76。以编程方式定义嵌入式实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.YES)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.YES)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            .indexEmbedded()
                .prefix("catalog.items"); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个示例使用注释显示相同的定义（ <code>@IndexedEmbedded</code> ）：</p>
</div>
<div class="exampleblock">
<div class="title">例子77。使用<code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription();

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_contained_in_definition"><a class="anchor" href="#_contained_in_definition"></a> 4.7.8。包含在定义中</h4>
<div class="paragraph">
<p><code>@ContainedIn</code>可以如以下示例所示进行定义：</p>
</div>
<div class="exampleblock">
<div class="title">示例78。以编程方式定义<code>containedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            .containedIn();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这相当于定义<code>@ContainedIn</code>在您的实体中：</p>
</div>
<div class="exampleblock">
<div class="title">示例79。的注释方法<code>@ContainedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class ProductCatalog {

 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded
 private List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Item {

 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}

 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_date_calendar_bridge"><a class="anchor" href="#_date_calendar_bridge"></a> 4.7.9。日期/日历桥</h4>
<div class="paragraph">
<p>为了定义日历或日期桥映射，请调用<code>dateBridge(Resolution resolution)</code>要么<code>calendarBridge(Resolution resolution)</code>定义一个<code>field()</code>在里面<code>SearchMapping</code>层次结构。</p>
</div>
<div class="exampleblock">
<div class="title">示例80。用于定义日历/日期桥的程序模型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        .dateBridge(Resolution.DAY)
    .property("lastUpdated", ElementType.FIELD)
        .calendarBridge(Resolution.DAY);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅下文以定义上述用途<code>@CalendarBridge</code>和<code>@DateBridge</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">例子81。 <code>@CalendarBridge</code>和<code>@DateBridge</code>定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_declaring_bridges"><a class="anchor" href="#_declaring_bridges"></a> 4.7.10。宣告桥梁</h4>
<div class="paragraph">
<p>可以将桥与以编程方式定义的字段相关联。当您定义一个<code>field()</code>您可以以编程方式使用<code>bridge(Class<?> impl)</code>关联一个<code>FieldBridge</code>实现类。bridge方法还提供了可选方法，以包括bridge类所需的任何参数。下面显示了以编程方式定义桥的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例82。以编程方式声明场桥</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                .bridge( ConcatStringBridge.class )
                    .param( "size", "4" );

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样可以使用注释定义以上内容，如在下一个示例中所示。</p>
</div>
<div class="exampleblock">
<div class="title">示例83。使用注解声明场桥</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Field
 @Field(name="street1_abridged",
        bridge = @FieldBridge( impl = ConcatStringBridge.class,
        params = @Parameter( name="size", value="4" ))
 private String address1;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_class_bridge"><a class="anchor" href="#_mapping_class_bridge"></a> 4.7.11。映射类桥</h4>
<div class="paragraph">
<p>您可以通过编程在实体上定义类桥。在下一个示例中显示：</p>
</div>
<div class="exampleblock">
<div class="title">示例84。使用API定义类桥</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
      .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.YES)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.YES)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面类似于使用<code>@ClassBridge</code>如下面的示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例85。使用<code>@ClassBridge</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@ClassBridge(name="branchnetwork",
  store= Store.YES,
  impl = CatDeptsFieldsClassBridge.class,
  params = @Parameter( name="sepChar", value=" " ) ),
@ClassBridge(name="equiptype",
  store= Store.YES,
  impl = EquipmentType.class,
  params = {@Parameter( name="C", value="Cisco" ),
     @Parameter( name="D", value="D-Link" ),
     @Parameter( name="K", value="Kingston" ),
     @Parameter( name="3", value="3Com" )
})
public class Departments {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_dynamic_boost"><a class="anchor" href="#_mapping_dynamic_boost"></a> 4.7.12。映射动态提升</h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用索引时间提升：自版本7起，将在Apache Lucene中删除对这种方法的支持。</p>
</div>
<div class="paragraph">
<p>我们建议改为使用查询时间提升：请参阅<a href="#search-query">查询</a> 。</p>
</div>
<div class="paragraph">
<p>如果查询时间提升不足以满足您的用例，则可以使用<a href="#section-custom-similarity">自定义相似性</a> （高级用法）实现动态提升。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以将动态提升因子应用于字段或整个实体：</p>
</div>
<div class="exampleblock">
<div class="title">示例86。 <code>dynamicBoost</code>使用程序模型进行映射</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   .dynamicBoost(CustomBoostStrategy.class)
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    .dynamicBoost(CustomFieldBoostStrategy.class);
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示了使用<code>@DynamicBoost</code>注解：</p>
</div>
<div class="exampleblock">
<div class="title">例子87。使用<code>@DynamicBoost</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;

 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</em></div><em>
</em></div><em>
<div class="sect1">
<h2 id="search-query"><a class="anchor" href="#search-query"></a> 5，查询方式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Search的第二个最重要的功能是执行Lucene查询和检索由Hibernate会话管理的实体的功能。该搜索提供了Lucene的功能，而无需离开Hibernate范例，这为Hibernate经典搜索机制（HQL，Criteria查询，本机SQL查询）提供了新的维度。</p>
</div>
<div class="paragraph">
<p>准备和执行查询包含四个简单步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个<code>FullTextSession</code></p>
</li>
<li>
<p>通过Hibernate Search查询DSL（推荐）或利用Lucene查询API创建Lucene查询</p>
</li>
<li>
<p>使用来包装Lucene查询<code>org.hibernate.Query</code></p>
</li>
<li>
<p>通过调用例如执行搜索<code>list()</code>要么<code>scroll()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要访问查询工具，您必须使用<code>FullTextSession</code> 。此搜索特定会话会包装常规<code>org.hibernate.Session</code>为了提供查询和索引功能。</p>
</div>
<div class="exampleblock">
<div class="title">例子88。创建一个FullTextSession</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = sessionFactory.openSession();
//...
FullTextSession fullTextSession = Search.getFullTextSession(session);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦你有一个<code>FullTextSession</code>您有两个选择来构建全文查询：Hibernate Search查询DSL或本地Lucene查询。</p>
</div>
<div class="paragraph">
<p>如果您使用Hibernate Search查询DSL，它将看起来像这样：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder b = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Myth.class).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以使用Lucene查询解析器或Lucene编程API编写Lucene查询。</p>
</div>
<div class="exampleblock">
<div class="title">示例89。通过QueryParser创建Lucene查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryparser.classic.QueryParser parser =
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class));
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse("history:storm^3");
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建立在Lucene查询之上的Hibernate查询是常规的<code>org.hibernate.Query</code> ，这意味着您与其他Hibernate查询工具（HQL，Native或Criteria）处于同一范例中。常规<code>list()</code> ， <code>uniqueResult()</code> ， <code>iterate()</code>和<code>scroll()</code>可以使用的方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用的是Hibernate的Java Persistence API，则存在相同的扩展名：</p>
</div>
<div class="exampleblock">
<div class="title">示例90。使用JPA API创建搜索查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

// ...
QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();
javax.persistence.Query fullTextQuery =
    fullTextEntityManager.createFullTextQuery( luceneQuery );

List result = fullTextQuery.getResultList(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下示例我们将使用Hibernate API，但是只需调整FullTextQuery的检索方式，就可以使用Java Persistence API轻松重写同一示例。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="section-building-lucene-queries"><a class="anchor" href="#section-building-lucene-queries"></a> 5.1。建立查询</h3>
<div class="paragraph">
<p>Hibernate Search查询建立在Lucene查询的基础上，它使您完全可以自由选择要执行的Lucene查询的类型。但是，一旦建立，Hibernate Search将使用org.hibernate打包进一步的查询处理。查询作为您的主要查询操作API。</p>
</div>
<div class="sect3">
<h4 id="search-query-lucene-api"><a class="anchor" href="#search-query-lucene-api"></a> 5.1.1。使用Lucene API构建Lucene查询</h4>
<div class="paragraph">
<p>使用Lucene API，您有几种选择。您可以使用查询解析器（适用于简单查询）或Lucene编程API（适用于更复杂的用例）。如何准确地构建Lucene查询超出了本文档的范围。请参考在线Lucene文档或获取Lucene In Action或Hibernate Search in Action的副本。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-query-querydsl"><a class="anchor" href="#search-query-querydsl"></a> 5.1.2。使用Hibernate Search查询DSL构建Lucene查询</h4>
<div class="paragraph">
<p>用Lucene编程API编写全文查询非常复杂。一旦编写代码，了解代码就更加复杂。除了固有的API复杂性外，您还必须记住将参数转换为等效的字符串，并确保将正确的分析器应用于正确的字段（例如，一个ngram分析器将使用多个ngram作为给定单词的标记，应该这样搜索）。</p>
</div>
<div class="paragraph">
<p>Hibernate Search查询DSL使用一种称为流畅API的API样式。该API具有一些关键特征：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它具有有意义的方法名称，使一系列操作读起来几乎像英语</p>
</li>
<li>
<p>它将提供的选项限制为在给定的上下文中有意义的选项（由于强类型和IDE自动完成功能）。</p>
</li>
<li>
<p>它通常使用链接方法模式</p>
</li>
<li>
<p>它易于使用，甚至更易于阅读</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们看看如何使用API。首先，您需要创建一个附加到给定索引实体类型的查询构建器。该QueryBuilder将知道要使用的分析器以及要应用的字段桥。您可以创建几个<code>QueryBuilder</code>实例（查询根中涉及的每个实体类型一个）。你得到<code>QueryBuilder</code>来自<code>SearchFactory</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以覆盖用于给定字段或多个字段的分析器。除非您知道自己在做什么，否则很少需要这样做，应该避免这样做。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用查询生成器，然后可以生成查询。重要的是要意识到QueryBuilder的最终结果是Lucene查询。因此，您可以轻松地混合和匹配通过Lucene的查询解析器或使用Lucene编程API组装的Query对象生成的查询，并将其与Hibernate Search DSL一起使用。以防万一DSL缺少某些功能。</p>
</div>
<div class="sect4">
<h5 id="_keyword_queries"><a class="anchor" href="#_keyword_queries"></a>关键字查询</h5>
<div class="paragraph">
<p>让我们从最基本的用例开始-搜索特定单词：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>keyword()</code>表示您正在寻找一个特定的单词。 <code>onField()</code>指定在哪个Lucene字段中查找。 <code>matching()</code>告诉要寻找什么。最后<code>createQuery()</code>创建Lucene查询对象。这行代码正在进行很多工作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>价值风暴通过<code>history</code> FieldBridge：没关系，但是您会发现在处理数字或日期时非常方便。</p>
</li>
<li>
<p>然后将字段电桥值传递到用于索引字段的分析器<code>history</code> 。这样可以确保查询使用与索引相同的术语转换（小写，n-gram，词干等）。如果分析过程为给定单词生成了多个术语，则布尔查询将与<code>SHOULD</code>逻辑（大致<code>OR</code>逻辑）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们现在使示例更加高级，并看看如何搜索使用ngram分析器的字段。 ngram分析器索引您的单词ngram的连续性，这有助于从用户输入错误中恢复。例如，冬眠一词的3克字母是hib，ibe，ber，rna，nat，ate。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)
@Entity
@Indexed
public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram")
  public String getName() { return name; }
  public String setName(String name) { this.name = name; }
  private String name;

  ...
}

Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>匹配的单词“ Sisiphus”将小写，然后分为3克：sis，isi，sip，phu和hus。这些n-gram中的每一个都是查询的一部分。然后，我们将能够找到Sysiphus神话（带有<code>y</code> ）。所有这些都为您透明地完成。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果由于某种原因您不希望特定的字段使用字段桥接器或分析仪，则可以调用<code>ignoreAnalyzer()</code>要么<code>ignoreFieldBridge()</code>功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要在同一字段中搜索多个可能的单词，只需将它们全部添加到匹配子句中。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//search document with storm or lightning in their history
Query luceneQuery =
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在多个字段上搜索相同的单词，请使用onFields方法。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有时，即使搜索相同的术语，也应将一个字段与另一个字段区别对待，您可以使用andField（）方法。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
        .boostedTo(5f)
    .andField("description")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，仅字段名称被提升为5。</p>
</div>
</div>
<div class="sect4">
<h5 id="_simple_query_string_queries"><a class="anchor" href="#_simple_query_string_queries"></a>简单查询字符串查询</h5>
<div class="paragraph">
<p>简单查询字符串查询使用Lucene <code>SimpleQueryParser</code> ，以“用于人类输入查询的解析器”的形式呈现。该解析器的要点是成为一个非常简单的宽松状态机，以解析最终用户输入的查询。</p>
</div>
<div class="paragraph">
<p>解析器能够转换<code>keyword "some phrase" -keywordidontwant fuzzy~ prefix*</code>到Lucene查询中，为您的用户提供更多功能（短语查询，模糊查询，布尔运算符……）。</p>
</div>
<div class="paragraph">
<p>宽大部分很重要，因为它会尽力构建最佳的查询而不会引发解析异常，即使查询不是我们认为在语法上正确的查询也是如此。</p>
</div>
<div class="paragraph">
<p>另一个不错的功能是它允许搜索多个字段。您基本上最终与Lucene建立了以下合同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户将输入搜索查询（语法上或多或少正确）</p>
</li>
<li>
<p>它将搜索您指定的字段（也可以为每个字段指定特定的提升）</p>
</li>
<li>
<p>您可以启用要向用户公开的每个功能（即，您可以启用词组查询，但不能启用布尔运算符）</p>
</li>
<li>
<p>建立查询不会引发异常</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>即使我们在这里谈论Lucene查询，我们的Elasticsearch集成也支持此功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下是几个示例，它们一次介绍了我们的简单查询字符串支持的功能。</p>
</div>
<div class="paragraph">
<p>下面的查询是简单查询字符串查询的最简单形式。它只是返回文档，其<code>history</code>字段包含<code>storm</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("history")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，如果未显式定义简单查询字符串查询，则使用OR运算符。如果您希望默认使用AND运算符，则可以添加<code>withAndAsDefaultOperator</code>旗。以下查询返回包含以下内容的结果<code>storm</code>和<code>tree</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("history")
    .withAndAsDefaultOperator()
    .matching("storm tree")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以同时搜索多个字段，这意味着您可以在例如<code>name</code> ， <code>history</code>要么<code>description</code> ，可能会带来不同的提升：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("name")
        .boostedTo(5f)
    .andFields("history", "description")
        .boostedTo(2f)
    .withAndAsDefaultOperator()
    .matching("storm tree")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的查询返回的结果包含<code>storm</code>和<code>tree</code>要么在<code>name</code> ， <code>history</code>要么<code>description</code> 。</p>
</div>
<div class="paragraph">
<p>语法支持<code>SimpleQueryParser</code>包括以下运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>布尔值（AND使用<code>+</code> ，或使用<code>|</code> ，不使用<code>-</code> ）</p>
</li>
<li>
<p>字首 （ <code>prefix*</code> ）</p>
</li>
<li>
<p>词组（ <code>"some phrase"</code> ）</p>
</li>
<li>
<p>优先级（使用括号）</p>
</li>
<li>
<p>模糊（ <code>fuzy~2</code> ）</p>
</li>
<li>
<p>词组查询的近似运算符（ <code>"war peace"~3</code> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下查询还将返回包含以下内容的结果<code>storms</code>要么<code>sturm</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("storm~2")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下查询将返回包含以下内容的结果： <code>war</code>还有<code>peace</code>要么<code>harmony</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("war + (peace | harmony)")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，下面的查询将返回包含以下短语的结果： <code>storm and tree</code>在任一<code>name</code> ， <code>history</code>要么<code>description</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("\"storm and tree\"")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fuzzy_queries"><a class="anchor" href="#_fuzzy_queries"></a>模糊查询</h5>
<div class="paragraph">
<p>要执行模糊查询（基于Levenshtein距离算法），请像<code>keyword</code>查询并添加模糊标志。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold(.8f)
        .withPrefixLength(1)
    .onField("history")
    .matching("starm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>threshold</code>是两个术语正在考虑匹配的上限。这是介于0和1之间的小数，默认为0.5。 <code>prefixLength</code>是被“模糊性”忽略的前缀的长度：虽然默认为0，但对于包含大量不同术语的索引，建议使用非零值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_wildcard_queries"><a class="anchor" href="#_wildcard_queries"></a>通配符查询</h5>
<div class="paragraph">
<p>您还可以执行通配符查询（查询单词中某些部分未知的查询）。性格<code>?</code>代表一个字符， <code>*</code>代表任何字符序列。请注意，出于性能目的，建议不要以任何一个查询开头<code>?</code>要么<code>*</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通配符查询不将分析器应用于匹配条件。否则的危险<code>*</code>要么<code>?</code>被弄得太高了。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_phrase_queries"><a class="anchor" href="#_phrase_queries"></a>词组查询</h5>
<div class="paragraph">
<p>到目前为止，我们一直在寻找单词或单词集，您也可以搜索精确或近似的句子。使用<code>phrase()</code>这样做。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过添加倾斜因子来搜索近似句子。斜率因子表示句子中允许的其他单词的数量：这类似于内部或附近运算符</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_range_queries"><a class="anchor" href="#_range_queries"></a>范围查询</h5>
<div class="paragraph">
<p>看完所有用于查询给定单词的查询示例后，就该介绍范围查询了（关于数字，日期，字符串等）。范围查询在给定边界之间（包括或不包括）之间的值或在给定边界之下或之上（包括或不包括）的值进行搜索。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="search-query-querydsl-spatial"><a class="anchor" href="#search-query-querydsl-spatial"></a>空间（或地理位置）查询</h5>
<div class="paragraph">
<p>这组查询有自己的章节，请<a href="#spatial">参阅Spatial</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="search-query-querydsl-mlt"><a class="anchor" href="#search-query-querydsl-mlt"></a>更多类似此查询</h5>
<div class="paragraph">
<p>您是否曾经看过文章或文档并想到：“我想找到更多类似的东西”？您是否曾经欣赏过一个电子商务网站，该网站为您提供与正在探索的网站相似的文章？</p>
</div>
<div class="paragraph">
<p>更多类似的查询正在实现这一目标。您向它提供一个实体（或其标识符），然后Hibernate Search返回相似的实体列表。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">它是如何工作的？</div>
<div class="paragraph">
<p>对于目标实体的每个（选定）字段，我们查看最有意义的术语。然后，我们创建一个与每个字段中最有意义的词匹配的查询。与原始的Lucene相比，这是一个微小的变化<code>MoreLikeThisQuery</code>实施。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>查询DSL API应该可以自我解释。让我们看一些用法示例。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder qb = fullTextSession.getSearchFactory()
        .buildQueryBuilder()
        .forEntity( Coffee.class )
        .get();

Query mltQuery = qb
        .moreLikeThis()
            .comparingAllFields()
            .toEntityWithId( coffeeId )
            .createQuery();
List&lt;Object[]&gt; results = (List&lt;Object[]&gt;) fullTextSession
        .createFullTextQuery( mltQuery, Coffee.class )
        .setProjection( ProjectionConstants.THIS, ProjectionConstants.SCORE )
        .list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个示例获取Coffee实体的ID，并在所有字段中找到匹配的Coffee。公平地说，这并不适用于<em>所有</em>领域。要包含在“更喜欢此查询”中，字段需要存储术语向量或实际字段值。（根实体和嵌入实体的）Id字段和数字字段均被排除。后者的排除可能在将来的版本中更改。</p>
</div>
<div class="paragraph">
<p>看着<code>Coffee</code>类，请考虑以下字段： <code>name</code>储存时<code>description</code>因为它存储术语向量。 <code>id</code>和<code>internalDescription</code>被排除在外。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class Coffee {

    @Id @GeneratedValue
    public Integer getId() { return id; }

    @Field(termVector = TermVector.NO, store = Store.YES)
    public String getName() { return name; }

    @Field(termVector = TermVector.YES)
    public String getSummary() { return summary; }

    @Column(length = 2000)
    @Field(termVector = TermVector.YES)
    public String getDescription() { return description; }

    public int getIntensity() { return intensity; }

    // Not stored nor term vector, i.e. cannot be used for More Like This
    @Field
    public String getInternalDescription() { return internalDescription; }

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用投影来检索每个元素的相对得分。我们可能会使用分数来仅显示分数足够高的结果。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了获得最佳性能和最佳结果，请将术语向量存储在要包含在“类似此查询”中的字段中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，您只对几个关键字段感兴趣，以查找相似的实体。另外，有些领域比其他领域更重要，应该加以加强。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntityWithId( coffeeId )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们通过摘要和描述查找相似的实体。但是类似的摘要比类似的描述更重要。这是使“更多类似”对您的数据集有意义的关键工具。</p>
</div>
<div class="paragraph">
<p>除了提供实体ID，您还可以传递完整的实体对象。如果实体包含标识符，我们将使用它来查找术语向量或字段值。这意味着我们将比较存储在Lucene索引中的实体状态。如果无法检索标识符（例如，如果实体尚未持久化），我们将查看每个实体属性以找到最有意义的术语。后者速度较慢，不会获得最佳效果-尽可能避免。</p>
</div>
<div class="paragraph">
<p>这是您传递要与之比较的实体实例的方式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Coffee coffee = ...; //managed entity from somewhere

Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，结果位于您要与之进行比较的实体的顶部。这对于比较相对分数特别有用。如果不需要，可以将其排除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .excludeEntityUsedForComparison()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以要求Hibernate Search对非常相似的实体给予较高的评分，而对轻微相似的实体给予较低的评分。为此，我们通过提高每个有意义的词的整体得分来做到这一点。从提升因子开始<code>1</code>然后从那里调整。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .favorSignificantTermsWithFactor(1f)
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请记住，更多类似的意思是非常主观的，并且会根据您的数据和域规则而有所不同。通过提供的各种选项，Hibernate Search为您提供了调整此武器的工具。确保根据您的数据集不断测试结果。</p>
</div>
</div>
<div class="sect4">
<h5 id="_combining_queries"><a class="anchor" href="#_combining_queries"></a>合并查询</h5>
<div class="paragraph">
<p>您可以组合查询来创建更复杂的查询。以下聚合运算符可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SHOULD</code> ：查询应包含子查询的匹配元素</p>
</li>
<li>
<p><code>MUST</code> ：查询必须包含子查询的匹配元素</p>
</li>
<li>
<p><code>MUST NOT</code> ：查询中不得包含子查询的匹配元素</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些聚合的作用与经典的布尔运算符相似<code>AND</code> ， <code>OR</code>和<code>NOT</code> ，但使用不同的名称来强调它们会对得分产生影响。</p>
</div>
<div class="paragraph">
<p>例如<code>SHOULD</code>两个查询之间的运算符将具有类似于boolean的效果<code>OR</code> ：如果两个组合查询中的任何一个与条目匹配，则该条目将包含在匹配项中；尽管与两个查询都匹配的条目得分要比仅与其中一个匹配的条目更高。</p>
</div>
<div class="paragraph">
<p>子查询可以是任何Lucene查询，包括布尔查询本身。</p>
</div>
<div class="exampleblock">
<div class="title">例子91。布尔值的结构<code>AND</code>查询： <code>must</code>方法。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例92。布尔值的结构<code>OR</code>查询： <code>should</code>方法。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .should( queryA )
        .should( queryB )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例93。否定查询的结构：应用<code>not</code>修饰符<code>must</code> 。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB ).not()
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们看一些更实际的例子。请注意如何嵌套querybuilder用法以及如何以多种方式组合“应该”，“必须”和“不”：</p>
</div>
<div class="exampleblock">
<div class="title">示例94。结合全文查询的完整示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();

//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();

//look for all myths except religious ones
Query luceneQuery = mythQB
    .all()
      .except( monthQb
        .keyword()
        .onField( "description_stem" )
        .matching( "religion" )
        .createQuery()
      )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_query_options"><a class="anchor" href="#_query_options"></a>查询选项</h5>
<div class="paragraph">
<p>在前面的示例中，我们已经看到了几个查询选项，但是让我们再次总结一下查询类型和字段的选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boostedTo</code> （根据查询类型和字段）：将整个查询或特定字段提升为给定因子</p>
</li>
<li>
<p><code>withConstantScore</code> （针对查询）：与查询匹配的所有结果的得分均等于提升</p>
</li>
<li>
<p><code>filteredBy(Filter)</code> （针对查询）：使用Filter实例过滤查询结果</p>
</li>
<li>
<p><code>ignoreAnalyzer</code> （在字段上）：处理此字段时，请忽略<a href="#analyzer">分析器</a> （或<a href="#section-normalizers">规范化器</a> ）</p>
</li>
<li>
<p><code>ignoreFieldBridge</code> （在字段上）：处理此字段时忽略字段桥接</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们来看一些使用这些选项的示例</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，Hibernate Search查询DSL是一种易于使用且易于阅读的查询API，通过接受和生成Lucene查询，您可以轻松合并DSL（尚不支持）的查询类型。请给我们反馈！</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_building_a_hibernate_search_query"><a class="anchor" href="#_building_a_hibernate_search_query"></a> 5.1.3。建立一个Hibernate Search查询</h4>
<div class="paragraph">
<p>到目前为止，我们仅介绍了如何创建Lucene查询的过程（请参阅<a href="#section-building-lucene-queries">构建查询</a> ）。但是，这只是行动链中的第一步。现在，让我们看看如何从Lucene查询中构建Hibernate Search查询。</p>
</div>
<div class="sect4">
<h5 id="_generality"><a class="anchor" href="#_generality"></a>概论</h5>
<div class="paragraph">
<p>构建Lucene查询后，需要将其包装到Hibernate查询中。如果没有另外指定，查询将针对所有索引实体执行，可能返回所有类型的索引类。</p>
</div>
<div class="exampleblock">
<div class="title">示例95。将Lucene查询包装为Hibernate查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从性能角度来看，建议限制返回的类型：</p>
</div>
<div id="example-filtering-by-entity-type" class="exampleblock">
<div class="title">例子96。按实体类型过滤搜索结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Customer.class);

// or

fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Item.class, Actor.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在<a href="#example-filtering-by-entity-type">按实体类型过滤搜索结果中，</a>第一个示例仅返回匹配项<code>Customer</code>实例，第二个返回匹配<code>Actor</code>和<code>Item</code>实例。类型限制是完全多态的，这意味着如果有两个索引子类<code>Salesman</code>和<code>Customer</code>基类的<code>Person</code> ，可以只指定<code>Person.class</code>为了筛选结果类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="_pagination"><a class="anchor" href="#_pagination"></a>分页</h5>
<div class="paragraph">
<p>出于性能原因，建议限制每个查询返回的对象数。实际上，无论如何，用户从一个页面导航到另一页面都是一个非常常见的用例。定义分页的方法与您在普通HQL或Criteria查询中定义分页的方法完全相同。</p>
</div>
<div class="exampleblock">
<div class="title">示例97。定义搜索查询的分页</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery(luceneQuery, Customer.class);
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不管分页如何，仍然可以通过fulltextQuery.getResultSize（）获得匹配元素的总数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="query-sorting"><a class="anchor" href="#query-sorting"></a>排序</h5>
<div class="paragraph">
<p>Apache Lucene提供了一种非常灵活而强大的方法来对结果进行排序。尽管默认排序（按相关性）在大多数情况下都是适当的，但按一个或几个其他属性进行排序可能很有趣。</p>
</div>
<div class="paragraph">
<p>为此，您必须构建一个Lucene。 <code>Sort</code>对象，可以通过使用“Hibernate搜索”排序DSL或本机Lucene来完成<code>SortField</code>类。</p>
</div>
<div class="paragraph">
<p>如果您使用Hibernate Search排序DSL，它将看起来像这样：</p>
</div>
<div class="exampleblock">
<div class="title">例子98。使用DSL构建的Lucene对结果进行排序<code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author").desc() // Descending order
    .andByField("title") // Default order (ascending)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您使用“排序DSL”（如上面的示例）来定位通过<strong>自定义</strong>索引的字段<code>FieldBridge</code> ，则这些场桥必须实现<a href="#metadata-providing-field-bridge"><code>MetadataProvidingFieldBridge</code></a> ，以便定义这些字段的类型并提及它们是可排序的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>或者，您可以使用Lucene建立排序<code>SortField</code>直接上课。然后，您将必须始终手动指定排序字段类型。</p>
</div>
<div class="exampleblock">
<div class="title">示例99。使用定制的Lucene对结果进行排序<code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("author", SortField.Type.STRING),
    new SortField("title", SortField.Type.STRING));
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，不得对用于排序的字段进行标记化（请参阅<a href="#field-annotation">@Field</a> ）。此外，还应使用<code>@SortableField</code>批注（请参阅<a href="#sortablefield-annotation">@SortableField</a> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_handling_missing_values"><a class="anchor" href="#_handling_missing_values"></a>处理缺失值</h6>
<div class="paragraph">
<p>默认情况下，Hibernate Search会期望每个文档的给定排序字段仅包含一个值。如果不是这种情况，则可以决定是否缺少值的文档将最终出现在结果列表中的第一位还是最后一位：</p>
</div>
<div class="exampleblock">
<div class="title">示例100排序时返回第一个位置缺少值的文档</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author")
      .onMissingValue().sortFirst()
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于数字字段（仅数字字段），您甚至可以提供默认值以防丢失：</p>
</div>
<div class="exampleblock">
<div class="title">示例101在排序字段上使用默认值</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("authorId")
      .onMissingValue().use(42L) // Assume the ID is 42 when it's missing
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>use(Object)</code>方法需要一个与字段的实际类型匹配的值。场桥（如果有） <strong>不</strong>适用。因此，在上面的示例中，提供了<code>Author</code>而不是标识符直接起作用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_using_native_sorts_within_the_sort_dsl"><a class="anchor" href="#_using_native_sorts_within_the_sort_dsl"></a>在排序DSL中使用本机排序</h6>
<div class="paragraph">
<p>如果您偶然发现Lucene支持的排序功能，但尚未在Hibernate Search中实现，请对DSL进行排序。如果是这样，您仍然可以使用DSL来混合本机<code>SortField</code> DSL定义的排序：</p>
</div>
<div class="exampleblock">
<div class="title">例子102。将DSL定义的排序与本机Lucene混合<code>SortField</code> s</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
SortField complexSortField = /* ... */;
Sort sort = builder
  .sort()
    .byField("author")
    .andByNative(complexSortField)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fetching_strategy"><a class="anchor" href="#_fetching_strategy"></a>提取策略</h5>
<div class="paragraph">
<p>当您将返回类型限制为一个类时，Hibernate Search会使用单个查询来加载对象。它还尊重您的域模型中定义的静态获取策略。</p>
</div>
<div class="paragraph">
<p>但是，针对特定用例优化获取策略通常很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例103在查询中指定FetchMode</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Criteria criteria =
    s.createCriteria(Book.class).setFetchMode("authors", FetchMode.JOIN);
s.createFullTextQuery(luceneQuery).setCriteriaQuery(criteria);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，查询将返回与luceneQuery匹配的所有Books。将使用SQL外连接从同一查询中加载authors集合。</p>
</div>
<div class="paragraph">
<p>在定义条件查询时，从全文会话创建Hibernate Search查询时，不必限制返回的实体类型：可以从条件查询本身中猜测类型。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只能调整抓取模式，请勿施加任何其他限制。尽管从Hibernate Search 4开始就可以使用，但应尽可能避免在Criteria查询中使用限制（即where子句）。 <code>getResultSize()</code>会抛出一个<code>SearchException</code>如果与有限制的条件结合使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果期望返回多个实体类型，则不能使用setCriteriaQuery。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="projections"><a class="anchor" href="#projections"></a>投影</h5>
<div class="paragraph">
<p>对于某些用例，返回域对象（包括其关联）是过大的。只需要属性的一小部分。Hibernate Search允许您返回属性的子集：</p>
</div>
<div class="exampleblock">
<div class="title">例子104。使用投影而不是返回整个域对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("id", "summary", "body", "mainAuthor.name");
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate Search从Lucene索引中提取属性，并将其转换回其对象表示形式，并返回<code>Object[]</code> 。投影避免了潜在的数据库往返（如果查询响应时间很关键，则很有用）。但是，它也有一些限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>投影的属性必须存储在索引中（ <code>@Field(store=Store.YES)</code> ），这会增加索引大小</p>
</li>
<li>
<p>预计的属性必须使用<code>FieldBridge</code>实现org.hibernate.search.bridge。TwoWayFieldBridge或<code>org.hibernate.search.bridge.TwoWayStringBridge</code> ，后者是较简单的版本。</p>
</li>
<li>
<p>您只能投影索引实体或其嵌入式关联的简单属性。这意味着您无法投影整个嵌入式实体。</p>
</li>
<li>
<p>投影不适用于通过索引的馆藏或地图<code>@IndexedEmbedded</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>投影对于另一种用例也很有用。Lucene可以提供有关结果的元数据信息。通过使用一些特殊的投影常量，投影机制可以检索以下元数据：</p>
</div>
<div class="exampleblock">
<div class="title">例子105。使用投影以检索元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection(
    FullTextQuery.SCORE,
    FullTextQuery.THIS,
    "mainAuthor.name" );
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以混合并匹配常规字段和投影常量。这是可用常量的列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FullTextQuery.THIS</code> ：返回已初始化和托管的实体（就像非计划查询一样）。</p>
</li>
<li>
<p><code>FullTextQuery.DOCUMENT</code> ：返回与投影对象有关的Lucene文档。</p>
</li>
<li>
<p><code>FullTextQuery.OBJECT_CLASS</code> ：返回索引实体的类。</p>
</li>
<li>
<p><code>FullTextQuery.SCORE</code> ：返回查询中的文档分数。对于给定的查询，将分数与另一个结果进行比较很方便，但是在比较不同查询的结果时，分数是没有用的。</p>
</li>
<li>
<p><code>FullTextQuery.ID</code> ：投影对象的id属性值。</p>
</li>
<li>
<p><code>FullTextQuery.DOCUMENT_ID</code> ：Lucene文档ID。小心，Lucene文档ID可能会在两个不同的IndexReader打开之间随时间变化。</p>
</li>
<li>
<p><code>FullTextQuery.EXPLANATION</code> ：返回给定查询中匹配对象/文档的Lucene解释对象。如果您检索大量数据，请不要使用。运行解释通常与每个匹配元素运行整个Lucene查询一样昂贵。确保使用投影！</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_customizing_object_initialization_strategies"><a class="anchor" href="#_customizing_object_initialization_strategies"></a>自定义对象初始化策略</h5>
<div class="paragraph">
<p>默认情况下，Hibernate Search使用最合适的策略来初始化与您的全文查询匹配的实体。它执行一个（或几个）查询以检索所需的实体。这是在持久性上下文（即会话）或第二级高速缓存中不存在/仅有少量检索到的实体的情况下最大程度地减少数据库往返次数的最佳方法。</p>
</div>
<div class="paragraph">
<p>如果您的大多数实体都存在于二级缓存中，则可以强制Hibernate Search在从数据库中检索对象之前先查询缓存。</p>
</div>
<div class="exampleblock">
<div class="title">例子106。使用查询之前，请检查二级缓存</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ObjectLookupMethod</code>定义用于检查对象是否易于访问（无需数据库往返）的策略。其他选项是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ObjectLookupMethod.PERSISTENCE_CONTEXT</code> ：如果大多数匹配实体已经在持久性上下文中（即在Session或EntityManager中加载），则很有用</p>
</li>
<li>
<p><code>ObjectLookupMethod.SECOND_LEVEL_CACHE</code> ：首先检查持久性上下文，然后检查第二级缓存。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，要在第二级缓存中进行搜索，必须有几个设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第二级缓存必须正确配置并处于活动状态</p>
</li>
<li>
<p>实体必须启用了二级缓存（例如，通过<code>@Cacheable</code> ）</p>
</li>
<li>
<p>的<code>Session</code> ， <code>EntityManager</code>要么<code>Query</code>必须允许访问二级缓存以进行读取访问（即<code>CacheMode.NORMAL</code>在Hibernate本机API中或<code>CacheRetrieveMode.USE</code>在JPA 2 API中）。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>避免使用<code>ObjectLookupMethod.SECOND_LEVEL_CACHE</code>除非您的二级缓存实现是EHCache或Infinispan；其他二级缓存提供程序当前无法有效实现此操作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以自定义如何从数据库加载对象（如果以前找不到）。使用<code>DatabaseRetrievalMethod</code>为了那个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QUERY</code> （默认）：使用（一组）查询批量加载多个对象。这通常是最好的方法。</p>
</li>
<li>
<p><code>FIND_BY_ID</code> ：使用逐一加载对象<code>Session.get</code>要么<code>EntityManager.find</code>语义。如果在实体上设置了批处理大小，这可能会很有用（在这种情况下，实体将由Hibernate Core批量加载）。几乎所有时候都应该优先选择QUERY。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两种方法，对象查找以及数据库检索的默认值也可以通过配置属性进行配置。这样，您不必在每次查询创建时都指定首选方法。属性名称是<code>hibernate.search.query.object_lookup_method</code>和<code>hibernate.search.query.database_retrieval_method</code>分别。作为值，请使用方法的名称（大写或小写）。例如：</p>
</div>
<div class="exampleblock">
<div class="title">例子107。通过配置属性设置对象查找和数据库检索方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.query.object_lookup_method = second_level_cache
hibernate.search.query.database_retrieval_method = query</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_limiting_the_time_of_a_query"><a class="anchor" href="#_limiting_the_time_of_a_query"></a>限制查询时间</h5>
<div class="paragraph">
<p>您可以通过两种方式限制查询在Hibernate Search中花费的时间：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>达到限制时引发异常</p>
</li>
<li>
<p>限制时间限制时检索到的结果数</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_raise_an_exception_on_time_limit"><a class="anchor" href="#_raise_an_exception_on_time_limit"></a>在时间限制上引发例外</h6>
<div class="paragraph">
<p>如果花费的时间超过预定义的时间，则可以决定停止查询。请注意，这是尽力而为的基础，但是如果Hibernate Search仍有大量工作要做，并且如果我们超出了时间限制，则将引发QueryTimeoutException（org.hibernate。QueryTimeoutException或javax.persistence。QueryTimeoutException取决于您的编程API）。</p>
</div>
<div class="paragraph">
<p>要在使用本地Hibernate API时定义限制，请使用以下方法之一</p>
</div>
<div class="exampleblock">
<div class="title">示例108。在查询执行中定义超时</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样地<code>getResultSize()</code> ， <code>iterate()</code>和<code>scroll()</code>遵守超时，但仅直到方法调用结束为止。这只是意味着Iterable或ScrollableResults的方法将忽略超时。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>explain()</code>不遵守超时：此方法用于调试目的，尤其是找出查询缓慢的原因</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用JPA时，只需使用限制查询执行时间的标准方法即可。</p>
</div>
<div class="exampleblock">
<div class="title">示例109在查询执行中定义超时</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住，这是一种尽力而为的方法，不能保证完全在指定的超时后停止。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_limit_the_number_of_results_when_the_time_limit_is_reached"><a class="anchor" href="#_limit_the_number_of_results_when_the_time_limit_is_reached"></a>达到时间限制时限制结果数</h6>
<div class="paragraph">
<p>或者，您可以返回达到限制时已获取的结果数。请注意，此限制仅影响查询的Lucene部分。如果您检索托管对象，则获取这些对象的时间可能会更长。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此方法与setTimeout方法不兼容。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要定义此软限制，请使用以下方法</p>
</div>
<div class="exampleblock">
<div class="title">例子110。在查询执行中定义时间限制</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样地<code>getResultSize()</code> ， <code>iterate()</code>和<code>scroll()</code>遵守时间限制，但只能直到方法调用结束。这只是意味着Iterable或<code>ScrollableResults</code>忽略超时。</p>
</div>
<div class="paragraph">
<p>您可以通过调用以下命令确定结果是否已部分加载<code>hasPartialResults</code>方法。</p>
</div>
<div class="exampleblock">
<div class="title">例子111。确定查询何时返回部分结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();

if ( query.hasPartialResults() ) {
    displayWarningToUser();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用JPA API，limitExecutionTimeTo和hasPartialResults也可供您使用。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_the_results"><a class="anchor" href="#_retrieving_the_results"></a> 5.2。检索结果</h3>
<div class="paragraph">
<p>建立Hibernate Search查询后，执行它与执行HQL或Criteria查询没有什么不同。相同的范例和对象语义适用。所有常用操作均可用： <code>list()</code> ， <code>uniqueResult()</code> ， <code>iterate()</code> ， <code>scroll()</code> 。</p>
</div>
<div class="sect3">
<h4 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a> 5.2.1。性能考量</h4>
<div class="paragraph">
<p>如果您希望获得合理数量的结果（例如使用分页），并希望对所有结果都可以使用， <code>list()</code>要么<code>uniqueResult()</code>推荐。 <code>list()</code>如果实体最有效<code>batch-size</code>设置正确。注意，使用时，Hibernate Search必须处理所有Lucene Hits元素（在分页内） <code>list()</code> ， <code>uniqueResult()</code>和<code>iterate()</code> 。</p>
</div>
<div class="paragraph">
<p>如果您希望减少Lucene文档的加载， <code>scroll()</code>比较合适。别忘了关闭<code>ScrollableResults</code>完成后，对象将保留，因为它保留了Lucene资源。如果您希望使用滚动条，但希望批量加载对象，则可以使用<code>query.setFetchSize()</code> 。访问对象时，如果尚未加载，则Hibernate Search将加载下一个对象。 <code>fetchSize</code>物体一口气。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>分页优先于滚动。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_result_size"><a class="anchor" href="#_result_size"></a> 5.2.2。结果大小</h4>
<div class="paragraph">
<p>了解匹配文档的总数有时会很有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类似Google的功能“约888,000,000的1-10”</p>
</li>
<li>
<p>实现快速分页导航</p>
</li>
<li>
<p>实现多步搜索引擎（如果受限查询未返回结果或返回的结果不足，则添加近似值）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然，检索所有匹配的文档将太昂贵。Hibernate Search允许您检索匹配文档的总数，而不考虑分页参数。更有趣的是，您可以检索匹配元素的数量而无需触发单个对象加载。</p>
</div>
<div class="exampleblock">
<div class="title">例子112。确定查询的结果大小</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
//return the number of matching books without loading a single one
assert 3245 == query.getResultSize();

org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == query.getResultSize();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与Google一样，如果索引不是数据库的最新信息（例如，异步集群），则结果数是一个近似值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_resulttransformer"><a class="anchor" href="#_resulttransformer"></a> 5.2.3。结果转换器</h4>
<div class="paragraph">
<p>如<a href="#projections">Projection中</a>所示， <a href="#projections">投影</a>结果以Object数组形式返回。这种数据结构并不总是符合应用程序的需求。在这种情况下，可以应用ResultTransformer，该查询在执行查询后可以构建所需的数据结构：</p>
</div>
<div class="exampleblock">
<div class="title">示例113。结合使用ResultTransformer和投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("title", "mainAuthor.name");

query.setResultTransformer(
    new StaticAliasToBeanResultTransformer(
        BookView.class,
        "title",
        "author" )
);
ListBookView&gt;; results = (List&lt;BookView&gt;) query.list();
for (BookView view : results) {
    log.info("Book: " + view.getTitle() + ", " + view.getAuthor());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以在Hibernate Core代码库中找到ResultTransformer实现的示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_understanding_results"><a class="anchor" href="#_understanding_results"></a> 5.2.4。了解结果</h4>
<div class="paragraph">
<p>您有时会发现自己对查询中显示的结果或查询中未显示的结果感到困惑。卢克（Luke）是了解这些奥秘的好工具。但是，Hibernate Search还允许您访问给定结果（在给定查询中）的Lucene解释对象。此类对于Lucene用户而言是相当高级的，但是可以很好地理解对象的评分。您可以通过两种方式访问给定结果的解释对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用fullTextQuery.explain（int）方法</p>
</li>
<li>
<p>使用投影</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一种方法将文档ID作为参数并返回解释对象。可以使用projection和<code>FullTextQuery.DOCUMENT_ID</code>不变。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>文档ID与实体ID无关。不要弄乱这两个概念。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在第二种方法中，您可以使用<code>FullTextQuery.EXPLANATION</code>不变。</p>
</div>
<div class="exampleblock">
<div class="title">示例114。使用投影检索Lucene解释对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection(
             FullTextQuery.DOCUMENT_ID,
             FullTextQuery.EXPLANATION,
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，构建说明对象非常昂贵，大约与再次运行Lucene查询一样昂贵。如果您不需要该对象，请不要这样做</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-filter"><a class="anchor" href="#query-filter"></a> 5.3。筛选器</h3>
<div class="sect3">
<h4 id="query-filter-fulltext"><a class="anchor" href="#query-filter-fulltext"></a> 5.3.1。全文过滤器</h4>
<div class="paragraph">
<p>Apache Lucene具有强大的功能，可以根据自定义过滤过程过滤查询结果。这是施加附加数据限制的一种非常有效的方法，特别是因为可以缓存和重用过滤器。一些有趣的用例是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>安全</p>
</li>
<li>
<p>时间数据（例如，仅查看上个月的数据）</p>
</li>
<li>
<p>人口筛选器（例如，搜索仅限于给定类别）</p>
</li>
<li>
<p>还有很多</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hibernate Search通过引入可参数化的命名过滤器（透明缓存）的概念进一步推动了这一概念。对于熟悉Hibernate Core过滤器概念的人们，该API非常相似：</p>
</div>
<div class="exampleblock">
<div class="title">示例115。为给定查询启用全文过滤器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter("login", "andre");
fullTextQuery.list(); //returns only best drivers where andre has credentials</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们在查询顶部启用了两个过滤器。您可以启用（或禁用）任意数量的过滤器。</p>
</div>
<div class="paragraph">
<p>声明过滤器是通过<code>@FullTextFilterDef</code>注解。您可以使用一个或多个<code>@FullTextFilterDef</code>任何： * <code>@Indexed</code>实体，而不管查询将随后应用于过滤器的哪个*父类<code>@Indexed</code>实体*包含以下内容的软件包的package-info.java <code>@Indexed</code>实体</p>
</div>
<div class="paragraph">
<p>这意味着过滤器定义是全局的，并且它们的名称必须唯一。一种<code>SearchException</code>在两个不同的情况下抛出<code>@FullTextFilterDef</code>定义了具有相同名称的注释。每个命名的过滤器都必须指定一种检索实际过滤器实现的方法。</p>
</div>
<div class="exampleblock">
<div class="title">示例116。定义和实现过滤器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)
public class Driver { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BestDriversFilterFactory {

    @org.hibernate.search.annotations.Factory
    public Query create() {
        return new TermQuery( new Term( "score", "5" ) );
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BestDriversFilterFactory</code>是一个简单的Lucene过滤器的示例，该过滤器将结果集简化为得分为5的驱动程序。在此示例中，我们使用工厂模式：分配给<code>@FullTextFilterDef.impl</code>是工厂类，实际的过滤器将由<code>@Factory</code>此类的带注释的无参数方法。确保工厂具有不需要任何参数的公共构造函数。</p>
</div>
<div class="paragraph">
<p>或者，您可以分配给<code>@FullTextFilterDef.impl</code>过滤器的确切类型，即扩展的类<code>org.apache.lucene.search.Query</code> 。该类仍然必须提供一个公共的，无参数的构造函数。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在以前的Hibernate Search版本中，过滤器必须扩展<code>org.apache.lucene.search.Filter</code>输入而不是<code>org.apache.lucene.search.Query</code> 。</p>
</div>
<div class="paragraph">
<p>仍然支持，但是<code>Filter</code> type已被弃用，并将在以后的Lucene版本中删除。</p>
</div>
<div class="paragraph">
<p>因此，建议您转换现有的过滤器和过滤器工厂，以免依赖于<code>org.apache.lucene.search.Filter</code>键入，并改用简单查询。应该有一个<code>Query</code>相当于每个<code>Filter</code>子类型： <code>TermQuery</code>取代<code>TermFilter</code> ， <code>BooleanQuery</code>取代<code>BooleanFilter</code>等</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在必须将参数传递到过滤器的地方，命名过滤器会派上用场。例如，安全过滤器可能想知道您要应用的安全级别：</p>
</div>
<div class="exampleblock">
<div class="title">示例117将参数传递到已定义的过滤器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("security").setParameter("level", 5);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每个参数必须在目标命名过滤器定义的过滤器或过滤器工厂上具有关联的设置器。</p>
</div>
<div class="exampleblock">
<div class="title">例子118。在实际的过滤器实现中使用参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    public void setLevel(Integer level) {
        this.level = level;
    }

    @Factory
    public Query getFilter() {
        return new TermQuery( new Term( "level", level.toString() ) );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>过滤器一旦创建，将根据其所有参数名称和值进行缓存。通过使用硬引用和软引用的组合来进行缓存，以在需要时处置内存。硬引用缓存跟踪最近使用的过滤器，并在需要时将最不常用的过滤器转换为SoftReferences。一旦达到硬引用缓存的限制，就会将其他过滤器缓存为SoftReferences。要调整硬引用缓存的大小，请使用<code>hibernate.search.filter.cache_strategy.size</code> （默认为128）。为了更高级地使用过滤器缓存，您可以实现自己的FilterCachingStrategy。类名由<code>hibernate.search.filter.cache_strategy</code> 。</p>
</div>
<div class="paragraph">
<p>此过滤器缓存机制不应与缓存实际过滤器结果混淆。在Lucene中，通常的做法是使用IndexReader将过滤器包装在<code>CachingWrapperQuery</code> 。包装器将缓存匹配的文档集，以避免昂贵的重新计算。值得一提的是，计算出的匹配文档集仅可用于同一IndexReader实例，因为阅读器有效地表示了打开索引时的状态。在打开的文档列表中不能更改文档列表<code>IndexReader</code> 。不同/新<code>IndexReader</code>但是，实例可能对不同的文档集起作用（或者来自不同的索引，或者仅仅是因为索引已更改），因此必须重新计算过滤器结果。</p>
</div>
<div class="paragraph">
<p>Hibernate Search在缓存方面也有帮助。默认情况下<code>cache</code>的标志<code>@FullTextFilterDef</code>被设定为<code>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code>它将自动缓存过滤器实例，并将指定的过滤器包装在Hibernate特定于的实现周围<code>CachingWrapperQuery</code> 。与Lucene的此类比较<code>SoftReferences</code>与硬引用计数一起使用（请参阅有关过滤器缓存的讨论）。硬参考计数可以使用<code>hibernate.search.filter.cache_docidresults.size</code> （默认为5）。包装行为可以使用<code>@FullTextFilterDef.cache</code>参数。此参数有三个不同的值：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType。没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate Search没有过滤器实例，也没有缓存任何结果。对于每个过滤器调用，都会创建一个新的过滤器实例。此设置对于快速更改数据集或内存受限的环境可能很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType。INSTANCE_ONLY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过滤器实例在并发过滤器调用之间进行缓存和重用。筛选结果未缓存。当过滤器使用其自己的特定缓存机制或由于应用程序特定的事件导致过滤器结果动态变化而使得在两种情况下都不需要过滤器结果缓存时，此设置很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType。INSTANCE_AND_DOCIDSETRESULTS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过滤器实例和过滤器结果均被缓存。这是默认值。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>最后但并非最不重要的-为什么要缓存过滤器？过滤器缓存在两个方面发挥作用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>系统不会经常更新目标实体索引（换句话说，IndexReader被大量重用）</p>
</li>
<li>
<p>过滤器的结果计算起来很昂贵（与执行查询所花费的时间相比）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="query-filter-shard"><a class="anchor" href="#query-filter-shard"></a> 5.3.2。在分片环境中使用过滤器</h4>
<div class="paragraph">
<p>在分片环境中，可以对可用分片的子集执行查询。这可以分两个步骤完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个分片策略，该策略根据某些过滤器配置选择一个IndexManagers子集</p>
</li>
<li>
<p>在查询时激活适当的过滤器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>首先，让我们看一个分片策略的示例，该示例在激活了客户过滤器后查询特定的客户分片。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CustomerShardingStrategy implements IndexShardingStrategy {

 // stored IndexManagers in a array indexed by customerID
 private IndexManager[] indexManagers;

 public void initialize(Properties properties, IndexManager[] indexManagers) {
   this.indexManagers = indexManagers;
 }

 public IndexManager[] getIndexManagersForAllShards() {
   return indexManagers;
 }

 public IndexManager getIndexManagerForAddition(
     Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
   Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
   return indexManagers[customerID];
 }

 public IndexManager[] getIndexManagersForDeletion(
     Class&lt;?&gt; entity, Serializable id, String idInString) {
   return getIndexManagersForAllShards();
 }

  /**
  * Optimization; don't search ALL shards and union the results; in this case, we
  * can be certain that all the data for a particular customer Filter is in a single
  * shard; simply return that shard by customerID.
  */
 public IndexManager[] getIndexManagersForQuery(
     FullTextFilterImplementor[] filters) {
   FullTextFilter filter = getCustomerFilter(filters, "customer");
   if (filter == null) {
     return getIndexManagersForAllShards();
   }
   else {
     return new IndexManager[] { indexManagers[Integer.parseInt(
       filter.getParameter("customerID").toString())] };
   }
 }

 private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
   for (FullTextFilterImplementor filter: filters) {
     if (filter.getName().equals(name)) return filter;
   }
   return null;
 }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，如果过滤器名为<code>customer</code>存在时，我们确保仅使用专用于该客户的分片。否则，我们将返回所有碎片。给定的分片策略可以对一个或多个过滤器做出反应，并取决于它们的参数。</p>
</div>
<div class="paragraph">
<p>第二步只是在查询时激活过滤器。虽然该过滤器可以是常规过滤器（如“ <a href="#query-filter-fulltext">全文过滤器”中</a>所定义），它也可以在查询后过滤Lucene结果，但是您可以使用特殊过滤器，该过滤器仅会传递给分片策略，否则将被忽略查询。只需使用<code>ShardSensitiveOnlyFilter</code>声明过滤器时的类。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)
public class Customer {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
query.enableFulltextFilter("customer").setParameter("CustomerID", 5);
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，通过使用<code>ShardSensitiveOnlyFilter</code> ，则无需实现任何Lucene过滤器。建议使用过滤器和分片策略对这些过滤器做出反应，以加快分片环境中的查询。</p>
</div>
</div>
<div class="sect3">
<h4 id="query-filter-orm"><a class="anchor" href="#query-filter-orm"></a> 5.3.3。HibernateORM过滤器</h4>
<div class="paragraph">
<p>HibernateORM过滤器，使用<code>org.hibernate.Session.enableFilter(String)</code> ，仅在与全文查询结合使用时才部分起作用。</p>
</div>
<div class="paragraph">
<p>过滤的实体将从结果中排除，但：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>返回的结果大小<code>FullTextQuery.getResultSize()</code>将忽略过滤器（将在应用过滤器之前返回大小）；</p>
</li>
<li>
<p>如果您使用分页， <code>setFirstResult</code>和<code>setMaxResults</code>修饰符将在过滤器之前应用，导致某些结果页小于<code>maxResults</code> （甚至是空的），即使它们不是最后一个。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些限制对于将性能保持在合理水平是必要的。如果您的用例不接受它们，则应在全文查询中使用<a href="#query-filter-fulltext">全文过滤器</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-faceting"><a class="anchor" href="#query-faceting"></a> 5.4。刻面</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Faceted_search">分面搜索</a>是一种允许将查询结果分为多个类别的技术。此分类包括计算每个类别的命中数，以及基于这些方面（类别）进一步限制搜索结果的能力。<a href="#example-amazon-facets">Amazon上的方面示例</a>显示了一个方面示例。搜索“Hibernate搜索”会产生15个匹配，这些匹配显示在页面的主要部分上。但是，左侧的导航栏显示类别为<em>计算机和Internet</em> ，其子类别为<em>编程</em> ， <em>计算机科学</em> ， <em>数据库</em> ， <em>软件</em> ， <em>Web开发，</em> <em>网络</em>和<em>家庭计算</em> 。对于这些子类别中的每一个，显示的图书数量均与主要搜索条件相匹配，并且属于相应的子类别。此类别的<em>计算机和Internet</em>是该搜索的一个方面。另一个是例如平均客户评论评分。</p>
</div>
<div id="example-amazon-facets" class="imageblock">
<div class="content">
<img src="images/faceting.png" alt="在亚马逊上搜索_'Hibernate Search'_">
</div>
<div class="title">图1。亚马逊方面的方面示例</div>
</div>
<div class="paragraph">
<p>在Hibernate中搜索类<code>QueryBuilder</code>和<code>FullTextQuery</code>是构面API的入口点。前者允许创建构面请求，而后者允许访问所谓的<code>FacetManager</code> 。借助<code>FacetManager</code>构面请求可以应用于查询，并且所选构面可以添加到现有查询中，以优化搜索结果。以下各节将更详细地介绍构面过程。这些示例将使用实体<code>Cd</code>如<a href="#example-faceting-entity">示例实体</a>所示：</p>
</div>
<div id="example-faceting-entity" class="exampleblock">
<div class="title">示例119。构面示例实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Cd {

    @Id
    @GeneratedValue
    private int id;

    @Field,
    private String name;

    @Field(analyze = Analyze.NO)
    @Facet
    private int price;

    @Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    @Facet
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    @Facet
    private String label;


// setter/getter
// ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了了解给定的索引字段，需要使用<code>@Facet</code>注解。而且，该领域本身无法分析。</p>
</div>
<div class="paragraph">
<p><code>@Facet</code>包含一个<code>name</code>和<code>forField</code>参数。的<code>name</code>是任意的，用于标识构面。默认情况下，它与它所属的字段名称匹配。 <code>forField</code>如果属性使用以下方式映射到多个字段，则相关<code>@Field</code>多次，因为它是可重复的注释。在这种情况下<code>forField</code>可以用来标识它适用的索引字段。都<code>@Field</code>和<code>@Facet</code>是可重复的注释。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的， <code>@Facet</code>包含一个<code>encoding</code>参数。通常，Hibernate Search会自动选择编码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字符串字段编码为<code>FacetEncodingType.STRING</code></p>
</li>
<li>
<p><code>byte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> （包括相应的包装器类型）和<code>Date</code>如<code>FacetEncodingType.LONG</code></p>
</li>
<li>
<p>和<code>float</code>和<code>double</code> （包括相应的包装器类型）为<code>FacetEncodingType.DOUBLE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，在某些情况下，显式设置编码是有意义的。
例如， <a href="#discrete-faceting-request">离散</a>构<a href="#discrete-faceting-request">面请求</a>仅适用于字符串编码的构面。为了将离散面用于数字，必须将编码明确设置为<code>FacetEncodingType.STRING</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在Hibernate Search 5.2之前的版本中，无需显式使用<code>@Facet</code>注解。在5.2中，有必要使用Lucene的本机Facet API。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="section-creating-faceting-request"><a class="anchor" href="#section-creating-faceting-request"></a> 5.4.1。创建构面请求</h4>
<div class="paragraph">
<p>进行多面搜索的第一步是创建<code>FacetingRequest</code> 。当前支持两种类型的构面请求。第一种称为<em>离散构面</em> ，第二种称为<em>范围构面</em>请求。</p>
</div>
<div class="sect4">
<h5 id="discrete-faceting-request"><a class="anchor" href="#discrete-faceting-request"></a>离散构面请求</h5>
<div class="paragraph">
<p>对于离散的构面请求，首先要给请求指定一个唯一的名称。稍后将使用该名称来检索构面值（请参阅<a href="#section-interpreting-facet-result">解释</a>构<a href="#section-interpreting-facet-result">面结果</a> ）。然后，您需要指定要在哪个索引字段上进行分类以及要应用哪些构面选项。<a href="#example-discrete-faceting">创建离散构面请求</a>的示例可以在<a href="#example-discrete-faceting">创建离散构面请求中</a>看到：</p>
</div>
<div id="example-discrete-faceting" class="exampleblock">
<div class="title">例子120。创建离散的构面请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Cd.class).get();

FacetingRequest labelFacetingRequest = builder.facet()
    .name("labelFacetRequest")
    .onField("label")
    .discrete()
    .orderedBy(FacetSortOrder.COUNT_DESC)
    .includeZeroCounts(false)
    .maxFacetCount(3)
    .createFacetingRequest();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>执行此构面请求时， <code>Facet</code>将为索引字段的每个离散值创建一个实例<code>label</code> 。的<code>Facet</code>实例将记录实际字段值，包括该特定字段值在原始查询结果中出现的频率。参量<code>orderedBy</code> ， <code>includeZeroCounts</code>和<code>maxFacetCount</code>是可选的，可以应用于任何构面请求。参数<code>orderedBy</code>允许指定以什么顺序返回创建的构面。默认是<code>FacetSortOrder.COUNT_DESC</code> ，但您也可以对字段值进行排序。参数<code>includeZeroCount</code>确定是否将计数为0的构面包含在结果中（默认情况下不包含），并<code>maxFacetCount</code>允许限制返回的构面的最大数量（默认情况下，返回100个构面）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要对索引字段进行分类（构面），必须满足几个先决条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引属性必须是类型<code>String</code> ， <code>Date</code>或数字类型为byte，shirt，int，long，double或float（或它们各自的Java包装器类型）。</p>
</li>
<li>
<p>该属性必须使用Analyze进行索引。没有。</p>
</li>
<li>
<p>应避免使用<em>空</em>值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您需要冲突的选项时，我们建议对属性进行两次索引，并根据用例使用适当的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Field(name="price")
@Field(name="price_facet",
       analyze=Analyze.NO,
       bridge=@FieldBridge(impl = IntegerBridge.class))
private int price;</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="range-faceting-request"><a class="anchor" href="#range-faceting-request"></a>创建范围构面请求</h5>
<div class="paragraph">
<p>范围构面请求的创建类似。我们还从请求的名称和要关注的字段开始。然后，我们必须指定字段值的范围。在<a href="#example-range-faceting">创建</a>范围构面请求中可以看到<a href="#example-range-faceting">范围构面请求</a> 。在那里，指定了三个不同的价格范围。<code>below</code>和<code>above</code>只能指定一次，但是您可以指定多个<code>from</code> -- <code>to</code>您想要的范围。对于每个范围边界，您还可以通过<code>excludeLimit</code>是否包含在范围内。</p>
</div>
<div id="example-range-faceting" class="exampleblock">
<div class="title">示例121。创建范围构面请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity(Cd.class)
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name("priceFaceting")
    .onField("price_facet")
    .range()
    .below(1000)
    .from(1001).to(1500)
    .above(1500).excludeLimit()
    .createFacetingRequest();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-sorting-faceting-request"><a class="anchor" href="#section-sorting-faceting-request"></a> 5.4.2。设定构面排序顺序</h4>
<div class="paragraph">
<p>应用构面请求的结果是<code>Facet</code>如<a href="#example-applying-faceting">应用构面请求所示</a> 。列表中的顺序由<code>FacetSortOrder</code>通过指定的参数<code>orderedBy</code>创建构面请求时。默认值为<code>FacetSortOrder.COUNT_DESC</code> ，表示构面按其计数从高到低排序（从最高计数开始）。其他值是<code>COUNT_ASC</code> ， <code>FIELD_VALUE</code>和<code>RANGE_DEFINITION_ORDER</code> 。<code>COUNT_ASC</code>以递增计数顺序返回构面，而<code>FIELD_VALUE</code>将按构面/类别值的字母顺序返回它们（请参阅<a href="#section-interpreting-facet-result">解释</a>构<a href="#section-interpreting-facet-result">面结果</a> ）。
<code>RANGE_DEFINITION_ORDER</code>仅适用于范围构面请求，并以定义范围的相同顺序返回构面。对于<a href="#example-range-faceting">创建范围</a>构<a href="#example-range-faceting">面请求，</a>这意味着将首先返回小于1000范围的构面，然后返回1001到1500范围的构面，最后是大于1500的构面。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-applying-faceting-request"><a class="anchor" href="#section-applying-faceting-request"></a> 5.4.3。应用构面请求</h4>
<div class="paragraph">
<p>在<a href="#section-creating-faceting-request">创建构面请求中，</a>我们了解了如何创建构面请求。现在是时候将其应用于查询了。关键是<code>FacetManager</code>可以通过<code>FullTextQuery</code> （请参阅<a href="#example-applying-faceting">应用构面请求</a> ）。</p>
</div>
<div id="example-applying-faceting" class="exampleblock">
<div class="title">例子122。应用构面请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery, Cd.class);

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting(priceFacetingRequest);

// get the list of Cds
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets("priceFaceting");
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您需要先启用构面请求，然后才能执行查询。您通过<code>facetManager.enableFaceting(<facetName>)</code> 。您可以根据需要启用任意多个构面请求。然后，您执行查询并通过检索给定请求的构面结果<code>facetManager.getFacets(<facetname>)</code> 。对于每个请求，您将获得以下列表： <code>Facet</code>实例。构面请求保持活动状态并应用于全文查询，直到通过显式禁用它们为止<code>disableFaceting(<facetName>)</code>或查询是<code>discarded</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="section-interpreting-facet-result"><a class="anchor" href="#section-interpreting-facet-result"></a> 5.4.4。解释构面结果</h4>
<div class="paragraph">
<p>每个方面请求都会产生一个列表<code>Facet</code>实例。每个实例代表一个构面/类别值。在我们要在CD标签上进行分类的CD示例（ <a href="#example-discrete-faceting">创建离散构面请求</a> ）中，例如<code>Facet</code>唱片公司环球唱片公司，索尼唱片公司和华纳唱片公司。
<a href="#example-facet-api">Facet API</a>显示<a href="#example-facet-api">Facet的API</a> 。</p>
</div>
<div id="example-facet-api" class="exampleblock">
<div class="title">示例123方面API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface Facet {
    /**
     * @return the faceting name this {@code Facet} belongs to.
     *
     * @see org.hibernate.search.query.facet.FacetingRequest#getFacetingName()
     */
    String getFacetingName();

    /**
     * Return the {@code Document} field name this facet is targeting.
     * The field needs to be indexed with {@code Analyze.NO}.
     *
     * @return the {@code Document} field name this facet is targeting.
     */
    String getFieldName();

    /**
     * @return the value of this facet. In case of a discrete facet it is the actual
     *         {@code Document} field value. In case of a range query the value is a
     *         string representation of the range.
     */
    String getValue();

    /**
     * @return the facet count.
     */
    int getCount();

    /**
     * @return a Lucene {@link Query} which can be executed to retrieve all
     *         documents matching the value of this facet.
     */
    Query getFacetQuery();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>getFacetingName()</code>和<code>getFieldName()</code>返回底层要求指定的构面请求名称和目标文档字段名称<code>FacetRequest</code> 。例如，“ <a href="#example-discrete-faceting">创建离散的构面请求</a> ”将是<code>labelFacetRequest</code>和<code>label</code>分别。有趣的信息是由<code>getValue()</code>和<code>getCount()</code> 。前者是实际构面/类别值，例如，像Universal这样的具体记录标签。后者返回此值的计数。再次坚持该示例，计数值告诉您在“通用”标签下释放了多少CD。最后但并非最不重要的， <code>getFacetQuery()</code>返回一个Lucene查询，该查询可用于检索此构面中计数的实体。</p>
</div>
</div>
<div class="sect3">
<h4 id="_restricting_query_results"><a class="anchor" href="#_restricting_query_results"></a> 5.4.5。限制查询结果</h4>
<div class="paragraph">
<p>构面的常见用例是“向下钻取”功能，该功能允许您通过在其上应用给定构面来缩小原始搜索范围。为此，您可以应用任何返回的<code>Facet</code>实例作为原始查询中通过的其他条件<code>FacetSelection</code> 。<code>FacetSelection</code>可通过<code>FacetManager</code>并允许您选择构面作为查询条件（ <code>selectFacets</code> ），删除方面限制（ <code>deselectFacets</code> ），删除所有方面的限制（ <code>clearSelectedFacets</code> ）并检索所有当前选择的构面（ <code>getSelectedFacets</code> ）。<a href="#example-restricting-query-results">通过应用一个查询来限制查询结果<code>FacetSelection</code></a>显示一个示例。</p>
</div>
<div id="example-restricting-query-results" class="exampleblock">
<div class="title">例子124。通过应用一个查询来限制查询结果<code>FacetSelection</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
FacetSelection facetSelection = facetManager.getFacetGroup( "priceFaceting" );
facetSelection.selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，选定的构面通过相加（OR）合并。如果一个字段具有多个值，例如势<code>Cd.artists</code>关联，您也可以将连词（AND）用于构面选择。</p>
</div>
<div id="example-using-conjunction-restricting-query-results" class="exampleblock">
<div class="title">示例125在中使用连词<code>FacetSelection</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FacetSelection facetSelection = facetManager.getFacetGroup( "artistsFaceting" );
facetSelection.selectFacets( FacetCombine.AND, facets.get( 0 ), facets.get( 1 ) );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimizing_the_query_process"><a class="anchor" href="#_optimizing_the_query_process"></a> 5.5。优化查询过程</h3>
<div class="paragraph">
<p>查询性能取决于以下几个条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lucene查询本身：请阅读有关该主题的文献。</p>
</li>
<li>
<p>加载对象的数量：使用分页和/或索引投影（如果需要）。</p>
</li>
<li>
<p>Hibernate Search与Lucene读者互动的方式：定义适当的<a href="#search-architecture-readerstrategy">Reader策略</a> 。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="query-logging"><a class="anchor" href="#query-logging"></a> 5.5.1。记录执行的搜索查询</h4>
<div class="paragraph">
<p>在进行性能优化时，了解执行的搜索查询至关重要。如果您的应用程序接受用户传递的查询，或者例如使用Hibernate Search查询DSL动态构建查询，则尤其如此。</p>
</div>
<div class="paragraph">
<p>为了记录所有由Hibernate Search执行的搜索查询，请启用<code>DEBUG</code>记录日志类别<code>org.hibernate.search.fulltext_query</code> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manual-index-changes"><a class="anchor" href="#manual-index-changes"></a> 6。手动更改索引</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当Hibernate核心将更改应用到数据库时，Hibernate Search会检测到这些更改并自动更新索引（除非禁用了EventListeners）。有时在不使用Hibernate的情况下对数据库进行更改，例如恢复备份或以其他方式影响数据时；对于这些情况，Hibernate Search公开了手动索引API，以从索引中显式更新或删除单个实体，或为整个数据库重建索引，或删除对特定类型的所有引用。</p>
</div>
<div class="paragraph">
<p>所有这些方法仅影响Lucene Index，而不会对数据库进行任何更改。</p>
</div>
<div class="sect2">
<h3 id="_adding_instances_to_the_index"><a class="anchor" href="#_adding_instances_to_the_index"></a> 6.1。将实例添加到索引</h3>
<div class="paragraph">
<p>使用<code>FullTextSession.index(T entity)</code>您可以直接向索引添加或更新特定的对象实例。如果该实体已被索引，则索引将被更新。索引更改仅在事务提交时应用。</p>
</div>
<div class="exampleblock">
<div class="title">示例126通过索引实体<code>FullTextSession.index(T entity)</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
fullTextSession.index(customer);
tx.commit(); //index only updated at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要为某个类型或所有索引类型添加所有实例，建议的方法是使用MassIndexer：有关更多详细信息，请参见<a href="#search-batchindex-massindexer">使用MassIndexer</a> 。</p>
</div>
<div class="paragraph">
<p>方法<code>FullTextSession.index(T entity)</code>被视为显式索引操作，因此在这种情况下将不会应用任何已注册的EntityIndexingInterceptor。有关EntityIndexingInterceptor的更多信息，请参见<a href="#search-mapping-indexinginterceptor">条件索引</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_instances_from_the_index"><a class="anchor" href="#_deleting_instances_from_the_index"></a> 6.2。从索引中删除实例</h3>
<div class="paragraph">
<p>同样有可能从Lucene索引中删除一个实体或给定类型的所有实体，而无需从数据库中物理删除它们。此操作称为清除，也可以通过<code>FullTextSession</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子127。从索引中清除实体的特定实例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    fullTextSession.purge( Customer.class, customer.getId() );
}
tx.commit(); //index is updated at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>清除将从Lucene索引中删除具有给定ID的实体，但不会触及数据库。</p>
</div>
<div class="paragraph">
<p>如果需要删除给定类型的所有实体，则可以使用purgeAll方法。此操作将删除作为参数传递的所有类型的实体及其所有子类型。</p>
</div>
<div class="exampleblock">
<div class="title">示例128。从索引中清除实体的所有实例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
fullTextSession.purgeAll( Customer.class );
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index changes are applied at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与前面的示例一样，建议在多次清除操作后优化索引以实际释放所使用的空间。</p>
</div>
<div class="paragraph">
<p>与方法一样<code>FullTextSession.index(T entity)</code> ，也<code>purge</code>和<code>purgeAll</code>被视为显式索引操作：任何已注册<code>EntityIndexingInterceptor</code>将不会被应用。有关更多信息<code>EntityIndexingInterceptor</code>请参阅<a href="#search-mapping-indexinginterceptor">条件索引</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在FullTextEntityManager上也可以使用index，purge和purgeAll方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>所有手动索引方法（index，purge和purgeAll）仅影响索引，而不影响数据库，但是它们是事务性的，因此，只有成功提交事务或您使用flushToIndexes时，它们才会应用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="search-batchindex"><a class="anchor" href="#search-batchindex"></a> 6.3。重建整个索引</h3>
<div class="paragraph">
<p>如果将实体映射更改为索引，则很可能需要更新整个索引。例如，如果您决定使用其他分析器为现有字段建立索引，则需要为受影响的类型重建索引。同样，如果替换了数据库（例如从备份还原，从旧系统导入），您将希望能够从现有数据重建索引。Hibernate Search提供了两种主要策略可供选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>FullTextSession.flushToIndexes()</code>定期，同时在所有实体上使用FullTextSession.index（）。</p>
</li>
<li>
<p>使用MassIndexer。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当您将实体映射更改为索引时，如果您不知道更改是否需要完全重新索引，则可以遵循以下经验法则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重建整个索引，如果你所做的一切是<strong>不是</strong>必需的：</p>
<div class="ulist">
<ul>
<li>
<p><strong>添加</strong>不会有任何持久化实例的新索引实体，例如，添加一个<code>@Indexed</code>在数据库中没有行的实体上的注释。</p>
</li>
<li>
<p><strong>添加</strong>将对所有当前持久存在的实体为空的新字段，例如，在实体类型上添加新属性并将其映射到字段，但要保证该属性对于该实体的每个实例最初将为null；</p>
</li>
<li>
<p>和/或从现有索引/字段中<strong>删除</strong>数据，例如，删除索引字段，或无需存储字段。</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果您对映射进行了以上未提及的任何更改， <strong>则</strong>需要重建整个索引。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="search-batchindex-flushtoindexes"><a class="anchor" href="#search-batchindex-flushtoindexes"></a> 6.3.1。使用flushToIndexes（）</h4>
<div class="paragraph">
<p>该策略包括删除现有索引，然后使用以下命令将所有实体添加回索引中<code>FullTextSession.purgeAll()</code>和<code>FullTextSession.index()</code> ，但是存在一些内存和效率方面的限制。为了获得最高效率，Hibernate Search会对索引操作进行批处理，并在提交时执行它们。如果您希望索引大量数据，则需要注意内存消耗，因为所有文档都将保留在队列中，直到事务提交为止。您可能会面对<code>OutOfMemoryException</code>如果您不定期清空队列：为此，您可以使用<code>fullTextSession.flushToIndexes()</code> 。每次<code>fullTextSession.flushToIndexes()</code>如果调用（或如果事务已提交），则将应用所有索引更改来处理批处理队列。请注意，刷新后，更改将无法回滚。</p>
</div>
<div class="exampleblock">
<div class="title">示例129使用index（）和flushToIndexes（）重建索引</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll(ScrollMode.FORWARD_ONLY);
int index = 0;
while(results.next()) {
    index++;
    fullTextSession.index(results.get(0)); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尝试使用保证您的应用程序不会用完内存的批处理大小：批处理大小越大，从数据库中获取对象的速度就越快，但是需要更多的内存。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-batchindex-massindexer"><a class="anchor" href="#search-batchindex-massindexer"></a> 6.3.2。使用MassIndexer</h4>
<div class="paragraph">
<p>Hibernate Search的MassIndexer使用多个并行线程来重建索引。您可以选择选择需要重新加载的实体，或使其重新索引所有实体。此方法已针对最佳性能进行了优化，但需要将应用程序设置为维护模式：在MassIndexer繁忙时，不建议对索引进行查询。</p>
</div>
<div class="exampleblock">
<div class="title">例子130。使用MassIndexer重建索引</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将重建索引，将其删除，然后从数据库中重新加载所有实体。尽管使用起来很简单，但建议进行一些调整以加快此过程：可以配置多个参数。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在执行MassIndexer的过程中，索引的内容未定义！如果在MassIndexer工作时执行查询，很可能会丢失一些结果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例131使用调整后的MassIndexer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession
 .createIndexer( User.class )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 12 )
 .idFetchSize( 150 )
 .transactionTimeout( 1800 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将重建所有的索引<code>User</code>实例（和子类型），并将创建12个并行线程来使用每个查询中的25个对象批次加载User实例；这12个线程也将需要处理索引的嵌入式关系和自定义FieldBridges或ClassBridges，以最终输出Lucene文档。在此转换过程中，这些线程可能需要触发其他属性的延迟加载，因此您可能需要大量并行工作的线程。当在诸如WildFly应用程序服务器之类的JTA环境中运行时，质量索引器将使用1800秒（= 30分钟）的超时进行事务。考虑到已配置的批处理大小和要加载对象的线程数，配置一个足够长的超时值以加载和索引具有最多实例的所有类型的实体。请注意，这些事务是只读的，因此选择一个较大的值通常不会造成任何问题。</p>
</div>
<div class="paragraph">
<p>从Hibernate Search 4.4.0开始，默认情况下，MassIndexer配置为仅对一种类型进行并行索引，而不是对所有类型进行并行索引。它可以防止资源耗尽，尤其是数据库连接耗尽，并且通常不会减慢索引速度。但是，您可以使用以下命令配置此行为<code>MassIndexer.typesToIndexInParallel(int threadsToIndexObjects)</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例132配置MassIndexer以并行索引几种类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession
 .createIndexer( User.class, Customer.class )
 .typesToIndexInParallel( 2 )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 5 )
 .idFetchSize( 150 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常我们建议将cacheMode保留为<code>CacheMode.IGNORE</code> （默认值），因为在大多数重新索引编制情况下，缓存将是无用的额外开销；启用其他一些功能可能会很有用<code>CacheMode</code>根据您的数据：如果主实体与索引中包含的枚举式数据相关，则可以提高性能。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>MassIndexer是为提高速度而设计的，并且不了解事务，因此无需开始或提交事务。另外，由于它不是事务性的，因此不建议用户在处理过程中使用系统，因为人们不太可能找到结果，而且系统负载也可能过高。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="search-batchindexing-threadsandconnections"><a class="anchor" href="#search-batchindexing-threadsandconnections"></a>使用线程和JDBC连接的MassIndexer</h5>
<div class="paragraph">
<p>MassIndexer旨在尽可能快地完成重新索引编制任务，但这需要对其配置进行一些注意才能公平地使用服务器资源。</p>
</div>
<div class="paragraph">
<p>有一个简单的公式可以了解应用于MassIndexer的不同选项如何影响已使用的工作线程和连接的数量：每个线程将需要JDBC连接。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>threads = typesToIndexInParallel * (threadsToLoadObjects + 1);
required JDBC connections = threads;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们来看一些合理调整起点的建议：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>选项<code>typesToIndexInParallel</code>可能应该是一个较低的值，例如1或2，具体取决于您有多少CPU有空闲周期以及数据库往返的速度如何。</p>
</li>
<li>
<p>在调整并行运行之前，请尝试使用一些选项来隔离您的主要索引实体。</p>
</li>
<li>
<p>制造<code>threadsToLoadObjects</code>较高的值会增加从数据库中选择的实体的预加载率，但也会增加内存使用率以及对后续索引工作的线程的压力。</p>
</li>
<li>
<p>并行性的提高通常会有所帮助，因为瓶颈通常是数据库连接的延迟：尝试以明显高于实际可用核心数量的值进行实验可能值得，但请确保您的数据库可以处理所有多个请求。</p>
</li>
<li>
<p>此建议可能不适用于您：请始终测量效果！我们提供此方法是为了帮助您了解这些选项之间的关系。</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用许多线程运行MassIndexer将需要许多与数据库的连接。如果您没有足够大的连接池，MassIndexer本身和/或您的其他应用程序可能会饿得无法满足其他请求：请确保按照上一段中的说明相应地调整连接池的大小。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要获得最佳性能的线程数量的“最佳结合点”在很大程度上取决于整体架构，数据库设计甚至数据值。所有内部线程组都有有意义的名称，因此应使用大多数诊断工具（包括简单的线程转储）轻松识别它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="search-batchindex-custommassindexer"><a class="anchor" href="#search-batchindex-custommassindexer"></a>使用自定义MassIndexer实现</h5>
<div class="paragraph">
<p>提供的MassIndexer是相当通用的，尽管我们认为这是一种可靠的方法，但您可以通过编写自定义实现来压缩一些更好的性能。要运行自己的MassIndexer而不是使用Hibernate Search随附的MassIndexer，您必须：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个实现<code>org.hibernate.search.spi.MassIndexerFactory</code>接口;</p>
</li>
<li>
<p>设置属性<code>hibernate.search.massindexer.factoryclass</code>带有工厂实施的合格类名称。</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="title">示例133自定义MassIndexerFactory示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package org.myproject
import org.hibernate.search.spi.MassIndexerFactory

// ...

public class CustomIndexerFactory implements MassIndexerFactory {

  public void initialize(Properties properties) {
  }

  public MassIndexer createMassIndexer(...) {
    return new CustomIndexer();
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.massindexer.factoryclass = org.myproject.CustomIndexerFactory</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_useful_parameters_for_batch_indexing"><a class="anchor" href="#_useful_parameters_for_batch_indexing"></a> 6.3.3。批量索引的有用参数</h4>
<div class="paragraph">
<p>影响索引时间和内存消耗的其他参数是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hibernate.search.[default|<indexname>].exclusive_index_use</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.max_buffered_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.max_merge_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_factor</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_min_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_max_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_max_optimize_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_calibrate_by_deletes</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.ram_buffer_size</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以前的版本也有一个<code>max_field_length</code>但这已从Lucene中删除，可以通过使用<code>LimitTokenCountAnalyzer</code> 。</p>
</div>
<div class="paragraph">
<p>所有<code>.indexwriter</code>参数是特定于Lucene的，而Hibernate Search只是通过传递这些参数-有关更多详细信息，请参见<a href="#lucene-indexing-performance">调整索引性能</a> 。</p>
</div>
<div class="paragraph">
<p>MassIndexer使用只能向前滚动的结果迭代要加载的主键，但是MySQL的JDBC驱动程序将加载内存中的所有值；避免这种“优化”设置<code>idFetchSize</code>至<code>Integer.MIN_VALUE</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jsr352-integration"><a class="anchor" href="#jsr352-integration"></a> 6.4。与JSR-352集成</h3>
<div class="paragraph">
<p>与Java批处理应用程序JSR-352的集成正在开发中。我们确实认为我们已经涵盖了基础知识，我们正在寻求反馈。</p>
</div>
<div class="paragraph">
<p>Hibernate Search提供了一个JSR-352作业来执行质量索引。它不仅涵盖了上述质量索引器的现有功能，而且还受益于Java Batch Platform（JSR-352）的一些强大标准功能，例如使用检查点的故障恢复，面向块的处理以及并行执行。该批处理作业接受不同的实体类型作为输入，从数据库中加载相关的实体，然后从这些实体重建全文索引。</p>
</div>
<div class="paragraph">
<p>但是，它需要批处理运行时才能执行。请注意，我们不提供任何批处理运行时，您可以自由选择适合您需要的批处理运行时，例如，嵌入在Java EE容器中的默认批处理运行时。我们提供了与JBeret实现的完全集成（请参阅<a href="#jsr-352-emf-jberet">此处如何配置它</a> ）。至于其他实现，也可以使用它们，但是需要<a href="#jsr-352-emf-other-implementation">更多配置</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">实施例134。如何使用JSR-352质量索引工作？</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Properties jobProps = MassIndexingJob
        .parameters()
        .forEntity( MyEntity.class )
        .build();
long executionId = BatchRuntime
        .getJobOperator()
        .start( MassIndexingJob.NAME, jobProps );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_job_parameters"><a class="anchor" href="#_job_parameters"></a> 6.4.1。工作参数</h4>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表14。JSR 352集成中的作业参数</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数名称</th>
<th class="tableblock halign-left valign-top">生成器方法</th>
<th class="tableblock halign-left valign-top">需求</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityTypes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forEntity(Class<?>)</code> ，<code>forEntities(Class<?>, Class<?>…​)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在此作业执行中要索引的实体类型，以逗号分隔。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>purgeAllOnStart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>purgeAllOnStart(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定是否应在作业开始时清除现有索引。该操作发生在索引编制之前。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optimizeAfterPurge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optimizeAfterPurge(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定是否在作业开始时优化质量索引器。该操作在清除操作之后和索引编制之前进行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optimizeOnFinish</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optimizeOnFinish(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定是否在作业结束时优化质量索引器。该操作在建立索引后进行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cacheMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cacheMode(CacheMode)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IGNORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定Hibernate<code>CacheMode</code>加载实体时。默认是<code>IGNORE</code> ，这将是大多数情况下最有效的选择，但使用其他模式，例如<code>GET</code>如果要索引的许多实体都引用了一小组其他实体，则可能会更有效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idFetchSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idFetchSize(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定加载主键时要使用的获取大小。一些数据库接受特殊值，例如MySQL可能会受益于使用<code>Integer#MIN_VALUE</code> ，否则它将尝试预加载内存中的所有内容。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityFetchSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityFetchSize(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的价值<code>sessionClearInterval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定从数据库加载实体时要使用的提取大小。一些数据库接受特殊值，例如MySQL可能会受益于使用<code>Integer#MIN_VALUE</code> ，否则它将尝试预加载内存中的所有内容。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>customQueryHQL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>restrictedBy(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用HQL / JPQL为目标实体类型的实体建立索引。您的查询应仅包含一种实体类型。不允许将这种方法与标准限制混合使用。请注意，您的输入没有查询验证。有关更多详细信息和限制，请参见<a href="#jsr-352-indexing-mode">索引模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>customQueryCriteria</code> （不可用，仅查询构建器）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>restrictedBy(Criterion)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加标准以在标准方法下构建质量索引的自定义选择。您可以多次调用此方法以添加多个条件：只有与每个条件匹配的实体都将被索引。但是，不允许将此方法与HQL限制混合使用。有关更多详细信息和限制，请参见<a href="#jsr-352-indexing-mode">索引模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxResultsPerEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxResultsPerEntity(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个实体类型要加载的最大结果数。使用此参数可以定义阈值，以避免意外加载太多实体。定义的值必须大于0。默认情况下不使用该参数。相当于关键字<code>LIMIT</code>在SQL中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rowsPerPartition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rowsPerPartition(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个分区要处理的最大行数。定义的值必须大于0，并且等于或大于<code>checkpointInterval</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxThreads</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxThreads(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">分区数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理作业的最大线程数。请注意，批处理运行时无法保证请求的线程数可用。它将使用尽可能多的数量，直到请求的最大数量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>checkpointInterval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>checkpointInterval(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2,000，或<code>rowsPerPartition</code>如果较小</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">触发检查点之前要处理的实体数。定义的值必须大于0，且等于或小于<code>rowsPerPartition</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sessionClearInterval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sessionClearInterval(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200，或<code>checkpointInterval</code>如果较小</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">清除会话之前要处理的实体数。定义的值必须大于0，且等于或小于<code>checkpointInterval</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityManagerFactoryReference</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityManagerFactoryReference(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果存在多个持久性单元，则需要</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该字符串将标识<code>EntityManagerFactory</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityManagerFactoryNamespace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityManagerFactoryNamespace(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请参阅<a href="#jsr-352-emf">选择持久性单元（EntityManagerFactory）</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="jsr-352-indexing-mode"><a class="anchor" href="#jsr-352-indexing-mode"></a> 6.4.2。索引模式</h4>
<div class="paragraph">
<p>使用批量索引工作，您可以定义自己的要建立索引的实体-您可以通过3种不同的方法来开始完全索引或部分索引：使用HQL或使用Hibernate标准选择所需的实体类型。</p>
</div>
<div class="exampleblock">
<div class="title">示例135如何定义索引模式？</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// full indexing
Properties jobProps1 = MassIndexingJob
        .parameters()
        .forEntity( MyClass.class )
        .build();

// partial indexing using HQL
Properties jobProps2 = MassIndexingJob
        .parameters()
        .forEntity( MyClass.class )
        .restrictedBy( "select c from MyClass c where c.name in ( 'Foo', 'Bar' )" )
        .build();

// partial indexing using Criteria
Properties jobProps3 = MassIndexingJob
        .parameters()
        .forEntity( MyClass.class )
        .restrictedBy( Restrictions.in( "name", "Foo", "Bar" ) )
        .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虽然在执行第一个索引时或在对整个数据库进行大量更改之后，完全索引很有用，但它也可能很耗时。如果只想对部分数据重新编制索引，则需要使用HQL或条件添加限制：它们可以帮助您定义自定义选择，并且仅该选择内的实体将被索引。一个典型的用例是索引自昨天以来出现的新实体。</p>
</div>
<div class="paragraph">
<p>请注意，如下所述，根据索引模式，某些功能可能不受支持。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表15。每种索引模式的比较</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">索引模式</th>
<th class="tableblock halign-left valign-top">范围</th>
<th class="tableblock halign-left valign-top">并行索引</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">全索引</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有实体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一些实体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">支持的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">高品质</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一些实体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不支持</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用HQL模式时，作业开始前没有任何查询验证。如果查询无效，则作业将启动并失败。</p>
</div>
<div class="paragraph">
<p>另外，在HQL模式下，并行索引被禁用，因为我们当前的并行性实现依赖于选择顺序，而该顺序可能无法由用户提供的HQL提供。</p>
</div>
<div class="paragraph">
<p>由于这些限制，我们建议您仅在为少量实体建立索引时使用此方法，并且仅当您知道在建立索引期间不会创建与查询匹配的实体时，才建议使用此方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_parallel_indexing"><a class="anchor" href="#_parallel_indexing"></a> 6.4.3。并行索引</h4>
<div class="paragraph">
<p>为了获得更好的性能，使用多个线程并行执行索引。要索引的实体集分为多个分区。每个线程一次处理一个分区。</p>
</div>
<div class="paragraph">
<p>下一节将说明如何调整并行执行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要获得最佳性能的线程数量，访存大小，分区大小等的“最佳结合点”在很大程度上取决于您的总体体系结构，数据库设计甚至数据值。</p>
</div>
<div class="paragraph">
<p>您应该尝试这些设置，以找出最适合您的特定情况的设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_threads"><a class="anchor" href="#_threads"></a>线程数</h5>
<div class="paragraph">
<p>作业执行使用的最大线程数是通过方法定义的<code>maxThreads()</code> 。在给定的N个线程中，为内核保留了1个线程，因此只有N-1个线程可用于不同的分区。如果N = 1，则程序将运行，并且所有批处理元素将在同一线程中运行。Hibernate Search中使用的默认线程数是10。您可以用您的首选号码覆盖它。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">MassIndexingJob.parameters()
        .maxThreads( 5 )
        ...</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，批处理运行时不能保证所请求的线程数可用，它将使用尽可能多的线程，直到所请求的最大数量（JSR352 v1.0最终版本，第34页）。还要注意，所有批处理作业共享相同的线程池，因此并发执行作业并非总是一个好主意。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_rows_per_partition"><a class="anchor" href="#_rows_per_partition"></a>每个分区行</h5>
<div class="paragraph">
<p>每个分区由固定数量的要索引的元素组成。您可以精确调整一个分区将容纳多少个元素<code>rowsPerPartition</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">MassIndexingJob.parameters()
        .rowsPerPartition( 5000 )
        ...</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此属性与“块大小” <strong>无关</strong> ，“块大小”是每次写入之间一起处理多少个元素。处理的这一方面通过分块解决。</p>
</div>
<div class="paragraph">
<p>代替， <code>rowsPerPartition</code>有关质量索引工作的并行程度。</p>
</div>
<div class="paragraph">
<p>请参阅“ <a href="#jsr-352-chunking">块”部分</a>以了解如何调整分块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>什么时候<code>rowsPerPartition</code>较低，将有许多小分区，因此处理线程将更不会饿死（由于没有更多要处理的分区，所以请保持空闲状态），但另一方面，您只能利用较小的提取大小，这将增加数据库访问的次数。另外，由于故障恢复机制的原因，启动新分区时会产生一些开销，因此，如果分区数量过多，则开销将加在一起。</p>
</div>
<div class="paragraph">
<p>什么时候<code>rowsPerPartition</code>高时，将有几个大分区，因此您将能够利用更大的<a href="#jsr-352-chunking">块大小</a> ，从而获得更大的访存大小，这将减少数据库访问的数量，并且启动新分区的开销将减少不太明显，但是另一方面，您可能无法使用所有可用线程。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个分区处理一种根实体类型，因此两种不同的实体类型将永远不会在同一分区下运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jsr-352-chunking"><a class="anchor" href="#jsr-352-chunking"></a> 6.4.4。分块和会话清理</h4>
<div class="paragraph">
<p>质量索引作业支持从暂停位置或多或少地重新启动已暂停或失败的作业。</p>
</div>
<div class="paragraph">
<p>通过将每个分区拆分为几个连续的实体<em>块</em> ，并将过程信息保存在每个块末尾的<em>检查点中</em> ，可以实现此目的。重新启动作业后，它将从最后一个检查点恢复。</p>
</div>
<div class="paragraph">
<p>每个块的大小由<code>checkpointInterval</code>参数。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">MassIndexingJob.parameters()
        .checkpointInterval( 1000 )
        ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，块的大小不仅与保存进度有关，而且与性能有关：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为每个块打开一个新的Hibernate会话；</p>
</li>
<li>
<p>每个块开始一个新的事务；</p>
</li>
<li>
<p>在一个大块内，根据<code>sessionClearInterval</code>参数，因此必须小于（或等于）块大小；</p>
</li>
<li>
<p>文档将刷新到每个块末尾的索引。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常，与每个分区的行数相比，检查点间隔应较小。</p>
</div>
<div class="paragraph">
<p>确实，由于故障恢复机制的缘故，每个分区的第一个检查点之前的元素要比另一个分区花费更长的时间，因此，在具有1000个元素的检查点间隔的情况下，比具有1000个元素的检查点间隔要快。元素检查点间隔。</p>
</div>
<div class="paragraph">
<p>另一方面，从绝对意义<strong>上讲</strong> ， <strong>块不应太小</strong> 。执行检查点意味着JSR-352运行时会将有关作业执行进度的信息写入其持久性存储中，这也需要一定的成本。同样，为每个块创建一个新的事务和会话，这不是免费的，这意味着将获取大小设置为大于块大小的值是没有意义的。最后，在每个块末尾执行的索引刷新是一项昂贵的操作，涉及全局锁，这实际上意味着您执行的次数越少，索引编制的速度就越快。因此，拥有1个元素的检查点间隔绝对不是一个好主意。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="jsr-352-emf"><a class="anchor" href="#jsr-352-emf"></a> 6.4.5。选择持久性单元（EntityManagerFactory）</h4>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无论如何检索实体管理器工厂，都必须确保质量索引器使用的实体管理器工厂在整个质量索引过程中保持打开状态。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="jsr-352-emf-jberet"><a class="anchor" href="#jsr-352-emf-jberet"></a>贝雷特</h5>
<div class="paragraph">
<p>如果您的JSR-352运行时是JBeret（特别是在WildFly中使用），则可以使用CDI检索<code>EntityManagerFactory</code> 。除非您使用已经打包的<code>hibernate-search-jsr352</code>应用容器的模块，这将需要您添加<code>hibernate-search-jsr352-jberet</code>罐子到你的classpath。</p>
</div>
<div class="paragraph">
<p>如果仅使用一个持久性单元，则质量索引器将能够自动访问数据库而无需任何特殊配置。</p>
</div>
<div class="paragraph">
<p>如果要使用多个持久性单元，则必须注册<code>EntityManagerFactories</code>作为CDI上下文中的bean。请注意，默认情况下，实体管理器工厂可能不会被视为Bean，在这种情况下，您必须自己注册它们。您可以使用应用程序范围的bean来做到这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@ApplicationScoped
public class EntityManagerFactoriesProducer {

    @PersistenceUnit(unitName = "db1")
    private EntityManagerFactory db1Factory;

    @PersistenceUnit(unitName = "db2")
    private EntityManagerFactory db2Factory;

    @Produces
    @Singleton
    @Named("db1") // The name to use when referencing the bean
    public EntityManagerFactory createEntityManagerFactoryForDb1() {
        return db1Factory;
    }

    @Produces
    @Singleton
    @Named("db2") // The name to use when referencing the bean
    public EntityManagerFactory createEntityManagerFactoryForDb2() {
        return db2Factory;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在CDI上下文中注册了实体管理器工厂后，您可以指示大众索引器特别使用一个，方法是使用<code>entityManagerReference</code>参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于CDI API的限制，在将质量索引器与CDI一起使用时，当前无法通过其持久性单元名称来引用实体管理器工厂。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="jsr-352-emf-other-implementation"><a class="anchor" href="#jsr-352-emf-other-implementation"></a>其他启用DI的JSR-352实现</h5>
<div class="paragraph">
<p>如果要使用恰好允许依赖项注入的JSR-352实现，则可以使用<code>hibernate-search-jsr352-core</code>在以下条件下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>您必须将以下两个范围注释映射到依赖项注入机制中的相关范围：</p>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.search.jsr352.inject.scope.spi.HibernateSearchJobScoped</code></p>
</li>
<li>
<p><code>org.hibernate.search.jsr352.inject.scope.spi.HibernateSearchPartitionScoped</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>您必须确保依赖项注入机制将注册所有带有注解的类（ <code>@Named</code> ，…） <code>hibernate-search-jsr352-core</code>依赖项注入上下文中的模块。例如，可以在Spring DI中使用<code>@ComponentScan</code>注解。</p>
</li>
<li>
<p>您必须在依赖项注入上下文中注册一个bean，该注入将实现<code>EntityManagerFactoryRegistry</code>接口。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_plain_java_environment_no_dependency_injection_at_all"><a class="anchor" href="#_plain_java_environment_no_dependency_injection_at_all"></a>纯Java环境（完全没有依赖项注入）</h5>
<div class="paragraph">
<p>仅当您的JSR-352运行时完全不支持依赖项注入（即忽略）时，以下内容才有效<code>@Inject</code>批处理工件中的注释。例如，在Java SE模式下的JBatch就是这种情况。</p>
</div>
<div class="paragraph">
<p>如果您仅使用一个持久性单元，则批量索引器将能够自动访问数据库而无需任何特殊配置：您只需确保创建<code>EntityManagerFactory</code> （要么<code>SessionFactory</code> ），然后启动质量索引器。</p>
</div>
<div class="paragraph">
<p>如果要使用多个持久性单元，则在启动质量索引器时必须添加两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>entityManagerFactoryReference</code> ：这是将标识<code>EntityManagerFactory</code> 。</p>
</li>
<li>
<p><code>entityManagerFactoryNamespace</code> ：这可以选择您要如何引用<code>EntityManagerFactory</code> 。可能的值为：</p>
<div class="ulist">
<ul>
<li>
<p><code>persistence-unit-name</code> （默认值）：使用在中定义的持久性单元名称<code>persistence.xml</code> 。</p>
</li>
<li>
<p><code>session-factory-name</code> ：使用Hibernate配置中定义的会话工厂名称<code>hibernate.session_factory_name</code>配置属性。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您设置<code>hibernate.session_factory_name</code> Hibernate配置中的“属性”，并且您不使用JNDI，则还必须设置<code>hibernate.session_factory_name_is_jndi</code>至<code>false</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-optimize"><a class="anchor" href="#search-optimize"></a> 7。指标优化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节说明一些低级技巧，以使索引保持最佳性能。我们介绍了Lucene的一些细节，在大多数情况下，您无需了解这些细节：Hibernate Search在大多数情况下将以最佳，透明的方式处理这些操作，而无需进一步配置。尽管如此，还是很高兴知道，如果需要的话，有一些方法可以配置行为。</p>
</div>
<div class="paragraph">
<p>该索引实际上存储在几个较小的段中。每个段都是不可变的，代表了代写索引。索引段会定期压缩，以合并较小的段并删除陈旧的条目。该合并过程在后台不断发生，并且可以使用“ <a href="#lucene-indexing-performance">调整索引性能”中</a>指定的选项进行<a href="#lucene-indexing-performance">调整</a> ，但是您也可以定义策略，以在最适合您的特定工作负载时完全运行索引优化。</p>
</div>
<div class="paragraph">
<p>对于旧版本的Lucene，重要的是经常优化索引以保持良好的性能，但是对于当前的Lucene版本，这已不再适用。显式优化的好处非常低，在某些情况下甚至适得其反。在显式优化过程中，整个索引都将被处理和重写，从而导致巨大的性能成本。因此，优化是一把双刃剑。</p>
</div>
<div class="paragraph">
<p>避免过于频繁地优化索引的另一个原因是，作为一个副作用，优化会使缓存的筛选器无效，并且需要刷新字段缓存和内部缓冲区。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常不需要优化索引，它根本不会提高写入（更新）性能，而且操作很慢：请确保在激活索引之前需要它。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然，优化索引不仅存在弊端：在优化过程完成并且新的IndexReader实例已加载其缓冲区之后，查询将以最高性能运行，并且您将收回陈旧条目可能使用的所有磁盘空间。</p>
</div>
<div class="paragraph">
<p>建议不要安排任何优化，但是如果您希望定期执行优化，则应运行它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在空闲系统上或搜索频率较低时</p>
</li>
<li>
<p>经过大量的索引修改</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用MassIndexer时（请参阅<a href="#search-batchindex-massindexer">使用MassIndexer</a> ），默认情况下它将在处理的开始和结束时优化所涉及的索引。您可以分别使用MassIndexer.optimizeAfterPurge和MassIndexer.optimizeOnFinish来更改此行为。初始优化实际上是很便宜的，因为它是在空索引上执行的：其目的是释放旧索引占用的存储空间。</p>
</div>
<div class="sect2">
<h3 id="_automatic_optimization"><a class="anchor" href="#_automatic_optimization"></a> 7.1。自动优化</h3>
<div class="paragraph">
<p>虽然在大多数情况下不需要这样做，但是Hibernate Search可以在以下情况下自动优化索引：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一定数量的写操作</p>
</li>
<li>
<p>或一定数量的交易后</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以在全局级别或每个索引上定义自动索引优化的配置：</p>
</div>
<div class="exampleblock">
<div class="title">实施例136。定义自动优化参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上述示例中，优化将触发<code>Animal</code>索引之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加和删除的数量达到1000</p>
</li>
<li>
<p>交易数量达到50（hibernate.search。Animal.optimizer.transaction_limit.max优先于hibernate.search.default.optimizer.transaction_limit.max）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果未定义这些参数，则不会自动处理优化。</p>
</div>
<div class="paragraph">
<p>可以通过实施OptimizerStrategy的默认实现来覆盖<code>org.hibernate.search.store.optimization.OptimizerStrategy</code>并设置<code>optimizer.implementation</code>属性为实现的完全限定名称。此实现必须实现接口，成为公共类并且具有不带参数的公共构造函数。</p>
</div>
<div class="exampleblock">
<div class="title">实施例137。加载自定义的OptimizerStrategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>关键字<code>default</code>可用于选择Hibernate Search的默认实现；之后的所有属性<code>.optimizer</code>键分隔符将在开始时传递给实现的initialize方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_optimization"><a class="anchor" href="#_manual_optimization"></a> 7.2。手动优化</h3>
<div class="paragraph">
<p>您可以通过SearchFactory以编程方式从Hibernate Search优化（整理）Lucene索引：</p>
</div>
<div class="exampleblock">
<div class="title">实施例138。程序化索引优化</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个示例优化了Lucene索引的保存顺序；第二，优化所有索引。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>searchFactory.optimize()</code>对JMS或JGroups后端无效：您必须在主节点上应用优化操作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_optimization"><a class="anchor" href="#_adjusting_optimization"></a> 7.3。调整优化</h3>
<div class="paragraph">
<p>Lucene索引不断在后台进行合并，以在读写性能之间保持良好的平衡。从某种意义上说，这是一直在应用的后台优化形式。</p>
</div>
<div class="paragraph">
<p>Lucene的IndexWriter的以下match属性，通常用于调整合并发生的频率和应用的积极程度。它们通过以下方式由Hibernate Search公开：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.max_buffered_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.max_merge_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.merge_factor</code></p>
</li>
<li>
<p><code>hibernate.search.[default|<indexname>].indexwriter.ram_buffer_size</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关这些属性的描述，请参见<a href="#lucene-indexing-performance">调整索引性能</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-monitoring"><a class="anchor" href="#search-monitoring"></a> 8。监控方式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过Hibernate Search，您可以访问<code>Statistics</code>通过对象<code>SearchFactory.getStatistics()</code> 。例如，它允许您确定要索引的类以及索引中有多少个实体。此信息始终可用。但是，通过指定<code>hibernate.search.generate_statistics</code>在配置中的“属性”属性中，您还可以收集Lucene查询和对象加载的总时间和平均时间。</p>
</div>
<div class="sect2">
<h3 id="_jmx"><a class="anchor" href="#_jmx"></a> 8.1。JMX</h3>
<div class="paragraph">
<p>您还可以通过JMX启用对统计信息的访问。设置属性<code>hibernate.search.jmx_enabled</code>将自动注册<code>StatisticsInfoMBean</code> 。根据您的配置<code>IndexControlMBean</code>和<code>IndexingProgressMonitorMBean</code>也将被注册。如果您在一个JVM中运行多个启用JMX的Hibernate Search实例，则还应该设置<code>hibernate.search.jmx_bean_suffix</code>每个实例的值都不同指定的后缀将用于区分不同的MBean实例。让我们仔细看看所提到的MBean。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要通过JConsole远程访问JMX Bean，请确保设置系统属性<code>com.sun.management.jmxremote</code>真实。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_statisticsinfombean"><a class="anchor" href="#_statisticsinfombean"></a> 8.1.1。StatisticsInfoMBean</h4>
<div class="paragraph">
<p>该MBean允许您访问上一节中所述的Statistics对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexcontrolmbean"><a class="anchor" href="#_indexcontrolmbean"></a> 8.1.2。IndexControlMBean</h4>
<div class="paragraph">
<p>该MBean允许构建，优化和清除给定实体的索引。索引通过质量索引API进行（请参阅<a href="#search-batchindex-massindexer">使用MassIndexer</a> ）。要在JMX中注册此bean，要求Hibernate SessionFactory通过以下方式绑定到JNDI： <code>hibernate.session_factory_name</code>属性。有关如何配置JNDI的更多信息，请参见Hibernate Core手册。</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexingprogressmonitormbean"><a class="anchor" href="#_indexingprogressmonitormbean"></a> 8.1.3。IndexingProgressMonitorMBean</h4>
<div class="paragraph">
<p>此MBean是MassIndexerProgressMonitor接口的实现。如果<code>hibernate.search.jmx_enabled</code>启用并且使用质量索引器API，可以通过此bean跟踪索引进度。仅在进行索引编制时，才会将bean绑定到JMX。一旦完成索引编制，MBean将不再可用。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spatial"><a class="anchor" href="#spatial"></a> 9。空间空间</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用空间扩展，您可以将全文查询与距离限制结合在一起，根据距离过滤结果，或根据这种距离标准对结果进行排序。</p>
</div>
<div class="paragraph">
<p>Hibernate Search的空间支持具有以下目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在实体上启用空间搜索：查找距地球上给定位置（纬度，经度）x公里以内的实体</p>
</li>
<li>
<p>提供一种通过表达性注释启用空间索引的简便方法</p>
</li>
<li>
<p>提供一种简单的查询方式</p>
</li>
<li>
<p>隐藏地域复杂性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，您可以搜索办公室周围2公里半径内的餐馆。</p>
</div>
<div class="paragraph">
<p>为了对索引实体使用空间扩展，您需要添加<code>@Spatial</code>注释（ <code>org.hibernate.search.annotations.Spatial</code> ）并指定一组或多组坐标。</p>
</div>
<div class="sect2">
<h3 id="spatial-indexing"><a class="anchor" href="#spatial-indexing"></a> 9.1。启用空间坐标索引</h3>
<div class="paragraph">
<p>有不同的技术来索引点坐标。Hibernate Search Spatial提供了两种策略之间的选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数字索引</p>
</li>
<li>
<p>索引为标记的空间哈希</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，我们将描述这两种方法，以便您做出适当的选择。您可以为每组坐标选择不同的策略。通过指定策略来选择策略<code>spatialMode</code>的属性<code>@Spatial</code>注解。</p>
</div>
<div class="sect3">
<h4 id="spatial-indexing-range"><a class="anchor" href="#spatial-indexing-range"></a> 9.1.1。范围查询的索引坐标</h4>
<div class="paragraph">
<p>设定<code>@Spatial.spatialMode</code>归因于<code>SpatialMode.RANGE</code> （这是默认设置）坐标被索引为数字字段，以便可以执行范围查询来缩小初始感兴趣区域的范围。</p>
</div>
<div class="paragraph">
<p>优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>快速处理小型数据集（<100k个实体）</p>
</li>
<li>
<p>非常简单：易于调试/分析</p>
</li>
<li>
<p>对索引大小的影响是中等的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>大数据集性能不佳</p>
</li>
<li>
<p>如果您的数据集分布在全球范围内，则性能会较差（例如，在对美国，欧洲和亚洲的兴趣点建立索引时，大面积区域会发生碰撞，因为它们共享相同的纬度。纬度范围查询返回的大量数据需要与经度范围返回的数据进行交叉检查。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要为实体索引以进行范围查询，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加<code>@Spatial</code>您实体上的注释</p>
</li>
<li>
<p>添加<code>@Latitude</code>和<code>@Longitude</code>在属性上表示坐标的注释；这些必须是类型<code>Double</code></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例139样本空间索引：酒店类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatial
public class Hotel {

  @Latitude
  Double latitude

  @Longitude
  Double longitude

  // ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-indexing-spatialHash"><a class="anchor" href="#spatial-indexing-spatialHash"></a> 9.1.2。用空间哈希索引网格中的坐标</h4>
<div class="paragraph">
<p>设定时<code>@Spatial.spatialMode</code>至<code>SpatialMode.HASH</code>坐标被编码在代表不同缩放级别的多个字段中。每个级别的每个框都有标签，因此为每个缩放级别分配了与之匹配的标签。这导致标签的网格编码称为<code>spatial hashes</code> 。</p>
</div>
<div class="paragraph">
<p>优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>即使是大型数据集也具有良好的性能</p>
</li>
<li>
<p>独立于世界范围的数据分发</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引大小更大：每对坐标需要编码多个标签</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要索引您的实体，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加<code>@Spatial</code>在实体上使用<code>SpatialMode</code>设置为GRID：@Spatial（spatialMode = SpatialMode。哈希）</p>
</li>
<li>
<p>添加<code>@Latitude</code>和<code>@Longitude</code>代表坐标的属性上的注释；这些必须是类型<code>Double</code></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">例子140。使用空间哈希索引网格中的坐标</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Spatial(spatialMode = SpatialMode.HASH)
@Indexed
@Entity
public class Hotel {

  @Latitude
  Double latitude;

  @Longitude
  Double longitude;

  // ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-coordinatesinterface"><a class="anchor" href="#spatial-coordinatesinterface"></a> 9.1.3。实施坐标界面</h4>
<div class="paragraph">
<p>而不是使用<code>@Latitude</code>和<code>@Longitude</code>您可以选择实施的注释<code>org.hibernate.search.spatial.Coordinates</code>接口。</p>
</div>
<div class="exampleblock">
<div class="title">实施例141。实施坐标界面</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;
import org.hibernate.search.spatial.Coordinates;

@Entity
@Indexed
@Spatial
public class Song implements Coordinates {

  @Id long id;
  double latitude;
  double longitude;
  // ...

  @Override
  Double getLatitude() {
    return latitude;
  }

  @Override
  Double getLongitude() {
    return longitude;
  }

  // ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如我们将在“ <a href="#spatial-multiplecoordinates">多个坐标对</a> ”部分中看到的，一个实体可以具有多个<code>@Spatial</code>注释；当实体实施时<code>Coordinates</code> ，实现的方法参考默认值<code>@Spatial</code>带有默认坐标对的注释。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认（字段）名称，以防万一<code>@Spatial</code>位于实体级别<code>org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一种替代方法是使用实现<code>Coordinates</code>接口;这样你可以有多个<code>Spatial</code>实例：</p>
</div>
<div class="exampleblock">
<div class="title">实施例142。使用坐标类型的属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Event {
  @Id
  Integer id;

  @Field(store = Store.YES)
  String name;

  double latitude;
  double longitude;

  @Spatial(spatialMode = SpatialMode.HASH)
  public Coordinates getLocation() {
    return new Coordinates() {
      @Override
      public Double getLatitude() {
        return latitude;
      }

      @Override
      public Double getLongitude() {
        return longitude;
      }
    };
  }

// ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此表格时<code>@Spatial.name</code>自动默认为属性名称。在上述情况下<code>location</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-queries"><a class="anchor" href="#spatial-queries"></a> 9.2。执行空间查询</h3>
<div class="paragraph">
<p>您可以使用Hibernate Search查询DSL来构建查询，以在一对坐标（纬度，经度）周围或在实现了<code>Coordinates</code>接口。</p>
</div>
<div class="paragraph">
<p>与任何全文查询一样，空间查询的创建流程如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>找一个<code>QueryBuilder</code>来自<code>SearchFactory</code></p>
</li>
<li>
<p>使用DSL建立空间查询，定义搜索中心和半径</p>
</li>
<li>
<p>可选地合并结果<code>Query</code>与其他过滤器</p>
</li>
<li>
<p>叫<code>createFullTextQuery()</code>并像任何标准的Hibernate或JPA查询一样使用结果查询</p>
</li>
</ol>
</div>
<div id="spatial-example-firstquery" class="exampleblock">
<div class="title">示例143。按距离搜索酒店</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( Hotel.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession
  .createFullTextQuery( luceneQuery, Hotel.class );
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在上面的示例中，我们没有明确指定要使用的字段名称。默认坐标字段名称被隐式使用。要在查询时将另一对坐标作为目标，我们还需要指定字段名称。请参阅<a href="#spatial-multiplecoordinates">多个坐标对</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在<a href="https://github.com/hibernate/hibernate-search">源代码</a>的测试套件中找到一个完整的示例。参考<code>SpatialIndexingTest.testSpatialAnnotationOnClassLevel()</code>及其对应的<code>Hotel</code>测试课。</p>
</div>
<div class="paragraph">
<p>除了传递单独的纬度和经度值之外，您还可以传递一个实现<code>Coordinates</code>接口：</p>
</div>
<div class="exampleblock">
<div class="title">实施例144。带坐标的DSL示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Coordinates coordinates = Point.fromDegrees(24d, 31.5d);
Query query = builder
  .spatial()
    .within( 51, Unit.KM )
      .ofCoordinates( coordinates )
  .createQuery();

List results = fullTextSession.createFullTextQuery( query, POI.class ).list();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-queries-distance"><a class="anchor" href="#spatial-queries-distance"></a> 9.2.1。返回搜索结果中查询点的距离</h4>
<div class="sect4">
<h5 id="spatial-distance-projection"><a class="anchor" href="#spatial-distance-projection"></a>返回结果到中心的距离</h5>
<div class="paragraph">
<p>要检索实际距离值（以公里为单位），您需要使用投影（请参见<a href="#projections">Projection</a> ）：</p>
</div>
<div class="exampleblock">
<div class="title">示例145距离投影示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude= 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(POI.class).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
     .onField("location")
     .within(100, Unit.KM)
       .ofLatitude(centerLatitude)
       .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
hibQuery.setProjection(FullTextQuery.SPATIAL_DISTANCE, FullTextQuery.THIS);
hibQuery.setSpatialParameters(centerLatitude, centerLongitude, "location");
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>FullTextQuery.setProjection</code>与<code>FullTextQuery.SPATIAL_DISTANCE</code>作为预计的领域之一。</p>
</li>
<li>
<p>呼叫<code>FullTextQuery.setSpatialParameters</code>以及用于构建空间查询的空间字段的纬度，经度和名称。请注意，使用与查询所用中心不同的坐标将产生意外结果。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认（字段）名称，以防万一<code>@Spatial</code>位于实体级别<code>org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">距离投影和空值</div>
<div class="paragraph">
<p>当实体上的空间场具有<code>null</code>值（无论是纬度还是经度（或两者）），则得出的投影距离将始终为<code>null</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spatial-distance-sort"><a class="anchor" href="#spatial-distance-sort"></a>按距离排序</h5>
<div class="paragraph">
<p>要按照到搜索中心的距离对结果进行排序，您必须构建一个<code>Sort</code>实例使用Hibernate Search排序DSL：</p>
</div>
<div class="exampleblock">
<div class="title">例子146。使用排序DSL的距离排序示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
List results = query.list();
Sort distanceSort = qb
  .sort()
    .byDistance()
      .onField("location")
      .fromLatitude(centerLatitude)
      .andLongitude(centerLongitude)
    .createSort();
hibQuery.setSort(distanceSort);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>必须在用于构建空间查询的同一空间字段上使用相同的坐标来构造排序，否则排序将以查询之外的其他中心进行。需要重复此操作，以允许您使用任何工具定义查询。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">排序和空值</div>
<div class="paragraph">
<p>当实体上的空间场具有<code>null</code>纬度或经度（或两者）的值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果使用距离查询过滤结果，则缺少坐标的实体将不会出现在查询结果中，并且其在排序中的排名无关紧要。</p>
</li>
<li>
<p>否则，结果距离将始终是最大可能的值，这意味着如果排序递增，则实体将排在最后；如果排序递减，则实体将排在第一。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，您也可以使用<code>DistanceSortField</code>直接，就像在引入Hibernate Search排序DSL之前所做的那样：</p>
</div>
<div class="exampleblock">
<div class="title">示例147不使用排序DSL的距离排序示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
Sort distanceSort = new Sort(
    new DistanceSortField(centerLatitude, centerLongitude, "location"));
hibQuery.setSort(distanceSort);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-multiplecoordinates"><a class="anchor" href="#spatial-multiplecoordinates"></a> 9.3。多个坐标对</h3>
<div class="paragraph">
<p>您可以将多对坐标关联到同一实体，只要每对坐标通过使用不同的名称进行唯一标识即可。这是通过堆叠多个<code>@Spatial</code>注释并指定<code>name</code>个人的属性<code>@Spatial</code>注解。最多允许其中之一使用默认名称。</p>
</div>
<div class="exampleblock">
<div class="title">实施例148。多组坐标</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatial
@Spatial(name="work",  spatialMode = SpatialMode.HASH)
public class UserEx {

  @Id
  Integer id;

  @Latitude
  Double homeLatitude;

  @Longitude
  Double homeLongitude;

  @Latitude(of="work")
  Double workLatitude;

  @Longitude(of="work")
  Double workLongitude;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在查询时定位另一对坐标，我们需要使用名称指定对<code>onField(String)</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例149查询非默认坐标集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( UserEx.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .onField( "work" )
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery( luceneQuery,
   Hotel.class );
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-behind-curtain"><a class="anchor" href="#spatial-behind-curtain"></a> 9.4。透视：空间哈希索引的实现细节</h3>
<div class="paragraph">
<p>下一章旨在提供有关空间哈希（网格）索引的技术见解。它讨论了如何将坐标映射到索引以及如何实现查询。</p>
</div>
<div class="sect3">
<h4 id="_at_indexing_level"><a class="anchor" href="#_at_indexing_level"></a> 9.4.1。在索引级别</h4>
<div class="paragraph">
<p>当Hibernate Search索引带有注释的实体时<code>@Spatial</code> ，它实例化一个<code>SpatialFieldBridge</code>转换通过<code>Coordinates</code>与存储在Lucene索引中的多个索引字段的接口。</p>
</div>
<div class="paragraph">
<p>空间索引的原理：Hibernate Search中使用的空间索引是基于<a href="http://en.wikipedia.org/wiki/Grid_(spatial_index)#Grid-based_spatial_indexing">网格的空间索引</a> ，其中网格ID是从纬度和经度得出的哈希值。</p>
</div>
<div class="paragraph">
<p>为了使计算更容易，借助<a href="http://en.wikipedia.org/wiki/Sinusoidal_projection">正弦投影，</a>将纬度和经度字段值投影到平面坐标系中。原始值空间为：</p>
</div>
<div class="paragraph">
<p>[-90→+90]，]-180→; 180]</p>
</div>
<div class="paragraph">
<p>对于纬度，经度坐标和投影空间为：</p>
</div>
<div class="paragraph">
<p>] -pi→+ pi]，[-pi / 2→+ pi / 2]</p>
</div>
<div class="paragraph">
<p>对于笛卡尔的x，y坐标（请注意字段的顺序反转：x为经度，y为纬度）。</p>
</div>
<div class="paragraph">
<p>索引分为从0到n-1标记的n个级别。</p>
</div>
<div class="paragraph">
<p>在0级，投影空间是整个地球。在第1层，投影空间分为4个矩形（在边界框中称为框）：</p>
</div>
<div class="paragraph">
<p>[-pi，-pi / 2]→[0,0]，[-pi，0]→[0，+ pi / 2]，[0，-pi / 2]→[+ pi，0]和[0 ，0]→[+ pi，+ pi / 2]</p>
</div>
<div class="paragraph">
<p>在级别n + 1，级别n的每个框被分为4个新框，依此类推。给定级别的盒子数为4 ^ n。</p>
</div>
<div class="paragraph">
<p>每个框都有一个ID，格式为：[X轴上的框索引] | [Y轴上的框索引]。为了计算盒子在轴上的索引，我们将轴范围划分为2 ^ n个插槽，并找到该盒子所属的插槽。在n级，轴上的索引从-（2 ^ n）/ 2到（2 ^ n）/ 2。例如，第5级具有4 ^ 5 = 1024个框，每个轴上有32个索引（32x32为1024），并且ID“ 0 | 8”的框覆盖[0,8 / 32 * pi / 2]→[ 1/32 * pi，9/32 * pi / 2]矩形是投影空间。</p>
</div>
<div class="paragraph">
<p>谨防！这些盒子在投影空间中是矩形，但地球上的相关区域不是矩形！</p>
</div>
<div class="paragraph">
<p>现在，我们已经在所有这些级别上拥有了所有这些框，我们可以将点“索引”入其中。</p>
</div>
<div class="paragraph">
<p>对于一个点（lat，long），我们计算其投影（x，y），然后为空间索引的每个级别计算其所属的框的id。</p>
</div>
<div class="paragraph">
<p>在每个级别上，该点位于一个框内，并且只有一个框。对于边缘上的点，该框在左侧被认为是排他的，而在右边即[start，end]被认为是排他的（将这些点在投影到[-90，+ 90]，]-180，+ 180]之前进行归一化）。</p>
</div>
<div class="paragraph">
<p>我们存储在与实体相对应的Lucene文档中，以为空间哈希网格的每个级别索引一个字段。该字段被命名为： <em class="spatial index fields name">HSSI</em> [n]。 [空间索引字段名称]是由类级别注释的参数给出的，或者是从实体的空间注释方法的名称派生的，HSSI代表“Hibernate搜索空间索引”，n是空间哈希网格的级别。</p>
</div>
<div class="paragraph">
<p>我们还将纬度和经度存储为[空间索引字段名称] _HSSI_Latitude和[空间索引字段名称] _HSSI_Longitude字段下的数字字段。它们将用于在搜索的第二阶段按距离精确过滤结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_at_search_level"><a class="anchor" href="#_at_search_level"></a> 9.4.2。在搜索级别</h4>
<div class="paragraph">
<p>现在我们有了所有这些字段，它们分别用于什么目的？</p>
</div>
<div class="paragraph">
<p>当您通过提供搜索铁饼（中心+半径）来进行空间搜索时，我们将计算确实覆盖投影空间中搜索铁饼的框ID，获取属于这些框的所有文档（从而缩小文档数量）为此，我们必须计算到中心的距离），然后使用实际距离计算过滤该子集。这称为两级空间滤波。</p>
</div>
<div class="sect4">
<h5 id="_step_1_compute_the_best_spatial_hashes_grid_level_for_the_search_discus"><a class="anchor" href="#_step_1_compute_the_best_spatial_hashes_grid_level_for_the_search_discus"></a>步骤1：为搜索铁饼计算最佳空间哈希网格级别</h5>
<div class="paragraph">
<p>对于给定的搜索半径，存在一个最佳的哈希网格级别，其中要检索的框数应最少，而不带回许多文档（级别0只有1个框，但可以检索所有文档）。最佳哈希网格级别是每个框的宽度大于搜索区域的最大级别。在赤道线附近（投影变形最小），这将导致最多检索4个盒子。朝向变形较大的极点时，可能需要检查更多的盒子，但由于正弦投影在人口稠密的地区有一个简单的天梭底纹（请参见<a href="http://en.wikipedia.org/wiki/Sinusoidal_projection">正弦投影</a> ），因此开销很小。</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_2_compute_ids_of_the_corresponding_covering_boxes_at_that_level"><a class="anchor" href="#_step_2_compute_ids_of_the_corresponding_covering_boxes_at_that_level"></a>步骤2：计算该级别相应覆盖框的ID</h5>
<div class="paragraph">
<p>现在我们已经选择了最佳级别，我们可以计算覆盖搜索铁饼（不再是投影空间中的铁饼）的框的ID。</p>
</div>
<div class="paragraph">
<p>这是通过<code>org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point center, double radius, int spatialHashLevel)</code></p>
</div>
<div class="paragraph">
<p>它将计算搜索铁饼的边界框，然后调用<code>org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point upperRight, int spatialHashLevel)</code>它将进行实际的计算。如果边框越过子午线，它将把搜索切成两部分，并向<code>getSpatialHashCellsIds(Point lowerLeft, Point upperRight, int spatialHashLevel)</code>盒子的左右部分。</p>
</div>
<div class="paragraph">
<p>有一些与地理位置相关的黑客行为（搜索半径过大，搜索半径越过两极）在由<code>Rectangle.fromBoundingCircle(Coordinates center, double radius)</code> （有关这些主题的参考，请参见<a href="http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates" class="bare">http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates</a> ）。</p>
</div>
<div class="paragraph">
<p>的<code>SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point upperRight, int spatialHashLevel)</code>投影边界框的定义点并计算它们所属的框。它返回左下角到右上角之间的所有框ID，从而覆盖该区域。</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_3_lucene_index_lookup"><a class="anchor" href="#_step_3_lucene_index_lookup"></a>步骤3：Lucene索引查找</h5>
<div class="paragraph">
<p>该查询是通过这些IDs构建的，这些IDs搜索具有<em class="spatial index fields
name">HSSI</em> [n]（n为在第1步中找到的级别）字段的值为第2步的id之一的文档。</p>
</div>
<div class="paragraph">
<p>另请参见<code>org.hibernate.search.spatial.impl.SpatialHashFilter</code> 。</p>
</div>
<div class="paragraph">
<p>该查询将返回包含搜索铁饼的预计边界框的框中的所有文档。因此它太大，需要细化。但是，我们已经将距离计算问题缩小到我们数据的一部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_4_refine"><a class="anchor" href="#_step_4_refine"></a>步骤4：细化</h5>
<div class="paragraph">
<p>在步骤3的Lucene索引查询之后，将设置距离计算过滤器，以从结果列表中排除错误的候选对象。</p>
</div>
<div class="paragraph">
<p>看到<code>SpatialQueryBuilderFromCoordinates.buildSpatialQuery(Coordinates center, double radius, String fieldName)</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-lucene-native"><a class="anchor" href="#search-lucene-native"></a> 10。高级功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在最后一章中，我们将提供一些技巧和窍门，这些技巧和窍门可能会随着您深入Hibernate Search而变得有用。</p>
</div>
<div class="sect2">
<h3 id="AccessingSearchFactory"><a class="anchor" href="#AccessingSearchFactory"></a> 10.1。访问<code>SearchFactory</code></h3>
<div class="paragraph">
<p>的<code>SearchFactory</code>对象跟踪Hibernate Search的基础Lucene资源。这是本地访问Lucene的便捷方式。的<code>SearchFactory</code>可以从FullTextSession访问：</p>
</div>
<div class="exampleblock">
<div class="title">示例150访问<code>SearchFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="AccessingSearchIntegrator"><a class="anchor" href="#AccessingSearchIntegrator"></a> 10.2。访问<code>SearchIntegrator</code></h3>
<div class="paragraph">
<p>介面<code>SearchIntegrator</code>允许访问Hibernate Search的高级功能和内部组件；这些通常仅对将Hibernate Search与其他库集成有用。这些被称为SPI（服务提供接口），以更好地将它们与常规API区分开。您可以通过注意到<code>spi</code>包名称中的元素，例如<code>org.hibernate.search.spi.SearchIntegrator</code> 。</p>
</div>
<div class="paragraph">
<p>您可以访问<code>SearchIntegrator</code>使用SearchFactory的SPI（ <a href="#AccessingSearchFactory">访问<code>SearchFactory</code></a> ），或从Hibernate本机提取实例<code>SessionFactory</code>或JPA <code>EntityManagerFactory</code>如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例151访问<code>SearchIntegrator</code>从一个<code>SearchFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchIntegrator si = searchFactory.unwrap(SearchIntegrator.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例152访问<code>SearchIntegrator</code>从一个<code>SessionFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchIntegrator si = org.hibernate.search.orm.spi.SearchIntegratorHelper.extractFromSessionFactory( sf );</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例153。访问<code>SearchIntegrator</code>从<code>EntityManagerFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchIntegrator si = org.hibernate.search.orm.spi.SearchIntegratorHelper.extractFromEntityManagerFactory( emf );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IndexReaders"><a class="anchor" href="#IndexReaders"></a> 10.3。使用<code>IndexReader</code></h3>
<div class="paragraph">
<p>Lucene中的查询在<code>IndexReader</code> 。Hibernate Search缓存索引读取器以最大化性能，并实施其他策略来检索更新的IndexReader，以最大程度地减少IO操作。您的代码可以访问这些缓存的资源，但是您必须遵循一些“良好公民”规则。</p>
</div>
<div class="exampleblock">
<div class="title">示例154正在访问<code>IndexReader</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IndexReader reader = searchFactory.getIndexReaderAccessor().open(Order.class);
try {
   //perform read-only operations on the reader
}
finally {
   searchFactory.getIndexReaderAccessor().close(reader);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，SearchFactory找出查询该实体所需的索引。在每个索引上使用配置的ReaderProvider（在<a href="#search-architecture-readerstrategy">Reader策略中</a>描述），它返回一个复合值<code>IndexReader</code>在所有相关索引之上。因为这<code>IndexReader</code>在多个客户之间共享时，您必须遵守以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>永不致电<code>indexReader.close()</code> ，但总是打电话<code>readerProvider.closeReader(reader)</code> ，使用finally块。</p>
</li>
<li>
<p>不要用这个<code>IndexReader</code>对于修改操作：这是一个只读实例，您将获得异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了这些规则，您还可以使用<code>IndexReader</code>自由地进行，尤其是执行本地Lucene查询。使用这种共享的IndexReaders比通过直接从（例如）文件系统中打开一个IndexReaders更为有效。</p>
</div>
<div class="paragraph">
<p>作为方法的替代<code>open(Class…​ types)</code>您可以使用<code>open(String…​ indexNames)</code>在这种情况下，您传入一个或多个索引名称；使用这种策略，如果使用分片，则还可以为任何索引类型选择索引的子集。</p>
</div>
<div class="exampleblock">
<div class="title">示例155正在访问<code>IndexReader</code>按索引名称</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IndexReader reader = searchFactory
      .getIndexReaderAccessor()
      .open("Products.1", "Products.3");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_accessing_a_lucene_directory"><a class="anchor" href="#_accessing_a_lucene_directory"></a> 10.4。访问Lucene目录</h3>
<div class="paragraph">
<p>目录是Lucene用来表示索引存储的最常见抽象。 Hibernate Search并不直接与Lucene Directory交互，而是通过IndexManager抽象这些交互：索引不一定需要由Directory实现。</p>
</div>
<div class="paragraph">
<p>如果确定索引表示为目录并需要访问它，则可以通过IndexManager获取对目录的引用。您将必须将IndexManager实例强制转换为DirectoryBasedIndexManager，然后使用<code>getDirectoryProvider().getDirectory()</code>获取对基础目录的引用。不建议这样做，如果您需要使用Lucene API对索引进行低级访问，我们建议您参阅<a href="#IndexReaders">使用<code>IndexReader</code></a>代替。</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-features-sharding"><a class="anchor" href="#advanced-features-sharding"></a> 10.5。分片索引</h3>
<div class="paragraph">
<p>在某些情况下，将数据拆分（分片）为多个Lucene索引可能很有用。主要有两个用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单个索引太大，以至于索引更新时间使应用程序变慢。在这种情况下，可以使用静态分片将数据拆分为预定义数量的分片。</p>
</li>
<li>
<p>数据自然按客户，地区，语言或其他应用程序参数进行细分，索引应根据这些细分进行划分。这是动态分片的用例。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，未启用分片。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_static_sharding"><a class="anchor" href="#_static_sharding"></a> 10.5.1。静态分片</h4>
<div class="paragraph">
<p>要启用静态分片，请设置hibernate.search。 <indexname>.sharding_strategy.nbr_of_shards属性，如<a href="#example-index-sharding">启用索引分</a>片中所示。</indexname></p>
</div>
<div id="example-index-sharding" class="exampleblock">
<div class="title">例子156。启用索引分片</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexName&gt;].sharding_strategy.nbr_of_shards = 5</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过设置此属性启用的默认分片策略将根据文档ID（由FieldBridge生成）的哈希值拆分数据。这样可以确保分片相当平衡。您可以通过实现自定义IndexShardingStrategy来替换默认策略。要使用您的自定义策略，您必须设置hibernate.search。[默认| <indexname>] .sharding_strategy属性设置为自定义IndexShardingStrategy的完全限定的类名。</indexname></p>
</div>
<div id="example-index-sharding-strategy" class="exampleblock">
<div class="title">示例157注册自定义IndexShardingStrategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexName&gt;].sharding_strategy = my.custom.RandomShardingStrategy</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advanced-features-dynamic-sharding"><a class="anchor" href="#advanced-features-dynamic-sharding"></a> 10.5.2。动态分片</h4>
<div class="paragraph">
<p>动态分片使您可以自己管理分片，甚至可以动态创建新的分片。为此，您需要实现ShardIdentifierProvider接口并设置hibernate.search。 <indexname>] .sharding_strategy属性为此类的完全限定名称。注意，与其直接实现接口，不如从org.hibernate.search.store派生实现。ShardIdentifierProviderTemplate提供基本的实现。让我们来看一个<a href="#example-custom-shard-identifier-provider">Custom ShardIdentifierProvider</a>的例子。</indexname></p>
</div>
<div id="example-custom-shard-identifier-provider" class="exampleblock">
<div class="title">例子158。自定义ShardIdentifierProvider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class AnimalShardIdentifierProvider extends ShardIdentifierProviderTemplate {

 @Override
 public String getShardIdentifier(Class&lt;?&gt; entityType, Serializable id,
         String idAsString, Document document) {
    if (entityType.equals(Animal.class)) {
       String typeValue = document.getField("type").stringValue();
       addShard(typeValue);
       return typeValue;
    }
    throw new RuntimeException("Animal expected but found " + entityType);
 }

 @Override
 protected Set&lt;String&gt; loadInitialShardNames(Properties properties, BuildContext buildContext) {
    ServiceManager serviceManager = buildContext.getServiceManager();
    SessionFactory sessionFactory = serviceManager.requestService(
        HibernateSessionFactoryService.class).getSessionFactory();
    Session session = sessionFactory.openSession();
    try {
       Criteria initialShardsCriteria = session.createCriteria(Animal.class);
       initialShardsCriteria.setProjection(Projections.distinct(Property.forName("type")));
       List&lt;String&gt; initialTypes = initialShardsCriteria.list();
       return new HashSet&lt;String&gt;(initialTypes);
    }
    finally {
       session.close();
    }
 }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>发生了几件事<code>AnimalShardIdentifierProvider</code> 。首先，其目的是为每种动物类型（例如哺乳动物，昆虫等）创建一个碎片。通过检查类类型和传递给<code>getShardIdentifier()</code>方法。它从文档中提取类型字段，并将其用作分片名称。 <code>getShardIdentifier()</code>索引的每一个增加都会调用，然后会遇到每种新的动物类型来创建一个新的碎片。基类<code>ShardIdentifierProviderTemplate</code>维护具有所有已知分片的集合，必须通过调用将任何标识符添加到该分片<code>addShard()</code> 。</p>
</div>
<div class="paragraph">
<p>重要的是要了解，Hibernate Search无法在应用程序启动时知道哪些分片已经存在。使用时<code>ShardIdentifierProviderTemplate</code>作为一个基类<code>ShardIdentifierProvider</code>实现中，分片标识符的初始集合必须由<code>loadInitialShardNames()</code>方法。如何完成将取决于用例。但是，与Hibernate ORM结合使用的一种常见情况是，初始分片集由给定数据库列的不同值定义。<a href="#example-custom-shard-identifier-provider">自定义ShardIdentifierProvider</a>显示了如何处理这种情况。 <code>AnimalShardIdentifierProvider</code>使它<code>loadInitialShardNames()</code>实现使用称为<code>HibernateSessionFactoryService</code> （另请参见<a href="#section-services">使用外部服务</a> ），这在ORM环境中可用。它允许请求Hibernate<code>SessionFactory</code>实例，该实例可用于运行“条件”查询以便确定分片标识符的初始集合。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的是<code>ShardIdentifierProvider</code>还可以通过选择针对哪个分片运行查询来优化搜索。通过激活过滤器（请参阅<a href="#query-filter-shard">在</a>分片<a href="#query-filter-shard">环境中使用过滤器</a> ），分片策略可以选择用于回答查询的分片子集（ <code>getShardIdentifiersForQuery()</code> ，该示例中未显示），从而加快了查询的执行速度。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该ShardIdentifierProvider被认为是实验性的。我们可能需要对定义的方法签名进行一些更改，以适应无法预料的用例。如果您有想法，请提供反馈，或者只是让我们知道您如何使用此API。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-sharing-indexes"><a class="anchor" href="#section-sharing-indexes"></a> 10.6。共享索引</h3>
<div class="paragraph">
<p>从技术上讲，可以将多个实体的信息存储到单个Lucene索引中。有两种方法可以实现此目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置基础目录提供程序以指向相同的物理索引目录。实际上，您设置属性<code>hibernate.search.[fully qualified entity name].indexName</code>值相同举例来说，我们将相同的索引（目录）用于<code>Furniture</code>和<code>Animal</code>实体。我们刚刚设定<code>indexName</code>将两个实体都设为“动物”。然后，这两个实体将存储在Animal目录中：</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>将要合并的实体的@Indexed批注的index属性设置为相同的值。如果我们再次希望所有的Furniture实例以及所有的Animal实例都在Animal索引中被索引，我们将在Animal和Furniture类上都指定@Indexed（index =“ Animal”）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅在此处显示，以使您知道该选项可用。共享索引确实没有太多好处。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="section-services"><a class="anchor" href="#section-services"></a> 10.7。使用外部服务</h3>
<div class="paragraph">
<p>一种<code>Service</code> Hibernate Search中的类是实现接口的类<code>org.hibernate.search.engine.service.spi.Service</code>并提供默认的无参数构造函数。从理论上讲，这就是从Hibernate Search请求给定服务类型所需的全部<code>ServiceManager</code> 。实际上，您可能想添加一些服务生命周期方法（实现<code>Startable</code>和<code>Stoppable</code> ）以及提供某些功能的实际方法。</p>
</div>
<div class="paragraph">
<p>Hibernate Search使用服务方法来解耦系统的不同组件。让我们仔细看看服务及其使用方式。</p>
</div>
<div class="sect3">
<h4 id="_using_a_service"><a class="anchor" href="#_using_a_service"></a> 10.7.1。使用服务</h4>
<div class="paragraph">
<p>Hibernate Search的许多可插拔合同都可以使用服务。可通过以下方式访问服务<code>BuildContext</code>界面如下例所示。</p>
</div>
<div class="exampleblock">
<div class="title">例子159。使用ClassLoaderService的自定义DirectoryProvider的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public CustomDirectoryProvider implements DirectoryProvider&lt;RAMDirectory&gt; {
    private ServiceManager serviceManager;
    private ClassLoaderService classLoaderService;

    public void initialize(
        String directoryProviderName,
        Properties properties,
        BuildContext context) {
        //get a reference to the ServiceManager
        this.serviceManager = context.getServiceManager();
    }

    public void start() {
        //get the current ClassLoaderService
        classLoaderService = serviceManager.requestService(ClassLoaderService.class);
    }

    public RAMDirectory getDirectory() {
        //use the ClassLoaderService
    }

    public stop() {
        //make sure to release all services
        serviceManager.releaseService(ClassLoaderService.class);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您请求服务时，将向您返回请求的服务类型的实例。确保通过以下方式释放服务<code>ServiceManager.releaseService</code>一旦您不再需要它。请注意，该服务可以在<code>DirectoryProvider.stop</code>如果<code>DirectoryProvider</code>在服务的生命周期内使用该服务，如果仅在初始化期间需要该服务，则可以立即将其释放。</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_a_service"><a class="anchor" href="#_implementing_a_service"></a> 10.7.2。实施服务</h4>
<div class="paragraph">
<p>要实现服务，您需要创建一个可以识别服务并进行扩展的接口<code>org.hibernate.search.engine.service.spi.Service</code> 。然后，您可以根据需要向服务接口添加其他方法。</p>
</div>
<div class="paragraph">
<p>当然，您还需要提供服务接口的实现。此实现必须具有公共的无参数构造函数。您的服务也可以选择实现生命周期方法<code>org.hibernate.search.engine.service.spi.Startable</code>和/或<code>org.hibernate.search.engine.service.spi.Stoppable</code> 。这些方法将由<code>ServiceManager</code>当分别创建服务时，释放对所请求服务的最后引用。</p>
</div>
<div class="paragraph">
<p>服务是从<code>ServiceManager.requestService</code>使用<code>Class</code>您定义为键的接口的对象。</p>
</div>
<div class="sect4">
<h5 id="_managed_services"><a class="anchor" href="#_managed_services"></a>管理服务</h5>
<div class="paragraph">
<p>为了透明地发现服务，Hibernate Search使用Java ServiceLoader机制。这意味着您需要在下面的jar中添加服务文件<code>/META-INF/services/</code>以服务接口的完全合格的类名命名。该文件的内容包含服务实现的完全限定的类名。</p>
</div>
<div class="exampleblock">
<div class="title">例子160。Infinispan CacheManagerService服务的服务文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>/META-INF/services/org.infinispan.hibernate.search.spi.CacheManagerService</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例161META-INF / services / org.infinispan.hibernate.search.spi的内容。CacheManagerService</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>org.infinispan.hibernate.search.impl.DefaultCacheManagerService</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search仅支持给定服务的单个服务实现。没有机制可以在服务的多个版本之间进行选择。有多个jar分别为同一服务定义不同的实现是错误的。如果要在运行时覆盖现有服务的实现，则需要查看<a href="#section-provided-services">提供的服务</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="section-provided-services"><a class="anchor" href="#section-provided-services"></a>提供的服务</h5>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>提供的服务通常由与Hibernate Search集成的框架使用，而不是由库用户本身使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>作为管理服务的替代方法，可以通过引导Hibernate Search的环境提供服务。例如，使用Hibernate Search作为内部搜索引擎的Infinispan传递了<code>CacheContainer</code>Hibernate搜索。在这种情况下， <code>CacheContainer</code>实例不受Hibernate Search的管理，并且start / stop方法由可选的方法定义<code>Stoppable</code>和<code>Startable</code>接口将被忽略。</p>
</div>
<div class="paragraph">
<p>仅用作提供服务的Service实现不需要具有不带参数的public构造函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>提供的服务优先于托管服务。如果提供的服务已在同一服务中注册<code>ServiceManager</code>实例作为托管服务，将使用提供的服务。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>提供的服务通过以下方式传递给Hibernate Search： <code>SearchConfiguration</code>接口：作为方法的实现者<code>getProvidedServices</code>你可以返回一个<code>Map</code>您需要提供的所有服务中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实施自定义时<code>org.hibernate.search.cfg.spi.SearchConfiguration</code>我们建议您扩展基类<code>org.hibernate.search.cfg.spi.SearchConfigurationBase</code> ：可以在我们需要向该接口添加新方法时不破坏您的代码来提高兼容性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-custom-similarity"><a class="anchor" href="#section-custom-similarity"></a> 10.8。自定义Lucene的评分公式</h3>
<div class="paragraph">
<p>Lucene允许用户通过扩展org.apache.lucene.search.similarities来定制其评分公式。相似。此类中定义的抽象方法与以下公式的因素匹配，这些公式计算文档d的查询q得分：</p>
</div>
<div class="paragraph">
<p><strong>分数（q，d）=坐标（q，d）·queryNorm（q）·∑〜t in q〜（tf（t in d）·idf（t） <sup>2</sup> ·t.getBoost（）·norm（t，d ））</strong></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">因子</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tf（t ind）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文档（d）中术语（t）的术语频率系数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">idf（t）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">术语的反文档频率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">坐标（q，d）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">得分因子基于在指定文档中找到多少个查询词。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">queryNorm（q）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于使查询之间的分数可比的标准化因子。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">t.getBoost（）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">场增强。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">规范（t，d）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">封装一些（索引时间）提升和长度因素。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>更详细地解释此公式超出了本手册的范围。请参阅相似性的Javadocs以获得更多信息。</p>
</div>
<div class="paragraph">
<p>Hibernate Search提供了两种修改Lucene相似度计算的方法。</p>
</div>
<div class="paragraph">
<p>首先，您可以使用属性hibernate.search.similarity指定完全相似的类实现，以设置默认相似度。默认值为org.apache.lucene.search.similarities。经典相似。</p>
</div>
<div class="paragraph">
<p>其次，您可以通过设置<code>similarity</code>该索引的属性（有关索引配置的更多信息，请参阅<a href="#search-configuration-directory">目录</a>配置）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].similarity = my.custom.Similarity</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，假设一个术语在文档中出现的频率不重要。一次出现该术语的文档应与多次出现的文档评分相同。在这种情况下，您的方法的自定义实现<code>tf(float freq)</code>应该返回1.0。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当两个实体共享相同的索引时，它们必须声明相同的相似性实现。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="section-multi-tenancy"><a class="anchor" href="#section-multi-tenancy"></a> 10.9。多租户</h3>
<div class="sect3">
<h4 id="_what_is_multi_tenancy"><a class="anchor" href="#_what_is_multi_tenancy"></a> 10.9.1。什么是多租户？</h4>
<div class="paragraph">
<p>术语“多租户”通常用于软件开发，以表示一种体系结构，其中应用程序的单个运行实例同时为多个客户端（租户）提供服务。在这些系统中，隔离与各种租户有关的信息（数据，定制等）是一个特殊的挑战。这包括存储在数据库中的每个租户所拥有的数据。您将在《 <a href="http://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#multitenacy">Hibernate ORM开发人员指南》中</a>找到有关如何使用Hibernate启用多租户的更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_tenant_aware_code_fulltextsession_code"><a class="anchor" href="#_using_a_tenant_aware_code_fulltextsession_code"></a> 10.9.2。使用承租人感知<code>FullTextSession</code></h4>
<div class="paragraph">
<p>Hibernate Search在Hibernate ORM之上支持多租户，它将租户标识符存储在文档中并自动过滤查询结果。</p>
</div>
<div class="paragraph">
<p>的<code>FullTextSession</code>将被绑定到特定的租户（示例中为“ client-A”），并且质量索引器将仅索引与该租户标识符关联的实体。</p>
</div>
<div class="exampleblock">
<div class="title">实施例162。将会话绑定到租户</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = getSessionFactory()
                      .withOptions()
                          .tenantIdentifier( "client-A" )
                  .openSession();

FullTextSession session = Search.getFullTextSession( session );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>租户标识符的使用将产生以下效果：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>索引中保存或更新的每个文档都会有一个附加字段<code>__HSearch_TenantId</code>包含租户标识符。</p>
</li>
<li>
<p>每次搜索都将使用租户标识符进行过滤。</p>
</li>
<li>
<p>MassIndexer（请参阅<a href="#search-batchindex-massindexer">使用MassIndexer</a> ）将仅影响当前选定的租户。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，不使用租户将返回索引中所有租户的所有匹配结果。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch-integration"><a class="anchor" href="#elasticsearch-integration"></a> 11。与Elasticsearch集成</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_status"><a class="anchor" href="#_status"></a> 11.1。状态</h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此功能正在进行中。请务必阅读“ <a href="#elasticsearch-limitations">限制”</a>部分！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与Elasticsearch的集成尚在开发中，应视为试验性的。我们确实认为我们已经涵盖了基础知识，我们正在寻求反馈。</p>
</div>
<div class="paragraph">
<p>补丁可以作为拉取请求发送到<a href="https://github.com/hibernate/hibernate-search">Github存储库</a> ，但是也欢迎常规反馈，建议和问题。要与贡献者取得联系或找到其他有趣的链接，请参见Hibernate网站的“ <a href="http://hibernate.org/community/">社区”页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_goal_of_the_elasticsearch_integration"><a class="anchor" href="#_goal_of_the_elasticsearch_integration"></a> 11.2。Elasticsearch集成的目标</h3>
<div class="paragraph">
<p>与Elasticsearch集成的目标是允许Hibernate Search用户从与Hibernate ORM集成的全文功能中受益，但可以使用远程Elasticsearch服务替换基于本地Lucene的索引。</p>
</div>
<div class="paragraph">
<p>与“嵌入式Lucene”方法相比，可能有多种原因更喜欢此方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>希望将运行您的应用程序的服务与搜索服务（微服务）分开</p>
</li>
<li>
<p>受益于Elasticsearch的开箱即用的水平可扩展性和高可用性功能</p>
</li>
<li>
<p>与现有的Elasticsearch集群集成</p>
</li>
<li>
<p>使用Elasticsearch仪表板集成（例如Kibana）探索由Hibernate驱动的应用程序更新的数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与嵌入式Lucene方法相比，存在一些缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引更新和运行查询都会导致远程RPC的性能下降</p>
</li>
<li>
<p>需要管理其他服务</p>
</li>
<li>
<p>可能需要购买和管理其他服务器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最佳解决方案将取决于您的系统和组织的特定需求。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">为什么不直接使用Elasticsearch？</div>
<div class="paragraph">
<p>排名第一的原因是Hibernate Search与Hibernate ORM完美集成。对对象所做的所有更改将透明地触发必要的索引更改。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它将遵守交易边界-即如果交易最终回滚，则不执行索引工作</p>
</li>
<li>
<p>处理级联对象的更改</p>
</li>
<li>
<p>处理嵌入在根索引实体中的嵌套对象的更改</p>
</li>
<li>
<p>更改将批量发送-即为您系统地优化</p>
</li>
<li>
<p>它从您的实体生成JSON编码的请求，解析响应</p>
</li>
<li>
<p>管理连接池</p>
</li>
<li>
<p>等等</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您的代码中没有更多的范式转移。您正在处理Hibernate ORM管理的对象，并使用漂亮的Java DSL对对象属性进行查询。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_started_and_configuration"><a class="anchor" href="#_getting_started_and_configuration"></a> 11.3。入门和配置</h3>
<div class="paragraph">
<p>要试验Elasticsearch集成，您必须下载Elasticsearch并运行它：Hibernate Search连接到Elasticsearch节点，但不提供该节点。</p>
</div>
<div class="paragraph">
<p>一种选择是使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">Elasticsearch Docker映像</a> 。</p>
</div>
<div class="sect3">
<h4 id="_elasticsearch_version"><a class="anchor" href="#_elasticsearch_version"></a> 11.3.1。Elasticsearch版本</h4>
<div class="paragraph">
<p>Hibernate Search期望运行版本2.x或5.x的Elasticsearch集群。群集上运行的版本将在启动时自动检测，并且Hibernate Search将根据检测到的版本进行调整。</p>
</div>
<div class="paragraph">
<p>目标版本对于Hibernate Search用户而言大部分是透明的，但是根据可能影响您的Elasticsearch版本，Hibernate Search的行为方式会有一些差异。下表详细说明了这些差异。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">2.x</th>
<th class="tableblock halign-left valign-top">5.0 / 5.1</th>
<th class="tableblock halign-left valign-top">5.2+</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">清除所需的配置</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#elasticsearch-integration-server-configuration">启用按查询删除插件</a></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">没有</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Elasticsearch中用于String字段的数据类型</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code> （如果已分析）或<code>keyword</code> （如果不）。的<code>string</code>数据类型<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/string.html">已在Elasticsearch 5.0中弃用</a> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code> （如果使用分析<a href="#analyzer">仪</a>进行了<a href="#analyzer">分析</a> ）或<code>keyword</code> （如果未分析或未使用<a href="#section-normalizers">规范化工具</a>进行分析）。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="#field-annotation-norms">规范</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">未实现</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">已实施</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">实施<a href="#field-annotation-indexNullAs"><code>@Field.indexNullAs</code></a>用于分析的文本字段</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/null-value.html"><code>null_value</code></a>被添加到映射， <code>null</code>值被这样索引。</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/null-value.html"><code>null_value</code></a>不适用于<code>text</code>字段，将空值替换为<code>indexNullAs</code>索引时明确显示值。
 <br>这不适用于<code>keyword</code>领域。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">没有空间排序的空间投影所需的配置</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#elasticsearch-integration-server-configuration">启用并配置groovy插件</a></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，Hibernate Search的测试套件针对Elasticsearch 5.6.8运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_upgrading_elasticsearch"><a class="anchor" href="#_upgrading_elasticsearch"></a>升级Elasticsearch</h5>
<div class="paragraph">
<p>升级Elasticsearch集群时，集群上仍需要<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html">执行</a>一些<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html">管理任务</a> ：Hibernate Search不会执行这些任务。</p>
</div>
<div class="paragraph">
<p>最重要的是，某些版本的Elasticsearch之间存在一些根本差异，因此，某些升级将要求您手动删除索引并为<a href="#search-batchindex">数据重新索引</a> 。</p>
</div>
<div class="paragraph">
<p>需要进行此类更改的升级如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从2.x升级到5.x，因为Hibernate Search不支持<code>string</code> Elasticsearch 5.x上的数据类型；</p>
</li>
<li>
<p>如果您使用<a href="#section-normalizer">规范化器</a> ，则从5.0 / 5.1升级到5.2+，因为Hibernate Search规范化器从Elasticsearch 5.2开始映射到本机Elasticsearch规范化器，从而使用规范化器更改字段的数据类型<code>text</code>至<code>keyword</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-dependencies"><a class="anchor" href="#elasticsearch-integration-dependencies"></a> 11.3.2。Java应用程序中的依赖项</h4>
<div class="paragraph">
<p>除了像Hibernate ORM和Hibernate Search这样的常用依赖项之外，您还需要新的<code>hibernate-search-elasticsearch</code>罐。</p>
</div>
<div class="exampleblock">
<div class="title">示例163。使用Elasticsearch进行Hibernate Search的Maven依赖关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-elasticsearch&lt;/artifactId&gt;
   &lt;version&gt;5.11.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您通过请求签名使用Amazon专有的IAM身份验证来访问Elasticsearch，则将需要其他依赖项来处理身份验证： <code>hibernate-search-elasticsearch-aws</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例164。使用AWS托管的Elasticsearch进行Hibernate Search的Maven依赖关系</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-elasticsearch-aws&lt;/artifactId&gt;
   &lt;version&gt;5.11.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-server-configuration"><a class="anchor" href="#elasticsearch-integration-server-configuration"></a> 11.3.3。Elasticsearch配置</h4>
<div class="paragraph">
<p>Hibernate Search可以与Elasticsearch服务器一起使用，而无需更改其配置。</p>
</div>
<div class="paragraph">
<p>但是，Hibernate Search提供的某些功能需要特定的配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅在Elasticsearch 2.x上（在5.x上不需要）：如果您希望能够将Hibernate Search <a href="#search-batchindex-massindexer">MassIndexer</a>与<code>purgeAllOnStart</code>已启用-默认情况下已启用-或使用<code>FullTextSession.purge()</code>要么<code>FullTextSession.purgeAll()</code> ，安装<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.2/plugins-delete-by-query.html"><code>delete-by-query</code>插入</a></p>
</li>
<li>
<p>仅在Elasticsearch 2.x上（在5.x上不是必需的）：如果要在地理位置查询中检索距离，请启用<code>lang-groovy</code>插件，请参阅<a href="#elasticsearch-query-spatial">Elasticsearch空间查询</a></p>
</li>
<li>
<p>如果您要对大于10000个元素的结果集使用分页（而不是<a href="#elasticsearch-scrolling">滚动</a> ）（例如，访问第10001个结果），则可以增加<code>index.max_result_window</code>属性（默认值为10000）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-configuration"><a class="anchor" href="#elasticsearch-integration-configuration"></a> 11.3.4。Hibernate搜索配置</h4>
<div class="paragraph">
<p>配置最少。将配置属性添加到您的<code>persistence.xml</code>或将其余的Hibernate Search配置放在哪里。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">选择Elasticsearch作为后端</dt>
<dd>
<p><code>hibernate.search.default.indexmanager elasticsearch</code></p>
</dd>
<dt class="hdlist1">Elasticsearch的主机名和端口</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.host http://127.0.0.1:9200</code> （默认）</p>
<div class="paragraph">
<p>您还可以选择多个主机（用空格字符分隔），以便依次为它们分配请求（负载平衡）：</p>
</div>
<div class="paragraph">
<p><code>hibernate.search.default.elasticsearch.host http://es1.mycompany.com:9200 http://es2.mycompany.com:9200</code></p>
</div>
<div class="paragraph">
<p>在上面的示例中，第一个请求将转到<code>es1</code> ，第二个<code>es2</code> ，第三个<code>es1</code> ， 等等。</p>
</div>
<div class="paragraph">
<p>另请注意，拥有多个主机将启用故障转移：如果一个节点碰巧无法处理请求（超时，服务器错误，无效的HTTP响应等），则相同的请求将发送至下一个请求;如果第二个请求没有错误地得到服务，则故障将归咎于该节点，并且不会向应用程序报告任何错误。</p>
</div>
<div class="paragraph">
<p>当您只有一台已配置的主机但由于自动发现而添加了其他主机时，也会启用故障转移功能（请参见下文）。</p>
</div>
</dd>
<dt class="hdlist1">Elasticsearch实例的可选路径前缀</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.path_prefix /my/path</code></p>
<div class="paragraph">
<p>在典型的Elasticsearch设置中，不应设置它。</p>
</div>
<div class="paragraph">
<p>如果您的Elasticsearch实例位于特定的上下文路径（例如，托管在<a href="http://localhost/my/elasticsearch/" class="bare">http：// localhost / my / elasticsearch /</a> ），请使用路径前缀。</p>
</div>
<div class="paragraph">
<p>路径前缀设置是全局的，因此您的Elasticsearch群集配置在此问题上必须保持一致。</p>
</div>
</dd>
<dt class="hdlist1">Elasticsearch连接的用户名</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.username ironman</code> （默认为空，表示匿名访问）</p>
</dd>
<dt class="hdlist1">Elasticsearch连接的密码</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.password j@rV1s</code> （默认为空）</p>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您在任何Elasticsearch主机URL中使用HTTP而非HTTPS（请参见上文），则密码将通过网络以明文形式传输。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1"><a id="elasticsearch-schema-management-strategy"></a>选择索引创建策略</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.index_schema_management_strategy CREATE</code> （默认）</p>
<div class="paragraph">
<p>让我们来看看<code>index_schema_management_strategy</code>属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不会创建，删除或更改索引，其映射和分析器定义。Hibernate Search <strong>甚至不会检查</strong>索引是否已存在。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将检查索引，索引的现有映射和分析器定义，以使其与应用程序的元模型兼容。不会创建，删除或更改索引，其映射和分析器定义。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>update</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将创建索引，其映射和分析器定义，如果不存在冲突，则将更新现有映射。注意：如果必须更新分析器定义，则索引将在更新过程中自动关闭。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>默认值</strong> ：现有索引不会更改，缺少的索引将与它们的映射和分析器定义一起创建。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drop-and-create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">索引将被删除（如果存在），然后与它们的映射和分析器定义一起创建以符合您的应用要求。这将从索引中删除所有内容！在开发过程中有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drop-and-create-and-drop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">相似<code>drop-and-create</code>但也会在关机时删除索引。常用于测试。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于Amazon Web Services（AWS） <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-es-operations.html">上的</a> Elasticsearch <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-es-operations.html">不支持<code>_close</code> / <code>_open</code>运营</a> <code>update</code>尝试更新AWS Elasticsearch集群上的分析器定义时，策略将失败。</p>
</div>
<div class="paragraph">
<p>唯一的解决方法是避免<code>update</code> AWS策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">生产环境中的策略</div>
<div class="paragraph">
<p>强烈建议使用<code>none</code>要么<code>validate</code>在生产环境中。</p>
</div>
<div class="paragraph">
<p>替代品<code>drop-and-create</code>和<code>drop-and-create-and-drop</code>在这种情况下显然不适合，除非您希望在每次启动时都重新索引所有内容，并且<code>update</code>如果发生冲突，可能会使您的映射保持半更新状态。</p>
</div>
<div class="paragraph">
<p>确切地说，如果您的映射以不兼容的方式更改（例如，其类型已更改的字段），那么在没有人工干预的情况下可能无法更新映射。在这种情况下， <code>update</code>该策略将阻止Hibernate Search启动，但是它可能已经成功更新了另一个索引的映射，从而使回滚变得很困难。</p>
</div>
<div class="paragraph">
<p>在更新分析器定义时，Hibernate Search将在更新过程中暂时停止受影响的索引。这意味着<code>update</code>当多个客户端使用由Hibernate Search管理的Elasticsearch索引时，应谨慎使用该策略：这些客户端应以这样的方式进行同步：启动Hibernate Search时，其他客户端无需访问该索引。</p>
</div>
<div class="paragraph">
<p>由于这些原因，应在部署过程中适当计划在活动群集上迁移映射。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>映射验证尽可能地宽松。Hibernate Search未知的字段或映射将被忽略，并且设置的功能比要求的更强大（例如，带有注释的字段<code>@Field(index = Index.NO)</code>在搜索中，但标记为<code>"index": analyzed</code>在Elasticsearch中）将被视为有效。</p>
</div>
<div class="paragraph">
<p>一个例外：由于实施限制，日期格式必须与Hibernate Search指定的格式完全匹配。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1">失败之前等待对Elasticsearch服务器的请求成功执行的最长时间（以毫秒为单位）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.request_timeout 60000</code> （默认）</p>
<div class="paragraph">
<p>请求的执行时间包括建立连接，发送请求和接收整个响应所需的时间，如果节点发生故障，可以选择重试。</p>
</div>
</dd>
<dt class="hdlist1">失败之前等待连接到Elasticsearch服务器的最长时间（以毫秒为单位）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.connection_timeout 3000</code> （默认）</p>
</dd>
<dt class="hdlist1">在失败之前等待来自Elasticsearch服务器的响应的最长时间（以毫秒为单位）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.read_timeout 60000</code> （默认）</p>
</dd>
<dt class="hdlist1">到Elasticsearch集群的最大同时连接数</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.max_total_connection 20</code> （默认）</p>
</dd>
<dt class="hdlist1">到单个Elasticsearch服务器的最大同时连接数</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.max_total_connection_per_route 2</code> （默认）</p>
</dd>
<dt class="hdlist1">是否在Elasticsearch集群中启用服务器自动发现（ <code>true</code>要么<code>false</code> ）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.enabled false</code> （默认）</p>
<div class="paragraph">
<p>使用自动发现时，Elasticsearch客户端将定期探测集群中的新节点，并将这些节点添加到服务器列表中（请参见<code>host</code>以上）。同样，客户端将定期检查注册的服务器是否仍然响应，如果没有响应，则会将其从服务器列表中删除。</p>
</div>
</dd>
<dt class="hdlist1">两次自动发现之间的时间间隔（以秒为单位）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.refresh_interval 10</code> （默认）</p>
<div class="paragraph">
<p>如果启用了自动发现，则仅会考虑此设置（请参见上文）。</p>
</div>
</dd>
<dt class="hdlist1">连接到自动发现的节点时要使用的方案（ <code>http</code>要么<code>https</code> ）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.default_scheme http</code> （默认）</p>
<div class="paragraph">
<p>如果启用了自动发现，则仅会考虑此设置（请参见上文）。</p>
</div>
</dd>
<dt class="hdlist1">失败之前等待索引变为可用的最长时间（以毫秒为单位）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.index_management_wait_timeout 10000</code> （默认）</p>
<div class="paragraph">
<p>当<code>NONE</code>选择策略，因为在启动时不会检查索引（请参见上文）。</p>
</div>
<div class="paragraph">
<p>该值必须小于读取超时（请参见上文）。</p>
</div>
</dd>
<dt class="hdlist1">索引必须至少具有某种状态，以便Hibernate Search可以使用它（“绿色”，“黄色”或“红色”之一）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.required_index_status green</code> （默认）</p>
<div class="paragraph">
<p>仅当索引处于此级别或更安全时才操作。在开发中，将此值设置为<code>yellow</code>如果启动的节点数小于预期的副本数。</p>
</div>
</dd>
<dt class="hdlist1">在针对特定索引执行了一组操作后是否执行显式刷新（ <code>true</code>要么<code>false</code> ）</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.refresh_after_write false</code> （默认）</p>
<div class="paragraph">
<p>这在单元测试中很有用，以确保查询可以立即看到写入而不会延迟。这使单元测试更加简单。除非在极少数情况下，否则您不应该依赖生产代码的同步行为，因为Elasticsearch已针对异步写入进行了优化：请留在<code>false</code>以获得最佳性能。</p>
</div>
</dd>
<dt class="hdlist1"><a href="#elasticsearch-scrolling">滚动时</a> ，可以随时在内存中保留最少的先前结果数</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_backtracking_window_size 10000</code> （默认）</p>
</dd>
<dt class="hdlist1"><a href="#elasticsearch-scrolling">滚动时</a> ，每个Elasticsearch调用获取的结果数</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_fetch_size 1000</code> （默认）</p>
</dd>
<dt class="hdlist1"><a href="#elasticsearch-scrolling">滚动时</a> ，最大持续时间<code>ScrollableResults</code>如果没有其他可从Elasticsearch获取的结果，将在几秒钟内可用</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_timeout 60</code> （默认）</p>
</dd>
<dt class="hdlist1">与Elasticsearch映射中动态添加的字段有关的行为</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.dynamic_mapping strict</code> （默认）</p>
<div class="paragraph">
<p>可能的值为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>true</code> ：将未知字段动态添加到架构</p>
</li>
<li>
<p><code>false</code> ：忽略未知字段</p>
</li>
<li>
<p><code>strict</code> ：在未知字段上引发异常</p>
<div class="paragraph">
<p>在每个字段的自定义字段网桥中，可以覆盖此设置：请参阅<a href="#elasticsearch-custom-field-bridge-dynamic-mapping">动态映射</a> 。</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a id="elasticsearch-log-json-pretty-printing"></a>日志中包含的JSON是否应打印精美（缩进，带有换行符）（ <code>true</code>要么<code>false</code> ）</dt>
<dd>
<p><code>hibernate.search.elasticsearch.log.json_pretty_printing false</code> （默认）</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>前缀为<code>hibernate.search.default</code>可以如上所示全局指定和/或针对特定索引指定：</p>
</div>
<div class="paragraph">
<p><code>hibernate.search.someindex.elasticsearch.index_schema_management_strategy update</code></p>
</div>
<div class="paragraph">
<p>这不包括与内部Elasticsearch客户端相关的属性，此属性目前对每个索引管理器都是公用的（但是在将来的版本中会有所变化）。排除的属性是<code>host</code> ， <code>username</code> ， <code>password</code> ， <code>read_timeout</code> ， <code>connection_timeout</code> ， <code>max_total_connection</code> ， <code>max_total_connection_per_route</code> ， <code>http_client_configurer</code> ， <code>discovery.enabled</code> ， <code>discovery.refresh_interval</code>和<code>discovery.scheme</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="elasticsearch-integration-configuration-aws"><a class="anchor" href="#elasticsearch-integration-configuration-aws"></a> Amazon Web Services上的身份验证</h5>
<div class="paragraph">
<p>Amazon通过请求签名进行的专有IAM身份验证<a href="#elasticsearch-integration-dependencies">需要其他依赖项</a> 。有了这些依赖性，您将能够使用以下配置选项。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">启用或禁用AWS请求签名</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.signing.enabled false</code> （默认）</p>
<div class="paragraph">
<p>该值必须是<code>true</code>要么<code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">AWS访问密钥</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.access_key AKIDEXAMPLE</code></p>
<div class="paragraph">
<p>此属性没有默认值，必须提供该属性才能使AWS身份验证起作用。</p>
</div>
</dd>
<dt class="hdlist1">AWS密钥</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.secret_key wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY</code></p>
<div class="paragraph">
<p>此属性没有默认值，必须提供该属性才能使AWS身份验证起作用。</p>
</div>
</dd>
<dt class="hdlist1">AWS区域</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.region us-east-1</code></p>
<div class="paragraph">
<p>此属性没有默认值，必须提供该属性才能使AWS身份验证起作用。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果您需要帮助以找到正确的值来使用，请参阅有关<a href="http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html">安全凭证</a>和<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html">区域</a>的AWS文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>设置这些特定于AWS的配置属性不足以启用Elasticsearch集成：您还应该查看<a href="#elasticsearch-integration-configuration">主要配置属性</a> ，尤其是<code>hibernate.search.default.indexmanager</code>和<code>hibernate.search.default.elasticsearch.host</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mapping_and_indexing"><a class="anchor" href="#_mapping_and_indexing"></a> 11.4。映射和索引</h3>
<div class="paragraph">
<p>像在Lucene嵌入式模式下一样，当您创建或更新映射到Hibernate Search的实体时，索引将透明更新。只需使用从<a href="#search-mapping">Mapping实体到索引结构的</a>熟悉注释。</p>
</div>
<div class="paragraph">
<p>索引名称将是提供给的小写名称<code>@Indexed</code> （默认情况下为非合格的类名）。Hibernate Search会将完全限定的类名称映射到Elasticsearch类型。</p>
</div>
<div class="sect3">
<h4 id="_annotation_specificities"><a class="anchor" href="#_annotation_specificities"></a> 11.4.1。注释特异性</h4>
<div class="sect4">
<h5 id="_field_indexnullas"><a class="anchor" href="#_field_indexnullas"></a> Field.indexNullAs</h5>
<div class="paragraph">
<p>的<code>org.hibernate.search.annotations.Field</code>批注允许您通过以下方式为空属性提供替换值： <code>indexNullAs</code>属性（请参阅<a href="#field-annotation">@Field</a> ），但是此值必须以字符串形式提供。</p>
</div>
<div class="paragraph">
<p>为了让Hibernate Search（和Elasticsearch）理解您的价值，提供的字符串必须遵循以下格式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于字符串值，不需要特定的格式。</p>
</li>
<li>
<p>对于数值，请使用接受的格式<code>Double.parseDouble</code> ， <code>Integer.parseInteger</code>等等，具体取决于您的字段的实际类型。</p>
</li>
<li>
<p>对于布尔值，请使用<code>true</code>要么<code>false</code> 。</p>
</li>
<li>
<p>对于日期（ <code>java.util.Calendar</code> ， <code>java.util.Date</code> ， <code>java.time.*</code> ），请使用ISO-8601格式。</p>
<div class="paragraph">
<p>完整格式为<code>yyyy-MM-dd’T’HH:mm:ss.nZ[ZZZ]</code> （例如<code>2016-11-26T16:41:00.006+01:00[CET]</code> ）。但是请记住，根据您的字段类型，必须忽略此格式的一部分。为一个<code>java.time.LocalDateTime</code>字段，例如，提供的字符串不得包含区域偏移量（ <code>+01:00</code> ）或区域ID（ <code>[UTC]</code> ），因为这些没有意义。</p>
</div>
<div class="paragraph">
<p>即使它们对您的字段类型有意义，也可以省略时间和时区（如果省略，则时区将被解释为默认的JVM时区）。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_index_time_boosting"><a class="anchor" href="#_index_time_boosting"></a>索引时间提升</h5>
<div class="paragraph">
<p>的<code>org.hibernate.search.annotations.DynamicBoost</code> Elasticsearch不（也不能）支持注解，因为该平台缺少按文档的索引时间提升功能。</p>
</div>
<div class="paragraph">
<p>的<code>@Boost</code>注解可以使用，但由于已弃用，建议您改用查询时间提升：请参阅<a href="#search-query">Querying</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-mapping-analyzer"><a class="anchor" href="#elasticsearch-mapping-analyzer"></a> 11.4.2。分析仪</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">分析器的处理方式不同于Lucene嵌入式模式。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_built_in_or_server_defined_analyzers"><a class="anchor" href="#_built_in_or_server_defined_analyzers"></a>内置或服务器定义的分析仪</h5>
<div class="paragraph">
<p>使用<code>definition</code>中的属性<code>@Analyzer</code>批注，您可以引用内置Elasticsearch分析器的名称，也可以引用已经在您的Elasticsearch实例上注册的自定义分析器的名称。</p>
</div>
<div class="paragraph">
<p>可以在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html">Elasticsearch文档中</a>找到有关分析器的更多信息，尤其是那些已经在Elasticsearch中内置的分析器。</p>
</div>
<div class="listingblock">
<div class="title">elasticsearch.yml中定义的定制分析器示例</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yml" data-lang="yml"># Custom analyzer
index.analysis:
  analyzer.custom-analyzer:
    type: custom
    tokenizer: standard
    filter: [custom-filter, lowercase]
  filter.custom-filter:
    type : stop
    stopwords : [test1, close]</code></pre>
</div>
</div>
<div class="paragraph">
<p>从那里，您可以在实体映射中按名称使用自定义分析器。</p>
</div>
<div class="listingblock">
<div class="title">引用Elasticsearch上的自定义和内置分析器的映射示例</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "english") // Elasticsearch built-in analyzer
    private String englishTweet;

    @Field
    @Analyzer(definition = "whitespace") // Elasticsearch built-in analyzer
    private String whitespaceTweet;

    @Field(name = "tweetNotAnalyzed", analyzer = Analyze.NO, store = Store.YES)
    // Custom analyzer:
    @Field(
        name = "tweetWithCustom",
        analyzer = @Analyzer(definition = "custom-analyzer")
    )
    private String multipleTweets;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用以下命令引用内置的Lucene分析器实现<code>@Analyzer.impl</code>属性：如果可能，Hibernate Search会将实现转换为等效的Elasticsearch内置类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用<code>@Analyzer.impl</code>不建议在Elasticsearch中使用attribute属性，因为它永远不会让您充分利用Elasticsearch分析功能。例如，您不能使用自定义分析器实现：仅支持内置的Lucene实现。</p>
</div>
<div class="paragraph">
<p>此功能旨在帮助将已使用Hibernate Search的应用程序从嵌入式Lucene实例迁移到Elasticsearch集群。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">使用Lucene实现类引用Elasticsearch上的内置分析器的映射示例</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(impl = EnglishAnalyzer.class) // Elasticsearch built-in "english" analyzer
    private String englishTweet;

    @Field
    @Analyzer(impl = WhitespaceAnalyzer.class) // Elasticsearch built-in "whitespace" analyzer
    private String whitespaceTweet;

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_analyzers_using_the_code_analyzerdef_code_annotation"><a class="anchor" href="#_custom_analyzers_using_the_code_analyzerdef_code_annotation"></a>定制分析仪使用<code>@AnalyzerDef</code>注解</h5>
<div class="paragraph">
<p>您也可以在Hibernate Search映射中使用<code>@AnalyzerDef</code>注释，就像<a href="#section-named-analyzers">对嵌入式Lucene实例所做的那样</a> 。当Hibernate Search创建Elasticsearch索引时，相关定义将被自动添加为索引设置中的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html">自定义分析器</a> 。</p>
</div>
<div class="paragraph">
<p>两种不同的方法可让您使用Elasticsearch定义分析器。</p>
</div>
<div class="paragraph">
<p>第一种推荐的方法是使用由<code>hibernate-search-elasticsearch</code>模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchCharFilterFactory</code></p>
</li>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenFilterFactory</code></p>
</li>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenizerFactory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些类可以传递给<code>factory</code>的属性<code>@CharFilterDef</code> ， <code>@TokenFilterDef</code>和<code>@TokenizerDef</code>注释。</p>
</div>
<div class="paragraph">
<p>的<code>params</code>属性可用于定义<code>type</code>参数以及Elasticsearch对此类型接受的任何其他参数。</p>
</div>
<div class="paragraph">
<p>参数值将解释为JSON。解析器并不严格，但是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在某些情况下，例如当字符串仅包含字母时，可能会忽略字符串周围的引号。</p>
</li>
<li>
<p>当需要引号时（例如，您的字符串可能被解释为数字，而您不希望这样），则可以使用单引号而不是双引号（用Java编写很麻烦）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用<code>name</code>的属性<code>@CharFilterDef</code> ， <code>@TokenFilterDef</code>和<code>@TokenizerDef</code>注释，以定义要在Elasticsearch设置中赋予该定义的确切名称。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">使用以下命令在Elasticsearch上定义分析器的映射示例<code>Elasticsearch*Factory</code>类型</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
@AnalyzerDef(
    name = "tweet_analyzer",
    charFilters = {
        @CharFilterDef(
            name = "custom_html_strip",
            factory = ElasticsearchCharFilterFactory.class,
            params = {
                @Parameter(name = "type", value = "'html_strip'"),
                // One can use Json arrays
                @Parameter(name = "escaped_tags", value = "['br', 'p']")
            }
        ),
        @CharFilterDef(
            name = "p_br_as_space",
            factory = ElasticsearchCharFilterFactory.class,
            params = {
                @Parameter(name = "type", value = "'pattern_replace'"),
                @Parameter(name = "pattern", value = "'&lt;p/?&gt;|&lt;br/?&gt;'"),
                @Parameter(name = "replacement", value = "' '"),
                @Parameter(name = "tags", value = "'CASE_INSENSITIVE'")
            }
        )
    },
    tokenizer = @TokenizerDef(
        factory = ElasticsearchTokenizerFactory.class,
        params = {
            @Parameter(name = "type", value = "'whitespace'"),
        }
    )
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二种方法是像使用Lucene一样配置所有内容：使用Lucene工厂及其参数名称，并根据Lucene的要求设置参数值的格式。Hibernate Search会自动将这些定义转换为等效的Elasticsearch。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不建议在Elasticsearch中引用Lucene工厂，因为它永远不允许您充分利用Elasticsearch分析功能。</p>
</div>
<div class="paragraph">
<p>这是自动翻译的已知限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一些工厂具有不受支持的参数，因为这些参数在Elasticsearch中没有等效项。如果不支持参数，则会在启动时引发异常。</p>
</li>
<li>
<p>的<code>hyphenator</code>的参数<code>HyphenatedWordsFilterFactory</code>必须引用Elasticsearch服务器上的文件，这与其他工厂直接通过Hibernate Search访问文件相反。这是由于Elasticsearch的限制（无法转发本地断字模式文件的内容）。</p>
</li>
<li>
<p>由于Lucene工厂与Elasticsearch等效项之间的参数不兼容，因此某些内置Lucene工厂无法（也无法）被翻译。对于以下情况尤其如此<code>HunspellStemFilterFactory</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，仅当在将已使用Hibernate Search的应用程序从嵌入式Lucene实例迁移到Elasticsearch集群时，才应在分析器定义中引用Lucene工厂。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">使用Lucene工厂在Elasticsearch上定义分析器的映射示例</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
@AnalyzerDef(
    name = "tweet_analyzer",
    charFilters = {
        @CharFilterDef(
            name = "custom_html_strip",
            factory = HTMLStripCharFilterFactory.class,
            params = {
                @Parameter(name = "escapedTags", value = "br,p")
            }
        ),
        @CharFilterDef(
            name = "p_br_as_space",
            factory = PatternReplaceCharFilterFactory.class,
            params = {
                @Parameter(name = "pattern", value = "&lt;p/?&gt;|&lt;br/?&gt;"),
                @Parameter(name = "replacement", value = " ")
            }
        )
    },
    tokenizer = @TokenizerDef(
        factory = WhitespaceTokenizerFactory.class
    )
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_analyzers_using_a_definition_provider"><a class="anchor" href="#_custom_analyzers_using_a_definition_provider"></a>使用定义提供程序的自定义分析器</h5>
<div class="paragraph">
<p><a href="#section-programmatic-analyzer-definition">与Lucene一样</a> ，您可以以编程方式定义分析器。</p>
</div>
<div class="paragraph">
<p>对于Elasticsearch，这需要设置<code>hibernate.search.elasticsearch.analysis_definition_provider</code>配置属性。</p>
</div>
<div class="paragraph">
<p>可以将属性设置为应用程序中带有公共，无参数构造函数的类的完全限定名称。此类必须实现<code>org.hibernate.search.elasticsearch.analyzer.definition.ElasticsearchAnalysisDefinitionProvider</code>直接或暴露<code>@Factory</code> -带注释的方法，返回该实现。</p>
</div>
<div class="listingblock">
<div class="title">使用以下命令在Elasticsearch上定义分析器的映射示例<code>Elasticsearch*Factory</code>类型</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static class CustomAnalyzerProvider implements ElasticsearchAnalysisDefinitionProvider {
    @Override
    public void register(ElasticsearchAnalysisDefinitionRegistryBuilder builder) {
        builder.analyzer( "tweet_analyzer" )
                .withTokenizer( "whitespace" )
                .withCharFilters( "custom_html_strip" )
                .withCharFilters( "p_br_as_space" );

        builder.charFilter( "custom_html_strip" )
                .type( "html_strip" )
                .param( "escaped_tags", "br", "p" );

        builder.charFilter( "p_br_as_space" )
                .type( "pattern_replace" )
                .param( "pattern", "&lt;p/?&gt;|&lt;br/?&gt;" )
                .param( "replacement", " " )
                .param( "tags", "CASE_INSENSITIVE" );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_normalizers"><a class="anchor" href="#_normalizers"></a>规范化器</h5>
<div class="paragraph">
<p>根据您使用的Elasticsearch版本， <a href="#section-normalizers">规范化器的</a>处理方式将有所不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在5.2及更高版本上，Elasticsearch本地支持规范化器，因此Hibernate Search规范化器将直接转换为Elasticsearch规范化器。</p>
</li>
<li>
<p>在5.1版及更低版本上，Elasticsearch本机不支持规范化器，因此Hibernate Search规范化器将使用关键字标记器转换为Elasticsearch分析器。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在Elasticsearch 5.1及更低版本上，将规范化器转换为Elasticsearch分析器的事实尤其意味着，没有规范化器定义应与分析器定义具有相同的名称。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用归一化器时，上述分析仪的所有功能也都可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以使用Lucene工厂定义它们， <code>@NormalizerDef</code> ，它将转换为Elasticsearch中的等效类型。</p>
</li>
<li>
<p>可以使用特殊工厂定义它们<code>ElasticsearchCharFilterFactory</code>和<code>ElasticsearchTokenFilterFactory</code>与<code>@NormalizerDef</code> 。</p>
</li>
<li>
<p>可以使用<code>ElasticsearchAnalysisDefinitionProvider</code> （使用<code>builder.normalizer(name)</code> ）。</p>
</li>
<li>
<p>可以使用以下方式引用定义：<code>@Field(normalizer = @Normalizer(definition = "myDefinition"))</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_field_bridges"><a class="anchor" href="#_field_bridges"></a> 11.4.3。场桥</h4>
<div class="sect4">
<h5 id="_built_in_field_bridges"><a class="anchor" href="#_built_in_field_bridges"></a>内置场桥</h5>
<div class="paragraph">
<p>默认字段桥接与<a href="#section-built-in-bridges">主要文档中</a>提到的字段桥接相同，但以下情况除外。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以参考Elasticsearch文档中有关<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html">日期格式</a>的描述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>boolean</code> ，<code>Boolean</code></dt>
<dd>
<p>转换为本地JSON布尔值。</p>
</dd>
<dt class="hdlist1"><code>Date</code> ，<code>Calendar</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入默认格式（ <code>strict_date_optional_time||epoch_millis</code> ）。</p>
</dd>
<dt class="hdlist1"><code>Instant</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入默认格式（ <code>strict_date_optional_time||epoch_millis</code> ）。</p>
</dd>
<dt class="hdlist1"><code>LocalDate</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_date||yyyyyyyyy-MM-dd</code> 。</p>
</dd>
<dt class="hdlist1"><code>LocalDateTime</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_date_hour_minute_second_fraction||yyyyyyyyy-MM-dd’T’HH:mm:ss.SSSSSSSSS</code> 。</p>
</dd>
<dt class="hdlist1"><code>LocalTime</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_hour_minute_second_fraction</code> 。</p>
</dd>
<dt class="hdlist1"><code>OffsetDateTime</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_date_time||yyyyyyyyy-MM-dd’T’HH:mm:ss.SSSSSSSSSZ</code> 。</p>
</dd>
<dt class="hdlist1"><code>OffsetTime</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_time</code> 。</p>
</dd>
<dt class="hdlist1"><code>ZonedDateTime</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>yyyy-MM-dd’T’HH:mm:ss.SSSZZ'['ZZZ']'||yyyyyyyyy-MM-dd’T’HH:mm:ss.SSSSSSSSSZZ'['ZZZ']'</code> 。</p>
</dd>
<dt class="hdlist1"><code>Year</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_year||yyyyyyyyy</code> 。</p>
</dd>
<dt class="hdlist1"><code>YearMonth</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>strict_year_month||yyyyyyyyy-MM</code> 。</p>
</dd>
<dt class="hdlist1"><code>MonthDay</code></dt>
<dd>
<p>转换为Elasticsearch <code>date</code>输入格式<code>--MM-dd</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_custom_field_bridges"><a class="anchor" href="#_custom_field_bridges"></a>定制场桥</h5>
<div class="paragraph">
<p>您可以编写自定义字段桥和类桥。对于创建多个字段的类桥和字段桥，请确保使桥实现也实现<code>MetadataProvidingFieldBridge</code>合同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static class FirstAndMiddleNamesFieldBridge implements MetadataProvidingFieldBridge {

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        Explorer explorer = (Explorer) value;

        String firstName = explorer.getFirstName();
        luceneOptions.addFieldToDocument( name + "_firstName", firstName, document );
        document.add( new SortedDocValuesField( name + "_firstName", new BytesRef( firstName ) ) );

        String middleName = explorer.getMiddleName();
        luceneOptions.addFieldToDocument( name + "_middleName", middleName, document );
        document.add( new SortedDocValuesField( name + "_middleName", new BytesRef( middleName ) ) );
    }

    @Override
    public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
        builder
            .field( name + "_firstName", FieldType.STRING )
                .sortable( true )
            .field( name + "_middleName", FieldType.STRING )
                .sortable( true );
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该接口和<code>FieldBridge</code>通常，在Hibernate Search的下一个主要版本中可能会发展，以取消对Lucene特定类（如<code>Document</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_sub_fields"><a class="anchor" href="#_sub_fields"></a>子领域</h6>
<div class="paragraph">
<p>当你的<code>MetadataProvidingFieldBridge</code>注册一个名称为现有字段名称的字段，并附加一个点和另一个字符串，例如<code>name + ".mySubField"</code> ，Hibernate Search会将其转换为具有属性的对象<code>mySubField</code>发送到Elasticsearch的JSON文档中。</p>
</div>
<div class="paragraph">
<p>结果，子字段只能有一个父字段，并且<code>OBJECT</code>类型：显然，Elasticsearch会拒绝使用以下字符串或整数<code>mySubField</code>属性。因此，每当一个名为<code>foo.bar</code>已注册，其父字段<code>foo</code>必须在<code>OBJECT</code>类型，如以下示例所示。如果不这样做，则会在Hibernate Search生成Elasticsearch模式时导致错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
    builder
        .field( name, FieldType.OBJECT )
        .field( name + ".firstName", FieldType.STRING )
            .sortable( true )
        .field( name + ".middleName", FieldType.STRING )
            .sortable( true );
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="elasticsearch-custom-field-bridge-dynamic-mapping"><a class="anchor" href="#elasticsearch-custom-field-bridge-dynamic-mapping"></a>动态映射</h6>
<div class="paragraph">
<p>默认情况下，Hibernate Search（或更准确地说，由Hibernate Search生成的Elasticsearch模式）将不允许自定义网桥创建以前未通过<code>configureFieldMetadata</code>方法。</p>
</div>
<div class="paragraph">
<p>如果您事先不知道自定义网桥创建的字段的名称，则可以全局或通过<a href="#elasticsearch-integration-configuration">配置选项</a>启用每个索引的“动态映射”，也可以使用<code>FieldMetadataCreationContext.mappedOn</code>方法和<code>org.hibernate.search.elasticsearch.bridge.spi.Elasticsearch</code>延期：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
    builder
        .field( name, FieldType.OBJECT )
            .mappedOn( Elasticsearch.class )
                .dynamic( DynamicType.TRUE ); // Will allow to index fields named &lt;name&gt;.foo, &lt;name&gt;.bar, etc.
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>动态映射涉及Elasticsearch自动猜测字段的类型和属性，并且有其自身的局限性。有关更多信息，请参见<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-mapping.html">Elasticsearch文档</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tika_bridges"><a class="anchor" href="#_tika_bridges"></a> 11.4.4。蒂卡桥</h4>
<div class="paragraph">
<p>如果您的元数据处理器创建的字段名称与作为参数传递的字段名称不同，请确保使处理器也实现<code>MetadataProvidingTikaMetadataProcessor</code>合同。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_queries"><a class="anchor" href="#_queries"></a> 11.5。查询</h3>
<div class="paragraph">
<p>您可以像在Hibernate Search中一样编写查询：本地Lucene查询和DSL查询（请参阅<a href="#search-query">查询</a> ）。我们会自动翻译最常见的Apache Lucene查询类型以及Hibernate Search DSL生成的所有查询，除了类似的更多内容（见下文）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">不支持的查询DSL功能</div>
<div class="paragraph">
<p>通过DSL编写的查询工作。否则，请打开JIRA。</p>
</div>
<div class="paragraph">
<p>值得注意的例外更像是这种查询。Hibernate Search具有比Lucene（或Elasticsearch / Solr）更高级的算法，该算法不易随Elasticsearch公开的内容移植。</p>
</div>
<div class="paragraph">
<p>如果您需要此功能，请与我们联系。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了翻译Lucene查询之外，您还可以使用其String格式或JSON格式直接创建Elasticsearch查询：</p>
</div>
<div class="exampleblock">
<div class="title">示例165从字符串创建Elasticsearch本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);
QueryDescriptor query = ElasticsearchQueries.fromQueryString("title:tales");
List&lt;?&gt; result = fullTextEm.createFullTextQuery(query, ComicBook.class).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例子166。从JSON创建Elasticsearch本机查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);
QueryDescriptor query = ElasticsearchQueries.fromJson(
      "{ 'query': { 'match' : { 'lastName' : 'Brand' } } }");
List&lt;?&gt; result = fullTextEm.createFullTextQuery(query, GolfPlayer.class).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">本机Elasticsearch查询中的日期/时间</div>
<div class="paragraph">
<p>默认情况下，Elasticsearch将缺少时区的日期/时间字符串解释为使用UTC时区表示的日期/时间字符串。如果被忽略，这可能会导致您的本机Elasticsearch查询完全关闭。</p>
</div>
<div class="paragraph">
<p>避免问题的最简单方法是在构建本地Elasticsearch查询时始终显式提供时区ID或偏移量。这可以通过直接添加时区ID或日期字符串中的偏移量来实现，也可以使用<code>time_zone</code>参数（仅限范围查询）。有关更多信息，请参见Elasticsearch文档。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">简单的查询字符串查询和分析器</div>
<div class="paragraph">
<p>Elasticsearch集成支持简单查询字符串DSL。</p>
</div>
<div class="paragraph">
<p>在一般情况下，您的查询将自动使用架构中定义的分析器，但是请注意，在高级情况下，当您想覆盖使用的分析器时，Elasticsearch仅支持全局覆盖分析器。</p>
</div>
<div class="paragraph">
<p>因此，在覆盖分析器时，它在所有查询字段中必须保持一致。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="elasticsearch-query-spatial"><a class="anchor" href="#elasticsearch-query-spatial"></a> 11.5.1。空间查询</h4>
<div class="paragraph">
<p>Elasticsearch集成通过使用DSL或本机Elasticsearch查询来支持空间查询。</p>
</div>
<div class="paragraph">
<p>对于常规使用，对空间支持没有特殊要求。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅在Elasticsearch 2.x上（5.x上不需要），如果要计算从实体到某个点的距离<strong>而不按</strong>到该点的距离进行<strong>排序</strong> ，则需要通过将以下代码段添加到其中来启用Groovy插件您的Elasticsearch配置：</p>
</div>
<div class="listingblock">
<div class="title">在elasticsearch.yml中启用Groovy支持</div>
<div class="content">
<pre>script.engine.groovy.inline.search: true</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-scrolling"><a class="anchor" href="#elasticsearch-scrolling"></a> 11.5.2。分页和滚动</h4>
<div class="paragraph">
<p>您可以用两种不同的方式处理大型结果集，但有不同的限制。</p>
</div>
<div class="paragraph">
<p>对于（相对）较小的结果集，您可以使用由<code>FullTextQuery</code>接口： <code>setFirstResult(int)</code>和<code>setMaxResults(int)</code> 。局限性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>这只会使您到达第一个10000个文档，即，当请求包含第10000个结果以外的文档的窗口时，Elasticsearch将返回错误。如果您想提高此限制，请参阅<code>index.max_result_window</code> <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#dynamic-index-settings">Elasticsearch的settings</a>中<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#dynamic-index-settings">的属性</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果结果集较大，则可以使用<code>scroll</code>方法开启<code>org.hibernate.search.FullTextQuery</code> 。局限性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>此方法不适用于<code>org.hibernate.search.jpa.FullTextQuery</code> 。</p>
</li>
<li>
<p>定义偏移量后，Elasticsearch实现的性能较差（即<code>setFirstResult(int)</code>在调用之前已在查询中被调用<code>scroll()</code> ）。这是因为Elasticsearch不提供此类功能，因此Hibernate Search必须滚动浏览所有以前的结果。</p>
</li>
<li>
<p>Elasticsearch实现仅允许有限的回溯。呼唤<code>scrollableResults.setRowNumber(4)</code>当前位于索引处时<code>1006</code> ，例如，可能会导致<code>SearchException</code>被抛出，因为只有1000个先前的元素被保留在内存中。您可以通过调整属性来解决此问题： <code>hibernate.search.elasticsearch.scroll_backtracking_window_size</code> （请参阅<a href="#elasticsearch-integration-configuration">Elasticsearch集成配置</a> ）。</p>
</li>
<li>
<p>的<code>ScrollableResults</code>在没有从Elasticsearch获取结果的情况下，经过一定时间后，它将变得过时且无法使用。您可以通过调整两个属性来解决此问题： <code>hibernate.search.elasticsearch.scroll_timeout</code>和<code>hibernate.search.elasticsearch.scroll_fetch_size</code> （请参阅<a href="#elasticsearch-integration-configuration">Elasticsearch集成配置</a> ）。通常，您可以通过减少访存大小和/或增加超时限制来解决超时问题，但这也会增加Elasticsearch的性能。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-query-sorting"><a class="anchor" href="#elasticsearch-query-sorting"></a> 11.5.3。排序</h4>
<div class="paragraph">
<p>排序<a href="#query-sorting">与Lucene后端相同</a> 。</p>
</div>
<div class="paragraph">
<p>如果您碰巧需要高级的Elasticsearch排序功能，而该功能本机不支持<code>SortField</code>或在Hibernate Search排序DSL中，您仍然可以根据JSON创建排序，甚至将其与DSL定义的排序混合使用：</p>
</div>
<div class="exampleblock">
<div class="title">例子167。将DSL定义的排序与本机Elasticsearch JSON排序混合</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextEntityManager fullTextEm = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);
org.hibernate.search.query.dsl.QueryBuilder queryBuilder =
        fullTextEm.getSearchFactory()
        .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... use the query builder as explained in the Querying section ... */;
FullTextQuery query = fullTextEm.createFullTextQuery( luceneQuery, Book.class );
Sort sort = queryBuilder.sort()
        .byNative("authors.name", "{'order':'asc', 'mode': 'min'}")
        .andByField("title")
        .createSort();
query.setSort(sort);
List results = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_projections"><a class="anchor" href="#_projections"></a> 11.5.4。投影</h4>
<div class="paragraph">
<p>所有字段都由Elasticsearch存储在它索引的JSON文档中，当您要投影它们时，没有特别需要将字段标记为已存储。缺点是要投射一个字段，Elasticsearch需要读取整个JSON文档。如果要避免这种情况，请使用<code>Store.YES</code>标记。</p>
</div>
<div class="paragraph">
<p>您还可以通过使用检索完整的JSON文档<code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.SOURCE</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);
FullTextQuery query = fullTextEm.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection( ElasticsearchProjectionConstants.SCORE, ElasticsearchProjectionConstants.SOURCE );

Object[] projection = (Object[]) query.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您要查找有关执行时间的信息，则也可以使用<code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TOOK</code>和<code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TIMED_OUT</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = org.hibernate.search.jpa.Search.getFullTextEntityManager(entityManager);
FullTextQuery query = fullTextEm.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection(
                    ElasticsearchProjectionConstants.SOURCE,
                    ElasticsearchProjectionConstants.TOOK,
                    ElasticsearchProjectionConstants.TIMED_OUT
            );

Object[] projection = (Object[]) query.getSingleResult();
Integer took = (Integer) projection[1]; // Execution time (milliseconds)
Boolean timedOut = (Boolean) projection[2]; // Whether the query timed out</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filters"><a class="anchor" href="#_filters"></a> 11.5.5。筛选器</h4>
<div class="paragraph">
<p>Elasticsearch集成支持全文过滤器的定义。</p>
</div>
<div class="paragraph">
<p>您的过滤器需要实施<code>ElasticsearchFilter</code>接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class DriversMatchingNameElasticsearchFilter implements ElasticsearchFilter {

    private String name;

    public DriversMatchingNameElasticsearchFilter() {
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getJsonFilter() {
        return "{ 'term': { 'name': '" + name + "' } }";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在实体中声明过滤器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed
@FullTextFilterDef(name = "namedDriver",
  impl = DriversMatchingNameElasticsearchFilter.class)
public class Driver {
    @Id
    @DocumentId
    private int id;

    @Field(analyze = Analyze.YES)
    private String name;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从那时起，您可以照常使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextQuery ftQuery = /* ... */;
ftQuery.enableFullTextFilter( "namedDriver" ).setParameter( "name", "liz" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于静态过滤器，您可以简单地扩展<code>SimpleElasticsearchFilter</code>并以JSON形式提供Elasticsearch过滤器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_index_optimization"><a class="anchor" href="#_index_optimization"></a> 11.6。索引优化</h3>
<div class="paragraph">
<p><a href="#search-optimize">索引优化</a>中记录的优化功能仅部分实现。最近的Lucene版本（Elasticsearch所基于的版本）很少需要这种优化，但是仍针对特定情况下的索引提供了一些优化，这些情况旨在长时间保持只读状态：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动优化未实现，很可能永远不会实现。</p>
</li>
<li>
<p>手动优化（ <code>searchFactory.optimize()</code> ）的实施。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch-client-access"><a class="anchor" href="#elasticsearch-client-access"></a> 11.7。直接访问Elasticsearch客户端</h3>
<div class="paragraph">
<p>在编写具有高级要求的复杂应用程序时，可能有必要不时直接将请求发送到Elasticsearch集群，特别是如果Hibernate Search不支持这种开箱即用的情况。</p>
</div>
<div class="paragraph">
<p>为此，您可以使用以下代码段在内部访问Hibernate Search所使用的Elasticsearch客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">SearchFactory searchFactory = fullTextSession.getSearchFactory();
IndexFamily indexFamily = searchFactory.getIndexFamily( ElasticsearchIndexFamilyType.get() );
ElasticsearchIndexFamily elasticsearchIndexFamily = indexFamily.unwrap( ElasticsearchIndexFamily.class );
RestClient restClient = elasticsearchIndexFamily.getClient( RestClient.class );</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>客户端本身不是Hibernate Search API的一部分，而是官方Elasticsearch REST客户端API的一部分。</p>
</div>
<div class="paragraph">
<p>如果我们必须将内部实现切换到具有不同Java类型的另一个客户端（我们可能会在没有事先通知的情况下这样做），则上面的代码片段将引发异常。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="elasticsearch-logging"><a class="anchor" href="#elasticsearch-logging"></a> 11.7.1。记录执行的请求</h4>
<div class="paragraph">
<p>搜索查询将记录到<code>org.hibernate.search.fulltext_query</code>类别<code>DEBUG</code>级别，例如使用嵌入式Lucene实例时（查询格式为Elasticsearch的实例）。</p>
</div>
<div class="paragraph">
<p>此外，您可以通过以下方式启用对发送到Elasticsearch集群的每个单个请求的日志记录： <code>DEBUG</code>记录日志类别<code>org.hibernate.search.elasticsearch.request</code> 。日志将特别包括HTTP方法，路径，查询参数，执行时间和响应状态。在<code>DEBUG</code>级别，请求主体和响应主体将被省略；使用<code>TRACE</code>级别还可以打印出请求正文和响应正文。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，日志中的JSON将以内联方式打印，不缩进。如果您希望JSON打印精美，请使用<a href="#elasticsearch-log-json-pretty-printing"><code>hibernate.search.elasticsearch.log.json_pretty_printing</code>配置属性</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch-limitations"><a class="anchor" href="#elasticsearch-limitations"></a> 11.8。局限性</h3>
<div class="paragraph">
<p>尚未实现所有功能。</p>
</div>
<div class="paragraph">
<p>在撰写本文时，已知以下功能尚无法使用；随时检查JIRA链接以获取更新：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>查询超时： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2399">HSEARCH-2399</a></p>
</li>
<li>
<p>像这样的查询： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2395">HSEARCH-2395</a></p>
</li>
<li>
<p><code>@IndexedEmbedded.indexNullAs</code> ： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2389">HSEARCH-2389</a></p>
</li>
<li>
<p><a href="#search-monitoring">统计信息</a> ： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2421">HSEARCH-2421</a></p>
</li>
<li>
<p><code>@AnalyzerDiscriminator</code> ： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2428">HSEARCH-2428</a></p>
</li>
<li>
<p>动态分片： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2725">HSEARCH-2725</a></p>
</li>
<li>
<p>混合基于Lucene的索引和基于Elasticsearch的索引（尽管实现了部分支持）</p>
</li>
<li>
<p>Hibernate Search不使用嵌套对象，也不使用父子关系映射<a href="https://hibernate.atlassian.net/browse/HSEARCH-2263">HSEARCH-2263</a> 。当嵌套对象更新时，Hibernate Search会自行进行反规范化并保持数据一致性，这在很大程度上缓解了这种情况。</p>
</li>
<li>
<p>MassIndexer实施的性能还有改进的余地</p>
</li>
<li>
<p>我们新的Elasticsearch集成模块在OSGi环境中不起作用。如果您需要此，请投票给： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2524">HSEARCH-2524</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_specific_versions_of_elasticsearch_to_avoid"><a class="anchor" href="#_specific_versions_of_elasticsearch_to_avoid"></a> 11.9。避免使用特定版本的Elasticsearch</h3>
<div class="paragraph">
<p>我们有时可能会在特定版本的Elasticsearch中遇到问题。这不是跟踪Elasticsearch缺陷的正确位置，但我们将尽力跟踪可能影响与Hibernate Search兼容性的特定问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>映射<code>java.time.ZonedDateTime</code>由于<a href="https://github.com/elastic/elasticsearch/issues/20911">JodaTime错误会影响Elasticsearch</a> ： <a href="https://hibernate.atlassian.net/browse/HSEARCH-2414">HSEARCH-2414，</a>因此无法与Elasticsearch 2.4.1一起使用。</p>
<div class="paragraph">
<p><strong>解决方案：</strong>升级到Elasticsearch 2.4.2或更高版本。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgment"><a class="anchor" href="#_acknowledgment"></a> 11.10。致谢</h3>
<div class="paragraph">
<p>可以在<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch网站</a>及其<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">参考文档中</a>找到有关Elasticsearch的更多信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_reading"><a class="anchor" href="#_further_reading"></a> 12进一步阅读</h2>
<div class="sectionbody">
<div class="paragraph">
<p>最后但并非最不重要的一点是一些指向进一步信息的指针。我们强烈建议您获取<a href="http://www.manning.com/bernard/">Hibernate Search in Action</a>的副本。这本出色的书比本在线文档更深入地介绍了Hibernate Search，并提供了大量其他示例。如果您想增加对Lucene的了解，我们建议您使用<a href="http://www.manning.com/hatcher3/">Lucene in Action（第二版）</a> 。</p>
</div>
<div class="paragraph">
<p>由于Hibernate Search的功能与Hibernate ORM紧密相连，因此了解Hibernate是一个好主意。从<a href="http://hibernate.org/orm/documentation/">在线文档</a>开始，或获取<a href="http://www.manning.com/bauer3/">Hibernate Second Edition</a>的<a href="http://www.manning.com/bauer3/">Java Persistence</a>的副本。</p>
</div>
<div class="paragraph">
<p>如果您对Hibernate Search还有其他疑问，或者想分享一些用例，请查看<a href="https://community.jboss.org/en/hibernate/search">Hibernate Search Wiki</a>和<a href="https://discourse.hibernate.org/c/hibernate-search">Hibernate Search论坛</a> 。我们期待着您的回音。</p>
</div>
<div class="paragraph">
<p>如果您想报告错误，请使用<a href="https://hibernate.atlassian.net/browse/HSEARCH">Hibernate Search JIRA</a>实例。随时欢迎反馈！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="credits"><a class="anchor" href="#credits"></a> 13学分</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有关Hibernate Search贡献者的完整列表，请参见<code>copyright.txt</code> Hibernate Search源文件，尤其是在我们的<a href="https://github.com/hibernate/hibernate-search/blob/master/copyright.txt">git存储库中</a> 。</p>
</div>
<div class="paragraph">
<p>以下贡献者参与了本文档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>伊曼纽尔·伯纳德（Emmanuel Bernard）</p>
</li>
<li>
<p>哈迪·费伦奇克</p>
</li>
<li>
<p>古斯塔沃·费尔南德斯</p>
</li>
<li>
<p>桑内·格林诺沃（Sanne Grinovero）</p>
</li>
<li>
<p>黄敏聪</p>
</li>
<li>
<p>纳比尔·阿里·梅蒙（Nabeel Ali Memon）</p>
</li>
<li>
<p>贡纳·莫林</p>
</li>
<li>
<p>约恩·罗迪埃（YoannRodière）</p>
</li>
<li>
<p>纪尧姆·斯梅特（Guillaume Smet）</p>
</li>
</ul>
</div>
</div>
</div>
</em></div><em>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-21 14:10:06 UTC</div>
</div>
<!-- Google Analytics -->
<script type="text/javascript">
	dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
		new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
		j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-NJWS5L');
</script>
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none"></iframe></noscript>
<!-- /Google Analytics -->

<!-- HibernateDoc.OutdatedContent -->
<script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script>
<script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script>
<script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install('search'); });</script>
<!-- /HibernateDoc.OutdatedContent -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</em></body></html>