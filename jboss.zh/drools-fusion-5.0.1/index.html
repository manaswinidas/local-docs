<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools Fusion用户指南</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"><meta name="generator" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" content="DocBook XSL-NS Stylesheets V1.74.0"><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e11">1。介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16">1.1。复杂事件处理</a></span></dt><dt><span class="section"><a href="#d0e70">1.2。流口水融合</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e172">2。Drools融合功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e175">2.1。大事记</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e180">2.1.1。事件语义</a></span></dt><dt><span class="section"><a href="#d0e232">2.1.2。活动宣言</a></span></dt><dt><span class="section"><a href="#d0e281">2.1.3。事件元数据</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e443">2.2。会话时钟</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e474">2.2.1。可用时钟实现</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e501">2.3。流支持</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e523">2.3.1。声明和使用入口点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e558">2.4。时间推理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e622">2.4.1。时间运算符</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1048">2.5。事件处理模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1055">2.5.1。云模式</a></span></dt><dt><span class="section"><a href="#d0e1086">2.5.2。流模式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1159">2.6。滑动窗</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1169">2.6.1。滑动时间窗</a></span></dt><dt><span class="section"><a href="#d0e1189">2.6.2。滑动长度窗</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1209">2.7。知识库分区</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1224">2.7.1。分区有用时</a></span></dt><dt><span class="section"><a href="#d0e1244">2.7.2。如何配置分区</a></span></dt><dt><span class="section"><a href="#d0e1260">2.7.3。多线程管理</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1282">2.8。事件的内存管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1300">2.8.1。显式过期偏移</a></span></dt><dt><span class="section"><a href="#d0e1312">2.8.2。推断的过期时间偏移</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1326">3。参考文献</a></span></dt><dt><span class="index"><a href="#d0e1329">指数</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11"></a>第1章。介绍</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16">1.1。复杂事件处理</a></span></dt><dt><span class="section"><a href="#d0e70">1.2。流口水融合</a></span></dt></dl></div><p>在Drools统一行为建模平台的愿景中，Drools Fusion是负责启用事件处理行为的模块。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16"></a> 1.1。复杂事件处理</h2></div></div></div><p>尽管进行了几次尝试，但到目前为止，术语“复杂事件处理”还没有任何被广泛接受的定义。术语事件本身经常被重载，并根据使用的上下文来指代几种不同的事物。定义术语不是本指南的目的，因此，让我们采用一个宽松的定义，尽管它不是正式的，但将使我们能够达成共识。</p><p>因此，在本指南的范围内：</p><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p><a id="d0e25" class="indexterm"></a> <span class="bold"><strong>事件</strong></span> ，是应用程序域中状态发生重大变化的记录。</p></div><p>例如，在Stock Broker应用程序上，当执行销售操作时，它将导致域中的状态更改。可以在域中的多个实体上观察到这种状态变化，例如，已更改为与操作价值匹配的证券价格，从卖方变为买方的单个交易资产的所有者，资产的余额。来自卖方和买方的贷方和借方帐户等。根据域的建模方式，这种状态变化可能由单个事件，多个原子事件或相关事件的层次结构表示。无论如何，在本指南中，事件是域中特定数据的更改记录。</p><p>自事件被发明以来，事件一直由计算机系统处理，并且在整个历史过程中，负责事件的系统被赋予了不同的名称和不同的方法。直到90年代，才开始着重于EDA（事件驱动架构）的工作，并对事件处理的要求和目标进行更正式的定义。为了满足这些要求，旧的消息传递系统开始发生变化，而出于事件处理的单一目的开始开发新的系统。在事件流处理和复杂事件处理的名称下诞生了两种趋势。</p><p>在开始时，事件流处理的重点是实时（近）处理事件流的能力，而复杂事件处理的主要重点是将原子事件与复杂（复合）事件的相关性和组成。一个重要的（也许是最重要的）里程碑是David Luckham博士于2002年出版的《事件的力量》一书。在这本书中，Luckham博士介绍了复杂事件处理的概念以及如何使用它来增强处理事件的系统。多年来，这两种趋势趋于一致，今天，这些系统都被称为CEP系统。</p><p>这是对一个非常复杂和富饶的研究领域的非常简单的解释，但是对本指南将介绍的概念设置了非常高的共识。</p><p>当前对什么是复杂事件处理的理解可以简短地描述为Wikipedia的以下引用：</p><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>” <a id="d0e52" class="indexterm"></a> <span class="bold"><strong>复杂事件处理</strong></span> （CEP）主要是一种事件处理概念，用于处理多个事件，以识别事件云中有意义的事件为目标。CEP采用了诸如检测许多事件的复杂模式，事件相关性和抽象性，事件层次结构以及事件之间的因果关系，成员资格和时间关系以及事件驱动过程之类的技术。”</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">- <span class="attribution"><a class="ulink" href="http://en.wikipedia.org/wiki/Complex_event_processing"><em class="citetitle">维基百科</em></a></span></td></tr></tbody></table></div></div><p>换句话说，CEP就是要从事件云中检测并选择有趣的事件（并且只有它们），找到它们之间的关系，并从它们及其关系中推断出新数据。</p><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>在本指南的其余部分中，我们将使用术语“ <span class="bold"><strong>复杂事件处理”</strong></span>和“ <span class="bold"><strong>CEP”</strong></span>作为任何相关技术的广泛参考，包括但不限于CEP，复杂事件处理，ESP，事件流处理和事件处理一般来说。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e70"></a> 1.2。流口水融合</h2></div></div></div><p>通常，事件处理用例与业务规则用例共享一些需求和目标。这些重叠发生在业务端和技术端。</p><p>在业务方面：</p><div class="itemizedlist"><ul><li><p>经常根据事件触发的场景的发生来定义业务规则。例如：</p><div class="itemizedlist"><ul><li><p>在算法交易应用程序上：如果证券价格与当日开盘价相比上涨X％，则采取措施，其中价格上涨通常由“股票交易”应用程序中的事件表示。</p></li><li><p>在监视应用程序上：如果服务器机房的温度在Y分钟内升高X度，则应采取措施，其中传感器读数通常由事件表示。</p></li></ul></div></li><li><p>业务规则和事件处理查询都经常更改，需要业务部门立即做出响应，以使其适应新的市场条件，新的法规和新的企业策略。</p></li></ul></div><p>从技术角度来看：</p><div class="itemizedlist"><ul><li><p>两者都需要与企业基础架构和应用程序进行无缝集成，特别是在自治治理方面，包括但不限于生命周期管理，审计，安全性等。</p></li><li><p>两者都有功能需求（例如模式匹配）和非功能需求（例如响应时间和查询/规则说明）。</p></li></ul></div><p>即使是共享需求和目标，从历史上看，这两个领域都是与生俱来的。尽管行业不断发展，人们可以在市场上找到好的产品，但它们要么专注于事件处理，要么专注于业务规则管理。这不仅是由于历史原因，而且还因为用例即使部分重叠也确实有一些不同的要求。</p><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p>Drools几年前也诞生于规则引擎，但是随着成为行为建模的单一平台的愿景，它很快意识到，只有将相同的重要性归功于三种互补的业务建模技术，才能实现此目标：</p><div class="itemizedlist"><ul><li><p>业务规则管理</p></li><li><p>业务流程管理</p></li><li><p>复杂事件处理</p></li></ul></div></div><p>在这种情况下，Drools Fusion是负责将事件处理功能添加到平台中的模块。</p><p>但是，支持复杂事件处理不仅仅是简单地了解事件是什么。CEP方案具有几个共同的和令人讨厌的特征：</p><div class="itemizedlist"><ul><li><p>通常需要处理大量事件，但是只有一小部分事件是真正有意义的。</p></li><li><p>事件通常是不可变的，因为它们是状态变化的记录。</p></li><li><p>通常，事件的规则和查询必须以反应性模式运行，即对事件模式的检测做出反应。</p></li><li><p>通常，相关事件之间存在很强的时间关系。</p></li><li><p>个别事件通常并不重要。系统关注相关事件的模式及其关系。</p></li><li><p>通常，系统需要执行事件的组合和聚集。</p></li></ul></div><p>基于这种普遍的共同特征，Drools Fusion定义了要适当支持复杂事件处理的一组目标：</p><div class="itemizedlist"><ul><li><p>以一流的公民身份支持活动，具有一流的公民身份。</p></li><li><p>允许检测，关联，聚合和组合事件。</p></li><li><p>支持事件流的处理。</p></li><li><p>支持时间约束以便对事件之间的时间关系建模。</p></li><li><p>支持有趣事件的滑动窗口。</p></li><li><p>支持会话范围的统一时钟。</p></li><li><p>支持CEP用例所需的事件量。</p></li><li><p>支持（重新）活动规则。</p></li><li><p>支持将事件输入引擎（管道）的适配器。</p></li></ul></div><p>上面的目标列表基于Drools Expert本身未涵盖的要求，因为在统一平台中，一个模块的所有功能均被其他模块利用。这样，Drools Fusion诞生了企业级功能，例如模式匹配，这对CEP产品至关重要，但是Drools Expert已经提供了该功能。以相同的方式，Drools Flow利用了Drools Fusion提供的所有功能（反之亦然），使流程管理意识到事件处理，反之亦然。</p><p>在本指南的其余部分，我们将介绍Drools Fusion添加到平台的每个功能。所有这些功能都可用于支持CEP世界中的不同用例，并且用户可以自由选择和使用将帮助他为业务用例建模的功能。</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e172"></a>第2章。Drools融合功能</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e175">2.1。大事记</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e180">2.1.1。事件语义</a></span></dt><dt><span class="section"><a href="#d0e232">2.1.2。活动宣言</a></span></dt><dt><span class="section"><a href="#d0e281">2.1.3。事件元数据</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e443">2.2。会话时钟</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e474">2.2.1。可用时钟实现</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e501">2.3。流支持</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e523">2.3.1。声明和使用入口点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e558">2.4。时间推理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e622">2.4.1。时间运算符</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1048">2.5。事件处理模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1055">2.5.1。云模式</a></span></dt><dt><span class="section"><a href="#d0e1086">2.5.2。流模式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1159">2.6。滑动窗</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1169">2.6.1。滑动时间窗</a></span></dt><dt><span class="section"><a href="#d0e1189">2.6.2。滑动长度窗</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1209">2.7。知识库分区</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1224">2.7.1。分区有用时</a></span></dt><dt><span class="section"><a href="#d0e1244">2.7.2。如何配置分区</a></span></dt><dt><span class="section"><a href="#d0e1260">2.7.3。多线程管理</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1282">2.8。事件的内存管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1300">2.8.1。显式过期偏移</a></span></dt><dt><span class="section"><a href="#d0e1312">2.8.2。推断的过期时间偏移</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e175"></a> 2.1。大事记</h2></div></div></div><p>从Drools的角度来看，事件只是一种特殊的事实。这样，我们可以说所有事件都是事实，但并非所有事实都是事件。在接下来的几节中，将介绍表征事件的特定差异。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e180"></a> 2.1.1。事件语义</h3></div></div></div><p><span class="emphasis"><em>事件</em></span>是一个事实，具有一些明显的特征：</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>通常是不可变的：</strong></span>由于按照前面讨论的定义，事件是应用程序域中状态更改的记录，即，已发生的事情的记录，并且过去的事件无法“更改”，因此事件是不可变的。此约束是开发多个优化和事件生命周期的规范的重要要求。这并不意味着代表该对象的java对象必须是不可变的。恰恰相反，引擎不会强制执行对象模型的不变性，因为规则的最常见用例之一是事件数据充实。</p><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>最佳做法是，允许应用程序填充未填充的事件属性（以用推断的数据丰富事件），但决不应更改已填充的属性。</p></div></li><li><p><span class="bold"><strong>强大的时间约束：</strong></span>涉及事件的规则通常需要多个事件的相关性，尤其是时间相关性，在这种情况下，事件被称为相对于其他事件在某个时间点发生。</p></li><li><p><span class="bold"><strong>托管生命周期：</strong></span>由于事件的不变性和时间限制，事件通常只会在有限的时间范围内匹配其他事件和事实，从而使引擎有可能自动管理事件的生命周期。换句话说，一个事件被插入到工作存储器中，引擎有可能找出一个事件何时不再与其他事实匹配，然后自动撤消该事件，从而释放其相关资源。</p></li><li><p><span class="bold"><strong>滑动窗口的使用：</strong></span>由于所有事件都具有与之关联的时间戳，因此可以在其上定义和使用滑动窗口，从而允许在一段时间内创建关于值聚合的规则。示例：60分钟内事件值的平均值。</p></li></ul></div><p>Drools支持两种语义的事件声明和使用： <span class="bold"><strong>时间点</strong></span>事件和<span class="bold"><strong>基于间隔的</strong></span>事件。</p><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>理解语义统一性的一种简单方法是将<span class="emphasis"><em>时间点</em></span>事件视为<span class="emphasis"><em>持续时间为零</em></span> <span class="emphasis"><em>的基于间隔的</em></span>事件。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e232"></a> 2.1.2。活动宣言</h3></div></div></div><p>要将事实类型声明为事件，所需要做的就是将@role元数据标签分配给事实类型。@role元数据标记接受两个可能的值：</p><div class="itemizedlist"><ul><li><p>fact：这是默认值，声明该类型将作为常规事实处理。</p></li><li><p>event：声明将类型作为事件处理。</p></li></ul></div><p>例如，下面的示例声明，股票经纪人应用程序中的事实类型StockTick应该作为事件处理。</p><div class="example"><a id="d0e247"></a><p class="title"><b>示例2.1将事实类型声明为事件</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>import</strong></span> some.package.StockTick

<span class="bold"><strong>declare</strong></span> StockTick
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break"></p><p>内联声明的事实也是如此。因此，如果StockTick是DRL本身声明的事实类型，而不是先前存在的类，则代码将是：</p><div class="example"><a id="d0e266"></a><p class="title"><b>示例2.2声明事实类型并辅助其事件角色</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> StockTick 
    <span class="emphasis"><em>@role</em></span>( event )

    datetime : java.util.Date
    symbol : String
    price : double
<span class="bold"><strong>end</strong></span>
</pre></div></div><p><br class="example-break">有关类型声明的更多信息，请检查Drools Expert文档的Rule Language部分。</p><p></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e281"></a> 2.1.3。事件元数据</h3></div></div></div><p>所有事件都有一组与之关联的元数据。大多数元数据值具有默认值，当将它们插入工作内存时会自动分配给每个事件，但是可以使用下面列出的元数据标签根据事件类型更改默认值。</p><p>对于示例，假设用户在应用程序域模型中具有以下类：</p><div class="example"><a id="d0e288"></a><p class="title"><b>例子2.3。 VoiceCall事实类</b></p><div class="example-contents"><pre class="programlisting"><span class="emphasis"><em>/**
 * A class that represents a voice call in 
 * a Telecom domain model
 */</em></span>
<span class="bold"><strong>public class</strong></span> VoiceCall {
    <span class="bold"><strong>private</strong></span> String  originNumber;
    <span class="bold"><strong>private</strong></span> String  destinationNumber;
    <span class="bold"><strong>private</strong></span> Date    callDateTime;
    <span class="bold"><strong>private</strong></span> long    callDuration;          // in milliseconds

    // constructors, getters and setters
}
</pre></div></div><br class="example-break"><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e310"></a> 2.1.3.1。 @角色</h4></div></div></div><p>@role元数据已经在上一节中讨论过，为了完整起见在此显示：</p><pre class="programlisting"><span class="emphasis"><em>@role</em></span>( &lt;fact|event&gt; )
</pre><p>它将给定的事实类型注释为常规事实或事件。它接受“事实”或“事件”作为参数。默认值为“事实”。</p><div class="example"><a id="d0e321"></a><p class="title"><b>示例2.4将VoiceCall声明为事件类型</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"><p></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e335"></a> 2.1.3.2。 @时间戳</h4></div></div></div><p>每个事件都分配有一个关联的时间戳。默认情况下，给定事件的时间戳是从会话时钟中读取的，并在事件插入到工作存储器中时分配给事件。尽管有时，事件将时间戳记作为其自身的属性之一。在这种情况下，用户可以告诉引擎使用事件属性中的时间戳，而不是从会话时钟中读取时间戳。</p><pre class="programlisting"><span class="emphasis"><em>@timestamp</em></span>( &lt;attributeName&gt; )</pre><p>要告诉引擎将哪个属性用作事件时间戳记的来源，只需将属性名称作为@timestamp标记的参数列出即可。</p><div class="example"><a id="d0e346"></a><p class="title"><b>示例2.5声明VoiceCall时间戳属性</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
<span class="bold"><strong>end</strong></span>
</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e362"></a> 2.1.3.3。 @持续时间</h4></div></div></div><p>Drools支持两种事件语义：时间点事件和基于间隔的事件。时间点事件表示为持续时间为零的基于间隔的事件。默认情况下，所有事件的持续时间为零。用户可以通过声明事件类型中的哪个属性包含事件的持续时间来为事件分配不同的持续时间。</p><pre class="programlisting"><span class="emphasis"><em>@duration</em></span>( &lt;attributeName&gt; )</pre><p>因此，对于我们的VoiceCall事实类型，声明为：</p><div class="example"><a id="d0e373"></a><p class="title"><b>示例2.6声明VoiceCall持续时间属性</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
<span class="bold"><strong>end</strong></span></pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e391"></a> 2.1.3.4。 @expires</h4></div></div></div><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p>仅在以STREAM模式运行引擎时才考虑使用此标签。另外，在“内存管理”部分还对使用此标签的效果进行了其他讨论。为了完整起见，此处将其包括在内。</p></div><p>事件可能会在一段时间后自动过期。通常，基于知识库中的现有规则，事件不再能够匹配和激活任何规则时，就会发生这种情况。虽然，可以显式定义事件应在何时到期。</p><pre class="programlisting"><span class="emphasis"><em>@expires</em></span>( &lt;timeOffset&gt; )</pre><p><span class="emphasis"><em>timeOffset</em></span>的值是以下形式的时间间隔：</p><pre class="programlisting">[#d][#h][#m][#s][#[ms]]</pre><p>其中<span class="emphasis"><em>[]</em></span>表示可选参数，而<span class="emphasis"><em>＃</em></span>表示数值。</p><p>因此，要声明VoiceCall事实在插入工作存储器后1小时35分钟后应该过期，用户可以这样写：</p><div class="example"><a id="d0e421"></a><p class="title"><b>示例2.7声明VoiceCall事件的到期时间偏移</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
    <span class="emphasis"><em>@expires</em></span>( 1h35m )
<span class="bold"><strong>end</strong></span></pre></div></div><p><br class="example-break"></p><p></p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e443"></a> 2.2。会话时钟</h2></div></div></div><p>随着时间的流逝需要一个参考时钟。仅举一个例子，如果规则超过了过去60分钟内给定股票的平均价格，那么引擎如何知道过去60分钟内发生了什么股价变化以计算平均值？明显的响应是：通过将事件的时间戳与“当前时间”进行比较。引擎如何知道<span class="bold"><strong>现在</strong></span>几点？同样，很明显，通过查询会话时钟。</p><p>会话时钟实现了一种策略模式，允许引擎插入和使用不同类型的时钟。这一点非常重要，因为引擎可能在可能需要不同时钟实现的一系列不同情况下运行。仅举几例：</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>规则测试：</strong></span>测试始终需要受控的环境，并且当测试包含具有时间限制的规则时，不仅需要控制输入规则和事实，还需要控制时间流。</p></li><li><p><span class="bold"><strong>定期执行：</strong></span>通常，在生产中运行规则时，应用程序将需要一个实时时钟，该时钟可使规则引擎立即对时间进度做出反应。</p></li><li><p><span class="bold"><strong>特殊环境：</strong></span>特定环境可能对时间控制有特定要求。群集环境可能需要通过心跳进行时钟同步，或者JEE环境可能需要使用AppServer提供的时钟等。</p></li><li><p><span class="bold"><strong>规则重播或模拟：</strong></span>要重播场景或模拟场景，应用程序还必须控制时间流。</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e474"></a> 2.2.1。可用时钟实现</h3></div></div></div><p>Drools 5提供了两种开箱即用的时钟实现。基于系统时钟的默认实时时钟，以及由应用程序控制的可选伪时钟。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e479"></a> 2.2.1.1。实时时钟</h4></div></div></div><p>默认情况下，Drools使用实时时钟实现，该实现在内部使用系统时钟来确定当前时间戳。</p><p>要将引擎显式配置为使用实时时钟，只需将会话配置参数设置为实时：</p><pre class="programlisting">KnowledgeSessionConfiguration config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e488"></a> 2.2.1.2。伪时钟</h4></div></div></div><p>Drools还提供了开箱即用的时钟实现，该时钟由应用程序控制，称为“伪时钟”。该时钟对于单元测试时间规则特别有用，因为它可以由应用程序控制，因此结果变得确定。</p><p>要配置伪会话时钟，请执行以下操作：</p><pre class="programlisting">KnowledgeSessionConfiguration config = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );</pre><p>作为如何控制伪会话时钟的示例：</p><pre class="programlisting">KnowledgeSessionConfiguration conf = KnowledgeBaseFactory.newKnowledgeSessionConfiguration();
conf.setOption( ClockTypeOption.get( "pseudo" ) );
StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession( conf, null );
        
SessionPseudoClock clock = session.getSessionClock();

// then, while inserting facts, advance the clock as necessary:
FactHandle handle1 = session.insert( tick1 );
clock.advanceTime( 10, TimeUnit.SECONDS );
FactHandle handle2 = session.insert( tick2 );
clock.advanceTime( 30, TimeUnit.SECONDS );
FactHandle handle3 = session.insert( tick3 );

</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e501"></a> 2.3。流支持</h2></div></div></div><p>大多数CEP用例必须处理事件流。流可以以各种形式（从JMS队列到纯文本文件，从数据库表到原始套接字，甚至通过Web服务调用）提供给应用程序。在任何情况下，流都具有一组共同的特征：</p><div class="itemizedlist"><ul><li><p>流中的事件按时间戳排序。对于不同的流，时间戳可能具有不同的语义，但始终在内部对其进行排序。</p></li><li><p>事件数量通常很高。</p></li><li><p>原子事件本身很少有用。通常，从流以及其他来源的多个事件之间的相关性中提取含义。</p></li><li><p>流可以是同质的，即包含单一类型的事件，也可以是异质的，即包含多种类型的事件。</p></li></ul></div><p>Drools将流的概念概括为引擎的“入口”。一个入口是流口水事实的大门。事实可以是常规事实，也可以是特殊事实，例如事件。</p><p>在Drools中，来自一个入口点（流）的事实可能与来自任何其他入口点或事件的事实以及来自工作内存的事实结合在一起。尽管它们从不混合，也就是说，它们从不丢失对进入引擎的入口点的引用。这很重要，因为通过多个入口点进入引擎可能具有相同类型的事实，但是通过入口点A插入引擎中的一个事实将永远不会匹配例如来自入口点B的模式。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e523"></a> 2.3.1。声明和使用入口点</h3></div></div></div><p>通过在规则中直接使用入口点在Drools中隐式声明。即，在规则中引用入口点将使引擎在编译时识别并创建适当的内部结构以支持该入口点。</p><p>因此，例如，假设有一个银行应用程序，其中交易是从流中输入到系统中的。流之一包含在ATM机中执行的所有事务。因此，如果其中一条规则说：仅当帐户余额超过所要求的提款金额时，才允许提款，该规则如下所示：</p><div class="example"><a id="d0e531"></a><p class="title"><b>示例2.8流使用示例</b></p><div class="example-contents"><pre class="programlisting">rule "authorize withdraw"
when
    WithdrawRequest( $ai : accountId, $am : amount ) from entry-point "ATM Stream"
    CheckingAccount( accountId == $ai, balance &gt; $am )
then
    // authorize withdraw
end
</pre></div></div><p><br class="example-break">在前面的示例中，引擎编译器将识别出该模式已绑定到入口点“ ATM流”，并且将为规则库创建所有必要的结构以支持“ ATM流”，并且只会匹配来自“ ATM流”。在前面的示例中，规则还将流中的事件与主工作内存中的事实（CheckingAccount）结合在一起。</p><p>现在，让我们想象第二条规则，该规则规定对在银行分行提出提款请求的任何帐户必须收取2美元的费用：</p><div class="example"><a id="d0e540"></a><p class="title"><b>示例2.9使用其他流</b></p><div class="example-contents"><pre class="programlisting">rule "apply fee on withdraws on branches"
when
    WithdrawRequest( $ai : accountId, processed == true ) from entry-point "Branch Stream"
    CheckingAccount( accountId == $ai )
then
    // apply a $2 fee on the account
end
</pre></div></div><p><br class="example-break">先前的规则将匹配与第一条规则（WithdrawRequest）完全相同类型的事件，但是来自两个不同的流，因此插入到“ ATM流”中的事件将永远不会根据第二条规则的模式进行评估它只对“分支流”中的模式感兴趣。</p><p>因此，入口点不仅是对流的适当抽象，而且还是一种在工作内存中确定事实范围的方法，并且是减少跨产品爆炸的有价值的工具。但这是另一个话题。</p><p>将事件插入入口点同样简单。无需将事件直接插入工作存储器中，而是将其插入入口点，如下面的示例所示：</p><div class="example"><a id="d0e551"></a><p class="title"><b>示例2.10将事实插入切入点</b></p><div class="example-contents"><pre class="programlisting">// create your rulebase and your session as usual
StatefulKnowledgeSession session = ...

// get a reference to the entry point
WorkingMemoryEntryPoint atmStream = session.getWorkingMemoryEntryPoint( "ATM Stream" );

// and start inserting your facts into the entry point
atmStream.insert( aWithdrawRequest );
</pre></div></div><p><br class="example-break"></p><p>前面的示例显示了如何将事实手动插入给定的入口点。尽管通常情况下，应用程序将使用许多适配器之一将流端点（如JMS队列）直接插入引擎入口点，而无需手动编码插入。Drools管道API具有多个适配器和帮助程序来做到这一点，以及有关如何执行此操作的示例。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e558"></a> 2.4。时间推理</h2></div></div></div><p>时间推理是任何CEP系统的另一个要求。如前所述，事件的显着特征之一是事件之间的牢固时间关系。</p><p>时间推理是一个广泛的研究领域，从其起源于时间模态逻辑到其在业务系统中的更实际应用。有数百篇论文，论文的写作和方法也针对几种应用进行了描述。Drools再次基于多种来源采取务实而简单的方法，但特别值得注意的是以下论文：</p><div class="bibliolist"><div class="biblioentry"><a id="d0e567"></a><p>[ <abbr class="abbrev">ALLEN81</abbr> ] <span class="author">JF艾伦。</span><span class="title"><i>基于时间间隔的时间知识表示</i> 。</span><span class="pubdate">1981年。</span></p></div><div class="biblioentry"><a id="d0e578"></a><p>[ <abbr class="abbrev">ALLEN83</abbr> ] <span class="author">JF艾伦。</span><span class="title"><i>保持关于时间间隔的知识</i> 。</span><span class="pubdate">1983年。</span></p></div><div class="biblioentry"><a id="d0e589"></a><p>[ <abbr class="abbrev">BENNE00</abbr> ] <span class="authorgroup">。</span><span class="title"><i>时间与事件的统一语义学</i> 。</span><span class="pubdate">2005。</span></p></div><div class="biblioentry"><a id="d0e604"></a><p>[ <abbr class="abbrev">YONEK05</abbr> ] <span class="authorgroup">。</span><span class="title"><i>混合网络环境下时空事件关联的统一语义</i> 。</span><span class="pubdate">2005。</span></p></div></div><div class="blockquote"><blockquote class="blockquote"></blockquote></div><p>Drools实现了Allen描述的基于间隔的时间事件语义，并将时间点事件表示为持续时间为0（零）的基于间隔的偶数。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e622"></a> 2.4.1。时间运算符</h3></div></div></div><p>Drools实现Allen定义的所有13个运算符以及它们的逻辑补码（取反）。本节详细介绍了每个运算符及其参数。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e627"></a> 2.4.1.1。后</h4></div></div></div><p>后评估器关联两个事件，并在从当前事件到关联事件的时间距离属于为操作员声明的距离范围时进行匹配。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this after[ 3m30s, 4m ] $eventB ) </pre><p>当且仅当$ eventB完成的时间与$ eventA开始的时间之间的时间距离在（3分钟至30秒）和（4分钟）之间时，上一个模式才会匹配。换一种说法：</p><pre class="programlisting"> 3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m </pre><p>after运算符的时间距离间隔是可选的：</p><div class="itemizedlist"><ul><li><p>如果定义了两个值（如下面的示例所示），则间隔从第一个值开始，到第二个结束。</p></li><li><p>如果仅定义一个值，则间隔从该值开始并以正无穷大结束。</p></li><li><p>如果未定义任何值，则假定初始值为1ms，最终值为正无穷大。</p></li></ul></div><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>可以为此操作员定义负距离。例：</p><pre class="programlisting">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) </pre></div><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>如果第一值大于第二值，则引擎会自动将其反转，因为没有理由使第一值大于第二值。示例：以下两种模式被认为具有相同的语义：</p><pre class="programlisting">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this after[ -2m, -3m30s ] $eventB ) </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e662"></a> 2.4.1.2。之前</h4></div></div></div><p>事前评估器将两个事件关联起来，并在从事件关联到当前关联的事件的时间距离属于为操作员声明的距离范围时匹配。
    </p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this before[ 3m30s, 4m ] $eventB ) </pre><p>当且仅当$ eventA完成的时间与$ eventB开始的时间之间的时间距离在（3分钟至30秒）和（4分钟）之间时，先前的模式才匹配。换一种说法：</p><pre class="programlisting"> 3m30s &lt;= $eventB.startTimestamp - $eventA.endTimeStamp &lt;= 4m </pre><p>before运算符的时间距离间隔是可选的：</p><div class="itemizedlist"><ul><li><p>如果定义了两个值（如下面的示例所示），则间隔从第一个值开始，到第二个结束。</p></li><li><p>如果仅定义一个值，则间隔从该值开始并在正无穷大处结束。</p></li><li><p>如果未定义任何值，则假定初始值为1ms，最终值为正无穷大。</p></li></ul></div><div class="tip" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>小费</h2><p>可以为此操作员定义负距离。例：</p><pre class="programlisting">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) </pre></div><div class="note" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>注意</h2><p>如果第一值大于第二值，则引擎会自动将其反转，因为没有理由使第一值大于第二值。示例：以下两种模式被认为具有相同的语义：</p><pre class="programlisting">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this before[ -2m, -3m30s ] $eventB ) </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e697"></a> 2.4.1.3。巧合</h4></div></div></div><p>符合评估器将两个事件关联，并且两个事件同时发生时进行匹配。可选地，评估者接受事件开始时间戳和结束时间戳之间的距离阈值。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this coincides $eventB ) </pre><p>当且仅当$ eventA和$ eventB的开始时间戳相同且$ eventA和$ eventB的结束时间戳相同时，上一个模式才会匹配。</p><p>（可选）此运算符接受一个或两个参数。这些参数是匹配时间戳之间的距离的阈值。</p><div class="itemizedlist"><ul><li><p>如果仅给出一个paratemer，则将其用于开始和结束时间戳记。</p></li><li><p>如果给出了两个参数，则第一个用作开始时间戳的阈值，第二个用作结束时间戳的阈值。</p></li></ul></div><p>换一种说法：</p><pre class="programlisting">$eventA : EventA( this coincides[15s, 10s] $eventB ) </pre><p>只有在以下情况下，上述模式才匹配：</p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 15s &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 10s </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发错误。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e728"></a> 2.4.1.4。中</h4></div></div></div><p>期间评估器关联两个事件，并在关联事件发生期间当前事件发生时进行匹配。
    </p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this during $eventB ) </pre><p>当且仅当$ eventA在$ eventB开始之后开始并在$ eventB完成之前结束时，先前的模式才匹配。</p><p>换一种说法：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt;= $eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>期间运算符接受1、2或4个可选参数，如下所示：</p><div class="itemizedlist"><ul><li><p>如果定义了一个值，这将是两个事件的开始时间戳之间的最大距离与两个事件的结束时间戳之间的最大距离，以便与操作员匹配。例：</p><pre class="programlisting">$eventA : EventA( this during[ 5s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">0 &lt; $eventA.startTimestamp - $eventB.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventB.endTimestamp - $eventA.endTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了两个值，则第一个值将是两个事件的时间戳之间的最小距离，而第二个值将是两个事件的时间戳之间的最大距离。例：</p><pre class="programlisting">$eventA : EventA( this during[ 5s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">5s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了四个值，则前两个值将是两个事件的开始时间戳之间的最小和最大距离，而后两个值将是两个事件的结束时间戳之间的最小和最大距离。例：</p><pre class="programlisting">$eventA : EventA( this during[ 2s, 6s, 4s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">2s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e775"></a> 2.4.1.5。饰面</h4></div></div></div><p>Finishes评估程序将两个事件相关联，并在相关事件的开始时间戳记之后发生当前事件的开始时间戳记时进行匹配，但是两个结束时间戳记都同时发生。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this finishes $eventB ) </pre><p>当且仅当$ eventA在$ eventB开始并在$ eventB完成的同时结束后，$ eventA开始时，先前的模式才匹配。
    </p><p>换一种说法：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </pre><p>Finishes评估程序接受一个可选参数。如果已定义，它将确定两个事件的结束时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this finishes[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e801"></a> 2.4.1.6。完成者</h4></div></div></div><p>finishby评估程序将两个事件相关联，并在当前事件开始时间戳记发生在相关事件开始时间戳记之前发生匹配，但是两个结束时间戳记都同时发生。这是涂饰评估师的对立面。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this finishedby $eventB ) </pre><p>当且仅当$ eventA在$ eventB开始并在$ eventB完成的同时结束时才与前一个模式匹配。
    </p><p>换一种说法：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </pre><p>finishby评估程序接受一个可选参数。如果已定义，它将确定两个事件的结束时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this finishedby[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e827"></a> 2.4.1.7。包括</h4></div></div></div><p>包含评估程序将两个事件关联起来，并在当前事件期间发生关联事件时进行匹配。它是评估程序期间的对称对立面。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this includes $eventB ) </pre><p>当且仅当$ eventB在$ eventA开始之后开始并在$ eventA完成之前结束时，先前的模式才匹配。</p><p>换一种说法：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt;= $eventB.endTimestamp &lt; $eventA.endTimestamp </pre><p>include运算符接受1、2或4个可选参数，如下所示：</p><div class="itemizedlist"><ul><li><p>如果定义了一个值，这将是两个事件的开始时间戳之间的最大距离与两个事件的结束时间戳之间的最大距离，以便与操作员匹配。例：</p><pre class="programlisting">$eventA : EventA( this includes[ 5s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">0 &lt; $eventB.startTimestamp - $eventA.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventA.endTimestamp - $eventB.endTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了两个值，则第一个值将是两个事件的时间戳之间的最小距离，而第二个值将是两个事件的时间戳之间的最大距离。例：</p><pre class="programlisting">$eventA : EventA( this includes[ 5s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">5s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了四个值，则前两个值将是两个事件的开始时间戳之间的最小和最大距离，而后两个值将是两个事件的结束时间戳之间的最小和最大距离。例：</p><pre class="programlisting">$eventA : EventA( this includes[ 2s, 6s, 4s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">2s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s </pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e874"></a> 2.4.1.8。遇见</h4></div></div></div><p>当当前事件的结束时间戳记与相关事件的开始时间戳记同时发生时，遇见评估器将两个事件关联起来并进行匹配。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this meets $eventB ) </pre><p>当且仅当$ eventA同时启动$ eventB时，上一个模式才匹配。</p><p>换一种说法：</p><pre class="programlisting">abs( $eventB.startTimestamp - $eventA.endTimestamp ) == 0 </pre><p>mets评估程序接受一个可选参数。如果已定义，它将确定当前事件的结束时间戳与相关事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this meets[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">abs( $eventB.startTimestamp - $eventA.endTimestamp) &lt;= 5s </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e900"></a> 2.4.1.9。遇见</h4></div></div></div><p>metby评估程序将两个事件关联起来，并在当前事件的开始时间戳记与关联事件的结束时间戳记同时发生时进行匹配。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this metby $eventB ) </pre><p>当且仅当$ eventA在$ eventB完成的同时开始时，上一个模式才匹配。</p><p>换一种说法：</p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.endTimestamp ) == 0 </pre><p>metby评估程序接受一个可选参数。如果已定义，它将确定相关事件的结束时间戳与当前事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this metby[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.endTimestamp) &lt;= 5s </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e926"></a> 2.4.1.10。重叠</h4></div></div></div><p>重叠评估器将两个事件关联起来，并在关联事件开始之前的当前事件开始时进行匹配，并在关联事件开始之后但关联事件结束之前完成关联。换句话说，两个事件都有一个重叠的时期。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this overlaps $eventB ) </pre><p>只有在以下情况下，上一个模式才会匹配：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>重叠运算符接受1或2个可选参数，如下所示：</p><div class="itemizedlist"><ul><li><p>如果定义了一个参数，则这将是相关事件的开始时间戳与当前事件的结束时间戳之间的最大距离。例：</p><pre class="programlisting">$eventA : EventA( this overlaps[ 5s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
0 &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了两个值，则第一个值将是相关事件的开始时间戳和当前事件的结束时间戳之间的最小距离，而第二个值将是最大距离。例：</p><pre class="programlisting">$eventA : EventA( this overlaps[ 5s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 10s </pre></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e961"></a> 2.4.1.11。重叠者</h4></div></div></div><p>overlaypedby评估程序会关联两个事件，并在相关事件在当前事件开始之前开始时匹配，并且在当前事件开始之后但在当前事件结束之前完成时匹配。换句话说，两个事件都有一个重叠的时期。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this overlappedby $eventB ) </pre><p>只有在以下情况下，上一个模式才会匹配：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp </pre><p>overlaypedby运算符接受1或2个可选参数，如下所示：</p><div class="itemizedlist"><ul><li><p>如果定义了一个参数，这将是当前事件的开始时间戳与相关事件的结束时间戳之间的最大距离。例：</p><pre class="programlisting">$eventA : EventA( this overlappedby[ 5s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
0 &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 5s</pre></li></ul></div><div class="itemizedlist"><ul><li><p>如果定义了两个值，则第一个值将是当前事件的开始时间戳和相关事件的结束时间戳之间的最小距离，而第二个值将是最大距离。例：</p><pre class="programlisting">$eventA : EventA( this overlappedby[ 5s, 10s ] $eventB )</pre><p>仅在以下情况下匹配：</p><pre class="programlisting">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 10s</pre></li></ul></div><p> </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e998"></a> 2.4.1.12。开始</h4></div></div></div><p>当当前事件的结束时间戳记在相关事件的结束时间戳记之前发生时，开始评估程序会关联两个事件并进行匹配，但是两个开始时间戳记都同时发生。</p><p>让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this starts $eventB ) </pre><p>当且仅当$ eventA在$ eventB完成并在$ eventB开始的同时开始时，先前的模式才匹配。
    </p><p>换一种说法：</p><pre class="programlisting">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </pre><p>启动评估程序接受一个可选参数。如果已定义，它将确定两个事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this starts[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1024"></a> 2.4.1.13。开始于</h4></div></div></div><p>当相关事件的结束时间戳记发生在当前事件的结束时间戳记之前，startedby评估程序将两个事件进行关联并进行匹配，但是两个开始时间戳记都同时发生。让我们看一个例子：</p><pre class="programlisting">$eventA : EventA( this startedby $eventB ) </pre><p>当且仅当$ eventB在$ eventA完成并在$ eventB开始的同时开始之前，先前的模式才匹配。
    </p><p>换一种说法：</p><pre class="programlisting">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </pre><p>startsby评估程序接受一个可选参数。如果已定义，它将确定两个事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</p><pre class="programlisting">$eventA : EventA( this starts[ 5s ] $eventB ) </pre><p>仅在以下情况下匹配：</p><pre class="programlisting">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </pre><div class="caution" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1048"></a> 2.5。事件处理模式</h2></div></div></div><p>规则引擎通常具有处理数据和规则并向应用程序提供结果的众所周知的方式。同样，对于如何将事实呈现给规则引擎也没有太多要求，特别是因为通常，处理本身是时间独立的。对于大多数场景而言，这是一个很好的假设，但对于所有场景而言并非如此。当需求包括实时或近实时事件的处理时，时间成为推理过程的重要变量。</p><p>以下各节将说明时间对规则推理的影响以及Drools为推理过程提供的两种模式。
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1055"></a> 2.5.1。云模式</h3></div></div></div><p>CLOUD处理模式是默认处理模式。规则引擎的用户熟悉此模式，因为它的行为与任何纯正向链接规则引擎（包括Drools的早期版本）完全相同。</p><p>在CLOUD模式下运行时，引擎会在工作内存中看到所有事实，无论它们是常规事实还是事件，都没有关系。尽管事件具有通常的时间戳，但没有时间流的概念。换句话说，尽管引擎知道某个给定事件是在2009年1月1日09：35：40.767上创建的，但由于存在以下情况，引擎无法确定该事件的“发生时间”没有“现在”的概念。</p><p>在这种模式下，引擎将应用其通常的多对多模式匹配算法，使用规则约束来查找匹配的元组，并照常激活和触发规则。</p><p>此模式不对事实施加任何其他要求。因此，例如：</p><div class="itemizedlist"><ul><li><p>没有时间观念。无需时钟同步。
      </p></li><li><p>对事件排序没有要求。引擎将事件视为无序的云，引擎将尝试匹配规则。</p></li></ul></div><p>另一方面，由于没有要求，因此某些好处也不可用。例如，在CLOUD模式下，无法使用滑动窗口，因为滑动窗口基于“ now”的概念，而在CLOUD模式下没有“ now”的概念。</p><p>由于对事件没有排序要求，因此引擎无法确定何时不再匹配事件，因此，没有针对事件的自动生命周期管理。即，应用程序必须在不再需要事件时显式撤回事件，就像应用程序处理常规事实一样。</p><p>云模式是Drools的默认执行模式，但是无论如何，与Drools中的任何其他配置一样，可以通过设置系统属性，使用配置属性文件或使用API来更改此行为。相应的属性是：</p><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( EventProcessingOption.CLOUD );</pre><p>等效属性为：</p><pre class="programlisting">drools.eventProcessingMode = cloud</pre><p></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1086"></a> 2.5.2。流模式</h3></div></div></div><p>当应用程序需要处理事件流时，选择STREAM处理模式。它为常规处理增加了一些通用要求，但启用了许多功能，这些功能使流事件处理变得更加简单。</p><p>使用STREAM模式的主要要求是：</p><div class="itemizedlist"><ul><li><p>每个流中的事件必须按时间排序。即，在给定的流中，首先发生的事件必须首先插入引擎。</p></li><li><p>引擎将通过使用会话时钟来强制流之间的同步，因此，尽管应用程序不需要在流之间强制执行时间排序，但使用非时间同步的流可能会导致某些意外结果。</p></li></ul></div><p>鉴于满足了以上要求，应用程序可以使用以下API启用STREAM模式：</p><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( EventProcessingOption.STREAM );</pre><p>或者，等效属性：</p><pre class="programlisting">drools.eventProcessingMode = stream</pre><p>使用STREAM时，引擎会了解时间流的概念和“现在”的概念，即引擎会根据从会话时钟读取的当前时间戳来了解旧事件的发生情况。此特征使引擎可以为应用程序提供以下附加功能：</p><div class="itemizedlist"><ul><li><p>滑动窗支架</p></li><li><p>自动事件生命周期管理</p></li><li><p>使用负模式时的自动规则延迟</p></li></ul></div><p>以下各节将说明所有这些功能。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1122"></a> 2.5.2.1。会话时钟在流模式下的作用</h4></div></div></div><p>在CLOUD模式下运行引擎时，会话时钟仅用于为没有预先定义的timestamp属性的到达事件加时间戳。尽管在STREAM模式下，会话时钟扮演着更为重要的角色。</p><p>在STREAM模式下，会话时钟负责保持当前时间戳，并基于该时间戳，引擎对事件的老化进行所有时间计算，同步来自多个源的流，安排将来的任务等。</p><p>查看“会话时钟”部分的文档，以了解如何配置和使用不同的会话时钟实现。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1131"></a> 2.5.2.2。流模式下的负模式</h4></div></div></div><p>与云模式相比，负模式在STREAM模式下的行为有所不同。在CLOUD模式下，引擎假定所有事实和事件都是事先已知的（没有时间流的概念），因此，否定模式会立即得到评估。</p><p>在STREAM模式下运行时，具有时间限制的否定模式可能要求引擎在激活规则之前等待一段时间。该时间段由引擎以用户无需使用任何技巧即可获得所需结果的方式自动计算。</p><p>例如：</p><div class="example"><a id="d0e1141"></a><p class="title"><b>示例2.11匹配后立即激活的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( ) )
then
    // sound the alarm
end
</pre></div></div><p><br class="example-break">上面的规则没有需要延迟规则的时间约束，因此规则立即激活。另一方面，以下规则在激活前必须等待10秒钟，因为喷淋头最多可能需要10秒钟才能激活：</p><div class="example"><a id="d0e1148"></a><p class="title"><b>示例2.12由于时间限制而自动延迟激活的规则</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break">当同时处理否定模式和时间约束时，此行为可使引擎保持一致性。上面的内容与下面的编写规则相同，但是不会给用户增加计算和明确编写适当的工时参数的负担：</p><div class="example"><a id="d0e1154"></a><p class="title"><b>示例2.13具有明确持续时间参数的相同规则</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm"
    duration( 10s )
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break"></p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1159"></a> 2.6。滑动窗</h2></div></div></div><p>滑动窗口是一种将感兴趣的事件划分为属于不断移动的窗口的事件的一种方法。两种最常见的滑动窗口实现是基于时间的窗口和基于长度的窗口。
  </p><p>下一节将详细介绍它们。</p><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p>只有在STREAM模式下运行引擎时，才可以使用滑动Windows。查看“事件处理模式”部分，以获取有关STREAM模式工作方式的详细信息。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1169"></a> 2.6.1。滑动时间窗</h3></div></div></div><p>滑动时间窗口允许用户编写仅匹配最近X个时间单位中发生的事件的规则。</p><p>例如，如果用户只想考虑最近2分钟内发生的“股票报价”，则模式如下所示：</p><pre class="programlisting">StockTick() over window:time( 2m )</pre><p>Drools使用“ over”关键字将窗口关联到模式。
  </p><p>在一个更详细的示例中，如果用户希望在从传感器读取的最近10分钟内的平均温度高于阈值的情况下发出警报，则规则如下所示：</p><div class="example"><a id="d0e1183"></a><p class="title"><b>示例2.14在时间范围内汇总值</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:time( 10m ),
        average( $temp ) )
then
    // sound the alarm
end
</pre></div></div><p><br class="example-break">引擎将自动丢弃任何超过10分钟的SensorReading，并保持计算出的平均值一致。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1189"></a> 2.6.2。滑动长度窗</h3></div></div></div><p>滑动长度窗口与时间窗口的工作方式相同，但是根据新事件的到来而不是时间的流逝丢弃事件。</p><p>例如，如果用户只考虑最近的10个IBM Stock Ticks，而与它们的年龄无关，则模式如下所示：</p><pre class="programlisting">StockTick( company == "IBM" ) over window:length( 10 )</pre><p>如您所见，该模式与上一节中介绍的模式类似，但是它没有使用window：time定义滑动窗口，而是使用window：length。</p><p>使用与上一部分类似的示例，如果用户希望在传感器的最近100个读数上的平均温度高于阈值的情况下发出警报，则规则如下所示：</p><div class="example"><a id="d0e1203"></a><p class="title"><b>示例2.15在长度窗口上汇总值</b></p><div class="example-contents"><pre class="programlisting">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:length( 100 ),
        average( $temp ) )
then
    // sound the alarm
end</pre></div></div><p><br class="example-break">引擎将仅保留最近的100个读数。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1209"></a> 2.7。知识库分区</h2></div></div></div><div class="warning" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>这是一项实验性功能，将来可能会发生变化。</p></div><p>经典的Rete算法通常使用单个线程执行。虽然，正如Forgy博士所证实的那样，该算法本身是可并行化的。ReteOO算法的Drools实现通过规则库分区支持粗粒度并行化。</p><p>启用此选项后，规则库将被划分为几个独立的分区，并且工作线程池将用于通过分区传播事实。该实现保证最多一个工作线程将为给定分区执行任务，但是多个分区可能在单个时间点处于“活动”状态。</p><p>一切对用户都是透明的，除了所有工作内存操作（插入/撤回/修改）是异步执行的。</p><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p>此功能启用并行LHS评估，但不会更改规则触发的行为。也就是说，根据冲突解决策略，规则将继续按顺序触发。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1224"></a> 2.7.1。分区有用时</h3></div></div></div><p>知识库分区是特定情况下非常强大的功能，但不是一般情况下的解决方案。要了解此功能对于给定场景是否有用，用户可以遵循以下检查清单：</p><div class="orderedlist"><ol type="1"><li><p>您的硬件是否包含多个处理器？</p></li><li><p>您的知识会议处理大量事实吗？</p></li><li><p>您的规则的LHS评估费用昂贵吗？（例如：使用昂贵的“ from”表达式）</p></li><li><p>您的知识库是否包含数百个或更多规则？</p></li></ol></div><p>如果对以上所有问题的回答均为“是”，则此功能可能会提高规则库评估的整体性能。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1244"></a> 2.7.2。如何配置分区</h3></div></div></div><p>要启用知识库分区，请设置以下选项：</p><div class="example"><a id="d0e1249"></a><p class="title"><b>示例2.16启用多线程评估（分区）</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( MultithreadEvaluationOption.YES );
</pre></div></div><br class="example-break"><p>等效属性为：</p><pre class="programlisting">drools.multithreadEvaluation = &lt;true|false&gt;</pre><p>此选项的默认值为“ false”（禁用）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1260"></a> 2.7.3。多线程管理</h3></div></div></div><p>Drools为用户提供了一个简单的配置选项，以控制工作线程池的大小。</p><p>要定义线程池的最大大小，用户可以使用以下配置选项：</p><div class="example"><a id="d0e1268"></a><p class="title"><b>示例2.17将用于规则评估的最大线程数设置为5</b></p><div class="example-contents"><pre class="programlisting">KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( MaxThreadsOption.get(5) );
</pre></div></div><p><br class="example-break"></p><p>等效属性为：</p><pre class="programlisting">drools.maxThreads = &lt;-1|1..n&gt;</pre><p>此配置的默认值为3，负数表示引擎将尝试生成与规则库中分区数量一样多的线程。</p><div class="warning" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>警告</h2><p>将此选项设置为负数通常很危险。始终将其设置为合理的正数线程。</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1282"></a> 2.8。事件的内存管理</h2></div></div></div><div class="important" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory"><h2>重要</h2><p>仅在STREAM模式下运行引擎时，才会执行事件的自动内存管理。查看“事件处理模式”部分，以获取有关STREAM模式工作方式的详细信息。</p></div><p>在STREAM模式下运行引擎的好处之一是，引擎可以检测到事件由于其时间限制而不再与任何规则匹配的时间。发生这种情况时，引擎可以安全地从会话中撤回该事件而没有副作用，并释放该事件使用的任何资源。</p><p>引擎基本上有2种方法来计算给定事件的匹配窗口：</p><div class="itemizedlist"><ul><li><p>明确地，使用到期策略</p></li><li><p>隐式地分析事件的时间约束</p></li></ul></div><p></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1300"></a> 2.8.1。显式过期偏移</h3></div></div></div><p>允许引擎为给定事件类型计算关注窗口的第一种方法是通过显式设置它。为此，只需使用clarify语句并为事实类型定义到期时间：</p><div class="example"><a id="d0e1306"></a><p class="title"><b>示例2.18为StockTick事件明确定义30分钟的到期时间偏移</b></p><div class="example-contents"><pre class="programlisting">declare StockTick
    @expires( 30m )
end
</pre></div></div><p><br class="example-break">上面的示例声明了StockTick事件的30分钟过期偏移。在那之后，假设没有规则仍然需要该事件，则引擎将过期并自动从会话中删除该事件。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1312"></a> 2.8.2。推断的过期时间偏移</h3></div></div></div><p>引擎针对给定事件计算过期偏移的另一种方法是通过分析规则中的时间约束来隐式地进行计算。例如，给定以下规则：</p><div class="example"><a id="d0e1318"></a><p class="title"><b>示例2.19具有时间约束的示例规则</b></p><div class="example-contents"><pre class="programlisting">rule "correlate orders"
when
    $bo : BuyOrderEvent( $id : id ) 
    $ae : AckEvent( id == $id, this after[0,10s] $bo )
then
    // do something
end
</pre></div></div><p><br class="example-break">分析上述规则，引擎会自动计算出，每当BuyOrderEvent匹配时，它需要将其存储最多10秒钟，以等待与AckEvent匹配。因此，BuyOrderEvent的隐式过期偏移为10秒。另一方面，AckEvent只能与现有的BuyOrderEvent匹配，因此其到期时间偏移为零秒。</p><p>引擎将对整个规则库进行分析，并找到每种事件类型的偏移量。每当隐式过期偏移与显式过期偏移发生冲突时，引擎将使用两者中的较大者。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1326"></a>第3章。参考文献</h2></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1329"></a>指数</h2></div></div></div><div class="index"><div class="indexdiv"><h3>C</h3><dl><dt>复杂事件处理， <a class="indexterm" href="#d0e16">复杂事件处理</a></dt></dl></div><div class="indexdiv"><h3>Ë</h3><dl><dt>事件， <a class="indexterm" href="#d0e16">复杂事件处理</a></dt></dl></div></div></div></div></body></html>