<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools Flow用户指南</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"><meta name="generator" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" content="DocBook XSL-NS Stylesheets V1.74.0"><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e9">1。介绍</a></span></dt><dt><span class="chapter"><a href="#d0e37">2。入门</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e42">2.1。安装</a></span></dt><dt><span class="section"><a href="#d0e68">2.2。创建您的第一个流程</a></span></dt><dt><span class="section"><a href="#d0e123">2.3。执行您的第一个过程</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e165">3。规则流</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e176">3.1。创建RuleFlow流程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e189">3.1.1。使用图形RuleFlow编辑器</a></span></dt><dt><span class="section"><a href="#d0e212">3.1.2。使用XML定义流程</a></span></dt><dt><span class="section"><a href="#d0e221">3.1.3。使用流程API定义流程</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e312">3.2。在您的应用程序中使用流程</a></span></dt><dt><span class="section"><a href="#d0e360">3.3。不同节点类型的详细说明</a></span></dt><dt><span class="section"><a href="#sec.data">3.4。数据</a></span></dt><dt><span class="section"><a href="#d0e1118">3.5。约束条件</a></span></dt><dt><span class="section"><a href="#d0e1154">3.6。动作</a></span></dt><dt><span class="section"><a href="#d0e1199">3.7。大事记</a></span></dt><dt><span class="section"><a href="#sec.exceptions">3.8。例外情况</a></span></dt><dt><span class="section"><a href="#sec.timers">3.9。计时器</a></span></dt><dt><span class="section"><a href="#d0e1297">3.10。将规则分配给规则流组</a></span></dt><dt><span class="section"><a href="#d0e1313">3.11。一个简单的规则流</a></span></dt><dt><span class="section"><a href="#d0e1360">3.12。使用Drools 4.x RuleFlow流程</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1375">4。Drools Flow API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1378">4.1。知识库</a></span></dt><dt><span class="section"><a href="#d0e1387">4.2。届会</a></span></dt><dt><span class="section"><a href="#d0e1401">4.3。大事记</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e1436">5，坚持不懈</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1441">5.1。运行时状态</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1448">5.1.1。二进制余辉</a></span></dt><dt><span class="section"><a href="#d0e1453">5.1.2。安全点</a></span></dt><dt><span class="section"><a href="#d0e1458">5.1.3。配置持久性</a></span></dt><dt><span class="section"><a href="#d0e1539">5.1.4。交易次数</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1548">5.2。工艺定义</a></span></dt><dt><span class="section"><a href="#d0e1555">5.3。历史记录</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1562">5.3.1。在数据库中存储流程事件</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1607">6。流口水流程模型</a></span></dt><dt><span class="chapter"><a href="#d0e1617">7。规则与程序</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1622">7.1。为什么在流程中使用规则？</a></span></dt><dt><span class="section"><a href="#d0e1655">7.2。为什么在单个引擎中集成规则和流程？</a></span></dt><dt><span class="section"><a href="#d0e1679">7.3。方法</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1693">7.3.1。讲授关于流程的规则引擎</a></span></dt><dt><span class="section"><a href="#d0e1698">7.3.2。控制反转</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1705">7.4。例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1716">7.4.1。评估过程中的一组规则</a></span></dt><dt><span class="section"><a href="#d0e1735">7.4.2。使用规则评估约束</a></span></dt><dt><span class="section"><a href="#d0e1743">7.4.3。分配规则</a></span></dt><dt><span class="section"><a href="#d0e1752">7.4.4。使用规则描述特殊情况</a></span></dt><dt><span class="section"><a href="#d0e1757">7.4.5。使用规则模块化问题</a></span></dt><dt><span class="section"><a href="#d0e1762">7.4.6。动态更改流程行为的规则</a></span></dt><dt><span class="section"><a href="#d0e1769">7.4.7。集成工具</a></span></dt><dt><span class="section"><a href="#d0e1781">7.4.8。特定领域的规则和流程</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ch.Domain_Specific_Processes">8。特定领域的流程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1791">8.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e1821">8.2。示例：通知</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1828">8.2.1。创建工作定义</a></span></dt><dt><span class="section"><a href="#d0e1835">8.2.2。注册工作定义</a></span></dt><dt><span class="section"><a href="#d0e1842">8.2.3。在流程中使用新工作项</a></span></dt><dt><span class="section"><a href="#d0e1864">8.2.4。执行工作项</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1892">8.3。使用工作项测试流程</a></span></dt><dt><span class="section"><a href="#d0e1897">8.4。未来</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch.Human_Tasks">9。人工任务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1909">9.1。流程中的人工任务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1989">9.1.1。泳道</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1998">9.2。人工任务管理组件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2010">9.2.1。任务生命周期</a></span></dt><dt><span class="section"><a href="#d0e2034">9.2.2。将任务组件链接到Drools Flow引擎</a></span></dt><dt><span class="section"><a href="#d0e2079">9.2.3。启动任务管理组件</a></span></dt><dt><span class="section"><a href="#d0e2094">9.2.4。与任务管理组件进行交互</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2122">9.3。人工任务管理界面</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2126">9.3.1。Eclipse整合</a></span></dt><dt><span class="section"><a href="#d0e2134">9.3.2。基于Web的任务视图</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2140">10。调试过程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2145">10.1。一个简单的例子</a></span></dt><dt><span class="section"><a href="#d0e2167">10.2。调试过程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2206">10.2.1。流程实例视图</a></span></dt><dt><span class="section"><a href="#d0e2248">10.2.2。审核视图</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ch.Drools_Eclipse_IDE_Features">11。Drools Eclipse IDE功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2261">11.1。流口水运行时</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2266">11.1.1。定义Drools运行时</a></span></dt><dt><span class="section"><a href="#d0e2303">11.1.2。为您的Drools项目选择运行时</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2318">11.2。处理皮肤</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e2346">12业务活动监控</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2353">12.1。报告中</a></span></dt><dt><span class="section"><a href="#d0e2374">12.2。直接干预</a></span></dt></dl></dd><dt><span class="index"><a href="#d0e2387">指数</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9"></a>第1章。介绍</h2></div></div></div><p>Drools Flow是一个工作流或流程引擎，允许对流程和规则进行高级集成。流程或工作流使用流程图描述了需要执行一系列步骤的顺序。例如，下图显示了需要并行执行第一个Task1和Task2的过程。两者都完成后，需要执行Task3。</p><div class="mediaobject" align="center"><img src="./images/Chapter-Introduction/process.bmp" align="middle"></div><p>以下章节将教您有关Drools Flow的所有知识。其区别特征是：</p><div class="orderedlist"><ol type="1"><li><span class="strong"><strong>流程和规则的高级集成：</strong></span>在定义业务逻辑时，流程和规则通常被视为两种不同的范例。通过集成流程和规则引擎可以实现流程和规则之间的松散耦合，但我们提供了开箱即用的流程和规则的高级集成。这使用户可以在定义业务流程时使用规则来定义其业务逻辑的一部分，反之亦然。</li><li><span class="strong"><strong>流程和规则的统一：</strong></span>我们将规则，流程和事件处理视为不同类型的知识。我们不仅允许这三种类型的高级集成，而且还提供了统一的API和统一的工具，因此用户不必学习三种不同的产品，而是可以使用我们基于知识的API轻松地将这三种类型组合在一起。该工具还允许无缝集成这些不同种类的知识，包括统一知识存储库，审核日志，调试等。</li><li><span class="strong"><strong>声明式建模：</strong></span> Drools Flow尝试使流程尽可能保持声明式，即专注于应该发生的事情而不是如何发生的事情。因此，我们试图避免将细节硬编码到您的流程中，而是提供了一种抽象的方式来描述您的工作的方式（例如，通过使用可插入工作项，业务脚本语言等）。我们还允许用户轻松创建特定于域的扩展名，从而使它们更易于阅读，更新或创建这些过程，因为它们使用的是与特定问题密切相关且领域专家可以理解的特定于域的概念。</li><li><span class="strong"><strong>支持多种流程语言的通用流程引擎：</strong></span>我们认为没有一种流程语言可以满足所有目的。因此，Drools Flow引擎基于通用流程引擎，该引擎允许定义和执行不同类型的流程语言，例如我们的RuleFlow语言，WS-BPEL（针对Web服务编排的标准），OSWorkflow（另一个现有的流程语言）工作流语言），jPDL（由jBPM项目定义的过程语言）等。所有这些语言都基于相同的核心构建块集，通过重用和组合这些低层构建，可以更轻松地实现自己的过程语言阻碍您想要的方式。</li></ol></div><p>所有这些功能（以及更多功能）将在以下章节中进行说明。
  </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e37"></a>第2章。入门</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e42">2.1。安装</a></span></dt><dt><span class="section"><a href="#d0e68">2.2。创建您的第一个流程</a></span></dt><dt><span class="section"><a href="#d0e123">2.3。执行您的第一个过程</a></span></dt></dl></div><p>本节描述了如何开始Drools Flow。它将指导您创建并执行您的第一个Drools Flow过程。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e42"></a> 2.1。安装</h2></div></div></div><p>最好的入门方法是在Eclipse开发环境中使用Drools Eclipse插件。它允许用户创建，执行和调试Drools流程和规则。要开始使用该插件，您首先需要安装Eclipse 3.4.x，包括Eclipse图形编辑框架（GEF）。可以从以下链接下载Eclipse（如果您不知道所需的eclipse版本，只需选择“ Java开发人员的Eclipse IDE”，并且该版本已经包含GEF插件）：</p><p><a class="ulink" href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a></p><p>接下来，您需要安装Drools Eclipse插件。从下面的链接下载Drools Eclipse IDE插件。将下载的文件解压缩到您的主eclipse文件夹中（不要只是将文件复制到那里，解压缩它，以便功能和插件jar最终位于eclipse的功能和插件目录中）并（重新）启动Eclipse。</p><p><a class="ulink" href="http://www.jboss.org/drools/downloads.html">http://www.jboss.org/drools/downloads.html</a></p><p>要检查安装是否成功，请尝试打开Drools透视图：单击Eclipse窗口右上角的“打开透视图”按钮，选择“其他...”，然后选择Drools透视图。如果您找不到Drools透视图作为可能的透视图之一，则说明安装可能不成功。检查是否正确执行了每个必需的步骤：您是否具有正确版本的Eclipse（3.4.x）？通过检查是否已安装Eclipse GEF，确保<code class="filename">org.eclipse.gef_3.4.*.jar</code>存在于Eclipse根文件夹的plugins目录中。通过检查是否已正确提取Drools Eclipse插件，确保<code class="filename">org.drools.eclipse_*.jar</code>存在于Eclipse根文件夹的plugins目录中。如果找不到问题，请尝试通过irc或用户邮件列表与我们联系。可以在我们的主页上找到更多信息：</p><p><a class="ulink" href="http://www.jboss.org/drools/">http://www.jboss.org/drools/</a></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e68"></a> 2.2。创建您的第一个流程</h2></div></div></div><p>Drools项目向导可用于设置可执行项目，该项目包含必要的文件，以便轻松地开始定义和执行过程。该向导将设置基本的项目结构，类路径，示例过程和执行代码，以帮助您入门。要创建一个新的Drools项目，只需在Eclipse工具栏中左键单击Drools操作按钮（带有Drools头），然后选择“ New Drools Project”。（请注意，Drools操作按钮仅在Drools透视图中显示。要打开Drools透视图（如果尚未打开），请单击Eclipse窗口右上角的“打开透视图”按钮，选择“其他...”，然后选择Drools透视图。）或者，您也可以选择“文件”，然后选择“新建”，再选择“项目...”，然后在Drools文件夹中选择“ Drools Project”。这应该打开以下对话框：</p><div class="mediaobject" align="center"><img src="./images/Chapter-GettingStarted/project-wizard1.bmp" align="middle"></div><p>为您的项目命名，然后单击“下一步”。在以下对话框中，您可以选择默认情况下将哪些元素添加到项目中。由于我们正在创建一个新流程，因此请取消选择前两个复选框，然后选择后两个复选框。这将生成一个示例过程和一个Java类来执行此过程。</p><div class="mediaobject" align="center"><img src="./images/Chapter-GettingStarted/project-wizard2.bmp" align="middle"></div><p>如果尚未设置Drools运行时，则应立即执行。Drools运行时是文件系统上jar的集合，代表了一个特定版本的Drools项目jar。要创建运行时，您必须将IDE指向您选择的发行版，或者您可以简单地从Drools Eclipse插件中包含的jar在文件系统上创建一个新的运行时。由于我们只是想使用此插件中包含的Drools版本，因此我们将使用后者。注意，您只需要这样做一次；下次创建Drools项目时，它将自动使用默认的Drools运行时（除非另行指定）。</p><p>除非您已经设置了Drools运行时，否则请单击“下一步”按钮。出现如下所示的对话框，告诉您尚未定义默认的Drools运行时，应首先配置工作区设置。通过单击“配置工作区设置...”链接来执行此操作。</p><div class="mediaobject" align="center"><img src="./images/Chapter-GettingStarted/project-wizard3.bmp" align="middle"></div><p>弹出的对话框显示Drools运行时的工作区设置。首次执行此操作时，已安装的Drools运行时列表可能为空，如下所示。要在文件系统上创建新的运行时，请单击“添加...”按钮。这将显示一个对话框，您应在其中为新的运行时命名（例如“ Drools 5.0.0运行时”），并在文件系统上指定Drools运行时的路径。在本教程中，我们将简单地从Drools Eclipse插件中嵌入的jar中创建一个新的Drools 5运行时。单击“创建新的Drools 5运行时...”按钮，然后选择要在其中存储该运行时的文件夹，然后单击“确定”按钮。您将在上一个对话框中看到所选路径。到此为止，点击“确定”按钮。您将在Drools运行时列表中看到新创建的运行时。单击运行时名称前面的复选框，然后将此运行时选择为新的默认运行时，然后单击“确定”。成功设置运行系统后，您现在可以通过单击“完成”按钮来完成项目创建向导。</p><div class="mediaobject" align="center"><img src="./images/Chapter-GettingStarted/project-runtimes.bmp" align="middle"></div><p>最终结果应如下所示，并包含：</p><div class="orderedlist"><ol type="1"><li><p><code class="filename">ruleflow.rf</code> ：流程定义，它是一个非常简单的流程，包含一个Start节点（入口点），一个Action节点（打印出“ Hello World”）和一个End节点（流程的结尾）。</p></li><li><p><code class="filename">RuleFlowTest.java</code> ：执行流程的Java类。</p></li><li><p>必要的库将作为Drools库自动添加到项目类路径中。</p></li></ol></div><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-GettingStarted/initial.bmp" align="middle" width="100%"></td></tr></tbody></table></div><p>双击<code class="filename">ruleflow.rf</code>文件，该过程将在RuleFlow编辑器中打开。RuleFlow编辑器包含过程定义的图形表示。它由相互连接的节点组成。编辑器显示了总体控制流程，而每个元素的详细信息都可以在底部的“属性视图”中查看（和编辑）。编辑器在左侧包含一个调色板，可用于拖放新节点，在右侧包含一个大纲视图。</p><p>此过程是三个节点的简单序列。“开始”节点定义流程的开始。它连接到一个动作节点（称为“ Hello”），该节点仅将“ Hello World”输出到标准输出。您可以通过单击“ Hello”节点并在下面的“属性视图”中检查action属性来查看。然后将此节点连接到End节点，以信号通知过程结束。</p><p>尽管使用图形编辑器编辑流程可能更容易，但用户也可以直接修改基础XML。下面显示了示例过程的XML（请注意，为简单起见，此处未包含图形信息）。流程元素包含诸如流程的名称和ID之类的参数，并由三个主要子部分组成：标头（可以定义诸如变量，全局变量和导入之类的信息），节点和连接。</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;process xmlns="http://drools.org/drools-5.0/process"
         xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         xs:schemaLocation="http://drools.org/drools-5.0/process drools-processes-5.0.xsd"
         type="RuleFlow"
         name="ruleflow"
         id="com.sample.ruleflow"
         package-name="com.sample" &gt;

  &lt;header&gt;
  &lt;/header&gt;

  &lt;nodes&gt;
    &lt;start id="1" name="Start" x="16" y="16" /&gt;
    &lt;actionNode id="2" name="Hello" x="128" y="16" &gt;
      &lt;action type="expression"
                 dialect="mvel"&gt;System.out.println("Hello World");&lt;/action&gt;
    &lt;/actionNode&gt;
    &lt;end id="3" name="End" x="240" y="16" /&gt;
  &lt;/nodes&gt;

  &lt;connections&gt;
    &lt;connection from="1" to="2" /&gt;
    &lt;connection from="2" to="3" /&gt;
  &lt;/connections&gt;

&lt;/process&gt;
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e123"></a> 2.3。执行您的第一个过程</h2></div></div></div><p>要执行此过程，请右键单击<code class="filename">RuleFlowTest.java</code>并选择“运行方式...”和“ Java应用程序”。执行该过程后，以下输出应出现在“控制台”窗口中：</p><pre class="programlisting">
Hello World
</pre><p>如果你看课的代码<code class="code">RuleFlowTest</code> （请参见下文），您将看到执行流程需要几个步骤：</p><div class="orderedlist"><ol type="1"><li><p>您首先应该创建一个知识库。知识库包含与您的应用程序相关的所有知识（即流程，规则等）。该知识库通常只创建一次，然后重用。在这种情况下，知识库仅包含我们的示例过程。</p></li><li><p>接下来，您应该创建一个会话以与引擎进行交互。请注意，我们还在会话中添加了一个记录器，以记录执行事件，并使可视化变得更加容易。</p></li><li><p>最后，您可以通过以下方式启动流程的新实例： <code class="code">startProcess(String processId)</code>会话中的方法。这将启动流程实例的执行，导致依次执行Start节点，Action节点和End节点，然后将完成流程实例。</p></li></ol></div><pre class="programlisting">
package com.sample;

import org.drools.KnowledgeBase;
import org.drools.KnowledgeBaseFactory;
import org.drools.builder.KnowledgeBuilder;
import org.drools.builder.KnowledgeBuilderError;
import org.drools.builder.KnowledgeBuilderErrors;
import org.drools.builder.KnowledgeBuilderFactory;
import org.drools.builder.KnowledgeType;
import org.drools.io.ResourceFactory;
import org.drools.logger.KnowledgeRuntimeLogger;
import org.drools.logger.KnowledgeRuntimeLoggerFactory;
import org.drools.runtime.StatefulKnowledgeSession;

/**
 * This is a sample file to launch a process.
 */
public class RuleFlowTest {

  public static final void main(String[] args) {
    try {
      // load up the knowledge base
      KnowledgeBase kbase = readKnowledgeBase();
      StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
      KnowledgeRuntimeLogger logger =
        KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "test");
      // start a new process instance
      ksession.startProcess("com.sample.ruleflow");
      logger.close();
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }

  private static KnowledgeBase readKnowledgeBase() throws Exception {
    KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
    kbuilder.add(ResourceFactory.newClassPathResource("ruleflow.rf"), KnowledgeType.DRF);
    KnowledgeBuilderErrors errors = kbuilder.getErrors();
    if (errors.size() &gt; 0) {
      for (KnowledgeBuilderError error: errors) {
        System.err.println(error);
      }
      throw new IllegalArgumentException("Could not parse knowledge.");
    }
    KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
    kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());
    return kbase;
  }

}
</pre><p>恭喜，您已经成功执行了第一个流程！由于我们在会话中添加了记录器，因此您可以通过查看审核日志轻松地检查内部发生的情况。选择右下角“控制台”选项卡旁边的“审核视图”选项卡。单击“打开日志”按钮（视图右侧的第一个），然后导航到新创建的<code class="filename">test.log</code>文件放在您的项目文件夹中。（如果不确定该项目文件夹的位置，请右键单击该项目文件夹，然后在“资源”部分中找到该位置）。应该显示类似下面的图像。它是运行时发生的事件的树状视图。作为另一个事件的直接结果而执行的事件将显示为该事件的子级。此日志显示，在启动流程之后，将按此顺序触发“开始”节点，“操作”节点和“结束”节点，然后完成流程实例。</p><div class="mediaobject" align="center"><img src="./images/Chapter-GettingStarted/audit.bmp" align="middle"></div><p>现在，您可以通过修改示例来开始实验和设计自己的流程。请注意，您可以通过单击“检查规则流模型”按钮来验证过程，即，如果您正在编辑过程，则上方工具栏中的绿色复选框动作将显示出来。保存后还将验证流程，并且错误将显示在“错误视图”中。</p><p>继续阅读我们的文档，以了解更多高级功能。</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e165"></a>第3章。规则流</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e176">3.1。创建RuleFlow流程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e189">3.1.1。使用图形RuleFlow编辑器</a></span></dt><dt><span class="section"><a href="#d0e212">3.1.2。使用XML定义流程</a></span></dt><dt><span class="section"><a href="#d0e221">3.1.3。使用流程API定义流程</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e312">3.2。在您的应用程序中使用流程</a></span></dt><dt><span class="section"><a href="#d0e360">3.3。不同节点类型的详细说明</a></span></dt><dt><span class="section"><a href="#sec.data">3.4。数据</a></span></dt><dt><span class="section"><a href="#d0e1118">3.5。约束条件</a></span></dt><dt><span class="section"><a href="#d0e1154">3.6。动作</a></span></dt><dt><span class="section"><a href="#d0e1199">3.7。大事记</a></span></dt><dt><span class="section"><a href="#sec.exceptions">3.8。例外情况</a></span></dt><dt><span class="section"><a href="#sec.timers">3.9。计时器</a></span></dt><dt><span class="section"><a href="#d0e1297">3.10。将规则分配给规则流组</a></span></dt><dt><span class="section"><a href="#d0e1313">3.11。一个简单的规则流</a></span></dt><dt><span class="section"><a href="#d0e1360">3.12。使用Drools 4.x RuleFlow流程</a></span></dt></dl></div><div class="figure"><a id="d0e168"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/RuleFlow.png" align="middle" alt="规则流"></div></div><p class="title"><b>图3.1。规则流</b></p></div><br class="figure-break"><p>RuleFlow是使用流程图描述需要执行一系列步骤的顺序的过程。一个过程由节点的集合组成，这些节点使用连接彼此链接。每个节点代表整个过程中的一个步骤，而连接指定如何从一个节点过渡到另一个节点。已经定义了很多预定义的节点类型。本章介绍如何定义此类过程并在您的应用程序中使用它们。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e176"></a> 3.1。创建RuleFlow流程</h2></div></div></div><p>可以使用以下三种方法之一创建进程：</p><div class="orderedlist"><ol type="1"><li>在Drools插件的Eclipse中使用图形化RuleFlow编辑器</li><li>作为XML文件，根据Drools流程的XML Schema定义中定义的XML流程格式。</li><li>通过使用Process API直接创建流程。</li></ol></div><p>
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e189"></a> 3.1.1。使用图形RuleFlow编辑器</h3></div></div></div><p>图形RuleFlow编辑器是允许您通过在画布上拖放不同的节点并编辑这些节点的属性来创建过程的编辑器。图形化RuleFlow编辑器是Eclipse的Drools插件的一部分。一旦设置了Drools项目（如果您不知道如何执行，请检查IDE章节），就可以开始添加流程。在项目中时，启动“新建”向导：使用Ctrl + N或右键单击要放入规则流的目录，然后选择“新建”，然后选择“其他...”。选择“ Drools”部分，然后选择“ RuleFlow文件”。这将创建一个新的.rf文件。</p><div class="figure"><a id="d0e194"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/RFNewWizard.png" align="middle" alt="创建一个新的RuleFlow文件"></div></div><p class="title"><b>图3.2。创建一个新的RuleFlow文件</b></p></div><br class="figure-break"><p>接下来，您将看到图形化RuleFlow编辑器。现在是切换到Drools Perspective的好时机（如果您还没有这样做的话）。这将调整用户界面，使其最适合规则。然后，确保您可以在Eclipse窗口的底部看到“属性视图”，因为有必要在流程中填写元素的不同属性。如果看不到属性视图，请使用菜单“窗口”，“显示视图”和“其他...”打开它，然后在“常规”文件夹下选择属性视图。</p><div class="figure"><a id="d0e202"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Flow/NewRF.png" align="middle" width="100%" alt="新的RuleFlow流程"></td></tr></tbody></table></div></div><p class="title"><b>图3.3。新的RuleFlow流程</b></p></div><br class="figure-break"><p>RuleFlow编辑器由一个调色板，一个画布和一个大纲视图组成。要将新元素添加到画布，请选择要在调色板中创建的元素，然后通过单击首选位置将其添加到画布。例如，在GUI的“组件”面板中单击“ RuleFlowGroup”图标：然后，您可以绘制一些规则流组。单击规则流中的元素，可以设置该元素的属性。您可以使用“组件”面板中的“连接创建”来连接节点（只要不同类型的节点允许）。</p><p>您可以继续向过程中添加节点和连接，直到它代表您要指定的业务逻辑为止。在尝试在应用程序中使用任何信息之前，您可能需要检查该过程中是否缺少任何信息（通过按IDE菜单栏中的绿色“检查”图标）。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e212"></a> 3.1.2。使用XML定义流程</h3></div></div></div><p>也可以直接使用基础XML指定进程。这些XML进程的语法是使用XML模式定义定义的。例如，以下XML片段显示了一个简单的过程，该过程包含一个开始节点，一个将“ Hello World”打印到控制台的Action节点和一个End节点的序列。</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;process xmlns="http://drools.org/drools-5.0/process"
         xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         xs:schemaLocation="http://drools.org/drools-5.0/process drools-processes-5.0.xsd"
         type="RuleFlow" name="ruleflow" id="com.sample.ruleflow" package-name="com.sample" &gt;

  &lt;header&gt;
  &lt;/header&gt;

  &lt;nodes&gt;
    &lt;start id="1" name="Start" x="16" y="16" /&gt;
    &lt;actionNode id="2" name="Hello" x="128" y="16" &gt;
      &lt;action type="expression" dialect="mvel" &gt;System.out.println("Hello World");&lt;/action&gt;
    &lt;/actionNode&gt;
    &lt;end id="3" name="End" x="240" y="16" /&gt;
  &lt;/nodes&gt;

  &lt;connections&gt;
    &lt;connection from="1" to="2" /&gt;
    &lt;connection from="2" to="3" /&gt;
  &lt;/connections&gt;

&lt;/process&gt;
</pre><p>流程XML文件应仅包含一个<process>元素。此元素包含与过程相关的参数（其类型，名称，ID和程序包名称），并包括三个小节：</process></p><header>（可以定义诸如变量，全局变量，导入和泳道之类的过程级信息），一个<nodes>定义过程中每个节点的<connections>部分以及一个<connections>包含过程中所有节点之间的连接的<connections>部分。在节点部分中，每个节点都有一个特定的元素，用于定义该节点类型的各种参数以及子元素。</connections></connections></connections></nodes></header></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e221"></a> 3.1.3。使用流程API定义流程</h3></div></div></div><p>虽然建议使用图形编辑器或基础XML定义流程（以保护自己免受内部API的侵害），但也可以直接使用Process API定义流程。软件包中定义了最重要的过程元素<code class="code">org.drools.workflow.core</code>和<code class="code">org.drools.workflow.core.node</code> 。提供了“流畅的API”，使您可以使用工厂以可读的方式轻松地构造流程。最后，您可以验证手动构建的过程。下面添加了一些有关如何使用此fluent API构建流程的示例。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e232"></a> 3.1.3.1。例子1</h4></div></div></div><p>这是仅具有规则集节点的基本过程的简单示例：</p><pre class="programlisting">
RuleFlowProcessFactory factory =
    RuleFlowProcessFactory.createProcess("org.drools.HelloWorldRuleSet");
factory
    // Header
    .name("HelloWorldRuleSet")
    .version("1.0")
    .packageName("org.drools")
    // Nodes
    .startNode(1).name("Start").done()
    .ruleSetNode(2)
        .name("RuleSet")
        .ruleFlowGroup("someGroup").done()
    .endNode(3).name("End").done()
    // Connections
    .connection(1, 2)
    .connection(2, 3);
RuleFlowProcess process = factory.validate().getProcess();</pre><p>
      </p><p>您可以看到我们首先调用了static <code class="code">createProcess()</code>的方法<code class="code">RuleFlowProcessFactory</code>类。此方法使用给定的id创建一个新进程，并返回<code class="code">RuleFlowProcessFactory</code>可以用来创建过程。一个典型的过程包括三个部分。标头部分包含全局元素，例如进程名称，导入，变量等。节点部分包含了流程中所有不同的节点。最后，连接部分将这些节点彼此链接以创建流程图。</p><p>在此示例中，标题包含进程的名称和版本以及程序包名称。之后，您可以开始将节点添加到当前进程。如果您具有自动完成功能，则可以看到可以使用不同的方法来创建每种受支持的节点类型。</p><p>在开始向流程中添加节点时，在本示例中，通过调用<code class="code">startNode()</code> ， <code class="code">ruleSetNode()</code>和<code class="code">endNode()</code>方法，您可以看到这些方法返回特定的<code class="code">NodeFactory</code> ，它允许您设置该节点的属性。完成特定节点的配置后， <code class="code">done()</code>方法将您返回到当前<code class="code">RuleFlowProcessFactory</code>因此您可以根据需要添加更多节点。</p><p>添加完节点后，必须通过在它们之间创建连接来连接它们。这可以通过调用方法来完成<code class="code">connection</code> ，它将链接先前创建的节点。</p><p>最后，您可以通过调用<code class="code">validate()</code>方法并检索创建的<code class="code">RuleFlowProcess</code>宾语。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e286"></a> 3.1.3.2。例子2</h4></div></div></div><p>本示例使用拆分和联接节点：</p><pre class="programlisting">
RuleFlowProcessFactory factory =
    RuleFlowProcessFactory.createProcess("org.drools.HelloWorldJoinSplit");
factory
    // Header
    .name("HelloWorldJoinSplit")
    .version("1.0")
    .packageName("org.drools")
    // Nodes
    .startNode(1).name("Start").done()
    .splitNode(2).name("Split").type(Split.TYPE_AND).done()
    .actionNode(3).name("Action 1")
        .action("mvel", "System.out.println(\"Inside Action 1\")").done()
    .actionNode(4).name("Action 2")
        .action("mvel", "System.out.println(\"Inside Action 2\")").done()
    .joinNode(5).type(Join.TYPE_AND).done()
    .endNode(6).name("End").done()
    // Connections
    .connection(1, 2)
    .connection(2, 3)
    .connection(2, 4)
    .connection(3, 5)
    .connection(4, 5)
    .connection(5, 6);
RuleFlowProcess process = factory.validate().getProcess();</pre><p>
      </p><p>这显示了一个使用Split和Join节点的简单示例。如您所见，拆分节点可以具有多个传出连接，而联接节点可以具有多个传入连接。要了解不同类型的拆分节点和联接节点的行为，请查看每个节点的文档。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e296"></a> 3.1.3.3。例子3</h4></div></div></div><p>现在，我们展示一个带有ForEach节点的更复杂的示例，其中有嵌套节点：</p><pre class="programlisting">
RuleFlowProcessFactory factory =
    RuleFlowProcessFactory.createProcess("org.drools.HelloWorldForeach");
factory
    // Header
    .name("HelloWorldForeach")
    .version("1.0")
    .packageName("org.drools")
    // Nodes
    .startNode(1).name("Start").done()
    .forEachNode(2)
        // Properties
        .linkIncomingConnections(3)
        .linkOutgoingConnections(4)
        .collectionExpression("persons")
        .variable("child", new ObjectDataType("org.drools.Person"))
        // Nodes
        .actionNode(3)
            .action("mvel", "System.out.println(\"inside action1\")").done()
        .actionNode(4)
            .action("mvel", "System.out.println(\"inside action2\")").done()
        // Connections
        .connection(3, 4)
        .done()
    .endNode(5).name("End").done()
    // Connections
    .connection(1, 2)
    .connection(2, 5);
RuleFlowProcess process = factory.validate().getProcess();</pre><p>
      </p><p>在这里，您可以看到如何将ForEach节点与嵌套动作节点包括在一起。注意<code class="code">linkIncomingConnections()</code>和<code class="code">linkOutgoingConnections()</code>用于将ForEach节点与内部操作节点链接起来的方法。这些方法用于指定ForEach复合节点内的第一个和最后一个节点。</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e312"></a> 3.2。在您的应用程序中使用流程</h2></div></div></div><p>为了能够从应用程序内部执行流程，您需要做两件事：（1）您需要创建一个包含流程定义的知识库，并且（2）您需要通过创建一个流程来启动流程会话以与流程引擎进行通信并启动流程。</p><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>创建知识库</em></span> ：拥有有效的流程后，您可以将流程添加到知识库中。请注意，除了添加的知识类型以外，这几乎与向知识库中添加规则相同：</p><pre class="programlisting">
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource("MyProcess.rf"),
              ResourceType.DRF );</pre><p>向构建器添加所有知识后（可以添加多个流程，甚至可以添加规则），您可能应该检查该流程（和规则）是否已正确解析，并写出以下任何错误：</p><pre class="programlisting">
KnowledgeBuilderErrors errors = kbuilder.getErrors();
if (errors.size() &gt; 0) {
    for (KnowledgeBuilderError error: errors) {
        System.err.println(error);
    }
    throw new IllegalArgumentException("Could not parse knowledge.");
}</pre><p>接下来，您需要创建包含所有必要流程（和规则）的知识库，如下所示：</p><pre class="programlisting">
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());</pre></li><li><p><span class="emphasis"><em>启动流程</em></span> ：仅当您明确声明应执行流程时，才会执行流程。这是因为您可能会在知识库中定义很多流程，并且引擎无法知道何时启动每个流程。要激活特定进程，您需要通过调用<code class="code">startProcess</code>会话中的方法。例如：</p><pre class="programlisting">
StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
ksession.startProcess("com.sample.MyProcess");</pre><p>的参数<code class="code">startProcess</code>方法表示需要启动的进程的ID。需要将此流程ID指定为流程的属性，单击流程的背景画布时，该属性将显示在“属性视图”中。如果您的流程在执行过程中还需要执行规则，则还需要调用<code class="code">ksession.fireAllRules()</code>确保规则也执行的方法。而已！</p><p>您可以使用以下命令指定其他参数，这些参数用于将输入数据传递给流程<code class="code">startProcess(String processId, Map parameters)</code>方法，它将一组附加参数作为名称/值对。然后，将这些参数作为流程的顶级变量复制到新创建的流程实例。</p><p>您还可以使用</p><pre class="programlisting">
kcontext.getKnowledgeRuntime().startProcess("com.sample.MyProcess");</pre><p>
      </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e360"></a> 3.3。不同节点类型的详细说明</h2></div></div></div><p>Ruleflow过程是一个流程图，其中使用连接来链接不同类型的节点。该过程本身公开以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>ID</em></span> ：进程的唯一ID。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：进程的显示名称。</p></li><li><p><span class="emphasis"><em>版本</em></span> ：进程的版本号。</p></li><li><p><span class="emphasis"><em>Package</em></span> ：定义过程的包（名称空间）。</p></li><li><p><span class="emphasis"><em>变量</em></span> ：可以定义变量以在过程执行期间存储数据。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.data" title="3.4。数据">数据</a></span> ”部分。</p></li><li><p><span class="emphasis"><em>泳道</em></span> ：指定负责执行人工任务的演员。有关详细信息，请参见“ <span class="quote"><a class="link" href="#ch.Human_Tasks" title="第九章人工任务">人工任务</a></span> ”一章。</p></li><li><p><span class="emphasis"><em>异常处理程序</em></span> ：指定过程中发生故障时的行为。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.exceptions" title="3.8。例外情况">例外</a></span> ”部分。</p></li><li><p><span class="emphasis"><em>连接布局</em></span> ：使用连接布局属性指定如何在画布上可视化连接：</p><div class="itemizedlist"><ul><li><p>“手动”始终将您的连接绘制为从起点到终点的直线（可以使用中间的断点）。</p></li><li><p>“最短路径”是相似的，但是它试图绕过它在起点和终点之间可能遇到的任何障碍，以避免线穿过节点。</p></li><li><p>“曼哈顿”仅通过使用水平和垂直线来绘制连接。</p></li></ul></div></li></ul></div><p>
    </p><p>RuleFlow流程支持不同类型的节点：</p><div class="figure"><a id="d0e428"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/ruleflow_nodes.png" align="middle" alt="不同类型的规则流节点"></div></div><p class="title"><b>图3.4。不同类型的规则流节点</b></p></div><p><br class="figure-break">

    </p><div class="orderedlist"><ol type="1"><li><p><span class="strong"><strong>开始</strong></span> ：规则流的开始。规则流应仅具有一个起始节点，该起始节点不能具有传入连接，而应该具有一个传出连接。每当启动RuleFlow流程时，执行将从该节点开始，并自动继续到链接到该起始节点的第一个节点，依此类推。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>触发器</em></span> ：“开始”节点还可以指定其他触发器，这些触发器可用于自动启动流程。示例是“约束”触发器，如果满足给定规则或约束，该触发器将自动启动过程；或者“事件”触发器，如果发出特定事件，则将自动启动过程。</p></li></ul></div></li><li><p><span class="strong"><strong>结束</strong></span> ：规则流的结束。规则流应具有一个或多个End节点。结束节点应具有一个传入连接，并且不能具有传出连接。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>终止</em></span> ：结束节点可以终止于整个过程（默认），也可以终止于路径。如果该过程终止，则取消该规则流中仍处于活动状态（在并行路径上）的所有节点。非终接节点只是某些路径的末端，而其他并行路径仍然继续。</p></li></ul></div></li><li><p><span class="strong"><strong>RuleFlowGroup</strong></span> ：代表一组需要评估的规则。到达节点时将评估规则。RuleFlowGroup节点应具有一个传入连接和一个传出连接。使用以下命令，规则可以成为特定规则流组的一部分<strong class="kw"><code>ruleflow-group</code></strong>标头中的属性。当规则流中到达RuleFlowGroup节点时，引擎将开始执行属于相应Ruleflow组（如果有）的规则。如果此规则流组中没有其他活动规则，则执行将自动继续到下一个节点。这意味着在执行规则流组期间，由于其他规则对事实的更改，可能会将属于当前活动规则流组的新激活添加到议程中。请注意，如果遇到下一个没有活动规则的规则流组，则规则流将立即继续下一个节点。如果规则流组已经处于活动状态，则规则流组将保持活动状态，并且只有在规则流组的所有活动规则均已完成时，执行才会继续。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>RuleFlowGroup</em></span> ：代表此RuleFlowGroup节点的规则集的规则流组的名称。</p></li><li><p><span class="emphasis"><em>计时器</em></span> ：链接到此节点的计时器。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.timers" title="3.9。计时器">计时器</a></span> ”部分。</p></li></ul></div></li><li><p><span class="strong"><strong>拆分</strong></span> ：允许您在规则流中创建分支。拆分节点应具有一个传入连接和两个或多个传出连接。当前支持三种类型的拆分节点：</p><div class="itemizedlist"><ul><li><p>AND表示控制流将同时在所有传出连接中继续。</p></li><li><p>XOR表示将完全选择传出连接之一。通过评估链接到每个传出连接的约束条件来做出决定。使用与规则左侧相同的语法来指定约束。选择具有<span class="emphasis"><em>最低</em></span>优先级数字且评估为true的约束。请注意，您应始终确保至少有一个传出连接在运行时评估为true（如果规则流找不到至少一个传出连接，则规则流将在运行时引发异常）。例如，您可以使用具有<span class="emphasis"><em>高</em></span>优先级数字的始终为真（默认）的连接来指定如果无法采用其他任何连接时应该发生的情况。</p></li><li><p>OR表示选择了条件为true的所有传出连接。条件与XOR拆分类似，但不考虑优先级。请注意，您应确保至少有一个传出连接在运行时评估为true，因为如果规则流无法确定传出连接，则规则流将在运行时引发异常。
             </p></li></ul></div><p>它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>Type</em></span> ：分割节点的类型，即AND，XOR或OR（请参见上文）。</p></li><li><p><span class="emphasis"><em>约束</em></span> ：链接到每个传出连接的约束（在（X）OR拆分的情况下）。</p></li></ul></div></li><li><p><span class="strong"><strong>联接</strong></span> ：允许您同步多个分支。一个加入节点应具有两个或多个传入连接和一个传出连接。当前支持四种类型的拆分：</p><div class="itemizedlist"><ul><li><p>AND表示将等到<span class="emphasis"><em>所有</em></span>传入分支完成后再继续。
            </p></li><li><p>XOR意味着它的传入分支<span class="emphasis"><em>之一</em></span>完成后便会继续。如果它是由多个传入连接触发的，则将为每个触发器触发下一个节点。</p></li><li><p>鉴别器意味着如果它的传入分支之一已完成，它将继续。注册所有其他传入分支的完成，直到所有连接都完成。届时，该节点将被重置，以便它的传入分支之一再次完成时可以再次触发。</p></li><li><p>n-of-m表示如果<span class="emphasis"><em>m个</em></span>传入分支中的<span class="emphasis"><em>n个</em></span>已经完成，则继续执行。变量<span class="emphasis"><em>n</em></span>可以硬编码为固定值，也可以引用包含将要等待的传入分支数的过程变量。</p></li></ul></div><p>它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>类型</em></span> ：Join节点的类型，即AND，XOR或Discriminator（请参见上文）。</p></li><li><p><span class="emphasis"><em>n</em></span> ：要等待的传入连接数（如果是n-of-m联接）。</p></li></ul></div></li><li><p><span class="strong"><strong>EventWait</strong></span> （或<span class="strong"><strong>Milestone</strong></span> ）：表示等待状态。EventWait应该具有一个传入连接和一个传出连接。它指定了一个约束，该约束定义了进程在此状态下应等待多长时间才能继续。例如，订单输入应用程序中的约束可能指定流程应等待，直到在给定的订单中没有发现更多错误为止。使用与规则左侧相同的语法来指定约束。在规则流中到达“等待”节点时，引擎将检查关联的约束。如果约束条件直接评估为true，则流程将立即继续。否则，如果稍后满足约束条件（例如，当事实被插入，更新或从工作存储器中删除时），则流程将继续。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>约束</em></span> ：定义进程何时可以离开此状态并继续。</p></li></ul></div></li><li><p><span class="strong"><strong>SubFlow</strong></span> ：代表从另一个流程中调用另一个流程。子流程节点应具有一个传入连接和一个传出连接。当在规则流中到达SubFlow节点时，引擎将使用给定的ID启动该过程。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>ProcessId</em></span> ：应执行的进程的ID。</p></li><li><p><span class="emphasis"><em>等待完成</em></span> ：如果此属性为true，则只有在该SubFlow进程终止其执行（已完成或中止）的情况下，SubFlow节点才会继续。否则它将在开始子过程后立即继续。</p></li><li><p><span class="emphasis"><em>独立</em></span> ：如果此属性为true，则子流程作为独立流程启动，这意味着如果该流程到达结束节点，则子流程不会终止。否则，活动子流程将在流程终止（或中止）时被取消。</p></li><li><p><span class="emphasis"><em>进入和退出动作</em></span> ：分别在此节点进入或退出时执行的动作。</p></li><li><p><span class="emphasis"><em>参数输入/输出映射</em></span> ：SubFlow节点还可以定义变量的输入和输出映射。在启动过程时，此过程中具有“ in”映射中给定变量名称的变量的值将用作参数（具有关联的参数名称）。子过程完成后，具有“ out”映射中给定变量名称的子过程中变量的值将被复制到该过程的变量中。请注意，只有在“等待完成”设置为true时，才能使用“输出”映射。</p></li><li><p><span class="emphasis"><em>计时器</em></span> ：链接到此节点的计时器。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.timers" title="3.9。计时器">计时器</a></span> ”部分。</p></li></ul></div></li><li><p><span class="strong"><strong>动作</strong></span> ：表示应在此规则流中执行的动作。一个动作节点应具有一个传入连接和一个传出连接。关联的动作指定应执行的动作，用于对动作进行编码的方言（即Java或MVEL）以及实际的动作代码。此代码可以访问任何全局变量，预定义变量<code class="code">drools</code>指一个<code class="code">KnowledgeHelper</code>对象（例如，可以通过调用来检索工作内存<code class="code">drools.getWorkingMemory()</code> ）和变量<code class="code">context</code>引用了<code class="code">ProcessContext</code>对象（例如，可用于访问当前对象<code class="code">ProcessInstance</code>要么<code class="code">NodeInstance</code> ，以及获取和设置变量）。在规则流中到达“动作”节点时，它将执行该动作，然后继续下一个节点。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>动作</em></span> ：与此动作节点关联的动作。</p></li></ul></div></li><li><p><span class="strong"><strong>计时器</strong></span> ：表示可以在给定时间段后触发一次或多次的计时器。计时器节点应具有一个传入连接和一个传出连接。计时器延迟指定计时器在触发第一次之前应等待的时间（以毫秒为单位）。计时器周期指定两个后续触发之间的时间。周期0表示计时器仅应触发一次。在规则流中到达“计时器”节点时，它将启动关联的计时器。如果取消了计时器节点（例如，通过完成或中止该过程），则取消计时器。有关更多信息，请参见“ <span class="quote"><a class="link" href="#sec.timers" title="3.9。计时器">计时器</a></span> ”部分。 -计时器节点包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>计时器延迟</em></span> ：节点在触发第一次之前应等待的延迟（以毫秒为单位）。</p></li><li><p><span class="emphasis"><em>计时器周期</em></span> ：两个后续触发之间的周期（以毫秒为单位）。如果周期为0，则计时器仅应触发一次。</p></li></ul></div></li><li><p><span class="strong"><strong>故障</strong></span> ：“故障”节点可用于发出过程中异常情况的信号。它应该只有一个传入连接，而没有传出连接。在规则流中到达“故障”节点时，它将抛出具有给定名称的故障。该过程将搜索能够处理此类错误的适当的异常处理程序。如果未找到故障处理程序，则流程实例将中止。故障节点包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>FaultName</em></span> ：故障的名称。此名称用于搜索能够处理此类错误的适当的异常处理程序。</p></li><li><p><span class="emphasis"><em>FaultVariable</em></span> ：包含与此故障关联的数据的变量的名称。此数据还将传递给异常处理程序（如果找到了）。</p></li></ul></div></li><li><p><span class="strong"><strong>事件</strong></span> ：事件节点可用于在流程执行期间响应内部或外部事件。一个“事件”节点应该没有传入连接和一个传出连接。它指定了预期的事件类型。只要检测到该类型的事件，就会触发连接到该事件节点的节点。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>EventType</em></span> ：预期的事件类型。</p></li><li><p><span class="emphasis"><em>VariableName</em></span> ：发生此事件时将包含与此事件关联的数据（如果有）的变量的名称。</p></li><li><p><span class="emphasis"><em>范围</em></span> ：一个事件只能用于侦听内部事件，即使用以下方式直接向该流程实例发出信号的事件<code class="code">processInstance.signalEvent(String type, Object data)</code> 。当事件节点定义为外部时，它还将使用以下方法侦听直接发送给流程引擎的外部事件： <code class="code">workingMemory.signalEvent(String type, Object event)</code> 。</p></li></ul></div></li><li><p>人工<span class="strong"><strong>任务</strong></span> ：流程也可能涉及需要由人工执行的任务。人工任务节点表示要由人工演员执行的原子任务。它应该具有一个传入连接和一个传出连接。人工任务节点可与Swimlanes结合使用，以将多个人工任务分配给相似的角色。有关更多详细信息，请参见“ <span class="quote"><a class="link" href="#ch.Human_Tasks" title="第九章人工任务">人工任务</a></span> ”一章。实际上，“人工任务”节点不过是特定类型的工作项节点（“人工任务”类型）。人工任务节点包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>TaskName</em></span> ：人工任务的名称。</p></li><li><p><span class="emphasis"><em>Priority</em></span> ：一个整数，指示人工任务的优先级。</p></li><li><p><span class="emphasis"><em>评论</em></span> ：与人工任务相关的评论。</p></li><li><p><span class="emphasis"><em>ActorId</em></span> ：负责执行人工任务的actor ID。演员ID的列表可以使用逗号（'，'）作为分隔符来指定。</p></li><li><p><span class="emphasis"><em>可跳过</em></span> ：指定是否可以跳过人工任务，即，参与者是否可以决定不执行任务。</p></li><li><p><span class="emphasis"><em>内容</em></span> ：与此任务关联的数据。</p></li><li><p><span class="emphasis"><em>Swimlane</em></span> ：此人工任务节点所属的泳道。通过泳道，可以轻松地将多个人工任务分配给同一演员。有关如何使用泳道的更多详细信息，请参见人工任务一章。</p></li><li><p><span class="emphasis"><em>等待完成</em></span> ：如果此属性为true，则人工任务节点仅在人工任务已终止（例如，通过完成或达到任何其他终端状态）时才继续。否则它将在创建人工任务后立即继续。</p></li><li><p><span class="emphasis"><em>On.entry和on-exit动作</em></span> ：分别在此节点进入和退出时执行的动作。</p></li><li><p><span class="emphasis"><em>参数映射</em></span> ：允许将过程变量的值复制到人工任务的参数。创建人工任务后，将复制值。</p></li><li><p><span class="emphasis"><em>结果映射</em></span> ：允许将人工任务的结果参数值复制到过程变量。完成人工任务后，将复制值。请注意，只有在“等待完成”设置为true时，才能使用结果映射。人工任务具有结果变量“ Result”，其中包含人工角色返回的数据。变量“ ActorId”包含实际执行任务的角色的ID。</p></li><li><p><span class="emphasis"><em>计时器</em></span> ：链接到此节点的计时器。有关详细信息，请参阅“ <span class="quote"><a class="link" href="#sec.timers" title="3.9。计时器">计时器</a></span> ”部分。</p></li></ul></div></li><li><p><span class="strong"><strong>Composite</strong></span> ：Composite节点是可以包含其他节点的节点，因此它充当节点容器。这不仅允许将一部分流嵌入到这样的Composite节点中，而且还可以定义可用于此容器内所有节点的其他变量和异常处理程序。复合节点应具有一个传入连接和一个传出连接。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>StartNodeId</em></span> ：触发该节点时应触发的节点的ID（在此节点容器内）。</p></li><li><p><span class="emphasis"><em>EndNodeId</em></span> ：节点的ID（在此节点容器内），代表此节点中包含的流的结尾。完成此节点后，复合节点也将完成并触发其传出连接。该复合节点内的所有其他执行节点将被取消。</p></li><li><p><span class="emphasis"><em>变量</em></span> ：可以定义其他变量来在执行此节点期间存储数据。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.data" title="3.4。数据">数据</a></span> ”部分。</p></li><li><p><span class="emphasis"><em>异常处理程序</em></span> ：指定此节点容器中发生故障时的行为。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.exceptions" title="3.8。例外情况">例外</a></span> ”部分。</p></li></ul></div></li><li><p><span class="strong"><strong>ForEach</strong></span> ：ForEach节点是一种特殊的复合节点，它允许您多次执行所包含的流，对于集合中的每个元素一次。一个ForEach节点应具有一个传入连接和一个传出连接。ForEach节点在继续之前等待每个集合元素的嵌入式流完成。它包含以下属性：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>StartNodeId</em></span> ：应该为集合中的每个元素触发的节点的ID（在此节点容器内）。</p></li><li><p><span class="emphasis"><em>EndNodeId</em></span> ：节点的ID（在此节点容器内），代表此节点中包含的流的结尾。完成此节点后，还将为当前集合元素完成ForEach节点的执行。如果收集用完，将触发传出连接。该复合节点内的所有其他执行节点将被取消。</p></li><li><p><span class="emphasis"><em>CollectionExpression</em></span> ：变量的名称，该变量表示应迭代的元素的集合。集合变量应该是类型<code class="code">java.util.Collection</code> 。</p></li><li><p><span class="emphasis"><em>VariableName</em></span> ：包含集合中当前元素的变量的名称。这使复合节点内的节点可以访问所选元素。</p></li></ul></div></li><li><p><span class="strong"><strong>WorkItem</strong></span> ：代表应该在此过程中执行的（抽象）工作单元。应该使用WorkItem节点（以声明的方式）表示在流程引擎外部执行的所有工作。预定义了不同类型的工作项，例如，发送电子邮件，记录消息等。用户可以使用唯一名称并通过定义与此类工作相关联的参数（输入）和结果（输出）来定义特定于域的工作项。有关如何在流程中定义和使用工作项的详细说明和说明性示例，请参阅“ <span class="quote"><a class="link" href="#ch.Domain_Specific_Processes" title="Chapter 8. Domain-specific processes">特定</a></span>于<span class="quote"><a class="link" href="#ch.Domain_Specific_Processes" title="第八章特定领域的流程">域的流程</a></span> ”一章。在流程中到达WorkItem节点时，将执行关联的工作项。一个WorkItem节点应具有一个传入连接和一个传出连接。</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</p></li><li><p><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</p></li><li><p><span class="emphasis"><em>等待完成</em></span> ：如果属性“等待完成”为true，则WorkItem节点将仅在创建的工作项已终止（完成或中止）其执行时继续；否则，将继续运行。否则它将在启动工作项后立即继续。</p></li><li><p><span class="emphasis"><em>参数映射</em></span> ：允许将过程变量的值复制到工作项的参数。创建工作项后，将复制值。</p></li><li><p><span class="emphasis"><em>结果映射</em></span> ：允许将工作项的结果参数的值复制到过程变量。每种工作类型都可以定义结果参数，这些参数将（可能）在工作项完成之后返回。结果映射可用于在此过程中将给定结果参数的值复制到给定变量。例如，“ FileFinder”工作项返回结果列表中与给定搜索条件匹配的文件列表。 <code class="code">Files</code> 。然后可以将此文件列表绑定到过程变量以在过程中使用。工作项目完成后，将复制值。请注意，只有在“等待完成”设置为true时，才能使用结果映射。</p></li><li><p><span class="emphasis"><em>进入和退出动作</em></span> ：分别在此节点进入或退出时执行的动作。</p></li><li><p><span class="emphasis"><em>计时器</em></span> ：链接到此节点的计时器。有关详细信息，请参见“ <span class="quote"><a class="link" href="#sec.timers" title="3.9。计时器">计时器</a></span> ”部分。</p></li><li><p><span class="emphasis"><em>附加参数</em></span> ：每种类型的工作项都可以定义与该类型的工作相关的附加参数。例如，“电子邮件”工作项定义了其他参数，例如<code class="code">From</code> ， <code class="code">To</code> ， <code class="code">Subject</code>和<code class="code">Body</code> 。用户可以直接为这些参数提供值，也可以定义参数映射，以将在此过程中给定变量的值复制到给定参数。如果两者都指定，则映射将具有优先级。参数类型<code class="code">String</code>可以使用<code class="code">#{<span class="emphasis"><em>expression</em></span>}</code>在字符串中嵌入一个值。创建工作项时将检索该值，并将替换表达式替换为调用结果<code class="code">toString()</code>在变量上。表达式可以只是变量的名称（在这种情况下，它可以解析为变量的值），但是更高级的MVEL表达式也是可能的，例如， <code class="code">#{person.name.firstname}</code> 。</p></li></ul></div></li></ol></div><p>
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec.data"></a> 3.4。数据</h2></div></div></div><p>虽然流程图着重于指定过程的控制流，但通常也有必要从数据角度看待过程。在整个过程的执行过程中，可以检索，存储，传递和使用数据。</p><p>为了存储运行时数据，您可以在执行过程中使用变量。变量由名称和数据类型定义。这可以是基本数据类型，例如boolean，int或String，也可以是任何类型的Object子类。可以在变量<span class="emphasis"><em>范围内</em></span>定义变量。顶级范围是流程本身的可变范围。可以使用Composite节点定义子范围。子作用域中定义的变量仅可用于该作用域内的节点。</p><p>每当访问变量时，过程都会搜索定义该变量的适当变量范围。允许嵌套可变作用域。节点将始终在其父容器中搜索变量。如果找不到该变量，它将在那个人的父容器中查找，依此类推，直到到达流程实例本身为止。如果找不到该变量，则读访问将产生空值，而写访问将产生错误消息，并且进程将继续执行。</p><p>变量可以通过多种方式使用：</p><div class="itemizedlist"><ul><li>在启动过程时，可以通过提供参数映射来调用过程级别变量来进行调用。 <code class="code">startProcess</code>方法。这些参数将在过程范围内设置为变量。
        </li><li>动作可以直接访问变量，只需将变量名用作参数名即可。
          <pre class="programlisting">
// call method on the process variable "person"
person.setAge(10);</pre>可以通过知识上下文来更改变量的值：<pre class="programlisting">
kcontext.setVariable(variableName, value);</pre></li><li>WorkItem和SubFlow节点可以通过将变量映射到工作项参数之一来传递参数值，方法是使用参数映射或通过使用参数插值将其插值到String参数中。 <code class="code">#{<span class="emphasis"><em>expression</em></span>}</code> 。也可以使用结果映射将WorkItem的结果复制到变量。
        </li><li>其他各种节点也可以访问数据。例如，事件节点可以将与事件关联的数据存储在变量中，异常处理程序可以从特定变量中读取错误数据，等等。请查看不同节点类型的属性以获取更多信息。
        </li></ul></div><p>
    </p><p>最后，流程和规则都可以访问全局变量，即，在规则评估方面被认为是不变的全局定义变量，以及知识会话中的数据。可以使用知识上下文在操作中访问知识会话：</p><pre class="programlisting">
kcontext.getKnowledgeRuntime().insert( new Person(...) );</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1118"></a> 3.5。约束条件</h2></div></div></div><p>约束可以在流程的各个位置使用，例如，在使用OR或XOR决策的Split节点中，或作为EventWait的约束。Drools Flow支持两种类型的约束：</p><div class="itemizedlist"><ul><li><span class="emphasis"><em>代码约束</em></span>是布尔表达式，只要达到它们就直接求值。当前，我们支持两种方言来表达这些代码约束：Java和MVEL。 Java和MVEL代码约束都可以直接访问流程中定义的全局变量和变量。这是有效的Java代码约束的示例， <code class="code">person</code>在过程中是一个变量：<pre class="programlisting">
return person.getAge() &gt; 20;</pre>有效MVEL代码约束的类似示例是：<pre class="programlisting">
return person.age &gt; 20;</pre></li><li><span class="emphasis"><em>规则约束</em></span>等于正常的Drools规则条件。他们使用Drools规则语言语法来表达可能复杂的约束。这些规则可以像其他任何规则一样引用工作内存中的数据。他们还可以直接引用全局变量。以下是有效规则约束的示例：<pre class="programlisting">Person( age &gt; 20 )</pre>这将对工作记忆中20岁以上的人进行测试。</li></ul></div><p>
    </p><p>规则约束不能直接访问流程内部定义的变量。但是，可以通过将流程实例添加到工作内存中并在规则约束中匹配该流程实例，来在规则约束内引用当前流程实例。我们添加了特殊的逻辑以确保变量<code class="code">processInstance</code>类型的<code class="code">WorkflowProcessInstance</code>将仅与当前流程实例匹配，而不与工作内存中的其他流程实例匹配。但是请注意，您有责任自己将流程实例插入会话中，并可能进行更新，例如，使用Java代码或流程中的入场，出场或显式操作。下面的规则约束示例将搜索与该过程的变量“名称”中存储的值同名的人：</p><pre class="programlisting">processInstance : WorkflowProcessInstance()
Person( name == ( processInstance.getVariable("name") ) )
# add more constraints here ...</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1154"></a> 3.6。动作</h2></div></div></div><p>动作可以以不同的方式使用：</p><div class="itemizedlist"><ul><li>在“动作”节点中，</li><li>作为具有多个节点的进入或退出动作，</li><li>指定异常处理程序行为的动作。</li></ul></div><p>
    </p><p>动作可以访问全局变量和为流程定义的变量以及预定义的变量<code class="code">context</code> 。此变量的类型<code class="code">org.drools.runtime.process.ProcessContext</code>并可以用于以下任务：</p><div class="itemizedlist"><ul><li>获取当前节点实例（如果适用）。可以查询节点实例以获取数据，例如其名称和类型。您也可以取消当前节点实例。
        <pre class="programlisting">
NodeInstance node = context.getNodeInstance();
String name = node.getNodeName();</pre></li><li>获取当前流程实例。可以查询流程实例以获取数据（名称，id，processId等），中止或发出内部事件信号。
        <pre class="programlisting">
WorkflowProcessInstance proc = context.getProcessInstance();
proc.signalEvent( type, eventObject );</pre></li><li>获取或设置变量的值。</li><li>通过访问知识运行库，您可以执行诸如启动流程，发出外部事件信号，插入数据等操作。</li></ul></div><p>
    </p><p>Drools当前支持两种方言，Java和MVEL。 Java操作应为有效的Java代码。MVEL操作可以使用业务脚本语言MVEL来表达操作。MVEL接受任何有效的Java代码，但另外还支持对参数的嵌套访问（例如， <code class="code">person.name</code>代替<code class="code">person.getName()</code> ），以及许多其他脚本方面的改进。因此，MVEL表达式对于业务用户而言更为方便。例如，在流程的“ requester”变量中打印出人员姓名的操作将如下所示：</p><pre class="programlisting">
// Java dialect
System.out.println( person.getName() );

//  MVEL dialect
System.out.println( person.name );
    </pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1199"></a> 3.7。大事记</h2></div></div></div><div class="figure"><a id="d0e1202"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/EventProcess.png" align="middle" alt="使用事件的样本过程"></div></div><p class="title"><b>图3.5。使用事件的样本过程</b></p></div><br class="figure-break"><p>在流程执行期间，流程引擎通过请求执行工作项并等待结果来确保根据流程计划执行所有相关任务。但是，流程也可能应响应流程引擎未直接请求的事件。在流程中明确表示这些事件使流程作者可以指定流程应如何应对此类事件。</p><p>事件具有类型以及可能与它们关联的数据。用户可以自由定义自己的事件类型及其关联的数据。</p><p>进程可以使用事件节点指定如何响应事件。事件节点需要指定该节点感兴趣的事件类型。它还可以定义变量的名称，该变量将接收与事件关联的数据。这允许过程中的后续节点访问事件数据并根据该数据采取适当的措施。</p><p>可以通过多种方式将事件信号通知正在运行的流程实例：</p><div class="itemizedlist"><ul><li>内部事件：流程内部的任何动作（例如，动作节点的动作，或某个节点的进入或退出动作）都可以使用诸如以下：<pre class="programlisting">
context.getProcessInstance().signalEvent(type, eventData);</pre></li><li>外部事件：可以使用以下代码从外部向流程实例通知事件：<pre class="programlisting">
processInstance.signalEvent(type, eventData);</pre></li><li>使用事件相关性的外部事件：使用<span class="emphasis"><em>事件相关性</em></span> （基于事件类型），可以使引擎自动确定哪些流程实例可能对事件感兴趣，而不是直接通知流程实例。每当发生此类事件时，都会通知一个包含侦听某种类型外部事件的事件节点的流程实例。要将此类事件通知流程引擎，请编写如下代码：<pre class="programlisting">
workingMemory.signalEvent(type, eventData);</pre></li></ul></div><p>
    </p><p>事件也可以用于启动流程。每当“启动”节点定义特定类型的事件触发器时，每次将这种类型的事件发送给流程引擎时，都会启动一个新的流程实例。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec.exceptions"></a> 3.8。例外情况</h2></div></div></div><div class="figure"><a id="d0e1238"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/FaultProcess.png" align="middle" alt="使用异常处理程序的示例过程"></div></div><p class="title"><b>图3.6。使用异常处理程序的示例过程</b></p></div><br class="figure-break"><p>每当在执行过程中发生异常情况时，就会引发故障以发出此异常的信号。然后，该过程将搜索能够处理此类错误的适当的异常处理程序。</p><p>与事件类似，故障也具有与故障相关的类型以及可能的数据。用户可以自由定义自己的故障类型及其数据。</p><p>故障由故障节点影响，生成给定类型的故障，由故障名称指示。如果“故障”节点指定故障变量，则给定变量的值将与故障关联。</p><p>无论何时创建故障，流程都会搜索能够处理给定类型的故障的适当的异常处理程序。流程和Composite节点都可以定义用于处理错误的异常处理程序。允许嵌套异常处理程序；节点将始终在其父容器中搜索适当的异常处理程序。如果没有找到，它将在那个人的父容器中查找，依此类推，直到到达流程实例本身为止。如果找不到异常处理程序，则流程实例将中止，从而取消了流程内的所有节点。</p><p>异常处理程序还可以指定故障变量。每当选择异常处理程序来处理故障时，与故障相关的数据（如果有）将被复制到此变量。这允许过程中的后续“动作”节点访问故障数据并根据该数据采取适当的措施。</p><p>异常处理程序需要定义一个动作，该动作指定如何响应给定的错误。在大多数情况下，对给定故障做出反应所需的行为无法用一种动作来表达。因此，建议让异常处理程序使用以下命令发出特定类型的事件（在本例中为“故障”）的信号</p><pre class="programlisting">
context.getProcessInstance().signalEvent("FaultType", context.getVariable("FaultVariable");</pre><p>
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec.timers"></a> 3.9。计时器</h2></div></div></div><p>计时器会在触发之前等待预定义的时间，一次或重复。它们可用于指定时间监督，或在一定时间段后触发特定逻辑，或定期重复执行某些操作。</p><p>计时器节点设置有延迟和周期。延迟指定了节点激活后第一次触发计时器之前要等待的时间（以毫秒为单位）。该时间段定义了后续触发激活之间的时间。周期为0会导致一次触发计时器。</p><p>计时器服务负责确保在适当的时间触发计时器。计时器也可以取消，这意味着计时器将不再被触发。</p><p>计时器可以在流程中以两种方式使用：</p><div class="itemizedlist"><ul><li>可以将“计时器”节点添加到流程中。它的激活将启动计时器，并且其触发器将一次或重复地激活Timer节点的后继者。这意味着具有正周期的计时器的传出连接将被多次触发。取消计时器节点也会取消关联的计时器，此后将不再发生触发。</li><li>计时器可能与基于事件的节点（如WorkItem，SubFlow等）相关联。每当节点变为活动状态时，都会激活与该节点关联的计时器。每当计时器触发时，就会执行关联的操作。例如，当任务执行时间过长时，您可以使用它定期发送通知，或者在时间监管到期时发出事件或错误信号。拥有计时器的节点完成后，计时器将自动取消。</li></ul></div><p>
    </p><p>默认情况下，Drools引擎是被动组件，这意味着只有在您告知时，它才会开始处理。通常，您首先插入必要的数据，然后告诉引擎开始处理。在被动模式下，已触发的计时器将被放置在操作队列中。这意味着，如果引擎仍在运行，它将自动执行，或者它将延迟直到用户告知引擎开始执行（通过调用<code class="code">fireAllRules()</code> ）。</p><p>当使用计时器时，让Drools引擎作为活动组件运行通常是有意义的，因此它会在动作可用时执行动作，而无需等到用户告诉它恢复执行。因此，计时器一触发就会生效。要使引擎连续执行所有操作，您必须调用方法<code class="code">fireUntilHalt()</code> ，然后发动机运转直到<code class="code">halt()</code>叫做。请注意，您应该致电<code class="code">fireUntilHalt()</code>在单独的线程中，因为只有在引擎被用户或某些逻辑调用停止后，它才会返回<code class="code">halt()</code>在会议上。以下代码段显示了如何执行此操作。</p><pre class="programlisting">
new Thread(new Runnable() {
  public void run() {
    ksession.fireUntilHalt();
  }
}).start();

// starting a new process instance
ksession.startProcess("...");
// any timer that triggers will now be executed automatically</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1297"></a> 3.10。将规则分配给规则流组</h2></div></div></div><p>Drools已经提供了一些功能来定义规则执行的顺序，例如显着性，激活组等。当处理潜在的许多大型规则集时，管理评估规则的顺序可能会变得很复杂。Ruleflow允许您使用流程图指定评估规则集的顺序。这使您可以定义应顺序或并行评估的规则集，以指定应评估规则集的条件。本章包含一些规则流示例。</p><p>规则流是规则引擎需要采取的一系列步骤的图形化描述，其中顺序很重要。规则流还可以处理条件分支，并行性和同步化。</p><p>要使用规则流描述规则评估的顺序，您应该首先使用<strong class="kw"><code>ruleflow-group</code></strong>规则属性（GUI中的“选项”）。然后，您应通过指定评估规则流组的顺序，创建一个规则流图（流程图），以图形方式描述规则的考虑顺序。</p><pre class="programlisting">
rule 'YourRule'
    ruleflow-group 'group1'
when
    ...
then
    ...
end</pre><p>该规则属于名为“ group1”的规则流组。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1313"></a> 3.11。一个简单的规则流</h2></div></div></div><div class="figure"><a id="d0e1316"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/RuleFlowSimple.png" align="middle" alt="规则流"></div></div><p class="title"><b>图3.7。规则流</b></p></div><br class="figure-break"><p>上面的规则流指定必须在执行“处理订单”组中的规则之前执行“检查订单”组中的规则。这意味着，首先将仅考虑标记为规则流组为“检查订单”的规则，然后，仅当不再有这些规则时，才考虑“流程订单”的规则。就是这样您可以通过使用显着性来达到类似的结果，但这很难维护，并使时间关系隐含在规则或议程组中。但是，使用规则流在规则结构顶部的一层中使处理的顺序明确，从而使管理更复杂的情况变得更加容易。</p><p>在实践中，如果您使用规则流，则除了设置简单的组顺序以进行处理外，您更有可能做更多的事情。您将使用“拆分”和“联接”节点为处理分支建模，并通过连接定义控制流，从“开始”到“规则流”组，再到“拆分”，再到更多的组，“联接”，依此类推。所有这些都是在grphic编辑器中完成的。</p><div class="figure"><a id="d0e1326"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Flow/RFComplex.png" align="middle" width="100%" alt="复杂规则流"></td></tr></tbody></table></div></div><p class="title"><b>图3.8。复杂规则流</b></p></div><br class="figure-break"><p>上面的流程是一个更复杂的示例，代表处理保险索赔的规则流程。最初，处理索赔数据验证规则，检查数据完整性，一致性和完整性。接下来，在拆分节点中，基于基于索赔值的条件进行决策。处理将移至“自动解决”组，或移至另一个Split节点，该节点检查事件中是否有致命事件。如果是这样，它将确定特定于死亡的规则的“常规”规则是否应生效，并需要进行更多处理。根据一些条件，许多不同的控制流程是可能的。请注意，所有规则都可以放在一个程序包中，控制流定义与实际规则分开。</p><div class="figure"><a id="d0e1334"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Flow/RFSplitType.png" align="middle" width="100%" alt="分割类型"></td></tr></tbody></table></div></div><p class="title"><b>图3.9。分割类型</b></p></div><br class="figure-break"><p>要编辑Split节点，请单击该节点，这将为您显示一个属性面板，如上所示。然后，您必须选择类型：AND，OR和XOR。如果选择“或”，则可能会发生拆分的任何“输出”，因此处理可以沿两条或更多条路径并行进行。如果选择XOR，则仅选择一个路径。</p><p>如果选择“或”或“异或”，则“约束”行的右侧将带有一个方形按钮。单击此按钮可打开约束编辑器，您可以在其中设置条件以决定遵循哪个输出路径。</p><div class="figure"><a id="d0e1344"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/RFEditConstraints.png" align="middle" alt="编辑约束"></div></div><p class="title"><b>图3.10。编辑约束</b></p></div><br class="figure-break"><p>选择要为其设置约束的输出路径（例如，自动沉降），然后您将看到以下约束编辑器：</p><div class="figure"><a id="d0e1352"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-Flow/RFConstraintEditor.png" align="middle" alt="约束编辑器"></div></div><p class="title"><b>图3.11。约束编辑器</b></p></div><br class="figure-break"><p>这是一个文本编辑器，在其中输入了约束（类似于规则的条件部分）。这些约束作用于工作存储器中的事实。在上面的示例中，检查了价值小于250的索赔。如果满足此条件，则将遵循关联的路径。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1360"></a> 3.12。使用Drools 4.x RuleFlow流程</h2></div></div></div><p>Drools4中用于存储RuleFlow流程的XML格式是使用XStream自动生成的。结果，它很难被人类读者阅读，并且难以维护和扩展。已创建新的Drools Flow XML格式来简化此过程。但是，这意味着默认情况下，旧的RuleFlow进程不能简单地在Drools5引擎上执行。</p><p>但是，我们确实提供了规则流迁移器，使您可以将旧的.rf文件转换为新格式。它使用XSLT转换来基于旧内容生成新的XML。从Drools4.x升级到Drools5.x时，可以使用此类手动将旧过程手动转换为新格式。但是，您也可以让KnowledgeBuilder在将流程加载到知识库中后自动将其升级为新格式。尽管每次将过程加载到知识库时都需要进行转换，但它确实支持更无缝的升级。要实施此自动升级，您需要将“ drools.ruleflow.port”系统属性设置为“ true”，例如，通过添加<code class="code">-Ddrools.ruleflow.port=true</code>启动应用程序时，或通过调用<code class="code">System.setProperty("drools.ruleflow.port", "true")</code> 。</p><p>Drools Eclipse插件还会自动检测是否打开了旧的RuleFlow文件。届时，它将自动执行转换并在图形编辑器中显示结果。然后，您需要将此结果保存在新文件中或覆盖旧文件，以将旧进程保留为新格式。请注意，该插件不支持旧的Drools4.x格式的编辑和保存过程。</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1375"></a>第四章Drools Flow API</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1378">4.1。知识库</a></span></dt><dt><span class="section"><a href="#d0e1387">4.2。届会</a></span></dt><dt><span class="section"><a href="#d0e1401">4.3。大事记</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1378"></a> 4.1。知识库</h2></div></div></div><p>我们基于知识的API使您可以首先创建一个包含所有必要知识的知识库。这包括所有相关的流程定义和规则等其他知识类型。以下代码段显示了如何创建一个仅包含一个流程定义的知识库，如何使用知识库生成器添加资源，检查错误并最终创建知识库。</p><pre class="programlisting">
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add(ResourceFactory.newClassPathResource("ruleflow.rf"), ResourceType.DRF);
KnowledgeBuilderErrors errors = kbuilder.getErrors();
if (errors.size() &gt; 0) {
  for (KnowledgeBuilderError error: errors) {
    System.err.println(error);
  }
  throw new IllegalArgumentException("Could not parse knowledge.");
}
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());
</pre><p>请注意，基于知识的API允许用户以几乎相同的方式将不同类型的资源（例如规则和流程）添加到同一知识库中。这使知道如何使用Drools Flow的用户几乎可以立即开始使用Drools Fusion，甚至可以集成这些不同类型的知识。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1387"></a> 4.2。届会</h2></div></div></div><p>接下来，您应该创建一个会话以与引擎进行交互。同样，API是基于知识的，支持不同类型的知识，每种知识类型都有特定的扩展名。下面的代码片段显示了基于较早创建的知识库创建会话并启动一个过程是多么容易。</p><pre class="programlisting">
StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
ProcessInstance processInstance = ksession.startProcess("com.sample.ruleflow");
</pre><p>的<code class="code">ProcessRuntime</code>界面定义了所有与流程进行交互的会话方法，如下所示。请查阅Javadocs以获得每种方法的详细说明。</p><pre class="programlisting">
ProcessInstance startProcess(String processId);
ProcessInstance startProcess(String processId, Map&lt;String, Object&gt; parameters);
void signalEvent(String type, Object event);
Collection&lt;ProcessInstance&gt; getProcessInstances();
ProcessInstance getProcessInstance(long id);
WorkItemManager getWorkItemManager();
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1401"></a> 4.3。大事记</h2></div></div></div><p>有状态知识会话和无状态知识会话都提供了注册和删除侦听器的方法。 <code class="code">ProcessEventListener</code>对象可用于侦听与流程相关的事件，例如启动或完成流程以及进入和离开节点。下面，不同的方法<code class="code">ProcessEventListener</code>显示。事件对象提供对相关信息的访问，例如链接到事件的流程实例和节点实例。</p><pre class="programlisting">
public interface ProcessEventListener {

  void beforeProcessStarted( ProcessStartedEvent event );
  void afterProcessStarted( ProcessStartedEvent event );
  void beforeProcessCompleted( ProcessCompletedEvent event );
  void afterProcessCompleted( ProcessCompletedEvent event );
  void beforeNodeTriggered( ProcessNodeTriggeredEvent event );
  void afterNodeTriggered( ProcessNodeTriggeredEvent event );
  void beforeNodeLeft( ProcessNodeLeftEvent event );
  void afterNodeLeft( ProcessNodeLeftEvent event );

}</pre><p>可以基于这些进程侦听器提供的信息来创建审核日志。我们提供各种默认的记录器实现：</p><div class="orderedlist"><ol type="1"><li>控制台记录器：该记录器将所有事件写到控制台。</li><li>文件记录器：该记录器使用XML表示将所有事件写出到文件中。然后，可以在IDE中使用此日志文件来生成执行过程中发生的事件的基于树的可视化。</li><li>线程文件记录器：因为文件记录器仅在关闭记录器或记录器中的事件数达到预定义级别时才将事件写到磁盘，所以在运行时调试进程时不能使用它。线程文件记录器在指定的时间间隔后将事件写入文件，从而可以在调试过程中使用记录器实时可视化进度。
      </li></ol></div><p>
    </p><p>的<code class="code">KnowledgeRuntimeLoggerFactory</code>允许您将记录器添加到会话中，如下所示。创建控制台记录器时，必须将需要为其创建记录器的Knowledge Session作为参数传递。文件记录器还需要创建日志文件的名称，而线程文件记录器需要保存事件的间隔（以毫秒为单位）。</p><pre class="programlisting">
KnowledgeRuntimeLogger logger =
    KnowledgeRuntimeLoggerFactory.newFileLogger( ksession, "test" );
// add invocations to the process engine here,
// e.g. ksession.startProcess(processId);
...
logger.close();</pre><p>可以使用Drools Eclipse插件中的Audit View在Eclipse中打开日志文件，其中事件以树形显示。在事件前后之间发生的事件将显示为该事件的子级。下面的屏幕快照显示了一个简单的示例，其中启动了一个过程，从而激活了Start节点，一个Action节点和一个End节点，此后该过程完成了。</p><div class="mediaobject" align="center"><img src="./images/Chapter-API/AuditView.png" align="middle"></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1436"></a>第五章坚持不懈</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1441">5.1。运行时状态</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1448">5.1.1。二进制余辉</a></span></dt><dt><span class="section"><a href="#d0e1453">5.1.2。安全点</a></span></dt><dt><span class="section"><a href="#d0e1458">5.1.3。配置持久性</a></span></dt><dt><span class="section"><a href="#d0e1539">5.1.4。交易次数</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1548">5.2。工艺定义</a></span></dt><dt><span class="section"><a href="#d0e1555">5.3。历史记录</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1562">5.3.1。在数据库中存储流程事件</a></span></dt></dl></dd></dl></div><p>Drools Flow允许持久存储某些信息，即流程运行时状态，流程定义和历史信息。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1441"></a> 5.1。运行时状态</h2></div></div></div><p>每当启动流程时，都会创建一个流程实例，该实例表示该特定上下文中流程的执行。例如，当执行指定如何处理销售订单的流程时，将为每个销售请求创建一个流程实例。流程实例表示该特定上下文中的当前执行状态，并包含与该流程实例相关的所有信息。请注意，它仅包含在以后的某个时间继续执行该流程实例所需的最小运行时状态，但如果该流程实例中不再需要该流程实例的历史信息，则它不包含该信息。</p><p>可以使执行过程的运行时状态持久化，例如在数据库中。这样可以在发生意外故障的情况下恢复所有正在运行的进程的执行状态，或者暂时从内存中删除正在运行的实例并在以后的某个时间还原它们。Drools Flow允许您插入不同的持久性策略。默认情况下，如果您不配置流程引擎，则不会使流程实例具有持久性。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1448"></a> 5.1.1。二进制余辉</h3></div></div></div><p>Drools Flow提供了一种二进制持久性机制，使您可以将流程实例的状态另存为二进制数据集。这样，所有正在运行的流程实例的状态始终可以存储在持久位置中。请注意，这些二进制数据集通常相对较小，因为它们仅包含流程实例的最小执行状态。对于一个简单的流程实例，它通常包含一个或几个节点实例，即当前正在执行的任何节点，并可能包含一些变量值。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1453"></a> 5.1.2。安全点</h3></div></div></div><p>流程实例的状态在流程引擎执行期间存储在所谓的“安全点”。每当执行流程实例时，在其启动或从等待状态继续执行之后，引擎都会继续运行，直到无法执行更多操作为止。那时，引擎已达到下一个安全状态，并且流程实例和所有其他可能受影响的流程实例的状态被永久存储。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1458"></a> 5.1.3。配置持久性</h3></div></div></div><p>默认情况下，引擎不会持久保存运行时数据。但是，通过添加配置文件和必要的依赖关系，将引擎配置为执行此操作非常简单。持久性本身基于Java持久性API（JPA），因此可以与多种持久性机制一起使用。默认情况下，我们使用的是Hibernate，但可以随意使用其他方法。下面使用H2数据库存储数据，但是您也可以为此选择自己的替代方法。</p><p>首先，您需要向类路径添加必要的依赖项。如果您使用的是Eclipse IDE，则可以通过将jar文件添加到Drools运行时目录（请参阅“ <span class="quote"><a class="link" href="#ch.Drools_Eclipse_IDE_Features" title="第十一章Drools Eclipse IDE功能">Drools Eclipse IDE功能</a></span> ”一章），或通过将这些依赖项手动添加到项目中来实现。首先，您需要jar文件<code class="filename">drools-persistence-jpa.jar</code> ，因为其中包含用于在必要时保存运行时状态的代码。接下来，您还需要各种其他依赖项，具体取决于您所使用的持久性解决方案和数据库。对于将Hibernate作为JPA持久性提供程序，H2数据库和Bitronix（用于基于JTA的事务管理）的默认组合，需要以下依赖项列表：</p><div class="orderedlist"><ol type="1"><li>drools-persistence-jpa（org.drools）</li><li>persistence-api-1.0.jar（javax.persistence）</li><li>hibernate-entitymanager-3.4.0。GA.jar（org.hibernate）</li><li>休眠注释3.4.0。GA.jar（org.hibernate）</li><li>hibernate-commons-annotations-3.1.0。GA.jar（org.hibernate）</li><li>休眠核心-3.3.0。SP1.jar（org.hibernate）</li><li>dom4j-1.6.1.jar（dom4j）</li><li>jta-1.0.1B.jar（javax.transaction）</li><li>btm-1.3.2.jar（org.codehaus.btm）</li><li>javassist-3.4。GA.jar（javassist）</li><li>slf4j-api-1.5.2.jar（org.slf4j）</li><li>slf4j-jdk14-1.5.2.jar（org.slf4j）</li><li>h2-1.0.77.jar（com.h2数据库）</li><li>commons-collections-3.2.jar（公共收藏）</li></ol></div><p>
    </p><p>接下来，您需要配置Drools引擎以在必要时保存引擎的状态。最简单的方法是使用<code class="code">JPAKnowledgeService</code>基于知识库，知识会话配置（如果需要）和环境来创建您的知识会话。该环境需要包含对您的Entity Manager Factory的引用。</p><pre class="programlisting">
// create the entity manager factory and register it in the environment
EntityManagerFactory emf =
    Persistence.createEntityManagerFactory( "org.drools.persistence.jpa" );
Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY, emf );

// create a new knowledge session that uses JPA to store the runtime state
StatefulKnowledgeSession ksession =
    JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );
int sessionId = ksession.getId();

// invoke methods on your method here
ksession.startProcess( "MyProcess" );
ksession.dispose();</pre><p>您也可以<code class="code">JPAKnowledgeService</code>根据特定的会话ID重新创建会话：</p><pre class="programlisting">
// recreate the session from database using the sessionId
ksession = JPAKnowledgeService.loadStatefulKnowledgeSession( sessionId, kbase, null, env );</pre><p>请注意，我们仅保存在稍后的某个时刻继续执行流程实例所需的最小状态。例如，这意味着，如果该信息不再相关，或者已经完成或中止的流程实例已从数据库中删除，则该信息不包含有关已执行节点的信息。如果要搜索与历史记录有关的信息，则应使用历史记录日志，如后面所述。</p><p>默认， <code class="filename">drools-persistence-jpa.jar</code>包含一个配置文件，该文件将JPA配置为使用Hibernate和H2数据库，称为<code class="filename">persistence.xml</code>在META-INF目录中，如下所示。如果要更改默认设置，则需要添加自己的默认设置<code class="filename">persistence.xml</code>在您的类路径中，在默认默认值之前<code class="filename">drools-persistence-jpa.jar</code> 。有关如何执行此操作的更多信息，请参考JPA和Hibernate文档。</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;persistence
  version="1.0"
  xsi:schemaLocation=
    "http://java.sun.com/xml/ns/persistence
     http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd
     http://java.sun.com/xml/ns/persistence/orm
     http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
  xmlns:orm="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://java.sun.com/xml/ns/persistence"&gt;

  &lt;persistence-unit name="org.drools.persistence.jpa"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;jta-data-source&gt;jdbc/processInstanceDS&lt;/jta-data-source&gt;
    &lt;class&gt;org.drools.persistence.session.SessionInfo&lt;/class&gt;
    &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
    &lt;class&gt;org.drools.persistence.processinstance.ProcessInstanceEventInfo&lt;/class&gt;
    &lt;class&gt;org.drools.persistence.processinstance.WorkItemInfo&lt;/class&gt;

    &lt;properties&gt;
      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
      &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
      &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;
      &lt;property name="hibernate.show_sql" value="true"/&gt;
      &lt;property name="hibernate.transaction.manager_lookup_class"
                value="org.hibernate.transaction.BTMTransactionManagerLookup"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><p>此配置文件引用名为“ jdbc / processInstanceDS”的数据源。以下Java片段可用于设置此数据源，我们在其中使用基于文件的H2数据库。</p><pre class="programlisting">
PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName("jdbc/processInstanceDS");
ds.setClassName("org.h2.jdbcx.JdbcDataSource");
ds.setMaxPoolSize(3);
ds.setAllowLocalTransactions(true);
ds.getDriverProperties().put("user", "sa");
ds.getDriverProperties().put("password", "sasa");
ds.getDriverProperties().put("URL", "jdbc:h2:file:/NotBackedUp/data/process-instance-db");
ds.init();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1539"></a> 5.1.4。交易次数</h3></div></div></div><p>只要您不在应用程序内部提供事务边界，引擎就会在单独的事务中自动执行引擎上的每个方法调用。如果此行为可以接受，则您无需执行其他任何操作。但是，您也可以自己指定事务边界。例如，这使您可以将多个命令组合到一个事务中。</p><p>使用用户定义的事务之前，需要在环境中注册事务管理器。以下示例代码使用Bitronix事务管理器。接下来，我们使用Java事务API（JTA）来指定事务边界，如下所示：</p><pre class="programlisting">
// create the entity manager factory and register it in the environment
EntityManagerFactory emf =
    Persistence.createEntityManagerFactory( "org.drools.persistence.jpa" );
Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY, emf );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );

// create a new knowledge session that uses JPA to store the runtime state
StatefulKnowledgeSession ksession =
    JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );

// start the transaction
UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();

// perform multiple commands inside one transaction
ksession.insert( new Person( "John Doe" ) );
ksession.startProcess( "MyProcess" );
ksession.fireAllRules();

// commit the transaction
ut.commit();</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1548"></a> 5.2。工艺定义</h2></div></div></div><p>流程定义文件通常以XML格式编写。这些文件可以在开发过程中轻松存储在文件系统中。但是，每当您要使知识可以供生产中的一个或多个引擎访问时，我们建议您使用一个知识库（在逻辑上）将您的知识集中在一个或多个知识库中。</p><p>Guvnor是一个完全提供此目的的子项目。它由一个用于存储各种知识的存储库组成，不仅可以存储过程定义，还可以存储规则，对象模型等。它允许使用WebDAV或通过使用知识代理轻松地检索此知识，该知识代理在创建数据库时会自动从Guvnor下载信息知识库，并提供一个Web应用程序，允许业务用户查看并可能更新知识库中的信息。请查看Drools Guvnor文档，以获取有关如何执行此操作的更多信息。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1555"></a> 5.3。历史记录</h2></div></div></div><p>在许多情况下，（如有必要）存储有关流程实例执行的信息非常有用（如果不是必要的话），以便以后可以使用此信息，例如，验证已为特定流程实例执行了哪些操作，或者监视和执行分析特定过程的效率。将历史信息存储在运行时数据库中通常不是一个好主意，因为这会导致运行时数据不断增长，并且监视和分析查询可能会影响运行时引擎的性能。这就是为什么有关流程实例执行的历史信息要分开存储的原因。</p><p>该执行信息的历史日志是根据流程引擎在执行过程中生成的事件创建的。Drools运行时引擎提供了一种通用机制来侦听各种事件。可以从这些事件中轻松提取必要的信息并使其持久化，例如在数据库中。过滤器只能用于存储您发现相关的信息。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1562"></a> 5.3.1。在数据库中存储流程事件</h3></div></div></div><p>drools-bam模块包含一个事件侦听器，该事件侦听器使用Hibernate将与进程相关的信息存储在数据库中。该数据库包含两个表，一个表用于流程实例信息，一个表用于节点实例信息（请参见下图）：</p><div class="orderedlist"><ol type="1"><li><span class="emphasis"><em>ProcessInstanceLog：</em></span>它列出了所有流程实例的流程实例ID，流程（定义）ID，开始日期和（如果适用）结束日期。
        </li><li><span class="emphasis"><em>NodeInstanceLog：</em></span>此表包含有关每个流程实例中实际执行了哪些节点的更多详细信息。每当节点实例从其传入连接之一进入或通过其传出连接之一退出时，该信息就会存储在此表中。为此，它存储正在执行的流程实例ID和流程实例的流程ID，以及所讨论的节点实例的节点实例ID和对应的节点ID（在流程定义中）。最后，事件的类型（0 =进入，1 =退出）以及事件的日期也被存储。
        </li></ol></div><p>
      </p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Persistence/audit_db.png" align="middle" width="100%"></td></tr></tbody></table></div><p>要将过程历史信息记录在这样的数据库中，您需要像这样在会话（或工作内存）上注册记录器：</p><pre class="programlisting">
StatefulKnowledgeSession ksession = ...;
WorkingMemoryDbLogger logger = new WorkingMemoryDbLogger(ksession);

// invoke methods one your session here

logger.dispose();</pre><p>请注意，此记录器与任何其他审核记录器一样，这意味着您可以通过调用方法来添加一个或多个过滤器<code class="code">addFilter</code> d确保仅相关信息存储在数据库中。只有所有过滤器都接受的信息才会显示在数据库中。当不再需要记录器时，应将其处置。</p><p>要指定应在其中存储信息的数据库，请修改文件<code class="filename">hibernate.cfg.xml</code>文件。默认情况下，它使用内存驻留数据库（H2）。如果您不知道如何执行，请查阅Hibernate文档。</p><p>从为一个特定流程实例创建历史日志到分析特定流程所有实例的性能，这些信息都可以轻松地查询和用于许多不同的用例中。类<code class="code">ProcessInstanceDbLog</code> （在包装中<code class="code">org.drools.process.audit</code> ）显示了一些有关如何检索所有流程实例，一个特定流程实例（按ID），一个特定流程的所有流程实例，特定流程实例的所有节点实例等的示例。当然，您可以轻松地创建自己的Hibernate查询，或直接访问数据库中的信息。</p><p>默认情况下，审核记录器使用在启动时重新创建的H2内存驻留数据库。您可以通过包含自己的配置文件来更改此默认设置<code class="filename">hibernate.cfg.xml</code> 。例如，这使您可以更改基础数据库等。有关如何执行此操作的更多信息，请参见Hibernate文档。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1607"></a>第六章流口水流程模型</h2></div></div></div><p></p><div class="mediaobject" align="center"><img src="./images/Chapter-ProcessModel/ProcessModel.png" align="middle"></div><div class="mediaobject" align="center"><img src="./images/Chapter-ProcessModel/ProcessInstanceModel.png" align="middle"></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1617"></a>第7章。规则与程序</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1622">7.1。为什么在流程中使用规则？</a></span></dt><dt><span class="section"><a href="#d0e1655">7.2。为什么在单个引擎中集成规则和流程？</a></span></dt><dt><span class="section"><a href="#d0e1679">7.3。方法</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1693">7.3.1。讲授关于流程的规则引擎</a></span></dt><dt><span class="section"><a href="#d0e1698">7.3.2。控制反转</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1705">7.4。例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1716">7.4.1。评估过程中的一组规则</a></span></dt><dt><span class="section"><a href="#d0e1735">7.4.2。使用规则评估约束</a></span></dt><dt><span class="section"><a href="#d0e1743">7.4.3。分配规则</a></span></dt><dt><span class="section"><a href="#d0e1752">7.4.4。使用规则描述特殊情况</a></span></dt><dt><span class="section"><a href="#d0e1757">7.4.5。使用规则模块化问题</a></span></dt><dt><span class="section"><a href="#d0e1762">7.4.6。动态更改流程行为的规则</a></span></dt><dt><span class="section"><a href="#d0e1769">7.4.7。集成工具</a></span></dt><dt><span class="section"><a href="#d0e1781">7.4.8。特定领域的规则和流程</a></span></dt></dl></dd></dl></div><p>Drools Flow是一个工作流和流程引擎，允许对流程和规则进行高级集成。本章讨论规则和流程的集成，范围从简单到高级方案。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1622"></a> 7.1。为什么在流程中使用规则？</h2></div></div></div><p>仅依靠流程结构（例如节点和连接）来描述应用程序的业务逻辑的工作流语言往往非常复杂。尽管这些工作流结构非常适合描述应用程序的总体控制流程，但是描述复杂的逻辑和特殊情况可能非常困难。因此，可执行过程往往变得非常复杂。我们认为，通过扩展支持声明性规则的流程引擎以及这些常规流程构造，可以控制这种复杂性。</p><div class="orderedlist"><ol type="1"><li><p>简便性：使用一组规则通常更容易指定复杂的决策。规则可以使用其高级约束语言更轻松地确定复杂的业务逻辑。可以组合多个规则，每个规则描述业务逻辑的一部分。</p></li><li><p>敏捷性：规则和流程可以有单独的生命周期。这意味着我们可以更改描述某些关键决策点的规则，而不必更改流程本身。可以添加，删除或修改规则，以根据不断变化的需求和环境微调流程的行为。</p></li><li><p>不同的范围：规则可以在流程之间或外部流程中重复使用。因此，您的业务逻辑未锁定在流程中。</p></li><li><p>声明性：专注于描述“什么”而不是“如何”。</p></li><li><p>粒度：编写处理特定情况的简单规则很容易。过程更适合描述总体控制流程，但如果它们也需要描述很多特殊情况，则往往变得非常复杂。</p></li><li><p>以数据为中心：规则可以轻松处理大型数据集。</p></li><li><p>性能：优化了规则评估。</p></li><li><p>高级条件和动作语言：规则语言支持高级功能，例如自定义函数，集合，条件元素（包括量词）等。</p></li><li><p>高级：通过使用DSL，业务编辑器，决策表和决策树，可以以业务用户可以理解（甚至可能修改）的方式描述您的业务逻辑。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1655"></a> 7.2。为什么在单个引擎中集成规则和流程？</h2></div></div></div><p>Drools Flow在一个软件产品中结合了流程和规则引擎。与尝试松散耦合现有流程和规则产品相比，这提供了多个优势。</p><div class="orderedlist"><ol type="1"><li><p>简便性：最终用户更容易组合规则和流程。</p></li><li><p>封装：有时，流程和规则之间的紧密集成是有益的。</p></li><li><p>性能：无需不必要的数据传递，转换或同步</p></li><li><p>学习曲线：更容易学习一种产品。</p></li><li><p>可管理性：易于管理一种产品，规则和流程可能是更大的知识库中的类似人工制品。</p></li><li><p>功能集成：我们提供集成的IDE，审核日志，基于Web的管理平台，存储库，调试等。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1679"></a> 7.3。方法</h2></div></div></div><p>工作流语言使用流程图描述了执行活动的顺序。流程引擎负责根据正在执行的流程的当前状态选择应执行哪些活动。另一方面，规则由一组条件组成，这些条件描述了一条规则何时适用以及在满足条件时执行的操作。然后，规则引擎负责评估和执行规则。它根据应用程序的当前状态决定需要执行哪些规则。</p><div class="mediaobject" align="center"><img src="./images/Chapter-RulesAndProcesses/rulesAndProcesses.bmp" align="middle"></div><p>工作流过程非常擅长描述（可能是长时间运行的）应用程序的总体控制流。但是，用于定义复杂业务决策，处理许多特殊情况以及需要响应各种外部事件的流程的确确实变得非常复杂。规则非常擅长描述复杂的决策以及有关大量数据或事件的推理。但是，使用规则定义长时间运行的流程并非易事。</p><p>过去，用户被迫在使用流程或规则引擎定义业务逻辑之间进行选择。需要对大量数据进行复杂推理的问题使用规则引擎，而希望专注于描述其流程的控制流的用户被迫使用流程引擎。但是，当今的企业可能希望将流程和规则结合起来，以便能够以最适合其需求的格式定义其所有业务逻辑。</p><p>基本上，规则和流程引擎都将通过查看其知识库（分别是一组规则或流程）和应用程序的当前已知状态（工作内存中的数据）来推导需要执行的下一步。或正在执行的流程实例的状态）。如果要集成规则和流程，我们需要一个引擎，可以考虑流程和规则中定义的逻辑来决定下一步。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1693"></a> 7.3.1。讲授关于流程的规则引擎</h3></div></div></div><p>扩展流程引擎以同时考虑规则非常困难（并且可能效率也很低）。流程引擎将需要检查可能需要在每个步骤执行的规则，并且必须使规则引擎使用的数据保持最新。但是，“教”有关流程的规则引擎并不难。如果流程的当前状态也作为规则引擎所考虑的工作内存数据的一部分插入，并且我们指示规则引擎如何导出正在执行的流程的后续步骤，则规则引擎将能够导出下一步将规则和流程共同考虑在内。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1698"></a> 7.3.2。控制反转</h3></div></div></div><p>从过程的角度看，这意味着存在控制反转。普通的流程引擎会行使完全控制权，并根据流程实例的当前状态得出后续步骤。如果需要，它可以联系外部服务以检索其他信息，但它仅决定采取哪些步骤，并且独自负责执行这些步骤。</p><p>但是，只有我们扩展的规则引擎（可以共同推理规则和流程）才能在考虑规则和流程的情况下得出下一步。如果需要执行流程的一部分，则规则引擎将请求流程引擎执行此步骤。一旦执行了此步骤，流程引擎就会将控制权返回给规则引擎，以再次得出后续步骤。这意味着对下一步操作的控制已被颠倒：流程引擎本身不再决定下一步，但我们的增强型规则引擎将处于控制状态，通知流程引擎下一步执行的操作以及何时执行。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1705"></a> 7.4。例</h2></div></div></div><p>drools-examples项目包含一个示例过程（ <code class="filename">org.drools.examples.process.order</code> ），说明了能够合并流程和规则的一些优势。此过程描述了一个订单应用程序，在该应用程序中，将验证传入订单，计算折扣并请求货物运输。
    </p><div class="mediaobject" align="center"><img src="./images/Chapter-RulesAndProcesses/orderProcess.bmp" align="middle"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1716"></a> 7.4.1。评估过程中的一组规则</h3></div></div></div><p>作为流程的一部分，Drools Flow可以轻松地包含一组规则。需要评估的规则应使用<strong class="kw"><code>ruleflow-group</code></strong>规则属性。为组激活一个RuleSet节点会触发对过程中这些规则的评估。本示例在此过程中使用了两个RuleSet节点：一个用于验证订单，另一个用于计算折扣。例如，下面显示了验证订单的规则之一。注意<strong class="kw"><code>ruleflow-group</code></strong>属性，以确保使用与图中所示相同的规则流组将该规则作为RuleSet节点的一部分进行评估。</p><pre class="programlisting">
rule "Invalid item id"
    ruleflow-group "validate"
    lock-on-active true
when
    o: Order()
    i: Order.OrderItem() from o.getOrderItems()
    not (Item() from itemCatalog.getItem(i.getItemId()))
then 
    System.err.println("Invalid item id found!");
    o.addError("Invalid item id " + i.getItemId());
end</pre><div class="figure"><a id="d0e1729"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/Chapter-RulesAndProcesses/validation.bmp" align="middle" alt="RuleSet节点及其规则之一"></div></div><p class="title"><b>图7.1。RuleSet节点及其规则之一</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1735"></a> 7.4.2。使用规则评估约束</h3></div></div></div><p>规则可用于表达和评估流程中的复杂约束。例如，当决定在Split节点上选择执行路径时，可以使用规则来定义这些条件。同样，等待状态可以使用规则来定义等待时间。本示例使用规则来确定订单后的下一步操作。如果订单包含错误，则销售代表应尝试更正订单。值大于1000 $的订单更为重要，因此高级销售代表应参加该订单。所有其他命令应正常进行。决策节点用于选择这些备选方案之一，而规则用于描述每个备选方案的约束。</p><div class="mediaobject" align="center"><img src="./images/Chapter-RulesAndProcesses/constraints.bmp" align="middle"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1743"></a> 7.4.3。分配规则</h3></div></div></div><p>人工任务可以用于描述需要由人类演员执行的工作的过程。参与者的选择可以基于过程的当前状态和历史记录。分配规则描述了如何根据此信息确定参与者。每当需要执行新的人工任务时，这些分配规则将自动应用。</p><p>请注意，下面显示的规则是用领域特定语言（DSL）编写的，适合于订单处理环境中制定条件的特定要求。</p><pre class="programlisting">
/********** Generic assignment rules **********/

rule "Assign 'Correct Order' to any sales representative"
    salience 30
    when
        There is a human task
        - with task name "Correct Order"
        - without actor id
    then 
        Set actor id "Sales Representative"
end

/********** Assignment rules for the RuleSetExample process **********/

rule "Assign 'Follow-up Order' to a senior sales representative"
    salience 40
    when
        Process "org.drools.examples.process.ruleset.RuleSetExample" contains a human task
        - with task name "Follow-up Order"
        - without actor id
    then 
        Set actor id "Senior Sales Representative"
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1752"></a> 7.4.4。使用规则描述特殊情况</h3></div></div></div><p>规则可用于描述特殊情况以及如何应对这些情况。将所有这些信息添加到常规过程的控制流中会使基本过程变得更加复杂。规则可用于分别处理每种情况，而核心过程保持简单形式。这也使适应现有流程以考虑以前无法预料的事件变得容易得多。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1757"></a> 7.4.5。使用规则模块化问题</h3></div></div></div><p>该过程定义了总体控制流程。可以使用规则在此过程中增加其他关注点，而不会使总体控制流程更加复杂。例如，可以定义规则以在过程执行期间记录某些信息。原始过程未更改，而所有日志记录功能都经过模块化模块化处理，成为一组规则。由于日志记录策略规则与流程本身的规则相分离，因此，这极大地提高了可重用性，允许用户轻松地将同一策略应用于不同的流程，可读性（通过不更改原始流程的控制流）和可维护性。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1762"></a> 7.4.6。动态更改流程行为的规则</h3></div></div></div><p>规则使您可以动态地微调流程的行为。想象一下，其中一个进程在运行时遇到问题。现在，可以在运行时添加新规则，以记录其他信息或处理特定过程状态。问题解决或情况改变后，可以轻松地再次删除这些规则。根据当前状态，可以动态选择不同的策略。例如，基于所有服务的当前负载，可以使用规则将流程优化为当前负载。此过程包含一个简单的示例，该示例使您可以动态添加或删除“检查订单”任务的日志记录。选中主应用程序窗口中的“调试输出”复选框后，将动态加载以下所示的规则，以便在请求“检查订单”任务时将日志输出写入控制台。取消选中该框将再次动态删除规则。</p><pre class="programlisting">
rule "Log the execution of 'Correct Order'"
    salience 25
when
    workItemNodeInstance: WorkItemNodeInstance( workItemId &lt;= 0, node.name == "Correct Order" )
    workItem: WorkItemImpl( state == WorkItemImpl.PENDING ) from workItemNodeInstance.getWorkItem()
then
    ProcessInstance proc = workItemNodeInstance.getProcessInstance();
    VariableScopeInstance variableScopeInstance =
      (VariableScopeInstance)proc.getContextInstance( VariableScope.VARIABLE_SCOPE );
    System.out.println( "LOGGING: Requesting the correction of " +
                        variableScopeInstance.getVariable("order"));
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1769"></a> 7.4.7。集成工具</h3></div></div></div><p>流程和规则集成在Drools Eclipse IDE中。流程和规则都只是被视为不同类型的业务逻辑，几乎可以完全相同地进行管理。例如，将流程或一组规则加载到引擎中非常相似。同样，以统一的方式处理不同的规则实现，例如DRL或DSL。</p><pre class="programlisting">
private static KnowledgeBase createKnowledgeBase() throws Exception {
    KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
    kbuilder.add( ResourceFactory.newClassPathResource(
                  "RuleSetExample.rf", OrderExample.class), ResourceType.DRF );
    kbuilder.add( ResourceFactory.newClassPathResource(
                  "workflow_rules.drl", OrderExample.class), ResourceType.DRL );
    kbuilder.add( ResourceFactory.newClassPathResource(
                  "assignment.dsl", OrderExample.class), ResourceType.DSL );
    kbuilder.add( ResourceFactory.newClassPathResource(
                 "assignment.dslr", OrderExample.class), ResourceType.DSLR );

    KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
    kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );
    return kbase;
}</pre><p>我们的审核日志还包含一个集成视图，显示规则和流程如何相互影响。例如，日志的一部分显示了如何将规则“ 5％折扣”作为节点“计算折扣”的一部分执行。</p><div class="mediaobject" align="center"><img src="./images/Chapter-RulesAndProcesses/audit.bmp" align="middle"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1781"></a> 7.4.8。特定领域的规则和流程</h3></div></div></div><p>无需使用核心规则语言语法来定义规则，但是也可以使用我们更高级的规则编辑器，域特定语言，决策表，指导性编辑器等来定义规则。我们的示例根据任务的类型，属性，定义的过程等，定义了一种用于描述分配规则的领域特定语言。这使非专家更容易理解分配规则。</p><pre class="programlisting">
/********** Generic assignment rules **********/

rule "Assign 'Correct Order' to any sales representative"
    salience 30
    when
        There is a human task
        - with task name "Correct Order"
        - without actor id
    then 
        Set actor id "Sales Representative"
end

/********** Assignment rules for the RuleSetExample process **********/

rule "Assign 'Follow-up Order' to a senior sales representative"
    salience 40
    when
        Process "org.drools.examples.process.ruleset.RuleSetExample" contains a human task
        - with task name "Follow-up Order"
        - without actor id
    then 
        Set actor id "Senior Sales Representative"
end</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ch.Domain_Specific_Processes"></a>第八章特定领域的流程</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1791">8.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e1821">8.2。示例：通知</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1828">8.2.1。创建工作定义</a></span></dt><dt><span class="section"><a href="#d0e1835">8.2.2。注册工作定义</a></span></dt><dt><span class="section"><a href="#d0e1842">8.2.3。在流程中使用新工作项</a></span></dt><dt><span class="section"><a href="#d0e1864">8.2.4。执行工作项</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1892">8.3。使用工作项测试流程</a></span></dt><dt><span class="section"><a href="#d0e1897">8.4。未来</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1791"></a> 8.1。介绍</h2></div></div></div><p>我们统一规则和流程框架的目标之一是允许用户使用特定于域的扩展来扩展默认的编程结构，从而简化特定应用程序域中的开发。尽管Drools一直提供用于创建特定于域的规则语言的结构，但本教程描述了我们迈向特定于域的过程语言的第一步。
</p><p>大多数处理语言都提供了一些通用操作（节点）构造，可以插入用户习惯操作。但是，这些操作通常是低级的，要求用户编写自定义代码以实现应包含在流程中的工作。该代码还与特定的目标环境紧密链接，从而使得很难在不同的上下文中重用该过程。
</p><p>特定领域的语言针对一种特定的应用程序域，因此可以提供与用户要解决的问题密切相关的构造。这使得流程更加容易理解和自我记录。我们将向您展示如何定义特定于域的工作项，这些工作项代表需要执行的原子工作单元。这些工作项以声明的方式指定了应在流程上下文中执行的工作，即，指定应在更高级别（无代码）执行（而不是如何执行）什么，并隐藏实现细节。
</p><p>因此，我们需要以下工作项目：</p><div class="orderedlist"><ol type="1"><li><p>特定领域</p></li><li><p>声明式的（什么，而不是如何）</p></li><li><p>高级（无代码）</p></li><li><p>可根据上下文定制</p></li></ol></div><p>
</p><p>用户可以轻松定义自己的一组特定于域的工作项，并将它们集成到我们的过程语言中。例如，下图显示了医疗保健环境中的流程示例。该过程包括特定领域的工作项目，用于订购护理任务（例如，测量血压），开药和通知护理人员。</p><div class="mediaobject" align="center"><img src="./images/Chapter-DomainSpecificProcesses/CDSSExample.bmp" align="middle"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1821"></a> 8.2。示例：通知</h2></div></div></div><p>让我们开始向您展示如何包含一个用于发送通知的简单工作项。工作项以声明的方式表示工作的原子单元。它由唯一的名称和其他参数定义，这些参数可用于更详细地描述作品。工作项在执行后也可以返回信息，指定为结果。因此，可以使用带有四个参数且没有结果的工作定义来定义我们的通知工作项：</p><pre class="programlisting">
  Name: "Notification"
  Parameters
  From [String]
  To [String]
  Message [String]
  Priority [String]
</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1828"></a> 8.2.1。创建工作定义</h3></div></div></div><p>必须在项目类路径中的一个或多个配置文件中指定所有工作定义，其中所有属性均指定为“名称/值”对。参数和结果是映射，其中每个参数名称也都映射到期望的数据类型。请注意，此配置文件还包括一些其他用户界面信息，例如图标和工作项的显示名称。（我们使用MVEL读取配置文件，这使我们可以执行更多高级配置文件）。我们的MyWorkDefinitions.conf文件如下所示：</p><pre class="programlisting">
import org.drools.process.core.datatype.impl.type.StringDataType;
[
  // the Notification work item
  [
    "name" : "Notification",
    "parameters" : [
      "Message" : new StringDataType(),
      "From" : new StringDataType(),
      "To" : new StringDataType(),
      "Priority" : new StringDataType(),
    ],
    "displayName" : "Notification",
    "icon" : "icons/notification.gif"
  ]

  // add more work items here ...
]
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1835"></a> 8.2.2。注册工作定义</h3></div></div></div><p>Drools Configuration API可用于使用drools.workDefinitions属性为您的项目注册工作定义文件，该属性表示包含工作定义的文件列表（使用空格分隔）。例如，在项目的META-INF目录中包含drools.rulebase.conf文件，并添加以下行：</p><pre class="programlisting">
  drools.workDefinitions = MyWorkDefinitions.conf
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1842"></a> 8.2.3。在流程中使用新工作项</h3></div></div></div><p>一旦创建并注册了工作定义，我们就可以在流程中开始使用它。流程编辑器在面板中包含一个单独的部分，在该部分中将显示为项目定义的不同工作项。</p><div class="mediaobject" align="center"><img src="./images/Chapter-DomainSpecificProcesses/NotificationPalette.bmp" align="middle"></div><p>使用拖放，可以在流程内部创建一个通知节点。可以使用属性视图填充属性。</p><p>除了为此工作项定义的属性之外，所有工作项还具有以下三个属性：</p><div class="orderedlist"><ol type="1"><li><p>参数映射：允许您将过程中的变量值映射到工作项的参数。这使您可以基于实际流程实例的当前状态来自定义工作项（例如，通知的优先级可能取决于某些特定于流程的信息）。</p></li><li><p>结果映射：允许您将结果（执行工作项后返回）映射到流程的变量。这使您可以在其余过程中使用结果。</p></li><li><p>等待完成：默认情况下，该过程将等待直到请求的工作项完成后再继续该过程。通过将“等待完成”设置为false，也可以在请求工作项后立即继续（而不等待结果）。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1864"></a> 8.2.4。执行工作项</h3></div></div></div><p>Drools引擎包含一个WorkItemManager，负责在必要时执行工作项。WorkItemManager负责将工作项目委派给执行该工作项目的WorkItemHandlers，并在工作项目完成时通知WorkItemManager。为了执行通知工作项，应该创建一个NotificationWorkItemHandler（实现WorkItemHandler接口）：</p><pre class="programlisting">
package com.sample;

import org.drools.process.instance.WorkItem;
import org.drools.process.instance.WorkItemHandler;
import org.drools.process.instance.WorkItemManager;

public class NotificationWorkItemHandler implements WorkItemHandler {

  public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {
    // extract parameters
    String from = (String) workItem.getParameter("From");
    String to = (String) workItem.getParameter("To");
    String message = (String) workItem.getParameter("Message");
    String priority = (String) workItem.getParameter("Priority");
    // send email
    EmailService service = ServiceRegistry.getInstance().getEmailService();
    service.sendEmail(from, to, "Notification", message);
    // notify manager that work item has been completed
    manager.completeWorkItem(workItem.getId(), null);
  }

  public void abortWorkItem(WorkItem workItem, WorkItemManager manager) {
    // Do nothing, notifications cannot be aborted
  }

}
</pre><p>此WorkItemHandler通过电子邮件发送通知，然后立即通知WorkItemManager工作项已完成。请注意，并非所有工作项目都可以直接完成。在执行工作项需要花费一些时间的情况下，执行可以异步继续，并且稍后可以通知工作项管理器。在这些情况下，工作项可能也有可能在完成之前被中止。中止方法可用于指定如何中止此类工作项。</p><p>应该使用以下API在WorkItemManager上注册WorkItemHandlers：</p><pre class="programlisting">
  workingMemory.getWorkItemManager().registerWorkItemHandler(
    "Notification", new NotificationWorkItemHandler());
</pre><p>将工作项的执行与流程本身分离，具有以下优点：</p><div class="orderedlist"><ol type="1"><li><p>该过程更具声明性，指定应执行的内容，而不是执行方式。</p></li><li><p>可以通过调整工作项处理程序来实现对环境的更改。该过程本身不应该更改。在工作项处理程序负责与正确的服务集成的不同环境中，也可以使用相同的过程。</p></li><li><p>在流程和项目之间共享工作项处理程序很容易（如果将代码嵌入到流程本身中，则将更加困难）。</p></li><li><p>根据上下文，可以使用不同的工作项处理程序。例如，在测试或模拟期间，可能不一定需要实际执行工作项。下一部分显示了如何在测试期间使用专用工作项处理程序的示例。</p></li></ol></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1892"></a> 8.3。使用工作项测试流程</h2></div></div></div><p>根据上下文进行可定制的执行，更易于管理环境更改（通过更改处理程序），跨上下文共享流程（使用不同的处理程序），测试，模拟（自定义测试处理程序）</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1897"></a> 8.4。未来</h2></div></div></div><p>我们的流程框架基于流程虚拟机（PVM）的（已经众所周知）的思想，该流程框架可以用作多种流程语言的基础。这使用户可以更轻松地创建自己的流程语言，流程语言设计人员可以（重新）使用流程框架提供的通用服务（例如，持久性，审计）。流程表示为节点图，每个节点描述流程逻辑的一部分。不同类型的节点用于表示不同种类的功能，例如创建或合并并行流（拆分和联接），调用子进程，调用外部服务等。我们的目标之一是创建一种真正可插入的过程语言，语言设计人员可以在其中轻松地插入自己的节点实现。</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ch.Human_Tasks"></a>第九章人工任务</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1909">9.1。流程中的人工任务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1989">9.1.1。泳道</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1998">9.2。人工任务管理组件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2010">9.2.1。任务生命周期</a></span></dt><dt><span class="section"><a href="#d0e2034">9.2.2。将任务组件链接到Drools Flow引擎</a></span></dt><dt><span class="section"><a href="#d0e2079">9.2.3。启动任务管理组件</a></span></dt><dt><span class="section"><a href="#d0e2094">9.2.4。与任务管理组件进行交互</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2122">9.3。人工任务管理界面</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2126">9.3.1。Eclipse整合</a></span></dt><dt><span class="section"><a href="#d0e2134">9.3.2。基于Web的任务视图</a></span></dt></dl></dd></dl></div><p>工作流程和BPM（业务流程管理）的重要方面是人工任务管理。虽然可以自动执行某个过程中执行的某些工作，但是某些任务需要在人类参与者的交互下执行。Drools Flow支持使用特殊的人工任务节点（代表这种交互）在流程内部使用人工任务。该节点允许流程设计人员定义任务的类型，参与者，与任务相关的数据等。我们还实现了任务服务，可用于管理这些人工任务。但是，用户愿意集成任何其他解决方案，因为这是完全可插入的。</p><p>要开始在流程内部使用人工任务，您首先需要（1）在流程内部包括人工任务节点，（2）集成您选择的任务管理组件（例如，我们提供的WS-HT实现），以及（3）让最终用户使用某种用户界面与人工任务管理组件进行交互。这些元素将在下一节中详细讨论。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1909"></a> 9.1。流程中的人工任务</h2></div></div></div><div class="mediaobject" align="center"><img src="./images/Chapter-HumanTasks/human_task_process.png" align="middle"></div><p>Drools Flow支持使用特殊的人工任务节点在流程内部使用人工任务（如上图所示）。人工任务节点表示需要由人工角色执行的原子任务。尽管Drools Flow具有一个特殊的人工任务节点，用于将人工任务包括在流程中，但是人工任务仅被视为需要调用的任何其他种类的外部服务，因此被简单地实现为一种特殊的工作项。关于人工任务节点的唯一特殊之处在于，我们增加了对泳道的支持，从而使向用户分配任务更加容易（请参见下文）。人工任务节点包含以下属性：</p><div class="itemizedlist"><ul><li><span class="emphasis"><em>Id</em></span> ：节点的ID（在一个节点容器中是唯一的）。</li><li><span class="emphasis"><em>名称</em></span> ：节点的显示名称。</li><li><span class="emphasis"><em>TaskName</em></span> ：人工任务的名称。</li><li><span class="emphasis"><em>Priority</em></span> ：一个整数，指示人工任务的优先级。</li><li><span class="emphasis"><em>评论</em></span> ：与人工任务相关的评论。</li><li><span class="emphasis"><em>ActorId</em></span> ：负责执行人工任务的actor ID。演员ID的列表可以使用逗号（'，'）作为分隔符来指定。</li><li><span class="emphasis"><em>可跳过</em></span> ：指定是否可以跳过人工任务（即参与者决定不执行人工任务）。</li><li><span class="emphasis"><em>内容</em></span> ：与此任务关联的数据。</li><li><span class="emphasis"><em>Swimlane</em></span> ：此人工任务节点所属的泳道。通过泳道，可以轻松地将多个人工任务分配给同一演员。有关如何使用泳道的更多详细信息，请参见下文。
      </li><li><span class="emphasis"><em>等待完成</em></span> ：如果此属性为true，则人工任务节点仅在人工任务已终止（即完成或任何其他终端状态）时才继续；否则它将在创建人工任务后立即继续。</li><li><span class="emphasis"><em>进入和退出动作</em></span> ：在此节点进入和退出时执行的动作。</li><li><span class="emphasis"><em>参数映射</em></span> ：允许将过程变量的值复制到人工任务的参数。创建人工任务后，将复制值。</li><li><span class="emphasis"><em>结果映射</em></span> ：允许将人工任务的结果参数值复制到过程变量。完成人工任务后，将复制值。请注意，只有在“等待完成”设置为true时，才能使用结果映射。人工任务具有结果变量“ Result”，其中包含人工角色返回的数据。变量“ ActorId”包含实际执行任务的角色的ID。</li><li><span class="emphasis"><em>计时器</em></span> ：链接到此节点的计时器（有关更多详细信息，请参见“计时器”部分）。</li><li><span class="emphasis"><em>ParentId</em></span> ：如果此任务是另一个任务的子任务，则允许指定父任务ID。 （有关更多详细信息，请参见“子任务”部分）</li></ul></div><p>
    </p><p>选择人工任务节点时，可以在属性视图中编辑这些变量（见下文），或者还可以通过双击人工任务节点来编辑最重要的属性，然后打开自定义人工任务节点编辑器，如下所示：如下所示。</p><div class="mediaobject" align="center"><img src="./images/Chapter-HumanTasks/human_task_properties.png" align="middle"></div><div class="mediaobject" align="center"><img src="./images/Chapter-HumanTasks/human_task_editor.png" align="middle"></div><p>请注意，您可以指定不同参数的值（actorId，优先级，内容等）。直接（在这种情况下，对于该流程的每次执行，它们将是相同的），或者根据流程实例内部的数据，使其针对特定上下文。例如，类型为String的参数可以使用＃{expression}将值嵌入到String中。创建工作项时将检索该值，并且＃{...}将被变量的toString（）值替换。表达式可以只是变量的名称（在这种情况下，它将被解析为变量的值），但是也可以使用更高级的MVEL表达式，例如＃{person.name.firstname}。例如，发送电子邮件时，电子邮件的正文中可能包含“ Dear＃{customer.name}，...”之类的内容。对于其他类型的变量，可以使用参数映射将变量的值映射到参数。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1989"></a> 9.1.1。泳道</h3></div></div></div><p>人工任务节点可与泳道结合使用，以将多个人工任务分配给相似的角色。同一泳道中的任务将分配给同一演员。每当在泳道中创建第一个任务，并且该任务指定了actorId时，该actorId也会分配给泳道。即使已为该任务指定了actorId，将在该泳道中创建的所有其他任务也将使用该actorId。</p><p>每当完成泳道一部分的人工任务时，该泳道的actorId就会设置为执行该人工任务的actorId。例如，这允许将人工任务分配给一组用户，并将该泳衣的未来任务分配给主张第一个任务的用户。如果在某个时候将一个任务重新分配给另一个用户，这还将自动更改任务的分配。</p><p>要将人工任务添加到泳道，只需将泳道的名称指定为人工任务节点的“ Swimlane”参数的值即可。流程还必须定义其包含的所有泳道。为此，通过单击过程的背景打开过程属性，然后单击“ Swimlanes”属性。您可以在此处添加新的泳道。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1998"></a> 9.2。人工任务管理组件</h2></div></div></div><p>就Drools Flow引擎而言，人工任务与需要调用并作为正常工作项的扩展实施的任何其他外部服务相似。结果，流程本身仅包含对需要执行的人工任务的抽象描述，并且工作项处理程序负责将此抽象任务绑定到特定的实现。使用我们的可插入工作项处理程序方法（有关更多详细信息，请参阅特定于域的过程一章），用户可以插入任何后端实现。</p><p>但是，我们确实基于WS-HumanTask规范提供了这种人工任务管理组件的实现。如果您不需要自己集成特定的人工任务组件，则可以使用此服务。它管理任务的任务生命周期（创建，声明，完成等），并永久存储任务状态。它还支持国际化，日历集成，不同类型的作业，委派，截止日期等功能。</p><p>因为我们不想在标准可用时实现自定义解决方案，所以我们选择基于WS-HumanTask（WS-HT）规范来实现我们的服务。该规范详细定义了任务的模型，生命周期以及上述许多其他功能。它非常全面，可以在<a class="ulink" href="http://download.boulder.ibm.com/ibmdl/pub/software/dw/specs/ws-bpel4people/WS-HumanTask_v1.pdf">这里</a>找到。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2010"></a> 9.2.1。任务生命周期</h3></div></div></div><p>从流程的角度看，只要在执行流程实例期间触发人工任务节点，就会创建人工任务。该流程将仅在该人工任务已完成或中止时从该点继续进行（除非您通过将“等待完成”属性设置为true来指定该进程不需要等待人工任务完成） 。但是，人工任务本身通常具有单独的生命周期。我们现在将简短介绍这个生命周期，如下图所示。有关更多详细信息，请查看WS-HumanTask规范。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-HumanTasks/WSHT-lifecycle.png" align="middle" width="100%"></td></tr></tbody></table></div><p>每当创建任务时，它就从“创建”阶段开始。它通常会自动转换为“就绪”状态，此时任务将显示在所有允许执行任务的参与者的任务列表上。在那里，它正在等待这些参与者之一声明任务，表明他或她将执行任务。用户声明任务后，状态将更改为“已保留”。请注意，只有一个潜在角色的任务会在创建该任务时自动分配给该角色。申领任务后，该用户可以在某个时候决定开始执行任务，在这种情况下，任务状态将更改为“进行中”。最后，一旦执行了任务，用户必须完成任务（并可以指定与任务相关的结果数据），在这种情况下，状态将更改为“已完成”。如果无法完成任务，则用户还可以使用故障响应（可能与故障数据相关联）来指示此情况，在这种情况下，状态将更改为“失败”。</p><p>以上说明的生命周期是正常的生命周期。该服务还允许许多其他生命周期方法，例如：</p><div class="itemizedlist"><ul><li>委派或转发任务，在这种情况下，将其分配给另一个参与者</li><li>撤消一项任务，因此不再由某个特定参与者声明，而是重新出现在所有潜在参与者的任务列表中</li><li>临时挂起和恢复任务</li><li>停止正在进行的任务</li><li>跳过任务（如果任务已被标记为可跳过），在这种情况下将不执行任务</li></ul></div><p>
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2034"></a> 9.2.2。将任务组件链接到Drools Flow引擎</h3></div></div></div><p>任务管理组件需要像其他任何外部服务一样，与Drools Flow引擎集成在一起，方法是注册一个工作项目处理程序，该处理程序负责将抽象工作项目（在这种情况下为人工任务）转换为特定的调用。我们已经实现了这样的工作项处理程序（org.drools.process.workitem.wsht。WSHumanTaskHandler（在drools-process-task模块中），因此您可以像这样轻松地链接此工作项处理程序：</p><pre class="programlisting">
  StatefulKnowledgeSession session = ...;
  session.getWorkItemManager().registerWorkItemHandler("Human Task", new WSHumanTaskHandler());</pre><p>默认情况下，此处理程序将在端口9123上连接到本地计算机上的人工任务管理组件，但是您可以通过调用WSHumanTaskHandler上的setConnection（ipAddress，port）方法来轻松地对其进行更改。</p><p>目前，WSHumanTaskHandler正在使用Mina <a class="ulink" href="http://mina.apache.org/">（http://mina.apache.org/）</a>来测试客户端/服务器体系结构中的行为。Mina使用客户端和服务器之间的消息来使客户端与服务器通信。这就是WSHumanTaskHandler具有MinaTaskClient的原因，该MinaTaskClient创建不同的消息以向用户提供针对服务器执行的不同操作。</p><p>在客户端（此实现中为MinaTaskClient）中，我们应该看到用于与人工任务进行交互的以下方法的实现：</p><pre class="programlisting">
public void start( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void stop( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void release( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void suspend( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void resume( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void skip( long taskId, String userId, TaskOperationResponseHandler responseHandler )
public void delegate( long taskId, String userId, String targetUserId,
                      TaskOperationResponseHandler responseHandler )
public void complete( long taskId, String userId, ContentData outputData,
                      TaskOperationResponseHandler responseHandler )
...</pre><p>使用这种方法，我们将实现最终用户用来执行他们分配的任务的任何类型的GUI。如果看一下this方法签名，您会注意到几乎所有的此方法都采用以下参数：</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>taskId</strong></span> ：我们正在处理的任务的ID。可能您将从UI（用户界面）的用户任务列表中选择此ID。</p></li><li><p><span class="bold"><strong>userId</strong></span> ：正在执行操作的用户的ID。可能是在应用程序中签名的用户的ID。</p></li><li><p><span class="bold"><strong>responseHandler</strong></span> ：这是处理程序有责任来捕获响应并获取结果，或者只是让我们知道任务已经完成。</p></li></ul></div><p>您可以想象所有方法都会创建一条消息，该消息将发送到服务器，服务器将执行实现正确操作的逻辑。创建此消息之一将如下所示：</p><pre class="programlisting">
public void complete(long taskId,
                     String userId,
                     ContentData outputData,
                     TaskOperationResponseHandler responseHandler) {
  List&lt;Object&gt; args = new ArrayList&lt;Object&gt;( 5 );
  args.add( Operation.Complete );
  args.add( taskId );
  args.add( userId );
  args.add( null );
  args.add( outputData );
  Command cmd = new Command( counter.getAndIncrement(),
                             CommandName.OperationRequest,
                             args );

  handler.addResponseHandler( cmd.getId(),
                              responseHandler );
  session.write( cmd );
}</pre><p>在这里，我们可以看到已经创建了一个Command，并将该方法的参数插入到我们尝试执行的操作类型的命令中，然后使用session.write（cmd）方法将该命令发送到服务器。</p><p>如果看到服务器实现，则在收到命令后，我们发现这取决于操作类型（此处为Operation。完成）将是将要执行的逻辑。如果我们在messageReceived方法中查看TaskServerHandler类，则使用taskServiceSession执行taskOperation，该任务负责在创建任务且用户未与之交互时负责获取，保留和操纵所有人员任务信息。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2079"></a> 9.2.3。启动任务管理组件</h3></div></div></div><p>任务管理组件是与流程引擎进行通信的完全独立的服务。因此，我们建议也将其作为单独的服务启动。要启动任务服务器，可以使用以下代码片段：</p><pre class="programlisting">
EntityManagerFactory emf = Persistence.createEntityManagerFactory("org.drools.task");
taskService = new TaskService(emf);
MinaTaskServer server = new MinaTaskServer( taskService );
Thread thread = new Thread( server );
thread.start();</pre><p>任务管理组件使用Java Persistence API（JPA）来以持久方式存储所有任务信息。要配置持久性，您需要相应地修改persistence.xml配置文件。我们参考JPA文档中有关如何执行此操作的信息。例如，以下片段显示了如何将任务管理组件与hibernate和内存H2数据库一起使用：</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;persistence
    version="1.0"
    xsi:schemaLocation=
      "http://java.sun.com/xml/ns/persistence
       http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd
       http://java.sun.com/xml/ns/persistence/orm
       http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
    xmlns:orm="http://java.sun.com/xml/ns/persistence/orm"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://java.sun.com/xml/ns/persistence"&gt;

  &lt;persistence-unit name="org.drools.task"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;class&gt;org.drools.task.Attachment&lt;/class&gt;
    &lt;class&gt;org.drools.task.Content&lt;/class&gt;
    &lt;class&gt;org.drools.task.BooleanExpression&lt;/class&gt;
    &lt;class&gt;org.drools.task.Comment&lt;/class&gt;
    &lt;class&gt;org.drools.task.Deadline&lt;/class&gt;
    &lt;class&gt;org.drools.task.Comment&lt;/class&gt;
    &lt;class&gt;org.drools.task.Deadline&lt;/class&gt;
    &lt;class&gt;org.drools.task.Delegation&lt;/class&gt;
    &lt;class&gt;org.drools.task.Escalation&lt;/class&gt;
    &lt;class&gt;org.drools.task.Group&lt;/class&gt;
    &lt;class&gt;org.drools.task.I18NText&lt;/class&gt;
    &lt;class&gt;org.drools.task.Notification&lt;/class&gt;
    &lt;class&gt;org.drools.task.EmailNotification&lt;/class&gt;
    &lt;class&gt;org.drools.task.EmailNotificationHeader&lt;/class&gt;
    &lt;class&gt;org.drools.task.PeopleAssignments&lt;/class&gt;
    &lt;class&gt;org.drools.task.Reassignment&lt;/class&gt;
    &lt;class&gt;org.drools.task.Status&lt;/class&gt;
    &lt;class&gt;org.drools.task.Task&lt;/class&gt;
    &lt;class&gt;org.drools.task.TaskData&lt;/class&gt;
    &lt;class&gt;org.drools.task.SubTasksStrategy&lt;/class&gt;
    &lt;class&gt;org.drools.task.OnParentAbortAllSubTasksEndStrategy&lt;/class&gt;
    &lt;class&gt;org.drools.task.OnAllSubTasksEndParentEndStrategy&lt;/class&gt;
    &lt;class&gt;org.drools.task.User&lt;/class&gt;

    &lt;properties&gt;
      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
      &lt;property name="hibernate.connection.driver_class" value="org.h2.Driver"/&gt;
      &lt;property name="hibernate.connection.url" value="jdbc:h2:mem:mydb" /&gt;
      &lt;property name="hibernate.connection.username" value="sa"/&gt;
      &lt;property name="hibernate.connection.password" value="sasa"/&gt;
      &lt;property name="hibernate.connection.autocommit" value="false" /&gt;
      &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
      &lt;property name="hibernate.hbm2ddl.auto" value="create" /&gt;
      &lt;property name="hibernate.show_sql" value="true" /&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><p>首次启动任务管理组件时，需要确保将所有必需的用户和组都添加到数据库中。我们的实现要求在尝试将任务分配给该用户或组之前，预先定义所有用户和组。因此，您需要确保使用taskSession.addUser（user）和taskSession.addGroup（group）方法将必要的用户和组添加到数据库中。请注意，您至少需要一个“管理员”用户，因为所有任务都将自动分配给该用户作为管理员角色。</p><p>drools-process-task模块包含一个org.drools.task。src / test / java源文件夹中的RunTaskService类，可用于启动任务服务器。它会自动根据LoadUsers.mvel和LoadGroups.mvel配置文件中的定义添加用户和组。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2094"></a> 9.2.4。与任务管理组件进行交互</h3></div></div></div><p>任务管理组件提供了各种方法来通过Java API管理任务的生命周期。这使客户端可以与任务管理组件集成（较低级别）。请注意，最终用户可能不应直接与此低级API进行交互，而应使用任务列表客户端之一。这些客户端使用此API与任务管理组件进行交互。</p><p>下图将描述这种交互：</p><div class="mediaobject" align="center"><img src="./images/Chapter-HumanTasks/component-distribution.png" align="middle"></div><p>如图所示，我们有MinaTaskClient和MinaTaskServer。它们彼此通信，发送消息以查询和操纵人工任务。逐步的交互将是这样的：</p><div class="itemizedlist"><ul><li><p>一些客户需要完成一些任务。因此，他/她需要创建一个MinaTaskClient实例并将其连接到MinaTaskServer以便进行会话以相互交谈。这是图像中的第一步。</p></li><li><p>然后，客户端可以使用相应的参数调用MinaTaskClient中的complete（）方法。这将生成一个新的消息（或命令），该消息将插入到客户端连接到服务器时打开的会话中。该消息必须指定一种类型，服务器可以识别该类型，并知道收到消息后该怎么做。这是图像中的第二步。</p></li><li><p>这时TaskServerHandler注意到会话中有一条新消息，因此将对哪种消息进行分析。在这种情况下是操作类型。完成，因为客户端成功完成了一些任务。因此，我们需要完成用户想要完成的任务。这可以通过使用TaskServiceSession来实现，它将触发特定类型的事件，该事件将由TaskEventListener的特定子类处理。这是图像中的第三步和第四步。</p></li><li><p>当TaskEventListener接收到事件时，它将知道如何修改任务的状态。这是通过使用EntityManager从数据库中检索和修改特定任务的状态来实现的。在这种情况下，由于我们正在完成任务，因此状态将更新为“已完成”。这是图像中的第五步。</p></li><li><p>现在，进行更改后，我们需要通知客户端任务已成功结束，并且可以通过创建一条响应消息来实现，TaskClientHandler将接收该消息并通知MinaTaskClient。这是图像中的第六，第七和第八步。</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2122"></a> 9.3。人工任务管理界面</h2></div></div></div><p></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2126"></a> 9.3.1。Eclipse整合</h3></div></div></div><p>Drools IDE包含一个org.drools.eclipse.task插件，使您可以使用人工任务测试和/或调试过程。其中包含可以连接到正在运行的任务管理组件的人员任务视图，为特定用户请求相关任务（即，该用户是潜在所有者或该用户已声明并正在执行的任务）。然后可以执行这些任务的生命周期，即声明或释放任务，开始或停止任务的执行，完成任务等。此人工任务视图的屏幕截图如下所示。您可以在Drools Task首选项页面中配置要连接到的任务管理组件（选择Window-> Preferences，然后选择Drools Task）。您可以在此处指定网址和端口（默认= 127.0.0.1:9123）。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-HumanTasks/human_task_view.png" align="middle" width="100%"></td></tr></tbody></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2134"></a> 9.3.2。基于Web的任务视图</h3></div></div></div><p>我们的目标是添加一个基于Web的视图，最终用户可以使用该视图来管理Drools 5.1的任务。</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2140"></a>第十章调试过程</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2145">10.1。一个简单的例子</a></span></dt><dt><span class="section"><a href="#d0e2167">10.2。调试过程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2206">10.2.1。流程实例视图</a></span></dt><dt><span class="section"><a href="#d0e2248">10.2.2。审核视图</a></span></dt></dl></dd></dl></div><p>本节介绍如何调试进程。这意味着可以在执行过程中检查并可视化正在运行的进程的当前状态。在本节中，我们将使用一个简单的示例来说明调试功能。首先将介绍该示例，然后说明如何使用调试功能。
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2145"></a> 10.1。一个简单的例子</h2></div></div></div><p>我们的示例包含两个流程和一些规则（在规则流组内部使用）：</p><div class="orderedlist"><ol type="1"><li><p>主流程包含一些最常见的节点：一个开始节点和一个结束节点（显然），两个规则流组，一个操作（将字符串简单地输出到默认输出），一个里程碑（一个等待状态，在特定状态下触发）事件被插入工作存储器中）和一个子进程。</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example.bmp" align="middle"></div></li><li><p>子流程仅包含一个里程碑，该里程碑还等待工作内存中的（另一个）特定事件。</p></li><li><p>只有两个规则（每个规则流组一个）可以简单地将hello world或再见world打印为默认输出。</p></li></ol></div><p>我们将通过启动流程，触发所有规则（导致执行hello规则），然后为两个里程碑（在主流程和子流程中）添加特定的里程碑事件，最后通过以下方式模拟该流程的执行：再次触发所有规则（导致执行再见规则）。控制台将如下所示：</p><pre class="programlisting">Hello World
Executing action
Goodbye cruel world</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2167"></a> 10.2。调试过程</h2></div></div></div><p>现在，我们在流程执行期间添加了四个断点（按遇到它们的顺序）：</p><div class="orderedlist"><ol type="1"><li><p>打招呼规则后果的开始</p></li><li><p>在主流程中插入里程碑的触发事件之前</p></li><li><p>在子流程中为里程碑插入触发事件之前</p></li><li><p>再见规则后果的开始</p></li></ol></div><p>在调试应用程序时，可以使用以下调试视图来跟踪过程的执行：</p><div class="orderedlist"><ol type="1"><li><p>工作存储器视图，显示工作存储器中的内容（数据）。</p></li><li><p>议程视图，显示议程中的所有激活。</p></li><li><p>全局数据视图，显示全局变量。</p></li><li><p>默认的Java Debug视图，显示了当前行和已知变量的值，这对于常规Java代码和规则都是如此。</p></li><li><p>流程实例视图，显示所有正在运行的流程（及其状态）。</p></li><li><p>审核视图，显示审核日志。</p></li></ol></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2206"></a> 10.2.1。流程实例视图</h3></div></div></div><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/process-instances.bmp" align="middle"></div><p>流程实例视图显示当前正在运行的流程实例。该示例显示当前有一个正在运行的进程（实例），当前正在执行一个节点（实例），即RuleSet节点。双击流程实例时，流程实例查看器将以图形方式显示流程实例的进度。在每个断点处，它看起来像：</p><div class="orderedlist"><ol type="1"><li><p>在hello规则的后果开始时，只有hello ruleflow组处于活动状态，等待hello规则的执行：</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-1.bmp" align="middle"></div></li><li><p>一旦执行了该规则，便会触发操作，里程碑和子流程。该操作将立即执行，并触发连接（连接将简单地等待，直到所有传入的连接都被触发）。子进程将在里程碑处等待。因此，在将里程碑的触发事件插入主流程之前，现在有两个流程实例，如下所示：</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-2a.bmp" align="middle"></div><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-2b.bmp" align="middle"></div></li><li><p>在主流程中为里程碑事件触发事件时，这还将触发联接（它将简单地等待，直到所有传入的连接都被触发为止）。因此，此时（在子流程中为里程碑插入触发事件之前），流程将如下所示：</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-3a.bmp" align="middle"></div><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-2b.bmp" align="middle"></div></li><li><p>当在子流程中为里程碑事件触发事件时，此流程实例将完成并且还将触发联接，然后该联接将继续并触发再见规则流组，因为其所有传入连接均已被触发。触发所有规则将触发再见规则中的断点。此时，情况如下：</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/example-debug-4.bmp" align="middle"></div></li><li><p>执行再见规则后，主流程也将完成，并且执行将结束。</p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2248"></a> 10.2.2。审核视图</h3></div></div></div><p>对于那些想要在审计视图中查看结果的人来说，它看起来像这样[注：对象插入事件可能看起来有点不合适，这是由于它们仅在之后记录（并且从不记录）之前），因此很难精确地确定其位置。]</p><div class="mediaobject" align="center"><img src="./images/Chapter-Debugging/audit.bmp" align="middle"></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ch.Drools_Eclipse_IDE_Features"></a>第十一章Drools Eclipse IDE功能</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2261">11.1。流口水运行时</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2266">11.1.1。定义Drools运行时</a></span></dt><dt><span class="section"><a href="#d0e2303">11.1.2。为您的Drools项目选择运行时</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2318">11.2。处理皮肤</a></span></dt></dl></div><p>Eclipse IDE的Drools插件提供了一些开发人员可能感兴趣的附加功能。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2261"></a> 11.1。流口水运行时</h2></div></div></div><p>Drools运行时是jar文件的集合，这些文件代表Drools项目jar的一个特定版本。要创建运行时，您必须将IDE指向您选择的版本。如果要基于插件本身包含的最新Drools项目jar创建新的运行时，则也可以轻松地做到这一点。您需要为Eclipse工作区指定默认的Drools运行时，但是每个单独的项目都可以覆盖默认值，并为该项目选择适当的运行时。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2266"></a> 11.1.1。定义Drools运行时</h3></div></div></div><p>要使用Eclipse首选项视图定义一个或多个Drools运行时，可以通过在菜单“窗口”中选择“首选项”菜单项来打开“首选项”。“首选项”对话框应显示所有设置。在此对话框的左侧，在Drools类别下，选择“ Installed Drools runtimes”。然后，右侧面板应显示当前定义的Drools运行时。如果尚未定义任何运行时，则其外观应如下图所示。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/drools-runtimes.png" align="middle" width="100%"></td></tr></tbody></table></div><p>要定义新的Drools运行时，请单击添加按钮。将弹出一个对话框，如下所示，要求您提供运行时的名称以及在文件系统上可以找到它的位置。</p><div class="mediaobject" align="center"><img src="./images/Chapter-Eclipse/drools-runtimes-add.png" align="middle"></div><p>通常，您有两种选择：</p><div class="orderedlist"><ol type="1"><li><p>如果您只想使用Drools Eclipse插件中包含的默认jar文件，则可以通过单击“创建新的Drools 5运行时...”按钮来自动创建新的Drools运行时。将显示一个文件浏览器，要求您在文件系统上选择要在其中创建运行时的文件夹。然后，插件将自动将所有必需的依赖项复制到指定的文件夹。选择此文件夹后，对话框应如下图所示。</p></li><li><p>如果要使用Drools项目的一个特定版本，则应在文件系统上创建一个文件夹，其中包含所有必需的Drools库和依赖项。不要像上面解释的那样创建新的Drools运行时，而是给运行时命名并选择包含所有必需jar的文件夹的位置。</p></li></ol></div><div class="mediaobject" align="center"><img src="./images/Chapter-Eclipse/drools-runtimes-add2.png" align="middle"></div><p>单击确定按钮后，运行时将显示在已安装的Drools运行时表中，如下所示。单击新创建的运行时前面的复选框，将其设置为默认的Drools运行时。默认的Drools运行时将用作所有尚未选择项目特定运行时的Drools项目的运行时。
      </p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/drools-runtimes2.png" align="middle" width="100%"></td></tr></tbody></table></div><p>您可以根据需要添加任意数量的Drools运行时。例如，以下屏幕截图显示了已定义三个运行时的配置：Drools 4.0.7运行时，Drools 5.0.0运行时和Drools 5.0.0。SNAPSHOT运行时。Drools 5.0.0运行时被选择为默认运行时。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/drools-runtimes3.png" align="middle" width="100%"></td></tr></tbody></table></div><p>请注意，如果您更改了默认运行时，则需要重新启动Eclipse，并且要确保所有使用默认运行时的项目都相应地更新其类路径。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2303"></a> 11.1.2。为您的Drools项目选择运行时</h3></div></div></div><p>每当您创建Drools项目时（使用“ New Drools Project”向导，或通过使用“转换为Drools项目”操作将现有的Java项目转换为Drools项目），该操作在Drools透视图中显示，并右键单击现有的Java项目），该插件会自动将所有必需的jar添加到您项目的类路径中。</p><p>当创建一个新的Drools项目时，除非您指定一个特定于项目的插件，否则插件将自动使用该项目的默认Drools运行时。您可以在“新建Drools项目”向导的最后一步中执行此操作，如下所示，方法是取消选中“使用默认Drools运行时”复选框，然后在下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。</p><div class="mediaobject" align="center"><img src="./images/Chapter-Eclipse/drools-runtimes-newproject.png" align="middle"></div><p>您可以随时通过打开项目属性并选择Drools类别来更改Drools项目的运行时，如下所示。选中“启用项目特定设置”复选框，然后从下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。如果取消选中“启用项目特定设置”复选框，它将使用全局首选项中定义的默认运行时。</p><div class="mediaobject" align="center"><img src="./images/Chapter-Eclipse/drools-runtimes-project.png" align="middle"></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2318"></a> 11.2。处理皮肤</h2></div></div></div><p><span class="emphasis"><em>过程外观</em></span>的概念提供了一种控制过程中不同节点的可视化的方法。您可以通过实现自己的节点，将各种节点类型的可视化方式更改为您喜欢的方式<code class="code">SkinProvider</code> 。</p><p>BPMN是一种流行的语言，供业务用户用来对业务流程进行建模。BPMN定义了术语，不同类型的节点，应如何可视化等等。熟悉BPMN的人们可能会发现，使用类似的可视化来实现可执行流程（可能基于BPMN流程图）更加容易。因此，我们创建了BPMN外观，该外观将Drools Flow概念映射到等效的BPMN可视化。</p><p>作为示例，下图显示了使用默认外观使用RuleFlow语言中的某些不同类型的节点的过程。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/RuleFlow.png" align="middle" width="100%"></td></tr></tbody></table></div><p>现在，您可以在“ Drools首选项”对话框中更改首选的流程外观：</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/preferences.png" align="middle" width="100%"></td></tr></tbody></table></div><p>重新打开编辑器后，使用BPMN皮肤显示相同的过程。</p><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-Eclipse/BPMN.png" align="middle" width="100%"></td></tr></tbody></table></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2346"></a>第十二章业务活动监控</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2353">12.1。报告中</a></span></dt><dt><span class="section"><a href="#d0e2374">12.2。直接干预</a></span></dt></dl></div><p>您需要积极地监视您的过程，以确保您可以检测到任何异常并尽快对意外事件做出反应。业务活动监视（BAM）涉及对流程的实时监视，以及基于对这些事件的分析进行直接干预（甚至可能自动干预）的选项。</p><p>Drools Flow允许用户基于流程引擎生成的事件定义报告，并可能使用复杂的事件处理规则（Drools Fusion）在特定情况下直接进行干预，如以下两节所述。Drools平台的未来版本将包括对业务活动监控的所有要求的支持，包括基于Web的应用程序，可用于更轻松地与正在运行的流程引擎进行交互，检查其状态，生成报告等。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2353"></a> 12.1。报告中</h2></div></div></div><p>通过将历史记录器添加到流程引擎，所有相关事件都存储在数据库中。此历史记录日志可用于监视和分析流程的执行。我们正在使用Eclipse BIRT（商业智能报告工具）来创建显示关键绩效指标的报告。使用包含所有过程历史信息的预定义数据集以及您可能要添加自己的任何其他数据源，可以轻松地自己定义自己的报告。</p><p>Eclipse BIRT框架允许您定义数据集，创建报告，包括图表，预览报告以及将其导出到网页上。（有关如何定义自己的报告，请咨询Eclipse BIRT文档。）以下屏幕快照显示了有关如何创建此类图表的示例。</p><div class="figure"><a id="d0e2360"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-BAM/EventingReportEdit.png" align="middle" width="100%" alt="使用Eclipse BIRT创建报告"></td></tr></tbody></table></div></div><p class="title"><b>图12.1使用Eclipse BIRT创建报告</b></p></div><br class="figure-break"><p>下图显示了一个基于一些历史数据的简单报告，其中显示了每小时的请求数以及该小时内请求的平均完成时间。这些图表可用于检查请求的意外下降或上升，平均处理时间的增加等。这些图表可能会在情况真正失控之前发出可能的问题的信号。</p><div class="figure"><a id="d0e2368"></a><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" cellspacing="0" cellpadding="0" width="100%" summary="manufactured viewport for HTML img"><tbody><tr><td align="center"><img src="./images/Chapter-BAM/EventingReport.png" align="middle" width="100%" alt="事件报告"></td></tr></tbody></table></div></div><p class="title"><b>图12.2。事件报告</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2374"></a> 12.2。直接干预</h2></div></div></div><p>报表可用于可视化流程的当前状态，但是报表依赖于人工操作者根据这些图表中的信息采取措施。但是，我们允许用户定义对特定情况的自动响应。</p><p>Drools Fusion提供了众多功能，可轻松处理大量事件。这可以用来监视流程引擎本身。这可以通过向引擎添加侦听器来实现，该侦听器将所有相关的流程事件（例如流程实例的开始和完成，或特定节点的触发）转发给负责处理这些事件的会话。这可以是与执行进程的会话相同的会话，也可以是独立的会话。然后可以使用复杂事件处理（CEP）规则来指定如何处理这些事件。例如，这些规则可以基于特定级别的低级流程事件来生成较高级的业务事件。规则还可以指定如何应对特定情况。</p><p>下一部分显示了一个示例规则，该规则使用“滑动窗口”支持累计了一个小时内一个特定订单流程的所有启动流程事件。如果在过去一小时内启动了1000个以上的流程实例，则此规则将输出一条错误消息（例如，以检测服务器可能的过载）。请注意，在实际情况下，可以通过向负责人发送电子邮件或其他形式的通知代替简单的日志记录来代替。</p><pre class="programlisting">
declare ProcessStartedEvent
    @role( event )
end

dialect "mvel"

rule "Number of process instances above threshold"
when
  Number( nbProcesses : intValue &gt; 1000 )
    from accumulate(
      e: ProcessStartedEvent( processInstance.processId == "com.sample.order.OrderProcess" )
      over window:size(1h),
      count(e) )
then
  System.err.println( "WARNING: Number of order processes in the last hour above 1000: " +
                      nbProcesses );
end</pre><p>这些规则甚至可以用于根据引擎生成的事件在运行时自动更改流程的行为。例如，每当检测到特定情况时，都可以将其他规则添加到知识库中，以修改流程行为。例如，每当在特定时间范围内检测到大量用户请求时，便可以向该过程添加其他验证，从而执行某种流控制以减少传入请求的频率。由于检测到问题，还可能部署其他日志记录规则。一旦情况恢复正常，这种规则将再次被删除。</p></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2387"></a>指数</h2></div></div></div><div class="index"></div></div></div></body></html>