<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">流口水的求解器</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"><meta name="generator" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" content="DocBook XSL-NS Stylesheets V1.74.0"><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e13">1。用户指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16">1.1。解算器介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19">1.1.1。什么是求解器？</a></span></dt><dt><span class="section"><a href="#d0e118">1.1.2。流口水溶解器的状态</a></span></dt><dt><span class="section"><a href="#d0e136">1.1.3。构建drools-solver并运行示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e154">1.2。求解器示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e157">1.2.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e162">1.2.2。n个皇后区的例子</a></span></dt><dt><span class="section"><a href="#d0e419">1.2.3。课程安排示例</a></span></dt><dt><span class="section"><a href="#d0e455">1.2.4。旅游比赛示例</a></span></dt><dt><span class="section"><a href="#d0e654">1.2.5。ITC2007考试实例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e952">1.3。求解器配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e955">1.3.1。求解器的类型</a></span></dt><dt><span class="section"><a href="#d0e1052">1.3.2。求解器界面</a></span></dt><dt><span class="section"><a href="#d0e1082">1.3.3。建立一个求解器</a></span></dt><dt><span class="section"><a href="#d0e1113">1.3.4。解决方案界面</a></span></dt><dt><span class="section"><a href="#d0e1176">1.3.5。起始解决方案</a></span></dt><dt><span class="section"><a href="#d0e1183">1.3.6。一个简单的填充算法</a></span></dt><dt><span class="section"><a href="#d0e1242">1.3.7。解决问题</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1262">1.4。使用规则引擎计算分数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1265">1.4.1。基于规则的分数计算</a></span></dt><dt><span class="section"><a href="#d0e1335">1.4.2。ScoreDefinition界面</a></span></dt><dt><span class="section"><a href="#d0e1420">1.4.3。技巧和窍门</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1484">1.5。本地搜索求解器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1487">1.5.1。总览</a></span></dt><dt><span class="section"><a href="#d0e1535">1.5.2。一个动作</a></span></dt><dt><span class="section"><a href="#d0e1695">1.5.3。移动世代</a></span></dt><dt><span class="section"><a href="#d0e1727">1.5.4。一步</a></span></dt><dt><span class="section"><a href="#d0e1797">1.5.5。陷入局部最优</a></span></dt><dt><span class="section"><a href="#d0e1820">1.5.6。决定下一步</a></span></dt><dt><span class="section"><a href="#d0e1996">1.5.7。最佳解决方案</a></span></dt><dt><span class="section"><a href="#d0e2001">1.5.8。完</a></span></dt></dl></dd></dl></dd><dt><span class="index"><a href="#d0e2069">指数</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13"></a>第1章。用户指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16">1.1。解算器介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19">1.1.1。什么是求解器？</a></span></dt><dt><span class="section"><a href="#d0e118">1.1.2。流口水溶解器的状态</a></span></dt><dt><span class="section"><a href="#d0e136">1.1.3。构建drools-solver并运行示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e154">1.2。求解器示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e157">1.2.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e162">1.2.2。n个皇后区的例子</a></span></dt><dt><span class="section"><a href="#d0e419">1.2.3。课程安排示例</a></span></dt><dt><span class="section"><a href="#d0e455">1.2.4。旅游比赛示例</a></span></dt><dt><span class="section"><a href="#d0e654">1.2.5。ITC2007考试实例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e952">1.3。求解器配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e955">1.3.1。求解器的类型</a></span></dt><dt><span class="section"><a href="#d0e1052">1.3.2。求解器界面</a></span></dt><dt><span class="section"><a href="#d0e1082">1.3.3。建立一个求解器</a></span></dt><dt><span class="section"><a href="#d0e1113">1.3.4。解决方案界面</a></span></dt><dt><span class="section"><a href="#d0e1176">1.3.5。起始解决方案</a></span></dt><dt><span class="section"><a href="#d0e1183">1.3.6。一个简单的填充算法</a></span></dt><dt><span class="section"><a href="#d0e1242">1.3.7。解决问题</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1262">1.4。使用规则引擎计算分数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1265">1.4.1。基于规则的分数计算</a></span></dt><dt><span class="section"><a href="#d0e1335">1.4.2。ScoreDefinition界面</a></span></dt><dt><span class="section"><a href="#d0e1420">1.4.3。技巧和窍门</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1484">1.5。本地搜索求解器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1487">1.5.1。总览</a></span></dt><dt><span class="section"><a href="#d0e1535">1.5.2。一个动作</a></span></dt><dt><span class="section"><a href="#d0e1695">1.5.3。移动世代</a></span></dt><dt><span class="section"><a href="#d0e1727">1.5.4。一步</a></span></dt><dt><span class="section"><a href="#d0e1797">1.5.5。陷入局部最优</a></span></dt><dt><span class="section"><a href="#d0e1820">1.5.6。决定下一步</a></span></dt><dt><span class="section"><a href="#d0e1996">1.5.7。最佳解决方案</a></span></dt><dt><span class="section"><a href="#d0e2001">1.5.8。完</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16"></a> 1.1。解算器介绍</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e19"></a> 1.1.1。什么是求解器？</h3></div></div></div><p>Drools-solver结合了搜索算法和Drools规则引擎的功能来解决计划问题。此类计划问题的好例子包括：</p><div class="itemizedlist"><ul><li><p>员工轮班表</p></li><li><p>货运路线</p></li><li><p>供应分类</p></li><li><p>课程安排</p></li><li><p>考试安排</p></li><li><p><a class="ulink" href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">旅行商问题</a></p></li><li><p><a class="ulink" href="http://mat.gsia.cmu.edu/TOURN/">旅游比赛问题</a></p></li><li><p>举止也很失礼（尽管drools-solver解决这个问题的方式与纯drools规则引擎示例不同）</p></li></ul></div><p>规划问题由许多约束组成。通常，有3种类型的约束：</p><div class="itemizedlist"><ul><li><p>绝对不能打破<span class="emphasis"><em>（负）硬约束</em></span> 。例如： <span class="emphasis"><em>1个老师不能同时教授2个不同的课程</em></span> 。</p></li><li><p>如果可以避免，则不能破坏<span class="emphasis"><em>（负）软约束</em></span> 。例如： <span class="emphasis"><em>老师A不喜欢在星期五下午教书</em></span> 。</p></li><li><p>如果可能的话，应该实现<span class="emphasis"><em>积极的约束（或奖励）</em></span> 。例如： <span class="emphasis"><em>B老师喜欢在星期一早上教书</em></span> 。</p></li></ul></div><p>这些约束定义了计划问题的<span class="emphasis"><em>得分函数</em></span> 。这就是drools规则引擎发挥作用的地方： <span class="bold"><strong>使用评分规则添加约束既简单又可扩展</strong></span> 。</p><p>规划问题有很多<span class="emphasis"><em>解决方案</em></span> 。每个解决方案都有一个分数。解决方案分为3类：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>可能的解决方案</em></span>是不破坏任何约束的解决方案。规划问题往往有大量的可能解决方案。这些解决方案大多数都不值钱。</p></li><li><p><span class="emphasis"><em>可行的解决方案</em></span>是不会破坏任何（负面）硬约束的解决方案。可行解决方案的数量往往与可能解决方案的数量有关。有时没有可行的解决方案。每个可行的解决方案都是可能的解决方案。</p></li><li><p><span class="emphasis"><em>最佳解决方案</em></span>是分数最高的解决方案。规划问题往往有1个或几个最佳解决方案。始终至少有一个最佳解决方案，即使在远程情况下，由于没有可行的解决方案，它也不是可行的解决方案。</p></li></ul></div><p>Drools-solver支持多种搜索算法，以有效地遍历越来越多的可能解决方案。只需更改求解器配置，即可<span class="bold"><strong>轻松切换搜索算法</strong></span> 。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e118"></a> 1.1.2。流口水溶解器的状态</h3></div></div></div><p>Drools-solver是Drools的<span class="bold"><strong>beta</strong></span>模块。该API几乎是稳定的，但是可能会发生向后不兼容的更改。食谱叫<code class="filename">UpgradeFromPreviousVersionRecipe.txt</code>您可以轻松升级并处理版本之间的任何向后不兼容的更改。您可以在Subversion和每个发行版中找到此食谱。</p><p>您可以从<a class="ulink" href="http://www.jboss.org/drools/downloads.html">drools下载站点</a>下载Beta版本的Drools-solver。也可以在<a class="ulink" href=""></a> jboss maven存储库。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e136"></a> 1.1.3。构建drools-solver并运行示例</h3></div></div></div><p>您也可以自己从源代码轻松构建它。从subversion检出流口水，并使用Solver配置文件进行Maven 2构建：</p><pre class="programlisting">$ svn checkout http://anonsvn.jboss.org/repos/labs/labs/jbossrules/trunk/ drools
...
$ cd drools
$ mvn -Dmaven.test.skip clean install
...</pre><p>之后，您可以直接从命令行运行任何示例，例如，要运行n个皇后区示例，请运行：</p><pre class="programlisting">$ cd drools-solver/drools-solver-examples/
$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.nqueens.app.NQueensApp"
...</pre><p>您将把drools-solver与最新的，不稳定的drools规则引擎快照结合使用。如果您希望使用稳定版本的Drools规则引擎，请编辑<code class="literal">/drools-solver/pom.xml</code>并在构建和运行示例之前覆盖drools jar版本：</p><pre class="programlisting">    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.drools&lt;/groupId&gt;
                &lt;artifactId&gt;drools-core&lt;/artifactId&gt;
                &lt;version&gt;5.0.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.drools&lt;/groupId&gt;
                &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
                &lt;version&gt;5.0.1&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e154"></a> 1.2。求解器示例</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e157"></a> 1.2.1。介绍</h3></div></div></div><p>Drools-solver有几个示例。在本手册中，我们主要使用n个皇后区示例来解释drools-solver。因此，建议至少阅读有关该示例的部分。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e162"></a> 1.2.2。n个皇后区的例子</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e165"></a> 1.2.2.1。运行示例</h4></div></div></div><p>在目录中<code class="literal">/drools-solver/drools-solver-examples/</code>运行以下命令：</p><pre class="programlisting">$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.nqueens.app.NQueensApp"
...</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e175"></a> 1.2.2.2。屏幕截图</h4></div></div></div><p>这是示例的屏幕截图：</p><div class="figure"><a id="d0e180"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/screenshotNQueens.png" alt="n个皇后区示例的屏幕截图"></div></div><p class="title"><b>图1.1。n个皇后区示例的屏幕截图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e186"></a> 1.2.2.3。问题陈述</h4></div></div></div><p><span class="emphasis"><em>n皇后难题</em></span>是具有以下约束的难题：</p><div class="itemizedlist"><ul><li><p>使用n行n列的棋盘。</p></li><li><p>将n个皇后放在棋盘上。</p></li><li><p>没有2个皇后可以互相攻击。请注意，女王可以在同一水平，垂直或对角线上攻击其他任何女王。</p></li></ul></div><p>最常见的n个皇后难题是8个皇后难题，其中<span class="emphasis"><em>n = 8</em></span> 。我们将以4个皇后号谜题为主要示例来说明drools-solver。</p><p>提议的解决方案可以是：</p><div class="figure"><a id="d0e211"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Solver/partiallySolvedNQueens04Explained.png" align="middle" alt="4个皇后难题的错误解决方案"></div></div><p class="title"><b>图1.2。4个皇后难题的错误解决方案</b></p></div><br class="figure-break"><p>上面的解决方案是错误的，因为皇后A1和B0可以互相攻击（皇后B0和D0也可以）。删除皇后B0会遵守“没有2个皇后可以互相攻击”约束，但会破坏“放置n个皇后”约束。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e219"></a> 1.2.2.4。解决方案</h4></div></div></div><p>以下是正确的解决方案：</p><div class="figure"><a id="d0e224"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Solver/solvedNQueens04.png" align="middle" alt="四皇后拼图的正确解决方案"></div></div><p class="title"><b>图1.3。四皇后拼图的正确解决方案</b></p></div><br class="figure-break"><p>已满足所有约束，因此解决方案是正确的。请注意，大多数n个皇后拼图都有多种正确的解决方案。我们将专注于为给定的n找到一个正确的解决方案，而不是为给定的n找到可能的正确解的数量。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e232"></a> 1.2.2.5。问题大小</h4></div></div></div><p>这些数字可能使您对这个问题的规模有一些了解。</p><div class="table"><a id="d0e237"></a><p class="title"><b>表1.1。NQueens问题大小</b></p><div class="table-contents"><table border="1" summary="NQueens problem size"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>＃皇后区（n）</th><th>＃可能的解决方案（每个女王都是自己的专栏）</th><th>＃可行的解决方案（不同）</th><th>＃最佳解决方案（不同）</th><th>＃可能/＃最佳</th></tr></thead><tbody><tr><td>4</td><td>256</td><td>2</td><td>2</td><td>128</td></tr><tr><td>8</td><td>16777216</td><td>64</td><td>64</td><td>262144</td></tr><tr><td>16</td><td>18446744073709551616</td><td>14772512</td><td>14772512</td><td>1248720872503</td></tr><tr><td>32</td><td>1.46150163733090291820368483e + 48</td><td>？</td><td>？</td><td>？</td></tr><tr><td>64</td><td>3.94020061963944792122790401e + 115</td><td>？</td><td>？</td><td>？</td></tr><tr><td>ñ</td><td>n ^ n</td><td>？</td><td>＃可行的解决方案</td><td>？</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e320"></a> 1.2.2.6。域类图</h4></div></div></div><p>使用良好的域模型，使用drools-solver会更容易理解和解决您的问题。我们将在n个皇后区示例中使用此域模型：</p><div class="figure"><a id="d0e325"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Solver/nQueensDomainDiagram.png" align="middle" alt="NQueens域类图"></div></div><p class="title"><b>图1.4。NQueens域类图</b></p></div><br class="figure-break"><p>一种<code class="literal">Queen</code>实例具有x（其列，例如：0是A列，1是B列，...）和ay（其行，例如：0是第0行，1是第1行，...）。根据x和y，可以计算上升对角线以及下降对角线。x和y索引从棋盘的左上角开始。</p><div class="table"><a id="d0e336"></a><p class="title"><b>表1.2。域模型中显示的4个皇后难题的解决方案</b></p><div class="table-contents"><table border="1" summary="A solution for the 4 queens puzzle shown in the domain
        model"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th align="center">一个办法</th><th align="center">女王</th><th>X</th><th>ÿ</th><th>升序D（x + y）</th><th>降序D（x-y）</th></tr></thead><tbody><tr><td rowspan="4"><div class="mediaobject"><img src="images/Chapter-Solver/partiallySolvedNQueens04Explained.png"></div></td><td>A1</td><td>0</td><td>1个</td><td>1（**）</td><td>-1</td></tr><tr><td>B0</td><td>1个</td><td>0（*）</td><td>1（**）</td><td>1个</td></tr><tr><td>C2</td><td>2</td><td>2</td><td>4</td><td>0</td></tr><tr><td>D0</td><td>3</td><td>0（*）</td><td>3</td><td>3</td></tr></tbody></table></div></div><br class="table-break"><p>一个<code class="literal">NQueens</code>实例包含所有列表<code class="literal">Queen</code>实例。它是<code class="literal">Solution</code>将提供给drools-solver并从中获取的实现。请注意，在4个皇后的示例中，NQueens的<code class="literal">getN()</code>方法将始终返回4。</p><p>您可以在drools-solver-examples src发行版中找到此示例（以及其他几个示例）的源代码。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e419"></a> 1.2.3。课程安排示例</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e422"></a> 1.2.3.1。运行示例</h4></div></div></div><p>在目录中<code class="literal">/drools-solver/drools-solver-examples/</code>运行以下命令：</p><pre class="programlisting">$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.lessonschedule.app.LessonScheduleApp"
...</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e432"></a> 1.2.3.2。屏幕截图</h4></div></div></div><p>这是示例的屏幕截图：</p><div class="figure"><a id="d0e437"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/screenshotLessonSchedule.png" alt="课程表示例的屏幕截图"></div></div><p class="title"><b>图1.5。课程表示例的屏幕截图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e443"></a> 1.2.3.3。问题陈述</h4></div></div></div><p>按照以下限制安排课程：</p><div class="itemizedlist"><ul><li><p>没有老师在同一时间段上2节课</p></li><li><p>没有小组在同一时段内有2节课</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e455"></a> 1.2.4。旅游比赛示例</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e458"></a> 1.2.4.1。运行示例</h4></div></div></div><p>在目录中<code class="literal">/drools-solver/drools-solver-examples/</code>运行以下命令之一：</p><pre class="programlisting">$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.travelingtournament.app.simple.SimpleTravelingTournamentApp"
...
$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.travelingtournament.app.smart.SmartTravelingTournamentApp"
...</pre><p>智能实现的性能和伸缩性比简单实现好得多。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e470"></a> 1.2.4.2。屏幕截图</h4></div></div></div><p>这是示例的屏幕截图：</p><div class="figure"><a id="d0e475"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/screenshotTravelingTournament.png" alt="巡回锦标赛示例的屏幕截图"></div></div><p class="title"><b>图1.6。巡回锦标赛示例的屏幕截图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e481"></a> 1.2.4.3。问题陈述</h4></div></div></div><p>安排有以下严格限制的团队之间的比赛：</p><div class="itemizedlist"><ul><li><p>每队对战其他队两次：一次进入主场，一次离开</p></li><li><p>每队每天有1场比赛</p></li><li><p>任何团队最多只能连续3个主场比赛或连续3个客场比赛</p></li><li><p>没有中继器：相同2支球队的2场连续比赛（因此，每支球队主场出战一次</p></li></ul></div><p>以及以下软约束：</p><div class="itemizedlist"><ul><li><p>最小化所有团队的总路程。</p></li></ul></div><p><a class="ulink" href="http://mat.gsia.cmu.edu/TOURN/">您可以在此处找到详细说明以及该问题的多条记录。</a></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e508"></a> 1.2.4.4。问题大小</h4></div></div></div><p>这些数字可能使您对这个问题的规模有一些了解。</p><div class="table"><a id="d0e513"></a><p class="title"><b>表1.3。巡回锦标赛问题大小</b></p><div class="table-contents"><table border="1" summary="Traveling tournament problem size"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>＃队</th><th>＃ 天</th><th>＃ 火柴</th><th>＃可能的解决方案（简单）</th><th>＃可能的解决方案（智能）</th><th>＃可行的解决方案</th><th>＃最佳解决方案</th></tr></thead><tbody><tr><td>4</td><td>6</td><td>12</td><td>2176782336</td><td><= 518400</td><td>？</td><td>1个</td></tr><tr><td>6</td><td>10</td><td>30</td><td>1000000000000000000000000000000</td><td><= 47784725839872000000</td><td>？</td><td>1个</td></tr><tr><td>8</td><td>14</td><td>56</td><td>1.52464943788290465606136043e + 64</td><td><= 5.77608277425558771434498864e + 43</td><td>？</td><td>1个</td></tr><tr><td>10</td><td>18岁</td><td>90</td><td>9.43029892325559280477052413e + 112</td><td><= 1.07573451027871200629339068e + 79</td><td>？</td><td>1个</td></tr><tr><td>12</td><td>22</td><td>132</td><td>1.58414112478195320415135060e + 177</td><td><= 2.01650616733413376416949843e + 126</td><td>？</td><td>1个</td></tr><tr><td>14</td><td>26</td><td>182</td><td>3.35080635695103223315189511e + 257</td><td><= 1.73513467024013808570420241e + 186</td><td>？</td><td>1个</td></tr><tr><td>16</td><td>30</td><td>240</td><td>3.22924601799855400751522483e + 354</td><td><= 2.45064610271441678267620602e + 259</td><td>？</td><td>1个</td></tr><tr><td>ñ</td><td>2 *（n-1）</td><td>n *（n-1）</td><td>（2 *（n-1））^（n *（n-1））</td><td><=（（（（2 *（n-1））！）^（n / 2））</td><td>？</td><td>1个</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e654"></a> 1.2.5。ITC2007考试实例</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e657"></a> 1.2.5.1。运行示例</h4></div></div></div><p>在目录中<code class="literal">/drools-solver/drools-solver-examples/</code>运行以下命令：</p><pre class="programlisting">$ mvn exec:exec -Dexec.mainClass="org.drools.solver.examples.itc2007.examination.app.ExaminationApp"
...</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e667"></a> 1.2.5.2。屏幕截图</h4></div></div></div><p>这是示例的屏幕截图：</p><div class="figure"><a id="d0e672"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/screenshotExamination.png" alt="考试示例的屏幕截图"></div></div><p class="title"><b>图1.7。考试示例的屏幕截图</b></p></div><br class="figure-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e678"></a> 1.2.5.3。问题陈述</h4></div></div></div><p>将每次考试安排在一个时段和一个房间中。多个考试可以在同一期间共享同一房间。</p><p>有许多不可打破的硬约束：</p><div class="itemizedlist"><ul><li><p>考试冲突：2个共享学生的考试不应同时进行。</p></li><li><p>房间容量：房间的座位容量应始终足够。</p></li><li><p>期间持续时间：一个期间的持续时间应足以应付所有考试。</p></li><li><p>与期间相关的硬约束应得到满足：</p><div class="itemizedlist"><ul><li><p>巧合：2次考试应使用相同的时间段（但也可以使用其他房间）。</p></li><li><p>排除：两次考试不应使用同一时期。</p></li><li><p>之后：在另一个考试期之后的一段时间内应进行1次考试。</p></li></ul></div></li><li><p>与房间相关的硬约束应满足：</p><div class="itemizedlist"><ul><li><p>独家：1项考试不必与其他任何考试共用一间房。</p></li></ul></div></li></ul></div><p>还有一些软约束应该最小化（每个都有参数化惩罚）：</p><div class="itemizedlist"><ul><li><p>连续2次考试。</p></li><li><p>一天进行2次考试。</p></li><li><p>期间传播：两个共享学生的考试应该分开多个时期。</p></li><li><p>混合时间长度：2个共享房间的考试不应具有不同的时间长度。</p></li><li><p>头等大事：大型考试应在日程安排中提前安排。</p></li><li><p>期限罚款：某些期限在使用时会受到罚款。</p></li><li><p>房间罚款：使用某些房间时会受到罚款。</p></li></ul></div><p>它使用现实生活中的大学的大型测试数据集。</p><p><a class="ulink" href="http://www.cs.qub.ac.uk/itc2007/examtrack/exam_track_index.htm">您可以在此处找到有关此问题的更详细描述。</a></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e744"></a> 1.2.5.4。问题大小</h4></div></div></div><p>这些数字可能使您对这个问题的规模有一些了解。</p><div class="table"><a id="d0e749"></a><p class="title"><b>表1.4。考试题目大小</b></p><div class="table-contents"><table border="1" summary="Examination problem size"><colgroup><col><col><col><col><col><col><col><col></colgroup><thead><tr><th>组</th><th>＃ 学生们</th><th>＃考试/主题</th><th>＃个时期</th><th>＃间</th><th>＃ 可能的解决方案</th><th>＃可行的解决方案</th><th>＃最佳解决方案</th></tr></thead><tbody><tr><td>exam_comp_set1</td><td>7883</td><td>607</td><td>54</td><td>7</td><td>1.11000574474221096210367623e + 1052</td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set2</td><td>12484</td><td>870</td><td>40</td><td>49</td><td>2.86903028422562597982749122e + 5761</td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set3</td><td>16365</td><td>934</td><td>36</td><td>48</td><td>5.74648299136737635070728795e + 5132</td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set4</td><td>4421</td><td>273</td><td>21</td><td>1个</td><td>1.44349601026818742275741580e + 51</td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set5</td><td>8719</td><td>1018</td><td>42</td><td>3</td><td> </td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set6</td><td>7909</td><td>242</td><td>16</td><td>8</td><td> </td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set7</td><td>13795</td><td>1096</td><td>80</td><td>28</td><td> </td><td>？</td><td>1个</td></tr><tr><td>exam_comp_set8</td><td>7718</td><td>598</td><td>80</td><td>8</td><td> </td><td>？</td><td>1个</td></tr><tr><td>？</td><td>s</td><td>Ť</td><td>p</td><td>[R</td><td>（t ^ p）^ r</td><td>？</td><td>1个</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e921"></a> 1.2.5.5。域类图</h4></div></div></div><p>您可以在下面看到主要的考试领域类别：</p><div class="figure"><a id="d0e926"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/examinationDomainDiagram.png" alt="考试领域类图"></div></div><p class="title"><b>图1.8。考试领域类图</b></p></div><br class="figure-break"><p>请注意，我们已将考试概念分为<code class="literal">Exam</code>类和一个<code class="literal">Topic</code>类。的<code class="literal">Exam</code>实例在求解过程中发生变化时（如果获得另一个周期或空间）。的<code class="literal">Topic</code> ， <code class="literal">Period</code>和<code class="literal">Room</code>实例在求解过程中永远不会改变。</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e952"></a> 1.3。求解器配置</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e955"></a> 1.3.1。求解器的类型</h3></div></div></div><p>不同的求解器以不同的方式解决问题。每种类型都有优点和缺点。我们将在此处粗略讨论一些求解器类型。您可以安全地跳过此部分。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e960"></a> 1.3.1.1。蛮力</h4></div></div></div><p>暴力破解通常通过创建搜索树来创建和评估所有可能的解决方案。</p><p>好处：</p><div class="itemizedlist"><ul><li><p>它找到了最佳解决方案。如果多于1个最优解，它将找到所有最优解。</p></li><li><p>它很容易实现。</p></li></ul></div><p>缺点：</p><div class="itemizedlist"><ul><li><p>它具有可怕的性能和可伸缩性。由于时间限制，对于现实世界的问题最不可用。</p></li></ul></div><p>当前在drools-solver中未实现暴力破解。但是我们计划在将来实现它，以作为验证其他求解器类型输出的参考。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e982"></a> 1.3.1.2。分支定界</h4></div></div></div><p>分支定界是对蛮力的一种改进，因为它会删去解决方案的子集，这些解决方案不能比当时已经找到的最佳解决方案更好。</p><p>好处：</p><div class="itemizedlist"><ul><li><p>它找到了最佳解决方案。如果有多个最优解，则可以根据需要找到所有最优解。</p></li></ul></div><p>缺点：</p><div class="itemizedlist"><ul><li><p>它的缩放比例仍然很差。</p></li></ul></div><p>当前在drools-solver中未实现分支和绑定。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1001"></a> 1.3.1.3。单面</h4></div></div></div><p>Simplex将所有约束和数据转换为一个大方程，然后将其转换为数学函数而无需局部最优。然后，通过找到该数学函数的最佳值，找到规划问题的最佳解决方案。</p><p>好处：</p><div class="itemizedlist"><ul><li><p>它找到了最佳解决方案。</p></li></ul></div><p>缺点：</p><div class="itemizedlist"><ul><li><p>实现约束通常是相当复杂和数学的。</p></li></ul></div><p>Drools-solver当前不实现单纯形。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1020"></a> 1.3.1.4。本地搜索（tabu搜索，模拟退火等）</h4></div></div></div><p>本地搜索从初始解决方案开始，然后将单个解决方案发展为越来越好的解决方案。它使用解决方案的单一搜索路径。在此路径上的每个解决方案上，它都会评估该解决方案上的许多可能动作，并应用最合适的动作来迈向下一个解决方案。</p><p>本地搜索的工作原理很像人类计划员：它使用单一搜索路径，并四处移动事实以找到一个好的可行解决方案。</p><p>一个简单的局部搜索很容易陷入局部最优，但是改进（例如禁忌搜索和模拟退火）解决了这个问题。</p><p>好处：</p><div class="itemizedlist"><ul><li><p>实现约束是相对简单自然的（至少在drools-solver的实现中）。</p></li><li><p>即使添加了额外的约束（至少在drools-solver的实现中），它也是非常可伸缩的。</p></li><li><p>通常，它需要担心负硬约束较少，因为移动模式可以满足许多负硬约束。</p></li></ul></div><p>缺点：</p><div class="itemizedlist"><ul><li><p>它不知道何时找到了最佳解决方案。</p></li><li><p>如果最佳分数未知（通常是这种情况），则必须告知何时停止搜索（例如，基于花费的时间，用户输入等）。</p></li></ul></div><p>Drools-solver实现本地搜索，包括禁忌搜索和模拟退火。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1052"></a> 1.3.2。求解器界面</h3></div></div></div><p>在drools-solver中实现的每个内置求解器都实现了<code class="literal">Solver</code>接口：</p><pre class="programlisting">public interface Solver {

    void setStartingSolution(Solution solution);

    Score getBestScore();
    Solution getBestSolution();
    
    void solve();

    // ...

}</pre><p>使用drools-solver解决规划问题包括4个步骤：</p><div class="orderedlist"><ol type="1"><li><p>构建一个求解器，例如针对NQueens拼图的禁忌搜索求解器。</p></li><li><p>在求解器上设置一个初始解，例如一个4 Queens拼图实例。</p></li><li><p>解决这个问题。</p></li><li><p>获得求解器找到的最佳解决方案。</p></li></ol></div><p>一种<code class="literal">Solver</code>当前应该直接从单个线程访问。在将来的发行版中将增加从另一个线程访问它的支持，例如尽早解决问题或实时更改问题事实。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1082"></a> 1.3.3。建立一个求解器</h3></div></div></div><p>您可以建立一个<code class="literal">Solver</code>具有的实例<code class="literal">XmlSolverConfigurer</code> 。使用求解器配置xml文件对其进行配置：</p><pre class="programlisting">    XmlSolverConfigurer configurer = new XmlSolverConfigurer();
    configurer.configure("/org/drools/solver/examples/nqueens/solver/nqueensSolverConfig.xml");
    Solver solver = configurer.buildSolver();</pre><p>基本的求解器配置文件如下所示：</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;localSearchSolver&gt;
    &lt;scoreDrl&gt;/org/drools/solver/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
    &lt;scoreDefinition&gt;
        &lt;scoreDefinitionType&gt;SIMPLE&lt;/scoreDefinitionType&gt;
    &lt;/scoreDefinition&gt;
    &lt;finish&gt;
        &lt;feasableScore&gt;0&lt;/feasableScore&gt;
    &lt;/finish&gt;
    &lt;selector&gt;
        &lt;moveFactoryClass&gt;org.drools.solver.examples.nqueens.solver.NQueensMoveFactory&lt;/moveFactoryClass&gt;
    &lt;/selector&gt;
    &lt;accepter&gt;
        &lt;completeSolutionTabuSize&gt;1000&lt;/completeSolutionTabuSize&gt;
    &lt;/accepter&gt;
    &lt;forager&gt;
        &lt;foragerType&gt;MAX_SCORE_OF_ALL&lt;/foragerType&gt;
    &lt;/forager&gt;
&lt;/localSearchSolver&gt;</pre><p>这是n个皇后的禁忌搜索配置。我们将在本手册的后面部分解释配置的各个部分。</p><p><span class="bold"><strong>Drools-solver使得仅通过更改配置即可相对轻松地切换求解器类型。</strong></span> 甚至还有一个基准实用程序，使您可以相互进行不同的配置并报告最适合您问题的配置。例如，您可以在4个皇后和64个皇后上播放禁忌搜索与模拟退火。</p><p>求解器只有一个<code class="literal">Random</code>实例。一些求解器配置比其他配置使用更多实例。例如，模拟退火高度依赖于随机数，而禁忌搜索仅依赖于随机数来处理得分关系。无论如何，建议您在测试期间进行设置<code class="literal">Random</code>实例，因此您的测试是可重复的。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1113"></a> 1.3.4。解决方案界面</h3></div></div></div><p>一个求解器一次只能解决一个问题。</p><p>您需要首先提出问题<code class="literal">Solution</code>实例到求解器。</p><p>您需要实施<code class="literal">Solution</code>接口：</p><pre class="programlisting">public interface Solution {

    Collection&lt;? extends Object&gt; getFacts();

    Solution cloneSolution();

}</pre><p>例如，一个NQueens实例仅保存所有皇后的列表：</p><pre class="programlisting">public class NQueens implements Solution {

    private List&lt;Queen&gt; queenList;

    // ...

}</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1134"></a> 1.3.4.1。getFacts方法</h4></div></div></div><p>由返回的所有对象<code class="literal">getFacts()</code>方法将断言到流口水的工作内存中。得分规则可以使用这些事实。例如， <code class="literal">NQueens</code>只返回全部<code class="literal">Queen</code>实例。</p><pre class="programlisting">    public Collection&lt;? extends Object&gt; getFacts() {
        return queenList;
    }</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1150"></a> 1.3.4.2。cloneSolution方法</h4></div></div></div><p>大多数求解器使用<code class="literal">cloneSolution()</code>每次遇到新的最佳解决方案时克隆解决方案的方法。的<code class="literal">NQueens</code>实现只是克隆所有<code class="literal">Queen</code>实例：</p><pre class="programlisting">    public NQueens cloneSolution() {
        NQueens clone = new NQueens();
        List&lt;Queen&gt; clonedQueenList = new ArrayList&lt;Queen&gt;(queenList.size());
        for (Queen queen : queenList) {
            clonedQueenList.add(queen.clone());
        }
        clone.queenList = clonedQueenList;
        return clone;
    }</pre><p>的<code class="literal">cloneSolution()</code>方法应该克隆的数量不得少于且不小于<code class="literal">Solution</code>在解决过程中可能会改变。例如，在课程表示例中，课程被克隆，但是教师，组和时间段未被克隆，因为在解决过程中仅课程的指定时间段发生了变化：</p><pre class="programlisting">    /**
     * Clone will only deep copy the lessons
     */
    public LessonSchedule cloneSolution() {
        LessonSchedule clone = new LessonSchedule();
        clone.timeslotList = timeslotList; // No Deep copy
        clone.teacherList = teacherList; // No Deep copy
        clone.groupList = groupList; // No Deep copy
        List&lt;Lesson&gt; clonedLessonList = new ArrayList&lt;Lesson&gt;(lessonList.size());
        for (Lesson lesson : lessonList) {
            clonedLessonList.add(lesson.clone());
        }
        clone.lessonList = clonedLessonList;
        return clone;
    }</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1176"></a> 1.3.5。起始解决方案</h3></div></div></div><p>首先，您需要制定一个初始解决方案并将其设置在求解器上：</p><pre class="programlisting">solver.setStartingSolution(startingSolution);</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1183"></a> 1.3.6。一个简单的填充算法</h3></div></div></div><p>对于4个皇后，我们使用一种简单的填充算法，该算法会创建一个初始解决方案，其中所有皇后都位于不同的x和相同的y（y = 0）上。</p><div class="figure"><a id="d0e1188"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/unsolvedNQueens04.png" alt="4个皇后难题的入门解决方案"></div></div><p class="title"><b>图1.9。4个皇后难题的入门解决方案</b></p></div><br class="figure-break"><p>这是我们生成它的方式：</p><pre class="programlisting">    private NQueens createNQueens(int n) {
        NQueens nQueens = new NQueens();
        nQueens.setId(0L);
        List&lt;Queen&gt; queenList = new ArrayList&lt;Queen&gt;(n);
        for (int i = 0; i &lt; n; i++) {
            Queen queen = new Queen();
            queen.setId((long) i);
            queen.setX(i); // Different column
            queen.setY(0); // Same row
            queenList.add(queen);
        }
        nQueens.setQueenList(queenList);
        return nQueens;
    }</pre><p>起始解决方案可能远非最佳方案（甚至不可行）。在这里，这实际上是最糟糕的解决方案。但是，无论如何，我们会让求解器为我们找到更好的解决方案。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1200"></a> 1.3.6.1。StartingSolutionInitializer</h4></div></div></div><p>对于大问题，可以使用简单的填充算法，例如<code class="literal">createNQueens(int)</code>不够。从不良的起始解决方案开始的（本地搜索）求解器会浪费大量时间来获得初始化程序算法可以在那部分时间内生成的解决方案。</p><p>通常，初始化器算法的工作原理如下：</p><div class="itemizedlist"><ul><li><p>它根据一些一般规则，例如按考试学生人数，对队列中未计划的元素进行排序。</p></li><li><p>接下来，按照从队列中来的顺序对它们进行计划。每个元素都放置在最好的，仍然可用的位置。</p></li><li><p>它不会更改已经计划的元素。当队列为空并且计划了所有元素时，它将退出。</p></li></ul></div><p>这样的算法非常确定：它确实很快速，但是您不能给它更多的时间来生成更好的解决方案。在某些情况下，它生成的解决方案是可行的，但在大多数情况下，它是不可行的。您将需要一个真正的求解器来获得可行的或更优化的解决方案。不过，您将希望使用这样的初始化程序，以便为真正的求解程序提供一个重要的起点。您可以通过实施<code class="literal">StartingSolutionInitializer</code>接口：</p><pre class="programlisting">public interface StartingSolutionInitializer extends SolverAware {

    boolean isSolutionInitialized(Solution solution);

    void initializeSolution(Solution solution);

}</pre><p>您需要在求解器上设置一个（未初始化的）解决方案。求解器启动后，将首先调用<code class="literal">StartingSolutionInitializer</code>初始化解决方案。如果<code class="literal">StartingSolutionInitializer</code>添加，编辑或删除它需要将此信息通知WorkingMemory的事实。它可以在初始化过程中使用分数计算。</p><p>这是有关如何添加<code class="literal">StartingSolutionInitializer</code>到配置：</p><pre class="programlisting">&lt;localSearchSolver&gt;
    ...
    &lt;startingSolutionInitializerClass&gt;org.drools.solver.examples.itc2007.examination.solver.solution.initializer.ExaminationStartingSolutionInitializer&lt;/startingSolutionInitializerClass&gt;
    ...
&lt;/localSearchSolver&gt;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1242"></a> 1.3.7。解决问题</h3></div></div></div><p>一旦有了求解器和起始解决方案，就可以轻松解决问题：</p><pre class="programlisting">    solver.setStartingSolution(startingSolution);
    solver.solve();
    Solution bestSolution = solver.getBestSolution();</pre><p>的<code class="literal">solve()</code>方法将花费很长时间（取决于问题大小和求解器配置）。求解器将记住（实际上是克隆）在求解过程中遇到的最佳解决方案。取决于许多因素（包括问题大小，允许求解器工作多长时间，使用哪种求解器类型，...），最佳解决方案将是可行的甚至是最佳解决方案。</p><div class="figure"><a id="d0e1254"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/solvedNQueens04.png" alt="四个皇后难题的最佳解决方案（也是最佳解决方案）"></div></div><p class="title"><b>图1.10。四个皇后难题的最佳解决方案（也是最佳解决方案）</b></p></div><br class="figure-break"><p>解决问题后，您可以重用相同的求解器实例来解决另一个问题（相同问题类型）。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1262"></a> 1.4。使用规则引擎计算分数</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1265"></a> 1.4.1。基于规则的分数计算</h3></div></div></div><p>计划问题的分数计算基于约束（例如硬约束，软约束，奖励等）。诸如流口水之类的规则引擎使将这些约束作为<span class="emphasis"><em>评分规则</em></span>轻松实现。</p><p>这是在流口水中实现为得分规则的约束示例：</p><pre class="programlisting">rule "multipleQueensHorizontal"
    when
        $q1 : Queen($id : id, $y : y);
        $q2 : Queen(id &gt; $id, y == $y);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensHorizontal", $q1, $q2));
end</pre><p>该得分规则将每2个皇后触发一次，且每次得分相同<code class="literal">y</code> 。的<code class="literal">(id > $id)</code>需要确保两个皇后A和B只能对（A，B）射击，而不能对（B，A），（A，A）或（B，B）射击。让我们仔细研究一下4个皇后区的起始解决方案的得分规则：</p><div class="figure"><a id="d0e1285"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/unsolvedNQueens04.png" alt="4个皇后难题的入门解决方案"></div></div><p class="title"><b>图1.11。4个皇后难题的入门解决方案</b></p></div><br class="figure-break"><p>在此初始解决方案中，multipleQueensHorizontal得分规则将对6个皇后夫妇生效：（A，B），（A，C），（A，D），（B，C），（B，D）和（C，D） 。由于没有一个女王/王后在同一条垂直线或对角线上，因此该初始解的分数为<code class="literal">-6</code> 。4个皇后的最佳解决方案得分为<code class="literal">0</code> 。</p><p>您需要在求解器配置中添加得分规则drl文件，例如：</p><pre class="programlisting">    &lt;scoreDrl&gt;/org/drools/solver/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;</pre><p>您可以添加多个<code class="literal"><scoreDrl></code>必要时输入。</p><p>建议在正向链接模式下使用流口水（这是默认行为），因为对于求解器实施，这将在每次解决方案评估中产生<span class="emphasis"><em>基于增量的分数计算</em></span>而不是完整分数计算的效果。例如，如果一个女王离开y <code class="literal">0</code>至<code class="literal">3</code> ，就不必为带有y的皇后重新计算“在同一条水平线上有多个皇后”约束<code class="literal">1</code>要么<code class="literal">2</code> 。这是巨大的性能提升。<span class="bold"><strong>Drools-solver可以为您带来巨大的性能提升，而无需强迫您编写非常复杂的基于增量的分数计算算法。</strong></span> 只是让流口水的统治者做艰苦的工作。</p><p><span class="bold"><strong>添加更多约束很<span class="bold"><strong>容易且</strong></span>可扩展</strong></span> （一旦您了解了drools规则语法）。这使您可以轻松地以合理的性能成本在硬约束得分规则之上添加一堆软约束得分规则。例如，对于货运路线问题，您可以添加软约束来避免高峰时段出现某些标记的高速公路。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1335"></a> 1.4.2。ScoreDefinition界面</h3></div></div></div><p>的<code class="literal">ScoreDefinition</code>界面定义分数表示。分数必须是<code class="literal">Score</code>实例和实例类型（例如<code class="literal">DefaultHardAndSoftScore</code> ）必须在整个求解器运行期间保持稳定。</p><p>求解器旨在找到分数最高的解决方案。<span class="emphasis"><em>最好的解决方案</em></span>是在解决过程中遇到的分数最高的解决方案。</p><p>大多数计划问题倾向于使用负分数（打破了负面约束的数量），而不可能的完美分数为0。这就解释了为什么4个皇后的解决方案得分是可以互相攻击的皇后夫妇数量的负数。</p><p>一种<code class="literal">ScoreDefinition</code>实例在求解器配置中配置：</p><pre class="programlisting">    &lt;scoreDefinition&gt;
        &lt;scoreDefinitionType&gt;SIMPLE&lt;/scoreDefinitionType&gt;
    &lt;/scoreDefinition&gt;</pre><p>有几个内置<code class="literal">ScoreDefinition</code>实现：</p><div class="itemizedlist"><ul><li><p>简单： <code class="literal">SimpleScoreDefinition</code>定义<code class="literal">Score</code>作为一个<code class="literal">SimpleScore</code>例如，它具有单个int值<code class="literal">-123</code> 。</p></li><li><p>HARD_AND_SOFT： <code class="literal">HardAndSoftScoreDefinition</code>定义<code class="literal">Score</code>作为一个<code class="literal">HardAndSoftScore</code>例如，它具有硬int值和软int值<code class="literal">-123hard/-456soft</code> 。</p></li></ul></div><p>您可以实现自己的<code class="literal">ScoreDefinition</code> ，尽管内置分数定义足以满足大多数需求。</p><p>一种<code class="literal">ScoreCalculator</code>实例作为全局调用被断言到工作内存中<code class="literal">scoreCalculator</code> 。您的评分规则需要（间接）更新该实例。通常，您将一个规则作为其他规则的汇总来更新分数：</p><pre class="programlisting">global SimpleScoreCalculator scoreCalculator;

rule "multipleQueensHorizontal"
    when
        $q1 : Queen($id : id, $y : y);
        $q2 : Queen(id &gt; $id, y == $y);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensHorizontal", $q1, $q2));
end

// multipleQueensVertical is obsolete because it is always 0

rule "multipleQueensAscendingDiagonal"
    when
        $q1 : Queen($id : id, $ascendingD : ascendingD);
        $q2 : Queen(id &gt; $id, ascendingD == $ascendingD);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensAscendingDiagonal", $q1, $q2));
end

rule "multipleQueensDescendingDiagonal"
    when
        $q1 : Queen($id : id, $descendingD : descendingD);
        $q2 : Queen(id &gt; $id, descendingD == $descendingD);
    then
        insertLogical(new UnweightedConstraintOccurrence("multipleQueensDescendingDiagonal", $q1, $q2));
end

rule "hardConstraintsBroken"
    when
        $occurrenceCount : Number() from accumulate(
            $unweightedConstraintOccurrence : UnweightedConstraintOccurrence(),
            count($unweightedConstraintOccurrence)
        );
    then
        scoreCalculator.setScore(- $occurrenceCount.intValue());
end</pre><p>（可选）您还可以通过将每个得分规则的计数与其权重相乘来不同地权衡约束。例如，在货运路线中，可以使5个中断的“避免交叉路口”软约束的数量最多等于1个中断的“避免在高峰时间避开高速公路”软约束的数量。这使您的业务分析师可以轻松地调整他们认为合适的评分功能。</p><p>这是所有使用单个模式编写的NQueens约束的示例，使用多个模式累加并使MultipleQueensHorizontal约束超过其他约束5倍：</p><pre class="programlisting">// Warning: This currently triggers backwards chaining instead of forward chaining and seriously hurts performance and scalability.
rule "constraintsBroken"
    when
        $multipleQueensHorizontal : Long()
        from accumulate(
            $q1 : Queen($id : id, $y : y)
            and Queen(id &gt; $id, y == $y),
           count($q1)
        );
        $multipleQueensAscendingDiagonal : Long()
        from accumulate(
            $q2 : Queen($id : id, $ascendingD : ascendingD)
            and Queen(id &gt; $id, ascendingD == $ascendingD),
           count($q2)
        );
        $multipleQueensDescendingDiagonal : Long()
        from accumulate(
            $q3 : Queen($id : id, $descendingD : descendingD)
            and Queen(id &gt; $id, descendingD == $descendingD),
           count($q3)
        );
    then
        scoreCalculator.setScore(- (5 * $multipleQueensHorizontal) - $multipleQueensAscendingDiagonal - $multipleQueensDescendingDiagonal);
end</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1420"></a> 1.4.3。技巧和窍门</h3></div></div></div><div class="itemizedlist"><ul><li><p>如果您知道某个约束永远不会被打破，那么就不要为它写分数规则。例如，n个皇后区示例没有“ multipleQueensVertical”规则，因为皇后区的<code class="literal">x</code>永不改变，起始解决方案将每个皇后放在不同的位置<code class="literal">x</code> 。这往往会带来巨大的性能提升，这不仅是因为得分函数更快，而且还主要是因为大多数求解器实现将花费较少的时间来评估不可行的解决方案。</p></li><li><p>注意分数陷阱。得分陷阱是一种状态，在该状态下，需要执行多个动作来解决或降低单个约束出现的权重。分数陷阱的一些示例：</p><div class="itemizedlist"><ul><li><p>如果您每张桌子需要2位医生，但一次只移动1位医生，那么求解器将没有动力将医生移动到没有医生的桌子上。在您的评分功能中，惩罚没有医生的桌子比只有一名医生的桌子多。</p></li><li><p>如果仅将表添加为ConstraintOccurrence的原因，而忘记了jobType（是医生或政客），则求解器将无法将医生转移到缺少医生和政客的表上。</p></li></ul></div></li><li><p>如果您使用禁忌搜索，请将其与<code class="literal">relativeSelection</code>选择器。需要一些时间来调整<code class="literal">relativeSelection</code> 。</p></li><li><p>验证您的分数计算是否正确<code class="literal">Number</code>类型。如果您要计算整数值的总和，请不要让流口水使用Double's，否则会损害性能。求解器实现通常会花费其大部分执行时间来运行评分功能。</p></li><li><p>永远记住，过早的优化是万恶之源。确保您的设计足够灵活以允许基于配置的调整。</p></li><li><p>当前，不允许流口水向后链而不是向前链，因此避免查询。它杀死可笑。</p></li><li><p>当前，不允许流口水切换到MVEL模式以提高性能。您可以通过使用<code class="literal">eval</code>在得分规则中，例如： <code class="literal">eval(day.getIndex() == $day1.getIndex() + 3)</code> 。</p></li><li><p>为了获得最佳性能，请至少使用Java 1.6并始终使用服务器模式（ <code class="literal">java -server</code> ）。通过从Java 1.5切换到1.6，可以看到性能提高了30％，而通过打开服务器模式，性能提高了50％。</p></li><li><p>如果要进行性能测试，请始终记住JVM需要预热。在开始进行基准测试之前，请先加载您的求解器并进行短期运行。</p></li></ul></div><p>如果您尚未弄清楚，性能（和可伸缩性）对于解决计划问题非常重要。耗时一天才能找到可行解决方案的实时货运路线求解器有什么用？即使是看起来很小巧的问题，也可能掩盖巨大的问题。例如，他们可能仍然不知道只有10个旅行队的旅行锦标赛问题的最佳解决方案。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1484"></a> 1.5。本地搜索求解器</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1487"></a> 1.5.1。总览</h3></div></div></div><p>对于计划问题，许多可能的解决方案都令人大跌眼镜。例如：</p><div class="itemizedlist"><ul><li><p>4个皇后区有256种可能的解决方案（ <code class="literal">n ^ n</code> ）和2个最佳解决方案。</p></li><li><p>5个皇后区有3125种可能的解决方案（ <code class="literal">n ^ n</code> ）和1个最佳解决方案。</p></li><li><p>8个皇后区有16777216个可能的解决方案（ <code class="literal">n ^ n</code> ）和92个最佳解决方案。</p></li><li><p>大多数现实生活中的规划问题都有数量惊人的可能解决方案，而只有一种最佳解决方案。</p></li></ul></div><p>检查每个可能的解决方案（即使有修剪）的算法也可以针对单个实际计划问题轻松运行数年。大多数时候，我们对在有限的时间内找到可行的解决方案感到满意。本地搜索倾向于相对快速地找到可行的解决方案。因为它的行为非常像人类，所以编程也很自然。</p><p>本地搜索解决了一个问题，即采用当前解决方案以将其更改为更好的解决方案。它会执行该次数，直到对解决方案感到满意为止。它从起始解决方案开始。</p><p>事实证明，本地搜索算法和drools规则引擎是一个非常不错的组合，因为：</p><div class="itemizedlist"><ul><li><p>诸如Drools之类的规则引擎<span class="bold"><strong>非常适合计算</strong></span>计划问题解决方案<span class="bold"><strong>的分数</strong></span> 。它使添加附加的软约束或硬约束变得很容易，例如“老师每天不应教超过7个小时的时间”。但是，它往往过于复杂以致于无法实际找到新的解决方案。</p></li><li><p>本地搜索算法<span class="bold"><strong>非常</strong></span>适合为规划问题<span class="bold"><strong>找到新的改进解决方案</strong></span> ，而不会强求所有可能性。但是，它需要知道解决方案的分数，并且通常不支持计算该分数。</p></li></ul></div><p>Drools-solver的本地搜索实现将两者结合在一起。最重要的是，它还为基准测试等提供了额外的支持。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1535"></a> 1.5.2。一个动作</h3></div></div></div><p>移动是从解决方案A到解决方案B的变化。例如，下面您可以看到在4个皇后的起始解决方案上的单个移动将单个皇后移动到另一行：</p><div class="figure"><a id="d0e1540"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/singleMoveNQueens04.png" alt="一招（以4个皇后为例）"></div></div><p class="title"><b>图1.12。一招（以4个皇后为例）</b></p></div><br class="figure-break"><p>举动可以产生大小影响。在上面的示例中，女王<span class="emphasis"><em>C0到C2</em></span>的移动很小。一些动作是相同的动作类型。以下是n个皇后区移动类型的一些可能性：</p><div class="itemizedlist"><ul><li><p>将一个女王/王后移到另一行。这是一个小动作。例如，将女王<span class="emphasis"><em>C0移到C2</em></span> 。</p></li><li><p>将所有皇后区上下移动若干行。这是一个大动作。</p></li><li><p>将一个女王/王后移到另一列。这是一个小动作。例如，将女王<span class="emphasis"><em>C2移到A0</em></span> （将其放置在女王A0的顶部）。</p></li><li><p>在板的特定行和列处添加一个女王。</p></li><li><p>从板上卸下一个女王。</p></li></ul></div><p>因为我们已经决定所有皇后都将一直在棋盘上，并且每个皇后都有一个指定的列（出于性能方面的考虑），所以在我们的示例中，仅前两种移动类型可用。此外，我们在示例中仅使用第一种移动类型，因为我们认为它具有最佳性能，但是欢迎您证明我们是错误的。</p><p>您的每种移动类型都将是<code class="literal">Move</code>接口：</p><pre class="programlisting">public interface Move {

    boolean isMoveDoable(EvaluationHandler evaluationHandler);

    Move createUndoMove(EvaluationHandler evaluationHandler);

    void doMove(EvaluationHandler evaluationHandler);

}</pre><p>让我们来看看<code class="literal">Move</code> 4个皇后区的实现，将一个皇后区移到另一行：</p><pre class="programlisting">public class YChangeMove implements Move {

    private Queen queen;
    private int toY;

    public YChangeMove(Queen queen, int toY) {
        this.queen = queen;
        this.toY = toY;
    }

    // ... see below

}</pre><p>的实例<code class="literal">YChangeMove</code>将女王/王后从当前y移到另一个y。</p><p>Drool-solver称为<code class="literal">doMove(WorkingMemory)</code>做招的方法。的<code class="literal">Move</code>实现必须将其对解决方案事实所做的任何更改通知工作内存：</p><pre class="programlisting">    public void doMove(WorkingMemory workingMemory) {
        FactHandle queenHandle = workingMemory.getFactHandle(queen);
        workingMemory.modifyRetract(queenHandle); // before changes are made
        queen.setY(toY);
        workingMemory.modifyInsert(queenHandle, queen); // after changes are made
    }</pre><p>Drools-solver禁用影子事实以提高性能，因此您不能使用<code class="literal">workingMemory.update(FactHandle, Object)</code>方法，您需要调用<code class="literal">workingMemory.modifyRetract(FactHandle)</code>修改事实和方法之前的方法<code class="literal">workingMemory.modifyInsert(FactHandle, Object)</code>事实修改后的方法。请注意，您可以在单个移动中更改多个事实，并有效地创建一个大移动（也称为粗粒度移动）。</p><p>Drools-solver通过调用以下命令自动过滤掉<span class="emphasis"><em>不可行的动作</em></span> <code class="literal">isDoable(WorkingMemory)</code>方法。一个<span class="emphasis"><em>不可行的举动</em></span>是：</p><div class="itemizedlist"><ul><li><p>此举不会改变当前解决方案。例如，将女王B0移到第0行是不可行的。</p></li><li><p>在当前解决方案上不可能采取的行动。例如，将女王B0移至第10行是不可行的，因为这会将其移出董事会限制。</p></li></ul></div><p>在n个皇后示例中，将皇后从当前行移到同一行的举动是不可行的：</p><pre class="programlisting">    public boolean isMoveDoable(WorkingMemory workingMemory) {
        int fromY = queen.getY();
        return fromY != toY;
    }</pre><p>因为我们不会产生可以使皇后移动超出棋盘限制的举动，所以我们无需进行检查。当前不可行的举动可以在以后的解决方案中可行。</p><p>每个动作都有一个<span class="emphasis"><em>撤销动作</em></span> ：一个动作（通常是同一类型），其作用完全相反。在上面的示例中， <span class="emphasis"><em>C0到C2</em></span>的撤消移动将是<span class="emphasis"><em>C2到C0</em></span>的移动。可以从移动创建撤消移动，但只能在当前解决方案上完成移动之前。</p><pre class="programlisting">    public Move createUndoMove(WorkingMemory workingMemory) {
        return new YChangeMove(queen, queen.getY());
    }</pre><p>注意，如果将C0移至C2，则撤消移动将创建<span class="emphasis"><em>C2至C2</em></span>的移动，而不是<span class="emphasis"><em>C2至C0</em></span>的移动。</p><p>即使使用不同的（成功的）解决方案，本地搜索求解器也可以多次执行和撤消移动。</p><p>此举必须实施<code class="literal">equals()</code>和<code class="literal">hashcode()</code>方法。在解决方案上进行相同更改的2个动作必须相等。</p><pre class="programlisting">    public boolean equals(Object o) {
        if (this == o) {
            return true;
        } else if (o instanceof YChangeMove) {
            YChangeMove other = (YChangeMove) o;
            return new EqualsBuilder()
                    .append(queen, other.queen)
                    .append(toY, other.toY)
                    .isEquals();
        } else {
            return false;
        }
    }

    public int hashCode() {
        return new HashCodeBuilder()
                .append(queen)
                .append(toY)
                .toHashCode();
    }</pre><p>在上面的示例中， <code class="literal">Queen</code>类使用默认值<code class="literal">Object</code><code class="literal">equal()</code>和<code class="literal">hashcode()</code>实现。请注意，它检查另一个移动是否是相同移动类型的实例。这一点很重要，因为如果您使用的移动类型多于1种，则移动将与另一种移动类型的移动进行比较。</p><p>还建议实施<code class="literal">toString()</code>方法，因为它使您可以更轻松地阅读drools-solver的日志记录：</p><pre class="programlisting">    public String toString() {
        return queen + " =&gt; " + toY;
    }</pre><p>现在我们可以进行单个动作了，让我们看一下生成动作。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1695"></a> 1.5.3。移动世代</h3></div></div></div><p>在每种解决方案中，本地搜索将尝试所有可能的移动，并选择最佳移动以更改为下一个解决方案。产生这些动作取决于您。让我们看一下4个皇后区起始解决方案上的所有可能动作：</p><div class="figure"><a id="d0e1700"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/possibleMovesNQueens04.png" alt="可能在第0步移动（以4个皇后为例）"></div></div><p class="title"><b>图1.13。可能在第0步移动（以4个皇后为例）</b></p></div><br class="figure-break"><p>如您所见，并非所有举动都是可行的。在开始的解决方案中，我们有12个可行的动作（ <code class="literal">n * (n - 1)</code> ），其中之一将移动，从而将起始解决方案更改为下一个解决方案。请注意，可能的解决方案数是256（ <code class="literal">n ^ n</code> ），而不是可行动作的数量。不要动用所有可能的解决方案。而是使用可以顺序组合以达到所有可能解决方案的移动。</p><p>强烈建议您验证所有解决方案是否已通过移动装置连接。这意味着通过组合有限数量的移动，您可以从任何解决方案获得任何解决方案。否则，您一开始就已经排除了解决方案。特别是如果您仅使用大动作，则应进行检查。仅仅因为在短时间的测试中大动作胜过小动作，并不意味着在长时间的测试中它们会胜过小动作。</p><p>您可以混合使用不同的移动类型。通常，您最好选择小（细粒度）移动而不是大（粗粒度）移动，因为分数增量计算会带来更多收益。但是，正如旅行比赛示例所证明的，如果您可以通过使用某些较大的动作来消除硬约束，则可以赢得性能和可伸缩性。自己尝试：运行旅行锦标赛示例的简单（小动作）和智能（大动作）版本。智能版本评估了许多不可行的解决方案，这使其能够胜过简单版本并超出其规模。</p><p>移动生成当前发生在<code class="literal">MoveFactory</code> ：</p><pre class="programlisting">public class NQueensMoveFactory extends CachedMoveListMoveFactory {

    public List&lt;Move&gt; createMoveList(Solution solution) {
        NQueens nQueens = (NQueens) solution;
        List&lt;Move&gt; moveList = new ArrayList&lt;Move&gt;();
        for (Queen queen : nQueens.getQueenList()) {
            for (int n : nQueens.createNList()) {
                moveList.add(new YChangeMove(queen, n));
            }
        }
        return moveList;
    }

}</pre><p>但是，我们很快将使移动生成成为drl的一部分。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1727"></a> 1.5.4。一步</h3></div></div></div><p>一步是制胜法宝。本地搜索求解器将尝试当前解决方案上的所有动作，并选择最佳的可接受动作作为步骤：</p><div class="figure"><a id="d0e1732"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/decideNextStepNQueens04.png" alt="在步骤0中决定下一步（以4个皇后为例）"></div></div><p class="title"><b>图1.14。在步骤0中决定下一步（以4个皇后为例）</b></p></div><br class="figure-break"><p>因为从<span class="emphasis"><em>B0到B3</em></span>的得分最高（ <code class="literal">-3</code> ），将其用作下一步。请注意，也可以选择<span class="emphasis"><em>C0至C3</em></span> （未显示），因为它也具有得分<code class="literal">-3</code> 。如果多个动作具有相同的最高分数，则随机选择一个，在这种情况下为<span class="emphasis"><em>B0至B3</em></span> 。</p><p>完成该步骤，然后从该新解决方案开始，本地搜索求解器将再次尝试所有可能的移动，以决定之后的下一步。它不断地循环执行此操作，我们得到如下信息：</p><div class="figure"><a id="d0e1757"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/allStepsNQueens04.png" alt="所有步骤（以4个皇后为例）"></div></div><p class="title"><b>图1.15。所有步骤（以4个皇后为例）</b></p></div><br class="figure-break"><p>注意，本地搜索求解器不使用搜索树，而是使用搜索路径。搜索路径由绿色箭头突出显示。在每个步骤中，它都会尝试所有可能的移动，但是除非执行此步骤，否则不会进一步研究该解决方案。这是本地搜索可扩展性很高的原因之一。</p><p>如您所见，本地搜索求解器通过从起始解决方案开始解决了4个皇后区问题，并依次执行以下步骤：</p><div class="orderedlist"><ol type="1"><li><p><span class="emphasis"><em>B0至B3</em></span></p></li><li><p><span class="emphasis"><em>D0至B2</em></span></p></li><li><p><span class="emphasis"><em>A0至B1</em></span></p></li></ol></div><p>如果我们打开INFO日志，这将反映在日志中：</p><pre class="programlisting">INFO  Solving with random seed (0).
INFO  Initial score (-6) is starting best score. Updating best solution and best score.
INFO  Step (0), time spend (0) doing next step ([Queen-1] 1 @ 0 =&gt; 3).
INFO  New score (-3) is better then last best score (-6). Updating best solution and best score.
INFO  Step (1), time spend (0) doing next step ([Queen-3] 3 @ 0 =&gt; 2).
INFO  New score (-1) is better then last best score (-3). Updating best solution and best score.
INFO  Step (2), time spend (15) doing next step ([Queen-0] 0 @ 0 =&gt; 1).
INFO  New score (0) is better then last best score (-1). Updating best solution and best score.
INFO  Solved in 3 steps and 15 time millis spend.</pre><p>请注意，日志记录使用了<code class="literal">toString()</code>我们的方法<code class="literal">Move</code>实施： <code class="literal">[Queen-1] 1 @ 0 => 3</code> 。</p><p>本地搜索求解器通过仅评估37个可能的解决方案（3个步骤，每12个动作+ 1个初始解决方案），分3个步骤解决了4个皇后区问题，这仅是全部256个可能解决方案的一小部分。它通过评估18446744073709551616可能的解决方案中的7441，以31个步骤解决了16个皇后区。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1797"></a> 1.5.5。陷入局部最优</h3></div></div></div><p>一个<span class="emphasis"><em>简单的本地搜索</em></span>总是需要改进动作。这似乎是一件好事，但事实并非如此。它有许多问题：</p><div class="itemizedlist"><ul><li><p>它可能会卡在局部最优中。例如，如果到达分数为-1的解决方案X并且没有改善的举动，则它被迫采取下一步导致分数为-2的解决方案Y，但是在那之后，很明显它将选择回到分数为-1的解X。然后它将开始在解决方案X和Y之间循环。</p></li><li><p>它可以开始走自己的脚步，在每一步都选择相同的下一步。</p></li></ul></div><p>当然，drools-solver可以实现更好的本地搜索，例如<span class="emphasis"><em>禁忌搜索</em></span>和<span class="emphasis"><em>模拟退火</em></span>可以避免这些问题。建议不要使用简单的本地搜索，除非您完全确定计划问题中没有本地最优方法。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1820"></a> 1.5.6。决定下一步</h3></div></div></div><p>本地搜索求解器借助3个可配置的组件来决定下一步：</p><div class="itemizedlist"><ul><li><p>一个<span class="emphasis"><em>选择器</em></span> ，用于选择（或生成）当前解决方案的可能动作。</p></li><li><p>一个<span class="emphasis"><em>接受器</em></span> ，过滤掉不可接受的动作。它还可以衡量自己接受的动作。</p></li><li><p><span class="emphasis"><em>觅食者</em></span>收集所有接受的动作并从中选择下一步。</p></li></ul></div><div class="figure"><a id="d0e1844"></a><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Solver/decideNextStepNQueens04.png" alt="在步骤0中决定下一步（以4个皇后为例）"></div></div><p class="title"><b>图1.16。在步骤0中决定下一步（以4个皇后为例）</b></p></div><br class="figure-break"><p>在上面的示例中，选择器生成了蓝线所示的移动，接受者接受了所有移动，而觅食者选择了<span class="emphasis"><em>B0至B3</em></span>的移动。</p><p>如果打开DEBUG日志记录，则可以在日志中看到决策：</p><pre class="programlisting">INFO  Solving with random seed (0).
INFO  Initial score (-6) is starting best score. Updating best solution and best score.
DEBUG     Move ([Queen-0] 0 @ 0 =&gt; 0) ignored because not doable.
DEBUG     Move ([Queen-0] 0 @ 1 =&gt; 1) with score (-4) and acceptChance (1.0).
DEBUG     Move ([Queen-0] 0 @ 2 =&gt; 2) with score (-4) and acceptChance (1.0).
...
DEBUG     Move ([Queen-1] 1 @ 3 =&gt; 3) with score (-3) and acceptChance (1.0).
...
DEBUG     Move ([Queen-3] 3 @ 3 =&gt; 3) with score (-4) and acceptChance (1.0).
INFO  Step (0), time spend (0) doing next step ([Queen-1] 1 @ 0 =&gt; 3).
INFO  New score (-3) is better then last best score (-6). Updating best solution and best score.
...</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1859"></a> 1.5.6.1。选择器</h4></div></div></div><p>选择器当前基于<code class="literal">MoveFactory</code> 。</p><pre class="programlisting">    &lt;selector&gt;
        &lt;moveFactoryClass&gt;org.drools.solver.examples.nqueens.solver.NQueensMoveFactory&lt;/moveFactoryClass&gt;
    &lt;/selector&gt;</pre><p>您不必在每一步都生成相同的稳定移动集。您可以从最初只生成大动作开始，然后逐渐切换到小动作。但是，尚无内置支持。</p><p>如果有很多可能的动作，则在每个步骤中评估所有这些动作可能会变得效率低下。使用relativeSelection只会评估它们的随机子集：</p><pre class="programlisting">    &lt;selector&gt;
       &lt;moveFactoryClass&gt;org.drools.solver.examples.itc2007.examination.solver.move.factory.RoomChangeMoveFactory&lt;/moveFactoryClass&gt;
       &lt;relativeSelection&gt;0.002&lt;/relativeSelection&gt;
    &lt;/selector&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1875"></a> 1.5.6.2。接受者</h4></div></div></div><p>使用受体（与觅食器一起）来进行禁忌搜索，模拟退火，大洪水，...对于每一步，它都会产生接受机会。如果举动被拒绝，则有机会接受<code class="literal">0.0</code> 。</p><p>您可以实现自己的<code class="literal">Accepter</code> ，尽管内置接受器应足以满足大多数需求。您也可以合并多个接受者。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1888"></a> 1.5.6.2.1。禁忌搜索接受器</h5></div></div></div><p>当禁忌搜索采取步骤时，它将创建禁忌。如果该动作中断了禁忌，则不接受该动作作为下一步。Drools-solver实现了几种禁忌类型：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>解决方案禁忌</em></span>使最近访问的解决方案禁忌。它不接受导致这些解决方案之一的举动。如果您可以节省内存，那么在禁忌大小上不要便宜。我们建议使用这种类型的禁忌，因为它往往会产生最佳效果，并且几乎不需要调整。</p><pre class="programlisting">    &lt;accepter&gt;
        &lt;completeSolutionTabuSize&gt;1000&lt;/completeSolutionTabuSize&gt;
    &lt;/accepter&gt;</pre></li><li><p><span class="emphasis"><em>移动禁忌</em></span>使最近的步骤禁忌。它不接受等于这些步骤之一的移动。</p><pre class="programlisting">    &lt;accepter&gt;
        &lt;completeMoveTabuSize&gt;1000&lt;/completeMoveTabuSize&gt;
    &lt;/accepter&gt;</pre></li><li><p><span class="emphasis"><em>撤消移动禁忌</em></span>使最近的步骤禁忌撤消移动。</p><pre class="programlisting">    &lt;accepter&gt;
        &lt;completeUndoMoveTabuSize&gt;1000&lt;/completeUndoMoveTabuSize&gt;
    &lt;/accepter&gt;</pre></li><li><p><span class="emphasis"><em>“属性”禁忌</em></span>构成最近步骤禁忌的属性。例如，它可以使皇后区成为禁忌区，这样就不会移动最近移动的女王区。</p><pre class="programlisting">    &lt;accepter&gt;
        &lt;completePropertyTabuSize&gt;1000&lt;/completePropertyTabuSize&gt;
    &lt;/accepter&gt;</pre><p>要使用属性禁忌，您的举动必须实现<code class="literal">TabuPropertyEnabled</code>界面，例如：</p><pre class="programlisting">public class YChangeMove implements Move, TabuPropertyEnabled {

    private Queen queen;
    private int toY;

    // ...

    public List&lt;? extends Object&gt; getTabuPropertyList() {
        return Collections.singletonList(queen);
    }

}</pre></li></ul></div><p>您甚至可以组合禁忌类型：</p><pre class="programlisting">    &lt;accepter&gt;
        &lt;completeSolutionTabuSize&gt;1000&lt;/completeSolutionTabuSize&gt;
        &lt;completeUndoMoveTabuSize&gt;10&lt;/completeUndoMoveTabuSize&gt;
    &lt;/accepter&gt;</pre><p>如果选择的Tabu尺寸太小，则求解器仍会卡在局部最优值中。另一方面，除了解决方案禁忌之外，如果选择的禁忌大小太大，则求解器可能会因弹跳墙壁而卡住。使用基准测试器来微调您的配置。</p><p>禁忌搜索接受者应与<span class="emphasis"><em>所有得分最高的分数</em></span>或<span class="emphasis"><em>首个得分</em></span> <span class="emphasis"><em>最高的</em></span>觅食者相结合。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1943"></a> 1.5.6.2.2。模拟退火受体</h5></div></div></div><p>模拟退火不会选择得分最高的移动，也不会评估所有移动。至少起初。</p><p>根据得分和温度的不同，它可以为不改进动作提供机会。<span class="emphasis"><em>温度</em></span>与溶解时间有关。最后，它逐渐变成一个简单的本地搜索，只接受改进的动作。</p><p>模拟退火受体应与<span class="emphasis"><em>第一个随机接受的</em></span>觅食器结合使用。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1958"></a> 1.5.6.3。觅食者</h4></div></div></div><p>觅食者收集所有接受的动作，并选择下一步。觅食者可以选择是否允许评估所有选定动作的子集，方法是如果已接受合适的动作，则尽早退出。</p><p>您可以实现自己的<code class="literal">Forager</code> ，尽管内置的觅食器可以满足大多数需求。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1968"></a> 1.5.6.3.1。所有觅食者的最高分数</h5></div></div></div><p>允许评估所有选定的动作，并选择得分最高的接受动作。如果几个接受的动作得分最高，则随机选择一个，并对其接受机会进行加权。</p><pre class="programlisting">    &lt;forager&gt;
        &lt;foragerType&gt;MAX_SCORE_OF_ALL&lt;/foragerType&gt;
    &lt;/forager&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1975"></a> 1.5.6.3.2。首个得分最高的觅食者</h5></div></div></div><p>选择可以提高最佳分数的第一个可接受的举动。如果没有一个可以提高最佳分数，则其行为与所有觅食者的最高分数完全相同。</p><pre class="programlisting">    &lt;forager&gt;
        &lt;foragerType&gt;FIRST_BEST_SCORE_IMPROVING&lt;/foragerType&gt;
    &lt;/forager&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1982"></a> 1.5.6.3.3。第一步得分提高觅食者</h5></div></div></div><p>选择提高最后一步得分的第一个可接受的举动。如果没有改善最后一步的分数，则其行为与所有觅食者的最高分数完全相同。</p><pre class="programlisting">    &lt;forager&gt;
        &lt;foragerType&gt;FIRST_BEST_SCORE_IMPROVING&lt;/foragerType&gt;
    &lt;/forager&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1989"></a> 1.5.6.3.4。首先随机接受的觅食者</h5></div></div></div><p>为每个接受的动作生成一个随机数，如果该动作的接受机会更高，它将选择该动作作为下一个动作。</p><pre class="programlisting">    &lt;forager&gt;
        &lt;foragerType&gt;FIRST_RANDOMLY_ACCEPTED&lt;/foragerType&gt;
    &lt;/forager&gt;</pre></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1996"></a> 1.5.7。最佳解决方案</h3></div></div></div><p>因为当前解决方案可能会降级（尤其是在禁忌搜索和模拟退火中），所以本地搜索求解器会记住它在整个搜索路径中遇到的最佳解决方案。每当当前解决方案比最近的最佳解决方案更好时，都会克隆当前解决方案并将其引用为新的最佳解决方案。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2001"></a> 1.5.8。完</h3></div></div></div><p>本地搜索求解器迟早将不得不停止求解。这可能是由于多种原因：时间到了，已经达到完美分数，...您唯一不能依靠的就是找到最佳解决方案（除非您知道最佳分数），因为本地搜索求解器在找到最佳解决方案时并不知道这一点。对于现实生活中的问题，这并不是什么大问题，因为找到最佳解决方案将需要数年时间，因此无论如何您都希望尽早完成。</p><p>您可以通过配置完成来配置何时需要停止本地搜索求解器。您可以实现自己的<code class="literal">Finish</code> ，尽管内置装饰足以满足大多数需求。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2011"></a> 1.5.8.1。TimeMillisSpendFinish</h4></div></div></div><p>达到一定时间后完成：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;maximumMinutesSpend&gt;2&lt;/maximumMinutesSpend&gt;
    &lt;/finish&gt;</pre><p>要么</p><pre class="programlisting">    &lt;finish&gt;
        &lt;maximumHouresSpend&gt;1&lt;/maximumHouresSpend&gt;
    &lt;/finish&gt;</pre><p>请注意， <code class="literal">StartingSolutionInitializer</code>此完成也考虑在内。因此，如果您给求解器2分钟来解决问题，但是初始化器需要1分钟，则本地搜索求解器仅剩一分钟。</p><p>请注意，如果使用此涂层，则很可能会牺牲可重复性。最佳解决方案将取决于可用的CPU时间，不仅因为它会影响所采取的步骤数量，而且因为基于时间梯度的算法（例如模拟退火）在每次运行中的行为可能会有所不同。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2029"></a> 1.5.8.2。StepCount完成</h4></div></div></div><p>在达到一定数量的步骤后完成：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;maximumStepCount&gt;100&lt;/maximumStepCount&gt;
    &lt;/finish&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2036"></a> 1.5.8.3。可行分数完成</h4></div></div></div><p>当达到可行分数时结束。如果您知道完美的分数，也可以使用此效果，例如4个皇后：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;feasableScore&gt;0&lt;/feasableScore&gt;
    &lt;/finish&gt;</pre><p>对于具有硬约束和软约束的求解器问题，可以这样定义：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;feasableScore&gt;0hard/-5000soft&lt;/feasableScore&gt;
    &lt;/finish&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2047"></a> 1.5.8.4。未经改进的StepCount完成</h4></div></div></div><p>在多个步骤中未取得最佳成绩的情况下完成：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;maximumUnimprovedStepCount&gt;100&lt;/maximumUnimprovedStepCount&gt;
    &lt;/finish&gt;</pre><p>如果最近没有改善，那么无论如何它可能不会很快改善，因此不值得继续努力。我们已经观察到，一旦找到了新的最佳解决方案（即使长时间没有对最佳解决方案进行任何改进），接下来的几步操作也往往会改善最佳解决方案。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2056"></a> 1.5.8.5。结合整理</h4></div></div></div><p>可以组合完成，例如：100个步骤后完成或达到0分：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;finishCompositionStyle&gt;OR&lt;/finishCompositionStyle&gt;
        &lt;maximumStepCount&gt;100&lt;/maximumStepCount&gt;
        &lt;feasableScore&gt;0&lt;/feasableScore&gt;
    &lt;/finish&gt;</pre><p>另外，您也可以使用AND，例如：在达到至少-100的可行分数之后完成，并且在5个步骤中没有改善：</p><pre class="programlisting">    &lt;finish&gt;
        &lt;finishCompositionStyle&gt;AND&lt;/finishCompositionStyle&gt;
        &lt;maximumUnimprovedStepCount&gt;5&lt;/maximumUnimprovedStepCount&gt;
        &lt;feasableScore&gt;-100&lt;/feasableScore&gt;
    &lt;/finish&gt;</pre><p>这样可以确保它不仅在找到可行的解决方案后完成，而且在完成之前对该解决方案进行了任何明显的改进。</p></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2069"></a>指数</h2></div></div></div><div class="index"></div></div></div></body></html>