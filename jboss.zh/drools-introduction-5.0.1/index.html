<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Drools简介和一般用户指南</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"><meta name="generator" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" content="DocBook XSL-NS Stylesheets V1.74.0"><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e9">1。欢迎</a></span></dt><dt><span class="chapter"><a href="#d0e26">2。Drools发行说明</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e29">2.1。Drools 5.0的新增功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e48">2.1.1。Drools API</a></span></dt><dt><span class="section"><a href="#d0e166">2.1.2。德鲁斯·古诺（Drools Guvnor）</a></span></dt><dt><span class="section"><a href="#d0e254">2.1.3。流口水专家</a></span></dt><dt><span class="section"><a href="#d0e625">2.1.4。流口水</a></span></dt><dt><span class="section"><a href="#d0e808">2.1.5。流口水融合</a></span></dt><dt><span class="section"><a href="#d0e978">2.1.6。Eclipse IDE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1009">2.2。Drools 4.0中的新增功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1014">2.2.1。语言表达能力增强</a></span></dt><dt><span class="section"><a href="#d0e1051">2.2.2。核心引擎增强功能</a></span></dt><dt><span class="section"><a href="#d0e1091">2.2.3。IDE增强</a></span></dt><dt><span class="section"><a href="#d0e1107">2.2.4。业务规则管理系统-BRMS</a></span></dt><dt><span class="section"><a href="#d0e1138">2.2.5。杂项增强</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1145">2.3。从Drools 3.0.x升级到Drools 4.0.x的提示</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1152">2.3.1。API变更</a></span></dt><dt><span class="section"><a href="#d0e1209">2.3.2。规则语言变更</a></span></dt><dt><span class="section"><a href="#d0e1268">2.3.3。Drools更新工具</a></span></dt><dt><span class="section"><a href="#d0e1294">2.3.4。Drools 4.0中的DSL语法</a></span></dt><dt><span class="section"><a href="#d0e1311">2.3.5。4.0.2的规则流更新</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1322">3。安装和设置（Core和IDE）</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1325">3.1。安装和使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1337">3.1.1。依赖和罐子</a></span></dt><dt><span class="section"><a href="#d0e1366">3.1.2。运行</a></span></dt><dt><span class="section"><a href="#d0e1371">3.1.3。安装IDE（Rule Workbench）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1473">3.2。从源安装</a></span></dt><dt><span class="section"><a href="#d0e1532">3.3。源结帐</a></span></dt><dt><span class="section"><a href="#d0e1583">3.4。建立</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1586">3.4.1。建立源</a></span></dt><dt><span class="section"><a href="#d0e1615">3.4.2。建立手册</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1667">3.5。日食</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1670">3.5.1。导入Eclipse项目</a></span></dt></dl></dd></dl></dd><dt><span class="index"><a href="#d0e1733">指数</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9"></a>第1章。欢迎</h2></div></div></div><div class="screenshot"><div class="mediaobject"><img src="../../images/Chapter-Welcome/drools_logo.png"></div></div><p>我一直说，最终业务用户很难理解规则和流程之间的差异，最近还很难理解规则和事件处理之间的差异。对于他们来说，他们心中有这个问题，他们只想使用某些软件对其进行建模。使用两个供应商产品的传统方式迫使业务用户使用面向过程或面向规则的方法来工作，而这通常会给他们带来麻烦，他们在使用哪种工具来建模哪个位时常常会产生很大的困惑。</p><p>PegaSystems和Microsoft在证明两者可以组合并且可以使用行为建模方法方面做得很好。这使业务用户可以在可以使用所有方法的地方更自然地工作，而不会妨碍工具。从面向过程到面向规则或中间的灰色阴影-不管是什么套件，都可以解决当时正在建模的问题。</p><p>Drools 5.0不仅通过在Drools Flow中添加工作流程，而且还在Drools Fusion中添加事件处理功能，进一步发展了这一步骤，从而为软件开发创造了一种更全面的方法。整体一词用于强调整体的重要性及其各个部分的相互依存关系。Drools 5.0是我们所谓的业务逻辑集成平台（BLiP）的发布。</p><p>Drools 5.0现在分为4个模块，每个模块都有自己的手册-Guvnor，Expert，Fusion和Flow。Guvnor是我们基于Web的治理系统，在规则世界中传统上称为BRMS。我们决定从BRMS术语转移到治理方面，因为它不是特定于规则的。专家是传统的规则引擎。融合是事件处理方面，是数据/传感器融合术语的一种玩法。最后是Flow，这是我们的工作流程模块。</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e26"></a>第2章。Drools发行说明</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e29">2.1。Drools 5.0的新增功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e48">2.1.1。Drools API</a></span></dt><dt><span class="section"><a href="#d0e166">2.1.2。德鲁斯·古诺（Drools Guvnor）</a></span></dt><dt><span class="section"><a href="#d0e254">2.1.3。流口水专家</a></span></dt><dt><span class="section"><a href="#d0e625">2.1.4。流口水</a></span></dt><dt><span class="section"><a href="#d0e808">2.1.5。流口水融合</a></span></dt><dt><span class="section"><a href="#d0e978">2.1.6。Eclipse IDE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1009">2.2。Drools 4.0中的新增功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1014">2.2.1。语言表达能力增强</a></span></dt><dt><span class="section"><a href="#d0e1051">2.2.2。核心引擎增强功能</a></span></dt><dt><span class="section"><a href="#d0e1091">2.2.3。IDE增强</a></span></dt><dt><span class="section"><a href="#d0e1107">2.2.4。业务规则管理系统-BRMS</a></span></dt><dt><span class="section"><a href="#d0e1138">2.2.5。杂项增强</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1145">2.3。从Drools 3.0.x升级到Drools 4.0.x的提示</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1152">2.3.1。API变更</a></span></dt><dt><span class="section"><a href="#d0e1209">2.3.2。规则语言变更</a></span></dt><dt><span class="section"><a href="#d0e1268">2.3.3。Drools更新工具</a></span></dt><dt><span class="section"><a href="#d0e1294">2.3.4。Drools 4.0中的DSL语法</a></span></dt><dt><span class="section"><a href="#d0e1311">2.3.5。4.0.2的规则流更新</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e29"></a> 2.1。Drools 5.0的新增功能</h2></div></div></div><p>Drools 5.0将成为我们所谓的业务逻辑集成平台（BLiP）的发布-BRM已死：)未来是针对规则，流程和CEP的统一集成解决方案-这就是用户想要的，这就是我们的目标。Drools 5.0将分为四个主要的子项目，文档已经被拆分以反映这一点：</p><div class="itemizedlist"><ul><li><p>Drools Guvnor（BRMS / BPMS）</p></li><li><p>Drools Expert（规则引擎），</p></li><li><p>流口水流程（流程/工作流程）</p></li><li><p>Drools Fusion（cep /时间推理）</p></li></ul></div><p>
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e48"></a> 2.1.1。Drools API</h3></div></div></div><p>Drools现在具有完全的api /实现分离，不再是面向规则的。随着我们支持其他形式的逻辑（例如工作流和事件处理），这是一项重要的策略。主要的变化是我们现在面向知识，而不是面向规则。drools-api模块提供了接口和工厂，并且我们比以前更努力地提供了更好的javadocs，带有许多代码片段。Drools-api还有助于清楚地表明什么是用户api，什么仅仅是引擎api，drools-core和drools-compiler对此不够清楚。您将使用的最常见的接口是：</p><div class="itemizedlist"><ul><li><p>org.drools.builder。知识构建者</p></li><li><p>org.drools。知识库</p></li><li><p>org.drools.agent。知识代理商</p></li><li><p>org.drools.runtime。有状态知识会话</p></li><li><p>org.drools.runtime。无状态知识会话</p></li></ul></div><p>具有静态方法的工厂类提供上述接口的实例。可插入的提供程序方法用于允许将提供程序实现在运行时连接到工厂。您最常使用的工厂有：</p><div class="itemizedlist"><ul><li><p>org.drools.builder。KnowledgeBuilderFactory</p></li><li><p>org.drools.io。资源工厂</p></li><li><p>org.drools。知识库工厂</p></li><li><p>org.drools.agent。知识代理商工厂</p></li></ul></div><p>

	</p><div class="example"><a id="d0e84"></a><p class="title"><b>示例2.1加载规则资源的典型示例</b></p><div class="example-contents"><pre class="programlisting">
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newUrlResource( url ),
            ResourceType.DRL );
if ( kbuilder.hasErrors() ) {
  System.err.println( builder.getErrors().toString() );
}         

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( builder.getKnowledgePackages() );

StatefulKnowledgeSession ksession = knowledgeBase.newStatefulKnowledgeSession();
ksession.insert( new Fibonacci( 10 ) );
ksession.fireAllRules();

ksession.dispose();</pre></div></div><p><br class="example-break">加载流程资源的典型示例。注意<code class="code">ResourceType</code>根据<code class="code">Resource</code>类型：</p><div class="example"><a id="d0e96"></a><p class="title"><b>示例2.2加载流程资源的典型示例。注意<code class="code">ResourceType</code>根据<code class="code">Resource</code>类型</b></p><div class="example-contents"><pre class="programlisting">
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newUrlResource( url ),
            ResourceType.DRF );
if ( kbuilder.hasErrors() ) {
  System.err.println( builder.getErrors().toString() );
}         

KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( builder.getKnowledgePackages() );

StatefulKnowledgeSession ksession = knowledgeBase.newStatefulKnowledgeSession();
ksession.startProcess( "Buy Order Process" );

ksession.dispose();
</pre></div></div><p><br class="example-break">“ kbuilder”，“ kbase”，“ ksession”是经常使用的变量标识符，k前缀用于“ knowledge”。

	</p><div class="example"><a id="d0e108"></a><p class="title"><b>例子2.3。我们已经统一了决策树的加载方式，现在它们变得一致，无需使用电子表格编译器预先生成DRL。</b></p><div class="example-contents"><pre class="programlisting">
DecisionTableConfiguration dtconf = KnowledgeBuilderFactory.newDecisionTableConfiguration();
dtconf.setInputType( DecisionTableInputType.XLS );
dtconf.setWorksheetName( "Tables_2" );
kbuilder.add( ResourceFactory.newUrlResource( "file://IntegrationExampleTest.xls" ),
            ResourceType.DTABLE,
            dtconf );
</pre></div></div><p><br class="example-break">也可以配置一个<code class="code">KnowledgeBase</code>通过xml变更集使用配置，而不是通过编程。
	</p><div class="example"><a id="d0e117"></a><p class="title"><b>示例2.4这是一个简单的变更集</b></p><div class="example-contents"><pre class="programlisting">
&lt;change-set xmlns='http://drools.org/drools-5.0/change-set'
xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'
xs:schemaLocation='http://drools.org/drools-5.0/change-set change-set-5.0.xsd' &gt;
  &lt;add&gt;
      &lt;resource source='classpath:org/domain/someRules.drl' type='DRL' /&gt;
      &lt;resource source='classpath:org/domain/aFlow.drf' type='DRF' /&gt;
  &lt;/add&gt;
&lt;/change-set&gt;
</pre></div></div><p><br class="example-break">

	</p><div class="example"><a id="d0e123"></a><p class="title"><b>示例2.5就像任何其他ResourceType一样添加</b></p><div class="example-contents"><pre class="programlisting">
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newUrlResource( url ),
            ResourceType.ChangeSet );
</pre></div></div><p><br class="example-break">另一个重大变化<code class="code">KnowledgeAgent</code> ，与<code class="code">RuleAgent</code> ，是轮询扫描程序现在是一项服务。除此之外，在代理通知和资源监视之间存在一个抽象，以允许使用除轮询以外的其他机制。

</p><div class="example"><a id="d0e135"></a><p class="title"><b>示例2.6这些服务当前默认情况下未启动，要启动它们，请执行以下操作</b></p><div class="example-contents"><pre class="programlisting">
ResourceFactory.getResourceChangeNotifierService().start();
ResourceFactory.getResourceChangeScannerService().start();
</pre></div></div><p><br class="example-break">添加了两个新接口， <code class="code">ResourceChangeNotifier</code>和<code class="code">ResourceChangeMonitor</code> 。 <code class="code">KnowlegeAgents</code>使用订阅资源更改通知<code class="code">ResourceChangeNotifier</code>实施。的<code class="code">ResourceChangeNotifier</code>通过添加通知资源更改<code class="code">ResourceChangeMonitors</code> 。我们目前仅提供一个开箱即用的监视器， <code class="code">ResourceChangeScannerService</code> ，它会轮询资源以查找更改。但是，该API可供用户添加自己的监视器，因此可以使用基于推送的监视器，例如JMS。</p><p><code class="code">ResourceFactory.getResourceChangeNotifierService().addResourceChangeMonitor( myJmsMonitor);</code>
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e166"></a> 2.1.2。德鲁斯·古诺（Drools Guvnor）</h3></div></div></div><div class="itemizedlist"><ul><li><p>新外观网络工具</p><div class="figure"><a id="d0e173"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/guvnor1.png" align="middle"></div></div><p class="title"><b>图2.1。</b></p></div><p><br class="figure-break">
	</p></li><li><p>基于Web的决策表编辑器</p><div class="figure"><a id="d0e183"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/WebDT.png" align="middle" alt="基于Web的决策表编辑器"></div></div><p class="title"><b>图2.2。基于Web的决策表编辑器</b></p></div><p><br class="figure-break">
	</p></li><li><p>集成方案测试</p><div class="figure"><a id="d0e193"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/ScenarioSuite.png" align="middle" alt="运行所有方案"></div></div><p class="title"><b>图2.3。运行所有方案</b></p></div><p><br class="figure-break">
	</p><div class="figure"><a id="d0e200"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/Scenario.png" align="middle" alt="运行单个方案"></div></div><p class="title"><b>图2.4。运行单个方案</b></p></div><p><br class="figure-break">
	</p></li><li><p>基于WebDAV文件的存储库接口</p><div class="figure"><a id="d0e210"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/WebDav.png" align="middle" alt="WebDAV"></div></div><p class="title"><b>图2.5。WebDAV</b></p></div><p><br class="figure-break">
	</p></li><li><p>类型的声明式建模（不在pojos中的类型）</p><div class="figure"><a id="d0e220"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/DeclaringModel.png" align="middle" alt=">声明式建模"></div></div><p class="title"><b>图2.6。 >声明式建模</b></p></div><p><br class="figure-break">这适用于新的“ declare”语句-您现在可以在drl本身中声明类型。然后，您可以在不使用pojo的情况下填充它们（如果您愿意）。然后，这些类型在规则库中可用。</p></li><li><p>细粒度的安全性（按包或按类别锁定对应用程序的访问）。仅具有类别权限的用户具有有限的UI功能（适合业务用户）</p></li><li><p>执行服务器-通过XML或JSON访问规则以执行</p></li><li><p>类别规则允许您为类别设置“父规则”。给定类别中出现的任何规则都将“扩展”指定的规则-即继承条件/ LHS。类别的基本规则可以在“程序包配置”选项卡上设置。RHS不是继承的，只有LHS</p></li><li><p>场景运行程序检测到无限循环</p></li><li><p>方案运行器可以显示审核记录器记录的事件跟踪</p></li><li><p>现在可以将引导编辑器中的DSL句子设置为将枚举显示为下拉列表，将日期显示为日期选择器，将布尔值显示为复选框，并使用正则表达式来验证输入（Guvnor中的DSL窗口小部件）</p></li><li><p>可以使用文本编辑器编辑功能</p></li><li><p>可以将对象添加到全局集合。</p></li><li><p>翻译成英文，西班牙文，中文和日文</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e254"></a> 2.1.3。流口水专家</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e257"></a> 2.1.3.1。非对称Rete算法的实现</h4></div></div></div><p>不再需要影子代理。影子代理可以保护引擎免受事实信息的更改，如果这些信息发生在引擎控制范围之外，则无法对其进行修改或收回。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e262"></a> 2.1.3.2。 <code class="code">PackageBuilder</code>现在可以构建多个名称空间</h4></div></div></div><p>您不再需要限制一个<code class="code">PackageBuilder</code>到一个程序包名称空间。只要继续为任何名称空间添加DRL， <code class="code">getPackages()</code>返回每个使用的名称空间的Packages数组。
	
	</p><div class="example"><a id="d0e275"></a><p class="title"><b>示例2.7获取多个包</b></p><div class="example-contents"><pre class="programlisting">Package[] packages = pkgBuilder.getPackages();</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e280"></a> 2.1.3.3。 <code class="code">RuleBase</code>附件<code class="code">PackageBuilder</code></h4></div></div></div><p>现在可以附加一个<code class="code">RuleBase</code>到一个<code class="code">PackageBuilder</code> ，这意味着将同时构建规则并将其添加到规则库。 <code class="code">PackageBuilder</code>使用<code class="code">Package</code>实际的实例<code class="code">RuleBase</code>作为其来源，无需额外的<code class="code">Package</code>现有方法中发生的创建和合并。

	</p><div class="example"><a id="d0e307"></a><p class="title"><b>示例2.8附加<code class="code">RuleBase</code>至<code class="code">PackageBuilder</code></b></p><div class="example-contents"><pre class="programlisting">RuleBase ruleBase = RuleBaseFactory.newRuleBase();
PackageBuilder pkgBuilder = new PackageBuilder( ruleBase, null );</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e317"></a> 2.1.3.4。有状态会话的二进制编组</h4></div></div></div><p>现在可以保存有状态会话，并在以后恢复。现在可以创建预加载的数据会话。可插拔策略可用于用户对象持久性，即休眠或身份映射。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e322"></a> 2.1.3.5。类型声明</h4></div></div></div><p>Drools现在支持称为类型声明的新基础构造。此构造实现两个目的：声明事实元数据的能力，以及动态生成规则引擎本地的新事实类型的能力。Guvnor建模工具在下面使用此工具。构造的一个示例是：</p><div class="example"><a id="d0e327"></a><p class="title"><b>示例2.9宣告<code class="code">StockTick</code></b></p><div class="example-contents"><pre class="programlisting">declare StockTick
  @role( event )
  @timestamp( timestampAttr )

  companySymbol : String
  stockPrice : double
  timestampAttr : long
end</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e334"></a> 2.1.3.6。声明事实元数据</h4></div></div></div><p>要声明和关联事实元数据，只需对要声明的每个元数据ID使用@符号。例：</p><div class="example"><a id="d0e339"></a><p class="title"><b>示例2.10声明元数据</b></p><div class="example-contents"><pre class="programlisting">
declare StockTick
  @role( event )
end</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e344"></a> 2.1.3.7。触发Bean生成</h4></div></div></div><p>要激活动态bean生成，只需在类型声明中添加字段和类型：</p><div class="example"><a id="d0e349"></a><p class="title"><b>示例2.11宣告<code class="code">Person</code></b></p><div class="example-contents"><pre class="programlisting">
declare Person
  name : String
  age : int
end</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e356"></a> 2.1.3.8。DSL改进</h4></div></div></div><p>实施了一系列DSL改进，包括全新的解析器以及为匹配变量声明匹配掩码的功能。例如，通过声明DSL映射，可以将电话号码字段限制为2位国家/地区代码+ 3位区号+ 8位电话号码，所有这些都由“-”（破折号）连接，例如： number是{number：\ d {2}-\ d {3}-\ d {8}}变量掩码中可以使用任何有效的Java regexp。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e361"></a> 2.1.3.9。<code class="code">fireUntilHalt()</code></h4></div></div></div><p>Drools现在支持“ fireUntilHalt（）”功能，该功能以响应模式启动引擎，在该模式下，规则将连续触发，直到调用halt（）。这对于需要通常称为“活动查询”的CEP方案特别有用。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e367"></a> 2.1.3.10。规则库分区和多线程传播</h4></div></div></div><p>Drools ReteOO算法现在支持在多线程模式下启动规则库的选项，在该模式下，Drools ReteOO网络被划分为多个分区，然后由多个线程同时评估规则。这也是CEP的要求，在CEP中，通常有多个独立的规则同时运行，并且具有接近实时的性能/吞吐量要求，并且一个评估不能干扰其他评估。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e372"></a> 2.1.3.11。XSD模型支持</h4></div></div></div><p>Drools现在支持XSD模型。请记住，尽管XSD模型是作为Drools类加载器本地的pojos生成的。那里有一个帮助程序类，以帮助在packagebuilder中创建模型。生成数据模型后，通常将使用JAXB数据加载器插入数据。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e377"></a> 2.1.3.12。数据加载器</h4></div></div></div><p>Drools现在支持两个数据加载器Smooks和JAXB。 Smooks是用于ETL的开源数据转换工具，而JAXB是标准的sun数据映射工具。可以在这里找到显示Smooks的单元测试，在这里可以找到JAXB。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e382"></a> 2.1.3.13。输入安全配置</h4></div></div></div><p>除了可以通过配置文件，系统属性以及通过API设置属性来在流口水中配置选项<code class="code">setProperty()</code>方法，Drools-API现在支持类型安全配置。我们不想为每种可能的配置方法添加特定的方法有两个原因：它污染了API，并且每次向Drools添加新选项时，API都必须更改。这样，我们遵循了模块化的，基于类的配置，其中针对每种可能的配置向API添加了新的Option类，以保持API稳定，但同时又很灵活。因此，为了立即设置配置选项，您只需要使用为每个选项提供的枚举或工厂。例如，如果您要配置知识库以断言行为“平等”并自动从模式匹配中删除身份，则只需使用枚举即可：</p><div class="example"><a id="d0e390"></a><p class="title"><b>示例2.12配置中</b></p><div class="example-contents"><pre class="programlisting">
KnowledgeBaseConfiguration config = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();
config.setOption( AssertBehaviorOption.EQUALITY );
config.setOption( RemoveIdentitiesOption.YES );</pre></div></div><p><br class="example-break">对于没有预定义常量或可以采用多个值的选项，提供了一种工厂方法。例如，要将alpha阈值配置为5，只需使用“ get”工厂方法即可：</p><div class="example"><a id="d0e396"></a><p class="title"><b>示例2.13配置Alpha阈值</b></p><div class="example-contents"><pre class="programlisting">
config.setOption( AlphaThresholdOption.get(5) );</pre></div></div><p><br class="example-break">如您所见，相同<code class="code">setOption()</code>方法用于不同的可能配置，但是它们仍然是类型安全的。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e405"></a> 2.1.3.14。新的累积函数：collectSet和collectList</h4></div></div></div><p>在某些情况下，有必要收集从事实属性派生而并非事实本身的值的集合或值列表。在这种情况下，不可能使用collect CE。因此，在这种情况下，Drools现在具有两个累加函数：collectSet用于收集值集（即没有重复值）和collectList用于收集值列表（即允许重复值）：</p><div class="example"><a id="d0e410"></a><p class="title"><b>示例2.14新的累计功能</b></p><div class="example-contents"><pre class="programlisting">
# collect the set of unique names in the working memory
$names : Set() from accumulate( Person( $n : name, $s : surname ),
                        collectSet( $n + " " + $s ) )

# collect the list of alarm codes from the alarms in the working memory
$codes : List() from accumulate( Alarm( $c : code, $s : severity ),
                         collectList( $c + $s ) )</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e415"></a> 2.1.3.15。类型声明的新元数据：@propertyChangeSupport</h4></div></div></div><p>现在可以注释实现Javabean（tm）规范中定义的对属性更改的支持的事实，以便引擎注册自身以侦听事实属性的更改。Drools 4 API中insert（）方法中使用的布尔参数已被弃用，并且在drools-api模块中不存在。

</p><div class="example"><a id="d0e420"></a><p class="title"><b>示例2.15 @propertyChangeSupport</b></p><div class="example-contents"><pre class="programlisting">
declare Person
	@propertyChangeSupport
end</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e425"></a> 2.1.3.16。批处理执行器</h4></div></div></div><p>Batch Executor允许使用命令编写知识会话的脚本，命令也可以<code class="code">StatelessKnowledgeSession</code>和<code class="code">StatefulKnowledgeSession</code>实现此接口使用以下命令创建命令<code class="code">CommandFactory</code>并使用“ execute”方法执行，例如以下插入命令：</p><div class="example"><a id="d0e439"></a><p class="title"><b>示例2.16使用<code class="code">CommandFactory</code></b></p><div class="example-contents"><pre class="programlisting">
ksession.execute( CommandFactory.newInsert( person ) ); </pre></div></div><p><br class="example-break">通常，尽管您将要执行一批命令，但这可以通过组合命令来实现<code class="code">BatchExecution</code> 。 <code class="code">BatchExecutionResults</code>现在用于处理结果，某些命令可以指定“ out”标识符，用于将结果添加到<code class="code">BatchExecutionResult</code> 。现在可以执行手动查询并将结果添加到<code class="code">BatchExecutionResult</code> 。除此以外，结果还限于此execute调用，并通过<code class="code">BatchExecutionResults</code> ：</p><div class="example"><a id="d0e462"></a><p class="title"><b>示例2.17使用<code class="code">BatchExecutionResult</code></b></p><div class="example-contents"><pre class="programlisting">
List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

BatchExecutionResults results = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
results.getValue( "list1" ); // returns the ArrayList
results.getValue( "person" ); // returns the inserted fact Person
results.getValue( "Get People" );// returns the query as a QueryResults instance.
end</pre></div></div><p><br class="example-break">的<code class="code">CommandFactory</code>详细说明了受支持的命令，所有命令都可以使用XStream和<code class="code">BatchExecutionHelper</code> 。可以将其与管道结合使用以自动执行会话脚本。

</p><div class="example"><a id="d0e476"></a><p class="title"><b>示例2.18使用<code class="code">PipelineFactory</code></b></p><div class="example-contents"><pre class="programlisting">
Action executeResultHandler = PipelineFactory.newExecuteResultHandler();
Action assignResult = PipelineFactory.newAssignObjectAsResult();
assignResult.setReceiver( executeResultHandler );
Transformer outTransformer = PipelineFactory.newXStreamToXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
outTransformer.setReceiver( assignResult );
KnowledgeRuntimeCommand batchExecution = PipelineFactory.newBatchExecutor();
batchExecution.setReceiver( outTransformer );
Transformer inTransformer = PipelineFactory.newXStreamFromXmlTransformer( BatchExecutionHelper.newXStreamMarshaller() );
inTransformer.setReceiver( batchExecution );
Pipeline pipeline = PipelineFactory.newStatelessKnowledgeSessionPipeline( ksession );
pipeline.setReceiver( inTransformer ); </pre></div></div><p><br class="example-break">给定以下xml以使用out-identifier插入Cheese实例的方式，将以上内容用于更新Cheese事实价格的规则集：</p><div class="example"><a id="d0e484"></a><p class="title"><b>示例2.19更新奶酪事实</b></p><div class="example-contents"><pre class="programlisting">
&lt;batch-execution&gt;
&lt;insert out-identifier='outStilton'&gt;
  &lt;org.drools.Cheese&gt;
    &lt;type&gt;stilton&lt;/type&gt;
    &lt;price&gt;25&lt;/price&gt;
    &lt;oldPrice&gt;0&lt;/oldPrice&gt;
  &lt;/org.drools.Cheese&gt;
&lt;/insert&gt;
&lt;/batch-execution&gt;
</pre></div></div><p><br class="example-break">然后我们得到以下内容<code class="code">BatchExecutionResults</code> ：</p><div class="example"><a id="d0e493"></a><p class="title"><b>示例2.20更新奶酪事实</b></p><div class="example-contents"><pre class="programlisting">
&lt;batch-execution-results&gt;
 &lt;result identifier='outStilton'&gt;
   &lt;org.drools.Cheese&gt;
     &lt;type&gt;stilton&lt;/type&gt;
     &lt;oldPrice&gt;0&lt;/oldPrice&gt;       
     &lt;price&gt;30&lt;/price&gt;
   &lt;/org.drools.Cheese&gt;
 &lt;/result&gt;
&lt;/batch-execution-results&gt;
</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e498"></a> 2.1.3.17。编组</h4></div></div></div><p>的<code class="code">MarshallerFactory</code>用于元帅和元帅<code class="code">StatefulKnowledgeSessions</code> 。最简单的方法如下：</p><div class="example"><a id="d0e509"></a><p class="title"><b>示例2.21。使用<code class="code">MarshallerFactory</code></b></p><div class="example-contents"><pre class="programlisting">
// ksession is the StatefulKnowledgeSession
// kbase is the KnowledgeBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><p><br class="example-break">但是，通过编组，在处理引用的用户数据时需要更大的灵活性。为此，我们拥有<code class="code">ObjectMarshallingStrategy</code>接口。提供了两种实现，但是用户可以实现自己的实现。提供的两个是<code class="code">IdentityMarshallingStrategy</code>和<code class="code">SerializeMarshallingStrategy</code> 。 <code class="code">SerializeMarshallingStrategy</code>是上面示例中使用的默认设置，它只调用<code class="code">Serializable</code>要么<code class="code">Externalizable</code>用户实例上的方法。 <code class="code">IdentityMarshallingStrategy</code>而是为每个用户对象创建一个int id并将其存储在<code class="code">Map</code> id被写入流中。拆组时，它看起来只是<code class="code">IdentityMarshallingStrategy</code>映射以检索实例。这意味着如果您使用<code class="code">IdentityMarshallingStrategy</code>它在Marshaller实例的生命期内具有状态，并将创建ID并保留对其尝试编组的所有对象的引用。

</p><div class="example"><a id="d0e547"></a><p class="title"><b>示例2.22使用代码<code class="code">IdentityMarshallingStrategy</code></b></p><div class="example-contents"><pre class="programlisting">
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase, new ObjectMarshallingStrategy[] { MarshallerFactory.newIdentityMarshallingStrategy() } );
marshaller.marshall( baos, ksession );
baos.close(); 
</pre></div></div><p><br class="example-break">为了增加灵活性，我们不能认为有一个适合自己的策略，因此我们添加了<code class="code">ObjectMarshallingStrategyAcceptor</code>每个接口<code class="code">ObjectMarshallingStrategy</code>拥有。编组器具有一系列策略，当尝试读取或写入用户对象时，它将迭代这些策略，询问它们是否接受将用户对象编组的责任。提供了一种实现<code class="code">ClassFilterAcceptor</code> 。这允许使用字符串和通配符来匹配类名。默认值为“ *。*”，因此在上面<code class="code">IdentityMarshallingStrategy</code>使用的是默认的“ *。*”接受器。但是可以说，我们要序列化除给定包之外的所有类，在该包中将使用身份查找，我们可以执行以下操作：</p><div class="example"><a id="d0e567"></a><p class="title"><b>示例2.23使用身份查询</b></p><div class="example-contents"><pre class="programlisting">
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectMarshallingStrategyAcceptor identityAceceptor = MarshallerFactory.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStratetgy = MarshallerFactory.newIdentityMarshallingStrategy( identityAceceptor );
Marshaller marshaller = MarshallerFactory.newMarshaller( kbase, new ObjectMarshallingStrategy[] { identityStratetgy, MarshallerFactory.newSerializeMarshallingStrategy() } );
marshaller.marshall( baos, ksession );
baos.close();
</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e572"></a> 2.1.3.18。知识代理</h4></div></div></div><p>的<code class="code">KnowlegeAgent</code>由创建<code class="code">KnowlegeAgentFactory</code> 。的<code class="code">KnowlegeAgent</code>提供自动加载，缓存和重新加载资源的功能，并通过属性文件进行配置。的<code class="code">KnowledgeAgent</code>可以更新或重建<code class="code">KnowlegeBase</code>随着它使用的资源发生变化。此策略由提供给工厂的配置确定，但通常使用常规轮询基于拉动。我们希望在将来的版本中添加基于推送的更新和重建。以下示例构造了一个将构建新代理的代理<code class="code">KnowledgeBase</code>从路径字符串中指定的文件。它将每30秒轮询一次这些文件，以查看它们是否已更新。如果找到新文件，则由于“ newInstance”设置为“ true”（因此，仅支持“ true”的值，并且将其硬编码到引擎中），它将构建一个新的知识库，而不是更新现有的知识库。 ：</p><div class="example"><a id="d0e595"></a><p class="title"><b>示例2.24构造一个代理</b></p><div class="example-contents"><pre class="programlisting">
// Set the interval on the ResourceChangeScannerService if you are to use it and default of 60s is not desirable.
ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();
sconf.setProperty( "drools.resource.scanner.interval",
                  "30" ); // set the disk scanning interval to 30s, default is 60s
ResourceFactory.getResourceChangeScannerService().configure( sconf );
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();
aconf.setProperty( "drools.agent.scanDirectories",
                  "true" ); // we want to scan directories, not just files, turning this on turns on file scanning
aconf.setProperty( "drools.agent.newInstance",
                  "true" ); // resource changes results in a new instance of the KnowledgeBase being built,
                            // this cannot currently be set to false for incremental building
    
KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( "test agent", // the name of the agent
                                                                kbase, // the KnowledgeBase to use, the Agent will also monitor any exist knowledge definitions
                                                                aconf );
kagent.applyChangeSet( ResourceFactory.newUrlResource( url ) ); // resource to the change-set xml for the resources to add
</pre></div></div><p><br class="example-break">

<code class="code">KnowledgeAgents</code>可以带空<code class="code">KnowledgeBase</code>或人口稠密的如果有人<code class="code">KnowledgeBase</code>提供， <code class="code">KnowledgeAgent</code>会迭代<code class="code">KnowledgeBase</code>并订阅<code class="code">Resource</code>它找到的。虽然有可能<code class="code">KnowledgeBuilder</code>要构建目录中找到的所有资源，该信息将被KnowledgeBuilder丢失，因此不会连续扫描这些目录。仅将目录指定为<code class="code">applyChangeSet(Resource)</code>方法受到监视。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e625"></a> 2.1.4。流口水</h3></div></div></div><p>Drools 4.0具有简单的“ RuleFlow”，用于编排规则。Drools 5.0引入了功能强大（可扩展）的工作流引擎。它允许用户同时使用规则和流程来指定其业务逻辑（可以在流程和规则之间进行强大的交互），并提供统一的环境。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e630"></a> 2.1.4.1。特定断点处的流程实例视图</h4></div></div></div><p>
</p><div class="figure"><a id="d0e635"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/process-instances.png" align="middle" alt="规则流属性"></div></div><p class="title"><b>图2.7。规则流属性</b></p></div><p><br class="figure-break">

</p><div class="figure"><a id="d0e642"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/example-debug-1.png" align="middle" alt="工作流中特定断点的当前活动节点"></div></div><p class="title"><b>图2.8。工作流中特定断点的当前活动节点</b></p></div><p><br class="figure-break">

	</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e649"></a> 2.1.4.2。新节点</h4></div></div></div><p>计时器：</p><p>可以添加一个计时器节点，该计时器节点使该节点的执行等待特定的时间。当前仅使用初始延迟和重复延迟的JDK默认值，更多里程碑中将提供更复杂的计时器。
</p><p>人工任务：</p><p>流程可以包括人类参与者需要执行的任务。人工任务包括任务名称，优先级，描述，actorId等参数。使用我们的可插入工作项，流程引擎可以轻松地与现有人工任务组件（例如WS-HumanTask实现）集成。还支持泳道和分配规则。

</p><p>屏幕快照中的调色板显示了这两个新组件，工作流本身显示了正在使用的人工任务。它还显示了两个“工作项”，将在下一节中对其进行说明：</p><div class="figure"><a id="d0e662"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/humantask.png" align="middle" alt="人工任务"></div></div><p class="title"><b>图2.9。人工任务</b></p></div><p><br class="figure-break">


	</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e669"></a> 2.1.4.3。特定领域的工作项目</h4></div></div></div><p>特定于域的工作项是用户创建的可插拔节点，以帮助自定义任务执行。它们提供了一个api，用于在任务属性的选项板和gui编辑器中指定一个新图标，如果未提供任何编辑gui，则默认为基于文本的键值对形式。然后，API允许指定这些工作项的执行行为。默认情况下，提供电子邮件和日志工作项。Drools流程手册已更新有关如何实现这些方法的信息。

</p><p>下图显示了工作流中使用的三个不同的工作项目：“血压”，“ BP药物治疗”，“通知GP”：</p><div class="figure"><a id="d0e676"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/CDSSExample.png" align="middle" alt="工作项目"></div></div><p class="title"><b>图2.10。工作项目</b></p></div><p><br class="figure-break">这欠了一个新的“通知”工作项：</p><div class="figure"><a id="d0e683"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/NotificationPalette.png" align="middle" alt="通知"></div></div><p class="title"><b>图2.11。通知</b></p></div><p><br class="figure-break">


	</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e690"></a> 2.1.4.4。可扩展过程定义语言（ePDL）</h4></div></div></div><p>Drools 4.0使用Xstream来存储它的内容，这是不容易人工编写的。Drools 5.0引入了ePDL，它是一种特定于我们的过程语言的XML，它还允许特定于域的扩展，在此博客文章“ Drools可扩展过程定义语言（ePDL）和语义模块框架（SMF）”中已对此进行了详细讨论。 ”。下面显示了XML语言的示例，其DSL扩展为红色。

</p><div class="example"><a id="d0e695"></a><p class="title"><b>示例2.25XML语言示例</b></p><div class="example-contents"><pre class="programlisting">
&lt;process  name="process name" id="process name" package-name="org.domain"
xmlns="http://drools.org/drools-4.0/process"
xmlns:mydsl="http://domain/org/mydsl"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:schemaLocation="http://drools.org/drools-4.0/process drools-processes-4.0.xsd" &gt;
&lt;nodes&gt;
  &lt;start id="0" /&gt;

  &lt;action id="1" dialect="java"&gt;
      list.add( "action node was here" ); 
  &lt;/action&gt;

    &lt;mydsl:logger id="2" type="warn"&gt;
        This is my message         
    &lt;mydsl:logger&gt;

  &lt;end id="3" /&gt;
&lt;/nodes&gt;

&lt;connections&gt;
  &lt;connection from="0 to="1" /&gt;
  &lt;connection from="1" to="2" /&gt;
  &lt;connection from="2" to="3" /&gt;
&lt;/connections&gt;

&lt;/process&gt;
</pre></div></div><p><br class="example-break">

	</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e701"></a> 2.1.4.5。可插拔节点</h4></div></div></div><p>该框架的基础节点是完全可插入的，从而使其易于扩展和实现其他执行模型。我们已经有OSWorkflow的部分实现，并且正在与Deigo合作完成此工作，从而为OSWorkflow用户提供了迁移路径。其他增强功能包括异常作用域，在各种节点类型上包括进入和退出操作的能力，与我们的二进制持久性机制集成以保持长时间运行的进程的状态等。请查看Drools Flow文档以了解更多信息。

	</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e706"></a> 2.1.4.6。人工任务</h4></div></div></div><p>人工任务管理在流程中非常重要。尽管我们允许用户插入他们喜欢的任何任务组件，但我们已经开发了一个人工任务管理组件，该组件基于WS-HumanTask规范支持人工任务的整个生命周期。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e711"></a> 2.1.4.7。Drools Flow语言的新功能</h4></div></div></div><p>

    </p><div class="itemizedlist"><ul><li><p>允许进程响应外部事件的事件节点</p></li><li><p>异常处理程序和异常处理程序作用域可处理可能引发的异常</p></li><li><p>ForEach节点允许针对集合中的每个元素多次实例化流程的一部分</p></li><li><p>数据类型支持已扩展</p></li><li><p>计时器与常见节点类型集成在一起</p></li></ul></div><p>结果，新的节点类型和属性已添加到Eclipse的Drools Flow编辑器中。您还可以在集成测试中找到这些新功能的示例（例如ProcessExceptionHandlerTest，ProcessTimerTest等）。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e733"></a> 2.1.4.8。工作项目</h4></div></div></div><p>我们的可插入工作项方法允许您以声明的方式在您的流程中插入特定于域的工作。我们计划建立一个通用工作项目库，并且已经提供了用于发送电子邮件，查找文件，存档，执行系统命令，记录日志和人工任务的实现。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e738"></a> 2.1.4.9。JPA</h4></div></div></div><p>改进了对持久性（JPA）和事务（JTA）的支持。
	</p><div class="example"><a id="d0e743"></a><p class="title"><b>示例2.26有关如何将持久性和事务与流程结合使用的示例</b></p><div class="example-contents"><pre class="programlisting">
// create a new JPA-based session and specify the JPA entity manager factory
Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY, Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER, TransactionManagerServices.getTransactionManager() );
        
StatefulKnowledgeSession ksession = JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env ); // KnowledgeSessionConfiguration may be null, and a default will be used
int sessionId = ksession.getId();

// if no transaction boundary is specified, the method invocation is executed in a new transaction automatically
ProcessInstance processInstance = ksession.startProcess( "org.drools.test.TestProcess" );

// the users can also specify the transaction boundary themselves
UserTransaction ut = (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( new Person( "John Doe" ) );
ksession.startProcess( "org.drools.test.TestProcess" );
ksession.fireAllRules();
ut.commit();</pre></div></div><p><br class="example-break">
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e749"></a> 2.1.4.10。可变注入</h4></div></div></div><p>支持在代码约束和操作中直接访问MVEL和Java中的过程变量，因此，如果您的过程中有一个名为“ person”的变量，则现在可以描述约束，例如：</p><div class="example"><a id="d0e754"></a><p class="title"><b>示例2.27可变注入示例</b></p><div class="example-contents"><pre class="programlisting">
    * [Java code constraint] return person.getAge() &gt; 20;
    * [MVEL action] System.out.println(person.name);</pre></div></div><p><br class="example-break">
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e760"></a> 2.1.4.11。杂项增强</h4></div></div></div><p>

    </p><div class="itemizedlist"><ul><li><p>现在，流程实例可以通过将事件节点属性“ external”标记为true来侦听外部事件。外部事件通过以下方式通知引擎<code class="code">session.signalEvent(type, eventData)</code>可在以下Drools Flow文档中找到有关如何在流程中使用事件的更多信息：https://hudson.jboss.org/hudson/job/drools/lastSuccessfulBuild/artifact/trunk/target/docs/drools-flow/ html / ch03.html＃d0e917</p></li><li><p>流程实例现在可以安全地用于多线程（因为阻止了多个线程在同一流程实例上工作）</p></li><li><p>流程持久性/事务支持得到了进一步改善。查看drools-process / drools-process-enterprise项目以获取更多信息。</p></li><li><p>人工任务组件已扩展为支持任务执行期间用于输入/输出/异常的各种数据。
	</p><div class="example"><a id="d0e781"></a><p class="title"><b>示例2.28结果，任务客户端的生命周期方法已扩展为允许内容数据</b></p><div class="example-contents"><pre class="programlisting">
          taskClient.addTask(task, contentData, responseHandler)
          taskClient.complete(taskId, userId, outputData,responseHandler)
          taskFail.complete(taskId, userId, outputData,responseHandler)

          long contentId = task.getTaskData().getDocumentContentId();
          taskClient.getContent(contentId, responseHandler);
          ContentData content = responseHandler.getContent();</pre></div></div><p><br class="example-break">

</p></li><li><p>现在可以在编译期间将旧的Drools4 RuleFlows（使用xstream格式）迁移到Drools5进程（使用可读的xml）。设置以下系统属性后，将RuleFlow添加到知识库时，将自动执行迁移：<code class="code">drools.ruleflow.port = true</code></p></li><li><p>“转换”工作项使您可以轻松地在内部流程中将数据从一种格式转换为另一种格式。该代码和示例可在drools-process / drools-workitems目录中找到。</p></li><li><p>现在，进程内部也支持函数导入。</p></li><li><p>历史记录日志-将所有已执行流程实例的历史记录保存在数据库中-已经扩展，因此现在可以为一个特定的流程实例存储更多详细信息。现在可以精确地找出在流程实例执行期间触发了哪些节点。</p></li><li><p>添加了一种新的联接，它将等待直到m个传入连接中的n个已完成。该n可以在过程中进行硬编码，也可以基于过程中变量的值进行编码。</p></li><li><p>进行了改进以使持久性更易于配置。持久性方法基于命令服务，该命令服务确保所有客户端调用都在事务内执行，并且在成功执行命令后将状态存储在数据库中。尽管在M4中直接使用命令已经可以做到这一点，但我们对此进行了扩展，以便人们可以简单地使用常规的StatefulKnowledgeSession接口，而可以使用配置文件配置持久性。有关更多详细信息，请参阅Drools Flow文档中有关持久性的章节。</p></li></ul></div><p>
</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e808"></a> 2.1.5。流口水融合</h3></div></div></div><p>Drools 5.0通过支持许多CEP功能以及在规则引擎中作为头等公民来支持事件，将事件处理的全部功能带到了规则世界。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e813"></a> 2.1.5.1。事件语义</h4></div></div></div><p>从规则引擎的角度来看，事件是一种特殊的事实，具有一些特殊特征：</p><div class="itemizedlist"><ul><li><p>他们是一成不变的</p></li><li><p>他们与时间的关系牢固</p></li><li><p>他们可能有清晰的生命周期窗口</p></li><li><p>它们的生命周期窗口过期后，可能会透明地收集垃圾</p></li><li><p>他们可能受时间限制</p></li><li><p>它们可能包含在滑动窗口中以进行推理</p></li></ul></div><p>
		</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e838"></a> 2.1.5.2。活动宣言</h4></div></div></div><p>任何事实类型都可以通过简单地声明它的元数据来承担事件角色及其相应的事件语义。
</p><div class="example"><a id="d0e843"></a><p class="title"><b>示例2.29现有的和生成的bean都支持事件语义：</b></p><div class="example-contents"><pre class="programlisting">
# existing bean assuming an event role
import org.drools.test.StockTick
declare StockTick
  @role( event )
end

# generated bean assuming an event role
declare Alarm
  @role( event )
  type : String
  timestamp : long
end</pre></div></div><p><br class="example-break">
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e849"></a> 2.1.5.3。入口点流侦听器</h4></div></div></div><p>已添加新的“来自入口点”键，以允许规则中的模式侦听流，这避免了必须将对象插入所有规则可能会推论到的工作内存中的开销。
</p><p><code class="code">$st : StockTick( company == "ACME", price > 10 ) from entry-point "stock stream"</code></p><p>
</p><p>
</p><div class="example"><a id="d0e861"></a><p class="title"><b>示例2.30将事实插入切入点</b></p><div class="example-contents"><pre class="programlisting">
WorkingMemoryEntryPoint entry = wm.getWorkingMemoryEntryPoint( "stock stream" );
entry.insert( ticker );
</pre></div></div><p><br class="example-break"></p><p>StreamTest为此显示一个单位。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e868"></a> 2.1.5.4。事件关联和新运算符</h4></div></div></div><p>事件相关性和基于时间的约束支持是事件处理的要求，并且Drools 5.0完全支持。在以下测试用例规则中可以看到新的开箱即用的时间约束运算符：test_CEP_TimeRelationalOperators.drl</p><p>从上面的测试中可以看到，Drools支持以下两种：原始事件（无持续时间的时间点事件）和复合事件（具有不同的开始和结束时间戳记的事件）。
</p><p>运算符的完整列表为：</p><div class="itemizedlist"><ul><li><p>巧合</p></li><li><p>之前</p></li><li><p>后</p></li><li><p>遇见</p></li><li><p>梅比</p></li><li><p>重叠</p></li><li><p>重叠的</p></li><li><p>中</p></li><li><p>包括</p></li><li><p>开始</p></li><li><p>开始于</p></li><li><p>完成</p></li><li><p>完成于</p></li></ul></div><p>
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e918"></a> 2.1.5.5。滑动时间窗</h4></div></div></div><p>Drools 5.0增加了对事件滑动窗口推理的支持。例如：</p><p><code class="code">StockTick( symbol == "RHAT" ) over window:time( 60 )</code></p><p>上面的示例将仅与最近60个时钟滴答中发生的RHAT股票滴答进行模式匹配，并丢弃任何早于该时间的事件。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e928"></a> 2.1.5.6。会话时钟</h4></div></div></div><p>要启用完整的事件处理功能，需要具有配置会话时钟并与之交互的能力。Drools增加了对时间推理和会话时钟配置的支持，从而使其不仅可以运行实时事件处理，还可以运行模拟，假设场景以及通过重播场景进行后处理审核。
</p><div class="example"><a id="d0e933"></a><p class="title"><b>示例2.31Clock被指定为SessionConfiguration的一部分，SessionConfiguration是一个新类，可以在会话创建时选择指定</b></p><div class="example-contents"><pre class="programlisting">
SessionConfiguration conf = new SessionConfiguration();
conf.setClockType( ClockType.PSEUDO_CLOCK );
StatefulSession session = ruleBase.newStatefulSession( conf );
</pre></div></div><p><br class="example-break">
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e939"></a> 2.1.5.7。活动垃圾收集</h4></div></div></div><p>由于事件通常具有很强的时间关系，因此可以推断事件可能匹配的逻辑时间窗口。引擎使用该功能来计算事件何时不再能够匹配任何规则，并自动撤回该事件。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e944"></a> 2.1.5.8。时间单位支持</h4></div></div></div><p>Drools根据持续时间的ISO 8601语法为时间单位采用了简化的语法。这使用户可以以众所周知的单位轻松地将时间约束添加到规则编写时间。例：</p><p>
<code class="code">SomeEvent( this after[1m,1h30m] $anotherEvent )</code>
</p><p>如果SomeEvent在1分钟（1m）至1小时30分钟后发生，则上述模式将匹配<code class="code">$anotherEvent</code> 。
</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e959"></a> 2.1.5.9。支持事件过期策略</h4></div></div></div><p>添加了定义每个类型的事件到期策略的功能。在下面的示例中，StockTick事件将在进入系统10分钟后过期：</p><p><code class="code">declare StockTick @role( event ) @expires( 10m ) end</code></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e967"></a> 2.1.5.10。支持任意日期的时间操作。</h4></div></div></div><p>
</p><div class="example"><a id="d0e972"></a><p class="title"><b>示例2.32添加了时间点运算符（之前，之后和重合）与任意日期字段一起使用的功能</b></p><div class="example-contents"><pre class="programlisting">rule "Allow access"
when
WorkHours( $s : start, $e : end )
LogIn( time after $s, time before $e )
then
// allow access
end
</pre></div></div><p><br class="example-break">
</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e978"></a> 2.1.6。Eclipse IDE</h3></div></div></div><div class="itemizedlist"><ul><li><p>支持多个运行时：IDE现在支持多个运行时。Drools运行时是文件系统上jar的集合，代表了一个特定版本的Drools项目jar。要创建运行时，您必须将IDE指向您选择的发行版，或者您可以简单地从Drools Eclipse插件中包含的jar在文件系统上创建一个新的运行时。可以通过打开Eclipse首选项并选择Drools-> Installed Drools Runtimes类别来配置Drools运行时，如下所示。
</p><div class="figure"><a id="d0e985"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/runtimes.png" align="middle" alt="运行时间"></div></div><p class="title"><b>图2.12。运行时间</b></p></div><p><br class="figure-break">


</p></li><li><p>修正了使用MVEL方言进行规则调试的问题</p></li><li><p>Drools Flow编辑器</p><div class="itemizedlist"><ul><li><p>使用流程外观，您可以定义如何显示不同的RuleFlow节点。现在，我们支持两种外观：以前存在的默认外观和使用类似BPMN的表示形式可视化节点的BPMN外观：http://blog.athico.com/2008/10/drools-flow-and-bpmn.html</p></li><li><p>（X）OR拆分现在将约束的名称显示为连接标签</p></li><li><p>定制工作项编辑器现在可以正确指示过程已被更改</p></li></ul></div><p>
</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1009"></a> 2.2。Drools 4.0中的新增功能</h2></div></div></div><p>Drools 4.0是对先前Drools 3.0.x系列的主要更新。开发了一套全新的功能，这些功能特别关注语言表达能力，引擎性能和工具可用性。以下是最有趣的更改列表。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1014"></a> 2.2.1。语言表达能力增强</h3></div></div></div><div class="itemizedlist"><ul><li><p>新的条件元素：来自，收集，累积和永久</p></li><li><p>新的字段约束运算符：不匹配，不包含，不包含在memberOf中，不在memberOf中</p></li><li><p>新的隐式自我参考字段：此</p></li><li><p>完全支持条件元素嵌套，以实现一阶逻辑完整性。</p></li><li><p>支持多约束和约束连接词&&和||</p></li><li><p>解析器改进，以消除以前的语言限制，例如字符转义和关键字冲突</p></li><li><p>支持可插拔的方言，并完全支持MVEL脚本语言</p></li><li><p>完全重写DSL引擎，允许完整的l10n</p></li><li><p>事实属性自动复活，用于返回值限制和内联评估约束</p></li><li><p>支持嵌套访问器，属性导航和简化的集合，数组和映射语法</p></li><li><p>改进了对XML规则的支持</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1051"></a> 2.2.2。核心引擎增强功能</h3></div></div></div><div class="itemizedlist"><ul><li><p>对原始类型的本地支持，避免了恒定的自动装箱</p></li><li><p>支持透明的可选阴影事实</p></li><li><p>Rete Network针对复杂规则的性能改进</p></li><li><p>支持规则流</p></li><li><p>支持有状态和无状态工作记忆（规则引擎会话）</p></li><li><p>支持异步工作内存操作</p></li><li><p>用于热部署和BRMS集成的Rule Engine代理</p></li><li><p>动态显着性解决规则冲突</p></li><li><p>支持参数化查询</p></li><li><p>支持暂停命令</p></li><li><p>支持顺序执行模式</p></li><li><p>支持可插拔全局变量解析器</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1091"></a> 2.2.3。IDE增强</h3></div></div></div><div class="itemizedlist"><ul><li><p>支持调试规则断点</p></li><li><p>所见即所得对规则流的支持</p></li><li><p>新的规则编辑指导编辑器</p></li><li><p>升级以支持所有新引擎功能</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1107"></a> 2.2.4。业务规则管理系统-BRMS</h3></div></div></div><div class="itemizedlist"><ul><li><p>新的BRMS工具</p></li><li><p>用户友好的Web界面，具有出色的WEB 2.0 ajax功能</p></li><li><p>套餐配置</p></li><li><p>规则创作易于使用向导编辑器（下拉菜单）和文本编辑器来编辑规则</p></li><li><p>软件包编译和部署</p></li><li><p>使用Rule Agent轻松部署</p></li><li><p>易于组织类别和搜索资产</p></li><li><p>启用版本控制后，您可以轻松地用之前保存的资产替换您的资产</p></li><li><p>符合JCR的规则资产存储库</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1138"></a> 2.2.5。杂项增强</h3></div></div></div><div class="itemizedlist"><ul><li><p>减少了依赖关系并减少了内存占用</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1145"></a> 2.3。从Drools 3.0.x升级到Drools 4.0.x的提示</h2></div></div></div><p>如前所述，Drools 4.0是对先前Drools 3.0.x系列的主要更新。不幸的是，为了实现此版本的目标，引入了一些向后兼容性问题，如邮件列表和博客中所讨论。</p><p>本手册的这一部分正在进行中，将记录从Drools 3.0.x升级到Drools 4.0.x的简单方法。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1152"></a> 2.3.1。API变更</h3></div></div></div><p>有一些API更改对普通用户可见，需要进行修复。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1157"></a> 2.3.1.1。工作记忆创建</h4></div></div></div><p>Drools 3.0.x只有一种工作存储器类型，其工作方式类似于有状态工作存储器。Drools 4.0.x引入了分别用于状态和无状态工作记忆的API，这些API现在称为“规则会话”。在Drools 3.0.x中，用于创建工作内存的代码为：</p><div class="example"><a id="d0e1163"></a><p class="title"><b>示例2.33Drools 3.0.x：工作记忆创建</b></p><div class="example-contents"><pre class="programlisting">WorkingMemory wm = rulebase.newWorkingMemory();</pre></div></div><p><br class="example-break">在Drools 4.0.x中，必须将其更改为：</p><div class="example"><a id="d0e1170"></a><p class="title"><b>示例2.34Drools 4.0.x：有状态规则会话创建</b></p><div class="example-contents"><pre class="programlisting">StatefulSession wm = rulebase.newStatefulSession();</pre></div></div><p><br class="example-break">StatefulSession对象的行为与Drools 3.0.x WorkingMemory相同（甚至扩展了WorkingMemory接口），因此此修复程序应该没有其他问题。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1176"></a> 2.3.1.2。工作记忆动作</h4></div></div></div><p>Drools 4.0.x现在支持可插入方言，并且内置了对Java和MVEL脚本语言的支持。为了避免关键字冲突，如下所示，将工作记忆操作重命名为：</p><p></p><div class="table"><a id="d0e1182"></a><p class="title"><b>表2.1。工作记忆操作等效的API方法</b></p><div class="table-contents"><table border="1" summary="Working Memory Actions equivalent API methods"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>流口水3.0.x</strong></span></td><td><span class="bold"><strong>流口水4.0.x</strong></span></td></tr><tr><td>WorkingMemory.assertObject（）</td><td>WorkingMemory.insert（）</td></tr><tr><td>WorkingMemory.assertLogicalObject（）</td><td>WorkingMemory.insertLogical（）</td></tr><tr><td>WorkingMemory.modifyObject（）</td><td>WorkingMemory.update（）</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1209"></a> 2.3.2。规则语言变更</h3></div></div></div><p>DRL规则语言还具有一些向后不兼容的更改，如下所示。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1214"></a> 2.3.2.1。工作记忆动作</h4></div></div></div><p>规则后果中的“工作内存”操作也以与API中所做的更改类似的方式进行了更改。下表总结了更改：</p><div class="table"><a id="d0e1219"></a><p class="title"><b>表2.2。工作记忆操作等效的DRL命令</b></p><div class="table-contents"><table border="1" summary="Working Memory Actions equivalent DRL commands"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>流口水3.0.x</strong></span></td><td><span class="bold"><strong>流口水4.0.x</strong></span></td></tr><tr><td>断言（）</td><td>插入（）</td></tr><tr><td>assertLogical（）</td><td>insertLogical（）</td></tr><tr><td>修改（）</td><td>update（）</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1246"></a> 2.3.2.2。基本支持和拆箱</h4></div></div></div><p>Drools 3.0.x没有对原始类型的本地支持，因此，它将所有原始类型自动装箱在各自的包装器类中。这样，对装箱变量绑定的任何使用都需要手动取消装箱。</p><p>Drools 4.0.x完全支持基本类型，并且不再包装任何值。因此，必须从DRL中删除所有以前的展开方法调用。</p><div class="example"><a id="d0e1253"></a><p class="title"><b>示例2.35Drools 3.0.x手动解包</b></p><div class="example-contents"><pre class="programlisting">rule "Primitive int manual unbox"
when
    $c : Cheese( $price : price )
then
    $c.setPrice( $price<span class="bold"><strong>.intValue()</strong></span> * 2 )
end
</pre></div></div><br class="example-break"><p>4.0.x中的上述规则为：</p><div class="example"><a id="d0e1263"></a><p class="title"><b>示例2.36Drools 4.0.x基本支持</b></p><div class="example-contents"><pre class="programlisting">rule "Primitive support"
when
    $c : Cheese( $price : price )
then
    $c.setPrice( $price * 2 )
end
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1268"></a> 2.3.3。Drools更新工具</h3></div></div></div><p>Drools更新工具是一个简单的程序，可帮助将DRL文件从Drools 3.0.x升级到Drools4.0.x。</p><p>此时，其主要目标是将内存操作调用从3.0.x升级到4.0.x，但希望它在接下来的几周内会增长，涉及其他场景。重要的是要注意，它不会在规则文件中进行愚蠢的文本搜索和替换，但实际上是在解析规则文件并尝试确保它没有做任何意外的事情，因此，它是一个使用安全的工具用于升级大量规则文件。</p><p>您可以在以下源代码库http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/experimental/drools-update/中找到Drools更新工具作为Maven项目，您只需将其签出并执行使用项目的pom.xml文件进行的maven全新安装操作。解决所有类路径依赖关系后，您可以使用以下命令运行收费：</p><pre class="programlisting">java -cp $CLASSPATH org.drools.tools.update.UpdateTool -f &lt;filemask&gt; [-d &lt;basedir&gt;] [-s &lt;sufix&gt;]</pre><p>程序参数很容易理解，如下所示。
    </p><div class="itemizedlist"><ul><li><p>-h，-help，显示一个非常简单的用法帮助列表</p></li><li><p>-d您的源基本目录</p></li><li><p>-f模式，用于更新文件。格式与ANT使用的格式相同：* =单个文件，目录** =任意级别的子目录示例：src / main / resources / ** / *。drl =匹配/ src / main的任何子目录中的所有DRL文件/资源</p></li><li><p>-s，-sufix将要添加到所有更新文件的sufix</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1294"></a> 2.3.4。Drools 4.0中的DSL语法</h3></div></div></div><p>重要的是要注意，DSL模板引擎是从头开始重写的，以提高灵活性。DSL语法的新功能之一是对正则表达式的支持。这样，现在您可以使用regexp编写映射，以具有更大的灵活性，如DSL章节中所述。虽然，现在您必须转义具有regexp含义的字符。示例：如果以前有类似的匹配项：</p><div class="example"><a id="d0e1299"></a><p class="title"><b>示例2.37Drools 3.0.x映射</b></p><div class="example-contents"><pre class="programlisting">[when][]- the {attr} is in [ {values} ]={attr} in ( {values} )</pre></div></div><br class="example-break"><p>现在，您需要转义'['和']'字符，因为它们在正则表达式中具有特殊含义。因此，Drools 4.0中的相同映射为：</p><div class="example"><a id="d0e1306"></a><p class="title"><b>示例2.38Drools 4.0.x带有转义字符的映射</b></p><div class="example-contents"><pre class="programlisting">[when][]- the {attr} is in \[ {values} \]={attr} in ( {values} )</pre></div></div><br class="example-break"></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1311"></a> 2.3.5。4.0.2的规则流更新</h3></div></div></div><p>规则流功能针对4.0.2进行了更新，现在所有规则流都必须声明一个程序包名称。
    </p><div class="figure"><a id="d0e1316"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Release_Notes/ruleflowproperties.png" align="middle" alt="规则流属性"></div></div><p class="title"><b>图2.13。规则流属性</b></p></div><br class="figure-break"></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1322"></a>第3章。安装和设置（Core和IDE）</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1325">3.1。安装和使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1337">3.1.1。依赖和罐子</a></span></dt><dt><span class="section"><a href="#d0e1366">3.1.2。运行</a></span></dt><dt><span class="section"><a href="#d0e1371">3.1.3。安装IDE（Rule Workbench）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1473">3.2。从源安装</a></span></dt><dt><span class="section"><a href="#d0e1532">3.3。源结帐</a></span></dt><dt><span class="section"><a href="#d0e1583">3.4。建立</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1586">3.4.1。建立源</a></span></dt><dt><span class="section"><a href="#d0e1615">3.4.2。建立手册</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1667">3.5。日食</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1670">3.5.1。导入Eclipse项目</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1325"></a> 3.1。安装和使用</h2></div></div></div><p>Drools提供了一个基于Eclipse的IDE（可选），但其核心仅需要Java 1.5（Java SE）。</p><p>一种简单的入门方法是下载并安装Eclipse插件-这也将需要安装Eclipse GEF框架（如果尚未安装，请参见下文）。这将为您提供开始所需的所有依赖项：您只需创建一个新的规则项目，一切都将为您完成。有关此方面的详细说明，请参阅Rule Workbench和IDE上的章节。安装Eclipse插件通常很简单，只需将文件解压缩到Eclipse插件目录中即可。</p><p>不需要使用Eclipse插件。规则文件只是文本输入（或视情况而定的电子表格），而IDE（也称为Rule Workbench）只是一种便利。人们以多种方式集成了规则引擎，没有“一刀切”的功能。</p><p>或者，您可以下载二进制发行版，并将相关的jar包含在项目的类路径中。</p><p></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1337"></a> 3.1.1。依赖和罐子</h3></div></div></div><p>Drools分为几个模块，在规则开发/编译过程中需要一些模块，在运行时需要一些模块。在许多情况下，人们只是想在运行时包括所有依赖项，这很好。它使您拥有最大的灵活性。但是，有些人可能希望将其“运行时”精简到最低限度，因为他们将以二进制形式部署规则-这也是可能的。核心运行时引擎可以非常紧凑，并且在2个jar文件中仅需要几百KB。</p><p>以下是构成JBoss规则的重要库的描述</p><div class="itemizedlist"><ul><li><p>drools-api.jar-提供接口和工厂。Drools-api还可以帮助清楚地显示什么是用户api以及什么是引擎api。</p></li><li><p>drools-core.jar-这是核心引擎，运行时组件。同时包含RETE引擎和LEAPS引擎。如果要预编译规则（并通过Package或RuleBase对象进行部署），则这是唯一的运行时依赖项。</p></li><li><p>drools-compiler.jar-它包含编译器/构建器组件，以获取规则源并构建可执行规则库。这通常是应用程序的运行时依赖项，但是如果您正在预编译规则，则不必如此。这取决于流口水核心</p></li><li><p>drools-jsr94.jar-这是JSR-94兼容的实现，它实质上是drools-compiler组件上的一层。请注意，由于JSR-94规范的性质，并非所有功能都可以通过此接口轻松公开。在某些情况下，直接进入Drools API会更容易，但是在某些环境中，必须使用JSR-94。</p></li><li><p>drools-decisiontables.jar-这是决策表的“编译器”组件，它使用drools-compiler组件。这支持excel和CSV输入格式。</p></li></ul></div><p>上述组件还需要其他一些依赖项，其中大多数依赖于drools-compiler，drools-jsr94或drools-decisiontables模块。需要注意的一些关键是提供电子表格分析功能的“ POI”和提供规则语言本身的分析的“ antlr”。</p><p>注意：如果在J2EE或Servlet容器中使用Drools，并且遇到“ JDT”的类路径问题，则可以切换到janino编译器。设置系统属性“ drools.compiler”：例如：-Ddrools.compiler = JANINO。</p><p>有关发行版中依赖项的最新信息，请查阅README_DEPENDENCIES.txt文件，该文件位于下载包的lib目录中或项目目录的根目录中。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1366"></a> 3.1.2。运行</h3></div></div></div><p>这里提到的“运行时”要求是如果您以规则的二进制形式（以KnowledgePackage对象或KnowledgeBase对象等）的形式部署规则。这是一项可选功能，可以使您的运行时保持良好状态。您可以使用drools-compiler生成“进程外”规则包，然后将其部署到运行时系统。该运行时系统仅需要drools-core.jar和drools-api即可执行。这是一种可选的部署模式，许多人不需要过多地“修剪”他们的应用程序，但是对于某些环境来说，它是理想的选择。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1371"></a> 3.1.3。安装IDE（Rule Workbench）</h3></div></div></div><p>规则工作台（对于Eclipse）要求您具有Eclipse 3.4或更高版本，以及Eclipse GEF 3.4或更高版本。您可以通过下载插件或使用更新站点来安装它。</p><p>另一个选择是使用JBoss IDE，它预先包装了所有插件要求，并提供了一些独立于规则的其他工具。您可以选择仅从JBoss IDE附带的“捆绑包”中安装规则。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1378"></a> 3.1.3.1。安装GEF（必需的依赖项）</h4></div></div></div><p>GEF是Eclipse图形编辑框架，用于查看插件中的图形。</p><p>如果未安装GEF，则可以使用内置的更新机制进行安装（或不建议从Eclipse.org网站下载GEF）。JBoss IDE和Eclipse的许多其他“发行版”一样，已经具有GEF，因此对于某些人来说，此步骤可能是多余的。</p><p>打开帮助->软件更新...->可用软件->添加站点...从帮助菜单。位置是：</p><pre class="programlisting">http://download.eclipse.org/tools/gef/updates/releases/</pre><p>接下来，选择GEF插件：</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/install_gef.png"></div></div><p>按下一步，并同意安装插件（可能需要重新启动Eclipse）。完成此操作后，即可继续安装规则插件。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1397"></a> 3.1.3.2。从zip文件安装GEF</h4></div></div></div><p>要从zip文件安装，请下载并解压缩该文件。在zip内，您将看到一个插件目录以及插件jar本身。您将插件jar放入Eclipse应用程序插件目录，然后重新启动Eclipse。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1402"></a> 3.1.3.3。从zip文件安装Drools插件</h4></div></div></div><p>从下面的链接下载Drools Eclipse IDE插件。将下载的文件解压缩到您的主eclipse文件夹中（不要只是将文件复制到那里，解压缩它，以便功能和插件jar最终位于eclipse的功能和插件目录中）并（重新）启动Eclipse。</p><p><a class="ulink" href="http://www.jboss.org/drools/downloads.html">http://www.jboss.org/drools/downloads.html</a></p><p>要检查安装是否成功，请尝试打开Drools透视图：单击Eclipse窗口右上角的“打开透视图”按钮，选择“其他...”，然后选择Drools透视图。如果您找不到Drools透视图作为可能的透视图之一，则说明安装可能不成功。检查是否正确执行了每个必需的步骤：您是否具有正确版本的Eclipse（3.4.x）？是否已安装Eclipse GEF（请检查org.eclipse.gef_3.4。* .jar是否存在于Eclipse根文件夹的plugins目录中？您是否正确提取了Drools Eclipse插件（检查Eclipse根文件夹中的plugins目录中是否存在org.drools.eclipse _ *。jar）？如果您找不到问题，请尝试与我们联系（例如，在irc或用户邮件列表中），可以在这里找到我们主页上没有的更多信息：</p><p><a class="ulink" href="http://www.jboss.org/drools/">http://www.jboss.org/drools/</a></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1415"></a> 3.1.3.4。流口水运行时</h4></div></div></div><p>Drools运行时是文件系统上jar的集合，代表了一个特定版本的Drools项目jar。要创建运行时，您必须将IDE指向您选择的版本。如果要基于插件本身包含的最新Drools项目jar创建新的运行时，则也可以轻松地做到这一点。您需要为Eclipse工作区指定默认的Drools运行时，但是每个单独的项目都可以覆盖默认值，并为该项目选择适当的运行时。</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1420"></a> 3.1.3.4.1。定义Drools运行时</h5></div></div></div><p>您需要使用Eclipse首选项视图定义一个或多个Drools运行时。要打开您的首选项，请在菜单窗口中选择首选项菜单项。新的首选项对话框应显示您的所有首选项。在此对话框的左侧，在Drools类别下，选择“ Installed Drools runtimes”。然后，右侧面板应显示当前定义的Drools运行时。如果尚未定义任何运行时，则应类似于下图所示。</p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes.png" align="middle"></div><p>要定义新的Drools运行时，请单击添加按钮。将会弹出一个如下所示的对话框，要求您提供运行时的名称以及在文件系统上可以找到它的位置。</p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes-add.png" align="middle"></div><p>通常，您有两种选择：</p><div class="orderedlist"><ol type="1"><li><p>如果您只想使用Drools Eclipse插件中包含的默认jar，则可以通过单击“创建新的Drools 5运行时...”按钮来自动创建新的Drools运行时。将显示一个文件浏览器，要求您在文件系统上选择要在其中创建运行时的文件夹。然后，插件将自动将所有必需的依赖项复制到指定的文件夹。选择此文件夹后，对话框应如下图所示。</p></li><li><p>如果要使用Drools项目的一个特定版本，则应在文件系统上创建一个文件夹，其中包含所有必需的Drools库和依赖项。不要像上面解释的那样创建新的Drools运行时，而是给运行时命名并选择包含所有必需jar的文件夹的位置。</p></li></ol></div><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes-add2.png" align="middle"></div><p>单击确定按钮后，运行时将显示在已安装的Drools运行时表中，如下所示。单击新创建的运行时前面的复选框，将其设置为默认的Drools运行时。默认的Drools运行时将用作所有尚未选择项目特定运行时的Drools项目的运行时。
      </p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes2.png" align="middle"></div><p>您可以根据需要添加任意数量的Drools运行时。例如，以下屏幕截图显示了已定义三个运行时的配置：Drools 4.0.7运行时，Drools 5.0.0运行时和Drools 5.0.0。SNAPSHOT运行时。Drools 5.0.0运行时被选择为默认运行时。</p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes3.png" align="middle"></div><p>请注意，如果您更改了默认运行时，则需要重新启动Eclipse，并且要确保所有使用默认运行时的项目都相应地更新其类路径。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e1457"></a> 3.1.3.4.2。为您的Drools项目选择运行时</h5></div></div></div><p>每当您创建Drools项目时（使用“ New Drools项目”向导，或者使用在Drools透视图中显示的“转换为Drools项目”操作将现有的Java项目转换为Drools项目，然后右键单击现有项目） Java项目），该插件会自动将所有必需的jar添加到您项目的类路径中。</p><p>当创建一个新的Drools项目时，除非您指定一个特定于项目的插件，否则插件将自动使用该项目的默认Drools运行时。您可以在“新建Drools项目”向导的最后一步中执行此操作，如下所示，方法是取消选中“使用默认Drools运行时”复选框，然后在下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。</p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes-newproject.png" align="middle"></div><p>您可以随时打开项目属性（右键单击该项目并选择“属性”），然后选择Drools类别，以随时更改Drools项目的运行时，如下所示。选中“启用项目特定设置”复选框，然后从下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。如果取消选中“启用项目特定设置”复选框，它将使用全局首选项中定义的默认运行时。</p><div class="mediaobject" align="center"><img src="images/Chapter-Install/drools-runtimes-project.png" align="middle"></div></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1473"></a> 3.2。从源安装</h2></div></div></div><p>由于Drools是一个开源项目，因此从源代码进行构建的说明是本手册的一部分！从源代码构建意味着您可以掌握最新功能。尽管Drools的各个方面非常复杂，但许多用户已经找到了成为贡献者的方法。</p><p>Drools可与JDK1.5及更高版本一起使用。您还需要安装以下工具。提供的最低要求版本号。</p><div class="itemizedlist"><ul><li><p><a id="d0e1483" class="indexterm"></a> Eclipse 3.4</p><p>http://www.eclipse.org/</p></li><li><p><a id="d0e1491" class="indexterm"></a> Subversion客户端1.4</p><p>http://subversion.tigris.org</p><p><a id="d0e1498" class="indexterm"></a> http://tortoisesvn.tigris.org-推荐的Win32客户端</p></li><li><p><a id="d0e1504" class="indexterm"></a> Maven的2.0.9</p><p>http://maven.apache.org/</p></li><li><p><a id="d0e1512" class="indexterm"></a>蚂蚁1.7.0</p><p>http://ant.apache.org</p></li></ul></div><p>确保ant，maven和java的可执行文件在您的<a id="d0e1520" class="indexterm"></a>路径。给出的示例是说明性的，并且适用于win32系统：</p><div class="literallayout"><p>路径= D：\ java \ j2sdk1.5.0_8 \ bin; D：\ java \ apache-ant-1.7 \ bin; D：\ java \ maven-2.0.9 \ bin</p></div><p>还需要设置以下环境变量。给出的示例是说明性的，并且适用于win32系统：</p><div class="literallayout"><p>JAVA_HOME = D：\ java \ j2sdk1.5.0_8<br>ANT_HOME = D：\ java \ apache-ant-1.7<br>MAVEN_HOME = D：\ java \ maven-2.0.9<br>
<br>
</p></div><p>过去的发行版曾经具有基于ant的构建机制，但是现在maven是强制性的，尽管在maven内部使用了Ant来进行文档构建。</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1532"></a> 3.3。源结帐</h2></div></div></div><p>流口水从两个可用<a id="d0e1537" class="indexterm"></a> Subversion存储库。</p><div class="itemizedlist"><ul><li><p>匿名SVN</p><p>http://anonsvn.jboss.org/repos/labs/labs/jbossrules/trunk/</p></li><li><p>开发人员获得了SVN</p><p>https://svn.jboss.org/repos/labs/labs/jbossrules/trunk/</p></li></ul></div>要签出Drools源代码，只需执行以下命令。

<pre class="programlisting">fmeyer:~/jboss $ svn checkout http://anonsvn.jboss.org/repos/labs/labs/jbossrules/trunk/ trunk</pre>并等待完成文件下载。

<pre class="programlisting">A    trunk/drools-repository
A    trunk/drools-repository/.classpath
A    trunk/drools-repository/.project
A    trunk/drools-repository/doc
A    trunk/drools-repository/doc/repository_layout.jpeg
A    trunk/drools-repository/doc/high_level_design.jpeg
A    trunk/drools-repository/doc/javadoc
A    trunk/drools-repository/doc/javadoc/serialized-form.html
A    trunk/drools-repository/doc/javadoc/index-all.html
A    trunk/drools-repository/doc/javadoc/stylesheet.css
A    trunk/drools-repository/doc/javadoc/allclasses-frame.html
A    trunk/drools-repository/doc/javadoc/package-list
A    trunk/drools-repository/doc/javadoc/overview-tree.html
A    trunk/drools-repository/doc/javadoc/org
A    trunk/drools-repository/doc/javadoc/org/drools
A    trunk/drools-repository/doc/javadoc/org/drools/repository
A    trunk/drools-repository/doc/javadoc/org/drools/repository/class-use
A    trunk/drools-repository/doc/javadoc/org/drools/repository/class-use/RuleSet.html
A    trunk/drools-repository/doc/javadoc/org/drools/repository/class-use/RulesRepositoryException.html
A    trunk/drools-repository/doc/javadoc/org/drools/repository/class-use/RulesRepository.html
A    trunk/drools-repository/doc/javadoc/org/drools/repository/RuleSet.html

....

snip 

....

A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltz
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltz/waltz.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/manners
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/manners/manners.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltzdb
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltzdb/waltzdb.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/TroubleTicketWithDSL.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/TroubleTicket.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/calculate.rfm
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/generation.rf
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/calculate.rf
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/registerNeighbor.rfm
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/killAll.rfm
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/registerNeighbor.rf
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/conway-agendagroup.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/killAll.rf
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/conway-ruleflow.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/generation.rfm
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/ticketing.dsl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleUsingSalience.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/golf.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/LogicalAssertionsNotPingPong.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleDynamicRule.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/sudoku
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/sudoku/sudoku.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/HelloWorld.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/ExamplePolicyPricing.xls
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/HonestPolitician.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/Fibonacci.drl
A    trunk/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleUsingAgendGroup.drl
A    trunk/drools-examples/drools-examples-drl/pom.xml
A    trunk/drools-examples/drools-examples-drl/build.xml
 U   trunk
Checked out revision 13656.</pre><p>尽管我们强烈建议命令行工具与存储库一起使用，但是您也可以同时使用Eclipse的集成SVN客户端或TortoiseSVN</p><p>设置TortoiseSVN以从Subversion存储库中检出，然后单击<code class="literal">'OK'</code>结帐完成后，您将看到如下所示的文件夹。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/svn_checkout1.png"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/svn_checkout2.png"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/svn_checkout3.png"></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1583"></a> 3.4。建立</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1586"></a> 3.4.1。建立源</h3></div></div></div><p>现在我们已经有了源代码，下一步就是构建和安装源代码。从版本3.1开始，Drools使用Maven 2来构建系统。有两个可用的概要文件，这些概要文件使关联的模块“文档”和“ Eclipse”成为可能。这使开发人员可以更快地构建核心模块。Eclipse配置文件会将Eclipse下载到drools-Eclipse文件夹中，该文件夹的下载量超过100MB（取决于您的操作系统），但是只需要执行一次；如果愿意，可以将Eclipse下载移动到另一个位置，并使用-DlocalEclipseDrop = / folder / jboss-drools / local-Eclipse-drop-mirror指定它。以下代码使用指定的本地文件夹来构建所有jar，文档和Eclipse zip，以避免下载Eclipse：</p><pre class="programlisting">mvn -Declipse -Ddocumentation clean install -DlocalEclipseDrop=/folder/jboss-drools/local-Eclipse-drop-mirror </pre><p>您可以生成发行版本，将所有内容放入zip中，如下所示：</p><pre class="programlisting">mvn -Declipse -Ddocumentation clean install -DlocalEclipseDrop=/folder/jboss-drools/local-Eclipse-drop-mirror
mvn -Ddocumentation -Declipse -Dmaven.test.skip package javadoc:javadoc assembly:assembly -DlocalEclipseDrop=/folder/jboss-drools/local-Eclipse-drop-mirror
</pre><p>请注意，必须首先完成安装，因为javadoc：javadoc除非罐子位于本地maven存储库中才起作用，但是可以在第二次运行时跳过测试。 assembly：除非您增加Maven的可用内存，否则组装失败，在Windows上，以下命令运行良好：set MAVEN_OPTS = -Xmx512m</p><p>键入mvn clean清除旧的工件，然后测试并构建源，并报告任何错误。</p><p>生成的jar放在项目顶层的/ target目录中。</p><p>当maven构建每个模块时，它将自动在本地Maven 2存储库中安装生成的jar。可以从其他项目轻松使用的地方<code class="literal">pom.xml</code>或复制到其他地方。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/mvn_install4.png"></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1615"></a> 3.4.2。建立手册</h3></div></div></div><p>现在，手册的构建已集成到maven的构建过程中，并且可以通过使用配置文件（-Ddocumentation）开关或编入主目录来构建。
	</p><p>流口水的用途<a id="d0e1622" class="indexterm"></a>本手册的Docbook。Maven用于构建文档，该构建产生三种不同的格式，所有格式共享相同的图像目录。</p><div class="itemizedlist"><ul><li><p>html_single</p><p>整个手册在一个html文档中</p></li><li><p><a id="d0e1634" class="indexterm"></a> html</p><p>该手册分为多个文档并放在框架集中。左框架提供导航</p></li><li><p>日食</p><p>适用于包含在Eclipse插件中的文档</p></li></ul></div><p>可以通过调用pom.xml项目生成手册<code class="literal">'mvn package'</code>构建源时，请在drools-docs目录中添加或添加-Ddocumentation开关。文档被生成到每个drools-docs子目录的<code class="literal">'target/'</code>目录。跑步<code class="literal">'mvn -Ddocumentation package assembly:assembly'</code>在Drools项目根目录中，将生成文档并将其复制到zip文件中。该zip文件位于根文件夹中<code class="literal">'target/'</code>目录。

    </p><pre class="programlisting">[trikkola@trikkola trunk]$ mvn -Ddocumentation clean package assembly:assembly
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   Drools
[INFO]   Drools :: API
[INFO]   Drools :: Core
[INFO]   Drools :: Compiler
[INFO]   Drools :: Templates
[INFO]   Drools :: Decision Tables
[INFO]   Drools :: JSR-94 API Module
[INFO]   Drools :: Pipeline :: Transformer :: Smooks
[INFO]   Drools :: Pipeline :: Transformer :: JAXB
[INFO]   Drools :: Pipeline :: Transformer :: XStream
[INFO]   Drools :: Pipeline :: Transformer :: JXLS
[INFO]   Drools :: Pipeline :: Messenger :: JMS
[INFO]   Drools :: Pipeline
[INFO]   Drools :: Process :: WorkItems
[INFO]   Drools :: Process :: Task
[INFO]   Drools :: Process :: BAM
[INFO]   Drools :: Process
[INFO]   Drools :: Persistence :: JPA
[INFO]   Drools :: Server
[INFO]   Drools :: Verifier
[INFO]   Drools :: Ant Task
[INFO]   Drools :: Repository
[INFO]   Drools :: Guvnor
[INFO]   Drools :: Microcontainer
[INFO]   Drools :: Clips
[INFO]   Drools :: Solver parent
[INFO]   Drools :: Solver core
[INFO]   Drools :: Solver examples
[INFO] Searching repository for plugin with prefix: 'assembly'.
WAGON_VERSION: 1.0-beta-2
[INFO] ------------------------------------------------------------------------
[INFO] Building Drools
[INFO]    task-segment: [clean, package]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] [site:attach-descriptor]
[INFO] Preparing source:jar
[WARNING] Removing: jar from forked lifecycle, to prevent recursive invocation.
[INFO] No goals needed for project - skipping
[INFO] [source:jar {execution: default}]
[INFO] Preparing source:test-jar
[WARNING] Removing: jar from forked lifecycle, to prevent recursive invocation.
[WARNING] Removing: test-jar from forked lifecycle, to prevent recursive invocation.
[INFO] No goals needed for project - skipping
[INFO] [source:test-jar {execution: default}]
[INFO] ------------------------------------------------------------------------
[INFO] Building Drools :: API
[INFO]    task-segment: [clean, package]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] Deleting directory /home/trikkola/jboss-drools/trunk/drools-api/target

...snip ...

[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Drools ................................................ SUCCESS [59.889s]
[INFO] Drools :: API ......................................... SUCCESS [4.832s]
[INFO] Drools :: Core ........................................ SUCCESS [11.027s]
[INFO] Drools :: Compiler .................................... SUCCESS [10.400s]
[INFO] Drools :: Templates ................................... SUCCESS [1.018s]
[INFO] Drools :: Decision Tables ............................. SUCCESS [1.179s]
[INFO] Drools :: JSR-94 API Module ........................... SUCCESS [1.001s]
[INFO] Drools :: Pipeline :: Transformer :: Smooks ........... SUCCESS [0.651s]
[INFO] Drools :: Pipeline :: Transformer :: JAXB ............. SUCCESS [0.711s]
[INFO] Drools :: Pipeline :: Transformer :: XStream .......... SUCCESS [0.465s]
[INFO] Drools :: Pipeline :: Transformer :: JXLS ............. SUCCESS [0.481s]
[INFO] Drools :: Pipeline :: Messenger :: JMS ................ SUCCESS [0.879s]
[INFO] Drools :: Pipeline .................................... SUCCESS [0.006s]
[INFO] Drools :: Process :: WorkItems ........................ SUCCESS [1.526s]
[INFO] Drools :: Process :: Task ............................. SUCCESS [3.104s]
[INFO] Drools :: Process :: BAM .............................. SUCCESS [0.580s]
[INFO] Drools :: Process ..................................... SUCCESS [0.005s]
[INFO] Drools :: Persistence :: JPA .......................... SUCCESS [0.958s]
[INFO] Drools :: Server ...................................... SUCCESS [2.216s]
[INFO] Drools :: Verifier .................................... SUCCESS [1.836s]
[INFO] Drools :: Ant Task .................................... SUCCESS [0.722s]
[INFO] Drools :: Repository .................................. SUCCESS [3.925s]
[INFO] Drools :: Guvnor ...................................... SUCCESS [19.850s]
[INFO] Drools :: Microcontainer .............................. SUCCESS [0.676s]
[INFO] Drools :: Clips ....................................... SUCCESS [1.464s]
[INFO] Drools :: Solver parent ............................... SUCCESS [0.527s]
[INFO] Drools :: Solver core ................................. SUCCESS [2.209s]
[INFO] Drools :: Solver examples ............................. SUCCESS [4.689s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 minutes 24 seconds
[INFO] Finished at: Tue Apr 07 15:11:14 EEST 2009
[INFO] Final Memory: 48M/178M
[INFO] ------------------------------------------------------------------------&gt;</pre><p>
    </p><p>生成的手册可以在<code class="literal">target\drools-docs$VERSION.jar'</code>文件，所有格式的压缩档案。</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1667"></a> 3.5。日食</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1670"></a> 3.5.1。导入Eclipse项目</h3></div></div></div><p>随着<a id="d0e1675" class="indexterm"></a>生成的Eclipse项目文件现在可以导入Eclipse。启动Eclipse时，在Subversion检出的根目录中打开工作区。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import2.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import3.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import4.jpg"></div></div><p>打电话时<code class="literal">'mvn install'</code>所有项目依赖项均已下载并添加到本地Maven存储库。除非您告诉它存储库在哪里，否则Eclipse无法找到那些依赖项。为此，请设置M2_REPO类路径变量。</p><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import6.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import7.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import8.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Chapter-Install/eclipse_import9.jpg"></div></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1733"></a>指数</h2></div></div></div><div class="index"><div class="indexdiv"><h3>一种</h3><dl><dt>ant， <a class="indexterm" href="#d0e1473">从源安装</a></dt></dl></div><div class="indexdiv"><h3>d</h3><dl><dt>docbook， <a class="indexterm" href="#d0e1615">构建手册</a></dt></dl></div><div class="indexdiv"><h3>Ë</h3><dl><dt>eclipse， <a class="indexterm" href="#d0e1473">从源安装</a></dt><dt>Eclipse， <a class="indexterm" href="#d0e1670">导入Eclipse项目</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>html， <a class="indexterm" href="#d0e1615">构建手册</a></dt></dl></div><div class="indexdiv"><h3>中号</h3><dl><dt>maven， <a class="indexterm" href="#d0e1473">从源安装</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>路径， <a class="indexterm" href="#d0e1473">从源安装</a></dt></dl></div><div class="indexdiv"><h3>小号</h3><dl><dt>颠覆， <a class="indexterm" href="#d0e1473">从源安装</a> ， <a class="indexterm" href="#d0e1532">源签出</a></dt></dl></div><div class="indexdiv"><h3>Ť</h3><dl><dt>TortoiseSVN， <a class="indexterm" href="#d0e1473">从源安装</a></dt></dl></div></div></div></div></body></html>