<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body >﻿<title>Drools文档</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><div class="book" title="Drools文档"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a> <a href="http://docs.jboss.org/" class="doc_href"><strong>社区文档</strong></a></p><div><h1 class="title"><a id="d0e1"></a> Drools文档</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="orgname"><a class="link" href="http://www.drools.org/community/team.html">JBoss Drools团队</a></span></h3></div></div></div><div><p class="releaseinfo">版本6.5.0。最后</p></div></div><hr></div><div class="toc"><dl><dt><span class="preface"><a href="#d0e19"></a></span></dt><dt><span class="part"><a href="#d0e23">一，欢迎</a></span></dt><dd><dl><dt><span class="chapter"><a href="#Welcome">1。介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e32">1.1。介绍</a></span></dt><dt><span class="section"><a href="#gettingstarted">1.2。卷入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e56">1.2.1。注册jboss.org</a></span></dt><dt><span class="section"><a href="#d0e67">1.2.2。签署贡献者协议</a></span></dt><dt><span class="section"><a href="#d0e78">1.2.3。通过JIRA提交问题</a></span></dt><dt><span class="section"><a href="#d0e98">1.2.4。叉GitHub</a></span></dt><dt><span class="section"><a href="#d0e109">1.2.5。写作测试</a></span></dt><dt><span class="section"><a href="#d0e122">1.2.6。遵守正确的约定</a></span></dt><dt><span class="section"><a href="#d0e132">1.2.7。提交拉取请求</a></span></dt></dl></dd><dt><span class="section"><a href="#installationAndSetup">1.3。安装和设置（Core和IDE）</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e147">1.3.1。安装和使用</a></span></dt><dt><span class="section"><a href="#d0e322">1.3.2。从源头建造</a></span></dt><dt><span class="section"><a href="#d0e368">1.3.3。日食</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#DroolsReleaseNotesChapter">2。发行说明</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.5.0">2.1。Drools 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e443">2.1.1。可配置的ThreadFactory</a></span></dt><dt><span class="section"><a href="#d0e456">2.1.2。使用任何表达式作为查询的输入</a></span></dt><dt><span class="section"><a href="#d0e467">2.1.3。使用修改后的属性更新</a></span></dt><dt><span class="section"><a href="#d0e476">2.1.4。监控框架改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.5.0.Final">2.2。KIE Workbench 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e567">2.2.1。指导规则编辑器：复合字段约束中的支持公式</a></span></dt><dt><span class="section"><a href="#d0e588">2.2.2。创作-项目编辑器-重新导入按钮</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.4.0">2.3。Drools 6.4.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e596">2.3.1。更好的Java 8兼容性</a></span></dt><dt><span class="section"><a href="#d0e601">2.3.2。更强大的增量编译</a></span></dt><dt><span class="section"><a href="#d0e606">2.3.3。改进的多线程行为</a></span></dt><dt><span class="section"><a href="#d0e615">2.3.4。OOPath改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.4.0.Final">2.4。KIE Workbench 6.4.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e663">2.4.1。新外观</a></span></dt><dt><span class="section"><a href="#d0e678">2.4.2。各种UI改进</a></span></dt><dt><span class="section"><a href="#d0e704">2.4.3。新地区</a></span></dt><dt><span class="section"><a href="#d0e762">2.4.4。创作-导入-一致的术语</a></span></dt><dt><span class="section"><a href="#d0e801">2.4.5。禁用自动构建</a></span></dt><dt><span class="section"><a href="#d0e815">2.4.6。支持<code class="literal">SCP</code>样式<code class="literal">git</code>储存库网址</a></span></dt><dt><span class="section"><a href="#d0e838">2.4.7。创作-重复的GAV检测</a></span></dt><dt><span class="section"><a href="#d0e945">2.4.8。新的执行服务器管理用户界面</a></span></dt><dt><span class="section"><a href="#d0e957">2.4.9。用户和组管理</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.3.0">2.5。Drools 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e973">2.5.1。使用OOPath浏览对象图</a></span></dt><dt><span class="section"><a href="#shared.ReleaseNotes.KieNavigator">2.5.2。Eclipse的Kie Navigator View</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.3.0.Final">2.6。KIE Workbench 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1105">2.6.1。决策表的实时验证和验证</a></span></dt><dt><span class="section"><a href="#d0e1121">2.6.2。改进的DRL编辑器</a></span></dt><dt><span class="section"><a href="#d0e1133">2.6.3。资产锁定</a></span></dt><dt><span class="section"><a href="#d0e1152">2.6.4。数据建模工具Windows</a></span></dt><dt><span class="section"><a href="#d0e1178">2.6.5。启用JPA的数据模型的生成</a></span></dt><dt><span class="section"><a href="#d0e1221">2.6.6。数据集创作</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.2.0">2.7。Drools 6.2.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1236">2.7.1。传播方式</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.2.0.Final">2.8。KIE Workbench 6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1291">2.8.1。以ZIP格式下载存储库或部分存储库</a></span></dt><dt><span class="section"><a href="#d0e1310">2.8.2。项目编辑者权限</a></span></dt><dt><span class="section"><a href="#d0e1354">2.8.3。在“指导决策表向导”中统一验证样式。</a></span></dt><dt><span class="section"><a href="#d0e1370">2.8.4。改进的巫师</a></span></dt><dt><span class="section"><a href="#d0e1384">2.8.5。XLS，指导决策表和指导模板的一致行为</a></span></dt><dt><span class="section"><a href="#d0e1407">2.8.6。改进的元数据选项卡</a></span></dt><dt><span class="section"><a href="#d0e1461">2.8.7。改进的数据对象编辑器</a></span></dt><dt><span class="section"><a href="#d0e1496">2.8.8。执行服务器管理UI</a></span></dt><dt><span class="section"><a href="#d0e1517">2.8.9。社交活动</a></span></dt><dt><span class="section"><a href="#d0e1567">2.8.10。贡献者仪表板</a></span></dt><dt><span class="section"><a href="#d0e1587">2.8.11。包选择器</a></span></dt><dt><span class="section"><a href="#d0e1603">2.8.12。改善视觉一致性</a></span></dt><dt><span class="section"><a href="#d0e1624">2.8.13。指导决策树编辑器</a></span></dt><dt><span class="section"><a href="#d0e1638">2.8.14。创建存储库向导</a></span></dt><dt><span class="section"><a href="#d0e1657">2.8.15。仓库结构屏幕</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.2.0">2.9。集成6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1679">2.9.1。KIE执行服务器</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.1.0">2.10。Drools 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1694">2.10.1。JMX对KieScanner的支持</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.1.0">2.11。KIE Workbench 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1755">2.11.1。Data Modeler-往返和源代码保存</a></span></dt><dt><span class="section"><a href="#d0e1760">2.11.2。Data Modeler-改进的注释</a></span></dt><dt><span class="section"><a href="#d0e1765">2.11.3。表格数据显示的标准化</a></span></dt><dt><span class="section"><a href="#d0e1824">2.11.4。的产生<code class="code">modify(x) {...}</code>块</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesKIE.6.0.0">2.12。KIE API 6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1848">2.12.1。新的KIE名称</a></span></dt><dt><span class="section"><a href="#d0e1859">2.12.2。Maven对齐项目和模块以及Maven部署</a></span></dt><dt><span class="section"><a href="#d0e1866">2.12.3。基于配置和约定的项目</a></span></dt><dt><span class="section"><a href="#d0e1881">2.12.4。KieBase包含</a></span></dt><dt><span class="section"><a href="#d0e1901">2.12.5。KieModules，KieContainer和KIE-CI</a></span></dt><dt><span class="section"><a href="#d0e1920">2.12.6。KieScanner</a></span></dt><dt><span class="section"><a href="#d0e1970">2.12.7。分层ClassLoader</a></span></dt><dt><span class="section"><a href="#d0e1975">2.12.8。旧版API适配器</a></span></dt><dt><span class="section"><a href="#d0e1980">2.12.9。KIE文档</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.0.0">2.13。Drools 6.0.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1988">2.13.1。PHREAK-惰性规则匹配算法</a></span></dt><dt><span class="section"><a href="#d0e1997">2.13.2。在被动模式下自动触发定时规则</a></span></dt><dt><span class="section"><a href="#d0e2023">2.13.3。表达计时器</a></span></dt><dt><span class="section"><a href="#d0e2058">2.13.4。RuleFlowGroups和AgendaGroups合并</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.0.0">2.14。KIE Workbench 6.0.0中的新功能和值得注意的功能</a></span></dt><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.0.0">2.15。集成6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2161">2.15.1。CDI</a></span></dt><dt><span class="section"><a href="#d0e2176">2.15.2。弹簧</a></span></dt><dt><span class="section"><a href="#d0e2181">2.15.3。白羊座的蓝图</a></span></dt><dt><span class="section"><a href="#d0e2186">2.15.4。准备好OSGi</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#compatibilityMatrix">3。相容性矩阵</a></span></dt></dl></dd><dt><span class="part"><a href="#d0e2196">二。 IE</a></span></dt><dd><dl><dt><span class="chapter"><a href="#KIEChapter">4。IE</a></span></dt><dd><dl><dt><span class="section"><a href="#KIEOverviewSection">4.1。总览</a></span></dt><dd><dl><dt><span class="section"><a href="#KIEAnatomySection">4.1.1。项目剖析</a></span></dt><dt><span class="section"><a href="#KIELifeCyclesSection">4.1.2。生命周期</a></span></dt></dl></dd><dt><span class="section"><a href="#BuildDeployUtilizeAndRunSection">4.2。构建，部署，利用和运行</a></span></dt><dd><dl><dt><span class="section"><a href="#KIEModuleIntroductionBuildingIntroductionSection">4.2.1。介绍</a></span></dt><dt><span class="section"><a href="#KIEBuildingSection">4.2.2。建造</a></span></dt><dt><span class="section"><a href="#KIEDeployingSection">4.2.3。部署中</a></span></dt><dt><span class="section"><a href="#KIERunningSection">4.2.4。跑步</a></span></dt><dt><span class="section"><a href="#KIEDeployCheatSheets">4.2.5。安装和部署备忘单</a></span></dt><dt><span class="section"><a href="#KIEExamplesSection">4.2.6。构建，部署和利用示例</a></span></dt></dl></dd><dt><span class="section"><a href="#KIESecuritySection">4.3。安全</a></span></dt><dd><dl><dt><span class="section"><a href="#SecurityManager">4.3.1。安全经理</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e4235">三， Drools运行时和语言</a></span></dt><dd><dl><dt><span class="chapter"><a href="#HybridReasoningChapter">5，混合推理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4244">5.1。人工智能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4247">5.1.1。一点历史</a></span></dt><dt><span class="section"><a href="#d0e4333">5.1.2。知识表示与推理</a></span></dt><dt><span class="section"><a href="#d0e4344">5.1.3。规则引擎和生产规则系统（PRS）</a></span></dt><dt><span class="section"><a href="#d0e4429">5.1.4。混合推理系统（HRS）</a></span></dt><dt><span class="section"><a href="#d0e4462">5.1.5。专家系统</a></span></dt><dt><span class="section"><a href="#d0e4486">5.1.6。推荐读物</a></span></dt></dl></dd><dt><span class="section"><a href="#ReteOO">5.2。Rete算法</a></span></dt><dt><span class="section"><a href="#ReteOOSection">5.3。ReteOO算法</a></span></dt><dt><span class="section"><a href="#PHREAK">5.4。PHREAK算法</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e4870">6。用户指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4873">6.1。基础</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4876">6.1.1。无状态知识会议</a></span></dt><dt><span class="section"><a href="#d0e5038">6.1.2。有状态知识会议</a></span></dt><dt><span class="section"><a href="#d0e5213">6.1.3。方法与规则</a></span></dt><dt><span class="section"><a href="#d0e5245">6.1.4。交叉产品</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5270">6.2。执行控制</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5273">6.2.1。议程</a></span></dt><dt><span class="section"><a href="#d0e5306">6.2.2。规则匹配和冲突集。</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5518">6.3。推理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5521">6.3.1。公交通行证示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5589">6.4。逻辑对象的真理维护</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5596">6.4.1。总览</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5713">6.5。电子表格中的决策表</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5725">6.5.1。何时使用决策表</a></span></dt><dt><span class="section"><a href="#d0e5743">6.5.2。总览</a></span></dt><dt><span class="section"><a href="#d0e5785">6.5.3。决策表如何工作</a></span></dt><dt><span class="section"><a href="#d0e5871">6.5.4。电子表格语法</a></span></dt><dt><span class="section"><a href="#d0e6396">6.5.5。创建和集成基于电子表格的决策表</a></span></dt><dt><span class="section"><a href="#d0e6417">6.5.6。在决策表中管理业务规则</a></span></dt><dt><span class="section"><a href="#d0e6464">6.5.7。规则模板</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6567">6.6。记录中</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e6607">7。跑步</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6612">7.1。KieRuntime</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6615">7.1.1。入口点</a></span></dt><dt><span class="section"><a href="#d0e6790">7.1.2。规则运行时</a></span></dt><dt><span class="section"><a href="#d0e6849">7.1.3。StatefulRuleSession</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6889">7.2。议程</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6926">7.2.1。解决冲突</a></span></dt><dt><span class="section"><a href="#d0e6942">7.2.2。议程集团</a></span></dt><dt><span class="section"><a href="#d0e6974">7.2.3。激活组</a></span></dt><dt><span class="section"><a href="#d0e6990">7.2.4。RuleFlowGroup</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7006">7.3。事件模型</a></span></dt><dt><span class="section"><a href="#d0e7084">7.4。StatelessKieSession</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7214">7.4.1。顺序模式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7279">7.5。规则执行模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7286">7.5.1。被动模式</a></span></dt><dt><span class="section"><a href="#d0e7301">7.5.2。主动模式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7377">7.6。传播方式</a></span></dt><dt><span class="section"><a href="#d0e7429">7.7。命令和CommandExecutor</a></span></dt></dl></dd><dt><span class="chapter"><a href="#DroolsLanguageReferenceChapter">8。规则语言参考</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7602">8.1。总览</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7610">8.1.1。规则文件</a></span></dt><dt><span class="section"><a href="#d0e7643">8.1.2。什么是规则</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7679">8.2。关键词</a></span></dt><dt><span class="section"><a href="#d0e7874">8.3。评论</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7879">8.3.1。单行注释</a></span></dt><dt><span class="section"><a href="#d0e7889">8.3.2。多行评论</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7902">8.4。错误讯息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7907">8.4.1。讯息格式</a></span></dt><dt><span class="section"><a href="#d0e7938">8.4.2。错误信息说明</a></span></dt><dt><span class="section"><a href="#d0e8093">8.4.3。其他讯息</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8098">8.5。包</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8121">8.5.1。进口</a></span></dt><dt><span class="section"><a href="#d0e8135">8.5.2。全球</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8178">8.6。功能</a></span></dt><dt><span class="section"><a href="#d0e8212">8.7。类型声明</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8240">8.7.1。声明新类型</a></span></dt><dt><span class="section"><a href="#d0e8397">8.7.2。声明元数据</a></span></dt><dt><span class="section"><a href="#d0e8758">8.7.3。声明现有类型的元数据</a></span></dt><dt><span class="section"><a href="#d0e8801">8.7.4。声明类型的参数化构造函数</a></span></dt><dt><span class="section"><a href="#d0e8825">8.7.5。非类型安全类</a></span></dt><dt><span class="section"><a href="#d0e8830">8.7.6。从应用程序代码访问声明的类型</a></span></dt><dt><span class="section"><a href="#d0e8879">8.7.7。类型声明“扩展”</a></span></dt><dt><span class="section"><a href="#d0e8911">8.7.8。特质</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9154">8.8。规则</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9196">8.8.1。规则属性</a></span></dt><dt><span class="section"><a href="#d0e9356">8.8.2。计时器和日历</a></span></dt><dt><span class="section"><a href="#d0e9456">8.8.3。左侧语法（当）</a></span></dt><dt><span class="section"><a href="#d0e11687">8.8.4。右侧（然后）</a></span></dt><dt><span class="section"><a href="#d0e11934">8.8.5。有条件的命名后果</a></span></dt><dt><span class="section"><a href="#d0e11959">8.8.6。关于自动装箱和原始类型的注释</a></span></dt></dl></dd><dt><span class="section"><a href="#QuerySection">8.9。询问</a></span></dt><dt><span class="section"><a href="#d0e12041">8.10。领域特定语言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12051">8.10.1。何时使用DSL</a></span></dt><dt><span class="section"><a href="#d0e12058">8.10.2。DSL基础</a></span></dt><dt><span class="section"><a href="#d0e12127">8.10.3。向事实添加约束</a></span></dt><dt><span class="section"><a href="#d0e12171">8.10.4。开发DSL</a></span></dt><dt><span class="section"><a href="#d0e12184">8.10.5。DSL和DSLR参考</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#DroolsComplexEventProcessingChapter">9。复杂事件处理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12392">9.1。复杂事件处理</a></span></dt><dt><span class="section"><a href="#d0e12443">9.2。流口水融合</a></span></dt><dt><span class="section"><a href="#d0e12545">9.3。事件语义</a></span></dt><dt><span class="section"><a href="#d0e12597">9.4。事件处理模式</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12604">9.4.1。云模式</a></span></dt><dt><span class="section"><a href="#d0e12635">9.4.2。流模式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12715">9.5。会话时钟</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12746">9.5.1。可用时钟实现</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12773">9.6。滑动窗</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12786">9.6.1。滑动时间窗</a></span></dt><dt><span class="section"><a href="#d0e12809">9.6.2。滑动长度窗</a></span></dt><dt><span class="section"><a href="#d0e12845">9.6.3。窗口声明</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12866">9.7。流支持</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12888">9.7.1。声明和使用入口点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12922">9.8。事件的内存管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12940">9.8.1。显式过期偏移</a></span></dt><dt><span class="section"><a href="#d0e12958">9.8.2。推断的过期时间偏移</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12978">9.9。时间推理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13050">9.9.1。时间运算符</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ExperimentalFeaturesChapter">10。实验特征</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13520">10.1。声明性议程</a></span></dt><dt><span class="section"><a href="#d0e13581">10.2。使用OOPath浏览对象图</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13688">10.2.1。反应式和非反应式OOPath</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e13738">IV。流口水整合</a></span></dt><dd><dl><dt><span class="chapter"><a href="#ch.commands">11。流口水的命令</a></span></dt><dd><dl><dt><span class="section"><a href="#CommandsAPISection">11.1。API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13764">11.1.1。XStream的</a></span></dt><dt><span class="section"><a href="#d0e13780">11.1.2。JSON格式</a></span></dt><dt><span class="section"><a href="#d0e13796">11.1.3。杰克斯</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13824">11.2。支持的命令</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13904">11.2.1。BatchExecutionCommand</a></span></dt><dt><span class="section"><a href="#d0e13972">11.2.2。InsertObjectCommand</a></span></dt><dt><span class="section"><a href="#d0e14054">11.2.3。缩回命令</a></span></dt><dt><span class="section"><a href="#d0e14121">11.2.4。修改命令</a></span></dt><dt><span class="section"><a href="#d0e14188">11.2.5。GetObjectCommand</a></span></dt><dt><span class="section"><a href="#d0e14256">11.2.6。InsertElementsCommand</a></span></dt><dt><span class="section"><a href="#d0e14334">11.2.7。FireAllRulesCommand</a></span></dt><dt><span class="section"><a href="#d0e14409">11.2.8。StartProcessCommand</a></span></dt><dt><span class="section"><a href="#d0e14479">11.2.9。SignalEventCommand</a></span></dt><dt><span class="section"><a href="#d0e14548">11.2.10。CompleteWorkItemCommand</a></span></dt><dt><span class="section"><a href="#d0e14615">11.2.11。AbortWorkItemCommand</a></span></dt><dt><span class="section"><a href="#d0e14676">11.2.12。QueryCommand</a></span></dt><dt><span class="section"><a href="#d0e14748">11.2.13。SetGlobalCommand</a></span></dt><dt><span class="section"><a href="#d0e14826">11.2.14。GetGlobalCommand</a></span></dt><dt><span class="section"><a href="#d0e14894">11.2.15。GetObjectsCommand</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CDIChapter">12CDI</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14965">12.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e14972">12.2。注解</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14977">12.2.1。@KReleaseId</a></span></dt><dt><span class="section"><a href="#d0e14982">12.2.2。@KContainer</a></span></dt><dt><span class="section"><a href="#d0e15002">12.2.3。@KBase</a></span></dt><dt><span class="section"><a href="#d0e15029">12.2.4。KieSession的@KSession</a></span></dt><dt><span class="section"><a href="#d0e15056">12.2.5。@KSession用于StatelessKieSession</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15083">12.3。API示例比较</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch.kie.spring">13与Spring整合</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15103">13.1。Drools 6.0的重要更改</a></span></dt><dt><span class="section"><a href="#d0e15157">13.2。与Drools Expert集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15165">13.2.1。KieModule</a></span></dt><dt><span class="section"><a href="#d0e15212">13.2.2。凯基</a></span></dt><dt><span class="section"><a href="#d0e15312">13.2.3。重要的提示</a></span></dt><dt><span class="section"><a href="#d0e15337">13.2.4。KieSessions</a></span></dt><dt><span class="section"><a href="#d0e15425">13.2.5。凯：ReleaseId</a></span></dt><dt><span class="section"><a href="#d0e15482">13.2.6。凯：进口</a></span></dt><dt><span class="section"><a href="#d0e15565">13.2.7。注解</a></span></dt><dt><span class="section"><a href="#d0e15688">13.2.8。事件监听器</a></span></dt><dt><span class="section"><a href="#d0e15844">13.2.9。记录仪</a></span></dt><dt><span class="section"><a href="#d0e15933">13.2.10。定义批处理命令</a></span></dt><dt><span class="section"><a href="#d0e16013">13.2.11。坚持不懈</a></span></dt><dt><span class="section"><a href="#d0e16043">13.2.12。利用其他Spring功能</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16083">13.3。与jBPM人工任务集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16088">13.3.1。如何使用jBPM人工任务配置Spring</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ch.kie.android">14。Android整合</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16206">14.1。与Drools Expert集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16214">14.1.1。预序列化规则</a></span></dt><dt><span class="section"><a href="#d0e16242">14.1.2。具有drools-compiler依赖性的KieContainer API</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16257">14.2。与Roboguice集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16260">14.2.1。Roboguice的预序列化规则</a></span></dt><dt><span class="section"><a href="#d0e16290">14.2.2。具有流口水编译器依赖性和Roboguice的KieContainer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ch.camel">15Apache Camel集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16370">15.1。骆驼</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch.server">16。Drools骆驼服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16423">16.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e16428">16.2。部署方式</a></span></dt><dt><span class="section"><a href="#d0e16433">16.3。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16473">16.3.1。REST /骆驼服务配置</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#RHQChapter">17。带有RHQ / JON的JMX监视</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16550">17.1。介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16555">17.1.1。在Drools应用程序中启用JMX监视</a></span></dt><dt><span class="section"><a href="#d0e16574">17.1.2。安装并运行RHQ / JON插件</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e16616">V.Drools工作台</a></span></dt><dd><dl><dt><span class="chapter"><a href="#wb.Workbench">18岁工作台（常规）</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.Installation">18.1。安装</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.warInstallation">18.1.1。战争安装</a></span></dt><dt><span class="section"><a href="#wb.workbenchData">18.1.2。工作台数据</a></span></dt><dt><span class="section"><a href="#wb.systemProperties">18.1.3。系统属性</a></span></dt><dt><span class="section"><a href="#wb.troubleShooting">18.1.4。故障排除</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.QuickStart">18.2。快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.QuickStartAddRepository">18.2.1。添加资料库</a></span></dt><dt><span class="section"><a href="#wb.QuickStartAddProject">18.2.2。添加项目</a></span></dt><dt><span class="section"><a href="#wb.QuickStartDefineDataModel">18.2.3。定义数据模型</a></span></dt><dt><span class="section"><a href="#wb.QuickStartDefineRule">18.2.4。定义规则</a></span></dt><dt><span class="section"><a href="#wb.QuickStartBuildAndDeloy">18.2.5。构建和部署</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.Administration">18.3。管理</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.administrationOverview">18.3.1。管理概述</a></span></dt><dt><span class="section"><a href="#wb.OrganizationalUnit">18.3.2。组织单元</a></span></dt><dt><span class="section"><a href="#wb.VFSRepository">18.3.3。储存库</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.Configuration">18.4。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.UserManagement">18.4.1。基本用户管理</a></span></dt><dt><span class="section"><a href="#wb.Roles">18.4.2。的角色</a></span></dt><dt><span class="section"><a href="#wb.RestrictedAccess">18.4.3。限制对存储库的访问</a></span></dt><dt><span class="section"><a href="#wb.CommandLineConfig">18.4.4。命令行配置工具</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.Introduction">18.5。介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.LogInAndLogOut">18.5.1。登录并注销</a></span></dt><dt><span class="section"><a href="#wb.HomeScreen">18.5.2。主屏幕</a></span></dt><dt><span class="section"><a href="#wb.WorkbenchConcepts">18.5.3。工作台概念</a></span></dt><dt><span class="section"><a href="#wb.InitialLayout">18.5.4。初始布局</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ChangingLayout">18.6。改变布局</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.Resizing">18.6.1。调整大小</a></span></dt><dt><span class="section"><a href="#wb.Repositioning">18.6.2。重新定位</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.Authoring">18.7。创作（一般）</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.ArtifactRepository">18.7.1。工件存储库</a></span></dt><dt><span class="section"><a href="#wb.AssetEditor">18.7.2。资产编辑器</a></span></dt><dt><span class="section"><a href="#wb.TagsEditor">18.7.3。标签编辑器</a></span></dt><dt><span class="section"><a href="#wb.ProjectExplorer">18.7.4。项目浏览器</a></span></dt><dt><span class="section"><a href="#wb.ProjectEditor">18.7.5。项目编辑</a></span></dt><dt><span class="section"><a href="#wb.Validation">18.7.6。验证方式</a></span></dt><dt><span class="section"><a href="#wb.DataModeller">18.7.7。数据建模师</a></span></dt><dt><span class="section"><a href="#wb.DataSets">18.7.8。数据集</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.UserAndGroupMgmt">18.8。用户和组管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e19602">18.8.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e19623">18.8.2。安全管理提供商</a></span></dt><dt><span class="section"><a href="#d0e19730">18.8.3。安装与设定</a></span></dt><dt><span class="section"><a href="#d0e19860">18.8.4。用法</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.Embedding">18.9。在您的应用程序中嵌入工作台</a></span></dt><dt><span class="section"><a href="#wb.AssetManagement">18.10。资产管理</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.assetMgmtOverview">18.10.1。资产管理概述</a></span></dt><dt><span class="section"><a href="#wb.assetMgmtManagedVsUnmanaged">18.10.2。托管与非托管存储库</a></span></dt><dt><span class="section"><a href="#wb.assetMgmtProcesses">18.10.3。资产管理流程</a></span></dt><dt><span class="section"><a href="#wb.assetMgmtUsageFlow">18.10.4。使用流程</a></span></dt><dt><span class="section"><a href="#wb.assetMgmtRepositoryStructure">18.10.5。储存库结构</a></span></dt><dt><span class="section"><a href="#wb.assetMgmtManagedRepositoryOperations">18.10.6。托管存储库操作</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ExecServerUI">18.11。执行服务器管理UI</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.ExecServerUITemplate">18.11.1。服务器模板</a></span></dt><dt><span class="section"><a href="#wb.ExecServerUIContainer">18.11.2。容器</a></span></dt><dt><span class="section"><a href="#wb.ExecServerUIRemoteServer">18.11.3。远端伺服器</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#drools.AuthoringAssets">19创作规则资产</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.NewPackage">19.1。创建一个包</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e20580">19.1.1。空包装</a></span></dt><dt><span class="section"><a href="#d0e20599">19.1.2。复制，重命名和删除软件包</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.GuidedRuleEditor">19.2。指导编辑的业务规则</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.GuidedRuleEditorParts">19.2.1。指导规则编辑器的部分</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorLHS">19.2.2。规则的“何时”（左侧）</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorRHS">19.2.3。规则的“ THEN”（右侧）</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorOptionalAttributes">19.2.4。可选属性</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorToolbar">19.2.5。模式/动作工具栏</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorEnumerations">19.2.6。用户驱动的下拉列表</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorDSL">19.2.7。DSL句子增强</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleEditorComplexExample">19.2.8。一个更复杂的示例：</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.GuidedRuleTemplateEditor">19.3。资产/规则模板</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.GuidedRuleTemplateEditorCreating">19.3.1。创建规则模板</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefining">19.3.2。定义模板</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefiningData">19.3.3。定义模板数据</a></span></dt><dt><span class="section"><a href="#drools.GuidedRuleTemplateEditorGeneratedDRL">19.3.4。生成的DRL</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.GuidedDecisionTableEditor">19.4。指导决策表（基于Web）</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorTypesOfDecisionTable">19.4.1。决策表类型</a></span></dt><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorConcepts">19.4.2。主要组成部分\概念</a></span></dt><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorDefining">19.4.3。定义基于Web的决策表</a></span></dt><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorRuleDefinitions">19.4.4。规则定义</a></span></dt><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorAuditLog">19.4.5。审核日志</a></span></dt><dt><span class="section"><a href="#drools.GuidedDecisionTableEditorVerification">19.4.6。实时验证与确认</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.GuidedDecisionTreeEditor">19.5。指导决策树</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e21644">19.5.1。初始编辑器布局</a></span></dt><dt><span class="section"><a href="#d0e21692">19.5.2。第一步</a></span></dt><dt><span class="section"><a href="#d0e21730">19.5.3。编辑数据对象节点</a></span></dt><dt><span class="section"><a href="#d0e21743">19.5.4。编辑字段约束节点</a></span></dt><dt><span class="section"><a href="#d0e21756">19.5.5。编辑动作节点</a></span></dt><dt><span class="section"><a href="#d0e21789">19.5.6。管理树</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.XLSDecisionTable">19.6。电子表格决策表</a></span></dt><dt><span class="section"><a href="#drools.GuidedScoreCardEditor">19.7。计分卡</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.GuidedScoreCardEditorSetupParameters">19.7.1。 （a）设定参数</a></span></dt><dt><span class="section"><a href="#drools.GuidedScoreCardEditorCharacteristics">19.7.2。 （b）特征</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.TestScenarioEditor">19.8。测试场景</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.KSessionSelector">19.8.1。知识会议选择器</a></span></dt><dt><span class="section"><a href="#drools.TestScenarioEditorGivenSection">19.8.2。给定部分</a></span></dt><dt><span class="section"><a href="#drools.TestScenarioEditorExpectedSection">19.8.3。期望部分</a></span></dt><dt><span class="section"><a href="#drools.TestScenarioEditorGlobalSection">19.8.4。全球部分</a></span></dt><dt><span class="section"><a href="#drools.TestScenarioEditorInpuotSection">19.8.5。新输入部分</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.FunctionEditor">19.9。功能</a></span></dt><dt><span class="section"><a href="#drools.DSLEditor">19.10。DSL编辑器</a></span></dt><dt><span class="section"><a href="#drools.EnumerationEditor">19.11。数据枚举（下拉列表配置）</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.AdvancedEnumConcepts">19.11.1。高级枚举概念</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.DRLEditor">19.12。技术规则（DRL）</a></span></dt></dl></dd><dt><span class="chapter"><a href="#wb.WorkbenchIntegration">20工作台整合</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.WorkbenchRemoteAPI">20.1。休息</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e22427">20.1.1。求职电话</a></span></dt><dt><span class="section"><a href="#d0e22531">20.1.2。储存库调用</a></span></dt><dt><span class="section"><a href="#d0e22706">20.1.3。组织单位电话</a></span></dt><dt><span class="section"><a href="#d0e22837">20.1.4。Maven电话</a></span></dt><dt><span class="section"><a href="#d0e22953">20.1.5。REST摘要</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.KeycloakSSOIntegration">20.2。Keycloak SSO集成</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e23153">20.2.1。情境</a></span></dt><dt><span class="section"><a href="#d0e23178">20.2.2。安装和设置Keycloak服务器</a></span></dt><dt><span class="section"><a href="#d0e23222">20.2.3。创建并设置演示领域</a></span></dt><dt><span class="section"><a href="#d0e23351">20.2.4。安装和设置jBPM Workbench</a></span></dt><dt><span class="section"><a href="#d0e23519">20.2.5。通过Keycloak保护工作台远程服务</a></span></dt><dt><span class="section"><a href="#d0e23565">20.2.6。通过Keycloak保护工作台的文件系统服务</a></span></dt><dt><span class="section"><a href="#d0e23668">20.2.7。执行服务器</a></span></dt><dt><span class="section"><a href="#d0e23850">20.2.8。消费远程服务</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#wb.WorkbenchHighAvailability">21工作台高可用性</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.HighAvailability">21.1。</a></span></dt><dd><dl><dt><span class="section"><a href="#wb.vfsClustering">21.1.1。VFS群集</a></span></dt><dt><span class="section"><a href="#d0e24193">21.1.2。 jBPM集群</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e24201">VI。 KIE服务器</a></span></dt><dd><dl><dt><span class="chapter"><a href="#ch.kie.server">22KIE执行服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e24210">22.1总览</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e24254">22.1.1。词汇表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e24323">22.2。安装KIE服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e24374">22.2.1。自举开关</a></span></dt><dt><span class="section"><a href="#d0e24677">22.2.2。不同容器的安装详细信息</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e24798">22.3。Kie服务器设置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e24807">22.3.1。托管Kie服务器</a></span></dt><dt><span class="section"><a href="#d0e24889">22.3.2。非托管KIE执行服务器</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e24914">22.4。创建一个Kie容器</a></span></dt><dt><span class="section"><a href="#d0e24991">22.5。管理容器</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e24996">22.5.1。启动容器</a></span></dt><dt><span class="section"><a href="#d0e25005">22.5.2。停止和删除容器</a></span></dt><dt><span class="section"><a href="#d0e25010">22.5.3。更新容器</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e25070">22.6。Kie Server REST API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e25090">22.6.1。[获取] /</a></span></dt><dt><span class="section"><a href="#d0e25100">22.6.2。[POST] /</a></span></dt><dt><span class="section"><a href="#d0e25140">22.6.3。[GET] /容器</a></span></dt><dt><span class="section"><a href="#d0e25171">22.6.4。 ⁠[GET] /容器/ {id}</a></span></dt><dt><span class="section"><a href="#d0e25184">22.6.5。[PUT] /容器/ {id}</a></span></dt><dt><span class="section"><a href="#d0e25207">22.6.6。[删除] / containers / {id}</a></span></dt><dt><span class="section"><a href="#d0e25220">22.6.7。[POST] /容器/实例/ {id}</a></span></dt><dt><span class="section"><a href="#d0e25288">22.6.8。[GET] /容器/ {id} /版本ID</a></span></dt><dt><span class="section"><a href="#d0e25298">22.6.9。[POST] / containers / {id} / release-id</a></span></dt><dt><span class="section"><a href="#d0e25315">22.6.10。[GET] /容器/ {id} /扫描仪</a></span></dt><dt><span class="section"><a href="#d0e25325">22.6.11。[POST] /容器/ {id} /扫描仪</a></span></dt><dt><span class="section"><a href="#d0e25350">22.6.12。执行服务器的本机REST客户端</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e25373">22.7。OptaPlanner REST API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e25410">22.7.1。[GET] / containers / {containerId} / solvers</a></span></dt><dt><span class="section"><a href="#d0e25425">22.7.2。[PUT] / containers / {containerId} / solvers / {solverId}</a></span></dt><dt><span class="section"><a href="#d0e25458">22.7.3。[GET] / containers / {containerId} / solvers / {solverId}</a></span></dt><dt><span class="section"><a href="#d0e25479">22.7.4。[POST] / containers / {containerId} / solvers / {solverId}</a></span></dt><dt><span class="section"><a href="#d0e25530">22.7.5。[GET] / containers / {containerId} / solvers / {solverId} / bestsolution</a></span></dt><dt><span class="section"><a href="#d0e25548">22.7.6。[删除] / containers / {containerId} / solvers / {solverId}</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e25569">22.8。控制器REST API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e25587">22.8.1。[GET] /管理/服务器</a></span></dt><dt><span class="section"><a href="#d0e25597">22.8.2。[GET] / management / server / {id}</a></span></dt><dt><span class="section"><a href="#d0e25607">22.8.3。[PUT] / management / server / {id}</a></span></dt><dt><span class="section"><a href="#d0e25617">22.8.4。[删除] / management / server / {id}</a></span></dt><dt><span class="section"><a href="#d0e25622">22.8.5。[GET] /管理/服务器/ {id} /容器</a></span></dt><dt><span class="section"><a href="#d0e25632">22.8.6。[GET] / management / server / {id} / containers / {containerId}</a></span></dt><dt><span class="section"><a href="#d0e25642">22.8.7。[PUT] / management / server / {id} / containers / {containerId}</a></span></dt><dt><span class="section"><a href="#d0e25652">22.8.8。[删除] / management / server / {id} / containers / {containerId}</a></span></dt><dt><span class="section"><a href="#d0e25657">22.8.9。[POST] / management / server / {id} / containers / {containerId} / status / started</a></span></dt><dt><span class="section"><a href="#d0e25662">22.8.10。[POST] / management / server / {id} / containers / {containerId} / status / stopped</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e25667">22.9。Kie Server Java客户端API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e25672">22.9.1。Maven配置</a></span></dt><dt><span class="section"><a href="#d0e25690">22.9.2。客户端配置</a></span></dt><dt><span class="section"><a href="#d0e25753">22.9.3。服务器响应</a></span></dt><dt><span class="section"><a href="#d0e25777">22.9.4。服务器功能</a></span></dt><dt><span class="section"><a href="#d0e25798">22.9.5。基氏容器</a></span></dt><dt><span class="section"><a href="#d0e25826">22.9.6。管理容器</a></span></dt><dt><span class="section"><a href="#d0e25837">22.9.7。决策服务器的可用客户端</a></span></dt><dt><span class="section"><a href="#d0e25870">22.9.8。将命令发送到服务器</a></span></dt><dt><span class="section"><a href="#d0e25897">22.9.9。列出可用的业务流程</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e25909">七。流口水的例子</a></span></dt><dd><dl><dt><span class="chapter"><a href="#d0e25915">23。例子</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e25918">23.1。得到例子</a></span></dt><dt><span class="section"><a href="#d0e25925">23.2。你好，世界</a></span></dt><dt><span class="section"><a href="#d0e26213">23.3。状态示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e26218">23.3.1。了解状态示例</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e26472">23.4。斐波那契示例</a></span></dt><dt><span class="section"><a href="#d0e26678">23.5。银行教程</a></span></dt><dt><span class="section"><a href="#d0e27005">23.6。定价规则决策表示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e27029">23.6.1。执行示例</a></span></dt><dt><span class="section"><a href="#d0e27071">23.6.2。决策表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e27136">23.7。宠物店的例子</a></span></dt><dt><span class="section"><a href="#d0e27716">23.8。诚实的政客例子</a></span></dt><dt><span class="section"><a href="#d0e27845">23.9。数独示例</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e27866">23.9.1。数独概述</a></span></dt><dt><span class="section"><a href="#d0e27880">23.9.2。运行示例</a></span></dt><dt><span class="section"><a href="#d0e27953">23.9.3。Java源代码和规则概述</a></span></dt><dt><span class="section"><a href="#d0e28083">23.9.4。数独验证器规则（validate.drl）</a></span></dt><dt><span class="section"><a href="#d0e28092">23.9.5。数独求解规则（sudoku.drl）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e28128">23.10。猜数字</a></span></dt><dt><span class="section"><a href="#d0e28419">23.11。康威的人生游戏</a></span></dt><dt><span class="section"><a href="#d0e28568">23.12。侵略者</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e28601">23.12.1。侵略者1</a></span></dt><dt><span class="section"><a href="#d0e28613">23.12.2。侵略者2</a></span></dt><dt><span class="section"><a href="#d0e28623">23.12.3。侵略者3</a></span></dt><dt><span class="section"><a href="#d0e28633">23.12.4。侵略者4</a></span></dt><dt><span class="section"><a href="#d0e28643">23.12.5。侵略者5</a></span></dt><dt><span class="section"><a href="#d0e28648">23.12.6。侵略者6</a></span></dt><dt><span class="section"><a href="#d0e28653">23.12.7。侵略者4</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e28663">23.13。流口水的冒险</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e28691">23.13.1。使用游戏。</a></span></dt><dt><span class="section"><a href="#d0e28725">23.13.2。代码</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e28763">23.14。傍</a></span></dt><dt><span class="section"><a href="#d0e28781">23.15。乌鸦世界</a></span></dt><dt><span class="section"><a href="#d0e28828">23.16。礼貌小姐和标杆管理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e28850">23.16.1。介绍</a></span></dt><dt><span class="section"><a href="#d0e28936">23.16.2。深入讨论</a></span></dt><dt><span class="section"><a href="#d0e29146">23.16.3。输出汇总</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e29201">23.17。后向链</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e29215">23.17.1。后向链系统</a></span></dt><dt><span class="section"><a href="#d0e29220">23.17.2。克隆传递性闭包</a></span></dt><dt><span class="section"><a href="#d0e29250">23.17.3。定义查询</a></span></dt><dt><span class="section"><a href="#d0e29275">23.17.4。传递闭包示例</a></span></dt><dt><span class="section"><a href="#d0e29347">23.17.5。反应式传递查询</a></span></dt><dt><span class="section"><a href="#d0e29372">23.17.6。具有未绑定参数的查询</a></span></dt><dt><span class="section"><a href="#d0e29391">23.17.7。多个未绑定参数</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div><div class="preface"><div class="titlepage"></div><div class="mediaobject"><img src="images/droolsExpertLogo.png"></div></div><div class="part" title="第一部分欢迎"><div class="titlepage"><div><div><h1 class="title"><a id="d0e23"></a>第一部分欢迎</h1></div></div></div><div class="partintro" title="欢迎"><div></div><p>欢迎和发行说明</p><div class="toc"><p><strong>目录</strong></p><dl><dt><span class="chapter"><a href="#Welcome">1。介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e32">1.1。介绍</a></span></dt><dt><span class="section"><a href="#gettingstarted">1.2。卷入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e56">1.2.1。注册jboss.org</a></span></dt><dt><span class="section"><a href="#d0e67">1.2.2。签署贡献者协议</a></span></dt><dt><span class="section"><a href="#d0e78">1.2.3。通过JIRA提交问题</a></span></dt><dt><span class="section"><a href="#d0e98">1.2.4。叉GitHub</a></span></dt><dt><span class="section"><a href="#d0e109">1.2.5。写作测试</a></span></dt><dt><span class="section"><a href="#d0e122">1.2.6。遵守正确的约定</a></span></dt><dt><span class="section"><a href="#d0e132">1.2.7。提交拉取请求</a></span></dt></dl></dd><dt><span class="section"><a href="#installationAndSetup">1.3。安装和设置（Core和IDE）</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e147">1.3.1。安装和使用</a></span></dt><dt><span class="section"><a href="#d0e322">1.3.2。从源头建造</a></span></dt><dt><span class="section"><a href="#d0e368">1.3.3。日食</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#DroolsReleaseNotesChapter">2。发行说明</a></span></dt><dd><dl><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.5.0">2.1。Drools 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e443">2.1.1。可配置的ThreadFactory</a></span></dt><dt><span class="section"><a href="#d0e456">2.1.2。使用任何表达式作为查询的输入</a></span></dt><dt><span class="section"><a href="#d0e467">2.1.3。使用修改后的属性更新</a></span></dt><dt><span class="section"><a href="#d0e476">2.1.4。监控框架改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.5.0.Final">2.2。KIE Workbench 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e567">2.2.1。指导规则编辑器：复合字段约束中的支持公式</a></span></dt><dt><span class="section"><a href="#d0e588">2.2.2。创作-项目编辑器-重新导入按钮</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.4.0">2.3。Drools 6.4.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e596">2.3.1。更好的Java 8兼容性</a></span></dt><dt><span class="section"><a href="#d0e601">2.3.2。更强大的增量编译</a></span></dt><dt><span class="section"><a href="#d0e606">2.3.3。改进的多线程行为</a></span></dt><dt><span class="section"><a href="#d0e615">2.3.4。OOPath改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.4.0.Final">2.4。KIE Workbench 6.4.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e663">2.4.1。新外观</a></span></dt><dt><span class="section"><a href="#d0e678">2.4.2。各种UI改进</a></span></dt><dt><span class="section"><a href="#d0e704">2.4.3。新地区</a></span></dt><dt><span class="section"><a href="#d0e762">2.4.4。创作-导入-一致的术语</a></span></dt><dt><span class="section"><a href="#d0e801">2.4.5。禁用自动构建</a></span></dt><dt><span class="section"><a href="#d0e815">2.4.6。支持<code class="literal">SCP</code>样式<code class="literal">git</code>储存库网址</a></span></dt><dt><span class="section"><a href="#d0e838">2.4.7。创作-重复的GAV检测</a></span></dt><dt><span class="section"><a href="#d0e945">2.4.8。新的执行服务器管理用户界面</a></span></dt><dt><span class="section"><a href="#d0e957">2.4.9。用户和组管理</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.3.0">2.5。Drools 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e973">2.5.1。使用OOPath浏览对象图</a></span></dt><dt><span class="section"><a href="#shared.ReleaseNotes.KieNavigator">2.5.2。Eclipse的Kie Navigator View</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.3.0.Final">2.6。KIE Workbench 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1105">2.6.1。决策表的实时验证和验证</a></span></dt><dt><span class="section"><a href="#d0e1121">2.6.2。改进的DRL编辑器</a></span></dt><dt><span class="section"><a href="#d0e1133">2.6.3。资产锁定</a></span></dt><dt><span class="section"><a href="#d0e1152">2.6.4。数据建模工具Windows</a></span></dt><dt><span class="section"><a href="#d0e1178">2.6.5。启用JPA的数据模型的生成</a></span></dt><dt><span class="section"><a href="#d0e1221">2.6.6。数据集创作</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.2.0">2.7。Drools 6.2.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1236">2.7.1。传播方式</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.2.0.Final">2.8。KIE Workbench 6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1291">2.8.1。以ZIP格式下载存储库或部分存储库</a></span></dt><dt><span class="section"><a href="#d0e1310">2.8.2。项目编辑者权限</a></span></dt><dt><span class="section"><a href="#d0e1354">2.8.3。在“指导决策表向导”中统一验证样式。</a></span></dt><dt><span class="section"><a href="#d0e1370">2.8.4。改进的巫师</a></span></dt><dt><span class="section"><a href="#d0e1384">2.8.5。XLS，指导决策表和指导模板的一致行为</a></span></dt><dt><span class="section"><a href="#d0e1407">2.8.6。改进的元数据选项卡</a></span></dt><dt><span class="section"><a href="#d0e1461">2.8.7。改进的数据对象编辑器</a></span></dt><dt><span class="section"><a href="#d0e1496">2.8.8。执行服务器管理UI</a></span></dt><dt><span class="section"><a href="#d0e1517">2.8.9。社交活动</a></span></dt><dt><span class="section"><a href="#d0e1567">2.8.10。贡献者仪表板</a></span></dt><dt><span class="section"><a href="#d0e1587">2.8.11。包选择器</a></span></dt><dt><span class="section"><a href="#d0e1603">2.8.12。改善视觉一致性</a></span></dt><dt><span class="section"><a href="#d0e1624">2.8.13。指导决策树编辑器</a></span></dt><dt><span class="section"><a href="#d0e1638">2.8.14。创建存储库向导</a></span></dt><dt><span class="section"><a href="#d0e1657">2.8.15。仓库结构屏幕</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.2.0">2.9。集成6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1679">2.9.1。KIE执行服务器</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.1.0">2.10。Drools 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1694">2.10.1。JMX对KieScanner的支持</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.1.0">2.11。KIE Workbench 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1755">2.11.1。Data Modeler-往返和源代码保存</a></span></dt><dt><span class="section"><a href="#d0e1760">2.11.2。Data Modeler-改进的注释</a></span></dt><dt><span class="section"><a href="#d0e1765">2.11.3。表格数据显示的标准化</a></span></dt><dt><span class="section"><a href="#d0e1824">2.11.4。的产生<code class="code">modify(x) {...}</code>块</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesKIE.6.0.0">2.12。KIE API 6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1848">2.12.1。新的KIE名称</a></span></dt><dt><span class="section"><a href="#d0e1859">2.12.2。Maven对齐项目和模块以及Maven部署</a></span></dt><dt><span class="section"><a href="#d0e1866">2.12.3。基于配置和约定的项目</a></span></dt><dt><span class="section"><a href="#d0e1881">2.12.4。KieBase包含</a></span></dt><dt><span class="section"><a href="#d0e1901">2.12.5。KieModules，KieContainer和KIE-CI</a></span></dt><dt><span class="section"><a href="#d0e1920">2.12.6。KieScanner</a></span></dt><dt><span class="section"><a href="#d0e1970">2.12.7。分层ClassLoader</a></span></dt><dt><span class="section"><a href="#d0e1975">2.12.8。旧版API适配器</a></span></dt><dt><span class="section"><a href="#d0e1980">2.12.9。KIE文档</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.0.0">2.13。Drools 6.0.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1988">2.13.1。PHREAK-惰性规则匹配算法</a></span></dt><dt><span class="section"><a href="#d0e1997">2.13.2。在被动模式下自动触发定时规则</a></span></dt><dt><span class="section"><a href="#d0e2023">2.13.3。表达计时器</a></span></dt><dt><span class="section"><a href="#d0e2058">2.13.4。RuleFlowGroups和AgendaGroups合并</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.0.0">2.14。KIE Workbench 6.0.0中的新功能和值得注意的功能</a></span></dt><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.0.0">2.15。集成6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2161">2.15.1。CDI</a></span></dt><dt><span class="section"><a href="#d0e2176">2.15.2。弹簧</a></span></dt><dt><span class="section"><a href="#d0e2181">2.15.3。白羊座的蓝图</a></span></dt><dt><span class="section"><a href="#d0e2186">2.15.4。准备好OSGi</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#compatibilityMatrix">3。相容性矩阵</a></span></dt></dl></div></div><div class="chapter" title="第1章。介绍"><div class="titlepage"><div><div><h2 class="title"><a id="Welcome"></a>第1章。介绍</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e32">1.1。介绍</a></span></dt><dt><span class="section"><a href="#gettingstarted">1.2。卷入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e56">1.2.1。注册jboss.org</a></span></dt><dt><span class="section"><a href="#d0e67">1.2.2。签署贡献者协议</a></span></dt><dt><span class="section"><a href="#d0e78">1.2.3。通过JIRA提交问题</a></span></dt><dt><span class="section"><a href="#d0e98">1.2.4。叉GitHub</a></span></dt><dt><span class="section"><a href="#d0e109">1.2.5。写作测试</a></span></dt><dt><span class="section"><a href="#d0e122">1.2.6。遵守正确的约定</a></span></dt><dt><span class="section"><a href="#d0e132">1.2.7。提交拉取请求</a></span></dt></dl></dd><dt><span class="section"><a href="#installationAndSetup">1.3。安装和设置（Core和IDE）</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e147">1.3.1。安装和使用</a></span></dt><dt><span class="section"><a href="#d0e322">1.3.2。从源头建造</a></span></dt><dt><span class="section"><a href="#d0e368">1.3.3。日食</a></span></dt></dl></dd></dl></div><div class="section" title="1.1。介绍"><div class="titlepage"><div><div><h2 class="title"><a id="d0e32"></a> 1.1。介绍</h2></div></div></div><p>自从上一个5.x系列发布以来，这是繁忙的一年，发生了很多变化。</p><p>5.x系列中最大的抱怨之一是缺乏定义的部署方法。Drools和jBPM使用的机制非常灵活，但是太灵活了。6.0的一大重点是简化系统的构建，部署和加载（利用）方面。现在，构建和部署与Maven保持一致，并且使用率现在是面向约定和配置的，而不是编程的，并且默认情况下是合理的，以最大程度地减少配置。</p><p>受Eclipse的启发，工作台已经完全重新构建，以提供一个灵活，更好的集成解决方案。通过插件提供面板和视角。基础工作台已经分解成一个名为UberFire的独立项目，因此任何人现在都可以构建基于Web的高质量工作台。从长远来看，它将促进用户定制的Drools和jBPM安装。</p><p>Git取代JCR作为内容存储库，为具有强大工具支持的内容提供了快速且可扩展的后端存储。人们将重心从数据库的简单性转移到另一个方面，目的是将所有内容都存储为文本文件，甚至元数据也只是文件。该数据库就可以通过Lucene提供快速索引和搜索。这将允许现在将存储库与已建立的基础架构（例如GitHub）同步并发布。</p><p>由于收购了Polymita，jBPM得到了极大的增强，它具有人工任务，表单构建器，类建模器，执行服务器和运行时管理。所有这些都完全集成到新的工作台中。</p><p>OptaPlanner现在是一个顶级项目，正在引起全职关注。</p><p>引入了一个新的总称KIE（知识就是一切），以将我们的相关技术集中在一起。它也是我们项目共享的核心。因此，希望看到很多。</p></div><div class="section" title="1.2。卷入"><div class="titlepage"><div><div><h2 class="title"><a id="gettingstarted"></a> 1.2。卷入</h2></div></div></div><p>我们经常被问到“我如何参与”。幸运的是，答案很简单，只需编写一些代码并提交即可：)您不必烦恼，也不必进行秘密握手。我们确实要求最小的“开销”以允许可伸缩的项目开发。下面，我们提供了所需工具和“工作流程”的概述，以及一些常规建议。</p><p>如果您贡献了一些出色的作品，请不要忘了写博客:)</p><div class="section" title="1.2.1。注册jboss.org"><div class="titlepage"><div><div><h3 class="title"><a id="d0e56"></a> 1.2.1。注册jboss.org</h3></div></div></div><p>登录jboss.org将使您可以访问JBoss Wiki，论坛和JIRA。转到<a class="link" href="http://www.jboss.org/">http://www.jboss.org/</a> ，然后单击“注册”。</p><div class="mediaobject"><img src="images/GettingInvolved/sign_jbossorg.png"></div></div><div class="section" title="1.2.2。签署贡献者协议"><div class="titlepage"><div><div><h3 class="title"><a id="d0e67"></a> 1.2.2。签署贡献者协议</h3></div></div></div><p>您需要签署的唯一表格是贡献者协议，该协议可以通过网络完全自动化。如下图所示：“这将确定您的贡献的条款和条件，并确保可以适当地许可源代码”</p><p><a class="link" href="https://cla.jboss.org/">https://cla.jboss.org/</a></p><div class="mediaobject"><img src="images/GettingInvolved/sign_contributor.png"></div></div><div class="section" title="1.2.3。通过JIRA提交问题"><div class="titlepage"><div><div><h3 class="title"><a id="d0e78"></a> 1.2.3。通过JIRA提交问题</h3></div></div></div><p>为了能够与核心开发团队进行互动，您将需要使用问题跟踪器JIRA。这样可确保记录所有请求并将其分配给发布计划，并将所有讨论都集中在一个地方。错误报告，错误修复，功能请求和功能提交都应在此处。一般问题应在邮件列表中进行。</p><p>次要代码提交（例如格式或文档修复）不需要创建关联的JIRA问题。</p><p><a class="link" href="https://issues.jboss.org/browse/JBRULES">https://issues.jboss.org/browse/JBRULES（Drools</a> ）</p><p><a class="link" href="https://issues.jboss.org/browse/JBPM">https://issues.jboss.org/browse/JBPM</a></p><p><a class="link" href="https://issues.jboss.org/browse/GUVNOR">https://issues.jboss.org/browse/GUVNOR</a></p><div class="mediaobject"><img src="images/GettingInvolved/submit_jira.png"></div></div><div class="section" title="1.2.4。叉GitHub"><div class="titlepage"><div><div><h3 class="title"><a id="d0e98"></a> 1.2.4。叉GitHub</h3></div></div></div><p>签署了贡献者协议并将您的请求提交给JIRA之后，您现在就可以开始编写代码了：）创建一个GitHub帐户并派生任何Drools，jBPM或Guvnor存储库。该分支将在您自己的GitHub空间中创建一个副本，您可以按照自己的进度进行操作。如果您输入有误，请放心将其吹走再叉。请注意，每个GitHub存储库都为您提供了克隆（签出）URL，GitHub将为您提供特定于您的fork的URL。</p><p><a class="link" href="https://github.com/droolsjbpm">https://github.com/droolsjbpm</a></p><div class="mediaobject"><img src="images/GettingInvolved/fork_github.png"></div></div><div class="section" title="1.2.5。写作测试"><div class="titlepage"><div><div><h3 class="title"><a id="d0e109"></a> 1.2.5。写作测试</h3></div></div></div><p>编写测试时，请尝试使它们保持在最低限度且自成体系。我们倾向于将DRL片段保留在测试中，因为这样可以更快地进行检查。如果它们是大量规则，那么使用字符串是不实际的，因此，一定要将它们放在单独的DRL文件中，而不是从类路径中加载。如果您的测试需要使用模型，请尝试使用其他单元测试已经存在的模型；例如“人”，“奶酪”或“订单”。如果不存在具有所需字段的类，请在添加新类之前尝试更新现有类的字段。</p><p>有大量的测试可用来了解您的想法，MiscTest是一个不错的起点。</p><p><a class="link" href="https://github.com/droolsjbpm">https://github.com/droolsjbpm/drools/blob/master/drools-compiler/src/test/java/org/drools/integrationtests/MiscTest.java</a></p><div class="mediaobject"><img src="images/GettingInvolved/unit_test.png"></div></div><div class="section" title="1.2.6。遵守正确的约定"><div class="titlepage"><div><div><h3 class="title"><a id="d0e122"></a> 1.2.6。遵守正确的约定</h3></div></div></div><p>提交时，请确保使用正确的约定。提交必须以JIRA问题ID（例如JBRULES-220）开头。这样可以确保通过JIRA对提交进行交叉引用，因此我们可以在同一位置查看给定问题的所有提交。在ID之后，应该紧接着是问题的标题。然后使用带有短划线的换行符来提供与此提交有关的其他信息。对于要创建的每个单独的点，请使用额外的新行和破折号。您可以在适当的情况下向同一提交添加其他JIRA交叉引用。通常，尝试避免在同一提交中合并无关的问题。</p><p>别忘了从原始主服务器上重新构建本地分叉，然后将提交推回分叉。</p><div class="mediaobject"><img src="images/GettingInvolved/jira_crossreferenced.png"></div></div><div class="section" title="1.2.7。提交拉取请求"><div class="titlepage"><div><div><h3 class="title"><a id="d0e132"></a> 1.2.7。提交拉取请求</h3></div></div></div><p>现在，您的代码已从原始主文件中重新定位并推送到您的个人GitHub区域，现在您可以将您的工作作为请求请求提交。如果您在GitHub的页面顶部找到您的工作区域，则它们将是“拉取请求”按钮。然后选择此项将提供一个gui，以自动执行您的请求请求的提交。</p><p>然后，pull请求进入队列，以供所有人查看和评论。在下面，您可以看到典型的请求请求。拉取请求允许进行讨论，并且显示所有关联的提交以及每个提交的差异。讨论通常涉及代码审查，这些审查为改进提供了有用的建议，并允许我们在代码的特定部分留下内联注释。如果我们不立即合并，请不要灰心，在接受拉取请求之前，通常可能需要进行多次修订。幸运的是，GitHub非常简单，它可以返回您的代码，再进行一些提交，然后将您的拉取请求更新为最新的最大的请求。</p><p>我们可能需要一些时间来响应请求请求，因此请耐心等待。提交的带有修复程序的测试通常会很快应用，就像测试通常会这样，直到我们有时间也提交带有修复程序的测试。不要忘了重新设置基础并不时重新提交您的请求，否则随着时间的流逝将出现合并冲突，核心开发人员通常会忽略这些冲突。</p><div class="mediaobject"><img src="images/GettingInvolved/submit_pull_request.png"></div></div></div><div class="section" title="1.3。安装和设置（Core和IDE）"><div class="titlepage"><div><div><h2 class="title"><a id="installationAndSetup"></a> 1.3。安装和设置（Core和IDE）</h2></div></div></div><div class="section" title="1.3.1。安装和使用"><div class="titlepage"><div><div><h3 class="title"><a id="d0e147"></a> 1.3.1。安装和使用</h3></div></div></div><p>Drools提供了一个基于Eclipse的IDE（可选），但其核心仅需要Java 1.5（Java SE）。</p><p>一种简单的入门方法是下载并安装Eclipse插件-这也将需要安装Eclipse GEF框架（如果尚未安装，请参见下文）。这将为您提供开始所需的所有依赖项：您只需创建一个新的规则项目，一切都将为您完成。有关此方面的详细说明，请参阅Rule Workbench和IDE上的章节。安装Eclipse插件通常很简单，只需将文件解压缩到Eclipse插件目录中即可。</p><p>不需要使用Eclipse插件。规则文件只是文本输入（或视情况而定的电子表格），而IDE（也称为Rule Workbench）只是一种便利。人们以多种方式集成了规则引擎，没有“一刀切”的功能。</p><p>或者，您可以下载二进制发行版，并将相关的JAR包含在项目的类路径中。</p><div class="section" title="1.3.1.1。依赖关系和JAR"><div class="titlepage"><div><div><h4 class="title"><a id="d0e158"></a> 1.3.1.1。依赖关系和JAR</h4></div></div></div><p>Drools分为几个模块，在规则开发/编译过程中需要一些模块，在运行时需要一些模块。在许多情况下，人们只是想在运行时包括所有依赖项，这很好。它使您拥有最大的灵活性。但是，有些人可能希望将其“运行时”精简到最低限度，因为他们将以二进制形式部署规则-这也是可能的。核心运行时引擎可以非常紧凑，并且在3个JAR文件中仅需要几百个KB。</p><p>以下是构成JBoss Drools的重要库的描述</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Knowledge-api.jar-提供接口和工厂。它还有助于清楚地表明什么是用户API，什么仅仅是引擎API。</p></li><li class="listitem"><p>Knowledge-internal-api.jar-提供内部接口和工厂。</p></li><li class="listitem"><p>drools-core.jar-这是核心引擎，运行时组件。同时包含RETE引擎和LEAPS引擎。如果要预编译规则（并通过Package或RuleBase对象进行部署），则这是唯一的运行时依赖项。</p></li><li class="listitem"><p>drools-compiler.jar-它包含编译器/构建器组件，以获取规则源并构建可执行规则库。这通常是应用程序的运行时依赖项，但是如果您正在预编译规则，则不必如此。这取决于流口水的核心。</p></li><li class="listitem"><p>drools-jsr94.jar-这是JSR-94兼容的实现，它实质上是drools-compiler组件上的一层。请注意，由于JSR-94规范的性质，并非所有功能都可以通过此接口轻松公开。在某些情况下，直接进入Drools API会更容易，但是在某些环境中，必须使用JSR-94。</p></li><li class="listitem"><p>drools-decisiontables.jar-这是决策表的“编译器”组件，它使用drools-compiler组件。这支持excel和CSV输入格式。</p></li></ul></div><p>上述组件还需要其他一些依赖项，其中大多数依赖于drools-compiler，drools-jsr94或drools-decisiontables模块。需要注意的一些关键是提供电子表格分析功能的“ POI”和提供规则语言本身的分析的“ antlr”。</p><p>注意：如果在J2EE或Servlet容器中使用Drools，并且遇到“ JDT”的类路径问题，则可以切换到janino编译器。设置系统属性“ drools.compiler”：例如：-Ddrools.compiler = JANINO。</p><p>有关发行版中依赖项的最新信息，请查阅发行的POM，可以在Maven存储库中找到。</p></div><div class="section" title="1.3.1.2。与Maven，Gradle，Ivy，Buildr或Ant一起使用"><div class="titlepage"><div><div><h4 class="title"><a id="d0e190"></a> 1.3.1.2。与Maven，Gradle，Ivy，Buildr或Ant一起使用</h4></div></div></div><p>JAR也可以在<a class="link" href="http://search.maven.org/#search|ga|1|org.drools">中央Maven存储库</a> （以及<a class="link" href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.drools~~~~">JBoss Maven存储库</a> ）中使用。</p><p>如果您使用Maven，则在项目的项目中添加KIE和Drools依赖项<code class="filename">pom.xml</code>像这样：</p><pre><code class="language-xml">  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.drools&lt;/groupId&gt;
        &lt;artifactId&gt;drools-bom&lt;/artifactId&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;version&gt;...&lt;/version&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
      ...
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.kie&lt;/groupId&gt;
      &lt;artifactId&gt;kie-api&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    ...
  &lt;dependencies&gt;</code></pre><p>这与Gradle，Ivy和Buildr类似。要确定最新版本，请检查Maven存储库。</p><p>如果您仍在使用Ant（没有Ivy），请从下载zip文件的所有副本中复制所有JAR <code class="filename">binaries</code>目录并手动验证您的类路径不包含重复的JAR。</p></div><div class="section" title="1.3.1.3。运行"><div class="titlepage"><div><div><h4 class="title"><a id="d0e215"></a> 1.3.1.3。运行</h4></div></div></div><p>这里提到的“运行时”要求是如果您以规则的二进制形式（以KnowledgePackage对象或KnowledgeBase对象等）的形式部署规则。这是一项可选功能，可以使您的运行时保持良好状态。您可以使用drools-compiler生成“进程外”规则包，然后将其部署到运行时系统。该运行时系统仅需要drools-core.jar和Knowledge-api即可执行。这是一种可选的部署模式，许多人不需要过多地“修剪”他们的应用程序，但是对于某些环境来说，它是理想的选择。</p></div><div class="section" title="1.3.1.4。安装IDE（Rule Workbench）"><div class="titlepage"><div><div><h4 class="title"><a id="d0e220"></a> 1.3.1.4。安装IDE（Rule Workbench）</h4></div></div></div><p>规则工作台（对于Eclipse）要求您具有Eclipse 3.4或更高版本，以及Eclipse GEF 3.4或更高版本。您可以通过下载插件或使用更新站点来安装它。</p><p>另一个选择是使用JBoss IDE，它预先包装了所有插件要求，并提供了一些独立于规则的其他工具。您可以选择仅从JBoss IDE附带的“捆绑包”中安装规则。</p><div class="section" title="1.3.1.4.1。安装GEF（必需的依赖项）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e227"></a> 1.3.1.4.1。安装GEF（必需的依赖项）</h5></div></div></div><p>GEF是Eclipse图形编辑框架，用于查看插件中的图形。</p><p>如果未安装GEF，则可以使用内置的更新机制进行安装（或不建议从Eclipse.org网站下载GEF）。JBoss IDE和Eclipse的许多其他“发行版”一样，已经具有GEF，因此对于某些人来说，此步骤可能是多余的。</p><p>从帮助菜单中打开“帮助”->“软件更新...”->“可用软件”->“添加站点...”。位置是：</p><pre><code class="no-highlight">http://download.eclipse.org/tools/gef/updates/releases/</code></pre><p>接下来，选择GEF插件：</p><div class="screenshot"><div class="mediaobject"><img src="images/Install/install_gef.png"></div></div><p>按下一步，并同意安装插件（可能需要重新启动Eclipse）。完成此操作后，即可继续安装规则插件。</p></div><div class="section" title="1.3.1.4.2。从zip文件安装GEF"><div class="titlepage"><div><div><h5 class="title"><a id="d0e246"></a> 1.3.1.4.2。从zip文件安装GEF</h5></div></div></div><p>要从zip文件安装，请下载并解压缩该文件。在zip内，您将看到一个插件目录以及插件JAR本身。您将插件JAR放入Eclipse应用程序插件目录，然后重新启动Eclipse。</p></div><div class="section" title="1.3.1.4.3。从zip文件安装Drools插件"><div class="titlepage"><div><div><h5 class="title"><a id="d0e251"></a> 1.3.1.4.3。从zip文件安装Drools插件</h5></div></div></div><p>从下面的链接下载Drools Eclipse IDE插件。将下载的文件解压缩到您的主eclipse文件夹中（不要只是将文件复制到那里，解压缩以便功能部件和插件JAR最终位于eclipse的功能部件和插件目录中），然后（重新）启动Eclipse。</p><p><a class="ulink" href="http://www.drools.org/download/download.html">http://www.drools.org/download/download.html</a></p><p>要检查安装是否成功，请尝试打开Drools透视图：单击Eclipse窗口右上角的“打开透视图”按钮，选择“其他...”，然后选择Drools透视图。如果您找不到Drools透视图作为可能的透视图之一，则说明安装可能不成功。检查是否正确执行了每个必需的步骤：您是否具有正确版本的Eclipse（3.4.x）？是否已安装Eclipse GEF（请检查org.eclipse.gef_3.4。* .jar是否存在于Eclipse根文件夹的plugins目录中？您是否正确提取了Drools Eclipse插件（检查Eclipse根文件夹中的plugins目录中是否存在org.drools.eclipse _ *。jar）？如果您找不到问题，请尝试与我们联系（例如，在irc或用户邮件列表中），可以在这里找到我们主页上没有的更多信息：</p><p><a class="ulink" href="http://www.drools.org/">http://www.drools.org/</a></p></div><div class="section" title="1.3.1.4.4。流口水运行时"><div class="titlepage"><div><div><h5 class="title"><a id="d0e264"></a> 1.3.1.4.4。流口水运行时</h5></div></div></div><p>Drools运行时是文件系统上JAR的集合，代表了Drools项目JAR的一个特定版本。要创建运行时，您必须将IDE指向您选择的版本。如果要基于插件本身中包含的最新Drools项目JAR创建新的运行时，则也可以轻松地做到这一点。您需要为Eclipse工作区指定默认的Drools运行时，但是每个单独的项目都可以覆盖默认值，并为该项目选择适当的运行时。</p><div class="section" title="1.3.1.4.4.1。定义Drools运行时"><div class="titlepage"><div><div><h6 class="title"><a id="d0e269"></a> 1.3.1.4.4.1。定义Drools运行时</h6></div></div></div><p>您需要使用Eclipse首选项视图定义一个或多个Drools运行时。要打开您的首选项，请在菜单窗口中选择首选项菜单项。新的首选项对话框应显示您的所有首选项。在此对话框的左侧，在Drools类别下，选择“ Installed Drools runtimes”。然后，右侧面板应显示当前定义的Drools运行时。如果尚未定义任何运行时，则应类似于下图所示。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes.png" align="middle"></div><p>要定义新的Drools运行时，请单击添加按钮。将会弹出一个如下所示的对话框，要求您提供运行时的名称以及在文件系统上可以找到它的位置。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes-add.png" align="middle"></div><p>通常，您有两种选择：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>如果您只想使用Drools Eclipse插件中包含的默认JAR，则可以通过单击“创建新的Drools 5运行时...”按钮来自动创建新的Drools运行时。将显示一个文件浏览器，要求您在文件系统上选择要在其中创建运行时的文件夹。然后，插件将自动将所有必需的依赖项复制到指定的文件夹。选择此文件夹后，对话框应如下图所示。</p></li><li class="listitem"><p>如果要使用Drools项目的一个特定版本，则应在文件系统上创建一个文件夹，其中包含所有必需的Drools库和依赖项。不要像上面解释的那样创建新的Drools运行时，而是给运行时命名并选择包含所有必需JAR的文件夹的位置。</p></li></ol></div><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes-add2.png" align="middle"></div><p>单击确定按钮后，运行时将显示在已安装的Drools运行时表中，如下所示。单击新创建的运行时前面的复选框，将其设置为默认的Drools运行时。默认的Drools运行时将用作所有尚未选择项目特定运行时的Drools项目的运行时。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes2.png" align="middle"></div><p>您可以根据需要添加任意数量的Drools运行时。例如，以下屏幕截图显示了已定义三个运行时的配置：Drools 4.0.7运行时，Drools 5.0.0运行时和Drools 5.0.0。SNAPSHOT运行时。Drools 5.0.0运行时被选择为默认运行时。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes3.png" align="middle"></div><p>请注意，如果您更改了默认运行时，则需要重新启动Eclipse，并且要确保所有使用默认运行时的项目都相应地更新其类路径。</p></div><div class="section" title="1.3.1.4.4.2。为您的Drools项目选择运行时"><div class="titlepage"><div><div><h6 class="title"><a id="d0e306"></a> 1.3.1.4.4.2。为您的Drools项目选择运行时</h6></div></div></div><p>每当您创建Drools项目时（使用“ New Drools项目”向导，或者使用在Drools透视图中显示的“转换为Drools项目”操作将现有的Java项目转换为Drools项目，然后右键单击现有项目） Java项目），该插件会自动将所有必需的JAR添加到您项目的类路径中。</p><p>当创建一个新的Drools项目时，除非您指定一个特定于项目的插件，否则插件将自动使用该项目的默认Drools运行时。您可以在“新建Drools项目”向导的最后一步中执行此操作，如下所示，方法是取消选中“使用默认Drools运行时”复选框，然后在下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes-newproject.png" align="middle"></div><p>您可以随时打开项目属性（右键单击该项目并选择“属性”），然后选择Drools类别，以随时更改Drools项目的运行时，如下所示。选中“启用项目特定设置”复选框，然后从下拉框中选择适当的运行时。如果单击“配置工作空间设置...”链接，将打开显示当前安装的Drools运行时的工作空间首选项，因此您可以在其中添加新的运行时。如果取消选中“启用项目特定设置”复选框，它将使用全局首选项中定义的默认运行时。</p><div class="mediaobject" align="center"><img src="images/Install/drools-runtimes-project.png" align="middle"></div></div></div></div></div><div class="section" title="1.3.2。从源头建造"><div class="titlepage"><div><div><h3 class="title"><a id="d0e322"></a> 1.3.2。从源头建造</h3></div></div></div><div class="section" title="1.3.2.1。获取资源"><div class="titlepage"><div><div><h4 class="title"><a id="d0e325"></a> 1.3.2.1。获取资源</h4></div></div></div><p>每个Maven工件的源代码都可以在JBoss Maven存储库中作为源JAR获得。下载zip文件中还包含相同的源JAR。但是，如果您要从源代码构建，强烈建议从源代码控件获取我们的源代码。</p><p>Drools和jBPM使用<a class="link" href="http://git-scm.com/">Git</a>进行源代码控制。受祝福的git仓库托管在<a class="link" href="https://github.com">GitHub上</a> ：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="https://github.com/droolsjbpm">https://github.com/droolsjbpm</a></p></li></ul></div><p>Git允许您分叉我们的代码，对其进行独立的个人更改，但仍会定期合并我们的最新更改，并可以选择与我们共享您的更改。要了解有关git的更多信息，请阅读免费书籍<a class="link" href="http://progit.org/book/">Git Pro</a> 。</p></div><div class="section" title="1.3.2.2。建立资源"><div class="titlepage"><div><div><h4 class="title"><a id="d0e348"></a> 1.3.2.2。建立资源</h4></div></div></div><p>本质上，从源代码构建非常容易，例如，如果要构建<em class="firstterm">guvnor</em>项目：</p><pre><code class="no-highlight">$ git clone git@github.com:droolsjbpm/guvnor.git
...
$ cd guvnor
$ mvn clean install -DskipTests -Dfull
...</code></pre><p>但是， <span class="emphasis"><em>存在很多潜在的陷阱</em></span> ，因此，如果您认真考虑从源代码进行构建并可能为项目做出贡献，请<span class="bold"><strong>遵循<a class="link" href="https://github.com/droolsjbpm/droolsjbpm-build-bootstrap/blob/master/README.md">droolsjbpm-build-bootstrap中的README文件中</a>的说明。</strong></span></p></div></div><div class="section" title="1.3.3。日食"><div class="titlepage"><div><div><h3 class="title"><a id="d0e368"></a> 1.3.3。日食</h3></div></div></div><div class="section" title="1.3.3.1。导入Eclipse项目"><div class="titlepage"><div><div><h4 class="title"><a id="d0e371"></a> 1.3.3.1。导入Eclipse项目</h4></div></div></div><p>随着<a id="d0e376" class="indexterm"></a>生成的Eclipse项目文件现在可以导入Eclipse。启动Eclipse时，在Subversion检出的根目录中打开工作区。</p><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import2.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import3.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import4.jpg"></div></div><p>调用<span class="command"><strong>mvn安装时，</strong></span>所有项目依赖项均已下载并添加到本地Maven存储库。除非您告诉它存储库在哪里，否则Eclipse无法找到那些依赖项。为此， <code class="literal">M2_REPO</code>类路径变量。</p><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import6.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import7.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import8.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Install/eclipse_import9.jpg"></div></div></div></div></div></div><div class="chapter" title="第2章。发行说明"><div class="titlepage"><div><div><h2 class="title"><a id="DroolsReleaseNotesChapter"></a>第2章。发行说明</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.5.0">2.1。Drools 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e443">2.1.1。可配置的ThreadFactory</a></span></dt><dt><span class="section"><a href="#d0e456">2.1.2。使用任何表达式作为查询的输入</a></span></dt><dt><span class="section"><a href="#d0e467">2.1.3。使用修改后的属性更新</a></span></dt><dt><span class="section"><a href="#d0e476">2.1.4。监控框架改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.5.0.Final">2.2。KIE Workbench 6.5.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e567">2.2.1。指导规则编辑器：复合字段约束中的支持公式</a></span></dt><dt><span class="section"><a href="#d0e588">2.2.2。创作-项目编辑器-重新导入按钮</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.4.0">2.3。Drools 6.4.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e596">2.3.1。更好的Java 8兼容性</a></span></dt><dt><span class="section"><a href="#d0e601">2.3.2。更强大的增量编译</a></span></dt><dt><span class="section"><a href="#d0e606">2.3.3。改进的多线程行为</a></span></dt><dt><span class="section"><a href="#d0e615">2.3.4。OOPath改进</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.4.0.Final">2.4。KIE Workbench 6.4.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e663">2.4.1。新外观</a></span></dt><dt><span class="section"><a href="#d0e678">2.4.2。各种UI改进</a></span></dt><dt><span class="section"><a href="#d0e704">2.4.3。新地区</a></span></dt><dt><span class="section"><a href="#d0e762">2.4.4。创作-导入-一致的术语</a></span></dt><dt><span class="section"><a href="#d0e801">2.4.5。禁用自动构建</a></span></dt><dt><span class="section"><a href="#d0e815">2.4.6。支持<code class="literal">SCP</code>样式<code class="literal">git</code>储存库网址</a></span></dt><dt><span class="section"><a href="#d0e838">2.4.7。创作-重复的GAV检测</a></span></dt><dt><span class="section"><a href="#d0e945">2.4.8。新的执行服务器管理用户界面</a></span></dt><dt><span class="section"><a href="#d0e957">2.4.9。用户和组管理</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.3.0">2.5。Drools 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e973">2.5.1。使用OOPath浏览对象图</a></span></dt><dt><span class="section"><a href="#shared.ReleaseNotes.KieNavigator">2.5.2。Eclipse的Kie Navigator View</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.3.0.Final">2.6。KIE Workbench 6.3.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1105">2.6.1。决策表的实时验证和验证</a></span></dt><dt><span class="section"><a href="#d0e1121">2.6.2。改进的DRL编辑器</a></span></dt><dt><span class="section"><a href="#d0e1133">2.6.3。资产锁定</a></span></dt><dt><span class="section"><a href="#d0e1152">2.6.4。数据建模工具Windows</a></span></dt><dt><span class="section"><a href="#d0e1178">2.6.5。启用JPA的数据模型的生成</a></span></dt><dt><span class="section"><a href="#d0e1221">2.6.6。数据集创作</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.2.0">2.7。Drools 6.2.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1236">2.7.1。传播方式</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.2.0.Final">2.8。KIE Workbench 6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1291">2.8.1。以ZIP格式下载存储库或部分存储库</a></span></dt><dt><span class="section"><a href="#d0e1310">2.8.2。项目编辑者权限</a></span></dt><dt><span class="section"><a href="#d0e1354">2.8.3。在“指导决策表向导”中统一验证样式。</a></span></dt><dt><span class="section"><a href="#d0e1370">2.8.4。改进的巫师</a></span></dt><dt><span class="section"><a href="#d0e1384">2.8.5。XLS，指导决策表和指导模板的一致行为</a></span></dt><dt><span class="section"><a href="#d0e1407">2.8.6。改进的元数据选项卡</a></span></dt><dt><span class="section"><a href="#d0e1461">2.8.7。改进的数据对象编辑器</a></span></dt><dt><span class="section"><a href="#d0e1496">2.8.8。执行服务器管理UI</a></span></dt><dt><span class="section"><a href="#d0e1517">2.8.9。社交活动</a></span></dt><dt><span class="section"><a href="#d0e1567">2.8.10。贡献者仪表板</a></span></dt><dt><span class="section"><a href="#d0e1587">2.8.11。包选择器</a></span></dt><dt><span class="section"><a href="#d0e1603">2.8.12。改善视觉一致性</a></span></dt><dt><span class="section"><a href="#d0e1624">2.8.13。指导决策树编辑器</a></span></dt><dt><span class="section"><a href="#d0e1638">2.8.14。创建存储库向导</a></span></dt><dt><span class="section"><a href="#d0e1657">2.8.15。仓库结构屏幕</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.2.0">2.9。集成6.2.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1679">2.9.1。KIE执行服务器</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.1.0">2.10。Drools 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1694">2.10.1。JMX对KieScanner的支持</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.1.0">2.11。KIE Workbench 6.1.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1755">2.11.1。Data Modeler-往返和源代码保存</a></span></dt><dt><span class="section"><a href="#d0e1760">2.11.2。Data Modeler-改进的注释</a></span></dt><dt><span class="section"><a href="#d0e1765">2.11.3。表格数据显示的标准化</a></span></dt><dt><span class="section"><a href="#d0e1824">2.11.4。的产生<code class="code">modify(x) {...}</code>块</a></span></dt></dl></dd><dt><span class="section"><a href="#kie.ReleaseNotesKIE.6.0.0">2.12。KIE API 6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1848">2.12.1。新的KIE名称</a></span></dt><dt><span class="section"><a href="#d0e1859">2.12.2。Maven对齐项目和模块以及Maven部署</a></span></dt><dt><span class="section"><a href="#d0e1866">2.12.3。基于配置和约定的项目</a></span></dt><dt><span class="section"><a href="#d0e1881">2.12.4。KieBase包含</a></span></dt><dt><span class="section"><a href="#d0e1901">2.12.5。KieModules，KieContainer和KIE-CI</a></span></dt><dt><span class="section"><a href="#d0e1920">2.12.6。KieScanner</a></span></dt><dt><span class="section"><a href="#d0e1970">2.12.7。分层ClassLoader</a></span></dt><dt><span class="section"><a href="#d0e1975">2.12.8。旧版API适配器</a></span></dt><dt><span class="section"><a href="#d0e1980">2.12.9。KIE文档</a></span></dt></dl></dd><dt><span class="section"><a href="#drools.ReleaseNotesDrools.6.0.0">2.13。Drools 6.0.0中有哪些新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1988">2.13.1。PHREAK-惰性规则匹配算法</a></span></dt><dt><span class="section"><a href="#d0e1997">2.13.2。在被动模式下自动触发定时规则</a></span></dt><dt><span class="section"><a href="#d0e2023">2.13.3。表达计时器</a></span></dt><dt><span class="section"><a href="#d0e2058">2.13.4。RuleFlowGroups和AgendaGroups合并</a></span></dt></dl></dd><dt><span class="section"><a href="#wb.ReleaseNotesWorkbench.6.0.0">2.14。KIE Workbench 6.0.0中的新功能和值得注意的功能</a></span></dt><dt><span class="section"><a href="#kie.ReleaseNotesIntegration.6.0.0">2.15。集成6.0.0中的新功能和值得注意的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2161">2.15.1。CDI</a></span></dt><dt><span class="section"><a href="#d0e2176">2.15.2。弹簧</a></span></dt><dt><span class="section"><a href="#d0e2181">2.15.3。白羊座的蓝图</a></span></dt><dt><span class="section"><a href="#d0e2186">2.15.4。准备好OSGi</a></span></dt></dl></dd></dl></div><div class="section" title="2.1。Drools 6.5.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="drools.ReleaseNotesDrools.6.5.0"></a> 2.1。Drools 6.5.0中的新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.1.1。可配置的ThreadFactory"><div class="titlepage"><div><div><h3 class="title"><a id="d0e443"></a> 2.1.1。可配置的ThreadFactory</h3></div></div></div><p>某些运行时环境（例如Google App Engine）不允许直接创建新的线程。因此，现在可以通过使用类名设置系统属性<span class="bold"><strong>drools.threadFactory</strong></span>来插入自己的ThreadFactory实现。例如，如果您使用此类实现了与Google App Engine兼容的ThreadFactory <code class="literal">com.user.project.GoogleAppEngineThreadFactory</code>您可以通过设置使Drools使用它：</p><pre><code class="no-highlight">drools.threadFactory = com.user.project.GoogleAppEngineThreadFactory</code></pre></div><div class="section" title="2.1.2。使用任何表达式作为查询的输入"><div class="titlepage"><div><div><h3 class="title"><a id="d0e456"></a> 2.1.2。使用任何表达式作为查询的输入</h3></div></div></div><p>现在可以将事实的字段都用作查询的输入参数，例如：</p><pre><code class="no-highlight">query contains(String $s, String $c)
    $s := String( this.contains( $c ) )
end

rule PersonNamesWithA when
    $p : Person()
    contains( $p.name, "a"; )
then
end</code></pre><p>通常，还有任何一种有效的表达式，例如：</p><pre><code class="no-highlight">query checkLength(String $s, int $l)
    $s := String( length == $l )
end

rule CheckPersonNameLength when
    $i : Integer()
    $p : Person()
    checkLength( $p.name, 1 + $i + $p.age; )
then
end</code></pre></div><div class="section" title="2.1.3。使用修改后的属性更新"><div class="titlepage"><div><div><h3 class="title"><a id="d0e467"></a> 2.1.3。使用修改后的属性更新</h3></div></div></div><p>引入了属性反应性，以避免不必要的和无用的（重新）评估，并使引擎仅对实际上限制或绑定在给定模式内部的属性做出反应。但是，此功能仅可用于在规则结果内进行的修改。相反，以编程方式进行的更新不会意识到对象的属性已更改，因此无法使用此功能。</p><p>为了克服此限制，现在可以有选择地在更新语句中指定已修改的对象中已更改的属性的名称，如以下示例所示：</p><pre><code class="no-highlight">Person me = new Person("me", 40);
FactHandle meHandle = ksession.insert( me );

me.setAge(41);
me.setAddress("California Avenue");
ksession.update( meHandle, me, "age", "address" );</code></pre></div><div class="section" title="2.1.4。监控框架改进"><div class="titlepage"><div><div><h3 class="title"><a id="d0e476"></a> 2.1.4。监控框架改进</h3></div></div></div><p>为了监视KieContainers，引入了一种新型的MBean，并且重新审视了JMX MBean的层次结构，以反映与KieBases的相关MBean的关系。已对JMX对象命名进行了规范化以反映Kie API中使用的术语。引入了一种新型的MBean，以便提供对Stateless KieSession的监视，而在以前的版本中则没有。</p><div class="table"><a id="d0e481"></a><p class="title"><strong>表2.1。JMX对象名更改</strong></p><div class="table-contents"><table border="1" summary="JMX objectname changes"><colgroup><col><col><col></colgroup><thead><tr><th align="center">MBean</th><th align="center">之前<code class="code">6.5.x</code></th><th align="center">从<code class="code">6.5.0.Final</code></th></tr></thead><tbody><tr><td>KieContainer</td><td>不适用</td><td><code class="code">org.kie:kcontainerId={kcontainerId}</code></td></tr><tr><td>凯基</td><td><code class="code">org.drools.kbases:type={kbaseId}</code></td><td><code class="code">org.kie:kcontainerId={kcontainerId},kbaseId={kbaseId}</code></td></tr><tr><td>KieSession（有状态）</td><td><code class="code">org.drools.kbases:type={kbaseId},group=Sessions,sessionId={ksessionId}</code></td><td><code class="code">org.kie:kcontainerId={kcontainerId},kbaseId={kbaseId},ksessionType=Stateful,ksessionName={ksessionName}</code></td></tr><tr><td>无状态KieSession</td><td>不适用</td><td><code class="code">org.kie:kcontainerId={kcontainerId},kbaseId={kbaseId},ksessionType=Stateless,ksessionName={ksessionName}</code></td></tr></tbody></table></div></div><br class="table-break"><p>KieSession MBean合并以相同名称实例化的所有会话的统计数据。</p><p>通过创建KieSession <code class="code">JPAKnowledgeService</code> ，将在具有常量的KieSession MBean下进行监控<code class="code">{ksessionName}</code>重视<code class="code">persistent</code> ;此MBean不直接由KieContainer管理，因此，当不再需要监视时，需要从JMX手动注销它。</p><p>新的JMX对象命名方案现在对ID强制使用正确的JMX引用，例如：<code class="code">org.kie:kcontainerId="2cb55f40-f220-432a-aba8-7940c18bf108",kbaseId="KBase1"</code></p><p>旧的DroolsManagementAgent（已在JMX上以<code class="code">org.drools:type=DroolsManagementAgent</code> ）不再需要，因此不再在JMX上注册。</p><p>现在，KieSession MBean具有适当的JMX <code class="code">CompositeData</code>和<code class="code">TabularData</code>支持（如适用）。KieSession MBean继续支持所有与流程相关的聚合统计信息监视，但不再显示每个流程实例的开始/结束日期：jBPM中对此范围提供了审计和日志记录支持。</p><p>Drools RHQ / JON插件进行了更改，以反映上述所有更改，此外还进行了旨在正确显示层次嵌套的特定错误修复。</p></div></div><div class="section" title="2.2。KIE Workbench 6.5.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="wb.ReleaseNotesWorkbench.6.5.0.Final"></a> 2.2。KIE Workbench 6.5.0中的新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.2.1。指导规则编辑器：复合字段约束中的支持公式"><div class="titlepage"><div><div><h3 class="title"><a id="d0e567"></a> 2.2.1。指导规则编辑器：复合字段约束中的支持公式</h3></div></div></div><p>现在，复合字段约束支持公式的使用。</p><p>将约束添加到模式时，“多字段约束”选择（“所有（和）”和“任何一个（或）”）支持使用除表达式之外的公式。</p><div class="figure"><a id="d0e574"></a><p class="title"><strong>图2.1。复合字段约束-选择公式</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/composite-field-constraint-formulae1.png" alt="复合字段约束-选择公式"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e581"></a><p class="title"><strong>图2.2。复合字段约束-公式编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/composite-field-constraint-formulae2.png" alt="复合字段约束-公式编辑器"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.2.2。创作-项目编辑器-重新导入按钮"><div class="titlepage"><div><div><h3 class="title"><a id="d0e588"></a> 2.2.2。创作-项目编辑器-重新导入按钮</h3></div></div></div><p>“重新导入”按钮会使所有缓存的依赖项无效，以便处理其中特定的依赖关系已更新而无需修改其版本的情况。
    </p></div></div><div class="section" title="2.3。Drools 6.4.0中有哪些新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="drools.ReleaseNotesDrools.6.4.0"></a> 2.3。Drools 6.4.0中有哪些新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.3.1。更好的Java 8兼容性"><div class="titlepage"><div><div><h3 class="title"><a id="d0e596"></a> 2.3.1。更好的Java 8兼容性</h3></div></div></div><p>现在可以在规则的右侧（然后）部分使用Java 8语法（lambda和方法引用）。</p></div><div class="section" title="2.3.2。更强大的增量编译"><div class="titlepage"><div><div><h3 class="title"><a id="d0e601"></a> 2.3.2。更强大的增量编译</h3></div></div></div><p>当涉及带有子网的一个或多个规则（具有复杂存在模式的规则）时，尤其是当在不同规则之间共享同一子网时，增量编译（基于规则的动态更新）存在一些相关的缺陷。此问题需要部分重写现有的增量编译算法，然后进行一次完整的审计，该审计也已通过仅在该领域由20,000多个测试用例构成的全新测试套件进行了验证。</p></div><div class="section" title="2.3.3。改进的多线程行为"><div class="titlepage"><div><div><h3 class="title"><a id="d0e606"></a> 2.3.3。改进的多线程行为</h3></div></div></div><p>为了消除大量同步点并提高稳定性和可预测性，部分处理了多线程引擎代码。尤其是，这种新的实现方式可以使用户线程（在会话上执行插入/更新/删除操作），引擎线程（进行适当的规则评估）和计时器（执行基于时间的操作）之间更清晰地分离并更好地交互。像事件到期）。</p><p>Drools 6引入了新的phreak算法，从而使这一改进成为可能。实际上，在ReteOO算法中，网络评估是在用户插入/更新/删除操作期间执行的，这意味着每个用户操作都会锁定整个引擎。与phreak相反，插入/更新/删除是分开的，并且在调用fireAllRules或fireUntilHalt时会进行网络评估。</p><p>更详细地说，此改进分为两部分。首先，添加了新的线程安全队列，以将所有用户操作存储为命令。在规则评估阶段，该队列由用户线程填充，而其条目由引擎线程刷新和处理。第二部分介绍了一个状态机，用于协调用户线程，计时器线程和引擎线程，然后提供了一种更清晰的自记录方式来对它们的交互进行建模。</p></div><div class="section" title="2.3.4。OOPath改进"><div class="titlepage"><div><div><h3 class="title"><a id="d0e615"></a> 2.3.4。OOPath改进</h3></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>此功能是实验性的</p></div><p>OOPath已在Drools 6.3.0中引入。在Drools 6.4.0中已对其进行了增强，以支持以下功能：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>约束还可以引用当前迭代对象之前遍历的图形对象。例如以下OOPath：</p><pre><code class="no-highlight">Student( $grade: /plan/exams/grades{ result &gt; ../averageResult } )</code></pre><p>将仅匹配成绩高于通过考试平均水平的成绩。</p></li><li class="listitem"><p>约束也可以递归地成为另一个OOPath，如下所示：</p><pre><code class="no-highlight">Student( $exam: /plan/exams{ /grades{ result &gt; 20 } } )</code></pre></li><li class="listitem"><p>也可以使用<code class="literal">?/</code>分隔符而不是<code class="literal">/</code>一。如以下示例所示：</p><pre><code class="no-highlight">Student( $grade: /plan/exams{ course == "Big Data" }?/grades )</code></pre><p>这样，引擎将对对考试所做的更改或是否将考试添加到计划中做出了反应，但是如果对现有考试添加了新成绩则不会做出反应。当然，如果OOPath块不是反应性的，则从那里到表达式结尾的所有OOPath其余部分也将是非反应性的。例如以下OOPath</p><pre><code class="no-highlight">Student( $grade: ?/plan/exams{ course == "Big Data" }/grades )</code></pre><p>将完全无反应。因此，不允许使用<code class="literal">?/</code>分隔符在同一OOPath中不止一次，所以表达式如下：</p><pre><code class="no-highlight">Student( $grade: /plan?/exams{ course == "Big Data" }?/grades )</code></pre><p>会导致编译时错误。</p></li></ul></div></div></div><div class="section" title="2.4。KIE Workbench 6.4.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="wb.ReleaseNotesWorkbench.6.4.0.Final"></a> 2.4。KIE Workbench 6.4.0中的新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.4.1。新外观"><div class="titlepage"><div><div><h3 class="title"><a id="d0e663"></a> 2.4.1。新外观</h3></div></div></div><p>整个工作台的总体外观已更新为采用<a class="link" href="https://www.patternfly.org/">PatternFly</a> 。此更新在每个屏幕上带来了更清洁，轻便和更一致的用户体验。通过删除所有不必要的视觉元素，使用户可以专注于数据和任务。交互和行为基本上保持不变，从而将这种更改的范围限制为视觉更新。
    </p><div class="figure"><a id="d0e671"></a><p class="title"><strong>图2.3。工作台-新外观</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewLookAndFeel.png" alt="工作台-新外观"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.4.2。各种UI改进"><div class="titlepage"><div><div><h3 class="title"><a id="d0e678"></a> 2.4.2。各种UI改进</h3></div></div></div><p>除了上述针对一般外观的PatternFly更新之外，还改进了工作台中的许多单个组件以创建更好的用户体验。这涉及确保模式弹出窗口的默认大小适合于适合相应的内容，调整文本字段的大小以及对齐标签，以及在较小的屏幕上使用时改善各种组件的调整大小行为。
    </p><div class="figure"><a id="d0e683"></a><p class="title"><strong>图2.4。工作台-适当大小的弹出窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ModalPostPatternFly.png" alt="工作台-适当大小的弹出窗口"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e690"></a><p class="title"><strong>图2.5。工作台-适当大小的文本字段和对齐的标签</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/LabelFieldAlignmentPostPatternFly.png" alt="工作台-适当大小的文本字段和对齐的标签"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e697"></a><p class="title"><strong>图2.6。工作台-调整大小的编辑器窗口，水平空间有限</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/HorizonalAlignmentPostPatternFly.png" alt="工作台-调整大小的编辑器窗口，水平空间有限"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.4.3。新地区"><div class="titlepage"><div><div><h3 class="title"><a id="d0e704"></a> 2.4.3。新地区</h3></div></div></div><p>语言环境<code class="literal">ru</code> （俄语）和<code class="literal">zh_TW</code> （繁体中文）现在已添加。</p><p>现在支持的语言环境是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>默认英语。</p></li><li class="listitem"><p><code class="literal">es</code> （西班牙语）</p></li><li class="listitem"><p><code class="literal">fr</code> （法文）</p></li><li class="listitem"><p><code class="literal">de</code> （德语）</p></li><li class="listitem"><p><code class="literal">ja</code> （日本）</p></li><li class="listitem"><p><code class="literal">pt_BR</code> （葡萄牙语-巴西）</p></li><li class="listitem"><p><code class="literal">zh_CN</code> （简体中文）</p></li><li class="listitem"><p><code class="literal">zh_TW</code> （中国传统的）</p></li><li class="listitem"><p><code class="literal">ru</code> （俄语）</p></li></ul></div><p>
    </p></div><div class="section" title="2.4.4。创作-导入-一致的术语"><div class="titlepage"><div><div><h3 class="title"><a id="d0e762"></a> 2.4.4。创作-导入-一致的术语</h3></div></div></div><p>工作台以前在项目编辑器中有一个用于“导入建议”的部分，这实际上是用户注册Java运行时环境提供的类以供规则创作使用的一种方法。此外，编辑器还有一个“配置”选项卡，在该选项卡中，用户应将类从其他程序包导入到规则所在的程序包中。</p><p>这两个术语都不明确，而且彼此之间以及工作台的其他方面均不一致。</p><p>我们更改了这些术语，以（希望）使其含义更清楚，并与在工作台中创作Java类有关的“数据对象”术语保持一致。</p><div class="figure"><a id="d0e771"></a><p class="title"><strong>图2.7。项目编辑器-外部数据对象</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ExternalDataObjects1.png" alt="项目编辑器-外部数据对象"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e778"></a><p class="title"><strong>图2.8。项目编辑器-定义外部数据对象</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ExternalDataObjects2.png" alt="项目编辑器-定义外部数据对象"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e785"></a><p class="title"><strong>图2.9。资产编辑器-数据对象</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DataObjects1.png" alt="资产编辑器-数据对象"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e792"></a><p class="title"><strong>图2.10。资产编辑器-定义可用于创作的数据对象</strong></p><div class="figure-contents"><p>“数据对象”屏幕列出了与资产在同一包中的所有数据对象，并允许导入其他包中的其他数据对象。</p><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DataObjects2.png" alt="资产编辑器-定义可用于创作的数据对象"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.4.5。禁用自动构建"><div class="titlepage"><div><div><h3 class="title"><a id="d0e801"></a> 2.4.5。禁用自动构建</h3></div></div></div><p>使用项目资源管理器浏览项目时，工作台会自动构建所选项目，并在消息控制台中显示构建消息。尽管这是有益的，但在编写大型项目时可能会对工作台的性能产生不利影响。现在可以使用<code class="code">org.kie.build.disable-project-explorer</code>系统属性。将值设置为<code class="code">true</code>禁用。默认值为<code class="code">false</code> 。</p></div><div class="section" title="2.4.6。支持SCP样式的git存储库URL"><div class="titlepage"><div><div><h3 class="title"><a id="d0e815"></a> 2.4.6。支持<code class="literal">SCP</code>样式<code class="literal">git</code>储存库网址</h3></div></div></div><p>克隆时<code class="literal">git</code>现在可以使用存储库<code class="literal">SCP</code>样式网址，例如<code class="literal">git@github.com:user/repository.git</code> 。如果您操作系统的公共密钥库受密码保护，则密码可以随<code class="literal">org.uberfire.nio.git.ssh.passphrase</code>系统属性。</p></div><div class="section" title="2.4.7。创作-重复的GAV检测"><div class="titlepage"><div><div><h3 class="title"><a id="d0e838"></a> 2.4.7。创作-重复的GAV检测</h3></div></div></div><p>执行以下任何操作时，现在将检查为项目解析的所有Maven存储库，以查看是否存在项目的GroupId，ArtifactId和Version。如果发现冲突，则阻止该操作；尽管用户可以使用<code class="code">admin</code>角色。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>可以通过设置系统属性来禁用该功能<code class="code">org.guvnor.project.gav.check.disabled</code>至<code class="code">true</code> 。</p></div><p>解析的存储库是在以下位置发现的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>项目的<code class="code">POM</code><code class="code"><repositories></code>部分（或任何父母<code class="code">POM</code> ）。</p></li><li class="listitem"><p>项目的<code class="code">POM</code><code class="code"><distributionManagement></code>部分。</p></li><li class="listitem"><p>Maven的全球<code class="code">settings.xml</code>配置文件。</p></li></ul></div><p>
    </p><p>受影响的操作：-</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>创建新的托管存储库。</p></li><li class="listitem"><p>使用项目编辑器保存项目定义。</p></li><li class="listitem"><p>将新模块添加到托管多模块存储库。</p></li><li class="listitem"><p>保存<code class="code">pom.xml</code>文件。</p></li><li class="listitem"><p>使用项目编辑器构建和安装项目。</p></li><li class="listitem"><p>使用项目编辑器构建和部署项目。</p></li><li class="listitem"><p>资产管理部门负责建设，安装或部署项目。</p></li><li class="listitem"><p><code class="code">REST</code>创建，安装或部署项目的操作。</p></li></ul></div><p>
    </p><p>的用户<code class="code">Admin</code>角色可以覆盖使用项目编辑器中“存储库”设置检查的存储库列表。</p><div class="figure"><a id="d0e924"></a><p class="title"><strong>图2.11。项目编辑器-查看已解决的存储库</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories1.png" alt="项目编辑器-查看已解决的存储库"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e931"></a><p class="title"><strong>图2.12。项目编辑器-解析的存储库列表</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories2.png" alt="项目编辑器-解析的存储库列表"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e938"></a><p class="title"><strong>图2.13。检测到重复的GAV</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories3.png" alt="检测到重复的GAV"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.4.8。新的执行服务器管理用户界面"><div class="titlepage"><div><div><h3 class="title"><a id="d0e945"></a> 2.4.8。新的执行服务器管理用户界面</h3></div></div></div><p>KIE Execution Server管理UI进行了完全重新设计，以适应最近引入的重大改进。除了新的UI是从头开始构建并遵循PatternFly提供的最佳实践这一事实外，新界面还扩展了以前的功能，使用户可以更好地控制服务器。
    </p><div class="figure"><a id="d0e950"></a><p class="title"><strong>图2.14。KIE Execution Server-新的用户界面</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewExecServerUI.png" alt="KIE Execution Server-新的用户界面"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.4.9。用户和组管理"><div class="titlepage"><div><div><h3 class="title"><a id="d0e957"></a> 2.4.9。用户和组管理</h3></div></div></div><p>提供后端服务和直观友好的用户界面，使工作台管理员可以管理应用程序的用户和组。</p><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/UserAndGroupManagement.png"></div></div><p>该界面为工作台管理员提供了执行领域相关操作的能力，例如创建用户，创建组，将组或角色分配给给定用户等。</p><p>默认情况下，它带有用于管理Wildfly，EAP和Tomcat默认领域的内置实现，并且设计为可扩展的-任何第三方领域管理系统都可以轻松集成到工作台中。</p></div></div><div class="section" title="2.5。Drools 6.3.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="drools.ReleaseNotesDrools.6.3.0"></a> 2.5。Drools 6.3.0中的新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.5.1。使用OOPath浏览对象图"><div class="titlepage"><div><div><h3 class="title"><a id="d0e973"></a> 2.5.1。使用OOPath浏览对象图</h3></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>此功能是实验性的</p></div><p>当事实的字段是一个集合时，可以使用<code class="literal">from</code>关键词。但是，当需要浏览对象图时，会广泛使用<code class="literal">from</code>条件元素可能会导致冗长而繁琐的语法，如以下示例所示：</p><div class="example"><a id="d0e987"></a><p class="title"><strong>示例2.1浏览来自的对象图</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Find all grades for Big Data exam" when
    $student: Student( $plan: plan )
    $exam: Exam( course == "Big Data" ) from $plan.exams
    $grade: Grade() from $exam.grades
then /* RHS */ end</code></pre></div></div><br class="example-break"><p>在此示例中，假设使用的领域模型包括<code class="literal">Student</code>谁有一个<code class="literal">Plan</code>研究： <code class="literal">Plan</code>可以有零个或多个<code class="literal">Exam</code> s和<code class="literal">Exam</code>零或更多<code class="literal">Grade</code> s。请注意，只有图的根对象（ <code class="literal">Student</code>在这种情况下）必须位于工作存储器中才能正常工作。</p><p>通过从XPath借用思想，可以使此语法更加简洁，因为XPath具有紧凑的符号，可以在处理集合和过滤约束时浏览相关元素。这种受XPath启发的符号被称为<code class="literal">OOPath</code>因为它专门用于浏览对象图。使用此表示法，可以按如下方式重写前一个示例：</p><div class="example"><a id="d0e1020"></a><p class="title"><strong>示例2.2使用OOPath浏览对象图</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Find all grades for Big Data exam" when
    Student( $grade: /plan/exams{course == "Big Data"}/grades )
then /* RHS */ end</code></pre></div></div><br class="example-break"><p>形式上，核心语法<code class="literal">OOPath</code>可以通过这种方式在EBNF表示法中定义表达式。</p><pre><code class="no-highlight">OOPExpr = "/" OOPSegment { ( "/" | "." ) OOPSegment } ;
OOPSegment = [ID ( ":" | ":=" )] ID ["[" Number "]"] ["{" Constraints "}"];</code></pre><p>在实践中<code class="literal">OOPath</code>表达式具有以下功能。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>它必须以<code class="literal">/</code> 。</p></li><li class="listitem"><p>它可以通过以下方式取消引用对象的单个属性： <code class="literal">.</code>算子</p></li><li class="listitem"><p>它可以使用<code class="literal">/</code>操作员。如果返回一个集合，它将遍历该集合中的值</p></li><li class="listitem"><p>在遍历引用的对象时，它可以过滤掉不满足一个或多个约束的对象，它们写成大括号之间的谓词表达式，例如：</p><pre><code class="no-highlight">Student( $grade: /plan/exams{course == "Big Data"}/grades )</code></pre></li><li class="listitem"><p>也可以通过将项目放在方括号之间来按其索引访问项目，例如：</p><pre><code class="no-highlight">Student( $grade: /plan/exams[0]/grades )</code></pre><p>为了遵守Java约定，与基于XPath 1的索引相比，OOPath索引的基于0的索引</p></li></ul></div><div class="section" title="2.5.1.1。反应性OOPath"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1068"></a> 2.5.1.1。反应性OOPath</h4></div></div></div><p>目前，Drools无法对包含在评估过程中遍历的深层嵌套的更新做出反应<code class="literal">OOPath</code>表达。为了使这些对象对当前的变化有反应，有必要使它们扩展类<code class="literal">org.drools.core.phreak.ReactiveObject</code> 。计划通过实现一种自动检测属于特定域模型的类的机制来克服此限制。</p><p>通过扩展该类，域对象可以通过调用继承的方法来通知引擎其字段之一已更新。 <code class="literal">notifyModification</code>如以下示例所示：</p><div class="example"><a id="d0e1084"></a><p class="title"><strong>例子2.3。通知引擎考试已移至其他课程</strong></p><div class="example-contents"><pre><code class="no-highlight">public void setCourse(String course) {
    this.course = course;
    notifyModification(this);
}</code></pre></div></div><br class="example-break"><p>这样，如果将考试转移到其他课程，则重新触发该规则，并重新计算与该规则匹配的成绩列表。</p></div></div><div class="section" title="2.5.2。Eclipse的Kie Navigator View"><div class="titlepage"><div><div><h3 class="title"><a id="shared.ReleaseNotes.KieNavigator"></a> 2.5.2。Eclipse的Kie Navigator View</h3></div></div></div><p>新的查看器已添加到Eclipse工具中。该Kie Navigator视图用于管理Kie Server的安装和项目。</p><p>请阅读“ <span class="olink"><span class="command"><strong>Kie Navigator视图</strong></span></span> ”一章以获取有关此新功能的更多信息</p></div></div><div class="section" title="2.6。KIE Workbench 6.3.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="wb.ReleaseNotesWorkbench.6.3.0.Final"></a> 2.6。KIE Workbench 6.3.0中的新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.6.1。决策表的实时验证和验证"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1105"></a> 2.6.1。决策表的实时验证和验证</h3></div></div></div><p>决策表过去具有用于验证表的“验证”按钮。现在将其删除，并在每个单元格值更改后验证该表。验证和验证检查包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">冗余</li><li class="listitem">包容性</li><li class="listitem">矛盾冲突</li><li class="listitem">缺少列</li></ul></div><p>这些检查将在工作台文档中详细说明。</p></div><div class="section" title="2.6.2。改进的DRL编辑器"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1121"></a> 2.6.2。改进的DRL编辑器</h3></div></div></div><p>DRL编辑器已经进行了整容。从普通的TextArea转换为使用ACE Editor和自定义DRL语法突出显示工具。</p><div class="figure"><a id="d0e1126"></a><p class="title"><strong>图2.15。ACE编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/drl-ace-editor.png" alt="ACE编辑器"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.6.3。资产锁定"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1133"></a> 2.6.3。资产锁定</h3></div></div></div><p>为了避免在编辑资产时发生冲突，引入了一种新的锁定机制，以确保一次只能有一个用户可以编辑资产。当用户开始编辑资产时，将自动获取锁。这由资产标题栏以及项目资源管理器视图中显示的锁定符号指示。如果用户开始编辑已经锁定的资产，则会显示一个弹出通知，通知用户该资产当前无法编辑，因为该资产正在由另一个用户使用。只要编辑用户持有该锁，就可以防止其他用户进行更改。当编辑用户保存或关闭资产或退出工作台时，锁将自动释放。如果需要，每个用户还可以选择在元数据选项卡中强制释放锁定。</p><div class="figure"><a id="d0e1138"></a><p class="title"><strong>图2.16。自动编辑资产会获得锁定</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DataModelEditingWithLock.png" alt="自动编辑资产会获得锁定"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e1145"></a><p class="title"><strong>图2.17。锁定资产不能由其他用户编辑</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DataModelLocked.png" alt="锁定资产不能由其他用户编辑"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.6.4。数据建模工具Windows"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1152"></a> 2.6.4。数据建模工具Windows</h3></div></div></div><p>Drools和jBPM配置，持久性（请参阅生成启用JPA的数据模型）和高级配置已移至“工具窗口”。“工具窗口”是最新的Uberfire版本中引入的新概念，可用于开发上下文感知的屏幕。每个“工具窗口”将包含一个域编辑器，该域编辑器将管理一组相关的数据对象参数。
    </p><div class="figure"><a id="d0e1157"></a><p class="title"><strong>图2.18。Drools和jBPM域工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-DroolsDomainToolWindow6.3.png" alt="Drools和jBPM域工具窗口"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e1164"></a><p class="title"><strong>图2.19。持久性工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-JPADomainToolWindow6.3.png" alt="持久性工具窗口"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e1171"></a><p class="title"><strong>图2.20。高级配置工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-AdvancedDomainToolWindow6.3.png" alt="高级配置工具窗口"></div></div></div></div><br class="figure-break"></div><div class="section" title="2.6.5。启用JPA的数据模型的生成"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1178"></a> 2.6.5。启用JPA的数据模型的生成</h3></div></div></div><p>扩展了数据建模器以支持可持久数据对象的生成。可持久数据对象基于JPA规范，并且所有基础元数据都是自动生成的。
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>可以在创建时将“新建->数据对象”数据对象标记为可持久。</p><div class="figure"><a id="d0e1187"></a><p class="title"><strong>图2.21。新数据对象</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-NewDataObject6.3.png" alt="新数据对象"></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>持久性工具窗口包含用于数据对象和字段的JPA域编辑器。每个编辑器将默认管理生成的JPA元数据</p><div class="figure"><a id="d0e1197"></a><p class="title"><strong>图2.22。数据对象级JPA域编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-DataObjectJPADomainTab6.3.png" alt="数据对象级JPA域编辑器"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e1204"></a><p class="title"><strong>图2.23。现场级JPA域编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-FieldJPADomainTab6.3.png" alt="现场级JPA域编辑器"></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>持久性配置屏幕已添加到项目编辑器。</p><div class="figure"><a id="d0e1214"></a><p class="title"><strong>图2.24。持久性配置</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DM-Persistence-Configuration6.3.png" alt="持久性配置"></div></div></div></div><br class="figure-break"></li></ul></div></div><div class="section" title="2.6.6。数据集创作"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1221"></a> 2.6.6。数据集创作</h3></div></div></div><p>添加了创作数据集定义的新视角。数据集定义可以从数据库，CSV / Excel文件等外部系统中检索数据，甚至可以使用Java类来生成数据。数据一旦可用，就可以用于例如从“透视编辑器”创建图表和仪表板，而仅从任何可用数据集中提供图表。
    </p><div class="figure"><a id="d0e1226"></a><p class="title"><strong>图2.25。数据集创作视角</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/DataSetAuthoringPerspective.png" alt="数据集创作视角"></div></div></div></div><br class="figure-break"></div></div><div class="section" title="2.7。Drools 6.2.0中有哪些新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><a id="drools.ReleaseNotesDrools.6.2.0"></a> 2.7。Drools 6.2.0中有哪些新功能和值得注意的功能</h2></div></div></div><div class="section" title="2.7.1。传播方式"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1236"></a> 2.7.1。传播方式</h3></div></div></div><p>PHREAK作为Drools引擎的默认算法的引入使规则的评估变得懒惰。这种新的Drools懒惰行为可以提高性能，但在某些特定情况下，则打破了Drools某些功能的语义。</p><p>更确切地说，在某些情况下，必须立即将新事实的插入传播到会话中。例如，Drools允许在查询之前以'？的形式在只拉（或被动）模式下执行查询。'符号，如下例所示：</p><div class="example"><a id="d0e1243"></a><p class="title"><strong>示例2.4被动查询</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></div><br class="example-break"><p>在这种情况下，由于查询是被动的，因此它不应对在查询本身中插入符合联接条件的String做出反应。换句话说，这一系列命令</p><pre><code class="language-java">KieSession ksession = ...
ksession.insert(1);
ksession.insert("1");
ksession.fireAllRules();</code></pre><p>不应导致规则R触发，因为在整数之后插入了满足查询条件的字符串，并且被动查询不应对此插入作出反应。相反，如果插入顺序被反转，则规则应触发，因为当存在现有String可以满足被动查询时，Integer的插入将触发它。</p><p>不幸的是，PHREAK的惰性特性不允许引擎对这两个事实的插入顺序进行任何区分，因此该规则在两种情况下都适用。在这种情况下，有必要像旧的基于RETEOO的引擎一样急切地评估规则。</p><p>在其他情况下，要求传播是热切的，这意味着它不是即时的，但是无论如何必须在引擎/议程开始计划的评估之前进行。例如，当规则具有no-loop或lock-on-active属性时，这是必需的，实际上，当这种情况发生时，此传播模式将由引擎自动实施。</p><p>为了涵盖这些用例，以及在所有其他需要立即评估或急切评估规则的情况下，可以通过使用<span class="bold"><strong>@Propagation（Propagation。）注释规则本身来声明性地指定<span class="bold"><strong>。类型）</strong></span> ，其中传播。Type是具有3个可能值的枚举：</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>IMMEDIATE</strong></span>表示立即进行传播。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>EAGER</strong></span>意味着传播是<span class="bold"><strong>缓慢</strong></span>进行的，但是在计划的评估之前急切地进行了评估。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>LAZY</strong></span>表示传播完全是惰性的，这是默认的PHREAK行为</strong></p></li></ul></div><p><strong>这意味着下面的drl：</strong></p><div class="example"><strong><a id="d0e1281"></a><p class="title"><strong>示例2.5使用被动查询的数据驱动规则</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R @Propagation(IMMEDIATE) when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></strong></div><strong><br class="example-break"><p>当且仅当将Integer插入到String之后时，规则R才会触发，从而符合被动查询的语义。</p></strong></div></div><div class="section" title="2.8。KIE Workbench 6.2.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="wb.ReleaseNotesWorkbench.6.2.0.Final"></a> 2.8。KIE Workbench 6.2.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.8.1。以ZIP格式下载存储库或部分存储库"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1291"></a> 2.8.1。以ZIP格式下载存储库或部分存储库</strong></h3></div></div></div><p><strong>使用此功能可以从存储库中下载ZIP格式的存储库或文件夹。</strong></p><div class="figure"><strong><a id="d0e1296"></a><p class="title"><strong>图2.26。下载当前存储库或项目</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/zip_repo.png" alt="下载当前存储库或项目"></div></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e1303"></a><p class="title"><strong>图2.27。下载资料夹</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/zip_folder.png" alt="下载资料夹"></div></div></div></div><br class="figure-break"></strong></div><div class="section" title="2.8.2。项目编辑者权限"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1310"></a> 2.8.2。项目编辑者权限</strong></h3></div></div></div><p><strong>添加了为项目编辑器配置基于角色的权限的功能。</strong></p><p><strong>可以使用以下命令配置权限<code class="code">WEB-INF/classes/workbench-policy.properties</code>文件。</strong></p><p><strong>支持以下权限：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>保存按钮</strong></p><p><strong><code class="code">feature.wb_project_authoring_save</code></strong></p></li><li class="listitem"><p><strong>删除按钮</strong></p><p><strong><code class="code">feature.wb_project_authoring_delete</code></strong></p></li><li class="listitem"><p><strong>复制按钮</strong></p><p><strong><code class="code">feature.wb_project_authoring_copy</code></strong></p></li><li class="listitem"><p><strong>重命名按钮</strong></p><p><strong><code class="code">feature.wb_project_authoring_rename</code></strong></p></li><li class="listitem"><p><strong>生成和部署按钮</strong></p><p><strong><code class="code">feature.wb_project_authoring_buildAndDeploy</code></strong></p></li></ul></div><p><strong>
    </strong></p></div><div class="section" title="2.8.3。在“指导决策表向导”中统一验证样式。"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1354"></a> 2.8.3。在“指导决策表向导”中统一验证样式。</strong></h3></div></div></div><p><strong>我们所有的新屏幕都使用GWT-Bootstrap小部件，并警告用户以一致的方式输入错误。</strong></p><p><strong>最明显的差异之一是“指导决策表向导”，该向导以与我们使用GWT-Bootstrap不一致的方式警告错误。</strong></p><p><strong>此向导已更新，可以使用新的外观。</strong></p><div class="figure"><strong><a id="d0e1363"></a><p class="title"><strong>图2.28。新的指导决策表向导验证</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewGuidedDecisionTableWizardValidation.png" alt="新的指导决策表向导验证"></div></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.8.4。改进的巫师"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1370"></a> 2.8.4。改进的巫师</strong></h3></div></div></div><p><strong>在对指导决策表向导进行重新设计以使其验证与应用程序其他区域一致的过程中，我们也借此机会将向导框架也移至了GWT-Bootstrap。</strong></p><p><strong>产生的外观更加令人愉悦。我们希望在时间和优先级允许的情况下，将更多的旧版编辑器迁移到GWT-Bootstrap。</strong></p><div class="figure"><strong><a id="d0e1377"></a><p class="title"><strong>图2.29。新向导框架</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewGuidedDecisionTableWizard.png" alt="新向导框架"></div></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.8.5。XLS，指导决策表和指导模板的一致行为"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1384"></a> 2.8.5。XLS，指导决策表和指导模板的一致行为</strong></h3></div></div></div><p><strong>一致性对每个人都是一件好事。用户可以期望不同的创作隐喻产生相同的规则行为（开发人员知道什么时候是错误！）。</strong></p><p><strong>XLS决策表，指导决策表和指导规则模板生成空单元格的基础规则的方式存在一些不一致之处。消除了这些，使它们的操作一致。</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>如果所有约束都具有空值（空单元格），则不会创建模式。</strong></p><p><strong>您是否需要模式但没有约束；您将需要包括约束<code class="code">this != null</code> 。</strong></p><p><strong>此操作与XLS和指导决策表始终工作的方式一致。</strong></p></li><li class="listitem"><p><strong>您可以在字符串字段中为空字符串或空格定义约束，方法是使用双引号将其定界。生成规则时，将从值中删除括起来的引号。</strong></p><p><strong>不需要对其他字符串值使用引号，并且可以将其省略。但是，它们的使用对于区分空字符串和空单元格的约束至关重要-在这种情况下，可以省略该约束。</strong></p></li></ul></div></div><div class="section" title="2.8.6。改进的元数据选项卡"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1407"></a> 2.8.6。改进的元数据选项卡</strong></h3></div></div></div><p><strong>重新设计了先前版本中提供的“元数据”选项卡，以提供更好的资产版本控制信息浏览和恢复。现在，每个工作台编辑器都将提供一个“概述”选项卡，使用户能够管理以下信息。</strong></p><div class="figure"><strong><a id="d0e1412"></a><p class="title"><strong>图2.30。改进的元数据选项卡</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ImprovedMetadataWidget.jpg" alt="改进的元数据选项卡"></div></div></div></strong></div><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>版本历史</p><p>版本历史记录显示资产版本的表格视图，并提供“选择”按钮，使用户能够加载先前创建的版本。</p><div class="figure"><a id="d0e1425"></a><p class="title"><strong>图2.31。版本历史</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ImprovedVersionsHistory.jpg" alt="版本历史"></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>元数据</p><p>元数据部分可以访问其他文件属性。</p><div class="figure"><a id="d0e1437"></a><p class="title"><strong>图2.32。元数据部分</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ImprovedMetadatSection.jpg" alt="元数据部分"></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>评论区</p><p>重新设计的注释区域使文件讨论更加清晰。</p></li><li class="listitem"><p>版本选择下拉列表</p><p>菜单栏上的“版本选择器下拉菜单”提供了从“编辑器”选项卡加载和还原以前版本的功能，而无需打开“概述选项卡”以加载“版本历史记录”。</p><div class="figure"><a id="d0e1454"></a><p class="title"><strong>图2.33。版本选择下拉列表</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ImprovedVersionsSelector.jpg" alt="版本选择下拉列表"></div></div></div></div><br class="figure-break"></li></ul></div></strong></div><div class="section" title="2.8.7。改进的数据对象编辑器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1461"></a> 2.8.7。改进的数据对象编辑器</strong></h3></div></div></div><p><strong>Java编辑器已统一为标准工作台编辑器起作用。这意味着现在每个数据对象都在自己的编辑器窗口中进行编辑。</strong></p><div class="figure"><strong><a id="d0e1466"></a><p class="title"><strong>图2.34。改进的数据对象编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewJavaEditor.png" alt="改进的数据对象编辑器"></div></div></div></strong></div><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>添加了“新建->数据对象”选项以创建数据对象。</p></li><li class="listitem"><p>为每个文件添加了“概述”选项卡，以管理文件元数据并有权访问文件版本历史记录。</p></li><li class="listitem"><p>添加了可编辑的“源选项卡”选项卡。现在，管理员可以使用工作台修改Java代码。</p></li><li class="listitem"><p>提供了“编辑器”-“源选项卡”往返。这将使管理员可以对生成的Java代码进行手动更改，然后返回到编辑器标签以继续工作。</p></li><li class="listitem"><p>类用法检测。每当将要删除或重命名数据对象时，都会在项目中扫描类的用法。如果找到用法（例如在drl文件，决策表等中），则用户将收到警报。这将防止用户中断项目构建。</p><div class="figure"><a id="d0e1489"></a><p class="title"><strong>图2.35。用法检测</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/UsagesDetection.png" alt="用法检测"></div></div></div></div><br class="figure-break"></li></ul></div></strong></div><div class="section" title="2.8.8。执行服务器管理UI"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1496"></a> 2.8.8。执行服务器管理UI</strong></h3></div></div></div><p><strong>在“ <span class="bold"><strong>服务器”</strong></span>顶级菜单下添加了一个名为“ <span class="bold"><strong>管理</strong></span> ”的新透视图。这种观点使用户能够管理具有多个容器的多个执行服务器。可用功能包括连接到已经部署的执行服务器；创建新的，启动，停止，删除或升级容器。
    </strong></p><div class="figure"><strong><a id="d0e1507"></a><p class="title"><strong>图2.36。管理视角</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/NewExecutionServerManagementPerspective.png" alt="管理视角"></div></div></div></strong></div><strong><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>当前版本的Execution Server仅支持基于规则的执行。</p></div></strong></div><div class="section" title="2.8.9。社交活动"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1517"></a> 2.8.9。社交活动</strong></h3></div></div></div><p><strong>在名为<span class="bold"><strong>Activity</strong></span>的新的顶级菜单项组下添加了一个名为<span class="bold"><strong>Social Activities的</strong></span>全新功能。</strong></p><p><strong>这项新功能分为两个不同的视角： <span class="bold"><strong>时间轴视角</strong></span>和<span class="bold"><strong>人员视角</strong></span> 。</strong></p><p><strong><span class="bold"><strong>时间轴透视图</strong></span>在左侧显示了登录用户创建或编辑的最近资产。在主窗口中，有一个“最新更改”屏幕，显示所有最近更新的资产以及一个按存储库过滤最近更新的选项。</strong></p><div class="figure"><strong><a id="d0e1541"></a><p class="title"><strong>图2.37。时间轴透视</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/TimelinePerspective.png" alt="时间轴透视"></div></div></div></strong></div><strong><br class="figure-break"><p><span class="bold"><strong>People Perspective</strong></span>是用户的主页。显示他的信息（包括用户电子邮件中的照片），用户连接（用户关注的人）以及用户最近的活动。还有一种编辑用户信息的方法。搜索建议可用于导航到用户个人资料，关注他并在您的时间轴上查看他的更新。</p><div class="figure"><a id="d0e1553"></a><p class="title"><strong>图2.38。以人为本</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/PeoplePerspective.png" alt="以人为本"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e1560"></a><p class="title"><strong>图2.39。编辑用户信息</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/PeoplePerspective1.png" alt="编辑用户信息"></div></div></div></div><br class="figure-break"></strong></div><div class="section" title="2.8.10。贡献者仪表板"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1567"></a> 2.8.10。贡献者仪表板</strong></h3></div></div></div><p><strong>在名为<span class="bold"><strong>Activity</strong></span>的新顶级菜单项组下添加了一个名为<span class="bold"><strong>Contributors的</strong></span>全新视角。透视图本身是一个仪表板，其中显示了有关工作台中对托管组织/存储库所做贡献的几个指标。每次从工作台中添加/删除组织/存储库时，仪表板本身都会相应更新。</strong></p><p><strong>这种新的视角允许监视托管存储库上的基础活动。</strong></p><div class="figure"><strong><a id="d0e1580"></a><p class="title"><strong>图2.40。贡献者观点</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ContributorsPerspective.png" alt="贡献者观点"></div></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.8.11。包选择器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1587"></a> 2.8.11。包选择器</strong></h3></div></div></div><p><strong>创作时新资产的位置由Project Explorer的上下文决定。</strong></p><p><strong>在“新资源”弹出窗口中，它已被“包选择器”所取代。</strong></p><p><strong>该位置默认为Project Explorer上下文，但现在可以更轻松地选择其他程序包。</strong></p><div class="figure"><strong><a id="d0e1596"></a><p class="title"><strong>图2.41。包选择器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/PackageSelector.png" alt="包选择器"></div></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.8.12。改善视觉一致性"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1603"></a> 2.8.12。改善视觉一致性</strong></h3></div></div></div><p><strong>所有弹出窗口都已重构为使用GWT-Bootstrap小部件。</strong></p><p><strong>尽管进行了简单的更改，但它为整个应用程序带来了更大的视觉一致性。</strong></p><div class="figure"><strong><a id="d0e1610"></a><p class="title"><strong>图2.42。指导决策表编辑器示例弹出窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/GuidedDecisionTableNewPopup.png" alt="指导决策表编辑器示例弹出窗口"></div></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e1617"></a><p class="title"><strong>图2.43。指导规则编辑器示例弹出窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/GuidedRuleNewPopup.png" alt="指导规则编辑器示例弹出窗口"></div></div></div></div><br class="figure-break"></strong></div><div class="section" title="2.8.13。指导决策树编辑器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1624"></a> 2.8.13。指导决策树编辑器</strong></h3></div></div></div><p><strong>添加了新的编辑器以支持简单决策树的建模。</strong></p><p><strong>有关使用的更多信息，请参见《用户指南》中的适用部分。</strong></p><div class="figure"><strong><a id="d0e1631"></a><p class="title"><strong>图2.44。指导决策树示例</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/GuidedDecisionTree1.png" alt="指导决策树示例"></div></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.8.14。创建存储库向导"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1638"></a> 2.8.14。创建存储库向导</strong></h3></div></div></div><p><strong>已经创建了一个向导来指导存储库的创建过程。现在，用户可以在存储库创建时决定它是托管库还是非托管库，并配置所有相关参数。</strong></p><div class="figure"><strong><a id="d0e1643"></a><p class="title"><strong>图2.45。创建存储库向导1/2</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/CreateRepositoryWizard1.png" alt="创建存储库向导1/2"></div></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e1650"></a><p class="title"><strong>图2.46。创建存储库向导2/2</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/CreateRepositoryWizard2.png" alt="创建存储库向导2/2"></div></div></div></div><br class="figure-break"></strong></div><div class="section" title="2.8.15。仓库结构屏幕"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1657"></a> 2.8.15。仓库结构屏幕</strong></h3></div></div></div><p><strong>新的存储库结构屏幕将使用户可以管理给定存储库的项目，以及与托管存储库相关的其他操作，例如：分支创建，资产提升和项目发布。</strong></p><div class="figure"><strong><a id="d0e1662"></a><p class="title"><strong>图2.47。托管存储库的存储库结构屏幕</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/ManagedRepositoryStructureScreen.png" alt="托管存储库的存储库结构屏幕"></div></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e1669"></a><p class="title"><strong>图2.48。非托管存储库的存储库结构屏幕</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/UnManagedRepositoryStructureScreen.png" alt="非托管存储库的存储库结构屏幕"></div></div></div></div><br class="figure-break"></strong></div></div><div class="section" title="2.9。集成6.2.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="kie.ReleaseNotesIntegration.6.2.0"></a> 2.9。集成6.2.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.9.1。KIE执行服务器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1679"></a> 2.9.1。KIE执行服务器</strong></h3></div></div></div><p><strong>创建了一个新的KIE Execution Server，其目的是支持kjars的部署以及自动创建REST端点以执行远程规则。此初始实现无需任何胶合代码即可支持通过REST设置和执行kjars。</strong></p><p><strong>用户界面也集成到工作台中以进行远程配置。有关详细信息，请参见工作台的“ New＆Noteworthy”。</strong></p><div class="figure"><strong><a id="d0e1686"></a><p class="title"><strong>图2.49。Kie Server界面</strong></p><div class="figure-contents"><pre><code class="language-java">@Path("/server")
public interface KieServer {
    
    @GET
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response getInfo();
    
    @POST
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response execute( CommandScript command );
    
    @GET
    @Path("containers")
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response listContainers();
    
    @GET
    @Path("containers/{id}")
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response getContainerInfo( @PathParam("id") String id );
    
    @PUT
    @Path("containers/{id}")
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response createContainer( @PathParam("id") String id, KieContainerResource container );
    
    @DELETE
    @Path("containers/{id}")
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response disposeContainer( @PathParam("id") String id );
    
    @POST
    @Path("containers/{id}")
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response execute( @PathParam("id") String id, String cmdPayload );
    
    @GET
    @Path("containers/{id}/release-id")
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response getReleaseId( @PathParam("id") String id);

    @POST
    @Path("containers/{id}/release-id")
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response updateReleaseId( @PathParam("id") String id, ReleaseId releaseId );
    
    @GET
    @Path("containers/{id}/scanner")
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response getScannerInfo( @PathParam("id") String id );
    
    @POST
    @Path("containers/{id}/scanner")
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response updateScanner( @PathParam("id") String id, KieScannerResource resource );
    
} 
</code></pre></div></strong></div><strong><br class="figure-break"></strong></div></div><div class="section" title="2.10。Drools 6.1.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="drools.ReleaseNotesDrools.6.1.0"></a> 2.10。Drools 6.1.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.10.1。JMX对KieScanner的支持"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1694"></a> 2.10.1。JMX对KieScanner的支持</strong></h3></div></div></div><p><strong>在KieScanner和KieContainer上增加了对JMX监视和管理的支持。要启用，请设置属性<code class="code">kie.scanner.mbeans</code>至<code class="code">enabled</code> ，例如通过Java命令行： <code class="code">-Dkie.scanner.mbeans=enabled</code> 。</strong></p><p><strong>KieScannerMBean将以以下名称注册：</strong></p><p><strong>它公开了以下属性：</strong></p><p><strong>
      </strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>扫描仪发行版ID：</strong></span>配置扫描仪的发行版ID。可能包括Maven范围版本和特殊关键字，例如LATEST，SNAPSHOT等。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>当前发行版ID：</strong></span>工件解析到的实际发行版ID。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>状态：正在</strong></span>启动，正在扫描，正在更新，正在运行，已停止，正在关闭</strong></p></li></ul></div><p><strong>
    </strong></p><p><strong>它还公开了以下操作：</strong></p><p><strong>
      </strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>scanNow（）：</strong></span>强制对maven存储库进行立即扫描以查找工件更新</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>start（）：</strong></span>根据轮询间隔参数开始轮询Maven存储库以获取工件更新</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>stop（）：</strong></span>停止自动轮询Maven存储库</strong></p></li></ul></div><p><strong>
    </strong></p></div></div><div class="section" title="2.11。KIE Workbench 6.1.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="wb.ReleaseNotesWorkbench.6.1.0"></a> 2.11。KIE Workbench 6.1.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.11.1。Data Modeler-往返和源代码保存"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1755"></a> 2.11.1。Data Modeler-往返和源代码保存</strong></h3></div></div></div><p><strong>现在支持数据建模器和Java源代码之间的完整往返。无论Java代码在何处生成（例如Eclipse，Data Modeller），数据建模器都只会更新必要的代码块以保持模型更新。</strong></p></div><div class="section" title="2.11.2。Data Modeler-改进的注释"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1760"></a> 2.11.2。Data Modeler-改进的注释</strong></h3></div></div></div><p><strong>添加了新的注释@ TypeSafe，@ ClassReactive，@ PropertyReactive，@ Timestamp，@ Duration和@Expires，以丰富数据建模人员管理的当前Drools注释。</strong></p></div><div class="section" title="2.11.3。表格数据显示的标准化"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1765"></a> 2.11.3。表格数据显示的标准化</strong></h3></div></div></div><p><strong>我们使用新的表格小部件对表格数据的显示进行了标准化。</strong></p><p><strong>新表支持以下功能：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>选择可见列</strong></p></li><li class="listitem"><p><strong>可调整大小的列</strong></p></li><li class="listitem"><p><strong>可移动列</strong></p></li></ul></div><p><strong>
    </strong></p><div class="figure"><strong><a id="d0e1783"></a><p class="title"><strong>图2.50。新表</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/new-grid.png" alt="新表"></div></div></div></strong></div><strong><br class="figure-break"><p>该表在以下情况下使用：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>收件箱（传入更改）</p></li><li class="listitem"><p>收件箱（最近编辑）</p></li><li class="listitem"><p>收件箱（最近打开）</p></li><li class="listitem"><p>项目问题摘要</p></li><li class="listitem"><p>神器库浏览器</p></li><li class="listitem"><p>项目编辑器依存关系网格</p></li><li class="listitem"><p>项目编辑器KSession网格</p></li><li class="listitem"><p>项目编辑器工作项处理程序配置网格</p></li><li class="listitem"><p>项目编辑器侦听器配置网格</p></li><li class="listitem"><p>搜索结果网格</p></li></ul></div><p>
    </p></strong></div><div class="section" title="2.11.4。Modify（x）{...}块的生成"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1824"></a> 2.11.4。的产生<code class="code">modify(x) {...}</code>块</strong></h3></div></div></div><p><strong>指导规则编辑器，指导模板编辑器和指导决策表编辑器已更改为生成<code class="code">modify(x){...}</code></strong></p><p><strong>从历史上看，这些编辑器支持较旧的<code class="code">update(x)</code>语法，因此在工作台中创建的规则将无法正确响应<code class="code">@PropertyReactive</code>以及模型中的相关注释。现在已经通过使用<code class="code">modify(x){...}</code>块。</strong></p></div></div><div class="section" title="2.12。KIE API 6.0.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="kie.ReleaseNotesKIE.6.0.0"></a> 2.12。KIE API 6.0.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.12.1。新的KIE名称"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1848"></a> 2.12.1。新的KIE名称</strong></h3></div></div></div><p><strong>KIE是用于将我们的相关项目组合在一起的新的总称；随着家庭的不断壮大。KIE还用于统一API的通用部分；例如构建，部署和加载。这将替换以前使用的droolsjbpm和Knowledge关键字。</strong></p><div class="figure"><strong><a id="d0e1853"></a><p class="title"><strong>图2.51。KIE解剖</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/Overview/kie.png" alt="KIE解剖"></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="2.12.2。Maven对齐项目和模块以及Maven部署"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1859"></a> 2.12.2。Maven对齐项目和模块以及Maven部署</strong></h3></div></div></div><p><strong>5.x系列中最大的抱怨之一是缺乏定义的部署方法。Drools和jBPM使用的机制非常灵活，但是太灵活了。6.0的主要重点是简化系统的构建，部署和加载（利用）方面。现在，构建和部署活动与Maven和Maven存储库保持一致。现在，用于加载规则和过程的利用率是面向约定和配置的，而不是面向程序的，并且具有合理的默认设置以最小化配置。</strong></p><p><strong>可以使用Maven构建项目并将其安装到本地M2_REPO或远程Maven存储库中。然后使用Maven声明和构建依赖项的类路径，以供KIE访问。</strong></p></div><div class="section" title="2.12.3。基于配置和约定的项目"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1866"></a> 2.12.3。基于配置和约定的项目</strong></h3></div></div></div><p><strong>“ kmodule.xml”为KIE项目提供了声明式配置。约定和默认值用于减少所需的配置量。</strong></p><div class="example"><strong><a id="d0e1871"></a><p class="title"><strong>示例2.6声明KieBases和KieSessions</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;kbase name="kbase1" packages="org.mypackages"&gt;
    &lt;ksession name="ksession1"/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></strong></div><strong><br class="example-break"><div class="example"><a id="d0e1876"></a><p class="title"><strong>示例2.7利用KieSession</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="2.12.4。KieBase包含"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1881"></a> 2.12.4。KieBase包含</strong></h3></div></div></div><p><strong>可以将属于一个KieBase的所有KIE工件包括到第二个KieBase中。这意味着第二个KieBase除了直接定义到其中的所有规则，功能和过程外，还将包含在包含的KieBase中创建的那些规则，功能和过程。可以在kmodule.xml文件中以声明方式完成此包含</strong></p><div class="example"><strong><a id="d0e1886"></a><p class="title"><strong>示例2.8声明式地将KieBase包含到另一个</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;kbase name="kbase2" includes="kbase1"&gt;
    &lt;ksession name="ksession2"/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></strong></div><strong><br class="example-break"><p>或以编程方式使用<code class="code">KieModuleModel</code> 。</p><div class="example"><a id="d0e1896"></a><p class="title"><strong>示例2.9以编程方式将KieBase包含到另一个</strong></p><div class="example-contents"><pre><code class="language-java">KieModuleModel kmodule = KieServices.Factory.get().newKieModuleModel();
KieBaseModel kieBaseModel1 = kmodule.newKieBaseModel("KBase2").addInclude("KBase1");</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="2.12.5。KieModules，KieContainer和KIE-CI"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1901"></a> 2.12.5。KieModules，KieContainer和KIE-CI</strong></h3></div></div></div><p><strong>Maven生产的任何带有'kmodule.xml'的JAR都被视为KieModule。这可以从类路径加载，也可以在运行时从资源位置动态加载。如果kie-ci依赖项位于类路径上，则它将嵌入Maven，并且所有解析都将使用Maven自动完成，并且可以访问本地或远程存储库。Maven配置遵循Settings.xml。</strong></p><p><strong>KieContainer提供了一个运行时来利用KieModule，通过Maven内置了版本控制功能。Kie-ci将根据要加载的工件的所有Maven声明的依赖关系动态创建一个类路径。支持Maven最新，快照，发布和版本范围。</strong></p><div class="example"><strong><a id="d0e1908"></a><p class="title"><strong>示例2.10使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.newKieContainer(
        ks.newReleaseId("org.mygroup", "myartefact", "1.0") );

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></strong></div><strong><br class="example-break"><p>如果KIE-CI在类路径中，则可以将KieContainers动态更新为特定版本，并通过Maven进行解析。对于有状态的KieSession，现有会话将增量更新。</p><div class="example"><a id="d0e1915"></a><p class="title"><strong>示例2.11动态更新-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieContainer kContainer.updateToVersion(
                ks.newReleaseId("org.mygroup", "myartefact", "1.1") );</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="2.12.6。KieScanner"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1920"></a> 2.12.6。KieScanner</strong></h3></div></div></div><p><strong>的<code class="code">KieScanner</code>是Drools 5中存在的KnowledgeAgent的面向Maven的替代。它会持续监视您的Maven存储库，以检查是否已安装新版本的Kie项目，如果已安装，则将其部署在<code class="code">KieContainer</code>包装那个项目。使用<code class="code">KieScanner</code>要求kie-ci.jar位于类路径上。</strong></p><p><strong>一种<code class="code">KieScanner</code>可以在<code class="code">KieContainer</code>如以下示例所示。</strong></p><div class="example"><strong><a id="d0e1942"></a><p class="title"><strong>示例2.12在KieContainer上注册并启动KieScanner</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "myartifact", "1.0-SNAPSHOT" );
KieContainer kContainer = kieServices.newKieContainer( releaseId );
KieScanner kScanner = kieServices.newKieScanner( kContainer );

// Start the KieScanner polling the Maven repository every 10 seconds
kScanner.start( 10000L );</code></pre></div></strong></div><strong><br class="example-break"><p>在这个例子中<code class="code">KieScanner</code>配置为以固定的时间间隔运行，但也可以通过调用以下命令按需运行<code class="code">scanNow()</code>方法就可以了。如果<code class="code">KieScanner</code>在Maven存储库中找到该用户使用的Kie项目的更新版本<code class="code">KieContainer</code>它会自动下载新版本并触发新项目的增量构建。从这一刻起，所有新<code class="code">KieBase</code>和<code class="code">KieSession</code>以此创建<code class="code">KieContainer</code>将使用新的项目版本。</p></strong></div><div class="section" title="2.12.7。分层ClassLoader"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1970"></a> 2.12.7。分层ClassLoader</strong></h3></div></div></div><p><strong>CompositeClassLoader不再使用。因为它一直是性能问题和错误的源头。现在使用传统的分层类加载器。根类加载器处于KieContext级别，每个名称空间有一个子类加载器。这样可以更轻松地添加和删除规则，但DRL文件中的命名空间之间现在不再存在引用。即，函数只能由声明它们的名称空间使用。建议在项目中使用静态Java方法，这对所有名称空间都是可见的。但是不能动态更新那些（与根KieContainer ClassLoader上的其他类一样）。</strong></p></div><div class="section" title="2.12.8。旧版API适配器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1975"></a> 2.12.8。旧版API适配器</strong></h3></div></div></div><p><strong>通过Maven依赖项“ knowledge-api-legacy5-adapter”仍可使用Drools和jBPM构建和运行5.x API。由于在6.0中部署的性质发生了显着变化，因此无法为KnowledgeAgent提供适配器桥。如果缺少任何其他方法或有问题，请打开JIRA，我们将修复6.1</strong></p></div><div class="section" title="2.12.9。KIE文档"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1980"></a> 2.12.9。KIE文档</strong></h3></div></div></div><p><strong>尽管添加了许多新文档来使用新的KIE API，但整个文档尚未更新。因此，将继续引用旧术语。提前致歉，感谢您的耐心配合。我们希望社区中的人们能够与我们一起为6.1更新整个文档</strong></p></div></div><div class="section" title="2.13。Drools 6.0.0中有哪些新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="drools.ReleaseNotesDrools.6.0.0"></a> 2.13。Drools 6.0.0中有哪些新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.13.1。PHREAK-惰性规则匹配算法"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1988"></a> 2.13.1。PHREAK-惰性规则匹配算法</strong></h3></div></div></div><p><strong>在Drools 6.0中完成的主要工作涉及新的PREAK算法。这是一种惰性算法，应可使Drools处理大量规则和事实。AngendaGroups现在可以帮助改善性能，因为只有在尝试触发规则时才对其进行评估。</strong></p><p><strong>PHREAK继续支持顺序模式，但现在允许“修改”。尽管顺序配置不存在“推论”，但由于规则被懒惰地评估，因此任何尚未评估的规则将由于“修改”而看到更新的数据。这更符合人们直观地认为顺序工作的方式。</strong></p><p><strong>已针对PHREAK调整了冲突解决顺序，现在按显着性然后按规则顺序进行了排序；根据文件中的规则位置。在Drools 6.0.0之前，在突出显示之后，它被认为是任意的。当KieModules和updateToVersion用于动态部署时，文件中的规则顺序将通过diff处理保留。</strong></p></div><div class="section" title="2.13.2。在被动模式下自动触发定时规则"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e1997"></a> 2.13.2。在被动模式下自动触发定时规则</strong></h3></div></div></div><p><strong>默认情况下，规则引擎在被动模式下运行（即：使用fireAllRules）时，除非再次调用fireAllRules，否则不会触发定时规则的结果。现在可以通过使用以下命令配置KieSession来更改此默认行为： <code class="code">TimedRuleExectionOption</code>如以下示例所示。</strong></p><div class="example"><strong><a id="d0e2005"></a><p class="title"><strong>示例2.13配置KieSession以自动执行定时规则</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExectionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, null);</code></pre></div></strong></div><strong><br class="example-break"><p>也可以对必须自动执行的定时规则进行更精细的控制。为此，必须设置一个<code class="code">FILTERED</code><code class="code">TimedRuleExectionOption</code>可以定义一个回调来过滤这些规则，如下面的示例所示。</p><div class="example"><a id="d0e2018"></a><p class="title"><strong>示例2.14配置过滤器以选择应自动执行哪些定时规则</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( new TimedRuleExectionOption.FILTERED(new TimedRuleExecutionFilter() {
    public boolean accept(Rule[] rules) {
        return rules[0].getName().equals("MyRule");
    }
}) );</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="2.13.3。表达计时器"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2023"></a> 2.13.3。表达计时器</strong></h3></div></div></div><p><strong>现在可以将间隔计时器的延迟和间隔定义为表达式而不是固定值。为此，必须将计时器声明为表达式一（用“ expr：”表示），如以下示例所示：</strong></p><div class="example"><strong><a id="d0e2028"></a><p class="title"><strong>示例2.15表达式计时器示例</strong></p><div class="example-contents"><pre><code class="language-java">declare Bean
    delay   : String = "30s"
    period  : long = 60000
end

rule "Expression timer"
    timer( expr: $d, $p )
when
    Bean( $d : delay, $p : period )
then
end</code></pre></div></strong></div><strong><br class="example-break"><p>在这种情况下，表达式$ d和$ p可以使用规则的模式匹配部分中定义的任何变量，并且可以是可以在一段时间内解析的任何String或可以在内部进行长时间转换的任何数值。代表以毫秒为单位的持续时间。</p><p>时间间隔和表达式计时器都可以具有3个可选参数，分别名为“开始”，“结束”和“重复限制”。当使用这些参数中的一个或多个时，计时器定义的第一部分必须后跟分号“;”。并且参数必须用逗号“，”分隔，如以下示例所示：</p><div class="example"><a id="d0e2037"></a><p class="title"><strong>示例2.16具有开始和结束的间隔计时器</strong></p><div class="example-contents"><pre><code class="language-java">timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)</code></pre></div></div><br class="example-break"><p>start和end参数的值可以是Date，代表Date的String或长整数，或者通常是任何Number，可以用以下转换在Java Date中进行转换：</p><pre><code class="language-java">new Date( ((Number) n).longValue() )</code></pre><p>相反，repeat-limit只能是整数，它定义计时器允许的最大重复次数。如果同时设置了end和repeat-limit参数，则当两者中的第一个匹配时，计时器将停止。</p><p>使用start参数意味着为计时器定义了一个阶段，其中阶段的开始由开始本身加上最终的延迟给出。换句话说，在这种情况下，有时会安排定时规则：</p><pre><code class="language-java">start + delay + n*period</code></pre><p>最多可重复限制时间，且不得迟于结束时间戳记（以先到者为准）。例如具有以下间隔计时器的规则</p><pre><code class="language-java">timer ( int: 30s 1m; start="3-JAN-2010" )</code></pre><p>排定在2010年1月3日午夜之后的每分钟30秒。这也意味着，例如，如果您在3-FEB-2010的午夜打开系统，则不会立即进行安排，但会保留计时器定义的阶段，因此将在30秒后第一次进行安排午夜。如果由于某种原因系统被暂停（例如，会话被序列化，然后在一段时间后反序列化），则该规则将仅计划一次以从丢失的激活中恢复（无论我们错过了多少激活），随后将再次计划该规则。与计时器的相位。</p></strong></div><div class="section" title="2.13.4。RuleFlowGroups和AgendaGroups合并"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2058"></a> 2.13.4。RuleFlowGroups和AgendaGroups合并</strong></h3></div></div></div><p><strong>这两个组已合并，现在RuleFlowGroups的行为与AgendaGroups相同。出于弃用的原因，保留了get方法，但是它们都返回相同的基础数据。当jBPM激活组时，它现在仅调用setFocus。一起使用RuleFlowGroups和AgendaGroups会继续导致错误。它还使代码库与PHREAK和将来计划的多核开发保持一致。</strong></p></div></div><div class="section" title="2.14。KIE Workbench 6.0.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="wb.ReleaseNotesWorkbench.6.0.0"></a> 2.14。KIE Workbench 6.0.0中的新功能和值得注意的功能</strong></h2></div></div></div><p><strong>使用名为UberFire的新基础项目对工作台进行了大修。UberFire受Eclipse的启发，为工作台提供了一个干净，可扩展和灵活的框架。最终结果不仅为我们的最终用户带来了更丰富的体验，而且我们现在可以使用干净的基于组件的体系结构更快地发展。如果您喜欢他的Workbench经验，则可以立即使用UberFire来构建自己的基于Web的仪表板和控制台。</strong></p><p><strong>除了迁移到UberFire之外，另一个最大的变化是从JCR迁移到Git。有一个实用程序项目可帮助迁移。Git是最具可伸缩性和功能最强大的源存储库，没有。JGit为Git提供了可靠的OSS实现。这解决了各种JCR实现的持续性能问题，一旦文件数量和版本数量变得过高，这些问题就会放慢速度。为了消除复杂性，已经有了很大的“低技术含量”驱动力。现在，所有内容都存储为文件，包括元数据。该数据库仅用于提供快速索引和搜索。因此，导入和导出都是所有标准Git，外部站点（例如GitHub）可用于交换存储库。</strong></p><p><strong>在5.x中，开发人员将使用自己的源存储库，然后通过团队提供程序推送JCR。该团队提供者功能不全，在Eclipse之外不可用。Git使我们的资源库可以处理任何现有的Git工具或团队提供者。虽然UI尚不支持，但会随着时间的推移添加它，但可以连接到存储库并标记和分支并还原内容。</strong></p><div class="figure"><strong><a id="d0e2073"></a><p class="title"><strong>图2.52。工作台</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/ReleaseNotes/kie-drools-wb.png" align="middle" alt="工作台"></div></div></strong></div><strong><br class="figure-break"><p>Guvnor品牌从其预期角色中泄漏了太多；例如决策表之类的创作隐喻，被视为Guvnor组件而不是Drools组件。Guvnor在5.x中使用的整体项目结构对此无济于事。在6.0版中，Guvnor的重点已缩小到封装UberFire插件集，这些插件提供了构建基于Web的IDE的基础。例如用于构建和部署的Maven集成，通过收件箱管理Maven存储库和活动通知。Drools和jBPM以Uberfire为基础构建工作台发行版，包括一组插件（例如Guvnor）以及自己的插件，用于决策表，指导编辑器，BPMN2设计器和人工任务。</p><p>“模型结构”图概述了新项目的结构。Drools工作台称为KIE-Drools-WB。 KIE-WB是结合了所有Guvnor，Drools和jBPM插件的uber工作台。由于jBPM-WB实际上并不存在，因此被KIE-WB冗余了，因此已被删除。</p><div class="figure"><a id="d0e2083"></a><p class="title"><strong>图2.53。模块结构</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/ReleaseNotes/kie-structure.png" align="middle" alt="模块结构"></div></div></div><br class="figure-break"><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>KIE Drools Workbench和KIE Workbench共享通用工作台功能的一组公共组件，例如项目导航，项目定义，基于Maven的项目，Maven Artifact存储库。在本文档中，将更详细地描述这些通用功能。</p></div><p></p><p>两个主要分布包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>KIE Drools工作台</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Drools编辑器，用于规则和辅助资产。</p></li><li class="listitem"><p>jBPM Designer，用于规则流和支持资产。</p></li></ul></div></li><li class="listitem"><p>KIE工作台</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Drools编辑器，用于规则和辅助资产。</p></li><li class="listitem"><p>jBPM Designer，用于BPMN2和支持资产。</p></li><li class="listitem"><p>jBPM控制台，运行时和人工任务支持。</p></li><li class="listitem"><p>jBPM表单生成器。</p></li><li class="listitem"><p>BAM。</p></li></ul></div></li></ul></div><p>工作台亮点：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>新的灵活的工作台环境，带有透视图和面板。</p></li><li class="listitem"><p>遵循KIE API的新打包和构建系统。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>基于Maven的项目。</p></li><li class="listitem"><p>Maven Artifact信息库取代了Global Area，并提供了完全依赖项支持。</p></li></ul></div></li><li class="listitem"><p>New Data Modeller取代了声明式事实模型编辑器；将Java类的创作带入创作环境。Java类被打包到项目中，并且可以在规则，流程等中使用，也可以在您自己的应用程序中外部使用。</p></li><li class="listitem"><p>虚拟文件系统用默认的基于Git的实现代替了JCR。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>基于默认Git的实现支持远程操作。</p></li><li class="listitem"><p>外部修改出现在工作台中。</p></li></ul></div></li><li class="listitem"><p>增量构建系统，几乎实时显示您的项目和资产的验证结果。</p></li></ul></div><p>编辑人员本身基本没有变化；但是，值得注意的是，导入已从程序包定义移至单个编辑器，因此您仅需要用于资产的导入类型，而无需整体上导入程序包。</p></strong></div><div class="section" title="2.15。集成6.0.0中的新功能和值得注意的功能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="kie.ReleaseNotesIntegration.6.0.0"></a> 2.15。集成6.0.0中的新功能和值得注意的功能</strong></h2></div></div></div><div class="section" title="2.15.1。CDI"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2161"></a> 2.15.1。CDI</strong></h3></div></div></div><p><strong>现在，CDI已紧密集成到KIE API中。它可以用来注入版本化的KieSession和KieBases。</strong></p><div class="figure"><strong><a id="d0e2166"></a><p class="title"><strong>图2.54。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("kbase1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.0")
private KieBase kbase1v10;

@Inject
@KBase("kbase1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.1")
private KieBase kbase1v10;</code></pre></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e2171"></a><p class="title"><strong>图2.55。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.0")
private KieSession ksessionv10;

@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.1")
private KieSession ksessionv11;</code></pre></div></div><br class="figure-break"></strong></div><div class="section" title="2.15.2。弹簧"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2176"></a> 2.15.2。弹簧</strong></h3></div></div></div><p><strong>Spring已进行了改进，现在已与KIE集成。 Spring可以用功能更强大的spring版本替换'kmodule.xml'。目的是与kmodule.xml保持一致</strong></p></div><div class="section" title="2.15.3。白羊座的蓝图"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2181"></a> 2.15.3。白羊座的蓝图</strong></h3></div></div></div><p><strong>现在也支持白羊座的蓝图，并遵循春季所做的工作。目的是与spring和kmodule.xml保持一致</strong></p></div><div class="section" title="2.15.4。准备好OSGi"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e2186"></a> 2.15.4。准备好OSGi</strong></h3></div></div></div><p><strong>所有模块都经过重构，以避免软件包拆分，这在5.x中是一个问题。测试已移至PAX。</strong></p></div></div></div><div class="chapter" title="第3章。相容性矩阵"><div class="titlepage"><div><div><h2 class="title"><strong><a id="compatibilityMatrix"></a>第3章。相容性矩阵</strong></h2></div></div></div><p><strong>从KIE 6.0开始，Drools（包括工作台），jBPM（包括设计器和控制台）和OptaPlanner遵循相同的版本编号。</strong></p></div></div><div class="part" title="第二部分IE"><div class="titlepage"><div><div><h1 class="title"><strong><a id="d0e2196"></a>第二部分IE</strong></h1></div></div></div><div class="partintro" title="IE"><div></div><p><strong>KIE是Drools和jBPM的共享核心。它为构建，部署和利用资源提供了统一的方法和编程模型。</strong></p><div class="toc"><p><strong><strong>目录</strong></strong></p><dl><dt><strong><span class="chapter"><a href="#KIEChapter">4。IE</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#KIEOverviewSection">4.1。总览</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#KIEAnatomySection">4.1.1。项目剖析</a></span></strong></dt><dt><strong><span class="section"><a href="#KIELifeCyclesSection">4.1.2。生命周期</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#BuildDeployUtilizeAndRunSection">4.2。构建，部署，利用和运行</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#KIEModuleIntroductionBuildingIntroductionSection">4.2.1。介绍</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEBuildingSection">4.2.2。建造</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEDeployingSection">4.2.3。部署中</a></span></strong></dt><dt><strong><span class="section"><a href="#KIERunningSection">4.2.4。跑步</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEDeployCheatSheets">4.2.5。安装和部署备忘单</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEExamplesSection">4.2.6。构建，部署和利用示例</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#KIESecuritySection">4.3。安全</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#SecurityManager">4.3.1。安全经理</a></span></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第四章IE"><div class="titlepage"><div><div><h2 class="title"><strong><a id="KIEChapter"></a>第四章IE</strong></h2></div></div></div><div class="toc"><dl><dt><strong><span class="section"><a href="#KIEOverviewSection">4.1。总览</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#KIEAnatomySection">4.1.1。项目剖析</a></span></strong></dt><dt><strong><span class="section"><a href="#KIELifeCyclesSection">4.1.2。生命周期</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#BuildDeployUtilizeAndRunSection">4.2。构建，部署，利用和运行</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#KIEModuleIntroductionBuildingIntroductionSection">4.2.1。介绍</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEBuildingSection">4.2.2。建造</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEDeployingSection">4.2.3。部署中</a></span></strong></dt><dt><strong><span class="section"><a href="#KIERunningSection">4.2.4。跑步</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEDeployCheatSheets">4.2.5。安装和部署备忘单</a></span></strong></dt><dt><strong><span class="section"><a href="#KIEExamplesSection">4.2.6。构建，部署和利用示例</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#KIESecuritySection">4.3。安全</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#SecurityManager">4.3.1。安全经理</a></span></strong></dt></dl></dd></dl></div><div class="section" title="4.1。总览"><div class="titlepage"><div><div><h2 class="title"><strong><a id="KIEOverviewSection"></a> 4.1。总览</strong></h2></div></div></div><div class="section" title="4.1.1。项目剖析"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEAnatomySection"></a> 4.1.1。项目剖析</strong></h3></div></div></div><p><strong>研究Drools和jBPM的集成知识解决方案的过程仅使用了“ droolsjbpm”组名。该名称遍布GitHub帐户和Maven POM。随着范围的扩大和新项目的推出，KIE被选为“知识就是一切”的缩写，作为新的小组名称。KIE名称也用于系统的共享方面。例如统一构建，部署和利用。</strong></p><p><strong>KIE当前包含以下子项目：</strong></p><div class="figure"><strong><a id="d0e2215"></a><p class="title"><strong>图4.1。KIE解剖</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/Overview/kie.png" alt="KIE解剖"></div></div></strong></div><strong><br class="figure-break"><p>OptaPlanner是一种本地搜索和优化工具，它是从Drools Planner衍生出来的，现在是Drools和jBPM的顶级项目。这是自然发展的过程，因为Optaplanner拥有强大的Drools集成，但长期以来一直独立于Drools。</p><p>收购Polymita以及其他功能后，将提供功能强大的Dashboard Builder，它提供了强大的报告功能。Dashboard Builder当前是一个临时名称，在6.0版本之后，将选择一个新名称。Dashboard Builder完全独立于Drools和jBPM，并且将在JBoss的许多项目中使用，并且希望在JBoss之外进行：)</p><p>UberFire是新的基础工作台项目，从头开始进行重写。UberFire提供了类似于Eclipse的工作台功能，并带有来自插件的面板和透视图。该项目独立于Drools和jBPM，任何人都可以将其用作构建灵活而强大的工作台的基础。UberFire将用于整个JBoss的控制台和工作台开发。</p><p>可以确定的是Guvnor品牌从其预期角色中泄漏了太多；例如决策表之类的创作隐喻，被视为Guvnor组件而不是Drools组件。Guvnor在5.x中使用的整体项目结构对此无济于事。在6.0中，Guvnor的重点已缩小到封装UberFire插件集，这些插件提供了构建基于Web的IDE的基础。例如用于构建和部署的Maven集成，通过收件箱管理Maven存储库和活动通知。Drools和jBPM以Uberfire为基础构建工作台发行版，包括一组插件（例如Guvnor）以及自己的插件，用于决策表，指导编辑器，BPMN2设计器和人工任务。Drools工作台称为Drools-WB。 KIE-WB是结合了所有Guvnor，Drools和jBPM插件的uber工作台。由于jBPM-WB实际上并不存在，因此被KIE-WB冗余了，因此已被删除。</p><p></p></strong></div><div class="section" title="4.1.2。生命周期"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIELifeCyclesSection"></a> 4.1.2。生命周期</strong></h3></div></div></div><p><strong>无论是Drools还是jBPM，使用KIE系统的不同方面或生命周期通常可以分为以下几类：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>作者</strong></span>
        </strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>使用UI隐喻编写知识，例如：DRL，BPMN2，决策表，类模型。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>建立</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>将创作的知识构建到可部署的单元中。</strong></p></li><li class="listitem"><p><strong>对于KIE，此单位为JAR。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>测试</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>在将KIE Knowedge部署到应用程序之前对其进行测试。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>部署</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>将单元部署到应用程序可以利用（消费）它们的位置。</strong></p></li><li class="listitem"><p><strong>KIE使用Maven样式存储库。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>利用</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>加载JAR以提供应用程序可以与之交互的KIE会话（KieSession）。</strong></p></li><li class="listitem"><p><strong>KIE在运行时通过KIE容器（KieContainer）公开JAR。</strong></p></li><li class="listitem"><p><strong>从KieContainer创建供运行时交互的KieSessions。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>跑</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>通过API与KieSession进行系统交互。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>工作</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>用户通过命令行或UI与KieSession进行交互。</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>管理</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>管理任何KieSession或KieContainer。</strong></p></li></ul></div></li></ul></div></div></div><div class="section" title="4.2。构建，部署，利用和运行"><div class="titlepage"><div><div><h2 class="title"><strong><a id="BuildDeployUtilizeAndRunSection"></a> 4.2。构建，部署，利用和运行</strong></h2></div></div></div><div class="section" title="4.2.1。介绍"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEModuleIntroductionBuildingIntroductionSection"></a> 4.2.1。介绍</strong></h3></div></div></div><p><strong>6.0引入了一种新的配置和约定方法来构建知识库，而不是在5.x中使用程序化生成器方法。该构建器仍可使用，因为它已用于工具集成。</strong></p><p><strong>现在，Building使用Maven，并与Maven实践保持一致。KIE项目或模块仅仅是Maven Java项目或模块；以及其他元数据文件META-INF / kmodule.xml。kmodule.xml文件是描述符，用于选择知识库的资源并配置这些知识库和会话。通过Spring和OSGi BluePrints还提供了其他XML支持。</strong></p><p><strong>尽管标准Maven可以构建和打包KIE资源，但它不会在构建时提供验证。有一个Maven插件，建议使用它来进行构建时间验证。该插件还生成许多类，从而使运行时加载也更快。</strong></p><p><strong>屏幕截图中说明了示例项目布局和Maven POM描述符。</strong></p><div class="figure"><strong><a id="d0e2327"></a><p class="title"><strong>图4.2。示例项目布局和Maven POM</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/defaultkiesession.png" alt="示例项目布局和Maven POM"></div></div></div></strong></div><strong><br class="figure-break"><p>KIE使用默认值来最大程度地减少配置量。空的kmodule.xml是最简单的配置。必须始终有一个kmodule.xml文件（即使为空），因为该文件用于发现JAR及其内容。</p><p>Maven可以“ mvn install”将KieModule部署到本地计算机，本地计算机上的所有其他应用程序都可以使用它。或者它可以“ mvn deploy”将KieModule推送到远程Maven存储库。构建应用程序将拉入KieModule并在此过程中填充本地Maven存储库。</p><div class="figure"><a id="d0e2338"></a><p class="title"><strong>图4.3。示例项目布局和Maven POM</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/maven.png" alt="示例项目布局和Maven POM"></div></div></div></div><br class="figure-break"><p>可以通过以下两种方式之一部署JAR。可以像添加Maven依赖列表中的任何其他JAR一样，添加到类路径中，也可以在运行时动态加载它们。KIE将扫描类路径以找到所有带有kmodule.xml的JAR。每个找到的JAR都由KieModule接口表示。术语类路径KieModule和动态KieModule用于指两种加载方法。动态模块支持并行版本控制，而类路径模块则不支持。此外，一旦模块位于类路径上，就不能动态加载其他版本。</p><p>API的详细参考资料包含在下一部分中，不耐烦的可以直接跳到示例部分，这在不同的用例上是不言而喻的。</p></strong></div><div class="section" title="4.2.2。建造"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEBuildingSection"></a> 4.2.2。建造</strong></h3></div></div></div><div class="figure"><strong><a id="d0e2352"></a><p class="title"><strong>图4.4。 org.kie.api.core.builder</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/builder.png" alt="org.kie.api.core.builder"></div></div></strong></div><strong><br class="figure-break"><div class="section" title="4.2.2.1。创建和构建Kie项目"><div class="titlepage"><div><div><h4 class="title"><a id="creatingAndBuildingAKieProject"></a> 4.2.2.1。创建和构建Kie项目</h4></div></div></div><p>Kie Project具有普通Maven项目的结构，唯一的特点是包括以声明方式定义kmodule.xml文件。 <code class="code">KieBase</code>和<code class="code">KieSession</code>可以从中创建的。该文件必须放置在Maven项目的resources / META-INF文件夹中，而所有其他Kie构件（例如DRL或Excel文件）必须存储在resources文件夹或其下的任何其他子文件夹中。</p><p>由于已经为所有配置方面提供了有意义的默认值，因此最简单的kmodule.xml文件只能包含一个空的kmodule标记，如下所示：</p><div class="example"><a id="d0e2372"></a><p class="title"><strong>示例4.1空的kmodule.xml文件</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"/&gt;</code></pre></div></div><br class="example-break"><p>这样，kmodule将包含一个默认值<code class="code">KieBase</code> 。存储在资源文件夹或其任何子文件夹下的所有Kie资产将被编译并添加到其中。要触发这些工件的构建，只需创建一个<code class="code">KieContainer</code>为他们。</p><div class="figure"><a id="d0e2385"></a><p class="title"><strong>图4.5。KieContainer</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieContainer.png" alt="KieContainer"></div></div></div><br class="figure-break"><p>对于这种简单的情况，只需创建一个<code class="code">KieContainer</code>从类路径读取要构建的文件：</p><div class="example"><a id="d0e2396"></a><p class="title"><strong>示例4.2从类路径创建一个KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();</code></pre></div></div><br class="example-break"><p><code class="code">KieServices</code>是可以从其中访问所有Kie构建和运行时设施的界面：</p><div class="figure"><a id="d0e2405"></a><p class="title"><strong>图4.6。KieServices</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieServices.png" alt="KieServices"></div></div></div><br class="figure-break"><p>这样，所有Java源代码和Kie资源都被编译并部署到KieContainer中，从而使其内容可在运行时使用。</p></div><div class="section" title="4.2.2.2。kmodule.xml文件"><div class="titlepage"><div><div><h4 class="title"><a id="theKmoduleXmlFile"></a> 4.2.2.2。kmodule.xml文件</h4></div></div></div><p>如前一节所述，kmodule.xml文件是可以声明性地配置<code class="code">KieBase</code> （s）和<code class="code">KieSession</code>可以从KIE项目中创建的内容。</p><p>特别是<code class="code">KieBase</code>是所有应用程序知识定义的存储库。它将包含规则，流程，功能和类型模型。的<code class="code">KieBase</code>本身不包含数据；而是从<code class="code">KieBase</code>可以在其中插入数据以及可以从中启动流程实例。创建<code class="code">KieBase</code>可能很繁重，而会话创建非常简单，因此建议<code class="code">KieBase</code>尽可能缓存以允许重复的会话创建。但是，最终用户通常不必担心，因为该缓存机制已经由<code class="code">KieContainer</code> 。</p><div class="figure"><a id="d0e2444"></a><p class="title"><strong>图4.7。凯基</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBase.png" alt="凯基"></div></div></div><br class="figure-break"><p>反之<code class="code">KieSession</code>存储并在运行时数据上执行。它是从<code class="code">KieBase</code>或更容易地可以直接从<code class="code">KieContainer</code>如果已在kmodule.xml文件中定义</p><div class="figure"><a id="d0e2461"></a><p class="title"><strong>图4.8。KieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieSession.png" alt="KieSession"></div></div></div><br class="figure-break"><p>kmodule.xml允许定义和配置一个或多个<code class="code">KieBase</code> s和每个<code class="code">KieBase</code>所有不同<code class="code">KieSession</code>可以从中创建的，如以下示例所示：</p><div class="example"><a id="d0e2478"></a><p class="title"><strong>示例4.3一个样本kmodule.xml文件</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;configuration&gt;
    &lt;property key="drools.evaluator.supersetOf" value="org.mycompany.SupersetOfEvaluatorDefinition"/&gt;
  &lt;/configuration&gt;
  &lt;kbase name="KBase1" default="true" eventProcessingMode="cloud" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg1"&gt;
    &lt;ksession name="KSession2_1" type="stateful" default="true"/&gt;
    &lt;ksession name="KSession2_2" type="stateless" default="false" beliefSystem="jtms"/&gt;
  &lt;/kbase&gt;
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    &lt;ksession name="KSession3_1" type="stateful" default="false" clockType="realtime"&gt;
      &lt;fileLogger file="drools.log" threaded="true" interval="10"/&gt;
      &lt;workItemHandlers&gt;
        &lt;workItemHandler name="name" type="org.domain.WorkItemHandler"/&gt;
      &lt;/workItemHandlers&gt;
      &lt;listeners&gt;
        &lt;ruleRuntimeEventListener type="org.domain.RuleRuntimeListener"/&gt;
        &lt;agendaEventListener type="org.domain.FirstAgendaListener"/&gt;
        &lt;agendaEventListener type="org.domain.SecondAgendaListener"/&gt;
        &lt;processEventListener type="org.domain.ProcessListener"/&gt;
      &lt;/listeners&gt;
    &lt;/ksession&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></div><br class="example-break"><p>此处的<configuration>代码包含键值对列表，这些键值对是用于配置<code class="code">KieBase</code>的建设过程。例如，此样本kmodule.xml文件定义了一个名为的附加自定义运算符<code class="code">supersetOf</code>并由<code class="code">org.mycompany.SupersetOfEvaluatorDefinition</code>类。</configuration></p><p>在此之后2 <code class="code">KieBase</code>已定义，可以实例2种不同类型的<code class="code">KieSession</code> s从第一个开始，而只有一个从第二个开始。可以在kbase标记上定义的属性及其含义和默认值的列表如下：</p><div class="table"><a id="d0e2502"></a><p class="title"><strong>表4.1。 kbase属性</strong></p><div class="table-contents"><table border="1" summary="kbase Attributes"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性名称</th><th align="center">默认值</th><th align="center">允许值</th><th align="center">含义</th></tr></thead><tbody><tr><td>名称</td><td>没有</td><td>任何</td><td>从KieContainer检索此KieBase的名称。这是唯一的必需属性。</td></tr><tr><td>包括</td><td>没有</td><td>任何用逗号分隔的列表</td><td>以逗号分隔的列表包含在此kmodule中的其他KieBase。所有这些KieBases的工件也将包括在这一部分中。</td></tr><tr><td>包装</td><td>所有</td><td>任何用逗号分隔的列表</td><td>默认情况下，任何级别的资源文件夹下的所有Drools工件都包含在KieBase中。该属性允许将要在此KieBase中编译的工件限制为仅属于软件包列表的工件。</td></tr><tr><td>默认</td><td>假</td><td>真假</td><td>定义此KieBase是否为该模块的默认模块，因此可以从KieContainer创建它而无需传递任何名称。每个模块中最多可以有一个默认的KieBase。</td></tr><tr><td>等于行为</td><td>身份</td><td>身份平等</td><td>定义将新事实插入工作记忆时的Drools行为。有了身份，它总是创建一个新的FactHandle，除非工作存储器中还没有相同的对象，而只有当新插入的对象与现有事实不相等（根据其相等方法）时，才具有相等性。</td></tr><tr><td>eventProcessingMode</td><td>云</td><td>云，流</td><td>在云模式下编译时，KieBase将事件视为正常事实，而在流模式下，则允许对事件进行时间推理。</td></tr><tr><td>声明性议程</td><td>残障人士</td><td>禁用启用</td><td>定义是否启用声明性议程。</td></tr></tbody></table></div></div><br class="table-break"><p>同样，ksession标记的所有属性（当然，名称除外）也都具有有意义的默认值。下表列出并描述了它们：</p><div class="table"><a id="d0e2582"></a><p class="title"><strong>表4.2。 ksession属性</strong></p><div class="table-contents"><table border="1" summary="ksession Attributes"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">属性名称</th><th align="center">默认值</th><th align="center">允许值</th><th align="center">含义</th></tr></thead><tbody><tr><td>名称</td><td>没有</td><td>任何</td><td>此KieSession的唯一名称。用于从KieContainer中获取KieSession。这是唯一的必需属性。</td></tr><tr><td>类型</td><td>有状态的</td><td>有状态的，无状态的</td><td>有状态会话允许迭代地使用工作内存，而无状态会话是使用提供的数据集一次性执行工作内存。</td></tr><tr><td>默认</td><td>假</td><td>真假</td><td>定义此KieSession是否是该模块的默认值，因此可以从KieContainer创建它而无需传递任何名称。在每个模块中，每种类型最多可以有一个默认的KieSession。</td></tr><tr><td>clockType</td><td>即时的</td><td>实时，伪</td><td>定义事件时间戳是由系统时钟还是由应用程序控制的伪时钟确定的。该时钟对于单元测试时间规则特别有用。</td></tr><tr><td>信仰体系</td><td>简单</td><td>简单，可行，可行</td><td>定义KieSession使用的信念系统的类型。</td></tr></tbody></table></div></div><br class="table-break"><p>如先前的kmodule.xml示例中概述的那样，也可以在每个声明性地创建<code class="code">KieSession</code>一个文件（或控制台）记录器，一个或多个<code class="code">WorkItemHandler</code>和一些可以为3种不同类型的侦听器：ruleRuntimeEventListener，议程事件侦听器和processEventListener</p><p>像先前示例中那样定义了一个kmodule.xml，现在可以使用它们的名称从KieContainer中简单地检索KieBases和KieSessions。</p><div class="example"><a id="d0e2652"></a><p class="title"><strong>示例4.4从KieContainer检索KieBases和KieSession</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();

KieBase kBase1 = kContainer.getKieBase("KBase1");
KieSession kieSession1 = kContainer.newKieSession("KSession2_1");
StatelessKieSession kieSession2 = kContainer.newStatelessKieSession("KSession2_2");</code></pre></div></div><br class="example-break"><p>必须注意的是，由于KSession2_1和KSession2_2是2种不同的类型（第一种是有状态的，而第二种是无状态的），因此有必要在KSession2_1和KSession2_2上调用2种不同的方法。 <code class="code">KieContainer</code>根据其声明的类型。如果类型<code class="code">KieSession</code>要求<code class="code">KieContainer</code>与kmodule.xml文件中声明的不对应<code class="code">KieContainer</code>会抛出一个<code class="code">RuntimeException</code> 。也因为<code class="code">KieBase</code>和一个<code class="code">KieSession</code>已被标记为默认值，是否有可能从<code class="code">KieContainer</code>没有传递任何名字。</p><div class="example"><a id="d0e2683"></a><p class="title"><strong>示例4.5从KieContainer检索默认的KieBases和KieSessions</strong></p><div class="example-contents"><pre><code class="language-java">KieContainer kContainer = ...

KieBase kBase1 = kContainer.getKieBase(); // returns KBase1
KieSession kieSession1 = kContainer.newKieSession(); // returns KSession2_1</code></pre></div></div><br class="example-break"><p>由于Kie项目也是Maven项目，因此使用pom.xml文件中声明的groupId，artifactId和版本来生成<code class="code">ReleaseId</code>在您的应用程序中唯一标识此项目。这允许通过简单地传递项目从项目创建新的KieContainer <code class="code">ReleaseId</code>到<code class="code">KieServices</code> 。</p><div class="example"><a id="d0e2699"></a><p class="title"><strong>示例4.6通过ReleaseId创建现有项目的KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "myartifact", "1.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );</code></pre></div></div><br class="example-break"></div><div class="section" title="4.2.2.3。用Maven构建"><div class="titlepage"><div><div><h4 class="title"><a id="buildingWithMaven"></a> 4.2.2.3。用Maven构建</h4></div></div></div><p>Maven的KIE插件可确保对工件资源进行验证和预编译，建议始终使用该资源。要使用该插件，只需将其添加到Maven pom.xml的build部分，并通过使用打包将其激活<code class="code">kjar</code> 。
     </p><div class="example"><a id="d0e2712"></a><p class="title"><strong>示例4.7将KIE插件添加到Maven pom.xml并激活它</strong></p><div class="example-contents"><pre><code class="language-xml">
  &lt;packaging&gt;kjar&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.kie&lt;/groupId&gt;
        &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;6.5.0.Final&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;        
      </code></pre></div></div><br class="example-break"><p>该插件附带了对所有Drools / jBPM知识资源的支持。但是，如果您在Java类中使用特定的KIE注释，例如<code class="code">@kie.api.Position</code> ，您将需要在<code class="code">kie-api</code>进入您的项目。我们建议对所有其他KIE依赖项使用提供的范围。这样，kjar尽可能保持轻量级，而不依赖于任何特定的KIE版本。
    </p><p>构建不带Maven插件的KIE模块会将所有资源照原样复制到生成的JAR中。当运行时加载该JAR时，它将尝试构建所有资源。如果存在编译问题，它将返回空KieContainer。它还将编译开销推到了运行时。通常不建议这样做，应该始终使用Maven插件。</p></div><div class="section" title="4.2.2.4。以编程方式定义KieModule"><div class="titlepage"><div><div><h4 class="title"><a id="definingAKieModuleProgrammatically"></a> 4.2.2.4。以编程方式定义KieModule</h4></div></div></div><p>也可以定义<code class="code">KieBase</code>和<code class="code">KieSession</code>通过编程方式属于KieModule而不是kmodule.xml文件中的声明性定义。相同的编程API还允许显式添加包含Kie工件的文件，而不是自动从项目的resources文件夹中读取它们。为此，有必要创建一个<code class="code">KieFileSystem</code> ，一种虚拟文件系统，并将项目中包含的所有资源添加到其中。</p><div class="figure"><a id="d0e2741"></a><p class="title"><strong>图4.9。KieFileSystem</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieFileSystem.png" alt="KieFileSystem"></div></div></div><br class="figure-break"><p>像所有其他Kie核心组件一样，您可以获取<code class="code">KieFileSystem</code>来自<code class="code">KieServices</code> 。必须将kmodule.xml配置文件添加到文件系统。这是必须执行的步骤。Kie还提供了便捷的流利API，由<code class="code">KieModuleModel</code> ，以编程方式创建此文件。</p><div class="figure"><a id="d0e2758"></a><p class="title"><strong>图4.10。KieModuleModel</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieModuleModel.png" alt="KieModuleModel"></div></div></div><br class="figure-break"><p>要在实践中做到这一点，有必要创建一个<code class="code">KieModuleModel</code>来自<code class="code">KieServices</code> ，使用所需的配置<code class="code">KieBase</code>和<code class="code">KieSession</code> ，将其转换为XML并将XML添加到<code class="code">KieFileSystem</code> 。以下示例显示了此过程：</p><div class="example"><a id="d0e2781"></a><p class="title"><strong>示例4.8以编程方式创建kmodule.xml并将其添加到KieFileSystem</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieModuleModel kieModuleModel = kieServices.newKieModuleModel();

KieBaseModel kieBaseModel1 = kieModuleModel.newKieBaseModel( "KBase1 ")
        .setDefault( true )
        .setEqualsBehavior( EqualityBehaviorOption.EQUALITY )
        .setEventProcessingMode( EventProcessingOption.STREAM );

KieSessionModel ksessionModel1 = kieBaseModel1.newKieSessionModel( "KSession1" )
        .setDefault( true )
        .setType( KieSessionModel.KieSessionType.STATEFUL )
        .setClockType( ClockTypeOption.get("realtime") );

KieFileSystem kfs = kieServices.newKieFileSystem();
kfs.writeKModuleXML(kieModuleModel.toXML());</code></pre></div></div><br class="example-break"><p>此时，还需要添加<code class="code">KieFileSystem</code> ，通过其流畅的API，所有其他组成项目的Kie工件。这些工件必须添加到相应的常规Maven项目的相同位置。</p><div class="example"><a id="d0e2791"></a><p class="title"><strong>示例4.9将Kie工件添加到KieFileSystem</strong></p><div class="example-contents"><pre><code class="language-java">KieFileSystem kfs = ...
kfs.write( "src/main/resources/KBase1/ruleSet1.drl", stringContainingAValidDRL )
        .write( "src/main/resources/dtable.xls",
                kieServices.getResources().newInputStreamResource( dtableFileStream ) );</code></pre></div></div><br class="example-break"><p>此示例说明可以将Kie工件既添加为纯字符串也添加为<code class="code">Resource</code> s。在后一种情况下<code class="code">Resource</code>可以由创建<code class="code">KieResources</code>工厂，也由<code class="code">KieServices</code> 。的<code class="code">KieResources</code>提供了许多方便的工厂方法来转换<code class="code">InputStream</code> ， 一种<code class="code">URL</code> ， 一种<code class="code">File</code>或<code class="code">String</code>代表文件系统到<code class="code">Resource</code>可以由<code class="code">KieFileSystem</code> 。</p><div class="figure"><a id="d0e2831"></a><p class="title"><strong>图4.11。Kie资源</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieResources.png" alt="Kie资源"></div></div></div><br class="figure-break"><p>通常情况下， <code class="code">Resource</code>可以从用于将其添加到<code class="code">KieFileSystem</code> 。但是，也可能不遵循有关文件扩展名的Kie约定，而是明确分配特定的<code class="code">ResourceType</code>到一个<code class="code">Resource</code>如下所示：</p><div class="example"><a id="d0e2851"></a><p class="title"><strong>示例4.10创建和添加具有显式类型的资源</strong></p><div class="example-contents"><pre><code class="language-java">KieFileSystem kfs = ...
kfs.write( "src/main/resources/myDrl.txt",
           kieServices.getResources().newInputStreamResource( drlStream )
                      .setResourceType(ResourceType.DRL) );</code></pre></div></div><br class="example-break"><p>将所有资源添加到<code class="code">KieFileSystem</code>并通过传递<code class="code">KieFileSystem</code>到一个<code class="code">KieBuilder</code></p><div class="figure"><a id="d0e2866"></a><p class="title"><strong>图4.12。KieBuilder</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBuilder.png" alt="KieBuilder"></div></div></div><br class="figure-break"><p>当一个内容<code class="code">KieFileSystem</code>成功构建，结果<code class="code">KieModule</code>自动添加到<code class="code">KieRepository</code> 。的<code class="code">KieRepository</code>是一个单例，充当所有可用资源的存储库<code class="code">KieModule</code> s。</p><div class="figure"><a id="d0e2889"></a><p class="title"><strong>图4.13。Kie资料库</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRepository.png" alt="Kie资料库"></div></div></div><br class="figure-break"><p>之后，可以通过创建<code class="code">KieServices</code>一个新的<code class="code">KieContainer</code>为了那个原因<code class="code">KieModule</code>使用其<code class="code">ReleaseId</code> 。但是，由于在这种情况下<code class="code">KieFileSystem</code>不包含任何pom.xml文件（可以使用<code class="code">KieFileSystem.writePomXML</code>方法），Kie无法确定<code class="code">ReleaseId</code>的<code class="code">KieModule</code>并为其分配一个默认值。这个预设<code class="code">ReleaseId</code>可以从<code class="code">KieRepository</code>并用来识别<code class="code">KieModule</code>在 - 的里面<code class="code">KieRepository</code>本身。以下示例显示了整个过程。</p><div class="example"><a id="d0e2933"></a><p class="title"><strong>示例4.11构建KieFileSystem的内容并创建KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieFileSystem kfs = ...
kieServices.newKieBuilder( kfs ).buildAll();
KieContainer kieContainer = kieServices.newKieContainer(kieServices.getRepository().getDefaultReleaseId());</code></pre></div></div><br class="example-break"><p>在这一点上有可能<code class="code">KieBase</code>并创建新<code class="code">KieSession</code>从这个<code class="code">KieContainer</code>与a情况完全相同<code class="code">KieContainer</code>直接从类路径创建。</p><p>最佳做法是检查编译结果。的<code class="code">KieBuilder</code>报告3种不同严重程度的编译结果：ERROR，WARNING和INFO。 ERROR表示项目的编译失败，如果不是<code class="code">KieModule</code>产生了什么也没有添加到<code class="code">KieRepository</code> 。警告和信息结果可以忽略，但可以检查。</p><div class="example"><a id="d0e2963"></a><p class="title"><strong>示例4.12检查编译没有产生任何错误</strong></p><div class="example-contents"><pre><code class="language-java">KieBuilder kieBuilder = kieServices.newKieBuilder( kfs ).buildAll();
assertEquals( 0, kieBuilder.getResults().getMessages( Message.Level.ERROR ).size() );</code></pre></div></div><br class="example-break"></div><div class="section" title="4.2.2.5。更改默认构建结果的严重性"><div class="titlepage"><div><div><h4 class="title"><a id="changingTheDefaultBuildResultSeverity"></a> 4.2.2.5。更改默认构建结果的严重性</h4></div></div></div><p>在某些情况下，可以更改某种生成结果的默认严重性。例如，将与现有规则同名的新规则添加到程序包时，默认行为是用新规则替换旧规则，并将其报告为INFO。对于大多数用例来说，这可能是理想的选择，但是在某些部署中，用户可能希望阻止规则更新并将其报告为错误。</p><p>可以通过API调用，系统属性或配置文件来更改结果类型的默认严重性，就像在Drools中的其他任何选项一样进行配置。从该版本开始，Drools支持规则更新和功能更新的可配置结果严重性。要使用系统属性或配置文件对其进行配置，用户必须使用以下属性：</p><div class="example"><a id="d0e2975"></a><p class="title"><strong>示例4.13使用属性设置严重性</strong></p><div class="example-contents"><pre><code class="no-highlight">// sets the severity of rule updates
drools.kbuilder.severity.duplicateRule = &lt;INFO|WARNING|ERROR&gt;
// sets the severity of function updates
drools.kbuilder.severity.duplicateFunction = &lt;INFO|WARNING|ERROR&gt;</code></pre></div></div><br class="example-break"></div></strong></div><div class="section" title="4.2.3。部署中"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEDeployingSection"></a> 4.2.3。部署中</strong></h3></div></div></div><div class="section" title="4.2.3.1。凯基"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e2984"></a> 4.2.3.1。凯基</strong></h4></div></div></div><p><strong>的<code class="code">KieBase</code>是所有应用程序知识定义的存储库。它将包含规则，流程，功能和类型模型。的<code class="code">KieBase</code>本身不包含数据；而是从<code class="code">KieBase</code>可以在其中插入数据以及可以从中启动流程实例。的<code class="code">KieBase</code>可以从<code class="code">KieContainer</code>包含<code class="code">KieModule</code>在哪里<code class="code">KieBase</code>已经定义。</strong></p><div class="figure"><strong><a id="d0e3010"></a><p class="title"><strong>图4.14。凯基</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieBase.png" alt="凯基"></div></div></strong></div><strong><br class="figure-break"><p>有时，例如在OSGi环境中， <code class="code">KieBase</code>需要解析默认类加载器中没有的类型。在这种情况下，有必要创建一个<code class="code">KieBaseConfiguration</code>用一个额外的类加载器，并将其传递给<code class="code">KieContainer</code>当创建一个新的<code class="code">KieBase</code>从中。</p><div class="example"><a id="d0e3030"></a><p class="title"><strong>示例4.14使用自定义的ClassLoader创建新的KieBase</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieBaseConfiguration kbaseConf = kieServices.newKieBaseConfiguration( null, MyType.class.getClassLoader() );
KieBase kbase = kieContainer.newKieBase( kbaseConf );</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.3.2。KieSession和KieBase修改"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3035"></a> 4.2.3.2。KieSession和KieBase修改</strong></h4></div></div></div><p><strong>KieSessions将在“运行”部分中详细讨论。的<code class="code">KieBase</code>创建并返回<code class="code">KieSession</code>对象，并且可以选择保留对这些对象的引用。什么时候<code class="code">KieBase</code>会发生修改，这些修改将应用于会话中的数据。此引用是弱引用，也是可选的，由布尔标志控制。</strong></p></div><div class="section" title="4.2.3.3。KieScanner"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3049"></a> 4.2.3.3。KieScanner</strong></h4></div></div></div><p><strong>的<code class="code">KieScanner</code>允许持续监视您的Maven存储库以检查是否已安装新版本的Kie项目。新版本已部署在<code class="code">KieContainer</code>包装那个项目。使用<code class="code">KieScanner</code>要求kie-ci.jar位于类路径上。</strong></p><div class="figure"><strong><a id="d0e3063"></a><p class="title"><strong>图4.15。KieScanner</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieScanner.png" alt="KieScanner"></div></div></strong></div><strong><br class="figure-break"><p>一种<code class="code">KieScanner</code>可以在<code class="code">KieContainer</code>如以下示例所示。</p><div class="example"><a id="d0e3077"></a><p class="title"><strong>示例4.15在KieContainer上注册并启动KieScanner</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "myartifact", "1.0-SNAPSHOT" );
KieContainer kContainer = kieServices.newKieContainer( releaseId );
KieScanner kScanner = kieServices.newKieScanner( kContainer );

// Start the KieScanner polling the Maven repository every 10 seconds
kScanner.start( 10000L );</code></pre></div></div><br class="example-break"><p>在这个例子中<code class="code">KieScanner</code>配置为以固定的时间间隔运行，但也可以通过调用以下命令按需运行<code class="code">scanNow()</code>方法就可以了。如果<code class="code">KieScanner</code>在Maven存储库中找到该用户使用的Kie项目的更新版本<code class="code">KieContainer</code>它会自动下载新版本并触发新项目的增量构建。至此，现有<code class="code">KieBase</code>和<code class="code">KieSession</code>在的控制之下<code class="code">KieContainer</code>将会自动升级-特别是那些<code class="code">KieBase</code>由获得<code class="code">getKieBase()</code>与他们相关<code class="code">KieSession</code> s，以及任何<code class="code">KieSession</code>直接获得<code class="code">KieContainer.newKieSession()</code>因此参考默认<code class="code">KieBase</code> 。此外，从现在开始，所有新<code class="code">KieBase</code>和<code class="code">KieSession</code>以此创建<code class="code">KieContainer</code>将使用新的项目版本。请注意任何现有的<code class="code">KieBase</code>通过以下方式获得<code class="code">newKieBase()</code>在KieScanner升级之前，及其任何相关内容<code class="code">KieSession</code> s，不会自动升级；这是因为<code class="code">KieBase</code>通过获得<code class="code">newKieBase()</code>不受...的直接控制<code class="code">KieContainer</code> 。
    </p><p>的<code class="code">KieScanner</code>仅当使用SNAPSHOT，版本范围，最新或发布设置时，才会提取对已部署jar的更改。固定版本不会在运行时自动更新。</p></strong></div><div class="section" title="4.2.3.4。Maven版本和依赖项"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3155"></a> 4.2.3.4。Maven版本和依赖项</strong></h4></div></div></div><p><strong>Maven支持多种机制来管理应用程序中的版本控制和依赖性。可以使用特定的版本号发布模块，也可以使用SNAPSHOT后缀。依赖项可以指定要使用的版本范围，也可以利用SNAPSHOT机制。</strong></p><p><strong>StackOverflow为此提供了一个很好的描述，下面转载。</strong></p><p><strong><a class="link" href="http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency">http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency</a></strong></p><p><strong>如果您始终想使用最新版本，则Maven有两个关键字可以用作版本范围的替代。您应该谨慎使用这些选项，因为您将不再控制所使用的插件/依赖项。</strong></p><p><strong>当您依赖插件或依赖项时，可以使用LATEST或RELEASE的版本值。 LATEST是指特定工件的最新发行版本或快照版本，是特定存储库中最新部署的工件。RELEASE是指存储库中的最后一个非快照版本。通常，设计依赖工件非特定版本的软件并不是最佳实践。如果您正在开发软件，则可能希望使用RELEASE或LATEST作为便利，以便在发行新版本的第三方库时不必更新版本号。发布软件时，应始终确保您的项目依赖于特定版本，以减少构建或项目受到不受您控制的软件版本影响的机会。谨慎使用LATEST和RELEASE。</strong></p><p><strong>有关更多详细信息，请参见Maven书籍的POM语法部分。</strong></p><p><strong><a class="link" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html</a></strong></p><p><strong><a class="link" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html</a></strong></p><p><strong>这是说明各种选项的示例。在Maven存储库中，com.foo:my-foo具有以下元数据：</strong></p><pre><code class="language-xml">&lt;metadata&gt;
  &lt;groupId&gt;com.foo&lt;/groupId&gt;
  &lt;artifactId&gt;my-foo&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;versioning&gt;
    &lt;release&gt;1.1.1&lt;/release&gt;
    &lt;versions&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;version&gt;1.0.1&lt;/version&gt;
      &lt;version&gt;1.1&lt;/version&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
      &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/versions&gt;
    &lt;lastUpdated&gt;20090722140000&lt;/lastUpdated&gt;
  &lt;/versioning&gt;
&lt;/metadata&gt;</code></pre><p><strong>如果需要依赖该工件，则可以使用以下选项（当然可以指定其他版本范围，只在此处显示相关的版本）：声明一个确切的版本（将始终解析为1.0.1）：</strong></p><pre><code class="no-highlight">&lt;version&gt;[1.0.1]&lt;/version&gt;</code></pre><p><strong>声明一个明确的版本（除非发生冲突，否则当Maven选择一个匹配的版本时，它将始终解析为1.0.1）：</strong></p><pre><code class="no-highlight">&lt;version&gt;1.0.1&lt;/version&gt;</code></pre><p><strong>声明所有1.x的版本范围（当前将解析为1.1.1）：</strong></p><pre><code class="no-highlight">&lt;version&gt;[1.0.0,2.0.0)&lt;/version&gt;</code></pre><p><strong>声明一个开放式版本范围（将解析为2.0.0）：</strong></p><pre><code class="no-highlight">&lt;version&gt;[1.0.0,)&lt;/version&gt;</code></pre><p><strong>将版本声明为最新（将解析为2.0.0）：</strong></p><pre><code class="no-highlight">&lt;version&gt;LATEST&lt;/version&gt;</code></pre><p><strong>将版本声明为RELEASE（将解析为1.1.1）：</strong></p><pre><code class="no-highlight">&lt;version&gt;RELEASE&lt;/version&gt;</code></pre><p><strong>请注意，默认情况下，您自己的部署将更新Maven元数据中的“最新”条目，但是要更新“发布”条目，则需要从Maven超级POM激活“发布配置文件”。您可以使用“ -Prelease-profile”或“ -DperformRelease = true”来执行此操作</strong></p></div><div class="section" title="4.2.3.5。Settings.xml和远程存储库设置"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3201"></a> 4.2.3.5。Settings.xml和远程存储库设置</strong></h4></div></div></div><p><strong>maven settings.xml用于配置Maven执行。可以在Maven网站上找到详细说明：</strong></p><p><strong><a class="link" href="http://maven.apache.org/settings.html">http://maven.apache.org/settings.html</a></strong></p><p><strong>settings.xml文件可以位于3个位置，实际使用的设置是这3个位置的合并。</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>Maven安装：<code class="literal">$M2_HOME/conf/settings.xml</code></strong></p></li><li class="listitem"><p><strong>用户的安装：<code class="literal">${user.home}/.m2/settings.xml</code></strong></p></li><li class="listitem"><p><strong>系统属性指定的文件夹位置<code class="literal">kie.maven.settings.custom</code></strong></p></li></ul></div><p><strong>settings.xml用于指定远程存储库的位置。激活指定远程存储库的配置文件很重要，通常可以使用“ activeByDefault”完成此操作：</strong></p><pre><code class="language-xml">&lt;profiles&gt;
  &lt;profile&gt;
    &lt;id&gt;profile-1&lt;/id&gt;
    &lt;activation&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;
    ...
  &lt;/profile&gt;
&lt;/profiles&gt;
    </code></pre><p><strong>Maven提供有关使用多个远程存储库的详细文档：</strong></p><p><strong><a class="link" href="http://maven.apache.org/guides/mini/guide-multiple-repositories.html">http://maven.apache.org/guides/mini/guide-multiple-repositories.html</a></strong></p></div></div><div class="section" title="4.2.4。跑步"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIERunningSection"></a> 4.2.4。跑步</strong></h3></div></div></div><p></p><div class="section" title="4.2.4.1。凯基"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3240"></a> 4.2.4.1。凯基</strong></h4></div></div></div><p><strong>的<code class="code">KieBase</code>是所有应用程序知识定义的存储库。它将包含规则，流程，功能和类型模型。的<code class="code">KieBase</code>本身不包含数据；而是从<code class="code">KieBase</code>可以在其中插入数据以及可以从中启动流程实例。的<code class="code">KieBase</code>可以从<code class="code">KieContainer</code>包含<code class="code">KieModule</code>在哪里<code class="code">KieBase</code>已经定义。</strong></p><div class="example"><strong><a id="d0e3266"></a><p class="title"><strong>示例4.16从KieContainer获取KieBase</strong></p><div class="example-contents"><pre><code class="language-java">KieBase kBase = kContainer.getKieBase();</code></pre></div></strong></div><strong><br class="example-break"></strong></div><div class="section" title="4.2.4.2。KieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3271"></a> 4.2.4.2。KieSession</strong></h4></div></div></div><p><strong>的<code class="code">KieSession</code>存储并在运行时数据上执行。它是从<code class="code">KieBase</code> 。</strong></p><div class="figure"><strong><a id="d0e3282"></a><p class="title"><strong>图4.16。KieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieSession.png" alt="KieSession"></div></div></strong></div><strong><br class="figure-break"><div class="example"><a id="d0e3288"></a><p class="title"><strong>示例4.17从KieBase创建一个KieSession</strong></p><div class="example-contents"><pre><code class="language-java">KieSession ksession = kbase.newKieSession();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.4.3。KieRuntime"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3293"></a> 4.2.4.3。KieRuntime</strong></h4></div></div></div><div class="section" title="4.2.4.3.1。KieRuntime"><div class="titlepage"><div><div><h5 class="title"><strong><a id="d0e3296"></a> 4.2.4.3.1。KieRuntime</strong></h5></div></div></div><p><strong>的<code class="code">KieRuntime</code>提供适用于规则和过程的方法，例如设置全局变量和注册通道。 （“出口点”是“渠道”的过时同义词。）</strong></p><div class="figure"><strong><a id="d0e3304"></a><p class="title"><strong>图4.17。KieRuntime</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntime.png" alt="KieRuntime"></div></div></strong></div><strong><br class="figure-break"><div class="section" title="4.2.4.3.1.1。全球"><div class="titlepage"><div><div><h6 class="title"><a id="d0e3310"></a> 4.2.4.3.1.1。全球</h6></div></div></div><p>全局变量被命名为规则引擎可见的对象，但与事实不同的是，它们与事实完全不同：支持全局变量的对象的更改不会触发规则的重新评估。尽管如此，全局变量仍可用于提供静态信息，作为对象提供规则的RHS中使用的服务或作为从规则引擎返回对象的手段。在规则的LHS上使用全局时，请确保它是不可变的，或者至少不要期望更改对规则的行为有任何影响。</p><p>必须在规则文件中声明全局变量，然后需要使用Java对象对其进行备份。</p><pre><code class="no-highlight">global java.util.List list</code></pre><p>现在，知识库知道全局标识符及其类型，现在可以调用<code class="code">ksession.setGlobal()</code>与全局名称和一个对象（对于任何会话），以将该对象与全局关联。如果未在DRL代码中声明全局类型和标识符，则将导致此调用引发异常。</p><pre><code class="language-java">List list = new ArrayList();
ksession.setGlobal("list", list);           </code></pre><p>在评估规则之前，请确保先设置任何全局变量。否则会导致<code class="code">NullPointerException</code> 。</p></div></strong></div></div><div class="section" title="4.2.4.4。事件模型"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3331"></a> 4.2.4.4。事件模型</strong></h4></div></div></div><p><strong>事件包提供了用于通知规则引擎事件的方法，包括规则触发，声明的对象等。这允许将日志记录和审核活动与应用程序的主要部分（以及规则）分开。</strong></p><p><strong>的<code class="code">KieRuntimeEventManager</code>接口由<code class="code">KieRuntime</code>它提供了两个接口， <code class="code">RuleRuntimeEventManager</code>和<code class="code">ProcessEventManager</code> 。我们将只涵盖<code class="code">RuleRuntimeEventManager</code>这里。</strong></p><div class="figure"><strong><a id="d0e3353"></a><p class="title"><strong>图4.18。KieRuntimeEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntimeEventManager.png" alt="KieRuntimeEventManager"></div></div></strong></div><strong><br class="figure-break"><p>的<code class="code">RuleRuntimeEventManager</code>允许添加和删除侦听器，以便可以侦听工作内存和议程的事件。</p><div class="figure"><a id="d0e3364"></a><p class="title"><strong>图4.19。RuleRuntimeEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/RuleRuntimeEventManager.png" alt="RuleRuntimeEventManager"></div></div></div><br class="figure-break"><p>以下代码段显示了如何声明简单的议程侦听器并将其附加到会话。射击后将打印火柴。</p><div class="example"><a id="d0e3372"></a><p class="title"><strong>示例4.18添加一个AgendaEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DefaultAgendaEventListener() {
    public void afterMatchFired(AfterMatchFiredEvent event) {
        super.afterMatchFired( event );
        System.out.println( event );
    }
});</code></pre></div></div><br class="example-break"><p>流口水还提供<code class="code">DebugRuleRuntimeEventListener</code>和<code class="code">DebugAgendaEventListener</code>使用调试打印语句实现每种方法。要打印所有工作内存事件，请添加一个侦听器，如下所示：</p><div class="example"><a id="d0e3385"></a><p class="title"><strong>示例4.19添加一个DebugRuleRuntimeEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DebugRuleRuntimeEventListener() );</code></pre></div></div><br class="example-break"><p>所有发出的事件都实现了<code class="code">KieRuntimeEvent</code>可以用来检索实际的接口<code class="code">KnowlegeRuntime</code>事件起源。</p><div class="figure"><a id="d0e3398"></a><p class="title"><strong>图4.20。KieRuntimeEvent</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieRuntimeEvent.png" alt="KieRuntimeEvent"></div></div></div><br class="figure-break"><p>当前支持的事件是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>MatchCreatedEvent</p></li><li class="listitem"><p>MatchCancelledEvent</p></li><li class="listitem"><p>BeforeMatchFiredEvent</p></li><li class="listitem"><p>AfterMatchFiredEvent</p></li><li class="listitem"><p>AgendaGroupPushedEvent</p></li><li class="listitem"><p>AgendaGroupPoppedEvent</p></li><li class="listitem"><p>ObjectInsertEvent</p></li><li class="listitem"><p>ObjectDeletedEvent</p></li><li class="listitem"><p>ObjectUpdatedEvent</p></li><li class="listitem"><p>ProcessCompletedEvent</p></li><li class="listitem"><p>ProcessNodeLeftEvent</p></li><li class="listitem"><p>ProcessNodeTriggeredEvent</p></li><li class="listitem"><p>ProcessStartEvent</p></li></ul></div></strong></div><div class="section" title="4.2.4.5。KieRuntimeLogger"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3446"></a> 4.2.4.5。KieRuntimeLogger</strong></h4></div></div></div><p><strong>KieRuntimeLogger使用Drools中的综合事件系统来创建审核日志，该日志可以使用Eclipse审核查看器等工具记录应用程序的执行情况，以供以后检查。</strong></p><div class="figure"><strong><a id="d0e3451"></a><p class="title"><strong>图4.21。记录仪</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieLoggers.png" alt="记录仪"></div></div></strong></div><strong><br class="figure-break"><div class="example"><a id="d0e3457"></a><p class="title"><strong>示例4.20文件记录器</strong></p><div class="example-contents"><pre><code class="language-java">KieRuntimeLogger logger =
  KieServices.Factory.get().getLoggers().newFileLogger(ksession, "logdir/mylogfile");
...
logger.close();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.4.6。命令和CommandExecutor"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3462"></a> 4.2.4.6。命令和CommandExecutor</strong></h4></div></div></div><p><strong>KIE具有状态会话或无状态会话的概念。已经讨论了使用标准KieRuntime的有状态会话，并且可以随着时间的推移反复使用它们。无状态是使用提供的数据集一次性执行KieRuntime。它可能会返回一些结果，而会话将被置于末尾，从而禁止进一步的迭代交互。您可以将无状态视为将引擎视为具有可选返回结果的函数调用。</strong></p><p><strong>其基础是<code class="code">CommandExecutor</code>接口，有状态接口和无状态接口都将对其进行扩展。这返回一个<code class="code">ExecutionResults</code> ：</strong></p><div class="figure"><strong><a id="d0e3475"></a><p class="title"><strong>图4.22。CommandExecutor</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/CommandExecutor.png" alt="CommandExecutor"></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e3481"></a><p class="title"><strong>图4.23。执行结果</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/ExecutionResults.png" alt="执行结果"></div></div></div><br class="figure-break"><p>的<code class="code">CommandExecutor</code>允许在这些会话上执行命令，唯一的不同是StatelessKieSession执行<code class="code">fireAllRules()</code>最后，在安排会议之前。可以使用以下命令创建命令<code class="code">CommandExecutor</code> 。Javadocs使用来提供允许的命令的完整列表。 <code class="code">CommandExecutor</code> 。</p><p>setGlobal和getGlobal是与Drools和jBPM相关的两个命令。</p><p>Set Global在下面调用setGlobal。可选的布尔值指示命令是否应将全局值返回为<code class="code">ExecutionResults</code> 。如果为true，则使用与全局名称相同的名称。如果需要备用名称，则可以使用字符串代替布尔值。</p><p>
      </p><div class="example"><a id="d0e3510"></a><p class="title"><strong>示例4.21。设置全局命令</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
    ksession.execute( CommandFactory.newSetGlobal( "stilton", new Cheese( "stilton" ), true);
Cheese stilton = bresults.getValue( "stilton" );
</code></pre></div></div><p><br class="example-break">
    </p><p>允许返回现有的全局变量。第二个可选的String参数允许使用其他返回名称。</p><div class="example"><a id="d0e3518"></a><p class="title"><strong>示例4.22获取全局命令</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
    ksession.execute( CommandFactory.getGlobal( "stilton" );
Cheese stilton = bresults.getValue( "stilton" );
</code></pre></div></div><br class="example-break"><p>以上所有示例均执行单个命令。的<code class="code">BatchExecution</code>表示从命令列表创建的复合命令。它将遍历列表并依次执行每个命令。这意味着您可以插入一个对象，启动一个流程，调用fireAllRules并执行一个查询<code class="code">execute(...)</code>通话，功能非常强大。</p><p>StatelessKieSession将执行<code class="code">fireAllRules()</code>自动结束。但是，敏锐的读者可能已经注意到<code class="code">FireAllRules</code>命令，并想知道如何与StatelessKieSession一起使用。的<code class="code">FireAllRules</code>命令是允许的，使用它会在最后禁用自动执行；考虑将其用作一种手动替代功能。</p><p>批处理中设置了out标识符的任何命令都将其结果添加到返回的命令中<code class="code">ExecutionResults</code>实例。让我们看一个简单的例子，看看它是如何工作的。为了说明起见，给出的示例包括来自Drools和jBPM的命令。在Drool和jBPM特定部分中将更详细地介绍它们。</p><div class="example"><a id="d0e3547"></a><p class="title"><strong>示例4.23BatchExecution命令</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();

List cmds = new ArrayList();
cmds.add( CommandFactory.newInsertObject( new Cheese( "stilton", 1), "stilton") );
cmds.add( CommandFactory.newStartProcess( "process cheeses" ) );
cmds.add( CommandFactory.newQuery( "cheeses" ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( "stilton" );
QueryResults qresults = ( QueryResults ) bresults.getValue( "cheeses" );
</code></pre></div></div><br class="example-break"><p>在上面的示例中，执行了多个命令，其中两个填充了<code class="code">ExecutionResults</code> 。默认情况下，查询命令使用与查询名称相同的标识符，但是也可以将其映射到其他标识符。</p><p>所有命令都支持使用XStream进行XML和jSON封送以及JAXB封送。这将在“ <a class="link" href="#CommandsAPISection" title="11.1。API">命令API”</a>小节中介绍。</p></strong></div><div class="section" title="4.2.4.7。StatelessKieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3562"></a> 4.2.4.7。StatelessKieSession</strong></h4></div></div></div><p><strong>的<code class="code">StatelessKieSession</code>包装<code class="code">KieSession</code> ，而不是扩展它。它的主要重点是决策服务类型方案。它避免了打电话的需要<code class="code">dispose()</code> 。无状态会话不支持迭代插入和方法调用<code class="code">fireAllRules()</code>来自Java代码；打电话的行为<code class="code">execute()</code>是单次使用的方法，将在内部实例化一个<code class="code">KieSession</code> ，添加所有用户数据并执行用户命令，然后调用<code class="code">fireAllRules()</code> ，然后致电<code class="code">dispose()</code> 。虽然使用此类的主要方法是通过<code class="code">BatchExecution</code> （的子接口<code class="code">Command</code> ）（由<code class="code">CommandExecutor</code>接口，当需要简单的对象插入时，提供了两种便捷的方法。的<code class="code">CommandExecutor</code>和<code class="code">BatchExecution</code>在各自的部分中进行了详细讨论。</strong></p><div class="figure"><strong><a id="d0e3606"></a><p class="title"><strong>图4.24。StatelessKieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/StatelessKieSession.png" alt="StatelessKieSession"></div></div></strong></div><strong><br class="figure-break"><p>我们的简单示例显示了使用便捷API执行给定Java对象集合的无状态会话。它将迭代集合，依次插入每个元素。</p><div class="example"><a id="d0e3614"></a><p class="title"><strong>示例4.24带有集合的简单StatelessKieSession执行</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute( collection );</code></pre></div></div><br class="example-break"><p>如果将其作为单个命令完成，则将如下所示：</p><div class="example"><a id="d0e3621"></a><p class="title"><strong>示例4.25使用InsertElements命令简单执行StatelessKieSession</strong></p><div class="example-contents"><pre><code class="language-java">ksession.execute( CommandFactory.newInsertElements( collection ) );  </code></pre></div></div><br class="example-break"><p>如果要插入集合本身以及集合的各个元素，则<code class="code">CommandFactory.newInsert(collection)</code>会做的工作。</p><p>方法<code class="code">CommandFactory</code>创建受支持的命令，所有命令都可以使用XStream和<code class="code">BatchExecutionHelper</code> 。<code class="code">BatchExecutionHelper</code>提供有关XML格式的详细信息，以及如何使用Drools Pipeline自动整理<code class="code">BatchExecution</code>和<code class="code">ExecutionResults</code> 。</p><p><code class="code">StatelessKieSession</code>支持全局变量，范围有很多种。我们首先介绍非命令方式，因为命令的作用域是特定的执行调用。全局变量可以通过三种方式解决。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>StatelessKieSession方法<code class="code">getGlobals()</code>返回一个Globals实例，该实例提供对会话的Globals的访问。这些将为<span class="emphasis"><em>所有</em></span>执行调用共享。请注意有关可变全局变量的注意事项，因为执行调用可以在不同线程中同时执行。</p><div class="example"><a id="d0e3662"></a><p class="title"><strong>示例4.26全球范围的会议</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.
ksession.execute( collection ); </code></pre></div></div><br class="example-break"></li><li class="listitem"><p>使用委托是全局解决的另一种方法。为全局值分配<code class="code">setGlobal(String, Object)</code> ）导致值存储在内部集合中，这些标识符将标识符映射到值。此内部集合中的标识符将优先于任何提供的委托。仅当在此内部集合中找不到标识符时，才使用全局委托（如果有）。</p></li><li class="listitem"><p>解决全局变量的第三种方法是使执行范围全局变量。在这里<code class="code">Command</code>设置全局传递给<code class="code">CommandExecutor</code> 。</p></li></ul></div><p>的<code class="code">CommandExecutor</code>界面还提供了通过“输出”参数导出数据的功能。插入的事实，全局变量和查询结果都可以返回。</p><div class="example"><a id="d0e3687"></a><p class="title"><strong>示例4.27输出标识符</strong></p><div class="example-contents"><pre><code class="language-java">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.4.8。编组"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3692"></a> 4.2.4.8。编组</strong></h4></div></div></div><p><strong>的<code class="code">KieMarshallers</code>用于编组和取消编组KieSessions。</strong></p><div class="figure"><strong><a id="d0e3700"></a><p class="title"><strong>图4.25。基·马歇尔</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/KieMarshallers.png" alt="基·马歇尔"></div></div></strong></div><strong><br class="figure-break"><p>的实例<code class="code">KieMarshallers</code>可以从<code class="code">KieServices</code> 。下面是一个简单的示例：</p><div class="example"><a id="d0e3714"></a><p class="title"><strong>示例4.28简单的Marshaller示例</strong></p><div class="example-contents"><pre><code class="language-java">// ksession is the KieSession
// kbase is the KieBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = KieServices.Factory.get().getMarshallers().newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"><p>但是，通过编组，在处理引用的用户数据时将需要更大的灵活性。为此，请使用<code class="code">ObjectMarshallingStrategy</code>接口。提供了两种实现，但用户可以实现自己的实现。提供的两种策略是<code class="code">IdentityMarshallingStrategy</code>和<code class="code">SerializeMarshallingStrategy</code> 。
    <code class="code">SerializeMarshallingStrategy</code>是默认值，如上面的示例所示，它只是调用<code class="code">Serializable</code>要么<code class="code">Externalizable</code>用户实例上的方法。
    <code class="code">IdentityMarshallingStrategy</code>为每个用户对象创建一个整数ID，并将其存储在Map中，同时将ID写入流中。当解组时，它访问<code class="code">IdentityMarshallingStrategy</code>映射以检索实例。这意味着如果您使用<code class="code">IdentityMarshallingStrategy</code> ，它在Marshaller实例的生命期内是有状态的，并将创建ID并保留对其尝试编组的所有对象的引用。以下是使用身份编组策略的代码。</p><div class="example"><a id="d0e3748"></a><p class="title"><strong>示例4.29身份编组策略</strong></p><div class="example-contents"><pre><code class="language-java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers()
ObjectMarshallingStrategy oms = kMarshallers.newIdentityMarshallingStrategy()
Marshaller marshaller =
        kMarshallers.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"><p>在大多数情况下，单一策略是不够的。为了增加灵活性， <code class="code">ObjectMarshallingStrategyAcceptor</code>可以使用接口。该编组器具有一系列策略，并且在读取或写入用户对象时会迭代这些策略，询问它们是否承担编组用户对象的责任。提供的实现之一是<code class="code">ClassFilterAcceptor</code> 。这允许使用字符串和通配符来匹配类名。默认值为“ *。*”，因此在上面的示例中，使用的身份编组策略具有默认的“ *。*”接受器。</p><p>假设我们要序列化除一个给定包以外的所有类，在该包中将使用身份查找，我们可以执行以下操作：</p><div class="example"><a id="d0e3763"></a><p class="title"><strong>示例4.30与接受者的身份编组策略</strong></p><div class="example-contents"><pre><code class="language-java">ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers()
ObjectMarshallingStrategyAcceptor identityAcceptor =
        kMarshallers.newClassFilterAcceptor( new String[] { "org.domain.pkg1.*" } );
ObjectMarshallingStrategy identityStrategy =
        kMarshallers.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = kMarshallers.newSerializeMarshallingStrategy();
Marshaller marshaller =
        kMarshallers.newMarshaller( kbase,
                                    new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre></div></div><br class="example-break"><p>请注意，验收检查的顺序是所提供元素的自然顺序。</p><p>还要注意，如果您使用排定的匹配项（例如，某些规则使用计时器或日历），则只有在使用前，将KieSession配置为使用可跟踪的计时器作业工厂管理器时，它们才可编组：</p><div class="example"><a id="d0e3772"></a><p class="title"><strong>示例4.31配置可跟踪的计时器作业工厂经理</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption(TimerJobFactoryOption.get("trackable"));
KSession ksession = kbase.newKieSession(ksconf, null);</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.4.9。持久性和交易"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3777"></a> 4.2.4.9。持久性和交易</strong></h4></div></div></div><p><strong>Drools可以实现Java Persistence API（JPA）的长期开箱即用的持久性。必须安装Java事务API（JTA）的某些实现。出于开发目的，建议使用Bitronix事务管理器，因为它易于安装并可以嵌入，但是建议在生产中使用JBoss Transactions。</strong></p><div class="example"><strong><a id="d0e3782"></a><p class="title"><strong>示例4.32使用交易的简单示例</strong></p><div class="example-contents"><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
Environment env = kieServices.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,
         Persistence.createEntityManagerFactory( "emf-name" ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );

// KieSessionConfiguration may be null, and a default will be used
KieSession ksession =
        kieServices.getStoreServices().newKieSession( kbase, null, env );
int sessionId = ksession.getId();

UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( "process1" );
ut.commit();</code></pre></div></strong></div><strong><br class="example-break"><p>要使用JPA，必须同时设置环境<code class="code">EntityManagerFactory</code>和<code class="code">TransactionManager</code> 。如果发生回滚，则ksession状态也会回滚，因此可以在回滚后继续使用它。要加载以前持久保存的KieSession，您将需要ID，如下所示：</p><div class="example"><a id="d0e3795"></a><p class="title"><strong>示例4.33加载一个KieSession</strong></p><div class="example-contents"><pre><code class="language-java">KieSession ksession =
        kieServices.getStoreServices().loadKieSession( sessionId, kbase, null, env );</code></pre></div></div><br class="example-break"><p>要启用持久性，必须将几个类添加到persistence.xml中，如下例所示：</p><div class="example"><a id="d0e3802"></a><p class="title"><strong>示例4.34配置JPA</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;persistence-unit name="org.drools.persistence.jpa" transaction-type="JTA"&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;
   &lt;class&gt;org.drools.persistence.info.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.info.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
         &lt;property name="hibernate.show_sql" value="true" /&gt;
         &lt;property name="hibernate.transaction.manager_lookup_class"
                      value="org.hibernate.transaction.BTMTransactionManagerLookup" /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre></div></div><br class="example-break"><p>必须首先配置jdbc JTA数据源。Bitronix提供了许多方法来执行此操作，有关详细信息，请查阅其文档。为了快速入门，以下是编程方法：</p><div class="example"><a id="d0e3809"></a><p class="title"><strong>示例4.35配置JTA数据源</strong></p><div class="example-contents"><pre><code class="language-java">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( "jdbc/BitronixJTADataSource" );
ds.setClassName( "org.h2.jdbcx.JdbcDataSource" );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( "user", "sa" );
ds.getDriverProperties().put( "password", "sasa" );
ds.getDriverProperties().put( "URL", "jdbc:h2:mem:mydb" );
ds.init();
</code></pre></div></div><br class="example-break"><p>Bitronix还提供简单的嵌入式JNDI服务，非常适合测试。要使用它，请将jndi.properties文件添加到您的META-INF文件夹，并向其中添加以下行：</p><div class="example"><a id="d0e3816"></a><p class="title"><strong>示例4.36JNDI属性</strong></p><div class="example-contents"><pre><code class="no-highlight">java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</code></pre></div></div><br class="example-break"></strong></div></div><div class="section" title="4.2.5。安装和部署备忘单"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEDeployCheatSheets"></a> 4.2.5。安装和部署备忘单</strong></h3></div></div></div><div class="figure"><strong><a id="d0e3824"></a><p class="title"><strong>图4.26。安装概述</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/cheatsheet1.png" alt="安装概述"></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e3830"></a><p class="title"><strong>图4.27。部署概述</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/kie/BuildDeployUtilizeAndRun/cheatsheet2.png" alt="部署概述"></div></div></div><br class="figure-break"></strong></div><div class="section" title="4.2.6。构建，部署和利用示例"><div class="titlepage"><div><div><h3 class="title"><strong><a id="KIEExamplesSection"></a> 4.2.6。构建，部署和利用示例</strong></h3></div></div></div><p><strong>学习新的构建系统的最佳方法是通过示例。源项目“ drools-examples-api”包含许多示例，可以在GitHub上找到：</strong></p><p><strong><a class="link" href="https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api">https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api</a></strong></p><p><strong>每个示例如下所述，顺序从最简单的开始（大多数选项都是默认选项），然后逐步扩展到更复杂的用例。</strong></p><p><strong>下面显示的Deploy用例都涉及<code class="code">mvn install</code> 。Maven文献充分介绍了在Maven中进行JAR的远程部署。利用是指加载资源并提供对KIE运行时的访问的初始操作。其中，“运行”是指与这些运行时进行交互的行为。</strong></p><div class="section" title="4.2.6.1。默认KieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3851"></a> 4.2.6.1。默认KieSession</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：default-kesession。</strong></p></li><li class="listitem"><p><strong>摘要：类路径上的空kmodule.xml KieModule包含单个默认KieBase中的所有资源。该示例显示了从类路径中检索默认的KieSession。</strong></p></li></ul></div><p><strong>空的kmodule.xml将产生一个单一的KieBase，其中包括在资源路径下找到的所有文件，例如DRL，BPMN2，XLS等。该单一的KieBase是默认的，并且还包含一个默认的KieSession。默认表示可以在不知道其名称的情况下创建它们。</strong></p><div class="example"><strong><a id="d0e3863"></a><p class="title"><strong>示例4.37作者-kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt; &lt;/kmodule&gt;
  </code></pre></div></strong></div><strong><br class="example-break"><div class="example"><a id="d0e3868"></a><p class="title"><strong>示例4.38构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"><p>ks.getKieClasspathContainer（）返回包含部署到环境类路径上的KieBase的KieContainer。 kContainer.newKieSession（）创建默认的KieSession。注意，您不再需要查找KieBase即可创建KieSession。KieSession知道它与哪个KieBase关联，并使用它，在这种情况下，它是默认的KieBase。</p><div class="example"><a id="d0e3875"></a><p class="title"><strong>示例4.39使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">
KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();                
      </code></pre></div></div><br class="example-break"><p></p><p></p></strong></div><div class="section" title="4.2.6.2。名为KieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3882"></a> 4.2.6.2。名为KieSession</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：命名为kiesession。</strong></p></li><li class="listitem"><p><strong>简介：kmodule.xml具有一个名为KieBase的名称和一个名为KieSession的名称。这些示例显示了从类路径中检索命名的KieSession。</strong></p></li></ul></div><p></p><p><strong>kmodule.xml将产生一个名为KieBase的单一名称，即“ kbase1”，其中包括在资源路径下找到的所有文件，无论是DRL，BPMN2，XLS等。KieSession“ ksession1”与该KieBase相关联，可以通过名称创建。</strong></p><div class="example"><strong><a id="d0e3895"></a><p class="title"><strong>示例4.40作者-kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
    &lt;kbase name="kbase1"&gt;
        &lt;ksession name="ksession1"/&gt;
    &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></strong></div><strong><br class="example-break"><div class="example"><a id="d0e3900"></a><p class="title"><strong>示例4.41构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"><p>ks.getKieClasspathContainer（）返回包含部署到环境类路径上的KieBase的KieContainer。这次，KieSession使用名称“ ksession1”。您无需先查找KieBase，因为它知道与哪个KieBase'ksession1'关联。</p><div class="example"><a id="d0e3907"></a><p class="title"><strong>示例4.42使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);
kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.3。KieBase继承"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3912"></a> 4.2.6.3。KieBase继承</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：kiebase-inclusion。</strong></p></li><li class="listitem"><p><strong>简介：“ kmodule.xml”演示了一个KieBase可以包含来自另一个KieBase，另一个KieModule的资源。在这种情况下，它从'name-kiesession'示例继承了命名的KieBase。包含的KieBase可以来自当前的KieModule或pom.xml依赖项列表中的任何其他KieModule。</strong></p></li></ul></div><p></p><p><strong>kmodule.xml将产生一个名为KieBase的名称，即“ kbase2”，其中包括在资源路径下找到的所有文件，例如DRL，BPMN2，XLS等。此外，由于使用的原因，它将包括从KieBase“ kbase1”中找到的所有资源。 “包含”属性的名称。KieSession'ksession2'与该KieBase相关联，可以通过名称创建。</strong></p><div class="example"><strong><a id="d0e3925"></a><p class="title"><strong>示例4.43作者-kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kbase name="kbase2" includes="kbase1"&gt;
    &lt;ksession name="ksession2"/&gt;
&lt;/kbase&gt;</code></pre></div></strong></div><strong><br class="example-break"><p>此示例要求首先构建先前的示例“ named-kiesession”，并将其安装到本地Maven存储库。安装后，可以使用标准Maven <dependencies>元素</dependencies>将其作为依赖项包含在内<dependencies>。</dependencies></p><div class="example"><a id="d0e3932"></a><p class="title"><strong>示例4.44作者-pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;kiebase-inclusion&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieBase Inclusion&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;named-kiesession&lt;/artifactId&gt;
      &lt;version&gt;6.0.0&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

&lt;/project&gt;</code></pre></div></div><br class="example-break"><p>一旦构建并安装了“ named-kiesession”，就可以正常构建和安装此示例。同样，安装过程将迫使单元测试运行，演示用例。</p><div class="example"><a id="d0e3939"></a><p class="title"><strong>示例4.45构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"><p>ks.getKieClasspathContainer（）返回包含部署到环境类路径上的KieBase的KieContainer。这次，KieSession使用名称“ ksession2”。您无需先查找KieBase，因为它知道与哪个KieBase'ksession1'关联。请注意，这次触发了两个规则，表明KieBase'kbase2'已包含依赖项KieBase'kbase1'的资源。</p><div class="example"><a id="d0e3946"></a><p class="title"><strong>示例4.46使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();
KieSession kSession = kContainer.newKieSession("ksession2");
kSession.setGlobal("out", out);

kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();

kSession.insert(new Message("Dave", "Open the pod bay doors, HAL."));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.4。多个KieBase"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3951"></a> 4.2.6.4。多个KieBase</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>专案：'multiple-kbases。</strong></p></li><li class="listitem"><p><strong>摘要：演示'kmodule.xml'可以包含任意数量的KieBase或KieSession声明。引入“包”属性以选择要包含在KieBase中的资源的文件夹。</strong></p></li></ul></div><p><strong>kmodule.xml产生6个不同的命名KieBases。 “ kbase1”包括来自KieModule的所有资源。其他KieBase通过“ packages”属性包括来自其他选定文件夹的资源。请注意使用通配符“ *”来选择此软件包及其下面的所有软件包。</strong></p><div class="example"><strong><a id="d0e3963"></a><p class="title"><strong>示例4.47作者-kmodule.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;

  &lt;kbase name="kbase1"&gt;
    &lt;ksession name="ksession1"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase2" packages="org.some.pkg"&gt;
    &lt;ksession name="ksession2"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase3" includes="kbase2" packages="org.some.pkg2"&gt;
    &lt;ksession name="ksession3"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase4" packages="org.some.pkg, org.other.pkg"&gt;
    &lt;ksession name="ksession4"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase5" packages="org.*"&gt;
    &lt;ksession name="ksession5"/&gt;
  &lt;/kbase&gt;

  &lt;kbase name="kbase6" packages="org.some.*"&gt;
    &lt;ksession name="ksession6"/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</code></pre></div></strong></div><strong><br class="example-break"><div class="example"><a id="d0e3968"></a><p class="title"><strong>示例4.48构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"><p>下面仅包含示例的一部分，因为每个KieSession都有一种测试方法，但每个示例都是另一个的重复，具有不同的列表期望。</p><div class="example"><a id="d0e3975"></a><p class="title"><strong>示例4.49使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">@Test
public void testSimpleKieBase() {
    List&lt;Integer&gt; list = useKieSession("ksession1");
    // no packages imported means import everything
    assertEquals(4, list.size());
    assertTrue( list.containsAll( asList(0, 1, 2, 3) ) );
}

//.. other tests for ksession2 to ksession6 here

private List&lt;Integer&gt; useKieSession(String name) {
    KieServices ks = KieServices.Factory.get();
    KieContainer kContainer = ks.getKieClasspathContainer();
    KieSession kSession = kContainer.newKieSession(name);

    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    kSession.setGlobal("list", list);
    kSession.insert(1);
    kSession.fireAllRules();

    return list;
}</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.5。来自KieRepository的KieContainer"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e3980"></a> 4.2.6.5。来自KieRepository的KieContainer</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：来自存储库的kcontainer</strong></p></li><li class="listitem"><p><strong>简介：该项目不包含kmodule.xml，pom.xml也没有与其他KieModules依赖。相反，Java代码演示了如何从Maven存储库中加载动态KieModule。</strong></p></li></ul></div><p><strong>pom.xml必须包含kie-ci作为依赖，以确保Maven在运行时可用。由于这是在后台使用Maven的，因此您也可以使用标准的Maven settings.xml文件。</strong></p><div class="example"><strong><a id="d0e3992"></a><p class="title"><strong>示例4.50作者-pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;kiecontainer-from-kierepo&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieContainer from KieRepo&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.kie&lt;/groupId&gt;
      &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

&lt;/project&gt;</code></pre></div></strong></div><strong><br class="example-break"><div class="example"><a id="d0e3997"></a><p class="title"><strong>示例4.51构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></div><br class="example-break"><p>在前面的示例中，使用了KieContainer类路径。本示例创建一个由ReleaseId指定的动态KieContainer。ReleaseId将Maven约定用于组ID，工件ID和版本。它也遵循LATEST和SNAPSHOT的版本。</p><div class="example"><a id="d0e4004"></a><p class="title"><strong>示例4.52使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();

// Install example1 in the local Maven repo before to do this
KieContainer kContainer = ks.newKieContainer(ks.newReleaseId("org.drools", "named-kiesession", "6.0.0-SNAPSHOT"));

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.6。文件中的默认KieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e4009"></a> 4.2.6.6。文件中的默认KieSession</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：来自文件的default-kiesession-from</strong></p></li><li class="listitem"><p><strong>简介：动态KieModules也可以从任何Resource位置加载。加载的KieModule提供默认的KieBase和KieSession定义。</strong></p></li></ul></div><p><strong>没有kmodue.xml文件。必须首先构建项目“ default-kiesession”，以便可以将目标文件夹中生成的JAR引用为文件。</strong></p><div class="example"><strong><a id="d0e4021"></a><p class="title"><strong>示例4.53构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></strong></div><strong><br class="example-break"><p>可以从资源位置加载任何KieModule并将其添加到KieRepository。一旦部署在KieRepository中，就可以通过其ReleaseId进行解析。注意这里不需要Maven或kie-ci。它将不会设置可传递依赖关系父类加载器。</p><div class="example"><a id="d0e4028"></a><p class="title"><strong>示例4.54使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile("default-kiesession")));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.7。从文件命名为KieSession"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e4033"></a> 4.2.6.7。从文件命名为KieSession</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：从文件命名为kiesession</strong></p></li><li class="listitem"><p><strong>简介：动态KieModules也可以从任何Resource位置加载。加载的KieModule提供了命名的KieBase和KieSession定义。</strong></p></li></ul></div><p><strong>没有kmodue.xml文件。必须首先构建项目“ named-kiesession”，以便目标文件夹中的结果JAR可以作为文件引用。</strong></p><div class="example"><strong><a id="d0e4045"></a><p class="title"><strong>示例4.55构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></strong></div><strong><br class="example-break"><p>可以从资源位置加载任何KieModule并将其添加到KieRepository。进入KieRepository后，可以通过其ReleaseId进行解析。注意这里不需要Maven或kie-ci。它不会设置可传递依赖关系父类加载器。</p><div class="example"><a id="d0e4052"></a><p class="title"><strong>示例4.56使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile("named-kiesession")));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession("ksession1");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.8。带有从属KieModule的KieModule"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e4057"></a> 4.2.6.8。带有从属KieModule的KieModule</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：kie-module-form-multiple-files</strong></p></li><li class="listitem"><p><strong>简介：以编程方式提供了依赖KieModule的列表，而无需使用Maven来解决任何问题。</strong></p></li></ul></div><p><strong>没有kmodue.xml文件。必须首先构建项目“ named-kiesession”和“ kiebase-include”，以便可以将目标文件夹中生成的JAR引用为Files。</strong></p><div class="example"><strong><a id="d0e4069"></a><p class="title"><strong>示例4.57构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></strong></div><strong><br class="example-break"><p>创建两个资源。一个用于主KieModule'exRes1'，另一个用于依赖项'exRes2'。即使不存在kie-ci，因此Maven无法解决依赖关系，这仍显示了如何为vararg手动指定依赖的KieModule。</p><div class="example"><a id="d0e4076"></a><p class="title"><strong>示例4.58使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile("kiebase-inclusion"));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile("named-kiesession"));

KieModule kModule = kr.addKieModule(ex1Res, ex2Res);
KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession("ksession2");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, "Dave", "Open the pod bay doors, HAL.");
kSession.insert(msg2);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.9。通过编程以默认方式构建简单的KieModule"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e4081"></a> 4.2.6.9。通过编程以默认方式构建简单的KieModule</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：kiemoduelmodel-example</strong></p></li><li class="listitem"><p><strong>简介：以编程方式仅从一个文件中构建KieModule。POM和模型都是默认的。这是开箱即用的最快方法，但是不应将其添加到Maven存储库中。</strong></p></li></ul></div><div class="example"><strong><a id="d0e4091"></a><p class="title"><strong>示例4.59构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></strong></div><strong><br class="example-break"><p>这将以编程方式构建KieModule。它填充表示ReleaseId和kmodule.xml的模型，并添加相关资源。从ReleaseId生成pom.xml。</p><div class="example"><a id="d0e4098"></a><p class="title"><strong>示例4.60使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();
KieFileSystem kfs = ks.newKieFileSystem();

kfs.write("src/main/resources/org/kie/example5/HAL5.drl", getRule());

KieBuilder kb = ks.newKieBuilder(kfs);

kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
    throw new RuntimeException("Build Errors:\n" + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(kr.getDefaultReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal("out", out);

kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div><div class="section" title="4.2.6.10。使用元模型以编程方式构建KieModule"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e4103"></a> 4.2.6.10。使用元模型以编程方式构建KieModule</strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>项目：kiemoduelmodel-example</strong></p></li><li class="listitem"><p><strong>简介：通过创建kieModule的kmodule.xml元模型资源，以编程方式构建它。</strong></p></li></ul></div><div class="example"><strong><a id="d0e4113"></a><p class="title"><strong>示例4.61构建和安装-Maven</strong></p><div class="example-contents"><pre><code class="no-highlight">mvn install</code></pre></div></strong></div><strong><br class="example-break"><p>这将以编程方式构建KieModule。它填充表示ReleaseId和kmodule.xml的模型，并添加相关资源。从ReleaseId生成pom.xml。</p><div class="example"><a id="d0e4120"></a><p class="title"><strong>示例4.62使用并运行-Java</strong></p><div class="example-contents"><pre><code class="language-java">KieServices ks = KieServices.Factory.get();
KieFileSystem kfs = ks.newKieFileSystem();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile("named-kiesession"));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile("kiebase-inclusion"));

ReleaseId rid = ks.newReleaseId("org.drools", "kiemodulemodel-example", "6.0.0-SNAPSHOT");
kfs.generateAndWritePomXML(rid);

KieModuleModel kModuleModel = ks.newKieModuleModel();
kModuleModel.newKieBaseModel("kiemodulemodel")
            .addInclude("kiebase1")
            .addInclude("kiebase2")
            .newKieSessionModel("ksession6");

kfs.writeKModuleXML(kModuleModel.toXML());
kfs.write("src/main/resources/kiemodulemodel/HAL6.drl", getRule());

KieBuilder kb = ks.newKieBuilder(kfs);
kb.setDependencies(ex1Res, ex2Res);
kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
    throw new RuntimeException("Build Errors:\n" + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(rid);

KieSession kSession = kContainer.newKieSession("ksession6");
kSession.setGlobal("out", out);

Object msg1 = createMessage(kContainer, "Dave", "Hello, HAL. Do you read me, HAL?");
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, "Dave", "Open the pod bay doors, HAL.");
kSession.insert(msg2);
kSession.fireAllRules();

Object msg3 = createMessage(kContainer, "Dave", "What's the problem?");
kSession.insert(msg3);
kSession.fireAllRules();</code></pre></div></div><br class="example-break"></strong></div></div></div><div class="section" title="4.3。安全"><div class="titlepage"><div><div><h2 class="title"><strong><a id="KIESecuritySection"></a> 4.3。安全</strong></h2></div></div></div><div class="section" title="4.3.1。安全经理"><div class="titlepage"><div><div><h3 class="title"><strong><a id="SecurityManager"></a> 4.3.1。安全经理</strong></h3></div></div></div><p><strong>KIE引擎是一个使用大量声明性抽象和隐喻（例如规则，流程，决策表等）对业务行为进行建模和执行的平台。</strong></p><p><strong>很多时候，这些隐喻的创作是由第三方小组完成的，无论是同一公司内部的不同小组，合伙公司的小组，还是互联网上的匿名第三方。</strong></p><p><strong>规则和流程旨在执行任意代码以完成其工作，但是在这种情况下，可能有必要限制它们可以做什么。例如，不太可能允许创建类加载器的规则（可能使系统受到攻击的规则），并且当然不应允许它调用<code class="code">System.exit()</code> 。</strong></p><p><strong>Java平台提供了一个非常全面且定义明确的安全框架，该框架允许用户定义有关系统可以执行的操作的策略。KIE平台利用该框架，并允许应用程序开发人员定义特定的策略，以应用于用户提供的代码的任何执行，无论是在规则，流程，工作项处理程序等中。</strong></p><div class="section" title="4.3.1.1。如何定义KIE策略"><div class="titlepage"><div><div><h4 class="title"><strong><a id="HowToDefineKiePolicy"></a> 4.3.1.1。如何定义KIE策略</strong></h4></div></div></div><p><strong>规则和流程可以在非常严格的权限下运行，但是引擎本身需要执行许多复杂的操作才能正常工作。例如：需要创建类加载器，读取系统属性，访问文件系统等。</strong></p><p><strong>但是，一旦安装了安全管理器，它将根据定义的策略将限制应用于在JVM中执行的所有代码。因此，KIE允许用户定义两个不同的策略文件：一个用于引擎本身，一个用于部署到引擎中并由引擎执行的资产。</strong></p><p><strong>设置环境的一种简单方法是为引擎本身提供非常宽松的策略，同时为规则和流程提供受约束的策略。</strong></p><p><strong>策略文件遵循Java文档中描述的标准策略文件语法。有关更多详细信息，请参见：</strong></p><p><strong>http://docs.oracle.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax</strong></p><p><strong>引擎的许可策略文件如下所示：</strong></p><div class="example"><strong><a id="d0e4158"></a><p class="title"><strong>示例4.63一个示例engine.policy文件</strong></p><div class="example-contents"><pre><code class="no-highlight">grant { 
    permission java.security.AllPermission;
}</code></pre></div></strong></div><strong><br class="example-break"><p>规则的示例安全策略可以是：</p><div class="example"><a id="d0e4165"></a><p class="title"><strong>示例4.64一个示例rules.policy文件</strong></p><div class="example-contents"><pre><code class="no-highlight">grant { 
    permission java.util.PropertyPermission "*", "read"; 
    permission java.lang.RuntimePermission "accessDeclaredMembers"; 
}</code></pre></div></div><br class="example-break"><p>请注意，根据规则和流程的意图，可能需要授予更多权限，例如访问文件系统，数据库中的文件等。</p><p>为了使用这些策略文件，只需将这些文件作为JVM的参数来执行应用程序。需要三个参数：</p><p>
      </p><div class="table"><a id="d0e4176"></a><p class="title"><strong>表4.3。参量</strong></p><div class="table-contents"><table border="1" summary="Parameters"><colgroup><col width="1.0*" class="c1"><col width="1.0*" class="c2"></colgroup><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>
                <p>-Djava.security.manager</p>
              </td><td>启用安全管理器</td></tr><tr><td>
                <p>-Djava.security.policy =<jvm_policy_file></jvm_policy_file></p>
              </td><td>定义要应用于整个应用程序（包括引擎）的全局策略文件</td></tr><tr><td>
                <p>-Dkie.security.policy =<kie_policy_file></kie_policy_file></p>
              </td><td>定义要应用于规则和流程的策略文件</td></tr></tbody></table></div></div><p><br class="table-break">
    </p><p>例如：</p><p><code class="code">java -Djava.security.manager -Djava.security.policy=global.policy -Dkie.security.policy=rules.policy foo.bar.MyApp</code></p><p></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>在容器内执行引擎时，请使用容器的文档以了解如何配置安全管理器以及如何定义全局安全策略。如上所述定义kie安全策略并设置<code class="code">kie.security.policy</code>系统属性，以便配置引擎以使用它。</p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>请注意，除非配置了安全管理器，否则<code class="code">kie.security.policy</code>将被忽略。</p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>安全管理器在JVM中具有较高的性能影响。强烈建议不要对具有严格性能要求的应用程序使用安全管理器。另一种选择是使用其他安全性程序，例如在测试和部署之前对规则/过程进行审核，以防止将恶意代码部署到环境中。</p></div></strong></div></div></div></div></div><div class="part" title="第三部分Drools运行时和语言"><div class="titlepage"><div><div><h1 class="title"><strong><a id="d0e4235"></a>第三部分Drools运行时和语言</strong></h1></div></div></div><div class="partintro" title="Drools运行时和语言"><div></div><p><strong>Drools是功能强大的混合推理系统。</strong></p><div class="toc"><p><strong><strong>目录</strong></strong></p><dl><dt><strong><span class="chapter"><a href="#HybridReasoningChapter">5，混合推理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4244">5.1。人工智能</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4247">5.1.1。一点历史</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4333">5.1.2。知识表示与推理</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4344">5.1.3。规则引擎和生产规则系统（PRS）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4429">5.1.4。混合推理系统（HRS）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4462">5.1.5。专家系统</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4486">5.1.6。推荐读物</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#ReteOO">5.2。Rete算法</a></span></strong></dt><dt><strong><span class="section"><a href="#ReteOOSection">5.3。ReteOO算法</a></span></strong></dt><dt><strong><span class="section"><a href="#PHREAK">5.4。PHREAK算法</a></span></strong></dt></dl></dd><dt><strong><span class="chapter"><a href="#d0e4870">6。用户指南</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4873">6.1。基础</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4876">6.1.1。无状态知识会议</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5038">6.1.2。有状态知识会议</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5213">6.1.3。方法与规则</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5245">6.1.4。交叉产品</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5270">6.2。执行控制</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5273">6.2.1。议程</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5306">6.2.2。规则匹配和冲突集。</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5518">6.3。推理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5521">6.3.1。公交通行证示例</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5589">6.4。逻辑对象的真理维护</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5596">6.4.1。总览</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5713">6.5。电子表格中的决策表</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5725">6.5.1。何时使用决策表</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5743">6.5.2。总览</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5785">6.5.3。决策表如何工作</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5871">6.5.4。电子表格语法</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6396">6.5.5。创建和集成基于电子表格的决策表</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6417">6.5.6。在决策表中管理业务规则</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6464">6.5.7。规则模板</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e6567">6.6。记录中</a></span></strong></dt></dl></dd><dt><strong><span class="chapter"><a href="#d0e6607">7。跑步</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e6612">7.1。KieRuntime</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e6615">7.1.1。入口点</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6790">7.1.2。规则运行时</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6849">7.1.3。StatefulRuleSession</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e6889">7.2。议程</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e6926">7.2.1。解决冲突</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6942">7.2.2。议程集团</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6974">7.2.3。激活组</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6990">7.2.4。RuleFlowGroup</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7006">7.3。事件模型</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7084">7.4。StatelessKieSession</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7214">7.4.1。顺序模式</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7279">7.5。规则执行模式</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7286">7.5.1。被动模式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7301">7.5.2。主动模式</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7377">7.6。传播方式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7429">7.7。命令和CommandExecutor</a></span></strong></dt></dl></dd><dt><strong><span class="chapter"><a href="#DroolsLanguageReferenceChapter">8。规则语言参考</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7602">8.1。总览</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7610">8.1.1。规则文件</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7643">8.1.2。什么是规则</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7679">8.2。关键词</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7874">8.3。评论</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7879">8.3.1。单行注释</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7889">8.3.2。多行评论</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7902">8.4。错误讯息</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7907">8.4.1。讯息格式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7938">8.4.2。错误信息说明</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8093">8.4.3。其他讯息</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e8098">8.5。包</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e8121">8.5.1。进口</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8135">8.5.2。全球</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e8178">8.6。功能</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8212">8.7。类型声明</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e8240">8.7.1。声明新类型</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8397">8.7.2。声明元数据</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8758">8.7.3。声明现有类型的元数据</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8801">8.7.4。声明类型的参数化构造函数</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8825">8.7.5。非类型安全类</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8830">8.7.6。从应用程序代码访问声明的类型</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8879">8.7.7。类型声明“扩展”</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e8911">8.7.8。特质</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e9154">8.8。规则</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e9196">8.8.1。规则属性</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e9356">8.8.2。计时器和日历</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e9456">8.8.3。左侧语法（当）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e11687">8.8.4。右侧（然后）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e11934">8.8.5。有条件的命名后果</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e11959">8.8.6。关于自动装箱和原始类型的注释</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#QuerySection">8.9。询问</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12041">8.10。领域特定语言</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12051">8.10.1。何时使用DSL</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12058">8.10.2。DSL基础</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12127">8.10.3。向事实添加约束</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12171">8.10.4。开发DSL</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12184">8.10.5。DSL和DSLR参考</a></span></strong></dt></dl></dd></dl></dd><dt><strong><span class="chapter"><a href="#DroolsComplexEventProcessingChapter">9。复杂事件处理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12392">9.1。复杂事件处理</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12443">9.2。流口水融合</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12545">9.3。事件语义</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12597">9.4。事件处理模式</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12604">9.4.1。云模式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12635">9.4.2。流模式</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e12715">9.5。会话时钟</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12746">9.5.1。可用时钟实现</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e12773">9.6。滑动窗</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12786">9.6.1。滑动时间窗</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12809">9.6.2。滑动长度窗</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12845">9.6.3。窗口声明</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e12866">9.7。流支持</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12888">9.7.1。声明和使用入口点</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e12922">9.8。事件的内存管理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e12940">9.8.1。显式过期偏移</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e12958">9.8.2。推断的过期时间偏移</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e12978">9.9。时间推理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e13050">9.9.1。时间运算符</a></span></strong></dt></dl></dd></dl></dd><dt><strong><span class="chapter"><a href="#ExperimentalFeaturesChapter">10。实验特征</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e13520">10.1。声明性议程</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e13581">10.2。使用OOPath浏览对象图</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e13688">10.2.1。反应式和非反应式OOPath</a></span></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第五章混合推理"><div class="titlepage"><div><div><h2 class="title"><strong><a id="HybridReasoningChapter"></a>第五章混合推理</strong></h2></div></div></div><div class="toc"><dl><dt><strong><span class="section"><a href="#d0e4244">5.1。人工智能</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4247">5.1.1。一点历史</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4333">5.1.2。知识表示与推理</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4344">5.1.3。规则引擎和生产规则系统（PRS）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4429">5.1.4。混合推理系统（HRS）</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4462">5.1.5。专家系统</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e4486">5.1.6。推荐读物</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#ReteOO">5.2。Rete算法</a></span></strong></dt><dt><strong><span class="section"><a href="#ReteOOSection">5.3。ReteOO算法</a></span></strong></dt><dt><strong><span class="section"><a href="#PHREAK">5.4。PHREAK算法</a></span></strong></dt></dl></div><div class="section" title="5.1。人工智能"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e4244"></a> 5.1。人工智能</strong></h2></div></div></div><div class="section" title="5.1.1。一点历史"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4247"></a> 5.1.1。一点历史</strong></h3></div></div></div><p><strong>在过去的几十年中， <em class="firstterm">人工智能</em> （AI）成为了一个不受欢迎的名词，它以著名的<a class="link" href="http://en.wikipedia.org/wiki/AI_winter">“ AI Winter”</a>而闻名。有大量科学家和工程师在寻找资金，但从未达到期望，导致许多项目失败。<a class="link" href="http://en.wikipedia.org/wiki/Thinking_Machines_Corporation">思维机器公司</a>和<a class="link" href="http://en.wikipedia.org/wiki/Fifth-generation_computer">第五代计算机</a> （5GP）项目可能是当时最好的例证。</strong></p><p><strong>1990年，Thinking Machines Corporation是领先的AI公司之一，销售额近6500万美元。这是它的小册子的报价：</strong></p><p><strong><span class="quote">“ <span class="quote">有一天，我们将建造一个思维机器。这将是一台真正的智能机器。可以看到，听到和讲话的人。一台让我们感到骄傲的机器。</span> ”</span></strong></p><p><strong>然而5年后，它根据第11章申请了破产保护。网站inc.com上有一篇引人入胜的文章，标题为<a class="link" href="http://www.inc.com/magazine/19950915/2622.html">“思维机器的兴衰”</a> 。本文介绍了该行业的发展以及与Thinking Machines和<a class="link" href="http://en.wikipedia.org/wiki/DARPA">DARPA的</a>友好关系如何使市场过热，甚至崩溃。它解释了商业如何以及为什么从人工智能转向更实用的数字运算超级计算机。</strong></p><p><strong>第五代计算机项目是在日本投资4亿美元建造下一代计算机的项目。阀门（或电子管）是第一代，晶体管是第二代，集成电路是第三代，最后是微处理器是第四代。第五台旨在成为能够有效实现人工智能的机器。该项目刺激了与英国和美国的“军备竞赛”，这导致了大部分AI泡沫。5GP将通过<em class="firstterm">Prolog</em>提供大量的多CPU并行处理硬件以及功能强大的知识表示和推理软件；一种<em class="firstterm">专家系统</em> 。到1992年，该项目被视为失败并被取消。它是Prolog规模最大，最引人注目的商业企业，许多失败都与试图在多CPU硬件上同时运行基于逻辑的编程语言并获得有效结果的问题有关。有人认为5GP项目的失败使Prolog受到了污染，并将其降级到学术界，请参阅John C. Dvorak撰写的<a class="link" href="http://www.dvorak.org/blog/whatever-happened-to-prolog/">“ Prolog发生的</a>一切<a class="link" href="http://www.dvorak.org/blog/whatever-happened-to-prolog/">”</a> 。</strong></p><p><strong>然而，尽管研究经费枯竭，并且AI一词的使用减少了，但许多绿芽以学科特定的名称种植并更安静地继续进行： <em class="firstterm">认知系统</em> ， <em class="firstterm">机器学习</em> ， <em class="firstterm">智能系统</em> ， <em class="firstterm">知识表示和推理</em> 。这些分支的分支随后进入商业系统，例如<em class="firstterm">业务规则管理系统</em> （BRMS）市场中的专家系统。</strong></p><p><strong>在过去的20年中，基于<em class="firstterm">命令的</em> ，基于系统的语言，诸如C，C ++，Java和C＃/。Net之类的语言占据了主导地位，这是由于这些语言的实用性以及在商品硬件上以良好性能运行的能力所致。但是，许多人认为，由于硬件功能和AI研究的不断发展，AI领域正在复兴。2005年，希瑟·黑文斯坦（Heather Havenstein）撰写了<a class="link" href="http://www.computerworld.com/s/article/99691/Spring_comes_to_AI_winter">《春季来临AI冬季》</a> ，概述了这种复兴的情况。Norvig和Russel专门讨论了哪些因素可以使该行业克服其问题以及由此产生的研究结果：</strong></p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>近年来，人工智能工作的内容和方法都发生了革命。现在，比起提出全新的理论，以现有的理论为基础，以严格的定理或严格的实验证据为基础的主张，而不是以直觉为基础，并表明其与现实世界的应用相关，而不是与玩具的实例相关，这种情况更为普遍。
        </p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">- <span class="attribution">人工智能：一种现代方法</span></td></tr></tbody></table></div><p><strong><em class="firstterm">计算机视觉</em> ， <em class="firstterm">神经网络</em> ， <em class="firstterm">机器学习</em>以及<em class="firstterm">知识表示和推理</em> （KRR）在实现商业环境中取得了长足的进步。例如，基于视觉的系统现在可以以强大的识别能力完全绘制地图并导航其环境。结果，我们现在有自动驾驶汽车即将进入商业市场。基于描述逻辑的<em class="firstterm">本体</em>研究提供了非常丰富的语义来表示我们的世界。诸如tableaux算法之类的算法使在大型复杂本体中有效使用那些丰富的语义成为可能。早期的KRR系统，例如5GP中的Prolog，受到语义能力的限制和这些本体大小的内存限制的困扰。</strong></p></div><div class="section" title="5.1.2。知识表示与推理"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4333"></a> 5.1.2。知识表示与推理</strong></h3></div></div></div><p><strong>在《小历史》中，关于人工智能是一个更广泛的主题，并涉及知识表示和推理（KRR）以及专家系统，稍后我将再回到专家系统。</strong></p><p><strong>KRR是关于我们如何以符号形式表示我们的知识，即我们如何描述事物。推理是关于我们如何利用这些知识进行思考的行为。基于系统的面向对象的语言（例如C ++，Java和C＃）具有称为类的数据定义，用于描述建模实体的组成和行为。在Java中，我们将这些描述的事物的示例称为bean或实例。然而，那些分类系统受到限制以确保计算效率。多年来，研究人员已经开发出越来越复杂的方法来代表我们的世界。你们中的许多人可能已经听说过OWL（网络本体语言）。在理论上可以表示的内容与实际可以及时使用的计算方法之间始终存在差距，这就是OWL具有从Lite到Full的不同子语言的原因。认为没有任何推理系统可以支持OWL Full。但是，算法的进步继续缩小了差距，并提高了推理引擎的可表达性。</strong></p><p><strong>这些系统如何进行思考也有许多方法。您可能已经听过讨论，将被动式和数据驱动的前向链与被动式和查询驱动的后向链的优缺点进行了比较。存在许多其他类型的推理技术，每种推理技术都扩大了我们可以声明式解决的问题的范围。仅列举一些：不完善的推理（模糊逻辑，确定性因素），不可行的逻辑，信念系统，时间推理和相关性。您无需了解所有这些术语即可了解和使用Drools。他们只是在这里提供有关研究主题范围的想法，实际上范围要广泛得多，并且随着研究人员不断推陈出新而不断发展。</strong></p><p><strong>KRR通常被称为人工智能的核心。即使使用诸如神经网络之类的生物学方法来对大脑进行建模并且更多地涉及模式识别而不是思考，它们仍然基于KRR理论。我对Drools的最初尝试是面向工程的，因为我没有经过正式的培训或对KRR的理解。学习KRR使我获得了更广阔的理论背景。让我更好地了解我所做的事情和我要去的地方，因为这几乎为我们的Drools研发提供了理论上的支持。这确实是一个广泛而有趣的主题，它将为那些花时间学习的人带来红利。我知道它确实为我做了。Bracham和Levesque撰写了一篇开创性的著作，称为“知识表示和推理”，这对任何想要建立坚实基础的人来说都是必读的。我还建议Russel和Norvig着书“人工智能，一种现代方法”，其中也涉及KRR。</strong></p></div><div class="section" title="5.1.3。规则引擎和生产规则系统（PRS）"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4344"></a> 5.1.3。规则引擎和生产规则系统（PRS）</strong></h3></div></div></div><p><strong>现在，我们已经简要介绍了AI的历史，并了解到AI的核心是围绕KRR形成的。我们已经证明，KRR是一个广泛而有趣的主题，它构成了推动Drools研发的理论的主体。</strong></p><p><strong>规则引擎是将KRR功能提供给开发人员的计算机程序。从高层次来看，它包含三个组成部分：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>本体论</strong></p></li><li class="listitem"><p><strong>规则</strong></p></li><li class="listitem"><p><strong>数据</strong></p></li></ul></div><p><strong>如前所述，本体是我们用于“事物”的表示模型。它可以使用记录或Java类或基于OWL的成熟本体。规则执行推理，即，它们有助于“思考”。规则和本体之间的区别与基于OWL的本体（其丰富性基于规则）有点模糊。</strong></p><p><strong>术语“规则引擎”非常模棱两可，因为它可以是使用任何形式的规则的任何系统，这些规则可以应用于数据以产生结果。这包括简单的系统，例如表单验证和动态表达式引擎。马尔科姆·奇斯霍尔姆（Malcolm Chisholm）的著作《如何构建业务规则引擎》（2004）就是这种歧义的例证。这本书实际上是关于如何构建和更改数据库架构以保存验证规则的。然后，这本书展示了如何从那些验证规则生成Visual Basic代码来验证数据输入。虽然完全有效，但这与我们所讨论的完全不同。</strong></p><p><strong>Drools作为一种称为生产规则系统（PRS）的特殊类型的规则引擎开始了生活，它基于Rete算法（通常发音为两个音节，例如REH-te或RAY-tay）。Rete算法是由Charles Forgy在1974年开发的，它构成了生产规则系统的大脑，并且能够扩展到大量规则和事实。生产规则是一个由两部分组成的结构：引擎将事实和数据与生产规则（也称为生产或仅称为规则）进行匹配，以推断出导致采取行动的结论。</strong></p><pre><code class="language-java">when
    &lt;conditions&gt;
then
    &lt;actions&gt;;</code></pre><p><strong>将新事实或现有事实与生产规则进行匹配的过程称为<em class="firstterm">模式匹配</em> <a id="d0e4373" class="indexterm"></a> ，由<em class="firstterm">推理引擎</em>执行<a id="d0e4379" class="indexterm"></a> 。响应于数据更改而执行的操作，例如数据库触发器；我们说这是<em class="firstterm">数据驱动的</em> <a id="d0e4385" class="indexterm"></a>推理方法。这些动作本身可以更改数据，而这些数据又可以与其他规则匹配，从而触发它们。这称为<a id="d0e4389" class="indexterm"></a>正向链</strong></p><p><strong>Drools 5.x实现并扩展<em class="firstterm">Rete</em> <a id="d0e4397" class="indexterm"></a>算法。这种扩展的Rete算法称为<em class="firstterm">ReteOO</em> <a id="d0e4403" class="indexterm"></a> ，表明Drools具有面向对象系统的Rete算法的增强和优化实现。其他基于Rete的引擎（如RetePlus和Rete III）也具有针对其对Rete的专有增强功能的营销条款。 Robert B. Doorenbos的论文“ Rete / UL”在“大型学习系统的生产匹配”（1995年）中介绍了最常见的增强功能。 Drools 6.x引入了一种新的名为<em class="firstterm">PHREAK的</em>惰性算法<a id="d0e4409" class="indexterm"></a> ;这将在PHEAK算法部分中详细介绍。</strong></p><p><strong>规则存储在<a id="d0e4415" class="indexterm"></a>生产记忆和推理引擎匹配的事实都保留在<a id="d0e4419" class="indexterm"></a>工作记忆。事实被断言到工作存储器中，然后可以在其中进行修改或收回。具有大量规则和事实的系统可能会导致许多规则对于相同的事实断言是正确的。据说这些规则是冲突的。议程使用“冲突解决”策略管理这些冲突规则的执行顺序。</strong></p><div class="figure"><strong><a id="d0e4423"></a><p class="title"><strong>图5.1。生产规则系统的高级视图</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/rule-engine-inkscape.png" align="middle" alt="生产规则系统的高级视图"></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="5.1.4。混合推理系统（HRS）"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4429"></a> 5.1.4。混合推理系统（HRS）</strong></h3></div></div></div><p><strong>您可能已经阅读了讨论正向链（反应式和数据驱动）或反向链（被动查询）优点的讨论。这是对这两种主要推理类型的简要说明。</strong></p><p><strong>正向链是“数据驱动的”，因此是反动的，事实被断言存入工作记忆中，这导致一个或多个规则同时为真，并计划由议程执行。简而言之，我们从一个事实开始，它通过规则传播，最后得出结论。</strong></p><div class="figure"><strong><a id="d0e4436"></a><p class="title"><strong>图5.2。正向链接</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Forward_Chaining.png" align="middle" alt="正向链接"></div></div></strong></div><strong><br class="figure-break"><p>向后链接是“目标驱动”的，这意味着我们从引擎试图满足的结论开始。如果不能，则搜索可以满足的结论。这些称为子目标，将有助于满足当前目标的某些未知部分。它会继续执行此过程，直到证明初始结论或没有更多子目标为止。Prolog是向后链接引擎的示例。Drools还可以进行反向链接，这称为派生查询。</p><div class="figure"><a id="d0e4444"></a><p class="title"><strong>图5.3。向后链接</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Backward_Chaining.png" align="middle" alt="向后链接"></div></div></div><br class="figure-break"><p>从历史上看，您将不得不在OPS5（向前）或Prolog（向后）等系统之间进行选择。如今，许多现代系统都提供两种类型的推理功能。还有许多其他类型的推理技术，每种技术都扩大了我们可以声明式解决的问题的范围。仅列举一些：不完善的推理（模糊逻辑，确定性因素），不可行的逻辑，信念系统，时间推理和相关性。现代系统正在将这些功能（未列出的其他功能）合并，以创建<em class="firstterm">混合推理系统</em> （HRS）。</p><p>当Drools最初是作为PRS时，5.x引入了Prolog样式向后链接推理以及一些功能编程样式。因此，在描述Drools时，我们现在更喜欢混合推理系统。
    </p><p>Drools当前提供清晰的推理，但是不完善的推理几乎已经准备就绪。最初，这将是模糊逻辑的不完美推理；稍后，我们将添加对其他类型不确定性的支持。基于OWL的本体论推理的工作也在进行中，它将与我们的<em class="firstterm">特征</em>系统集成。我们还将继续提高我们的功能编程能力。</p></strong></div><div class="section" title="5.1.5。专家系统"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4462"></a> 5.1.5。专家系统</strong></h3></div></div></div><p><strong>您会经常听到术语“ <em class="firstterm">专家系统”，</em>它们是指<em class="firstterm">生产规则系统</em>或<em class="firstterm">类似Prolog</em>的系统。尽管这通常是可以接受的，但是在技术上是不正确的，因为它们是用来构建专家系统的框架，而不是专家系统本身。一旦有了代表领域的本体模型，并且有了知识获取和解释的便利，它就会成为专家系统。
    </strong></p><p><strong><em class="firstterm">Mycin</em>是最著名的专家系统，建于70年代。它在学术文献中仍然被大量报道，例如Peter Jackson推荐的书“ Expert Systems”。</strong></p><div class="figure"><strong><a id="d0e4480"></a><p class="title"><strong>图5.4。专家系统的早期历史</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/expertsytem_history.png" align="middle" alt="专家系统的早期历史"></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="5.1.6。推荐读物"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4486"></a> 5.1.6。推荐读物</strong></h3></div></div></div><p><strong><span class="bold"><strong>通用AI，KRR和专家系统书籍</strong></span></strong></p><p><strong>对于那些希望在KRR和专家系统方面拥有强大理论背景的人，我强烈建议您阅读以下书籍。对于任何人的书架来说，“人工智能：一种现代方法”都是必不可少的。</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>专家系统简介</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>彼得·杰克逊</strong></p></li></ul></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>专家系统：原理与程序设计</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>约瑟夫·C·贾拉塔诺，加里·D·莱利</strong></p></li></ul></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>知识表示与推理</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>罗纳德·J·布拉奇曼，赫克托·J·莱维斯克</strong></p></li></ul></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>人工智能：一种现代方法。</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>斯图尔特·罗素（Stuart Russell）和彼得·诺维（Peter Norvig）</strong></p></li></ul></div></li></ul></div><div class="figure"><strong><a id="d0e4526"></a><p class="title"><strong>图5.5。推荐读物</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/book_recommendations.png" align="middle" alt="推荐读物"></div></div></strong></div><strong><br class="figure-break"><p><span class="bold"><strong>文件</strong></span></p><p>以下是一些推荐的论文，涵盖了规则引擎研究中的有趣领域：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>大型学习系统的生产匹配：Rete / UL（1993）</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>罗伯特·B·多伦博斯</p></li></ul></div></li><li class="listitem"><p>Rete模式匹配的进展</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Marshall Schor，Timothy P.Daly，Ho Soo Lee，Beth R.Tibbitts（AAAI 1986）</p></li></ul></div></li><li class="listitem"><p>面向集合的比赛</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>阿努拉格·阿查里亚（Anurag Acharya）和米琳德·坦贝（Milind Tambe）（1993）</p></li></ul></div></li><li class="listitem"><p>飞跃算法</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>唐·巴特里（1990）</p></li></ul></div></li><li class="listitem"><p>Gator：用于活动数据库规则条件测试的优化区分网络</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>埃里克·汉森（Eric Hanson），穆罕默德·哈桑（Mohammed S.Hasan）（1993）</p></li></ul></div></li></ul></div><p><span class="bold"><strong>流口水的书</strong></span></p><p>当前有三本Drools书籍，全部来自Packt Publishing。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>JBoss Drools业务规则</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>保罗·布朗</p></li></ul></div></li><li class="listitem"><p>Drools JBoss Rules 5.0开发人员指南</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>巴厘岛米哈尔（Michal Bali）</p></li></ul></div></li><li class="listitem"><p>Drools开发人员食谱</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>卢卡斯·阿马多尔（Lucas Amador）</p></li></ul></div></li></ul></div><div class="figure"><a id="d0e4600"></a><p class="title"><strong>图5.6。推荐读物</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/drools_book_recommendations.png" align="middle" alt="推荐读物"></div></div></div><br class="figure-break"></strong></div></div><div class="section" title="5.2。Rete算法"><div class="titlepage"><div><div><h2 class="title"><strong><a id="ReteOO"></a> 5.2。Rete算法</strong></h2></div></div></div><p><strong><span class="emphasis"><em>Rete</em></span>算法是由Charles Forgy博士发明的，并在1978-79年的博士论文中得到了证明。该论文的简化版本于1982年发布（ <a class="link" href="http://citeseer.ist.psu.edu/context/505087/0">http://citeseer.ist.psu.edu/context/505087/0</a> ）。拉丁词“ rete”的意思是“网”或“网络”。Rete算法可以分为两部分：规则编译和运行时执行。</strong></p><p><strong>编译算法描述了如何处理生产内存中的规则以生成有效的区分网络。用非技术术语来说，鉴别网络用于过滤通过网络传播的数据。网络顶部的节点将具有许多匹配项，并且随着我们沿着网络下行，匹配项将更少。网络的最底层是终端节点。在Forgy博士1982年的论文中，他描述了4个基本节点：根，1输入，2输入和终端。</strong></p><div class="figure"><strong><a id="d0e4619"></a><p class="title"><strong>图5.7。节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Rete_Nodes.png" align="middle" alt="节点"></div></div></strong></div><strong><br class="figure-break"><p>根节点是所有对象进入网络的地方。从那里，它立即转到ObjectTypeNode。ObjectTypeNode的目的是确保引擎不会完成超出其所需工作的工作。例如，假设我们有2个对象：客户和订单。如果规则引擎尝试针对每个对象评估每个节点，则将浪费大量的周期。为了使事情高效，引擎应仅将对象传递给与对象类型匹配的节点。最简单的方法是创建一个ObjectTypeNode并使所有1输入和2输入节点都从该节点继承。这样，如果应用程序断言了一个新帐户，它将不会传播到Order对象的节点。在Drools中，当一个对象被断言时，它通过在HashMap中从该对象的Class中进行查找来检索一个有效的ObjectTypesNodes列表。如果此列表不存在，它将扫描所有ObjectTypeNodes，以查找有效的匹配项并将其缓存在列表中。这使Drools能够与任何与<code class="literal">instanceof</code>校验。</p><div class="figure"><a id="d0e4630"></a><p class="title"><strong>图5.8。ObjectTypeNodes</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Object_Type_Nodes.png" align="middle" alt="ObjectTypeNodes"></div></div></div><br class="figure-break"><p>ObjectTypeNodes可以传播到AlphaNodes，LeftInputAdapterNodes和BetaNodes。AlphaNode用于评估文字条件。尽管1982年的论文仅涉及平等条件，但许多RETE实现仍支持其他操作。例如， <code class="code">Account.name == "Mr Trout"</code>是一个字面条件。当规则对单个对象类型具有多个文字条件时，它们将链接在一起。这意味着，如果应用程序断言一个Account对象，则它必须先满足第一个文字条件，然后才能进行下一个AlphaNode。在Forgy博士的论文中，他将这些称为IntraElement条件。下图显示了Cheese的AlphaNode组合（name ==“ cheddar”，strength ==“ strong”）：</p><div class="figure"><a id="d0e4641"></a><p class="title"><strong>图5.9。Alpha节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Alpha_Nodes.png" align="middle" alt="Alpha节点"></div></div></div><br class="figure-break"><p>Drools通过使用哈希优化从ObjectTypeNode到AlphaNode的传播来扩展Rete。每次将AlphaNode添加到ObjectTypeNode时，它将文字值添加为HashMap的键，并使用AlphaNode作为值。当新实例进入ObjectType节点时，无需传播到每个AlphaNode，而是可以从HashMap中检索正确的AlphaNode，从而避免不必要的文字检查。</p><p>有两个两个输入节点，JoinNode和NotNode，它们都是BetaNode的类型。BetaNode用于将2个对象及其字段进行相互比较。对象可以是相同或不同的类型。按照惯例，我们将两个输入称为左和右。BetaNode的左输入通常是一个对象列表。在Drools中，这是一个元组。正确的输入是单个对象。两个节点可用于实现“存在”检查。BetaNode也有内存。左边的输入称为Beta内存，并记住所有传入的元组。正确的输入称为Alpha存储器，并记住所有传入的对象。Drools通过在BetaNode上执行索引来扩展Rete。例如，如果我们知道BetaNode正在对String字段执行检查，那么当每个对象进入时，我们都可以对该String值进行哈希查找。这意味着当事实从相反的方向输入时，我们将遍历所有事实以查找有效联接，而不是遍历所有事实以查找有效联接。在任何时候都可以找到有效的联接，将元组与对象联接；这称为部分匹配；然后传播到下一个节点。</p><div class="figure"><a id="d0e4651"></a><p class="title"><strong>图5.10。JoinNode</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Join_Node.png" align="middle" alt="JoinNode"></div></div></div><br class="figure-break"><p>为了使第一个对象（在上述情况下为Cheese）进入网络，我们使用LeftInputNodeAdapter-这将一个对象作为输入并传播单个对象元组。</p><p>终端节点用于指示符合所有条件的单个规则。在这一点上，我们说规则已经完全匹配。具有“或”条件析取连接词的规则会为每个可能的逻辑分支生成子规则。因此一个规则可以有多个终端节点。</p><p>Drools还执行节点共享。许多规则重复相同的模式，并且节点共享使我们能够折叠这些模式，从而不必为每个实例重新评估它们。以下两个规则共享第一个模式，而不是最后一个：</p><pre><code class="no-highlight">rule
when
    Cheese( $cheddar : name == "cheddar" )
    $person : Person( favouriteCheese == $cheddar )
then
    System.out.println( $person.getName() + " likes cheddar" );
end</code></pre><pre><code class="no-highlight">rule
when
    Cheese( $cheddar : name == "cheddar" )
    $person : Person( favouriteCheese != $cheddar )
then
    System.out.println( $person.getName() + " does not like cheddar" );
end</code></pre><p>如下所示，已编译的Rete网络显示了Alpha节点是共享的，但Beta节点不是共享的。每个beta节点都有自己的TerminalNode。如果第二种模式相同，那么它也将被共享。</p><div class="figure"><a id="d0e4669"></a><p class="title"><strong>图5.11。节点共享</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Node_Sharing.png" align="middle" alt="节点共享"></div></div></div><br class="figure-break"></strong></div><div class="section" title="5.3。ReteOO算法"><div class="titlepage"><div><div><h2 class="title"><strong><a id="ReteOOSection"></a> 5.3。ReteOO算法</strong></h2></div></div></div><p><strong><span class="emphasis"><em>ReteOO</em></span>是在3、4和5系列发行版中开发的。它采用RETE算法并应用了众所周知的增强功能，现有的学术文献都涵盖了所有这些增强功能：</strong></p><p><strong>节点共享</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>共享同时应用于Alpha和Beta网络。Beta网络共享始终来自根模式。</strong></p></li></ul></div><p><strong>字母索引</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>具有许多子级的Alpha节点使用哈希查找机制，以避免测试每个结果。</strong></p></li></ul></div><p><strong>Beta索引</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>Join，Not和Exist节点使用哈希索引它们的内存。这减少了相等检查的联接尝试。最近，范围索引已添加到“不存在”中。</strong></p></li></ul></div><p><strong>基于树的图</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>联接匹配不包含对其父项或子项匹配的任何引用。删除将不得不再次重新计算所有联接匹配，这涉及到重新创建所有那些联接匹配对象，以便能够找到应删除元组的网络部分。这称为对称传播。树形图提供了父级和子级引用，因此删除仅需遵循这些引用即可。这是不对称传播。结果更快，对GC的影响更小，并且更健壮，因为如果在未通知引擎的情况下发生值更改，则不会导致内存泄漏。</strong></p></li></ul></div><p><strong>就地修改</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>传统的RETE将修改实现为删除+插入。这将导致所有联接元组都经过GC处理，其中许多作为插入的一部分再次被重新创建。相反，就地修改传播为单遍，检查每个节点</strong></p></li></ul></div><p><strong>反应性</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>也称为“新触发条件”。允许更精细的反应性来更新。模式可以对特定属性的更改做出反应，而忽略其他属性。这样可以减轻递归问题，并有助于提高性能。</strong></p></li></ul></div><p><strong>子网</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>否，“存在”和“累加”可以各自具有嵌套的条件元素，这些条件元素形成子网。</strong></p></li></ul></div><p><strong>向后链接</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>支持用于反向链接的Prolog样式派生树。该实现是基于堆栈的，因此对于大型图不存在方法递归问题。</strong></p></li></ul></div><p><strong>懒惰真相维护</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>真相维护会产生运行时成本，无论是否使用TMS，都会产生运行时成本。惰性TMS仅在首次使用时将其打开。此外，它仅针对该对象类型启用，因此其他对象类型不会产生运行时成本。</strong></p></li></ul></div><p><strong>基于堆的议程</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>议程使用二进制堆队列按显着性对规则匹配进行排序，而不是使用任何线性搜索或维护方法。</strong></p></li></ul></div><p><strong>动态规则</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>可以在运行时添加和删除规则，而引擎仍将填充数据。</strong></p></li></ul></div></div><div class="section" title="5.4。PHREAK算法"><div class="titlepage"><div><div><h2 class="title"><strong><a id="PHREAK"></a> 5.4。PHREAK算法</strong></h2></div></div></div><p><strong>Drools 6引入了一种新算法，试图解决RETE的一些核心问题。该算法不是从头编写的，而是结合了ReteOO的所有现有代码及其所有增强功能。尽管PHREAK是RETE算法的改进，但它不再被归类为RETE实现。就像动物进化超过特定点并改变关键特征一样，该动物也被归类为新物种。无论优化如何，有两个关键的RETE特征可强烈识别任何衍生菌株。这是一个渴望的，面向数据的算法。完成所有工作后，执行插入，更新或删除操作；急于产生所有规则的所有部分匹配。相比之下，PHREAK被描述为一种懒惰的，面向目标的算法。其中部分匹配会被严重延迟。</strong></p><p><strong>RETE的这种渴望会导致大型系统中的大量用户流失，并浪费大量工作。浪费的工作归类为不会导致解雇的匹配工作。</strong></p><p><strong>PHREAK受到许多算法的启发。包括（但不限于）LEAPS，RETE / UL和面向集合的匹配。PHREAK具有ReteOO部分中列出的所有增强功能。此外，它还添加了以下增强功能集，将在以下各段中进行详细说明。</strong></p><p><strong>
    </strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>三层上下文记忆；节点，段和规则存储器。</strong></p></li><li class="listitem"><p><strong>基于规则，分段和节点的链接。</strong></p></li><li class="listitem"><p><strong>懒惰（延迟）规则评估。</strong></p></li><li class="listitem"><p><strong>孤立的规则评估。</strong></p></li><li class="listitem"><p><strong>面向集合的传播。</strong></p></li><li class="listitem"><p><strong>基于堆栈的评估，包括暂停和继续。</strong></p></li></ul></div><p><strong>
  </strong></p><p><strong>当PHREAK引擎启动时，所有规则都被认为是未链接的，因此，当规则未链接时，将不会进行任何规则评估。进入Beta网络之前，插入，更新和删除操作已排队。根据最有可能导致解雇的规则，使用一种简单的启发式方法来选择下一个评估规则；这会延迟评估和触发其他规则。尽管尚未完成任何工作，但只有在规则中填充了所有正确输入后，该规则才被视为已链接。而是创建一个代表规则的目标，并将其放入优先级队列中。这是由显着性命令的。每个队列本身都与一个议程组关联。只有活动的AgendaGroup会检查其队列，以最高显着性弹出规则的目标，并将其提交评估。因此，完成的工作从插入，更新，删除阶段转移到fireAllRules阶段。仅评估为其创建目标的规则，而根据这些事实进行的其他潜在规则评估将被延迟。在评估各个规则时，仍然可以通过分段过程来实现节点共享，这将在后面说明。</strong></p><p><strong>RETE中每次成功的加入尝试都会生成一个元组（或令牌，或部分匹配），该元组将传播到子节点。因此，它被描述为面向元组的算法。对于到达的每个子节点，它将尝试与该节点的另一侧进行联接，再次，每次成功的联接尝试都将立即传播。这将产生下降递归效果。当节点网络从进入beta网络的点到所有可到达的叶节点上下左右波动时，对节点网络进行处理。</strong></p><p><strong>PHREAK传播是面向集合（或面向集合）的，而不是面向元组的。对于正在评估的规则，它将访问第一个节点并处理所有排队的插入，更新和删除。将结果添加到集合中，并将该集合传播到子节点。在子节点中，所有排队的插入，更新和删除都将被处理，并将结果添加到同一集合中。完成后，该集合将传播到下一个子节点，依此类推，直到到达终端节点。这将创建一个单一的管道类型效果，该效果与当前正在评估的规则隔离。这将创建批处理效果，可以为某些规则构造提供性能优势。例如具有累积作用的子网。将来，它将依靠多种方式来利用多核计算机。</strong></p><p><strong>链接和取消链接使用基于网络分段的分层位掩码系统。构建规则网络后，将为由同一组规则共享的节点创建分段。规则本身是由段的路径组成的，尽管如果没有共享，则将是一个段。将位掩码偏移量分配给段中的每个节点。另外，将另一个位掩码（分层）分配给规则路径中的每个段。当至少有一个输入（数据传播）时，节点的位设置为on。当每个节点的位设置为on时，段的位也设置为on。相反，如果任何节点的位设置为关闭，则该段也将设置为关闭。如果将规则路径中的每个细分均设置为启用，则将规则链接到该规则中，并创建一个目标来计划该规则以进行评估。相同的位掩码技术还用于跟踪脏节点，段和规则。如果自上次评估以来认为已变脏的规则，则可以安排已链接的规则进行评估。</strong></p><p><strong>这样可以确保没有规则会评估部分匹配，如果由于其中一个联接没有数据而导致它无法导致规则实例的情况，则不会评估。这在RETE中是可能的，并且即使最后一个连接为空，也会为所有节点产生不必要的武术比赛尝试。</strong></p><p><strong>尽管增量规则评估始终从根节点开始，但脏位掩码用于允许跳过不脏的节点和段。</strong></p><p><strong>使用每个节点至少存在一项数据是一种相当基本的启发式方法。未来的工作将试图进一步延迟链接；使用诸如弧一致性的技术来确定匹配是否会导致规则实例触发。</strong></p><p><strong>由于RETE仅具有一个单一的存储器单元（节点存储器），因此PHREAK具有3个级别的存储器。这样可以在评估规则期间获得更多的上下文理解。</strong></p><div class="figure"><strong><a id="d0e4796"></a><p class="title"><strong>图5.12。PHREAK 3分层存储系统</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/LayeredMemory.png" align="middle" alt="PHREAK 3分层存储系统"></div></div></strong></div><strong><br class="figure-break"><p>示例1显示了具有三种模式的一条规则； A，B和C。它形成单个段，节点的位1、2和4。单段的位偏移为1。</p><div class="figure"><a id="d0e4804"></a><p class="title"><strong>图5.13。示例1：单一规则，不共享</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/segment1.png" align="middle" alt="示例1：单一规则，不共享"></div></div></div><br class="figure-break"><p>示例2演示了添加另一个共享模式A的规则时发生的情况。A放置在其自己的细分中，每个规则导致两个细分。这两段构成了各自规则的路径。第一条路段由两条路径共享。当链接A时，该段将被链接，然后迭代该段共享的每个路径，将位1设置为on。如果稍后打开B和C，则链接到路径R1的第二段；这将导致R1的位2被打开。将R1的位1和位2设置为打开后，现在将链接该规则，并创建一个目标以计划该规则以供以后评估和触发。</p><p>评估规则时，正是可以共享匹配结果的细分。每个段都有一个临时存储器，用于将该段的所有插入，更新和删除排队。如果要评估R1，它将处理A并得到一组元组。该算法检测到存在分段拆分，并将为集合中的每个插入，更新和删除创建对等元组，并将它们添加到R2的暂存中。这些元组将与任何现有的暂存元组合并，并等待R2最终被评估。</p><div class="figure"><a id="d0e4814"></a><p class="title"><strong>图5.14。示例2：共享的两个规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/segment2.png" align="middle" alt="示例2：共享的两个规则"></div></div></div><br class="figure-break"><p>示例3添加了第三条规则，并演示了共享A和B时发生的情况。这次仅显示段的位。证明R4具有3个段，R3具有3个段，R1具有2个段。A和B由R1，R3和R4共享。而D由R3和R4共享。</p><div class="figure"><a id="d0e4822"></a><p class="title"><strong>图5.15。示例3：共享的三个规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/segment3.png" align="middle" alt="示例3：共享的三个规则"></div></div></div><br class="figure-break"><p>当“不存在，存在或累积”节点包含多个元素时，形成子网。在示例4中，“ B not（C）”形成子网，请注意，“ not（C）”是单个元素，不需要子网，并且在Not节点内部合并。</p><p>子网拥有自己的网段。R1仍具有两个段的路径。子网形成另一个“内部”路径。当子网被链接时，它将链接到外部网段。</p><div class="figure"><a id="d0e4832"></a><p class="title"><strong>图5.16。示例4：单规则，具有子网且不共享</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/segment4.png" align="middle" alt="示例4：单规则，具有子网且不共享"></div></div></div><br class="figure-break"><p>示例5显示了可以通过不具有子网的规则对子网节点进行分片。这导致子网段被分成两个部分。</p><div class="figure"><a id="d0e4840"></a><p class="title"><strong>图5.17。示例5：两条规则，一条与子网共享</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/segment5.png" align="middle" alt="示例5：两条规则，一条与子网共享"></div></div></div><br class="figure-break"><p>并非具有约束的节点和累积节点都具有特殊的行为，并且永远无法取消链接段，并且始终将其视为打开状态。</p><p>所有规则评估都是递增的，不会浪费已经重新产生的工作重新计算匹配项。</p><p>评估算法基于堆栈，而不是方法递归。通过使用StackEntry表示要评估的当前节点，可以随时暂停和恢复评估。</p><p>当规则评估到达子网时，将为外部路径段和子网段创建StackEntry。首先评估子网段，当集合到达子网路径的末尾时，将其合并到为其馈入的外部节点的暂存列表中。然后恢复先前的StackEntry，在其中可以处理子网的结果。这样做还有一个好处，就是所有工作在传播到子节点之前都将被成批处理；这对于累积节点效率更高。</p><p>相同的堆栈系统可用于有效的反向链接。当规则评估到达查询节点时，它会通过将其放在堆栈上来再次暂停当前评估。然后对查询进行评估，生成结果集，结果集保存在内存中，供恢复的StackEntry拾取并传播到子节点。如果查询本身调用了其他查询，则该过程将重复，暂停当前查询，并为当前查询节点设置新的评估。</p><p>关于性能的最后一点。通常，使用PHREAK的单个规则不会比使用RETE更快。对于给定的规则和相同的数据集（使用根上下文对象启用和禁用匹配），它们都尝试相同数量的匹配并产生相同数量的规则实例，并且花费的时间大致相同。除了带有子网的用例和积累。</p><p>但是，可以认为PHREAK更适合RETE，因为它的规则库编写得不好，并且随着规则数量和复杂性的增加，性能也会更适度地下降。</p><p>RETE还将为不包含所有联接的数据的规则生产部分机器。 PHREAK会避免这种情况。</p><p>因此，并不是说PHREAK比RETE快，它不会随系统的增长而变慢：)</p><p>AgendaGroups对RETE的性能没有帮助，因为所有规则都在任何时候进行评估，而与组别无关。显着性也是如此。这就是为什么经常使用根上下文对象来限制匹配尝试的原因。PHREAK仅评估活动AgendaGroup的规则，并且在该组内将尝试避免评估（不会因规则引起）规则的评估（通过显着性）。</p><p>通过PHREAK AgendaGroups和显着性现在已成为有用的绩效工具。根上下文对象不再需要，并且可能对性能产生反作用，因为它们会强制刷新和重新生成规则的匹配项。</p><p> </p></strong></div></div><div class="chapter" title="第六章用户指南"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e4870"></a>第六章用户指南</strong></h2></div></div></div><div class="toc"><dl><dt><strong><span class="section"><a href="#d0e4873">6.1。基础</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e4876">6.1.1。无状态知识会议</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5038">6.1.2。有状态知识会议</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5213">6.1.3。方法与规则</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5245">6.1.4。交叉产品</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5270">6.2。执行控制</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5273">6.2.1。议程</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5306">6.2.2。规则匹配和冲突集。</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5518">6.3。推理</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5521">6.3.1。公交通行证示例</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5589">6.4。逻辑对象的真理维护</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5596">6.4.1。总览</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e5713">6.5。电子表格中的决策表</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e5725">6.5.1。何时使用决策表</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5743">6.5.2。总览</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5785">6.5.3。决策表如何工作</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e5871">6.5.4。电子表格语法</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6396">6.5.5。创建和集成基于电子表格的决策表</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6417">6.5.6。在决策表中管理业务规则</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6464">6.5.7。规则模板</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e6567">6.6。记录中</a></span></strong></dt></dl></div><div class="section" title="6.1。基础"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e4873"></a> 6.1。基础</strong></h2></div></div></div><div class="section" title="6.1.1。无状态知识会议"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e4876"></a> 6.1.1。无状态知识会议</strong></h3></div></div></div><p><strong>那么我们从哪里开始呢？规则引擎（例如Drools）中有太多的用例和太多的功能，以至于变得令人迷惑。不用担心我的勇敢冒险家，它的复杂性是分层的，您可以通过简单的用例来解决问题。</strong></p><p><strong>不使用推理的无状态会话形成最简单的用例。可以像调用函数一样将无状态会话传递给它一些数据，然后再接收一些结果。无状态会话的一些常见用例包括但不限于：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>验证方式</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>这个人有资格抵押吗？</strong></p></li></ul></div></li><li class="listitem"><p><strong>计算方式</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>计算抵押贷款溢价。</strong></p></li></ul></div></li><li class="listitem"><p><strong>路由和过滤</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>将传入消息（例如电子邮件）过滤到文件夹中。</strong></p></li><li class="listitem"><p><strong>将传入消息发送到目的地。</strong></p></li></ul></div></li></ul></div><p><strong>因此，让我们从一个使用驾驶执照应用程序的非常简单的示例开始。</strong></p><pre><code class="language-java">public class Applicant {
    private String name;
    private int age;
    private boolean valid;
    // getter and setter methods here
}
</code></pre><p><strong>现在我们有了数据模型，我们可以编写第一个规则了。我们假设应用程序使用规则拒绝无效的应用程序。由于这是一个简单的验证用例，我们将添加一条规则以取消任何未满18岁的申请人的资格。</strong></p><pre><code class="no-highlight">package com.company.license

rule "Is of valid age"
when
    $a : Applicant( age &lt; 18 )
then
    $a.setValid( false );
end</code></pre><p><strong>为了使引擎知道数据，以便可以根据规则对其进行处理，我们必须像<span class="emphasis"><em>插入</em></span>数据库一样<span class="emphasis"><em>插入</em></span>数据。当将Applicant实例插入引擎中时，将根据规则的约束对其进行评估，在这种情况下，一个规则只有两个约束。我们说<span class="emphasis"><em>两个</em></span>是因为类型Applicant是第一个对象类型约束，并且<code class="code">age < 18</code>是第二个字段约束。对象类型约束加上其零个或多个字段约束称为模式。当插入的实例同时满足对象类型约束和所有字段约束时，就称为匹配。的<code class="code">$a</code>是一个绑定变量，它允许我们在结果中引用匹配的对象。在那里可以更新其属性。美元字符（'$'）是可选的，但有助于区分变量名和字段名。毫无疑问，将模式与插入的数据进行匹配的过程通常称为<span class="emphasis"><em>模式匹配</em></span> 。</strong></p><p><strong>要使用此规则，有必要将其放置为Drools文件，只是具有.drl扩展名的纯文本文件，是“ Drools Rule Language”的缩写。我们将此文件称为licenseApplication.drl，并将其存储在Kie Project中。Kie Project具有普通Maven项目的结构，并带有一个附加文件（kmodule.xml），用于定义<code class="code">KieBase</code>和<code class="code">KieSession</code>可以创建的。该文件必须放置在Maven项目的resources / META-INF文件夹中，而所有其他Drools工件（例如包含前一个规则的licenseApplication.drl）必须存储在resources文件夹或该文件夹下的任何其他子文件夹中。</strong></p><p><strong>由于已经为所有配置方面提供了有意义的默认值，因此最简单的kmodule.xml文件只能包含一个空的kmodule标记，如下所示：</strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"/&gt;</code></pre><p><strong>此时，可以创建一个<code class="code">KieContainer</code>从类路径读取要构建的文件。</strong></p><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();</code></pre><p><strong>上面的代码片段编译了所有在类路径上找到的DRL文件，并将该编译结果<code class="code">KieModule</code> ， 在里面<code class="code">KieContainer</code> 。如果没有错误，我们现在可以从<code class="code">KieContainer</code>然后执行一些数据：</strong></p><pre><code class="language-java">StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
assertTrue( applicant.isValid() );
ksession.execute( applicant );
assertFalse( applicant.isValid() );
</code></pre><p><strong>前面的代码将根据规则执行数据。由于申请人未满18岁，因此该申请被标记为无效。</strong></p><p><strong>到目前为止，我们仅使用了一个实例，但是如果我们要使用多个实例又该怎么办？我们可以针对实现Iterable的任何对象（例如集合）执行。让我们添加另一个名为<code class="code">Application</code> ，其中包含申请日期，我们还将布尔有效字段移至<code class="code">Application</code>类。</strong></p><pre><code class="language-java">public class Applicant {
    private String name;
    private int age;
    // getter and setter methods here
}

public class Application {
    private Date dateApplied;
    private boolean valid;
    // getter and setter methods here
}</code></pre><p><strong>我们还将添加另一个规则，以验证该应用程序是在一段时间内完成的。</strong></p><pre><code class="no-highlight">package com.company.license

rule "Is of valid age"
when
    Applicant( age &lt; 18 )
    $a : Application()     
then
    $a.setValid( false );
end

rule "Application was made this year"
when
    $a : Application( dateApplied &gt; "01-jan-2009" )     
then
    $a.setValid( false );
end
</code></pre><p><strong>不幸的是，Java数组未实现<code class="code">Iterable</code>接口，所以我们必须使用JDK转换器方法<code class="code">Arrays.asList(...)</code> 。下面显示的代码针对一个可迭代的列表执行，在该列表中，所有匹配元素在触发任何匹配的规则之前都会插入。</strong></p><pre><code class="language-java">StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant( "Mr John Smith", 16 );
Application application = new Application();
assertTrue( application.isValid() );
ksession.execute( Arrays.asList( new Object[] { application, applicant } ) );
assertFalse( application.isValid() );
</code></pre><p><strong>两种执行方法<code class="code">execute(Object object)</code>和<code class="code">execute(Iterable objects)</code>实际上是界面的便捷方法<code class="code">BatchExecutor</code>的方法<code class="code">execute(Command command)</code> 。</strong></p><p><strong>的<code class="code">KieCommands</code>命令工厂，可从<code class="code">KieServices</code>像KIE API的所有其他工厂一样，用于创建命令，因此以下内容等同于<code class="code">execute(Iterable it)</code> ：</strong></p><pre><code class="language-java">ksession.execute( kieServices.getCommands().newInsertElements( Arrays.asList( new Object[] { application, applicant } ) );
</code></pre><p><strong>当使用多个命令并使用输出标识符来获取结果时，批处理执行器和命令工厂特别有用。</strong></p><pre><code class="language-java">KieCommands kieCommands = kieServices.getCommands();
List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();
cmds.add( kieCommands.newInsert( new Person( "Mr John Smith" ), "mrSmith", true, null ) );
cmds.add( kieCommands.newInsert( new Person( "Mr John Doe" ), "mrDoe", true, null ) );
BatchExecutionResults results = ksession.execute( kieCommands.newBatchExecution( cmds ) );
assertEquals( new Person( "Mr John Smith" ), results.getValue( "mrSmith" ) );
</code></pre><p><strong><code class="code">CommandFactory</code>支持许多其他可以在<code class="code">BatchExecutor</code>喜欢<code class="code">StartProcess</code> ， <code class="code">Query</code>和<code class="code">SetGlobal</code> 。</strong></p></div><div class="section" title="6.1.2。有状态知识会议"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5038"></a> 6.1.2。有状态知识会议</strong></h3></div></div></div><p><strong>有状态会话是长期存在的，并允许随着时间的推移进行迭代更改。有状态会话的一些常见用例包括但不限于：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>监控方式</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>半自动购买的股票市场监视和分析。</strong></p></li></ul></div></li><li class="listitem"><p><strong>诊断程序</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>故障查找，医疗诊断</strong></p></li></ul></div></li><li class="listitem"><p><strong>后勤</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>包裹追踪和配送</strong></p></li></ul></div></li><li class="listitem"><p><strong>合规</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>验证市场交易的合法性。</strong></p></li></ul></div></li></ul></div><p><strong>与无状态会话相比， <code class="code">dispose()</code>此后必须调用方法，以确保没有内存泄漏，因为KieBase包含在创建有状态知识会话时对其的引用。由于有状态知识会话是最常用的会话类型，因此仅将其命名为<code class="code">KieSession</code>在KIE API中。 <code class="code">KieSession</code>也支持<code class="code">BatchExecutor</code>界面，如<code class="code">StatelessKieSession</code> ，唯一的区别是<code class="code">FireAllRules</code>最终状态会话不会自动调用该命令。</strong></p><p><strong>我们以引发火灾警报的示例来说明监视用例。仅使用四个类，我们就代表一间屋子的房间，每个房间都有一个洒水器。如果房间里起火了，我们用一个<code class="code">Fire</code>实例。</strong></p><pre><code class="language-java">public class Room {
    private String name
    // getter and setter methods here
}
public class Sprinkler {
    private Room room;
    private boolean on;
    // getter and setter methods here
}
public class Fire {
    private Room room;
    // getter and setter methods here
}
public class Alarm {
}
</code></pre><p><strong>在上一节“无状态会话”中，介绍了对数据进行插入和匹配的概念。该示例假定只插入了每种对象类型的单个实例，因此仅使用了文字约束。但是，房屋有许多房间，因此规则必须表达对象之间的关系，例如某个房间中的洒水器。最好通过将绑定变量用作模式中的约束来完成。这种“连接”过程产生了所谓的交叉乘积，将在下一节中介绍。</strong></p><p><strong>发生火灾时， <code class="code">Fire</code>为此房间创建了class，并将其插入到会话中。该规则在<code class="code">room</code>的领域<code class="code">Fire</code>对象以限制与该房间（目前已关闭）的洒水装置的匹配。当该规则触发并执行结果时，喷淋头将打开。</strong></p><pre><code class="no-highlight">rule "When there is a fire turn on the sprinkler"
when
    Fire($room : room)
    $sprinkler : Sprinkler( room == $room, on == false )
then
    modify( $sprinkler ) { setOn( true ) };
    System.out.println( "Turn on the sprinkler for room " + $room.getName() );
end</code></pre><p><strong>无状态会话使用标准Java语法修改字段，而在上述规则中，我们使用<code class="literal">modify</code>语句，它充当一种“ with”语句。它可能包含一系列用逗号分隔的Java表达式，即，对由Java对象选择的对象的setter的调用。 <code class="literal">modify</code>语句的控制表达式。这会修改数据，并使引擎知道这些更改，以便可以再次对它们进行推理。此过程称为推断，对于有状态会话的工作而言至关重要。无状态会话通常不使用推断，因此引擎不需要知道数据更改。也可以使用<span class="emphasis"><em>顺序模式</em></span>显式关闭推断。</strong></p><p><strong>到目前为止，我们有规则告诉我们何时存在匹配数据，但是什么时候<span class="emphasis"><em>不</em></span>存在呢？我们如何确定火已熄灭，即没有火<code class="code">Fire</code>反对了吗？以前，约束是根据命题逻辑的语句，其中引擎针对单个实例进行约束。Drools还支持一阶逻辑，该逻辑使您可以查看数据集。关键字下的模式<code class="literal">not</code>不存在时匹配。当房间里的火消失后，下面给出的规则将自动关闭洒水装置。</strong></p><pre><code class="no-highlight">rule "When the fire is gone turn off the sprinkler"
when
    $room : Room( )
    $sprinkler : Sprinkler( room == $room, on == true )
    not Fire( room == $room )
then
    modify( $sprinkler ) { setOn( false ) };
    System.out.println( "Turn off the sprinkler for room " + $room.getName() );
end</code></pre><p><strong>虽然每个房间只有一个洒水装置，但建筑物只有一个警报。一个<code class="code">Alarm</code>发生火灾时创建对象，但只有一个<code class="code">Alarm</code>无论发生多少火灾，整个建筑物都需要使用。先前<code class="literal">not</code>被引入以匹配事实的缺失；现在我们用它的补码<code class="literal">exists</code>与某个类别的一个或多个实例匹配。</strong></p><pre><code class="no-highlight">rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert( new Alarm() );
    System.out.println( "Raise the alarm" );
end</code></pre><p><strong>同样，当没有火灾发生时，我们要删除警报，因此<code class="literal">not</code>关键字可以再次使用。</strong></p><pre><code class="no-highlight">rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    delete( $alarm );
    System.out.println( "Cancel the alarm" );
end

</code></pre><p><strong>最后，在应用程序首次启动时以及在删除警报并关闭所有洒水装置之后，会打印一条常规的健康状态消息。</strong></p><pre><code class="no-highlight">rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler( on == true ) 
then
    System.out.println( "Everything is ok" );
end</code></pre><p><strong>就像我们在无状态会话示例中所做的那样，以上规则应放在单个DRL文件中，并保存到Maven项目或其任何子文件夹的resouces文件夹中。和以前一样，我们可以获取<code class="code">KieSession</code>来自<code class="code">KieContainer</code> 。唯一的区别是这一次我们创建了一个有状态会话，而在创建无状态会话之前。</strong></p><pre><code class="language-java">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
KieSession ksession = kContainer.newKieSession();</code></pre><p><strong>创建会话后，现在可以随着时间的推移反复使用它。四个<code class="code">Room</code>创建并插入对象，以及一个<code class="code">Sprinkler</code>每个房间的对象。此时，引擎已完成所有匹配，但尚未触发任何规则。呼唤<code class="code">ksession.fireAllRules()</code>允许匹配的规则触发，但不会触发只会产生运行状况消息的触发。</strong></p><pre><code class="language-java">String[] names = new String[]{"kitchen", "bedroom", "office", "livingroom"};
Map&lt;String,Room&gt; name2room = new HashMap&lt;String,Room&gt;();
for( String name: names ){
    Room room = new Room( name );
    name2room.put( name, room );
    ksession.insert( room );
    Sprinkler sprinkler = new Sprinkler( room );
    ksession.insert( sprinkler );
}

ksession.fireAllRules();
</code></pre><pre><code class="no-highlight">&gt; Everything is ok</code></pre><p><strong>现在，我们创建两个火并将其插入；这次保留了返回的参考<code class="code">FactHandle</code> 。事实句柄是对插入实例的内部引擎引用，它允许实例在以后的某个时间点撤回或修改。现在，引擎起火了<code class="code">fireAllRules()</code>调用时，将发出警报并打开相应的洒水装置。</strong></p><pre><code class="language-java">Fire kitchenFire = new Fire( name2room.get( "kitchen" ) );
Fire officeFire = new Fire( name2room.get( "office" ) );

FactHandle kitchenFireHandle = ksession.insert( kitchenFire );
FactHandle officeFireHandle = ksession.insert( officeFire );

ksession.fireAllRules();</code></pre><pre><code class="no-highlight">&gt; Raise the alarm
&gt; Turn on the sprinkler for room kitchen
&gt; Turn on the sprinkler for room office</code></pre><p><strong>一段时间后，将扑灭大火， <code class="code">Fire</code>实例已撤消。这样会导致喷头关闭，警报被取消，并最终再次打印健康信息。</strong></p><pre><code class="language-java">ksession.delete( kitchenFireHandle );
ksession.delete( officeFireHandle );

ksession.fireAllRules();</code></pre><pre><code class="no-highlight">&gt; Cancel the alarm
&gt; Turn off the sprinkler for room office
&gt; Turn off the sprinkler for room kitchen
&gt; Everything is ok</code></pre><p><strong>每个人还和我在一起吗？并不是那么困难，我已经希望您可以开始看到声明性规则系统的价值和力量。</strong></p></div><div class="section" title="6.1.3。方法与规则"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5213"></a> 6.1.3。方法与规则</strong></h3></div></div></div><p><strong>人们经常会混淆方法和规则，而新规则用户经常会问：“我怎么称呼规则？“在上一节之后，您现在感觉像是一个规则专家，答案很明显，但是尽管如此，还是让我们总结一下区别。</strong></p><pre><code class="language-java">public void helloWorld(Person person) {
    if ( person.getName().equals( "Chuck" ) ) {
        System.out.println( "Hello Chuck" );
    }
}</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>方法被直接调用。</strong></p></li><li class="listitem"><p><strong>传递了特定实例。</strong></p></li><li class="listitem"><p><strong>一个调用导致一次执行。</strong></p></li></ul></div><pre><code class="no-highlight">rule "Hello World" when
    Person( name == "Chuck" )
then
    System.out.println( "Hello Chuck" );
end</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>只要将数据插入引擎中，规则就会通过匹配任何数据来执行。</strong></p></li><li class="listitem"><p><strong>规则永远不能直接调用。</strong></p></li><li class="listitem"><p><strong>特定实例无法传递到规则。</strong></p></li><li class="listitem"><p><strong>根据比赛的不同，规则可能会触发一次或多次，甚至根本不会触发。</strong></p></li></ul></div></div><div class="section" title="6.1.4。交叉产品"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5245"></a> 6.1.4。交叉产品</strong></h3></div></div></div><p><strong>前面提到了“叉积”一词，这是联接的结果。想象一下，将火灾警报示例中的数据与以下规则结合使用，其中没有字段约束：</strong></p><pre><code class="no-highlight">rule "Show Sprinklers" when
    $room : Room()
    $sprinkler : Sprinkler()
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</code></pre><p><strong>用SQL术语来说，这就像<code class="code">select * from Room, Sprinkler</code> Room表中的每一行将与Sprinkler表中的每一行连接在一起，从而产生以下输出：</strong></p><pre><code class="no-highlight">room:office sprinkler:office
room:office sprinkler:kitchen
room:office sprinkler:livingroom
room:office sprinkler:bedroom
room:kitchen sprinkler:office
room:kitchen sprinkler:kitchen
room:kitchen sprinkler:livingroom
room:kitchen sprinkler:bedroom
room:livingroom sprinkler:office
room:livingroom sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:livingroom sprinkler:bedroom
room:bedroom sprinkler:office
room:bedroom sprinkler:kitchen
room:bedroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</code></pre><p><strong>这些交叉乘积显然会变得巨大，并且很可能包含虚假数据。对于新规则作者而言，交叉产品的大小通常是性能问题的根源。由此可见，总是需要约束叉积，这是通过变量约束来完成的。</strong></p><pre><code class="no-highlight">rule
when
    $room : Room()
    $sprinkler : Sprinkler( room == $room )
then
    System.out.println( "room:" + $room.getName() +
                        " sprinkler:" + $sprinkler.getRoom().getName() );
end</code></pre><p><strong>这样仅产生四行数据，每个房间都有正确的自动喷水灭火器。在SQL（实际上是HQL）中，相应的查询为<code class="code">select * from Room, Sprinkler where Room == Sprinkler.room</code> 。</strong></p><pre><code class="no-highlight">room:office sprinkler:office
room:kitchen sprinkler:kitchen
room:livingroom sprinkler:livingroom
room:bedroom sprinkler:bedroom</code></pre></div></div><div class="section" title="6.2。执行控制"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e5270"></a> 6.2。执行控制</strong></h2></div></div></div><div class="section" title="6.2.1。议程"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5273"></a> 6.2.1。议程</strong></h3></div></div></div><p><strong>议程是一项<span class="emphasis"><em>Rete</em></span>功能。它维护一组能够执行的规则，其工作是按确定的顺序安排执行时间。</strong></p><p><strong>在行动期间<code class="code">RuleRuntime</code> ，规则可能会完全匹配并有资格执行；单个“规则运行时操作”可以产生多个合格规则。完全匹配规则后，将创建一个规则匹配，引用规则和匹配的事实，并将其放在议程中。议程使用冲突解决策略控制这些比赛的执行顺序。</strong></p><p><strong>引擎反复循环经过两个阶段：</strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong>规则运行时操作。这是大多数工作的结果，无论是结果（RHS本身）还是主要的Java应用程序过程。后果完成后或主要Java应用程序流程调用<code class="code">fireAllRules()</code>引擎将切换到“议程评估”阶段。</strong></p></li><li class="listitem"><p><strong>议程评估。这将尝试选择要触发的规则。如果未找到任何规则，则退出，否则将激发找到的规则，并将阶段切换回“规则运行时操作”。</strong></p></li></ol></div><div class="figure"><strong><a id="d0e5298"></a><p class="title"><strong>图6.1。两阶段执行</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/UserGuide/Two_Phase.png" align="middle" alt="两阶段执行"></div></div></strong></div><strong><br class="figure-break"><p>重复该过程，直到清除议程为止，在这种情况下，控制权返回到调用应用程序。进行规则运行时操作时，不会触发任何规则。</p></strong></div><div class="section" title="6.2.2。规则匹配和冲突集。"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5306"></a> 6.2.2。规则匹配和冲突集。</strong></h3></div></div></div><div class="section" title="6.2.2.1。现金流量示例"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5309"></a> 6.2.2.1。现金流量示例</strong></h4></div></div></div><p><strong>到目前为止，数据和匹配过程非常简单而且很小。为了使事情更加复杂，将探索一个新示例，该示例处理日期期间的现金流量计算。发动机状态将在关键阶段进行说明性显示，以帮助您更好地了解发动机罩下实际发生的情况。如下所示，将使用三个类。这将帮助我们加深对模式匹配的理解，并进一步加入。然后，我们将使用它来说明执行控制的不同技术。</strong></p><pre><code class="language-java">public class CashFlow {
    private Date   date;
    private double amount;
    private int    type;
    long           accountNo;
    // getter and setter methods here
}

public class Account {
    private long   accountNo;
    private double balance;
    // getter and setter methods here
}

public AccountPeriod {
    private Date start;
    private Date end;
    // getter and setter methods here
}</code></pre><p><strong>到目前为止，您已经知道如何创建KieBases以及如何实例化事实以填充<code class="code">KieSession</code> ，因此表格将用于显示插入数据的状态，因为为了说明起见，它使事情变得更加清晰。下表显示了为<code class="code">Account</code> 。还插入了一系列借方和贷方，例如<code class="code">CashFlow</code>该帐户的对象，扩展了两个季度。</strong></p><div class="figure"><strong><a id="d0e5327"></a><p class="title"><strong>图6.2。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables1.png" alt="现金流量和账户"></div></div></strong></div><strong><br class="figure-break"><p>可以使用两个规则来确定该季度的借方和贷方并更新帐户余额。以下两个规则限制了给定时间段内帐户的现金流量。请注意，“ &&”使用快捷语法来避免重复两次字段名称。</p><table id="d0e5335" frame="void"><tbody><tr>
            <td align="left" valign="top"><pre><code class="no-highlight">rule "increase balance for credits"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre></td>

            <td align="left" valign="top"><pre><code class="no-highlight">rule "decrease balance for debits" 
when 
  ap : AccountPeriod() 
  acc : Account( $accountNo : accountNo ) 
  CashFlow( type == DEBIT, 
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end, 
            $amount : amount ) 
then 
  acc.balance -= $amount; 
end</code></pre></td>
          </tr></tbody></table><p>前面我们展示了规则如何等同于SQL，这通常可以帮助具有SQL背景的人理解规则。上面的两个规则可以用两个视图和每个视图的触发器来表示，如下所示：</p><table border="0" id="d0e5349"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">select * from Account acc,
              Cashflow cf,
              AccountPeriod ap      
where acc.accountNo == cf.accountNo and 
      cf.type == CREDIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">select * from Account acc, 
              Cashflow cf,
              AccountPeriod ap 
where acc.accountNo == cf.accountNo and 
      cf.type == DEBIT and
      cf.date &gt;= ap.start and 
      cf.date &lt;= ap.end</code></pre>
            </td>
          </tr><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">trigger : acc.balance += cf.amount</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">trigger : acc.balance -= cf.amount</code></pre>
            </td>
          </tr></tbody></table><p>如果<code class="code">AccountPeriod</code>设置为第一季度，我们将规则“增加贷方余额”应用于两行数据，将“减少借方余额余额”应用于单行数据。</p><div class="figure"><a id="d0e5384"></a><p class="title"><strong>图6.3。会计期间，现金流量和帐户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables2.png" alt="会计期间，现金流量和帐户"></div></div></div><br class="figure-break"><p>上面的两个现金流量表代表两个规则的匹配数据。数据在插入阶段是匹配的，正如您在上一章中发现的那样，不会立即触发，而只会在之后<code class="code">fireAllRules()</code>叫做。同时，规则及其匹配的数据被放在议程上，称为规则匹配或规则实例。议程是一个规则匹配表，一旦调用fireAllRules（），该规则匹配就可以触发并执行其结果。议程上的规则匹配称为<em class="firstterm">冲突集</em> ，其执行由冲突解决策略决定。注意，到目前为止，执行顺序被认为是任意的。</p><div class="figure"><a id="d0e5398"></a><p class="title"><strong>图6.4。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables7.png" alt="现金流量和账户"></div></div></div><br class="figure-break"><p>触发所有上述激活后，帐户的余额为-25。</p><div class="figure"><a id="d0e5406"></a><p class="title"><strong>图6.5。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables3.png" alt="现金流量和账户"></div></div></div><br class="figure-break"><p>如果<code class="code">AccountPeriod</code>更新到第二季度，我们只有一行匹配的数据，因此该议程上只有一个规则匹配。</p><p>触发该激活会导致余额为25。</p><div class="figure"><a id="d0e5419"></a><p class="title"><strong>图6.6。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables4.png" alt="现金流量和账户"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e5425"></a><p class="title"><strong>图6.7。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables5.png" alt="现金流量和账户"></div></div></div><br class="figure-break"></strong></div><div class="section" title="6.2.2.2。解决冲突"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5431"></a> 6.2.2.2。解决冲突</strong></h4></div></div></div><p><strong>如果您不希望规则执行的顺序是任意的怎么办？当议程上存在一个或多个规则匹配时，它们被认为存在冲突，并且使用冲突解决策略来确定执行顺序。Drools策略非常简单，并且基于显着性值，该显着性值为规则分配了优先级。每个规则的默认值为0，该值越高，优先级越高。</strong></p><p><strong>作为一般规则，最好不要依赖以任何特定顺序触发的规则，并且在编写规则时不必担心“流程”。但是，当需要流程时，除了显着性外，还有许多可能性：议程组，规则流程组，激活组和控制/信号量事实。</strong></p><p><strong>从Drools 6.0开始，源文件中的规则定义顺序用于设置显着性之后的优先级。</strong></p></div><div class="section" title="6.2.2.3。显着性"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5440"></a> 6.2.2.3。显着性</strong></h4></div></div></div><p><strong>为了说明Salience，我们添加了一条规则来打印帐户余额，在此我们希望在所有借项和贷项均已应用于所有帐户之后执行该规则。我们通过为该规则分配负的显着性来实现，以便在所有规则的默认显着性为0时触发。</strong></p><table border="0" id="d0e5445"><tbody><tr>
            <td>
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
        salience -50
    when
        ap : AccountPeriod()
        acc : Account()        
    then
        System.out.println( acc.accountNo + " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table><p><strong>下表描述了由此产生的议程。这三个借记和贷记规则显示为任意顺序，而打印规则排在最后，然后执行。</strong></p><div class="figure"><strong><a id="d0e5457"></a><p class="title"><strong>图6.8。现金流量和账户</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/UserGuide/tables6.png" alt="现金流量和账户"></div></div></strong></div><strong><br class="figure-break"></strong></div><div class="section" title="6.2.2.4。议程小组"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5463"></a> 6.2.2.4。议程小组</strong></h4></div></div></div><p><strong>通过议程组，您可以将规则放入组中，并将这些组放入堆栈中。堆栈具有推/弹出行为。调用“ setFocus”会将组放置到堆栈中：</strong></p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</code></pre><p><strong>议程总是评估堆栈的顶部。为一个组触发所有规则后，将从堆栈中弹出该规则，然后评估下一个组。</strong></p><table border="0" id="d0e5472"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "increase balance for credits"
  agenda-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
  agenda-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table><p><strong>首先将重点设置为“报告”组，然后将重点放在“计算”上，以确保首先评估该组。</strong></p><pre><code class="language-java">Agenda agenda = ksession.getAgenda();
agenda.getAgendaGroup( "report" ).setFocus();
agenda.getAgendaGroup( "calculation" ).setFocus();
ksession.fireAllRules();</code></pre></div><div class="section" title="6.2.2.5。规则流"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5492"></a> 6.2.2.5。规则流</strong></h4></div></div></div><p><strong>Drools还具有ruleflow-group属性，该属性允许工作流图以声明方式指定允许规则触发的时间。下面的屏幕快照是使用Drools插件从Eclipse中获取的。它具有两个Ruleflow-Group节点，可确保计算规则在报告规则之前执行。</strong></p><div class="mediaobject"><strong><img src="images/UserGuide/ruleflow.png"></strong></div><p><strong>下面显示了规则中ruleflow-group属性的使用。</strong></p><table border="0" id="d0e5502"><tbody><tr>
            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "increase balance for credits"
  ruleflow-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</code></pre>
            </td>

            <td align="left" valign="top">
              <pre><code class="no-highlight">rule "Print balance for AccountPeriod"
  ruleflow-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );    
end</code></pre>
            </td>
          </tr></tbody></table></div></div></div><div class="section" title="6.3。推理"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e5518"></a> 6.3。推理</strong></h2></div></div></div><div class="section" title="6.3.1。公交通行证示例"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5521"></a> 6.3.1。公交通行证示例</strong></h3></div></div></div><p><strong>如今，推理有一个坏名字，因为它与业务用例无关，太复杂而无法使用。确实，人为推论中出现了人为的和复杂的示例，但这不应减损也存在简单和有用的示例的事实。不仅如此，正确使用推理还可以创造更多的敏捷性和更少的容易出错的业务规则，而这些规则更易于维护。</strong></p><p><strong>那么什么是推论？当我们通过使用先前的知识获得某些知识时，就可以推断出某种东西。例如，给定某人的事实，该人具有年龄字段和提供年龄政策控制的规则，我们可以推断该人是成年人还是孩子，并对此采取行动。</strong></p><pre><code class="no-highlight">rule "Infer Adult"
when
  $p : Person( age &gt;= 18 )
then
  insert( new IsAdult( $p ) )
end</code></pre><p><strong>根据上述规则，每个18岁或以上的Person都将为其插入一个IsAdult实例。这个事实的特殊之处在于它被称为关系。我们可以在任何规则中使用此推断关系：</strong></p><pre><code class="no-highlight">$p : Person()
IsAdult( person == $p )</code></pre><p><strong>因此，现在我们知道了什么是推理，并有一个基本示例，这如何促进良好的规则设计和维护？</strong></p><p><strong>让我们假设一个政府部门，该部门负责在儿童成年后发行身份证，以下称为ID部门。他们可能有一个包含如下逻辑的决策表，该逻辑说当居住在伦敦的18岁以上的成年人签发该卡：</strong></p><div class="mediaobject"><strong><img src="images/UserGuide/monolithic.png"></strong></div><p><strong>但是，身份证部门没有为成人设定政策。这是在中央政府一级完成的。如果中央政府将该年龄改为21岁，这将启动变更管理流程。为了使法律生效，必须有人与ID部门保持联系，并确保其系统得到更新。</strong></p><p><strong>这种变更管理过程和部门之间的通信对于敏捷环境不是理想的选择，变更变得昂贵且容易出错。此外，卡部门正在使用其“整体式”规则管理方法来管理比其需要注意的更多信息，该方法“泄漏”了更好地放置在其他地方的信息。我的意思是，它并不关心显式的“年龄> = 18”信息确定某人是否是成年人，而仅是他们是成年人。</strong></p><p><strong>与此相反，让我们采用一种方法来划分（分离）创作职责，以便中央政府和ID部门都保持自己的规则。</strong></p><p><strong>确定谁是成年人是中央政府的工作。如果他们更改了法律，则只需使用新规则更新其中央存储库，其他规则将使用这些新规则：</strong></p><div class="mediaobject"><strong><img src="images/UserGuide/InferIsAdult.png"></strong></div><p><strong>如前所述，IsAdult事实是从策略规则中推断出来的。它封装了看似任意的逻辑“年龄> = 18”，并为其含义提供了语义抽象。现在，如果有人使用上述规则，则他们不再需要知道确定某人是否为成年人的显式信息。他们可以使用推断的事实：</strong></p><div class="mediaobject"><strong><img src="images/UserGuide/IssueIdCard.png"></strong></div><p><strong>尽管该示例非常简单且琐碎，但它说明了一些要点。我们从整体性和泄漏性的知识工程开始。我们创建了一个决策表，其中包含所有可能的信息，并且从中央政府泄漏了ID部门不关心也不希望管理的信息。</strong></p><p><strong>我们首先将知识过程解耦，所以每个部门只负责需要知道的内容。然后，我们使用推断的事实IsAdult封装了这种泄漏的知识。IsAdult一词的使用也为先前任意的逻辑“年龄> = 18”提供了语义抽象。</strong></p><p><strong>因此，进行知识工程时的一般经验法则是：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>坏</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>单片</strong></p></li><li class="listitem"><p><strong>漏水的</strong></p></li></ul></div></li><li class="listitem"><p><strong><span class="bold"><strong>好</strong></span></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>解耦知识责任</strong></p></li><li class="listitem"><p><strong>封装知识</strong></p></li><li class="listitem"><p><strong>为这些封装提供语义抽象</strong></p></li></ul></div></li></ul></div></div></div><div class="section" title="6.4。逻辑对象的真理维护"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e5589"></a> 6.4。真理维护<a id="d0e5592" class="indexterm"></a>逻辑对象</strong></h2></div></div></div><div class="section" title="6.4.1。总览"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5596"></a> 6.4.1。总览</strong></h3></div></div></div><p><strong>在常规插入之后，您必须显式撤回事实。使用<span class="emphasis"><em>逻辑</em></span>断言，当首先断言它的条件不再成立时，断言的事实将自动撤回。实际上，它甚至更聪明，因为只有在没有任何单个条件支持逻辑断言的情况下它才会被收回。</strong></p><p><strong>正常插入被认为是<span class="emphasis"><em>陈述性的</em></span> ，即就像“陈述事实”的直观含义所暗示的那样。用一个<code class="code">HashMap</code>还有一个计数器，我们跟踪一个特定的相等被<span class="emphasis"><em>陈述</em></span>了多少次；这意味着我们计算了多少个不同的实例相等。</strong></p><p><strong>当我们在RHS执行过程中在<span class="emphasis"><em>逻辑上</em></span>插入一个对象时，我们称其为<span class="emphasis"><em>合理的</em></span> ，并且触发规则认为该对象是合理的。对于每个逻辑插入，只能有一个相等的对象，并且随后的每个相等的逻辑插入都会增加此逻辑断言的对齐计数器。LHS消除了创建规则变为不正确的理由，并相应地减少了计数器。一旦没有理由，逻辑对象就会自动收回。</strong></p><p><strong>如果我们尝试在存在相等<span class="emphasis"><em>声明</em></span>的对象时<span class="emphasis"><em>逻辑上</em></span>插入对象，则此操作将失败并返回null。如果我们<span class="emphasis"><em>规定</em></span>有是<span class="emphasis"><em>有道理的</em></span> ，我们覆盖事实现有等于对象的对象;此替代的工作方式取决于配置设置<code class="code">WM_BEHAVIOR_PRESERVE</code> 。当该属性设置为丢弃时，我们使用现有的句柄，并用新的Object替换现有的实例，这是默认行为。否则，我们将其覆盖为<span class="emphasis"><em>声明，</em></span>但我们创建了一个新<code class="code">FactHandle</code> 。</strong></p><p><strong>初读时可能会造成混淆，因此希望下面的流程图有所帮助。当它说它返回一个新的<code class="code">FactHandle</code> ，这也表示<code class="code">Object</code>是通过网络传播的。</strong></p><div class="figure"><strong><a id="d0e5654"></a><p class="title"><strong>图6.9。指定插入</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Stated_Assertion.png" align="middle" alt="指定插入"></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e5660"></a><p class="title"><strong>图6.10。逻辑插入</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/HybridReasoning/Logical_Assertion.png" align="middle" alt="逻辑插入"></div></div></div><br class="figure-break"><div class="section" title="6.4.1.1。带有推理和TMS的公交通行证示例"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5666"></a> 6.4.1.1。带有推理和TMS的公交通行证示例</h4></div></div></div><p>之前的示例向18岁以上的居民发行了身份证，在此示例中，我们现在发行了儿童或成人通行证。</p><pre><code class="no-highlight">rule "Issue Child Bus Pass" when
    $p : Person( age &lt; 16 )
then
    insert(new ChildBusPass( $p ) );
end
 
rule "Issue Adult Bus Pass" when
    $p : Person( age &gt;= 16 )
then
    insert(new AdultBusPass( $p ) );
end</code></pre><p>如前所述，以上示例被认为是整体的，泄漏的，并且关注点分离差。</p><p>和以前一样，我们可以提供一个更强大的应用程序，并使用推理将关注点分离。注意，这次我们不只是插入推断的对象，我们使用“ insertLogical”：</p><pre><code class="no-highlight">rule "Infer Child" when
    $p : Person( age &lt; 16 )
then
    insertLogical( new IsChild( $p ) )
end
rule "Infer Adult" when
    $p : Person( age &gt;= 16 )
then
    insertLogical( new IsAdult( $p ) )
end</code></pre><p>“插入逻辑”是Drools真相维护系统（TMS）的一部分。在逻辑上插入事实时，该事实取决于“ when”子句的真实性。这意味着当规则变为假时，事实将自动撤回。这两个规则互斥，因此效果特别好。因此，在上述规则中，如果此人未满16岁，则会插入一个IsChild事实，一旦该人在16岁或16岁以上，IsChild事实将自动撤回并插入IsAdult事实。</p><p>返回代码以发布公交通行证，这两个规则可以+在逻辑上插入ChildBusPass和AdultBusPass事实，因为TMS +支持为一系列级联的撤回操作逻辑插入链接。</p><pre><code class="no-highlight">rule "Issue Child Bus Pass" when
    $p : Person( )
         IsChild( person == $p )
then
    insertLogical(new ChildBusPass( $p ) );
end
 
rule "Issue Adult Bus Pass" when
    $p : Person( age &gt;= 16 )
         IsAdult( person =$p )
then
    insertLogical(new AdultBusPass( $p ) );
end</code></pre><p>现在，当一个人的年龄从15岁变为16岁时，不仅IsChild事实自动收回，该人的ChildBusPass事实也会自动撤消。对于奖励积分，我们可以将其与“ not”条件元素结合起来以处理通知，在这种情况下，要求返回通行证。因此，当TMS自动撤回ChildBusPass对象时，此规则将触发并向该人发送请求：</p><pre><code class="no-highlight">rule "Return ChildBusPass Request "when
    $p : Person( )
         not( ChildBusPass( person == $p ) )
then
    requestChildBusPass( $p );
end</code></pre></div><div class="section" title="6.4.1.2。重要说明：Java对象的相等性"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5689"></a> 6.4.1.2。重要说明：Java对象的相等性</h4></div></div></div><p>重要的是要注意，要使真理维护（和逻辑断言）完全起作用，您的Fact对象（可能是JavaBean）必须覆盖equals和hashCode方法（来自java.lang。对象）正确。由于真相维护系统需要知道两个不同的物理对象何时相等， <span class="emphasis"><em>因此</em></span>必须按照Java标准正确地覆盖equals和hashCode。</p><p>当且仅当两个对象的equals方法彼此返回true且其hashCode方法返回相同的值时，两个对象才相等。有关更多详细信息，请参见Java API（但请记住，您<span class="emphasis"><em>必须同时</em></span>覆盖equals和hashCode）。</p><p>TMS行为不受“身份与平等”的运行时配置的影响，TMS始终是平等的。</p></div><div class="section" title="6.4.1.3。从工作记忆中删除陈述或逻辑断言的事实"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5704"></a> 6.4.1.3。从工作记忆中删除陈述或逻辑断言的事实</h4></div></div></div><p>默认情况下，当从工作存储器中删除事实时，Drools会尝试从陈述的事实集以及真值维护系统（如果已对其进行逻辑断言）中将其删除。但是，使用delete方法的重载，也可以仅从2种方法之一中将其删除。例如调用：</p><pre><code class="no-highlight">ksession.delete( factHandle, FactHandle.State.LOGICAL );</code></pre><p>仅在逻辑上断言了该事实后，该事实才被删除，但如果是已陈述的事实，则该事实不被删除。在这种情况下，如果事实已被声明，则其删除将以静默方式失败，并且将被忽略。</p></div></strong></div></div><div class="section" title="6.5。电子表格中的决策表"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e5713"></a> 6.5。电子表格中的决策表</strong></h2></div></div></div><p><strong>决策表是“精确而紧凑的”（参考Wikipedia）表示条件逻辑的方式，非常适合<span class="emphasis"><em>业务</em></span>级别规则。</strong></p><p><strong>Drools支持以电子表格格式管理规则。支持的格式为Excel（XLS）和CSV，这意味着可以使用各种电子表格程序（例如Microsoft Excel，OpenOffice.org Calc等）。预计在不久的将来版本中将包含基于Web的决策表编辑器。</strong></p><p><strong>决策表（从软件角度而言）是一个古老的概念，但多年来已证明是有用的。简而言之，在Drools中，决策表是一种根据输入电子表格的数据生成规则的方法。可以利用电子表格中用于数据捕获和处理的所有常规功能。</strong></p><div class="section" title="6.5.1。何时使用决策表"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5725"></a> 6.5.1。何时使用决策表</strong></h3></div></div></div><p><strong>如果存在可以表示为规则模板和数据的规则，则将决策表视为行动过程：决策表的每一行都提供与模板组合以生成规则的数据。</strong></p><p><strong>许多企业已经使用电子表格来管理数据，计算等。如果您愿意继续使用这种方式，则也可以通过这种方式来管理您的业务规则。这也假设您很乐意在<code class="filename">.xls</code>要么<code class="filename">.csv</code>文件。对于不遵循一组模板的规则，或者规则数量很少（或者对Excel或OpenOffice.org之类的软件不满意）的规则，不建议使用决策表。它们是理想的，因为可以控制规则的哪些<span class="emphasis"><em>参数</em></span>可以编辑，而无需直接暴露规则。</strong></p><p><strong>决策表还提供了与基础对象模型的隔离度。</strong></p></div><div class="section" title="6.5.2。总览"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5743"></a> 6.5.2。总览</strong></h3></div></div></div><p><strong>以下是现实世界中决策表的一些示例（为保护无辜者而进行了轻微编辑）。</strong></p><div class="figure"><strong><a id="d0e5748"></a><p class="title"><strong>图6.11。使用Excel编辑决策表</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/excel.png" alt="使用Excel编辑决策表"></div></div></div></strong></div><strong><br class="figure-break"><div class="figure"><a id="d0e5755"></a><p class="title"><strong>图6.12。规则行的多个操作</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/actions.png" alt="规则行的多个操作"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e5762"></a><p class="title"><strong>图6.13。使用OpenOffice.org</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/open_office.png" alt="使用OpenOffice.org"></div></div></div></div><br class="figure-break"><p>在以上示例中，决策表的技术方面已被折叠（使用标准电子表格功能）。</p><p>规则从第17行开始，每行生成一条规则。条件在C，D，E等列中，操作不在屏幕上。单元格中的值非常简单，其含义由第16行中的标题指示。B列仅是描述。通常使用颜色使表的不同区域的含义显而易见。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>请注意，尽管决策表看起来像是自上而下处理的，但不一定是这种情况。理想情况下，编写规则时无需考虑行的顺序，这仅仅是因为这使维护更加容易，因为行不需要一直移动。</p></div><p>由于每一行都是一条规则，因此适用相同的原则。在规则引擎处理事实时，可能会触发任何匹配的规则。（一些人对此感到困惑。有可能在规则触发时清除议程，并模拟一个非常简单的决策表，其中只有第一个匹配项才影响一个动作。）另请注意，一个电子表格上可以有多个表。这样，可以将规则共享共同的模板的位置分组，但最终将它们全部组合到一个规则包中。决策表本质上是自动生成DRL规则的工具。</p><div class="figure"><a id="d0e5778"></a><p class="title"><strong>图6.14。使用多个表对规则进行分组的真实示例</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/multi_table.png" alt="使用多个表对规则进行分组的真实示例"></div></div></div></div><br class="figure-break"></strong></div><div class="section" title="6.5.3。决策表如何工作"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5785"></a> 6.5.3。决策表如何工作</strong></h3></div></div></div><p><strong>要记住的关键点是，在决策表中，每一行都是一条规则，而该行中的每一列都是该规则的条件或动作。</strong></p><div class="figure"><strong><a id="d0e5790"></a><p class="title"><strong>图6.15。行和列</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/row_col.png" alt="行和列"></div></div></div></strong></div><strong><br class="figure-break"><p>电子表格将查找<em class="firstterm">RuleTable</em>关键字，以指示规则表的开始（起始行和列）。其他关键字也用于定义其他程序包级别属性（稍后介绍）。将关键字放在一列中很重要。按照惯例，第二列（“ B”）用于此目的，但可以是任何一列（习惯上在笔记的左边留有一个空白）。在下图中，C实际上是它开始的列。左侧的所有内容都将被忽略。</p><p>如果我们扩展隐藏的部分，它将开始更有意义。请注意列C中的关键字。</p><div class="figure"><a id="d0e5804"></a><p class="title"><strong>图6.16。扩展了规则模板</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/expanded.png" alt="扩展了规则模板"></div></div></div></div><br class="figure-break"><p>现在可以看到使之起作用的隐藏魔法。RuleSet关键字指示将在包含所有规则的<span class="emphasis"><em>规则包</em></span>中使用的名称。该名称是可选的，使用默认名称，但是在紧靠右侧的单元格中<span class="emphasis"><em>必须</em></span>具有<span class="emphasis"><em>RuleSet</em></span>关键字。</p><p>C列中其他可见的关键字是Import和Sequential，稍后将介绍。RuleTable关键字很重要，因为它表明将基于某些规则模板遵循大量规则。RuleTable关键字之后有一个名称，用于为生成的规则的名称加上前缀。工作表名称和行号被附加以保证唯一的规则名称。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>RuleTable名称和工作表名称的组合在同一KieBase中的所有电子表格文件中必须唯一。如果不是这种情况，则某些规则可能具有相同的名称，并且仅会应用其中的一个。要显示此类被忽略的规则，请<a class="link" href="#changingTheDefaultBuildResultSeverity" title="4.2.2.5。更改默认构建结果的严重性">提高此类规则名称冲突的严重性</a> 。</p></div><p>RuleTable的列指示规则开始的列；左侧的列将被忽略。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>通常，关键字组成名称/值对。</p></div><p>参考第14行（RuleTable之后的行），关键字CONDITION和ACTION表示以下各列中的数据适用于规则的LHS或RHS部分。规则上还有其他属性，也可以选择通过这种方式设置。</p><p>第15行包含<em class="firstterm">ObjectTypes的声明</em> 。该行中的内容是可选的，但是如果未使用此选项，则该行必须留为空白；但是，通常发现此选项非常有用。使用此行时，下面的单元格（第16行）中的值成为该对象类型的约束。在上述情况下，它会生成<code class="code">Person(age=="42")</code>和<code class="code">Cheese(type=="stilton")</code> ，其中42和“ stilton”来自第18行。在上面的示例中，“ ==”是隐式的；如果仅给出了字段名，那么翻译器将假定它是为了生成精确匹配。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>ObjectType声明可以跨列（通过合并的单元格），这意味着合并范围以下的所有列都将被组合为一次匹配单个事实的单个模式内的一组约束，而不是包含相同的ObjectType，但是导致不同的模式，可能匹配不同或相同的事实。</p></div><p>第16行包含规则模板本身。他们可以使用“ $ param”占位符指示应插入来自下面单元格的数据的位置。（对于多次插入，请使用“ $ 1”，“ $ 2”等，以指示来自以下单元格中逗号分隔列表的参数。）第17行将被忽略；它可能包含该列用途的文字描述。</p><p>第18和19行显示数据，这些数据将与第15行中的模板结合（插值）以生成规则。如果单元格不包含任何数据，则将忽略其模板。（这意味着某些条件或操作不适用于该规则行。）读取规则行，直到出现空白行。一个工作表中可以存在多个RuleTable。第20行包含另一个关键字和一个值。这样的关键字的行位置无关紧要（大多数人将其放在顶部），但是其列应与应显示RuleTable或RuleSet关键字的列相同。在我们的情况下，C列被选择为有效列，但可以使用任何其他列代替。</p><p>在上面的示例中，规则将如下所示呈现（因为它使用“ ObjectType”行）：</p><pre class="screen">//row 18
rule "Cheese_fans_18"
when
    Person(age=="42")
    Cheese(type=="stilton")
then
    list.add("Old man stilton");
end
</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>约束条件<code class="code">age=="42"</code>和<code class="code">type=="stilton"</code>被解释为单个约束，将被添加到上方单元格中的相应ObjectType中。如果上面的单元格是跨度的，则一个“列”上可能存在多个约束。</p></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>很大的决策表可能有很大的内存需求。</p></div></strong></div><div class="section" title="6.5.4。电子表格语法"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e5871"></a> 6.5.4。电子表格语法</strong></h3></div></div></div><div class="section" title="6.5.4.1。试算表结构"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5874"></a> 6.5.4.1。试算表结构</strong></h4></div></div></div><p><strong>定义用于生成DRL文件的数据的矩形区域有两种类型。一个，标有一个标记为<code class="code">RuleSet</code> ，定义规则以外的所有DRL项目。另一个可能重复出现，并且位于内容开头为的单元格的右侧和下方<code class="code">RuleTable</code> 。这些区域代表实际的决策表，每个区域产生一组结构相似的规则。</strong></p><p><strong>规则集区域可能包含单元格对，在<code class="code">RuleSet</code>单元格并包含一个关键字，该关键字指定同一行中的另一个值所包含的值的类型。</strong></p><p><strong>规则表区域的各列定义了从其派生的规则左侧的模式和约束，规则后果的动作以及各个规则属性的值。因此，“规则表”区域应包含一个或多个用于条件和动作的列，以及一个用于规则属性的列的任意选择，每个属性最多包含一个列。该行之后的前四行，其中单元格标记为<code class="code">RuleTable</code>被指定为标头区域，主要用于定义代码以构造规则。这四个标头行下方的任何其他行都产生另一个规则，其数据提供了“规则表”标头中定义的代码的变体。</strong></p><p><strong>所有关键字都不区分大小写。</strong></p><p><strong>仅检查第一个工作表的决策表。</strong></p></div><div class="section" title="6.5.4.2。规则集条目"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e5899"></a> 6.5.4.2。规则集条目</strong></h4></div></div></div><p><strong>规则集区域中的条目可以定义DRL构造（规则除外），并指定规则属性。尽管可以重复使用构造的条目，但每个规则属性最多只能给出一次，并且适用于所有规则，除非被“规则表”区域中定义的同一属性所覆盖。</strong></p><p><strong>条目必须以单元格对的垂直堆叠顺序给出。第一个包含一个关键字，第一个包含一个关键字，其值在右侧，如下表所示。该单元对对的序列可能会被空白行甚至规则表打断，只要该列标记为<code class="code">RuleSet</code>坚持为包含关键字的关键字。</strong></p><div class="table"><strong><a id="d0e5909"></a><p class="title"><strong>表6.5。规则集区域中的条目</strong></p><div class="table-contents"><table border="1" summary="Entries in the Rule Set area"><colgroup><col><col><col></colgroup><thead><tr><th>关键词</th><th>值</th><th>用法</th></tr></thead><tbody><tr><td>规则集</td><td>生成的DRL文件的软件包名称。可选，默认为<code class="code">rule_table</code> 。</td><td>必须是第一个条目。</td></tr><tr><td>顺序的</td><td>“对或错”。如果为“ true”，则使用显着性来确保规则从上到下触发。</td><td>可选，最多一次。如果省略，则不施加任何点火命令。</td></tr><tr><td>逃逸语录</td><td>“对或错”。如果为“ true”，则引号会转义，以便它们在字面上出现在DRL中。</td><td>可选，最多一次。如果省略，引号将被转义。</td></tr><tr><td>进口</td><td>以逗号分隔的要导入的Java类列表。</td><td>可选，可以重复使用。</td></tr><tr><td>变数</td><td>DRL全局声明，即类型后跟变量名。多个全局定义必须用逗号分隔。</td><td>可选，可以重复使用。</td></tr><tr><td>功能</td><td>根据DRL语法的一个或多个函数定义。</td><td>可选，可以重复使用。</td></tr><tr><td>查询</td><td>根据DRL语法的一个或多个查询定义。</td><td>可选，可以重复使用。</td></tr><tr><td>宣布</td><td>根据DRL语法的一种或多种声明性类型。</td><td>可选，可以重复使用。</td></tr></tbody></table></div></strong></div><strong><br class="table-break"><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>在某些语言环境中，MS Office，LibreOffice和OpenOffice将对双引号进行编码<code class="literal">"</code>不同的是，这将导致编译错误。这种差异通常很难看到。例如： <code class="literal">“A”</code>会失败，但是<code class="literal">"A"</code>将工作。</p></div><p>要定义适用于生成的DRL文件中所有规则的规则属性，可以使用下表中的任何条目。但是请注意，必须使用正确的关键字。同样，这些属性中的每一个只能使用一次。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>在“规则集”区域中指定的规则属性将影响同一包中的所有规则资产（不仅限于电子表格中）。除非您确定电子表格是软件包中唯一的一个规则资产，否则建议不要在“规则集”区域中而是在每个规则的“规则表”列中指定规则属性。</p></div><div class="table"><a id="d0e5998"></a><p class="title"><strong>表6.6。规则集区域中的规则属性条目</strong></p><div class="table-contents"><table border="1" summary="Rule attribute entries in the Rule Set area"><colgroup><col><col><col></colgroup><thead><tr><th>关键词</th><th>初始</th><th>值</th></tr></thead><tbody><tr><td>优先</td><td>P</td><td>一个整数，用于定义规则的“显着性”值。被“顺序”标志覆盖。</td></tr><tr><td>持续时间</td><td>d</td><td>一个长整数值，用于定义规则的“持续时间”值。</td></tr><tr><td>计时器</td><td>Ť</td><td>计时器定义。请参阅“计时器和日历”。</td></tr><tr><td>已启用</td><td>乙</td><td>布尔值。 “ true”启用规则； “ false”禁用规则。</td></tr><tr><td>日历</td><td>Ë</td><td>日历定义。请参阅“计时器和日历”。</td></tr><tr><td>无圈</td><td>ü</td><td>布尔值。 “ true”禁止由于其结果更改而导致规则循环。</td></tr><tr><td>主动锁定</td><td>大号</td><td>布尔值。 “ true”禁止在同一规则流或议程组中使用此标志设置的所有规则的其他激活。</td></tr><tr><td>自动对焦</td><td>F</td><td>布尔值。议程组中某条规则的“ true”会导致该规则的激活自动将焦点给予该组。</td></tr><tr><td>激活组</td><td>X</td><td>标识激活（或XOR）组的字符串。激活组中只有一个规则将被触发，即，第一个要触发的规则将取消同一组中其他规则的任何现有激活。</td></tr><tr><td>议程组</td><td>G</td><td>标识议程组的字符串，必须通过为其赋予“焦点”来激活它，这是控制规则组之间的流动的一种方式。</td></tr><tr><td>粗花丛</td><td>[R</td><td>标识规则流组的字符串。</td></tr></tbody></table></div></div><br class="table-break"></strong></div><div class="section" title="6.5.4.3。规则表"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e6088"></a> 6.5.4.3。规则表</strong></h4></div></div></div><p><strong>所有规则表都以包含“ RuleTable”的单元格开头，可以选择在同一单元格中后面跟一个字符串。该字符串用作此规则表派生的所有规则的名称的开头部分，并附加了行号以进行区分。（可以使用NAME列来覆盖此自动命名。）定义此规则表规则的所有其他单元格都在此单元格的下方和右侧。</strong></p><p><strong>下一行定义列的类型，每列导致条件或结果的一部分，或者提供一些规则属性，规则名称或注释。下表显示了可用的列标题。根据上一节中显示的规则属性条目表，可以使用其他列。请注意，每个属性列最多只能使用一次。对于列标题，请使用关键字或以这些表的“初始”列中给定的字母开头的任何其他单词。</strong></p><div class="table"><strong><a id="d0e6095"></a><p class="title"><strong>表6.7。规则表中的列标题</strong></p><div class="table-contents"><table border="1" summary="Column Headers in the Rule Table"><colgroup><col><col><col><col></colgroup><thead><tr><th>关键词</th><th>初始</th><th>值</th><th>用法</th></tr></thead><tbody><tr><td>名称</td><td>ñ</td><td>提供从该行生成的规则的名称。默认值由RuleTable标记后面的文本和行号构成。</td><td>最多一栏</td></tr><tr><td>描述</td><td>一世</td><td>文本，在生成的规则中产生注释。</td><td>最多一栏</td></tr><tr><td>条件</td><td>C</td><td>用于在条件中的模式内构造约束的代码段和内插值。</td><td>每个规则表至少一个</td></tr><tr><td>行动</td><td>一种</td><td>代码段和内插值，用于为规则的结果构造动作。</td><td>每个规则表至少一个</td></tr><tr><td>元数据</td><td>@</td><td>用于构建规则的元数据条目的代码段和内插值。</td><td>可选，任意数量的列</td></tr></tbody></table></div></strong></div><strong><br class="table-break"><p>给定标题为CONDITION的列，连续行中的单元格将产生条件元素。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>CONDITION下面的第一个单元格中的文本发展为规则条件的模式，下一行中的代码段成为约束。如果单元格与一个或多个邻居合并，则会形成具有多个约束的单个模式：所有约束都合并到带括号的列表中，并附加到此单元格中的文本中。单元格可以留空，这意味着下一行中的代码段必须自己产生有效的条件元素。</p><p>要包括一个没有限制的模式，您可以在另一种模式的文本前面编写该模式。</p><p>该模式可以带有或不带有空括号。可以将“ from”子句附加到模式中。</p><p>如果模式以“ eval”结尾，则代码片段应产生布尔表达式，以包含在“ eval”之后的一对括号中。</p></li><li class="listitem"><p>分两步处理CONDITION下面第二个单元格中的文本。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>通过对列中距离较远的单元格的值进行插值，可以修改此单元格中的代码段。如果要创建一个约束，该约束包含使用“ ==”与下面单元格中的值进行比较的内容，则仅使用字段选择器就足够了。必须将任何其他比较运算符指定为代码段中的最后一项，并附加以下单元格中的值。对于所有其他约束形式，必须用符号标记包含单元格内容的位置<code class="code">$param</code> 。使用符号可以多次插入<code class="code">$1</code> ， <code class="code">$2</code>等等，并在下面的单元格中用逗号分隔值列表。</p><p>根据图案的文字<code class="code">forall(</code> <span class="emphasis"><em>定界符</em></span> <code class="code">){</code> <span class="emphasis"><em>片段</em></span> <code class="code">}</code>通过对以下每个单元格中的逗号分隔值列表中的每个值重复一次<span class="emphasis"><em>代码片段</em></span>来展开，将值插入到符号中<code class="code">$</code>并通过给定的<span class="emphasis"><em>分隔符</em></span>加入这些扩展。注意，forall构造可能被其他文本包围。</p></li><li class="listitem"><p>如果上一行的单元格不为空，则将完整的代码段添加到该单元格的条件元素中。如果将多个约束添加到合并单元格中的模式，则会自动提供一对括号以及一个逗号分隔。</p><p>如果上面的单元格为空，则插值结果将按原样使用。</p></li></ol></div></li><li class="listitem"><p>CONDITION下面的第三个单元格中的文本仅供参考。它应用于向读者表明该专栏目的。</p></li><li class="listitem"><p>从第四行开始，非空白条目如上所述提供用于插值的数据。空白单元格将导致该规则的条件元素或约束遗漏。</p></li></ul></div><p>给定标题为ACTION的列，连续行中的单元格将导致一个action语句。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ACTION下面的第一个单元格中的文本是可选的。如果存在，则将其解释为对象引用。</p></li><li class="listitem"><p>ACTION下面的第二个单元格中的文本分两个步骤处理。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>通过对列中距离较远的单元格的值进行插值，可以修改此单元格中的代码段。对于单数插入，请使用符号标记包含单元格内容的位置<code class="code">$param</code> 。使用符号可以多次插入<code class="code">$1</code> ， <code class="code">$2</code>等等，并在下面的单元格中用逗号分隔值列表。</p><p>没有插值的方法调用可以通过没有任何标记符号的文本来实现。在这种情况下，请在下面的行中使用任何非空白条目来包含该语句。</p><p>forall构造在这里也可用。</p></li><li class="listitem"><p>如果第一个单元格不为空，则将其文本，后跟句点，第二个单元格中的文本和终止分号串在一起，从而生成方法调用，该方法调用将作为结果的动作语句添加。</p><p>如果上面的单元格为空，则插值结果将按原样使用。</p></li></ol></div></li><li class="listitem"><p>ACTION下面的第三个单元格中的文本仅供参考。它应用于向读者表明该专栏目的。</p></li><li class="listitem"><p>从第四行开始，非空白条目如上所述提供用于插值的数据。空白单元格将导致该规则的动作声明遗漏。</p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>使用<code class="code">$1</code>代替<code class="code">$param</code>在大多数情况下都可以使用，但是如果替换文本包含逗号，它将失败：然后，仅插入第一个逗号之前的部分。明智地使用此“缩写”。</p></div><p>给定标题为METADATA的列，连续行中的单元格将为生成的规则生成元数据注释。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>METADATA下的第一个单元格中的文本将被忽略。</p></li><li class="listitem"><p>如上所述，使用规则行中单元格的值对METADATA下方第二个单元格中的文本进行插值。元数据标记字符<code class="code">@</code>会自动加上前缀，因此不应包含在该单元格的文本中。</p></li><li class="listitem"><p>METADATA下的第三个单元格中的文本仅供参考。它应用于向读者表明该专栏目的。</p></li><li class="listitem"><p>从第四行开始，非空白条目如上所述提供用于插值的数据。空白单元格将导致该规则的元数据注释遗漏。</p></li></ul></div></strong></div><div class="section" title="6.5.4.4。例子"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e6280"></a> 6.5.4.4。例子</strong></h4></div></div></div><p><strong>在以下示例中说明了各种插值。</strong></p><div class="example"><strong><a id="d0e6285"></a><p class="title"><strong>示例6.1内插单元数据</strong></p><div class="example-contents"><p>如果模板是<code class="code">Foo(bar == $param)</code>而细胞是<code class="code">42</code> ，那么结果是<code class="code">Foo(bar == 42)</code> 。</p><p>如果模板是<code class="code">Foo(bar < $1, baz == $2)</code>并且该单元格包含<code class="code">42,43</code> ，结果将是<code class="code">Foo(bar < 42, baz ==43)</code> 。</p><p>模板<code class="code">forall(&&){bar != $}</code>与包含<code class="code">42,43</code>结果是<code class="code">bar != 42 && bar != 43</code> 。</p></div></strong></div><strong><br class="example-break"><p>下一个示例演示了一个单元格的定义效果，该单元格定义了模式类型及其下方的代码段。</p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/spanned_column.png"></div></div><p>此电子表格部分显示了<code class="code">Person</code>类型声明跨越2列，因此两个约束都将显示为<code class="code">Person(age == ..., type == ...)</code> 。由于代码段中仅存在字段名称，因此它们意味着相等性测试。</p><p>在以下示例中，标记符号<code class="code">$param</code>用来。</p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/with_param.png"></div></div><p>该列的结果是模式<code class="code">Person(age == "42"))</code> 。您可能已经注意到标记和运算符“ ==”是多余的。</p><p>下一个示例说明可以省略尾随插入标记。</p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/operator_completion.png"></div></div><p>在这里，暗示从单元格附加值，导致<code class="code">Person(age < "42")).</code></p><p>您可以提供绑定变量的定义，如下例所示。 。</p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/with_binding.png"></div></div><p>在这里，结果是<code class="code">c: Cheese(type == "stilton").</code>请注意，引号是自动提供的。实际上，任何东西都可以放在对象类型行中。除了定义绑定变量之外，它还可以是从字面上插入的其他模式。</p><p>下面显示了带有单个值插入的动作语句的简单构造。</p><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/consequence.png"></div></div><p>ACTION标头下方的单元格保留为空白。使用这种样式，任何结果都可以放在结果中，而不仅仅是单个方法调用。（相同的技术也适用于CONDITION列。）</p><p>下面是一个综合示例，显示了各种列标题的用法。在列标题下没有任何值（如在NO-LOOP列中）没有错误是错误的：这里，该属性将不会应用到任何规则中。</p><div class="figure"><a id="d0e6375"></a><p class="title"><strong>图6.17。导入，标题等关键字的示例用法</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/Key.png" alt="导入，标题等关键字的示例用法"></div></div></div></div><p><br class="figure-break">
      </p><p>最后，这是导入，变量和函数的示例。</p><div class="figure"><a id="d0e6385"></a><p class="title"><strong>图6.18。函数等的关键字用法示例</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/keywords.png" alt="函数等的关键字用法示例"></div></div></div></div><p><br class="figure-break">同一单元格中的多个软件包名称必须用逗号分隔。另外，类型和变量名称对必须用逗号分隔。但是，必须按照DRL文件中出现的功能编写函数。它应与“ RuleSet”关键字显示在同一列中；它可以在所有规则行的上方，之间或下方。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>重复使用导入，变量，函数和查询可能比将多个定义打包到单个单元格中更为方便。</p></div></strong></div></div><div class="section" title="6.5.5。创建和集成基于电子表格的决策表"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6396"></a> 6.5.5。创建和集成基于电子表格的决策表</strong></h3></div></div></div><p><strong>使用基于电子表格的决策表的API在drools-decisiontables模块中。实际上只有一堂课可以看： <code class="literal">SpreadsheetCompiler</code> 。此类将采用各种格式的电子表格，并以DRL（然后可以按常规方式使用）生成规则。的<code class="literal">SpreadsheetCompiler</code>可以仅用于生成部分规则文件（如果需要的话），然后将其组合成一个完整的规则包（如果需要，可以将规则的技术和非技术方面分开）。</strong></p><p><strong>首先，可以将示例电子表格用作基础。或者，如果正在使用插件（Rule Workbench IDE），则向导可以从模板生成电子表格（要对其进行编辑，将需要使用与xls兼容的电子表格编辑器）。
      </strong></p><div class="figure"><strong><a id="d0e6409"></a><p class="title"><strong>图6.19。IDE中的向导</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/wizard.png" alt="IDE中的向导"></div></div></div></strong></div><p><strong><br class="figure-break">
    </strong></p></div><div class="section" title="6.5.6。在决策表中管理业务规则"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6417"></a> 6.5.6。在决策表中管理业务规则</strong></h3></div></div></div><div class="section" title="6.5.6.1。工作流程与协作"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e6420"></a> 6.5.6.1。工作流程与协作</strong></h4></div></div></div><p><strong>电子表格是完善的业务工具（已使用25年以上）。决策表可以使IT与领域专家之间保持紧密的协作，同时使业务分析师可以清楚地了解业务规则，这是关注点之间的理想分离。</strong></p><p><strong>通常，编写规则的整个过程（连同新的决策表）如下所示：</strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong>业务分析师（从存储库或从IT）获取模板决策表</strong></p></li><li class="listitem"><p><strong>决策表业务语言描述输入到表中</strong></p></li><li class="listitem"><p><strong>大致输入决策表规则（行）</strong></p></li><li class="listitem"><p><strong>决策表将交给技术资源，后者将业务语言（描述）映射到脚本（当然，这可能涉及软件开发，如果它是新的应用程序或数据模型）</strong></p></li><li class="listitem"><p><strong>技术人员退回并与业务分析师一起审查修改。</strong></p></li><li class="listitem"><p><strong>业务分析师可以根据需要继续编辑规则行（也可以在列周围移动等）。</strong></p></li><li class="listitem"><p><strong>同时，技术人员可以开发规则的测试用例（与业务分析师联系），因为一旦系统运行，这些测试用例就可以用来验证规则和规则更改。</strong></p></li></ol></div></div><div class="section" title="6.5.6.2。使用电子表格功能"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e6449"></a> 6.5.6.2。使用电子表格功能</strong></h4></div></div></div><p><strong>Excel等应用程序的功能可用于协助将数据输入到电子表格中，例如验证字段。存储在其他工作表中的列表可用于为单元格提供有效的值列表，如下图所示。
        </strong></p><div class="figure"><strong><a id="d0e6454"></a><p class="title"><strong>图6.20。</strong></p><div class="figure-contents"><div class="screenshot"><span style="color:red"><title>IDE中的向导</title></span><div class="mediaobject"><img src="images/DecisionTables/lists.png"></div></div></div></strong></div><p><strong><br class="figure-break">
      </strong></p><p><strong>某些应用程序提供的更改历史记录功能有限，但是建议使用替代版本控制方法。当规则随时间变化时，旧版本将被存档（为此存在许多开源解决方案，例如Subversion或Git）。</strong></p></div></div><div class="section" title="6.5.7。规则模板"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6464"></a> 6.5.7。规则模板</strong></h3></div></div></div><p><strong>与决策表相关的（但不一定需要电子表格）是“规则模板”（在drools-templates模块中）。它们使用任何表格数据源作为规则数据源-填充模板以生成许多规则。这样既可以使用更灵活的电子表格，也可以使用现有数据库中的规则（例如，需要预先开发模板以生成规则）。</strong></p><p><strong>使用规则模板，数据与规则是分离的，并且对规则的哪一部分受数据驱动没有限制。因此，尽管您可以做决策表中可以做的所有事情，但是您还可以执行以下操作：</strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong>将您的数据存储在数据库（或任何其他格式）中</strong></p></li><li class="listitem"><p><strong>根据数据中的值有条件地生成规则</strong></p></li><li class="listitem"><p><strong>将数据用于规则的任何部分（例如条件运算符，类名，属性名）</strong></p></li><li class="listitem"><p><strong>对同一数据运行不同的模板</strong></p></li></ul></div><p><strong>例如，显示了一个更经典的决策表，但没有任何隐藏的规则元数据行（因此，电子表格仅包含用于生成规则的原始数据）。</strong></p><div class="figure"><strong><a id="d0e6486"></a><p class="title"><strong>图6.21。模板数据</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/DecisionTables/template1.png" alt="模板数据"></div></div></div></strong></div><strong><br class="figure-break"><p>见<code class="filename">ExampleCheese.xls</code>在上述电子表格的示例下载中。</p><p>如果这是一个常规决策表，则在第1行之前以及第1和2行之间将包含隐藏的行，其中包含规则元数据。使用规则模板，数据与规则完全分开。这有两个方便的结果-您可以将多个规则模板应用于相同的数据，而您的数据完全不依赖于规则。那么模板是什么样的？</p><pre><code class="no-highlight">
1  template header
2  age
3  type
4  log
5
6  package org.drools.examples.templates;
7
8  global java.util.List list;
9
10 template "cheesefans"
11
12 rule "Cheese fans_@{row.rowNumber}"
13 when
14    Person(age == @{age})
15    Cheese(type == "@{type}")
16 then
17    list.add("@{log}");
18 end
19
20 end template
</code></pre><p>前面程序清单的注释：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>第1行：所有规则模板均以<code class="code">template header</code> 。</p></li><li class="listitem"><p>第2-4行：标题之后是按其在数据中出现的顺序列出的列。在这种情况下，我们称为第一列<code class="code">age</code> ， 第二<code class="code">type</code>第三<code class="code">log</code> 。</p></li><li class="listitem"><p>第5行：空行表示列定义的结尾。</p></li><li class="listitem"><p>第6-9行：标准规则标题文本。这是标准规则DRL，将显示在生成的DRL的顶部。将package语句以及所有导入，全局和函数定义放入此部分。</p></li><li class="listitem"><p>第10行：关键字<code class="code">template</code>表示规则模板的开始。模板文件中可以有多个模板，但是每个模板应具有唯一的名称。</p></li><li class="listitem"><p>第11-18行：规则模板-有关详细信息，请参见下文。</p></li><li class="listitem"><p>第20行：关键字<code class="code">end template</code>表示模板的结尾。</p></li></ul></div><p>规则模板依靠MVEL使用@ {token_name}语法进行替换。当前有一个内置表达式@ {row.rowNumber}，它为每行数据提供唯一的编号，并使您能够生成唯一的规则名称。对于每行数据，将生成一条规则，其中数据中的值将替换模板中的标记。</p><p>如下例所示，在kmodule.xml文件中定义kbase时，规则模板必须包含在扩展名为.drt的文件中并与相应的决策表相关联。</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://drools.org/xsd/kmodule"&gt;
  &lt;kbase name="TemplatesKB" packages="org.drools.examples.templates"&gt;
    &lt;ruleTemplate dtable="org/drools/examples/templates/ExampleCheese.xls"
                  template="org/drools/examples/templates/Cheese.drt"
                  row="2" col="2"/&gt;
      &lt;ksession name="TemplatesKS"/&gt;
      &lt;/kbase&gt;
&lt;/kmodule&gt;
</code></pre><p>对于上面的示例数据，将生成以下规则文件：</p><pre><code class="no-highlight">
package org.drools.examples.templates;

global java.util.List list;

rule "Cheese fans_1"
when
  Person(age == 42)
  Cheese(type == "stilton")
then
  list.add("Old man stilton");
end

rule "Cheese fans_2"
when
  Person(age == 21)
  Cheese(type == "cheddar")
then
  list.add("Young man cheddar");
end
</code></pre><p>此时， <code class="code">KieSession</code>可以轻松地通过以下方式创建名为“ TemplatesKS”并包含从模板生成的规则的文件<code class="code">KieContainer</code>并用作其他<code class="code">KieSession</code> 。</p><pre><code class="language-java">
KieSession ksession = kc.newKieSession( "TemplatesKS" );

//now create some test data
ksession.insert( new Cheese( "stilton", 42 ) );
ksession.insert( new Person( "michael", "stilton", 42 ) );
final List&lt;String&gt; list = new ArrayList&lt;String&gt;();
ksession.setGlobal( "list", list );

ksession.fireAllRules();
</code></pre></strong></div></div><div class="section" title="6.6。记录中"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e6567"></a> 6.6。记录中</strong></h2></div></div></div><p><strong>照亮黑盒（即规则引擎）的一种方法是使用日志记录级别。</strong></p><p><strong>一切都记录到<a class="link" href="http://www.slf4j.org/">SLF4J</a> ，这是一个简单的日志记录外观，可以将任何日志委托给Logback，Apache Commons Logging，Log4j或java.util.logging。为您选择的日志记录框架向日志记录适配器添加依赖项。如果您尚未使用任何日志记录框架，则可以通过添加以下Maven依赖项来使用Logback：</strong></p><pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong>注意</strong></h2><p><strong>如果您正在为超轻环境而开发，请使用<code class="literal">slf4j-nop</code>要么<code class="literal">slf4j-simple</code>代替。</strong></p></div><p><strong>在程序包上配置日志记录级别<code class="literal">org.drools</code> 。例如：</strong></p><p><strong>在Logback中，在您的<code class="filename">logback.xml</code>文件：</strong></p><pre><code class="language-xml">&lt;configuration&gt;

    &lt;logger name="org.drools" level="debug"/&gt;

    ...

&lt;configuration&gt;</code></pre><p><strong>在Log4J中，在您的<code class="filename">log4j.xml</code>文件：</strong></p><pre><code class="language-xml">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;

    &lt;category name="org.drools"&gt;
      &lt;priority value="debug" /&gt;
    &lt;/category&gt;

    ...

&lt;/log4j:configuration&gt;</code></pre></div></div><div class="chapter" title="第7章。跑步"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e6607"></a>第7章。跑步</strong></h2></div></div></div><div class="toc"><dl><dt><strong><span class="section"><a href="#d0e6612">7.1。KieRuntime</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e6615">7.1.1。入口点</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6790">7.1.2。规则运行时</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6849">7.1.3。StatefulRuleSession</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e6889">7.2。议程</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e6926">7.2.1。解决冲突</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6942">7.2.2。议程集团</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6974">7.2.3。激活组</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e6990">7.2.4。RuleFlowGroup</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7006">7.3。事件模型</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7084">7.4。StatelessKieSession</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7214">7.4.1。顺序模式</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7279">7.5。规则执行模式</a></span></strong></dt><dd><dl><dt><strong><span class="section"><a href="#d0e7286">7.5.1。被动模式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7301">7.5.2。主动模式</a></span></strong></dt></dl></dd><dt><strong><span class="section"><a href="#d0e7377">7.6。传播方式</a></span></strong></dt><dt><strong><span class="section"><a href="#d0e7429">7.7。命令和CommandExecutor</a></span></strong></dt></dl></div><p><strong>这些部分扩展了“ KIE运行”部分，该部分应首先阅读，并包含有关Drools运行时的详细信息。</strong></p><div class="section" title="7.1。KieRuntime"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e6612"></a> 7.1。KieRuntime</strong></h2></div></div></div><div class="section" title="7.1.1。入口点"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6615"></a> 7.1.1。入口点</strong></h3></div></div></div><p><strong>的<code class="code">EntryPoint</code>提供有关插入，更新和删除事实的方法。术语“入口点”与以下事实有关：工作内存中有多个分区，您可以选择要插入的分区。在事件处理用例中，通常使用多个入口点，但是纯规则应用程序也可以使用它们。</strong></p><p><strong>的<code class="code">KieRuntime</code>接口提供了与引擎的主要交互。在规则后果和流程操作中可用。在本手册中，重点是与规则相关的方法和接口，而与流程相关的方法现在将被忽略。但您会注意到<code class="code">KieRuntime</code>从两个继承方法<code class="code">WorkingMemory</code>和<code class="code">ProcessRuntime</code> ，从而提供一个统一的API来处理流程和规则。使用规则时，三个接口构成了<code class="code">KieRuntime</code> ： <code class="code">EntryPoint</code> ， <code class="code">WorkingMemory</code>和<code class="code">KieRuntime</code>本身。</strong></p><div class="figure"><strong><a id="d0e6649"></a><p class="title"><strong>图7.1。入口点</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/EntryPoint.png" alt="入口点"></div></div></strong></div><strong><br class="figure-break"><div class="section" title="7.1.1.1。插入"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6655"></a> 7.1.1.1。插入</h4></div></div></div><p>为了使事实根据规则中的规则进行评估<code class="code">KieBase</code> ，则必须将其插入会话中。通过调用方法来完成<code class="code">insert(yourObject)</code> 。当将事实插入会话时，可能会立即评估其某些属性（急切评估），而某些属性可能会延迟进行以后的评估（惰性评估）。确切的行为取决于所使用的规则引擎算法。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>专家系统通常使用术语<span class="emphasis"><em>断言</em></span>或<span class="emphasis"><em>断言</em></span>来指代可供系统使用的事实。但是，由于“ assert”是大多数语言中的关键字，因此我们决定使用<code class="literal">insert</code>关键词;在本手册中，这两个术语可以互换使用。</p></div><p>插入对象后，它返回一个<code class="code">FactHandle</code> 。这个<code class="code">FactHandle</code>是用于表示您在其中插入的对象的令牌<code class="code">WorkingMemory</code> 。也可用于与<code class="code">WorkingMemory</code>当您希望删除或修改对象时。</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );      </code></pre><p>如KieBase一节所述，工作内存可以两种断言模式进行操作：相等或身份。身份是默认设置。</p><p><span class="emphasis"><em>身份</em></span>意味着工作记忆使用<code class="code">IdentityHashMap</code>存储所有声明的对象。新实例断言总是导致新实例的返回<code class="code">FactHandle</code> ，但是如果再次声明一个实例，则它将返回原始事实句柄，即，它将忽略针对同一对象的重复插入。</p><p><span class="emphasis"><em>平等</em></span>意味着工作记忆使用<code class="code">HashMap</code>存储所有声明的对象。一个对象实例的断言只会返回一个新的<code class="code">FactHandle</code>如果插入的对象不相等（根据其<code class="code">equal()/hashcode()</code>方法）到已经存在的事实。</p></div><div class="section" title="7.1.1.2。删除"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6720"></a> 7.1.1.2。删除</h4></div></div></div><p>为了从会话中删除事实，该方法<code class="code">delete()</code>用来。当事实被删除时，任何活动的并依赖于该事实的匹配都将被取消。请注意，可能有一些规则取决于事实的不存在，在这种情况下，删除事实可能会导致规则被激活。（请参阅<code class="code">not</code>和<code class="code">exists</code>关键字）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>专家系统通常使用术语“ <span class="emphasis"><em>缩回”</em></span>或“ <span class="emphasis"><em>缩回”</em></span>来指代从工作存储器中删除事实的操作。Drools更喜欢关键字<code class="literal">delete</code>与关键字对称<code class="code">insert</code> ; Drools还支持关键字<code class="code">retract</code> ，但已弃用，以支持<code class="code">delete</code> 。在本手册中，这两个术语可以互换使用。</p></div><p>收回可以使用<code class="code">FactHandle</code>是通过插入调用返回的。在规则的右侧<code class="literal">delete</code>语句，与简单的对象引用一起使用。</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = ksession.insert( stilton );
....
ksession.delete( stiltonHandle );            </code></pre></div><div class="section" title="7.1.1.3。更新资料"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6765"></a> 7.1.1.3。更新资料</h4></div></div></div><p>必须将修改后的事实通知规则引擎，以便可以对其进行重新处理。您必须使用<code class="code">update()</code>通知方法<code class="code">WorkingMemory</code>无法通知对象的那些对象的更改对象<code class="code">WorkingMemory</code>他们自己。注意<code class="code">update()</code>始终将修改后的对象作为第二个参数，这使您可以为不可变对象指定新实例。在规则的右侧<code class="code">modify</code>建议使用statement语句，因为它可以进行更改并在单个语句中通知引擎。或者，通过调用setter方法更改事实对象的字段值后，必须调用<code class="code">update</code>立即在更改另一个事实之前发生事件，否则将导致规则引擎中的索引出现问题。Modify语句避免了此问题。</p><pre><code class="language-java">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
...
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </code></pre></div></strong></div><div class="section" title="7.1.2。规则运行时"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6790"></a> 7.1.2。规则运行时</strong></h3></div></div></div><p><strong>RuleRuntime提供对议程的访问，允许查询执行，并允许您访问命名的入口点。</strong></p><div class="figure"><strong><a id="d0e6795"></a><p class="title"><strong>图7.2。规则运行时</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/RuleRuntime.png" alt="规则运行时"></div></div></strong></div><strong><br class="figure-break"><div class="section" title="7.1.2.1。询问"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6801"></a> 7.1.2.1。询问</h4></div></div></div><p>查询用于规则中的基于模式的事实集。模式可以使用可选参数。可以在知识库中定义查询，从那里可以调用查询以返回匹配的结果。在结果集合上进行迭代时，查询中绑定的任何标识符都可以通过调用以下命令来访问相应的事实或事实字段<code class="code">get</code>绑定变量名称作为参数的方法。如果绑定引用事实对象，则可以通过调用检索其FactHandle <code class="code">getFactHandle</code> ，再次以变量名称作为参数。</p><div class="figure"><a id="d0e6812"></a><p class="title"><strong>图7.3。查询结果</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/QueryResults.png" alt="查询结果"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e6818"></a><p class="title"><strong>图7.4。QueryResultsRow</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/QueryResultsRow.png" alt="QueryResultsRow"></div></div></div><br class="figure-break"><div class="example"><a id="d0e6824"></a><p class="title"><strong>示例7.1简单查询示例</strong></p><div class="example-contents"><pre><code class="language-java">QueryResults results =
    ksession.getQueryResults( "my query", new Object[] { "string" } );
for ( QueryResultsRow row : results ) {
    System.out.println( row.get( "varName" ) );
}</code></pre></div></div><br class="example-break"></div><div class="section" title="7.1.2.2。实时查询"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6829"></a> 7.1.2.2。实时查询</h4></div></div></div><p>通过遍历返回的集合调用查询和处理结果不是监视随时间变化的好方法。</p><p>为了缓解这种情况，Drools提供了实时查询，该查询附加了侦听器，而不是返回可迭代的结果集。这些实时查询通过创建视图并发布该视图内容的更改事件而保持打开状态。要激活，请使用参数启动查询，并在结果视图中侦听更改。的<code class="code">dispose</code>方法终止查询并终止此反应式方案。</p><div class="example"><a id="d0e6839"></a><p class="title"><strong>示例7.2实现ViewChangedEventListener</strong></p><div class="example-contents"><pre><code class="language-java">final List updated = new ArrayList();
final List removed = new ArrayList();
final List added = new ArrayList();

ViewChangedEventListener listener = new ViewChangedEventListener() {
 public void rowUpdated(Row row) {
  updated.add( row.get( "$price" ) );
 }

 public void rowRemoved(Row row) {
  removed.add( row.get( "$price" ) );
 }

 public void rowAdded(Row row) {
  added.add( row.get( "$price" ) );
 }
};

// Open the LiveQuery
LiveQuery query = ksession.openLiveQuery( "cheeses",
                                          new Object[] { "cheddar", "stilton" },
                                          listener );
...
...
query.dispose() // calling dispose to terminate the live query</code></pre></div></div><br class="example-break"><p>Drools博客文章包含一个用于实时查询的Glazed List集成示例：</p><p><a class="link" href="http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html">http://blog.athico.com/2010/07/glazed-lists-examples-for-drools-live.html</a></p></div></strong></div><div class="section" title="7.1.3。StatefulRuleSession"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e6849"></a> 7.1.3。StatefulRuleSession</strong></h3></div></div></div><p><strong>的<code class="code">StatefulRuleSession</code>是由<code class="code">KieSession</code>并提供与引擎外部相关的规则相关方法。</strong></p><div class="figure"><strong><a id="d0e6860"></a><p class="title"><strong>图7.5。StatefulRuleSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/StatefulRuleSession.png" alt="StatefulRuleSession"></div></div></strong></div><strong><br class="figure-break"><div class="section" title="7.1.3.1。议程过滤器"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6866"></a> 7.1.3.1。议程过滤器</h4></div></div></div><div class="figure"><a id="d0e6869"></a><p class="title"><strong>图7.6。议程过滤器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/ApiReference/AgendaFilter.png" align="middle" alt="议程过滤器"></div></div></div><br class="figure-break"><p><code class="code">AgendaFilter</code>对象是过滤器接口的可选实现，用于允许或拒绝触发匹配。您过滤的内容完全取决于实现。Drools 4.0曾经提供了一些现成的过滤器，但在Drools 5.0 Knowledge-api中并未公开这些过滤器，但它们易于实现，可以参考Drools 4.0代码库。</p><p>要使用过滤器，请在调用时指定它<code class="code">fireAllRules()</code> 。以下示例仅允许以字符串结尾的规则<code class="code">"Test"</code> 。其他所有内容将被过滤掉。</p><pre><code class="language-java">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</code></pre></div></strong></div></div><div class="section" title="7.2。议程"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e6889"></a> 7.2。议程</strong></h2></div></div></div><p><strong>议程是一项<span class="emphasis"><em>Rete</em></span>功能。在行动期间<code class="code">WorkingMemory</code> ，规则可能会完全匹配并有资格执行；一个工作记忆操作可以产生多个合格规则。完全匹配规则后，将创建一个“匹配项”，引用该规则和匹配的事实，并将其放在议程中。议程使用冲突解决策略控制这些比赛的执行顺序。</strong></p><p><strong>引擎反复循环经过两个阶段：</strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong>工作记忆动作。这是大多数工作的结果，无论是结果（RHS本身）还是主要的Java应用程序过程。后果完成后或主要Java应用程序流程调用<code class="code">fireAllRules()</code>引擎将切换到“议程评估”阶段。</strong></p></li><li class="listitem"><p><strong>议程评估。这将尝试选择要触发的规则。如果未找到任何规则，则退出，否则将激发找到的规则，并将阶段切换回“工作内存操作”。</strong></p></li></ol></div><div class="figure"><strong><a id="d0e6912"></a><p class="title"><strong>图7.7。两阶段执行</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Chapter-Rule_Engine/Two_Phase.png" align="middle" alt="两阶段执行"></div></div></strong></div><strong><br class="figure-break"><p>重复该过程，直到清除议程为止，在这种情况下，控制权返回到调用应用程序。当进行“工作记忆操作”时，不会触发任何规则。</p><div class="figure"><a id="d0e6920"></a><p class="title"><strong>图7.8。议程</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/Agenda.png" alt="议程"></div></div></div><br class="figure-break"><div class="section" title="7.2.1。解决冲突"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6926"></a> 7.2.1。解决冲突</h3></div></div></div><p>当议程上有多个规则时，需要解决冲突。（有关基本知识，请参见“快速入门”一章。）由于触发规则可能会对工作内存产生副作用，因此规则引擎需要知道规则应按什么顺序触发（例如，触发规则A可能导致将规则B从议程中删除）。</p><p>Drools使用的默认冲突解决策略是：Salience和LIFO（后进先出）。</p><p>最明显的是<span class="emphasis"><em>显着性</em></span> （或优先级），在这种情况下，用户可以指定某个规则比其他规则具有更高的优先级（通过给其更高的编号）。在那种情况下，具有较高显着性的规则将是首选。LIFO优先级基于分配的“工作内存操作”计数器值，在同一操作期间创建的所有规则均接收相同的值。具有相同优先级值的一组触发的执行顺序是任意的。</p><p>作为一般规则，最好不要依赖以任何特定顺序触发的规则，并且在编写规则时不必担心“流程”。但是，当需要流程时，存在许多可能性，包括但不限于：议程组，规则流程组，激活组，控制/信号量事实。这些将在后面的部分中讨论。</p><p>Drools 4.0支持自定义冲突解决策略；尽管该功能在Drools中仍然存在，但尚未通过Drools 5.0中的Knowledge-api向最终用户公开。</p></div><div class="section" title="7.2.2。议程集团"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6942"></a> 7.2.2。议程集团</h3></div></div></div><div class="figure"><a id="d0e6945"></a><p class="title"><strong>图7.9。议程集团</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/AgendaGroup.png" alt="议程集团"></div></div></div><br class="figure-break"><p>议程组是一种划分议程上的规则（实际上是匹配项）的方法。在任何时候，只有一组具有“焦点”，这意味着该组中的规则匹配只会生效。您还可以使用带有“自动聚焦”的规则，这意味着当该规则的条件为真时，焦点将集中在其议程组中。</p><p>议程组在CLIPS术语中称为“模块”。尽管最好设计不需要控制流的规则，但这并不总是可能的。议程组提供了一种方便的方法来在分组规则之间创建“流程”。您可以从规则引擎内部或通过API切换具有焦点的组。如果您的规则明确需要处理的多个“阶段”或“顺序”，请考虑为此目的使用议程组。</p><p>每一次<code class="code">setFocus()</code>被称为将议程组推入堆栈。当焦点组为空时，将从堆栈中弹出焦点组，并评估现在位于顶部的焦点组。议程组可以出现在堆栈中的多个位置。默认的议程组是“ MAIN”，所有未指定议程组的规则都在该组中。在默认情况下，它始终始终是堆栈中的第一个组，最初会给予焦点。</p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).setFocus();</code></pre><p>的<code class="code">clear()</code>方法可以用于在某个人有机会被触发之前取消属于给定议程组的规则所生成的所有激活。</p><pre><code class="language-java">ksession.getAgenda().getAgendaGroup( "Group A" ).clear();</code></pre><p>请注意，由于Drools使用的phreak算法的惰性，默认情况下仅在触发时才实现激活，但是可以预见评估，然后在事实被发现时激活给定规则。通过使用注释将其插入会话<code class="code">@Propagation(IMMEDIATE)</code>如传播模式部分所述。</p></div><div class="section" title="7.2.3。激活组"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6974"></a> 7.2.3。激活组</h3></div></div></div><div class="figure"><a id="d0e6977"></a><p class="title"><strong>图7.10。激活组</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/ActivationGroup.png" alt="激活组"></div></div></div><br class="figure-break"><p>激活组是由相同的“激活组”规则属性绑定在一起的一组规则。在该组中，只有一个规则可以触发，并且在该规则触发后，所有其他规则都将从议程中删除。的<code class="code">clear()</code>可以随时调用方法，该方法会在有机会触发之前取消所有激活。</p><pre><code class="language-java">ksession.getAgenda().getActivationGroup( "Group B" ).clear();</code></pre></div><div class="section" title="7.2.4。RuleFlowGroup"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6990"></a> 7.2.4。RuleFlowGroup</h3></div></div></div><div class="figure"><a id="d0e6993"></a><p class="title"><strong>图7.11。RuleFlowGroup</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/RuleFlowGroup.png" alt="RuleFlowGroup"></div></div></div><br class="figure-break"><p>规则流组是由“ ruleflow-group”规则属性关联的一组规则。这些规则仅在激活该组后才能触发。仅当规则流图的详细说明到达代表该组的节点时，该组本身才能变为活动状态。在这里， <code class="code">clear()</code>可以随时调用方法取消仍保留在议程中的所有匹配项。</p><pre><code class="language-java">ksession.getAgenda().getRuleFlowGroup( "Group C" ).clear();</code></pre></div></strong></div><div class="section" title="7.3。事件模型"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e7006"></a> 7.3。事件模型</strong></h2></div></div></div><p><strong>事件包提供了用于通知规则引擎事件的方法，包括规则触发，声明的对象等。例如，这使您可以将日志记录和审核活动与应用程序的主要部分（以及规则）分开。</strong></p><p><strong>的<code class="code">WorkingMemoryEventManager</code>允许添加和删除侦听器，以便可以侦听工作内存和议程的事件。</strong></p><div class="figure"><strong><a id="d0e7016"></a><p class="title"><strong>图7.12。WorkingMemoryEventManager</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/WorkingMemoryEventManager.png" alt="WorkingMemoryEventManager"></div></div></strong></div><strong><br class="figure-break"><p>以下代码段显示了如何声明简单的议程侦听器并将其附加到会话。射击后将打印火柴。</p><div class="example"><a id="d0e7024"></a><p class="title"><strong>示例7.3添加一个AgendaEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DefaultAgendaEventListener() {
   public void afterMatchFired(AfterMatchFiredEvent event) {
       super.afterMatchFired( event );
       System.out.println( event );
   }
});     </code></pre></div></div><br class="example-break"><p>流口水还提供<code class="code">DebugRuleRuntimeEventListener</code>和<code class="code">DebugAgendaEventListener</code>使用调试打印语句实现每种方法。要打印所有工作内存事件，请添加一个侦听器，如下所示：</p><div class="example"><a id="d0e7037"></a><p class="title"><strong>示例7.4添加一个DebugRuleRuntimeEventListener</strong></p><div class="example-contents"><pre><code class="language-java">ksession.addEventListener( new DebugRuleRuntimeEventListener() );     </code></pre></div></div><br class="example-break"><p>当前支持的事件是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>MatchCreatedEvent</p></li><li class="listitem"><p>MatchCancelledEvent</p></li><li class="listitem"><p>BeforeMatchFiredEvent</p></li><li class="listitem"><p>AfterMatchFiredEvent</p></li><li class="listitem"><p>AgendaGroupPushedEvent</p></li><li class="listitem"><p>AgendaGroupPoppedEvent</p></li><li class="listitem"><p>ObjectInsertEvent</p></li><li class="listitem"><p>ObjectDeletedEvent</p></li><li class="listitem"><p>ObjectUpdatedEvent</p></li><li class="listitem"><p>ProcessCompletedEvent</p></li><li class="listitem"><p>ProcessNodeLeftEvent</p></li><li class="listitem"><p>ProcessNodeTriggeredEvent</p></li><li class="listitem"><p>ProcessStartEvent</p></li></ul></div></strong></div><div class="section" title="7.4。StatelessKieSession"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e7084"></a> 7.4。StatelessKieSession</strong></h2></div></div></div><p><strong>的<code class="code">StatelessKieSession</code>包装<code class="code">KieSession</code> ，而不是扩展它。它的主要重点是决策服务类型方案。它避免了打电话的需要<code class="code">dispose()</code> 。无状态会话不支持迭代插入和方法调用<code class="code">fireAllRules()</code>来自Java代码；打电话的行为<code class="code">execute()</code>是单次使用的方法，将在内部实例化一个<code class="code">KieSession</code> ，添加所有用户数据并执行用户命令，然后调用<code class="code">fireAllRules()</code> ，然后致电<code class="code">dispose()</code> 。虽然使用此类的主要方法是通过<code class="code">BatchExecution</code> （的子接口<code class="code">Command</code> ）（由<code class="code">CommandExecutor</code>接口，当需要简单的对象插入时，提供了两种便捷的方法。的<code class="code">CommandExecutor</code>和<code class="code">BatchExecution</code>在各自的部分中进行了详细讨论。</strong></p><div class="figure"><strong><a id="d0e7128"></a><p class="title"><strong>图7.13。StatelessKieSession</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ApiReference/StatelessKieSession.png" alt="StatelessKieSession"></div></div></strong></div><strong><br class="figure-break"><p>我们的简单示例显示了使用便捷API执行给定Java对象集合的无状态会话。它将迭代集合，依次插入每个元素。</p><div class="example"><a id="d0e7136"></a><p class="title"><strong>示例7.5带有集合的简单StatelessKieSession执行</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute( collection );</code></pre></div></div><br class="example-break"><p>如果将其作为单个命令完成，则将如下所示：</p><div class="example"><a id="d0e7143"></a><p class="title"><strong>示例7.6使用InsertElements命令简单执行StatelessKieSession</strong></p><div class="example-contents"><pre><code class="language-java">ksession.execute( CommandFactory.newInsertElements( collection ) );  </code></pre></div></div><br class="example-break"><p>如果要插入集合本身以及集合的各个元素，则<code class="code">CommandFactory.newInsert(collection)</code>会做的工作。</p><p>方法<code class="code">CommandFactory</code>创建受支持的命令，所有命令都可以使用XStream和<code class="code">BatchExecutionHelper</code> 。<code class="code">BatchExecutionHelper</code>提供有关XML格式的详细信息，以及如何使用Drools Pipeline自动整理<code class="code">BatchExecution</code>和<code class="code">ExecutionResults</code> 。</p><p><code class="code">StatelessKieSession</code>支持全局变量，范围有很多种。我将首先介绍非命令方式，因为命令的作用域是特定的执行调用。全局变量可以通过三种方式解决。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>StatelessKieSession方法<code class="code">getGlobals()</code>返回一个Globals实例，该实例提供对会话的Globals的访问。这些将为<span class="emphasis"><em>所有</em></span>执行调用共享。请注意有关可变全局变量的注意事项，因为执行调用可以在不同线程中同时执行。</p><div class="example"><a id="d0e7184"></a><p class="title"><strong>示例7.7全球范围的会议</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( "hbnSession", hibernateSession );
// Execute while being able to resolve the "hbnSession" identifier.
ksession.execute( collection ); </code></pre></div></div><br class="example-break"></li><li class="listitem"><p>使用委托是全局解决的另一种方法。为全局值分配<code class="code">setGlobal(String, Object)</code> ）导致值存储在内部集合中，这些标识符将标识符映射到值。此内部集合中的标识符将优先于任何提供的委托。仅当在此内部集合中找不到标识符时，才使用全局委托（如果有）。</p></li><li class="listitem"><p>解决全局变量的第三种方法是使执行范围全局变量。在这里<code class="code">Command</code>设置全局传递给<code class="code">CommandExecutor</code> 。</p></li></ul></div><p>的<code class="code">CommandExecutor</code>界面还提供了通过“输出”参数导出数据的功能。插入的事实，全局变量和查询结果都可以返回。</p><div class="example"><a id="d0e7209"></a><p class="title"><strong>示例7.8输出标识符</strong></p><div class="example-contents"><pre><code class="language-java">// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( "list1", new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( "jon", 102 ), "person" ) );
cmds.add( CommandFactory.newQuery( "Get People" "getPeople" );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( "list1" );
// Retrieve the inserted Person fact
results.getValue( "person" );
// Retrieve the query as a QueryResults instance.
results.getValue( "Get People" );</code></pre></div></div><br class="example-break"><div class="section" title="7.4.1。顺序模式"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7214"></a> 7.4.1。顺序模式</h3></div></div></div><p>使用Rete，您可以进行有状态的会话，可以随着时间的推移声明和修改对象，还可以添加和删除规则。现在，如果我们假设一个无状态会话会发生什么，在该会话中，在初始数据集之后不能再声明或修改任何数据，并且不能添加或删除规则了？当然，不必重新评估规则，并且引擎将能够以简化的方式运行。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>通过显着性和在规则集中的位置对规则进行排序（通过在规则终端节点上设置序列属性）。</p></li><li class="listitem"><p>创建一个元素，每个可能的规则匹配都包含一个元素；元素位置指示点火顺序。</p></li><li class="listitem"><p>关闭所有节点存储器，右输入对象存储器除外。</p></li><li class="listitem"><p>断开左输入适配器节点的传播，并在命令对象中引用该对象和该节点，然后将其添加到工作内存上的列表中以供以后执行。</p></li><li class="listitem"><p>声明所有对象，并在完成所有断言并填充右输入节点存储器后，检查“命令”列表并依次执行每个命令。</p></li><li class="listitem"><p>所有确定的匹配项都应根据确定的规则序号放置在元素中。记录第一个和最后一个填充的元素，以减小迭代范围。</p></li><li class="listitem"><p>迭代Matches的元素，依次执行填充的元素。</p></li><li class="listitem"><p>如果我们有最大数量的允许规则执行，则可以提早退出网络评估以激发元素中的所有规则。</p></li></ol></div><p>的<code class="code">LeftInputAdapterNode</code>不再创建元组，添加对象，然后传播元组-而是创建一个Command对象并将其添加到工作内存中的列表中。该Command对象包含对<code class="code">LeftInputAdapterNode</code>和传播的对象。这会在插入时停止所有左输入传播，因此我们知道右输入传播将永远不需要尝试与左输入进行联接（无需使用左输入内存）。所有节点的内存都已关闭，包括左输入Tuple存储器，但右输入对象存储器除外，这意味着记住插入传播的唯一节点是右输入对象存储器。一旦所有的断言都完成并且所有的右输入存储器都被填充，我们就可以迭代列表。 <code class="code">LeftInputAdatperNode</code>命令对象依次调用每个对象。它们将在试图与右输入对象连接的网络中传播，但不会在左输入中被记住，因为我们知道不会再有其他对象断言，因此会传播到右输入存储器中。</p><p>不再有议程，有了优先队列来安排元组。相反，规则的数量只是一个元素。的序号<code class="code">RuleTerminalNode</code>表示元素中放置匹配项的元素。一旦所有Command对象完成，我们就可以迭代我们的元素，依次检查每个元素，并触发Matches（如果存在）。为了提高性能，我们记住元素中的第一个和最后一个填充的单元格。网络建设，每个<code class="code">RuleTerminalNode</code>根据显着性编号及其被添加到网络的顺序，被赋予序列号。</p><p>通常，右输入节点的内存是用于快速删除对象的哈希映射。在这里，我们知道不会删除任何对象，当对象的值未建立索引时，我们可以使用列表。对于更多的对象，使用索引的哈希图可以提高性能；如果我们知道一个对象类型只有几个实例，那么索引可能就没有优势，可以使用一个列表。</p><p>顺序模式只能与无状态会话一起使用，并且默认情况下处于关闭状态。要打开它，请致电<code class="code">RuleBaseConfiguration.setSequential(true)</code> ，或设置rulebase配置属性<code class="code">drools.sequential</code>真实。顺序模式可以通过调用<code class="code">setSequentialAgenda</code>与<code class="code">SequentialAgenda.DYNAMIC</code> 。您也可以将“ drools.sequential.agenda”属性设置为“ sequential”或“ dynamic”。</p></div></strong></div><div class="section" title="7.5。规则执行模式"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e7279"></a> 7.5。规则执行模式</strong></h2></div></div></div><p><strong>Drools为规则执行提供了两种模式-被动和主动。</strong></p><p><strong>作为一般准则，被动模式最适合需要明确控制引擎何时评估和触发规则的规则引擎应用程序，或最适合使用伪时钟的CEP应用程序。主动模式对规则引擎应用程序最为有效，后者可以控制何时评估规则并将规则触发到引擎，或者对于使用实时时钟的典型CEP应用程序。</strong></p><div class="section" title="7.5.1。被动模式"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e7286"></a> 7.5.1。被动模式</strong></h3></div></div></div><p><strong>使用被动模式时，用户不仅负责工作内存操作，例如<code class="code">insert()</code> ，也适用于规则何时评估数据并触发生成的规则实例化-使用<code class="code">fireAllRules()</code></strong></p><p><strong>使用被动模式的CEP应用程序的Drools代码示例大纲：</strong></p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );
KieSession session = kbase.newKieSession( conf, null );
SessionPseudoClock clock = session.getSessionClock();

session.insert( tick1 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick2 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick3 );
session.fireAllRules();

session.dispose();</code></pre></div><div class="section" title="7.5.2。主动模式"><div class="titlepage"><div><div><h3 class="title"><strong><a id="d0e7301"></a> 7.5.2。主动模式</strong></h3></div></div></div><p><strong>Drools提供了<code class="code">fireUntilHalt()</code>方法，以“活动模式”启动引擎，该模式在行为上是异步的，在该模式下，规则将不断进行评估和触发，直到<code class="code">halt()</code>打电话了。</strong></p><p><strong>这对于需要通常称为“活动查询”的CEP方案特别有用。</strong></p><p><strong>请注意打电话<code class="code">fireUntilHalt()</code>阻止当前线程，而引擎将启动并继续异步运行，直到<code class="code">halt()</code>在KieSession上被调用。因此建议致电<code class="code">fireUntilHalt()</code>来自专用线程，因此当前线程不会无限期地被阻塞；这也使当前线程可以调用<code class="code">halt()</code>在稍后阶段，参考。下面的例子。</strong></p><p><strong>使用活动模式的CEP应用程序的Drools代码示例大纲：</strong></p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
KieSession session = kbase.newKieSession( conf, null );

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

session.insert( tick1 );

... Thread.sleep( 1000L ); ...

session.insert( tick2 );

... Thread.sleep( 1000L ); ...

session.insert( tick3 );

session.halt();
session.dispose();</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong>注意</strong></h2><p><strong>通常不建议混用<code class="code">fireAllRules()</code>和<code class="code">fireUntilHalt()</code> ，尤其是来自不同线程的。但是，借助内部状态机，发动机能够安全地处理此类情况。如果<code class="code">fireAllRules()</code>正在运行，有电话<code class="code">fireUntilHalt()</code>完成后，引擎将一直等到<code class="code">fireAllRules()</code>完成后再开始<code class="code">fireUntilHalt()</code> 。但是如果<code class="code">fireUntilHalt()</code>正在运行， <code class="code">fireAllRules()</code>会被调用，后者将被忽略，而直接返回。有关线程安全和内部状态机的更多详细信息，请参见“改进的多线程行为”一节。</strong></p></div><div class="section" title="7.5.2.1。在活动模式下自动执行KieSession操作"><div class="titlepage"><div><div><h4 class="title"><strong><a id="d0e7359"></a> 7.5.2.1。在活动模式下自动执行KieSession操作</strong></h4></div></div></div><p><strong>在活动模式下，Drools引擎将控制何时评估和触发规则；因此，以线程安全的方式对KieSession进行操作非常重要。此外，从客户端的角度来看，可能需要在两次规则评估之间在KieSession上调用多个操作，但引擎必须将这些操作视为原子操作：例如，在处插入多个Fact。给定的时间，但是让引擎等待直到所有插入操作完成，然后再次评估规则。</strong></p><p><strong>在活动模式下，Drools提供了一个commit（）方法来对KieSession进行分组和执行操作，作为线程安全的原子动作。</strong></p><p><strong>在活动模式下以原子方式执行KieSession操作的Drools代码示例概述：</strong></p><pre><code class="language-java">KieSession session = ...;

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

final FactHandle fh = session.insert( fact_a );

... Thread.sleep( 1000L ); ...

session.submit( new KieSession.AtomicAction() {
  @Override
  public void execute( KieSession kieSession ) {
    fact_a.setField("value");
    kieSession.update( fh, fact_a );
    kieSession.insert( fact_1 );
    kieSession.insert( fact_2 );
    kieSession.insert( fact_3 );
  }
} );

... Thread.sleep( 1000L ); ...

session.insert( fact_z );

session.halt();
session.dispose();</code></pre><p><strong>作为提醒示例，事实句柄也可以从KieSession中检索：</strong></p><pre><code class="language-java">...
session.insert( fact_a );

... Thread.sleep( 1000L ); ...

session.submit( new KieSession.AtomicAction() {
  @Override
  public void execute( KieSession kieSession ) {
    final FactHandle fh = kieSession.getFactHandle( fact_a );
    fact_a.setField("value");
    kieSession.update( fh, fact_a );
    kieSession.insert( fact_1 );
    kieSession.insert( fact_2 );
    kieSession.insert( fact_3 );
  }
} );

...</code></pre></div></div></div><div class="section" title="7.6。传播方式"><div class="titlepage"><div><div><h2 class="title"><strong><a id="d0e7377"></a> 7.6。传播方式</strong></h2></div></div></div><p><strong>PHREAK作为Drools引擎的默认算法的引入使规则的评估变得懒惰。这种新的Drools懒惰行为可以提高性能，但在某些特定情况下，则打破了Drools某些功能的语义。</strong></p><p><strong>更确切地说，在某些情况下，必须立即将新事实的插入传播到会话中。例如，Drools允许在查询之前以'？的形式在只拉（或被动）模式下执行查询。'符号，如下例所示：</strong></p><div class="example"><strong><a id="d0e7384"></a><p class="title"><strong>示例7.9被动查询</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></strong></div><strong><br class="example-break"><p>在这种情况下，由于查询是被动的，因此它不应对在查询本身中插入符合联接条件的String做出反应。换句话说，这一系列命令</p><pre><code class="language-java">KieSession ksession = ...
ksession.insert(1);
ksession.insert("1");
ksession.fireAllRules();</code></pre><p>不应导致规则R触发，因为在整数之后插入了满足查询条件的字符串，并且被动查询不应对此插入作出反应。相反，如果插入顺序被反转，则规则应触发，因为当存在现有String可以满足被动查询时，Integer的插入将触发它。</p><p>不幸的是，PHREAK的惰性特性不允许引擎对这两个事实的插入顺序进行任何区分，因此该规则在两种情况下都适用。在这种情况下，有必要像旧的基于RETEOO的引擎一样急切地评估规则。</p><p>在其他情况下，要求传播是热切的，这意味着它不是即时的，但是无论如何必须在引擎/议程开始计划的评估之前进行。例如，当规则具有no-loop或lock-on-active属性时，这是必需的，实际上，当这种情况发生时，此传播模式将由引擎自动实施。</p><p>为了涵盖这些用例，以及在所有其他需要立即评估或急切评估规则的情况下，可以通过使用<span class="bold"><strong>@Propagation（Propagation。）注释规则本身来声明性地指定<span class="bold"><strong>。类型）</strong></span> ，其中传播。Type是具有3个可能值的枚举：</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><span class="bold"><strong>IMMEDIATE</strong></span>表示立即进行传播。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>EAGER</strong></span>意味着传播是<span class="bold"><strong>缓慢</strong></span>进行的，但是在计划的评估之前急切地进行了评估。</strong></p></li><li class="listitem"><p><strong><span class="bold"><strong>LAZY</strong></span>表示传播完全是惰性的，这是默认的PHREAK行为</strong></p></li></ul></div><p><strong>这意味着下面的drl：</strong></p><div class="example"><strong><a id="d0e7422"></a><p class="title"><strong>示例7.10使用被动查询的数据驱动规则</strong></p><div class="example-contents"><pre><code class="language-java">query Q (Integer i)
    String( this == i.toString() )
end
rule R @Propagation(IMMEDIATE) when
    $i : Integer()
    ?Q( $i; )
then
    System.out.println( $i );
end</code></pre></div></strong></div><strong><br class="example-break"><p>当且仅当将Integer插入到String之后时，规则R才会触发，从而符合被动查询的语义。</p></strong></strong></div><div class="section" title="7.7。命令和CommandExecutor"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e7429"></a> 7.7。命令和CommandExecutor</strong></strong></h2></div></div></div><p><strong><strong>的<code class="code">CommandFactory</code>允许在这些会话上执行命令，唯一的区别是无状态知识会话执行<code class="code">fireAllRules()</code>最后，在安排会议之前。当前支持的命令是：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>FireAllRules</strong></strong></p></li><li class="listitem"><p><strong><strong>GetGlobal</strong></strong></p></li><li class="listitem"><p><strong><strong>SetGlobal</strong></strong></p></li><li class="listitem"><p><strong><strong>插入对象</strong></strong></p></li><li class="listitem"><p><strong><strong>InsertElements</strong></strong></p></li><li class="listitem"><p><strong><strong>询问</strong></strong></p></li><li class="listitem"><p><strong><strong>启动过程</strong></strong></p></li><li class="listitem"><p><strong><strong>批处理</strong></strong></p></li></ul></div><p><strong><strong><code class="code">InsertObject</code>将插入一个带有可选“出”标识符的对象。 <code class="code">InsertElements</code>将迭代一个Iterable，插入每个元素。这意味着无状态知识会话不再仅限于插入对象，它现在可以启动进程或执行查询，并且可以按任何顺序执行。</strong></strong></p><div class="example"><strong><strong><a id="d0e7472"></a><p class="title"><strong>示例7.11插入命令</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults =
  ksession.execute( CommandFactory.newInsert( new Cheese( "stilton" ), "stilton_id" ) );
Stilton stilton = bresults.getValue( "stilton_id" );
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>execute方法始终返回一个<code class="code">ExecutionResults</code>实例，如果它们指定了out标识符，例如上面的“ stilton_id”，则可以访问任何命令结果。</p><div class="example"><a id="d0e7482"></a><p class="title"><strong>示例7.12InsertElements命令</strong></p><div class="example-contents"><pre><code class="language-java">StatelessKieSession ksession = kbase.newStatelessKieSession();
Command cmd = CommandFactory.newInsertElements( Arrays.asList( Object[] {
                  new Cheese( "stilton" ),
                  new Cheese( "brie" ),
                  new Cheese( "cheddar" ),
              });
ExecutionResults bresults = ksession.execute( cmd );
</code></pre></div></div><br class="example-break"><p>execute方法仅允许单个命令。那边<code class="code">BatchExecution</code>进来，它表示从命令列表创建的复合命令。现在，execute将遍历列表并依次执行每个命令。这意味着您可以插入一个对象，启动一个流程，调用fireAllRules并执行一个查询<code class="code">execute(...)</code>通话，功能非常强大。</p><p>如前所述，StatelessKieSession将执行<code class="code">fireAllRules()</code>自动结束。但是，敏锐的读者可能已经注意到<code class="code">FireAllRules</code>命令，并想知道如何与StatelessKieSession一起使用。的<code class="code">FireAllRules</code>命令是允许的，使用它会在最后禁用自动执行；考虑将其用作一种手动替代功能。</p><p>定制的XStream编组器可以与Drools Pipeline一起使用，以实现XML脚本编制，这对于服务是完美的。这是两个简单的XML示例，一个用于BatchExecution，另一个用于<code class="code">ExecutionResults</code> 。</p><div class="example"><a id="d0e7511"></a><p class="title"><strong>示例7.13简单的BatchExecution XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='outStilton'&gt;
      &lt;org.drools.compiler.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;price&gt;25&lt;/price&gt;
         &lt;oldPrice&gt;0&lt;/oldPrice&gt;
      &lt;/org.drools.compiler.Cheese&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e7516"></a><p class="title"><strong>示例7.14简单的ExecutionResults XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;execution-results&gt;
   &lt;result identifier='outStilton'&gt;
      &lt;org.drools.compiler.Cheese&gt;
         &lt;type&gt;stilton&lt;/type&gt;
         &lt;oldPrice&gt;25&lt;/oldPrice&gt;
         &lt;price&gt;30&lt;/price&gt;
      &lt;/org.drools.compiler.Cheese&gt;
   &lt;/result&gt;
&lt;/execution-results&gt;
</code></pre></div></div><br class="example-break"><p>集成手册中介绍的Spring和Camel有助于声明式服务。</p><div class="example"><a id="d0e7523"></a><p class="title"><strong>示例7.15将BatchExecution编组为XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
  &lt;insert out-identifier="stilton"&gt;
    &lt;org.drools.compiler.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;1&lt;/price&gt;
      &lt;oldPrice&gt;0&lt;/oldPrice&gt;
    &lt;/org.drools.compiler.Cheese&gt;
  &lt;/insert&gt;
  &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
    &lt;string&gt;stilton&lt;/string&gt;
    &lt;string&gt;cheddar&lt;/string&gt;
  &lt;/query&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><p>的<code class="code">CommandExecutor</code>返回一个<code class="code">ExecutionResults</code> ，这也由管道代码段处理。<batch-execution>上面</batch-execution>的<batch-execution>XML示例的</batch-execution>类似输出为<batch-execution>：</batch-execution></p><div class="example"><a id="d0e7536"></a><p class="title"><strong>示例7.16ExecutionResults编组到XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;execution-results&gt;
  &lt;result identifier="stilton"&gt;
    &lt;org.drools.compiler.Cheese&gt;
      &lt;type&gt;stilton&lt;/type&gt;
      &lt;price&gt;2&lt;/price&gt;
    &lt;/org.drools.compiler.Cheese&gt;
  &lt;/result&gt;
  &lt;result identifier='cheeses2'&gt;
    &lt;query-results&gt;
      &lt;identifiers&gt;
        &lt;identifier&gt;cheese&lt;/identifier&gt;
      &lt;/identifiers&gt;
      &lt;row&gt;
        &lt;org.drools.compiler.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;2&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.compiler.Cheese&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;org.drools.compiler.Cheese&gt;
          &lt;type&gt;cheddar&lt;/type&gt;
          &lt;price&gt;1&lt;/price&gt;
          &lt;oldPrice&gt;0&lt;/oldPrice&gt;
        &lt;/org.drools.compiler.Cheese&gt;
      &lt;/row&gt;
    &lt;/query-results&gt;
  &lt;/result&gt;
&lt;/execution-results&gt;
</code></pre></div></div><br class="example-break"><p>的<code class="code">BatchExecutionHelper</code>提供了一个配置的XStream实例来支持批处理执行的封送处理，其中生成的XML可以用作消息格式，如上所示。配置的转换器仅适用于通过命令工厂支持的命令。用户可以为其用户对象添加其他转换器。这对于编写无状态或有状态知识会话的脚本非常有用，尤其是在涉及服务时。</p><p>当前没有支持架构验证的XML架构。此处概述了基本格式，并且drools-pipeline模块在<code class="code">XStreamBatchExecutionTest</code>单元测试。根元素是<batch-execution>并且它可以包含零个或多个command元素。</batch-execution></p><div class="example"><a id="d0e7551"></a><p class="title"><strong>示例7.17根XML元素</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
...
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><p>它包含代表命令的元素的列表，受支持的命令仅限于命令工厂提供的命令。其中最基本的是<insert>元素，它插入对象。插入元素的内容是用户对象，由XStream指示。</insert></p><div class="example"><a id="d0e7558"></a><p class="title"><strong>示例7.18插入</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert&gt;
      ...&lt;!-- any user object --&gt;
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><p>insert元素具有“ out-identifier”属性，要求插入的对象也将作为结果有效内容的一部分返回。</p><div class="example"><a id="d0e7565"></a><p class="title"><strong>示例7.19使用输出标识符命令插入</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert out-identifier='userVar'&gt;
      ...
   &lt;/insert&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><p>也可以使用<insert-elements>元素插入对象的<insert-elements>集合。该命令不支持输出标识符。的<code class="code">org.domain.UserClass</code>只是XStream序列化的一个说明性用户对象。</insert-elements></insert-elements></p><div class="example"><a id="d0e7575"></a><p class="title"><strong>示例7.20插入元素命令</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;insert-elements&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
      &lt;org.domain.UserClass&gt;
         ...
      &lt;/org.domain.UserClass&gt;
   &lt;/insert-elements&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"><p>而<code class="literal">out</code>属性在返回特定实例作为结果有效负载时很有用，我们通常希望运行实际查询。支持参数查询和无参数查询。的<code class="literal">name</code> attribute是要调用的查询的名称，并且<code class="literal">out-identifier</code>是要用于查询结果的标识符<code class="code"><execution-results></code>有效载荷。</p><div class="example"><a id="d0e7594"></a><p class="title"><strong>示例7.21。查询命令</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;batch-execution&gt;
   &lt;query out-identifier='cheeses' name='cheeses'/&gt;
   &lt;query out-identifier='cheeses2' name='cheesesWithParams'&gt;
      &lt;string&gt;stilton&lt;/string&gt;
      &lt;string&gt;cheddar&lt;/string&gt;
   &lt;/query&gt;
&lt;/batch-execution&gt;
</code></pre></div></div><br class="example-break"></strong></strong></div></div><div class="chapter" title="第八章规则语言参考"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="DroolsLanguageReferenceChapter"></a>第八章规则语言参考</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e7602">8.1。总览</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e7610">8.1.1。规则文件</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e7643">8.1.2。什么是规则</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e7679">8.2。关键词</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e7874">8.3。评论</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e7879">8.3.1。单行注释</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e7889">8.3.2。多行评论</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e7902">8.4。错误讯息</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e7907">8.4.1。讯息格式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e7938">8.4.2。错误信息说明</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8093">8.4.3。其他讯息</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e8098">8.5。包</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e8121">8.5.1。进口</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8135">8.5.2。全球</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e8178">8.6。功能</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8212">8.7。类型声明</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e8240">8.7.1。声明新类型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8397">8.7.2。声明元数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8758">8.7.3。声明现有类型的元数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8801">8.7.4。声明类型的参数化构造函数</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8825">8.7.5。非类型安全类</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8830">8.7.6。从应用程序代码访问声明的类型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8879">8.7.7。类型声明“扩展”</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e8911">8.7.8。特质</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e9154">8.8。规则</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e9196">8.8.1。规则属性</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e9356">8.8.2。计时器和日历</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e9456">8.8.3。左侧语法（当）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e11687">8.8.4。右侧（然后）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e11934">8.8.5。有条件的命名后果</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e11959">8.8.6。关于自动装箱和原始类型的注释</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#QuerySection">8.9。询问</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12041">8.10。领域特定语言</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12051">8.10.1。何时使用DSL</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12058">8.10.2。DSL基础</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12127">8.10.3。向事实添加约束</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12171">8.10.4。开发DSL</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12184">8.10.5。DSL和DSLR参考</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="8.1。总览"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e7602"></a> 8.1。总览</strong></strong></h2></div></div></div><p><strong><strong>Drools有一种“本机”规则语言。这种格式在标点符号方面非常轻巧，并且通过“扩展器”支持自然语言和特定于领域的语言，该扩展器允许该语言转变为您的问题领域。本章主要与本机规则格式配合使用。用于表示语法的图称为“铁路”图，它们基本上是语言术语的流程图。技术上非常热衷的人也可以指<code class="filename">DRL.g</code>这是规则语言的Antlr3语法。如果使用Rule Workbench，则可以在内容帮助下为您完成很多规则结构，例如，键入“ ru”并按ctrl + space，它将为您构建规则结构。</strong></strong></p><div class="section" title="8.1.1。规则文件"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7610"></a> 8.1.1。规则文件</strong></strong></h3></div></div></div><p><strong><strong>规则文件通常是扩展名为.drl的文件。在DRL文件中，您可以具有多个规则，查询和函数，以及一些由规则和查询分配和使用的资源声明，例如导入，全局和属性。但是，您也可以将规则分布在多个规则文件中（在这种情况下，建议使用扩展名.rule，但不是必需的）-在文件中分布规则可以帮助管理大量规则。DRL文件只是一个文本文件。</strong></strong></p><p><strong><strong>规则文件的整体结构为：</strong></strong></p><div class="example"><strong><strong><a id="d0e7617"></a><p class="title"><strong>示例8.1规则文件</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>package </strong></span><em class="replaceable"><code>package-name</code></em>

<em class="replaceable"><code>imports</code></em>

<em class="replaceable"><code>globals</code></em>

<em class="replaceable"><code>functions</code></em>

<em class="replaceable"><code>queries</code></em>

<em class="replaceable"><code>rules</code></em>
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>声明元素的顺序并不重要，但包名称必须声明为规则文件中的第一个元素，但包名称除外。所有元素都是可选的，因此您将仅使用所需的元素。我们将在以下各节中对它们进行讨论。</p></strong></strong></div><div class="section" title="8.1.2。什么是规则"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7643"></a> 8.1.2。什么是规则</strong></strong></h3></div></div></div><p><strong><strong>对于不耐烦的人，就像早期的观点一样，规则具有以下大致结构：</strong></strong></p><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> <em class="replaceable"><code>"name"</code></em>
    <em class="replaceable"><code>attributes</code></em>
    <span class="bold"><strong>when</strong></span>
        <em class="replaceable"><code>LHS</code></em>
    <span class="bold"><strong>then</strong></span>
        <em class="replaceable"><code>RHS</code></em>
<span class="bold"><strong>end</strong></span>
</code></pre><p><strong><strong>真的就是这么简单。通常不需要标点符号，甚至“名称”的双引号和换行符都是可选的。属性是简单的（总是可选的）提示规则的行为。LHS是规则的条件部分，它遵循下面介绍的某些语法。RHS基本上是一个块，允许执行方言特定的语义代码。</strong></strong></p><p><strong><strong>重要的是要注意，空格并不重要， <span class="emphasis"><em>除非</em></span>是特定于领域的语言，其中一行一行地处理行，并且空格对于领域语言可能很重要。</strong></strong></p></div></div><div class="section" title="8.2。关键词"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e7679"></a> 8.2。关键词</strong></strong></h2></div></div></div><p><strong><strong>Drools 5引入了<span class="emphasis"><em>硬</em></span>关键字和<span class="emphasis"><em>软</em></span>关键字的概念。</strong></strong></p><p><strong><strong>保留硬关键字，在命名规则文本中使用的域对象，属性，方法，函数和其他元素时，您不能使用任何硬关键字。</strong></strong></p><p><strong><strong>这是在编写规则时必须避免作为标识符的硬关键字的列表：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="literal">true</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">false</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">null</code></strong></strong></p></li></ul></div><p><strong><strong>软关键字仅在它们的上下文中被识别，因此您可以根据需要在其他任何地方使用这些词，但是仍然建议避免使用它们，以免造成混淆。这是软关键字的列表：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="literal">lock-on-active</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">date-effective</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">date-expires</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">no-loop</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">auto-focus</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">activation-group</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">agenda-group</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">ruleflow-group</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">entry-point</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">duration</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">package</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">import</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">dialect</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">salience</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">enabled</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">attributes</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">rule</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">extend</code></strong></strong></p></li><li class="listitem"><p><strong><strong>什么时候</strong></strong></p></li><li class="listitem"><p><strong><strong>然后</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">template</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">query</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">declare</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">function</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">global</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">eval</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">not</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">in</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">or</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">and</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">exists</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">forall</code></strong></strong></p></li><li class="listitem"><p><strong><strong>积累</strong></strong></p></li><li class="listitem"><p><strong><strong>搜集</strong></strong></p></li><li class="listitem"><p><strong><strong>从</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">action</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">reverse</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">result</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">end</code></strong></strong></p></li><li class="listitem"><p><strong><strong>过度</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">init</code></strong></strong></p></li></ul></div><p><strong><strong>当然，在驼峰式的情况下，您可以将这些（硬性和软性）词作为方法名称的一部分，例如notSomething（）或accumulateSomething（）-这种情况没有问题。</strong></strong></p><p><strong><strong>尽管上面的3个硬关键字不太可能在您现有的域模型中使用，但是如果您绝对需要将它们用作标识符而不是关键字，则DRL语言提供了在规则文本中转义硬关键字的功能。要转义一个单词，只需用重音将其括起来，如下所示：</strong></strong></p><pre><code class="no-highlight">Holiday( `true` == "yes" ) // please note that Drools will resolve that reference to the method Holiday.isTrue()</code></pre></div><div class="section" title="8.3。评论"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e7874"></a> 8.3。评论</strong></strong></h2></div></div></div><p><strong><strong>注释是规则引擎忽略的文本部分。遇到规则时，它们会被删除，除了内部语义代码块（如规则的RHS）外。</strong></strong></p><div class="section" title="8.3.1。单行注释"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7879"></a> 8.3.1。单行注释</strong></strong></h3></div></div></div><p><strong><strong>要创建单行注释，可以使用“ //”。解析器将忽略注释符号后一行中的任何内容。例：</strong></strong></p><pre><code class="no-highlight">rule "Testing Comments"
when
    // this is a single line comment
    eval( true ) // this is a comment in the same line of a pattern
then
    // this is a comment inside a semantic code block
end
</code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>已删除注释的“＃”。</strong></strong></p></div></div><div class="section" title="8.3.2。多行评论"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7889"></a> 8.3.2。多行评论</strong></strong></h3></div></div></div><div class="figure"><strong><strong><a id="d0e7892"></a><p class="title"><strong>图8.1。多行评论</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/multi_line_comment.png" align="middle" alt="多行评论"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>多行注释用于在语义代码块内外注释文本块。例：</p><pre><code class="no-highlight">rule "Test Multi-line Comments"
when
    /* this is a multi-line comment
       in the left hand side of a rule */
    eval( true )
then
    /* and this is a multi-line comment
       in the right hand side of a rule */
end </code></pre></strong></strong></div></div><div class="section" title="8.4。错误讯息"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e7902"></a> 8.4。错误讯息</strong></strong></h2></div></div></div><p><strong><strong>Drools 5引入了标准化的错误消息。该标准化旨在帮助用户以更轻松，更快捷的方式查找和解决问题。在本节中，您将学习如何识别和解释这些错误消息，并且还将获得有关如何解决与它们相关的问题的一些技巧。</strong></strong></p><div class="section" title="8.4.1。讯息格式"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7907"></a> 8.4.1。讯息格式</strong></strong></h3></div></div></div><p><strong><strong>标准化包括错误消息格式，为了更好地解释该格式，让我们使用以下示例：</strong></strong></p><div class="figure"><strong><strong><a id="d0e7912"></a><p class="title"><strong>图8.2。错误讯息格式</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/error_message.png" align="middle" alt="错误讯息格式"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p><span class="bold"><strong>第一块：</strong></span>此区域标识错误代码。</p><p><span class="bold"><strong>第二块：</strong></span>行和列信息。</p><p><span class="bold"><strong>第三块：</strong></span>描述问题的一些文字。</p><p><span class="bold"><strong>第四区：</strong></span>这是第一个背景。通常指示发生错误的规则，函数，模板或查询。此块不是必需的。</p><p><span class="bold"><strong>第5块：</strong></span>标识发生错误的模式。此块不是必需的。</p></strong></strong></div><div class="section" title="8.4.2。错误信息说明"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e7938"></a> 8.4.2。错误信息说明</strong></strong></h3></div></div></div><div class="section" title="8.4.2.1。101：没有可行的选择"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e7941"></a> 8.4.2.1。101：没有可行的选择</strong></strong></h4></div></div></div><p><strong><strong>指示最常见的错误，解析器到达决策点但无法识别替代项。这里有些例子：</strong></strong></p><div class="example"><strong><strong><a id="d0e7946"></a><p class="title"><strong>示例8.2</strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule one
2:   when
3:     exists Foo()
4:     <span class="bold"><strong>exits</strong></span> Bar()
5:   then
6: end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>上面的示例生成此消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101]第4：4行，规则一的输入“出口”没有可行的选择</p></li></ul></div><p>乍一看，这似乎是有效的语法，但事实并非如此（退出！=存在）。让我们看下一个例子：</p><div class="example"><a id="d0e7960"></a><p class="title"><strong>示例8.3</strong></p><div class="example-contents"><pre><code class="no-highlight">1: package org.drools.examples;
2: rule
3:   when
4:     Object()
5:   then
6:     System.out.println("A RHS");
7: end
</code></pre></div></div><br class="example-break"><p>现在，上面的代码生成此消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101]第3：2行，输入“何时”没有其他选择</p></li></ul></div><p>该消息表示解析器遇到了令牌<span class="bold"><strong>WHEN</strong></span> ，实际上是一个硬关键字，但是由于缺少规则名称，因此它位于错误的位置。</p><p>当您犯一个简单的词汇错误时，也会出现错误“没有可行的选择”。这是一个词汇问题的示例：</p><div class="example"><a id="d0e7976"></a><p class="title"><strong>示例8.4</strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     Student( name == "Andy )
4:   then
5: end
</code></pre></div></div><br class="example-break"><p>上面的代码未能关闭引号，因此解析器将生成以下错误消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 101]行0：-1 <eof>在模式Student中的规则simple_rule中的</eof>输入' <eof>'</eof>处没有可行的选择</p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>通常，“行”和“列”信息是准确的，但是在某些情况下（如未封闭的引号），解析器会生成0：-1位置。在这种情况下，您应该检查是否没有忘记关闭引号，撇号或括号。</p></div></strong></strong></div><div class="section" title="8.4.2.2。102：输入不匹配"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e7989"></a> 8.4.2.2。102：输入不匹配</strong></strong></h4></div></div></div><p><strong><strong>该错误表明解析器正在寻找一个未在当前输入位置找到的特定符号。以下是一些示例：</strong></strong></p><div class="example"><strong><strong><a id="d0e7994"></a><p class="title"><strong>示例8.5</strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     foo3 : Bar(
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>上面的示例生成此消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 102]第0：-1 <eof>行在模式栏中的规则simple_rule中的</eof>输入' <eof>'期望'）'</eof>不匹配</p></li></ul></div><p>若要解决此问题，有必要完成规则语句。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>通常，当您获得0：-1位置时，这意味着解析器到达了源的末尾。</p></div><p>以下代码生成多个错误消息：</p><div class="example"><a id="d0e8010"></a><p class="title"><strong>示例8.6</strong></p><div class="example-contents"><pre><code class="no-highlight">1: package org.drools.examples;
2:
3: rule "Avoid NPE on wrong syntax"
4:   when
5:     not( Cheese( ( type == "stilton", price == 10 ) || ( type == "brie", price == 15 ) ) from $cheeseList )
6:   then
7:     System.out.println("OK");
8: end
</code></pre></div></div><br class="example-break"><p>这些是与此来源相关的错误：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 102]第5:36行，奶酪中的规则“避免语法错误避免NPE”中的输入'，'期望为'）'不匹配</p></li><li class="listitem"><p>[ERR 101]行5:57在规则“避免错误语法的NPE”的输入“类型”上没有可行的选择</p></li><li class="listitem"><p>[ERR 102]行5：106输入'）'不匹配，期望规则“避免使用错误语法的NPE”中的“然后”</p></li></ul></div><p>请注意，第二个问题与第一个有关。要解决此问题，只需用AND运算符（'&&'）替换逗号（'，'）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>在某些情况下，您可以获得多个错误消息。尝试从第一个开始一个一个地修复。某些错误消息只是作为其他错误的结果而生成的。</p></div></strong></strong></div><div class="section" title="8.4.2.3。103：谓词失败"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e8030"></a> 8.4.2.3。103：谓词失败</strong></strong></h4></div></div></div><p><strong><strong>验证语义谓词评估为false。通常，这些语义谓词用于识别软关键字。该示例准确显示了这种情况：</strong></strong></p><div class="example"><strong><strong><a id="d0e8035"></a><p class="title"><strong>示例8.7</strong></p><div class="example-contents"><pre><code class="no-highlight"> 1: package nesting;
 2: dialect "mvel"
 3:
 4: import org.drools.compiler.Person
 5: import org.drools.compiler.Address
 6: 
 7: <span class="bold"><strong>fdsfdsfds</strong></span>
 8: 
 9: rule "test something"
10:   when
11:     p: Person( name=="Michael" )
12:   then
13:     p.name = "other";
14:     System.out.println(p.name);
15: end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>通过此示例，我们得到以下错误消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 103]第7：0行规则'rule_key'的谓词失败：{（validateIdentifierKey（DroolsSoftKeywords。规则））}？在规则上</p></li></ul></div><p><span class="bold"><strong>fdsfdsfds</strong></span>文本无效，并且解析器无法将其识别为软关键字<code class="literal">rule</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>此错误非常类似于102：输入不匹配，但通常涉及软关键字。</p></div></strong></strong></div><div class="section" title="8.4.2.4。104：不允许使用尾部分号"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e8058"></a> 8.4.2.4。104：不允许使用尾部分号</strong></strong></h4></div></div></div><p><strong><strong>此错误与<code class="literal">eval</code>子句，其表达式不能以分号结尾。检查以下示例：</strong></strong></p><div class="example"><strong><strong><a id="d0e8066"></a><p class="title"><strong>示例8.8</strong></p><div class="example-contents"><pre><code class="no-highlight">1: rule simple_rule
2:   when
3:     eval(abc();)
4:   then
5: end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>由于eval中的尾部分号，我们收到此错误消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 104]第3：4行，在规则simple_rule中不允许使用尾部分号</p></li></ul></div><p>这个问题很容易解决：只需删除分号即可。</p></strong></strong></div><div class="section" title="8.4.2.5。105：提早退出"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e8077"></a> 8.4.2.5。105：提早退出</strong></strong></h4></div></div></div><p><strong><strong>识别器出现在语法中的子规则中，该子规则必须至少匹配一个替代项，但是该子规则不匹配任何内容。简而言之：解析器已经进入了没有分支的分支。这个例子说明了这一点：</strong></strong></p><div class="example"><strong><strong><a id="d0e8082"></a><p class="title"><strong>示例8.9</strong></p><div class="example-contents"><pre><code class="no-highlight">1: template test_error
2:   aa s  11;
3: end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>这是与以上示例相关的消息：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>[ERR 105]所需的行2：2（...）+循环与模板test_error中的输入'aa'上的任何内容都不匹配</p></li></ul></div><p>要解决此问题，必须删除数字值，因为它既不是有效的数据类型，它可能不会开始新的模板插槽，也不可能是任何其他规则文件构造的开始。</p></strong></strong></div></div><div class="section" title="8.4.3。其他讯息"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e8093"></a> 8.4.3。其他讯息</strong></strong></h3></div></div></div><p><strong><strong>任何其他消息都意味着发生了不好的事情，因此请与开发团队联系。</strong></strong></p></div></div><div class="section" title="8.5。包"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e8098"></a> 8.5。包</strong></strong></h2></div></div></div><p><strong><strong>包是规则和其他相关构造（例如，导入和全局）的集合。包成员通常彼此相关-例如，可能是HR规则。包代表一个命名空间，理想情况下，它对于给定的规则分组保持唯一。程序包名称本身就是名称空间，与文件或文件夹没有任何关系。</strong></strong></p><p><strong><strong>可以从多个规则源组合规则，并具有一个顶层程序包配置，所有规则都保留在该规则下（组合规则时）。但是，不可能合并到以不同名称声明的相同包资源中。但是，一个规则库可能包含基于其构建的多个程序包。一个通用的结构是将包的所有规则与包声明放在同一个文件中（这样就完全独立了）。</strong></strong></p><p><strong><strong>下图显示了组成包装的所有组件。请注意，程序包<span class="emphasis"><em>必须</em></span>具有名称空间，并使用标准Java约定来声明程序包名称。即，没有空格，与允许空格的规则名称不同。就元素的顺序而言，它们可以以任何顺序出现在规则文件中，但<code class="literal">package</code>语句，该语句必须位于文件的顶部。在所有情况下，分号都是可选的。</strong></strong></p><div class="figure"><strong><strong><a id="d0e8113"></a><p class="title"><strong>图8.3。包</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/package.png" align="middle" alt="包"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>注意，任何规则属性（如“规则属性”一节中所述）也可以在包级别编写，以取代该属性的默认值。修改后的默认值仍可以替换为规则中的属性设置。</p><div class="section" title="8.5.1。进口"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8121"></a> 8.5.1。进口</h3></div></div></div><div class="figure"><a id="d0e8124"></a><p class="title"><strong>图8.4。进口</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/LanguageReference/import.png" alt="进口"></div></div></div><br class="figure-break"><p>导入语句的工作方式类似于Java中的导入语句。您需要为要在规则中使用的任何对象指定完全限定的路径并键入名称。Drools会从同名的Java包以及包中自动导入类<code class="code">java.lang</code> 。</p></div><div class="section" title="8.5.2。全球"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8135"></a> 8.5.2。全球</h3></div></div></div><div class="figure"><a id="d0e8138"></a><p class="title"><strong>图8.5。全球</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/LanguageReference/global.png" alt="全球"></div></div></div><br class="figure-break"><p>用<code class="literal">global</code>您定义全局变量。它们用于使应用程序对象可用于规则。通常，它们用于提供规则使用的数据或服务，尤其是用于规则结果的应用程序服务，并从规则返回数据，例如在规则结果中添加的日志或值，或用于与应用程序进行交互的规则，做回调。全局变量没有插入到工作存储器中，因此，除非具有恒定不变的值，否则永远不要使用全局变量在规则中建立条件。无法通知引擎有关全局变量值的更改，并且不跟踪其更改。在约束中错误使用全局变量可能会产生令人惊讶的结果-以一种不好的方式令人惊讶。</p><p>如果多个程序包使用相同的标识符声明全局变量，则它们必须具有相同的类型，并且它们都将引用相同的全局值。</p><p>为了使用全局变量，您必须：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>在规则文件中声明全局变量，然后在规则中使用它。例：</p><pre><code class="no-highlight">global java.util.List myGlobalList;

rule "Using a global"
when
    eval( true )
then
    myGlobalList.add( "Hello World" );
end
</code></pre></li><li class="listitem"><p>在工作内存上设置全局值。最佳做法是在将任何事实断言到工作内存之前设置所有全局值。例：</p><pre><code class="language-java">List list = new ArrayList();
KieSession kieSession = kiebase.newKieSession();
kieSession.setGlobal( "myGlobalList", list );
</code></pre></li></ol></div><p>请注意，这些只是您从应用程序传递到工作内存的对象的命名实例。这意味着您可以传递任何想要的对象：您可以传递服务定位器，或者服务本身。随着新<code class="literal">from</code>元素，现在通常将Hibernate会话作为全局传递，以允许<code class="literal">from</code>从命名的Hibernate查询中提取数据。</p><p>一个示例可以是电子邮件服务的实例。在调用规则引擎的集成代码中，获取您的emailService对象，然后将其设置在工作内存中。在DRL中，您声明您具有类型为EmailService的全局变量，并将其命名为“ email”。然后，在规则后果中，您可以使用诸如email.sendSMS（number，message）之类的东西。</p><p>全局变量不是为了在规则之间共享数据而设计的，切勿将它们用于此目的。规则始终会推理并对工作内存状态做出反应，因此，如果要在规则之间传递数据，请将数据作为事实断言到工作内存中。</p><p>更改全局变量持有的数据时必须小心，因为规则引擎不会意识到这些更改，因此无法对它们做出反应。</p></div></strong></strong></div><div class="section" title="8.6。功能"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e8178"></a> 8.6。功能</strong></strong></h2></div></div></div><div class="figure"><strong><strong><a id="d0e8181"></a><p class="title"><strong>图8.6。功能</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/function.png" align="middle" alt="功能"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>与普通的Java类相反，函数是一种将语义代码放入规则源文件中的方法。他们不能做的比您使用帮助程序类能做的更多。（实际上，编译器会在后台为您生成帮助器类。）在规则中使用函数的主要优点是可以将逻辑全都放在一个位置，并且可以根据需要更改函数（这可以是好事也可以是坏事）。函数对于对结果调用动作最有用（ <code class="literal">then</code> ）作为规则的一部分，尤其是如果一遍又一遍地使用该特定操作时，也许每个规则的参数可能不同。</p><p>典型的函数声明如下：</p><pre><code class="no-highlight">function String hello(String name) {
    return "Hello "+name+"!";
}
</code></pre><p>请注意<code class="literal">function</code>使用了关键字，即使它不是Java的真正组成部分。函数的参数是为方法定义的，如果不需要，则不必具有参数。返回类型的定义与常规方法一样。</p><p>或者，您可以在帮助程序类中使用静态方法，例如， <code class="code">Foo.hello()</code> 。Drools支持使用函数导入，因此您所需要做的就是：</p><pre><code class="no-highlight">import function my.package.Foo.hello</code></pre><p>无论定义或导入函数的方式如何，都可以通过在结果中或在语义代码块内按其名称调用函数来使用它。例：</p><pre><code class="no-highlight">rule "using a static function"
when 
    eval( true )
then
    System.out.println( hello( "Bob" ) );
end
</code></pre></strong></strong></div><div class="section" title="8.7。类型声明"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e8212"></a> 8.7。类型声明</strong></strong></h2></div></div></div><div class="figure"><strong><strong><a id="d0e8215"></a><p class="title"><strong>图8.7。 meta_data</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/meta_data.png" align="middle" alt="meta_data"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e8221"></a><p class="title"><strong>图8.8。 type_declaration</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/type_declaration.png" align="middle" alt="type_declaration"></div></div></div><br class="figure-break"><p>类型声明在规则引擎中有两个主要目标：允许声明新类型，并允许声明类型的元数据。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>声明新的类型：</strong></span> Drools开箱即用，将普通的Java对象作为事实。但是，有时，用户可能希望直接在规则引擎中定义模型，而不必担心使用Java之类的低级语言创建模型。在其他时候，已经建立了一个领域模型，但是最终用户希望或需要用主要在推理过程中使用的其他实体来补充该模型。</p></li><li class="listitem"><p><span class="bold"><strong>声明元数据：</strong></span>事实可能具有与之关联的元信息。元信息的示例包括事实属性未表示并且在该事实类型的所有实例之间一致的任何类型的数据。该元信息可以在运行时由引擎查询并在推理过程中使用。</p></li></ul></div><div class="section" title="8.7.1。声明新类型"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8240"></a> 8.7.1。声明新类型</h3></div></div></div><p>要声明一个新类型，您所要做的就是使用关键字<code class="literal">declare</code> ，然后是字段列表和关键字<code class="literal">end</code> 。新事实必须具有字段列表，否则引擎将在类路径中查找现有事实类，如果找不到则引发错误。</p><div class="example"><a id="d0e8251"></a><p class="title"><strong>示例8.10声明新的事实类型：地址</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Address
   number : int
   streetName : String
   city : String
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>前面的示例声明了一个新的事实类型，称为<code class="code">Address</code> 。此事实类型将具有三个属性： <code class="code">number</code> ， <code class="code">streetName</code>和<code class="code">city</code> 。每个属性的类型都可以是任何有效的Java类型，包括用户创建的任何其他类，甚至是先前声明的其他事实类型。</p><p>例如，我们可能要声明另一个事实类型<code class="code">Person</code> ：</p><div class="example"><a id="d0e8280"></a><p class="title"><strong>示例8.11声明新的事实类型：人员</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : java.util.Date
    address : Address
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>如上例所示， <code class="code">dateOfBirth</code>是类型<code class="code">java.util.Date</code> ，来自Java API，而<code class="code">address</code>具有先前定义的事实类型地址。</p><p>您可以避免每次使用类编写全限定名时都必须使用<code class="literal">import</code>如前所述。</p><div class="example"><a id="d0e8306"></a><p class="title"><strong>示例8.12通过使用import避免使用完全限定的类名</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>当您声明新的事实类型时，Drools将在编译时生成字节代码，该字节代码实现表示该事实类型的Java类。生成的Java类将是类型定义的一对一Java Bean映射。因此，对于前面的示例，生成的Java类将是：</p><div class="example"><a id="d0e8320"></a><p class="title"><strong>示例8.13为先前的Person事实类型声明生成Java类</strong></p><div class="example-contents"><pre><code class="language-java">public class Person implements Serializable {
    private String name;
    private java.util.Date dateOfBirth;
    private Address address;

    // empty constructor
    public Person() {...}

    // constructor with all fields 
    public Person( String name, Date dateOfBirth, Address address ) {...}

    // if keys are defined, constructor with keys
    public Person( ...keys... ) {...}

    // getters and setters
    // equals/hashCode
    // toString
}
</code></pre></div></div><br class="example-break"><p>由于生成的类是简单的Java类，因此可以像其他任何事实一样在规则中透明地使用它。</p><div class="example"><a id="d0e8327"></a><p class="title"><strong>示例8.14在规则中使用声明的类型</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> "Using a declared Type"
<span class="bold"><strong>when</strong></span> 
    $p : Person( name == "Bob" )
<span class="bold"><strong>then</strong></span>
    <span class="emphasis"><em>// Insert Mark, who is Bob's mate.</em></span>
    Person mark = new Person();
    mark.setName("Mark");
    insert( mark );
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><div class="section" title="8.7.1.1。声明枚举类型"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8346"></a> 8.7.1.1。声明枚举类型</h4></div></div></div><p>DRL还支持枚举类型的声明。此类类型声明需要附加的关键字<span class="emphasis"><em>enum</em></span> ，后跟逗号分隔的可允许值列表，以分号终止。
		  </p><div class="example"><a id="d0e8354"></a><p class="title"><strong>示例8.15</strong></p><div class="example-contents"><pre><code class="no-highlight">
<span class="bold"><strong>declare enum</strong></span> DaysOfWeek
   SUN,MON,TUE,WED,THU,FRI,SAT;
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>编译器将生成一个带有静态方法valueOf（）和values（）以及实例方法ordinal（），compareTo（）和name（）的有效Java枚举。</p><p>还部分支持复杂的枚举，类似于常规类型声明一样声明内部字段。请注意，从版本6.x开始，枚举字段<span class="emphasis"><em>不</em></span>支持其他声明的类型或枚举</p><div class="example"><a id="d0e8370"></a><p class="title"><strong>示例8.16</strong></p><div class="example-contents"><pre><code class="no-highlight">
<span class="bold"><strong>declare enum</strong></span> DaysOfWeek
   SUN("Sunday"),MON("Monday"),TUE("Tuesday"),WED("Wednesday"),THU("Thursday"),FRI("Friday"),SAT("Saturday");

   fullName : String
<span class="bold"><strong>end</strong></span>
			  </code></pre></div></div><br class="example-break"><p>然后可以在规则中使用枚举</p><div class="example"><a id="d0e8381"></a><p class="title"><strong>示例8.17在规则中使用声明性枚举</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>rule</strong></span> "Using a declared Enum"
<span class="bold"><strong>when</strong></span>
   $p : Employee( dayOff == DaysOfWeek.MONDAY )
<span class="bold"><strong>then</strong></span>
   ...
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"></div></div><div class="section" title="8.7.2。声明元数据"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8397"></a> 8.7.2。声明元数据</h3></div></div></div><p>在Drools中，元数据可以分配给几种不同的构造：事实类型，事实属性和规则。Drools使用at符号（'@'）引入元数据，并且始终使用以下形式：</p><pre><code class="no-highlight">@<span class="emphasis"><em>metadata_key</em></span>( <span class="emphasis"><em>metadata_value</em></span> )</code></pre><p>带括号的<span class="emphasis"><em>metadata_value</em></span>是可选的。</p><p>例如，如果您想声明一个元数据属性，例如<code class="code">author</code> ，其值为<span class="emphasis"><em>Bob</em></span> ，您可以简单地编写：</p><div class="example"><a id="d0e8423"></a><p class="title"><strong>示例8.18声明元数据属性</strong></p><div class="example-contents"><pre><code class="no-highlight">@author( Bob )</code></pre></div></div><br class="example-break"><p>Drools允许声明任何任意的元数据属性，但是其中一些对引擎具有特殊的意义，而其他一些则可以在运行时查询。Drools允许为事实类型和事实属性声明元数据。在事实类型的属性之前声明的任何元数据都被分配给事实类型，而在属性之后声明的元数据则被分配给该特定属性。</p><div class="example"><a id="d0e8430"></a><p class="title"><strong>示例8.19声明事实类型和属性的元数据属性</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )

    name : String <span class="emphasis"><em>@key @maxLength</em></span>( 30 )
    dateOfBirth : Date 
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>在上一个示例中，为事实类型声明了两个元数据项（ <code class="code">@author</code>和<code class="code">@dateOfCreation</code> ），还为name属性定义了两个（ <code class="code">@key</code>和<code class="code">@maxLength</code> ）。请注意<code class="code">@key</code>元数据没有必需的值，因此省略了括号和值。</p><div class="section" title="8.7.2.1。预定义的类级别注释"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8468"></a> 8.7.2.1。预定义的类级别注释</h4></div></div></div><p>一些注释具有由引擎解释的预定义语义。以下是其中一些预定义注释及其含义的列表。</p><div class="section" title="8.7.2.1.1。 @role（<事实|事件>）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8473"></a> 8.7.2.1.1。 @角色（ <fact |="" event="">）</fact></h5></div></div></div><p>@role注释定义引擎应如何处理该类型的实例：作为常规事实还是作为事件。它接受两个可能的值：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>fact：这是默认值，声明该类型将作为常规事实处理。</p></li><li class="listitem"><p>event：声明将类型作为事件处理。</p></li></ul></div><p>以下示例声明将股票经纪人应用程序中的事实类型StockTick视为事件。</p><div class="example"><a id="d0e8487"></a><p class="title"><strong>示例8.20将事实类型声明为事件</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> some.package.StockTick

<span class="bold"><strong>declare</strong></span> StockTick
    <span class="emphasis"><em>@role</em></span>( event )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>内联声明的事实也是如此。如果StockTick是DRL本身声明的事实类型，而不是先前存在的类，则代码将是：</p><div class="example"><a id="d0e8505"></a><p class="title"><strong>示例8.21。声明事实类型并为其分配事件角色</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> StockTick 
    <span class="emphasis"><em>@role</em></span>( event )

    datetime : java.util.Date
    symbol : String
    price : double
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.2.1.2。 @typesafe（<boolean>）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8518"></a> 8.7.2.1.2。 @typesafe（ <boolean>）</boolean></h5></div></div></div><p>默认情况下，所有类型声明都在启用类型安全的情况下进行编译； @typesafe（false）提供了一种方法，可以通过允许回退来覆盖此行为，键入不安全的评估，其中所有约束均作为MVEL约束生成并动态执行。当处理没有任何泛型或混合类型集合的集合时，这可能很重要。</p></div><div class="section" title="8.7.2.1.3。 @timestamp（<属性名称>）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8523"></a> 8.7.2.1.3。 @timestamp（ <attribute name="">）</attribute></h5></div></div></div><p>每个事件都分配有一个关联的时间戳。默认情况下，给定事件的时间戳是从会话时钟中读取的，并在事件插入到工作存储器中时分配给事件。尽管有时事件将时间戳记作为其自身的属性之一。在这种情况下，用户可以告诉引擎使用事件属性中的时间戳，而不是从会话时钟中读取时间戳。</p><pre><code class="no-highlight"><span class="emphasis"><em>@timestamp</em></span>( &lt;attributeName&gt; )</code></pre><p>要告诉引擎将哪个属性用作事件时间戳记的来源，只需将属性名称作为@timestamp标记的参数列出即可。</p><div class="example"><a id="d0e8534"></a><p class="title"><strong>示例8.22声明VoiceCall时间戳属性</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.2.1.4。 @duration（<属性名称>）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8550"></a> 8.7.2.1.4。 @duration（ <attribute name="">）</attribute></h5></div></div></div><p>Drools支持两种事件语义：时间点事件和基于间隔的事件。时间点事件表示为持续时间为零的基于间隔的事件。默认情况下，所有事件的持续时间为零。用户可以通过声明事件类型中的哪个属性包含事件的持续时间来为事件分配不同的持续时间。</p><pre><code class="no-highlight"><span class="emphasis"><em>@duration</em></span>( &lt;attributeName&gt; )</code></pre><p>因此，对于我们的VoiceCall事实类型，声明为：</p><div class="example"><a id="d0e8561"></a><p class="title"><strong>示例8.23声明VoiceCall持续时间属性</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.2.1.5。 @expires（<时间间隔>）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8579"></a> 8.7.2.1.5。 @expires（ <time interval=""> ） </time></h5></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>仅在以STREAM模式运行引擎时才考虑使用此标签。另外，在“内存管理”部分还对使用此标签的效果进行了其他讨论。为了完整起见，此处将其包括在内。</p></div><p>事件可能会在一段时间后自动过期。通常，基于知识库中的现有规则，事件不再能够匹配和激活任何规则时，就会发生这种情况。虽然，可以显式定义事件应在何时到期。</p><pre><code class="no-highlight"><span class="emphasis"><em>@expires</em></span>( &lt;timeOffset&gt; )</code></pre><p><span class="emphasis"><em>timeOffset</em></span>的值是以下形式的时间间隔：</p><pre><code class="no-highlight">[#d][#h][#m][#s][#[ms]]</code></pre><p>其中<span class="emphasis"><em>[]</em></span>表示可选参数，而<span class="emphasis"><em>＃</em></span>表示数值。</p><p>因此，要声明VoiceCall事实在插入工作存储器后1小时35分钟后应该过期，用户可以这样写：</p><div class="example"><a id="d0e8608"></a><p class="title"><strong>示例8.24声明VoiceCall事件的到期时间偏移</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> VoiceCall
    <span class="emphasis"><em>@role</em></span>( event )
    <span class="emphasis"><em>@timestamp</em></span>( callDateTime )
    <span class="emphasis"><em>@duration</em></span>( callDuration )
    <span class="emphasis"><em>@expires</em></span>( 1h35m )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>@expires策略将具有优先权，并将覆盖从知识库中的时间约束和滑动窗口计算出的隐式过期偏移。</p></div><div class="section" title="8.7.2.1.6。 @propertyChangeSupport"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8631"></a> 8.7.2.1.6。 @propertyChangeSupport</h5></div></div></div><p>现在可以注释实现Javabean（tm）规范中定义的对属性更改的支持的事实，以便引擎注册自身以侦听事实属性的更改。Drools 4 API中insert（）方法中使用的布尔参数已被弃用，并且在drools-api模块中不存在。</p><div class="example"><a id="d0e8636"></a><p class="title"><strong>示例8.25 @propertyChangeSupport</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  <span class="italic">@propertyChangeSupport</span>
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.2.1.7。 @propertyReactive"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8648"></a> 8.7.2.1.7。 @propertyReactive</h5></div></div></div><p>使此类型属性具有反应性。有关详细信息，请参见细粒度的属性更改侦听器部分。</p></div></div><div class="section" title="8.7.2.2。预定义的属性级别注释"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8653"></a> 8.7.2.2。预定义的属性级别注释</h4></div></div></div><p>如前所述，Drools还支持类型属性中的注释。这是预定义属性注释的列表。</p><div class="section" title="8.7.2.2.1。 @键"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8658"></a> 8.7.2.2.1。 @键</h5></div></div></div><p>将属性声明为键属性对生成的类型有两个主要影响：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>该属性将用作该类型的键标识符，因此，在比较此类型的实例时，生成的类将实现考虑到该属性的equals（）和hashCode（）方法。</p></li><li class="listitem"><p>Drools将使用所有关键属性作为参数来生成构造函数。</p></li></ol></div><p>例如：</p><div class="example"><a id="d0e8672"></a><p class="title"><strong>示例8.26类型的@key声明示例</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    firstName : String @key
    lastName : String @key
    age : int
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>对于前面的示例，Drools将生成equals（）和hashCode（）方法，这些方法将检查firstName和lastName属性，以确定Person的两个实例是否彼此相等，但不检查age属性。它还将生成一个构造函数，以firstName和lastName作为参数，从而允许使用以下代码创建实例：</p><div class="example"><a id="d0e8684"></a><p class="title"><strong>示例8.27使用键构造函数创建实例</strong></p><div class="example-contents"><pre><code class="no-highlight">Person person = new Person( "John", "Doe" );</code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.2.2.2。 @位置"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8689"></a> 8.7.2.2.2。 @位置</h5></div></div></div><p>模式支持类型声明中的位置参数。</p><p>位置参数是不需要指定字段名称的参数，因为位置映射到已知的命名字段。即，Person（name ==“ mark”）可以重写为Person（“ mark”;）。分号“;”重要的是，引擎必须知道位置之前的所有内容。否则，我们可能会假定它是一个布尔表达式，这就是在分号之后如何解释它的方式。您可以使用分号“;”在模式上混合位置参数和命名参数分开他们。位置中尚未绑定的任何变量都将绑定到映射到该位置的字段。</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String
    shop : String
    price : int
<span class="bold"><strong>end</strong></span>
</code></pre><p>默认顺序是声明的顺序，但是可以使用@position覆盖它</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String <span class="italic">@position(1)</span>
    shop : String <span class="italic">@position(2)</span>
    price : int <span class="italic">@position(0)</span>
<span class="bold"><strong>end</strong></span>
</code></pre><p>org.drools.definition.type包中的@Position批注可用于在类路径上批注原始pojo。当前，仅可以注释类中的字段。支持类的继承，但尚不支持方法的接口。</p><p>示例模式，具有两个约束和一个绑定。记住分号“;”用于区分位置部分和命名参数部分。位置参数支持变量，文字和仅使用文字的表达式，但不支持变量。</p><pre><code class="no-highlight">
Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
</code></pre><p>当bean彼此延伸时，@Position被继承。尽管不建议使用，但两个字段可能具有相同的@position值，并且不需要声明所有连续的值。如果重复@position，则使用继承（超类中的字段具有优先级）和声明顺序来解决冲突。如果缺少@position值，则选择没有显式@position（如果有）的第一个字段来填补空白。与往常一样，冲突通过继承和声明顺序解决。</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Cheese
    name : String 
    shop : String <span class="italic">@position(2)</span>
    price : int <span class="italic">@position(0)</span>
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> SeasonedCheese <span class="bold"><strong>extends</strong></span> Cheese
    year : Date <span class="italic">@position(0)</span>
    origin : String <span class="italic">@position(6)</span>
    country : String    
<span class="bold"><strong>end</strong></span></code></pre><p>在示例中，字段顺序为：价格（超类中的@position 0），年份（子类中的@position 0），名称（第一个没有@position的字段），商店（@position 2），国家（第二个）没有@position的字段），来源。</p></div></div></div><div class="section" title="8.7.3。声明现有类型的元数据"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8758"></a> 8.7.3。声明现有类型的元数据</h3></div></div></div><p>Drools允许以与声明新事实类型的元数据属性相同的方式声明现有类型的元数据属性。唯一的区别是该声明中没有字段。</p><p>例如，如果存在org.drools.examples类。人员，并且想要为其声明元数据，可以编写以下代码：</p><div class="example"><a id="d0e8765"></a><p class="title"><strong>示例8.28声明现有类型的元数据</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.examples.Person

<span class="bold"><strong>declare</strong></span> Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span>
</code></pre></div></div><br class="example-break"><p>除了使用导入之外，还可以通过其完全限定的名称来引用该类，但是由于该类也将在规则中被引用，因此添加导入并在所有地方使用短类名通常会更短。</p><div class="example"><a id="d0e8786"></a><p class="title"><strong>示例8.29使用完全限定的类名声明元数据</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> org.drools.examples.Person
    <span class="emphasis"><em>@author</em></span>( Bob )
    <span class="emphasis"><em>@dateOfCreation</em></span>( 01-Feb-2009 )
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"></div><div class="section" title="8.7.4。声明类型的参数化构造函数"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8801"></a> 8.7.4。声明类型的参数化构造函数</h3></div></div></div><p>生成带有声明类型的参数的构造函数。</p><p>示例：对于声明的类型，如下所示：</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
    firstName : String <span class="italic">@key</span>
    lastName : String <span class="italic">@key</span>
    age : int
<span class="bold"><strong>end</strong></span>
</code></pre><p>编译器将隐式生成3个构造函数：一个没有参数，一个带有@key字段，一个带有所有字段的构造函数。</p><pre><code class="no-highlight">Person() // parameterless constructor
Person( String firstName, String lastName )
Person( String firstName, String lastName, int age )</code></pre></div><div class="section" title="8.7.5。非类型安全类"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8825"></a> 8.7.5。非类型安全类</h3></div></div></div><p>@typesafe（ <boolean>）已添加到类型声明中。默认情况下，所有类型声明都在启用类型安全的情况下进行编译； @typesafe（false）提供了一种方法，可以通过允许回退来覆盖此行为，键入不安全的评估，其中所有约束均作为MVEL约束生成并动态执行。当处理没有任何泛型或混合类型集合的集合时，这可能很重要。</boolean></p></div><div class="section" title="8.7.6。从应用程序代码访问声明的类型"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8830"></a> 8.7.6。从应用程序代码访问声明的类型</h3></div></div></div><p>声明的类型通常用于规则文件中，而Java模型则用于在规则和应用程序之间共享模型时使用。尽管有时应用程序可能需要访问和处理已声明类型的事实，尤其是当应用程序包装规则引擎并为规则管理提供更高级别的特定于域的用户界面时。</p><p>在这种情况下，可以使用Java Reflection API照常处理生成的类，但是，众所周知，通常需要大量工作才能获得较小的结果。因此，Drools为处理应用程序可能想要做的最常见的事实提供了简化的API。</p><p>首先要意识到的是，声明的事实将属于声明它的包。因此，例如，在下面的示例中， <code class="code">Person</code>将属于<code class="code">org.drools.examples</code>包，因此生成的类的完全限定名称为<code class="code">org.drools.examples.Person</code> 。</p><div class="example"><a id="d0e8848"></a><p class="title"><strong>示例8.30在org.drools.examples包中声明类型</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>package</strong></span> org.drools.examples

<span class="bold"><strong>import</strong></span> java.util.Date

<span class="bold"><strong>declare</strong></span> Person
    name : String
    dateOfBirth : Date
    address : Address
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>如前所述，声明的类型是在知识库编译时生成的，即，应用程序只能在应用程序运行时对其进行访问。因此，这些类不可用于直接从应用程序中引用。</p><p>然后Drools提供一个接口，用户可以通过该接口处理应用程序代码中声明的类型： <code class="code">org.drools.definition.type.FactType</code> 。通过此接口，用户可以实例化，读取和写入声明的事实类型的字段。</p><div class="example"><a id="d0e8870"></a><p class="title"><strong>示例8.31通过API处理声明的事实类型</strong></p><div class="example-contents"><pre><code class="no-highlight">// get a reference to a knowledge base with a declared type:
KieBase kbase = ...

// get the declared FactType
FactType personType = kbase.getFactType( "org.drools.examples",
                                         "Person" );

// handle the type as necessary:
// create instances:
Object bob = personType.newInstance();

// set attributes values
personType.set( bob,
                "name",
                "Bob" );
personType.set( bob,
                "age",
                42 );

// insert fact into a session
KieSession ksession = ...
ksession.insert( bob );
ksession.fireAllRules();

// read attributes
String name = personType.get( bob, "name" );
int age = personType.get( bob, "age" );

</code></pre></div></div><br class="example-break"><p>该API还包括其他有用的方法，例如一次设置所有属性，从Map读取值或一次将所有属性读取到Map中。</p><p>尽管该API与Java反射类似（使用起来更简单），但它并没有在下面使用反射，而是依赖于使用生成的字节码实现的性能更高的访问器。</p></div><div class="section" title="8.7.7。类型声明“扩展”"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8879"></a> 8.7.7。类型声明“扩展”</h3></div></div></div><p>类型声明现在支持继承的'extends'关键字</p><p>为了扩展由DRL声明的子类型在Java中声明的类型，请在声明语句中重复该超类型而无需任何字段。</p><pre><code class="no-highlight">b org.people.Person

<span class="bold"><strong>declare</strong></span> Person <span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> Student <span class="bold"><strong>extends</strong></span> Person
    school : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> LongTermStudent <span class="bold"><strong>extends</strong></span> Student
    years : int
    course : String
<span class="bold"><strong>end</strong></span></code></pre></div><div class="section" title="8.7.8。特质"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8911"></a> 8.7.8。特质</h3></div></div></div><p>警告：此功能仍处于试验阶段，可能会有所更改</p><p>同一事实可能具有多个动态类型，这些动态类型自然不适合于类层次结构。特性允许对这种非常常见的情况进行建模。特质是可以在运行时应用于（最终删除）单个对象的接口。要创建特征而不是传统Bean，必须像以下示例中那样显式声明它们：</p><div class="example"><a id="d0e8918"></a><p class="title"><strong>示例8.32</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer
    // fields will map to getters/setters
    code     : String
    balance  : long
    discount : int
    maxExpense : long
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>在运行时，此声明导致一个接口，该接口可用于编写模式，但不能直接实例化。为了将特征应用于对象，我们提供了新的don关键字，该关键字可以这样简单地使用：</p><div class="example"><a id="d0e8930"></a><p class="title"><strong>示例8.33</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $c : Customer()
then
    GoldenCustomer gc = don( $c, GoldenCustomer.class );
end</code></pre></div></div><br class="example-break"><p>当一个核心对象不具有特征时，将立即创建一个代理类（对于每个核心/特征类组合，将懒惰地生成一个这样的类）。包裹核心对象并实现trait接口的代理实例会自动插入，并可能会激活其他规则。声明和使用接口的直接好处是可以从引擎中免费获取实现代理，这是在编写规则时可以利用多个继承层次结构。但是，核心类不需要静态地实现这些接口中的任何一个，也便于将遗留类用作核心。实际上，只要声明为@Traitable，任何对象都可以具有特征。请注意，该注释曾经是可选的，但现在是必需的。</p><div class="example"><a id="d0e8935"></a><p class="title"><strong>示例8.34</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.core.factmodel.traits.Traitable;
<span class="bold"><strong>declare</strong></span> Customer
    <span class="italic">@Traitable</span>
    code    : String
    balance : long
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>核心类和trait接口之间的唯一连接是在代理级别：trait没有专门与核心类相关联。这意味着可以将相同的特征应用于完全不同的对象。因此，特征不能透明地公开其核心对象的字段。因此，当使用特征接口编写规则时，照常只有接口的字段可用。但是，代理类将映射接口中与核心对象字段对应的任何字段：</p><div class="example"><a id="d0e8950"></a><p class="title"><strong>示例8.35</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $o: OrderItem( $p : price, $code : custCode )
    $c: GoldenCustomer( code == $code, $a : balance, $d: discount )
then
    $c.setBalance( $a - $p*$d );
end</code></pre></div></div><br class="example-break"><p>在这种情况下，将从底层客户对象中读取代码和余额。同样，setAccount将修改基础对象，从而保留对数据结构的强类型访问。硬字段必须在核心类和所有使用的接口中具有相同的名称和类型。该名称用于建立映射：如果两个字段具有相同的名称，则它们还必须具有相同的声明类型。注释@ org.drools.core.factmodel.traits。别名允许放宽此限制。如果提供了@Alias，则将使用其值字符串而不是原始字段名称来解析映射。@Alias可以应用于特征和核心bean。</p><div class="example"><a id="d0e8955"></a><p class="title"><strong>示例8.36</strong></p><div class="example-contents"><pre><code class="no-highlight">import org.drools.core.factmodel.traits.*;
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer
    balance : long <span class="italic">@Alias( "org.acme.foo.accountBalance" )</span>
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> Person
    <span class="italic">@Traitable</span>
    name : String
    savings : long <span class="italic">@Alias( "org.acme.foo.accountBalance" )</span>
<span class="bold"><strong>end</strong></span>

when
    GoldenCustomer( balance &gt; 1000 ) // will react to new Person( 2000 )
then
end
</code></pre></div></div><br class="example-break"><p>在克服此约束方面需要做更多的工作（请参阅稍后的“逻辑”特征的实验部分）。现在，您可能会想，如果核心类不提供接口中定义的字段的实现，会发生什么情况。我们将硬性字段称为特征字段，它们也是核心字段，因此易于使用，而我们定义软性字段时，核心类没有提供这些字段。相反，隐藏字段是核心类中的字段未由接口公开。</p><p>因此，尽管硬域管理是直观的，但仍然存在软域和隐藏域的问题。通常只能直接使用core类访问隐藏字段。但是，可以在特征接口上使用“字段”映射来访问隐藏的字段。如果无法解析该字段，则将返回null。请注意，此功能将来可能会更改。</p><div class="example"><a id="d0e8986"></a><p class="title"><strong>示例8.37</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $sc : GoldenCustomer( fields[ "age" ] &gt; 18 )  // age is declared by the underlying core class, but not by GoldenCustomer
then</code></pre></div></div><br class="example-break"><p>相反，软字段存储在特定于每个核心对象并由代理引用的类似Map的数据结构中，因此即使对象具有多个特征，也可以有效地共享它们。</p><div class="example"><a id="d0e8991"></a><p class="title"><strong>示例8.38</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    $sc : GoldenCustomer( $c : code, // hard getter
                          $maxExpense : maxExpense &gt; 1000 // soft getter
    )
then
    $sc.setDiscount( ... ); // soft setter
end</code></pre></div></div><br class="example-break"><p>核心对象还拥有对其所有代理的引用，因此可以使用一种动态的“ instanceof”运算符（我们称为isA）来跟踪已将哪些类型添加到对象。操作员可以接受字符串，类文字或类文字列表。在后一种情况下，仅当所有特征都已被使用时才满足约束条件。</p><div class="example"><a id="d0e8996"></a><p class="title"><strong>示例8.39</strong></p><div class="example-contents"><pre><code class="no-highlight">$sc : GoldenCustomer( $maxExpense : maxExpense &gt; 1000,
                      this isA "SeniorCustomer", this isA [ NationalCustomer.class, OnlineCustomer.class ]
)</code></pre></div></div><br class="example-break"><p>最终，业务逻辑可能要求从包装的对象中删除特征。为此，我们提供了两种选择。第一个是“逻辑don”，这将导致特征化操作导致代理的逻辑插入。当首先删除其逻辑支持时，TMS将确保删除该特性。</p><div class="example"><a id="d0e9001"></a><p class="title"><strong>示例8.40</strong></p><div class="example-contents"><pre><code class="no-highlight">then
    <span class="bold"><strong>don</strong></span>( $x, // core object
         Customer.class, // trait class
         true // optional flag for logical insertion
    )
    </code></pre></div></div><br class="example-break"><p>第二个是使用“ shed”关键字，该关键字将导致删除作为参数传递的子类型（或等效形式）的任何类型。请注意，从5.5版开始，棚子仅允许删除单个特定特征。</p><div class="example"><a id="d0e9009"></a><p class="title"><strong>示例8.41</strong></p><div class="example-contents"><pre><code class="no-highlight">then
    Thing t = <span class="bold"><strong>shed</strong></span>( $x, GoldenCustomer.class ) // also removes any trait that</code></pre></div></div><br class="example-break"><p>此操作返回另一个实现org.drools.core.factmodel.traits的代理。Thing接口，其中定义了getFields（）和getCore（）方法。实际上，在内部，将生成所有声明的特征以扩展此接口（除了指定的任何其他特征之外）。这样可以保留带有软字段的包装，否则将丢失。</p><p>特质及其代理也以另一种方式关联。从版本5.6开始，每当“修改”核心对象时，其代理也会自动“修改”，以允许基于特征的模式对硬字段中的潜在更改做出反应。同样，只要修改了特征代理（由特征模式组成），该修改就会传播到核心类和其他特征。Morover，无论何时执行don操作，都会自动修改核心对象，以重新评估可能触发的任何“ isA”操作。</p><p>可能会导致大量修改，从而严重影响性能（和正确性）。因此，当前实施了两种解决方案。首先，只要修改了核心对象，就只会更新最特定的特征（就特征接口之间的继承而言），并采用内部阻止机制来确保每个潜在匹配的模式仅被评估一次。因此，在以下情况下：</p><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span>
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> NationalGoldenustomer <span class="bold"><strong>extends</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span>
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> SeniorGoldenCustomer <span class="bold"><strong>extends</strong></span> GoldenCustomer <span class="bold"><strong>end</strong></span></code></pre><p>如果对对象的修改同时是GoldenCustomer，NationalGoldenCustomer和SeniorGoldenCustomer，则会仅实际修改后两个代理。第一个将匹配GoldenCustomer和NationalGoldenCustomer的任何模式；相反，将阻止后者重新匹配GoldenCustomer，但将允许其匹配SeniorGoldenCustomer模式。相反，没有必要修改GoldenCustomer代理，因为它已经被至少一个其他更特定的特征所涵盖。</p><p>直到usr为止的第二种方法是将特征标记为@PropertyReactive。属性反应性启用了特征，并考虑了特征字段映射，以阻止不必要的传播。</p><div class="section" title="8.7.8.1。级联特征"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9058"></a> 8.7.8.1。级联特征</h4></div></div></div><p><span class="bold"><strong>警告</strong></span> ：此功能是非常实验性的，可能会更改</p><p>通常，硬字段必须通过对象赋予的所有特征以其原始类型公开，以防止出现诸如</p><div class="example"><a id="d0e9067"></a><p class="title"><strong>示例8.42</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  @Traitable
  name : String
  id : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer
  id : String
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Patient
  id : long  // Person can't don Patient, or an exception will be thrown
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><p>如果人员不同时提供客户和患者，则硬字段ID的类型将是不明确的。但是，请考虑以下示例，在该示例中，GoldenCustomers推荐了他们最好的朋友，以便他们也成为客户：</p><div class="example"><a id="d0e9094"></a><p class="title"><strong>示例8.43</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>declare</strong></span> Person
  @Traitable( logical=true )
  bestFriend : Person
<span class="bold"><strong>end</strong></span>

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer <span class="bold"><strong>end</strong></span>
        
<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> GoldenCustomer <span class="bold"><strong>extends</strong></span> Customer
  refers : Customer <span class="italic">@Alias( "bestFriend" )</span>
<span class="bold"><strong>end</strong></span>          </code></pre></div></div><br class="example-break"><p>除了@Alias之外，Person-as-GoldenCustomer的最好朋友可能与特征GoldenCustomer的要求兼容，只要它们本身是某种客户。将人员标记为“具有逻辑特征”，即添加注释@Traitable（logical = true），将指示引擎尝试保持逻辑一致性，而不是由于具有不同类型声明的硬字段（人与客户）而引发异常）。然后将执行以下操作：</p><div class="example"><a id="d0e9128"></a><p class="title"><strong>示例8.44</strong></p><div class="example-contents"><pre><code class="no-highlight">Person p1 = new Person();
Person p2 = new Person();
p1.setBestFriend( p2 );
...
Customer c2 = don( p2, Customer.class );
...
GoldenCustomer gc1 = don( p1, GoldenCustomer.class );
...
p1.getBestFriend(); // returns p2
gc1.getRefers(); // returns c2, a Customer proxy wrapping p2</code></pre></div></div><br class="example-break"><p>请注意，当p1成为GoldenCustomer时，p2必须本身已经成为Customer，否则会因为抛出GoldenCustomer的定义而引发运行时异常。</p><p>但是，在某些情况下，由于p1是GoldenCustomer，所以您可能想推断而不是验证p2是客户。可以通过使用@ org.drools.core.factmodel.traits批注将Customer标记为“逻辑”来启用此模式。特性（逻辑= true）。在这种情况下，如果在p1成为GoldenCustomer时p2不再是客户，它将自动具有特质Customer以保持系统的逻辑完整性。</p><p>请注意，核心类上的注释启用了对其字段的动态类型管理，而特征上的注释则确定是将其强制执行为完整性约束还是动态地级联。</p><div class="example"><a id="d0e9137"></a><p class="title"><strong>示例8.45</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import</strong></span> org.drools.factmodel.traits.*;

<span class="bold"><strong>declare</strong></span> <span class="bold"><strong>trait</strong></span> Customer
    <span class="italic">@Trait( logical = true )</span>
<span class="bold"><strong>end</strong></span>        </code></pre></div></div><br class="example-break"></div></div></strong></strong></div><div class="section" title="8.8。规则"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e9154"></a> 8.8。规则</strong></strong></h2></div></div></div><div class="figure"><strong><strong><a id="d0e9157"></a><p class="title"><strong>图8.9。规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/rule.png" align="middle" alt="规则"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>一条规则指定， <span class="emphasis"><em>当</em></span>发生一组特殊条件时，在左侧（LHS）中指定该条件， <span class="emphasis"><em>然后</em></span>执行指定为右侧（RHS）中的动作列表的查询。用户的一个常见问题是“为什么使用when而不是if？之所以选择“何时”而不是“如果”，是因为“如果”通常是过程执行流程的一部分，在此过程中，应在特定时间点检查条件。相反，“何时”表示状态评估与特定的评估顺序或时间点无关，而是在发动机使用寿命内的任何时间连续发生；只要满足条件，便会执行操作。</p><p>规则必须在其规则包中具有唯一的名称。如果您在同一DRL中两次定义规则，则在加载时会产生错误。如果添加的DRL中已包含软件包中已存在的规则名称，则它将替换先前的规则。如果规则名称要有空格，则需要将其括在双引号中（最好始终使用双引号）。</p><p>属性-如下所述-是可选的。最好每行写一篇。</p><p>该规则的LHS遵循<code class="literal">when</code>关键字（最好在新行上），类似RHS遵循<code class="literal">then</code>关键字（同样，最好在换行符上）。规则以关键字终止<code class="literal">end</code> 。规则不能嵌套。</p><div class="example"><a id="d0e9186"></a><p class="title"><strong>示例8.46规则语法概述</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e9191"></a><p class="title"><strong>示例8.47一个简单的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</code></pre></div></div><br class="example-break"><div class="section" title="8.8.1。规则属性"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9196"></a> 8.8.1。规则属性</h3></div></div></div><p>规则属性提供了一种声明性的方式来影响规则的行为。有些非常简单，而另一些则是诸如规则流之类的复杂子系统的一部分。要充分利用Drools，您应该确保对每个属性都有正确的了解。</p><div class="figure"><a id="d0e9201"></a><p class="title"><strong>图8.10。规则属性</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/rule_attributes.png" align="middle" alt="规则属性"></div></div></div><br class="figure-break"><div class="variablelist"><dl><dt><span class="term"><code class="literal">no-loop</code></span></dt><dd><p>默认值：<code class="literal">false</code></p><p>类型：布尔型</p><p>当规则的结果修改事实时，可能导致规则再次激活，从而导致无限循环。将no-loop设置为true将跳过使用当前事实集为规则创建另一个激活的过程。</p></dd><dt><span class="term"><code class="literal">ruleflow-group</code></span></dt><dd><p>默认值：不适用</p><p>类型：字符串</p><p>Ruleflow是Drools的一项功能，使您可以控制规则的触发。由相同的规则流组标识符组合的规则只有在其组处于活动状态时才会触发。</p></dd><dt><span class="term"><code class="literal">lock-on-active</code></span></dt><dd><p>默认值：<code class="literal">false</code></p><p>类型：布尔型</p><p>每当规则流组变为活动状态或议程组获得焦点时，该组中任何将活动锁定设置为true的规则将不再被激活；无论更新的起源如何，都将放弃激活匹配规则。这是无环的更强版本，因为现在更改不仅可以由规则本身引起。对于具有许多修改事实的规则并且您不希望任何规则重新匹配并再次触发的计算规则而言，它是理想的选择。只有当规则流组不再处于活动状态或议程组失去焦点时，那些将活动锁定设置为true的规则才有资格再次将其激活置于议程中。</p></dd><dt><span class="term"><code class="literal">salience</code></span></dt><dd><p>默认值：<code class="literal">0</code></p><p>类型：整数</p><p>每个规则都有一个整数显着性属性，默认为零，可以为负也可以为正。显着性是优先级的一种形式，在激活队列中对具有较高显着性值的规则进行排序时，将赋予它们较高的优先级。</p><p>Drools还支持动态显着性，您可以在其中使用涉及绑定变量的表达式。</p><div class="example"><a id="d0e9260"></a><p class="title"><strong>示例8.48动态显着性</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Fire in rank order 1,2,.."
        salience( -$rank )
    when
        Element( $rank : rank,... )
    then
        ...
end</code></pre></div></div><br class="example-break"></dd><dt><span class="term"><code class="literal">agenda-group</code></span></dt><dd><p>默认值：MAIN</p><p>类型：字符串</p><p>议程组允许用户对议程进行分区，以提供更多执行控制。只有议程组中已获得焦点的规则才可以执行。</p></dd><dt><span class="term"><code class="literal">auto-focus</code></span></dt><dd><p>默认值：<code class="literal">false</code></p><p>类型：布尔型</p><p>激活规则后， <code class="code">auto-focus</code>值是正确的并且规则的议程组还没有焦点，则将其赋予焦点，从而使规则有可能被触发。</p></dd><dt><span class="term"><code class="literal">activation-group</code></span></dt><dd><p>默认值：不适用</p><p>类型：字符串</p><p>由该属性的字符串值标识的属于同一个激活组的规则将仅被触发。更准确地讲，激活组中要触发的第一个规则将取消组中所有规则的所有未决激活，即停止激发它们。</p><p>注意：这以前称为Xor组，但从技术上讲，它不是Xor。您可能仍然听到有人提到Xor小组；只需将您的想法与激活组互换即可。</p></dd><dt><span class="term"><code class="literal">dialect</code></span></dt><dd><p>默认值：由软件包指定</p><p>类型：字符串</p><p>可能的值：“ java”或“ mvel”</p><p>该方言在LHS或RHS代码块中的任何代码表达式中都使用了该语言。当前有两种方言，Java和MVEL。虽然可以在包级别指定方言，但此属性允许包定义被规则覆盖。</p></dd><dt><span class="term"><code class="literal">date-effective</code></span></dt><dd><p>默认值：不适用</p><p>类型：字符串，包含日期和时间定义</p><p>仅当当前日期和时间在日期生效属性之后时，规则才能激活。</p></dd><dt><span class="term"><code class="literal">date-expires</code></span></dt><dd><p>默认值：不适用</p><p>类型：字符串，包含日期和时间定义</p><p>如果当前日期和时间在date-expires属性之后，则无法激活规则。</p></dd><dt><span class="term"><code class="literal">duration</code></span></dt><dd><p>默认值：无默认值</p><p>类型：长</p><p>持续时间表明规则将在指定的持续时间后继续触发（如果它仍然为真）。</p></dd></dl></div><div class="example"><a id="d0e9351"></a><p class="title"><strong>示例8.49一些属性示例</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.2。计时器和日历"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9356"></a> 8.8.2。计时器和日历</h3></div></div></div><p>规则现在支持基于间隔和基于cron的计时器，它们取代了现在不建议使用的duration属性。</p><div class="example"><a id="d0e9361"></a><p class="title"><strong>示例8.50样本计时器属性使用</strong></p><div class="example-contents"><pre><code class="language-java">timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt;? )
timer ( int: 30s )
timer ( int: 30s 5m )

timer ( cron: &lt;cron expression&gt; )
timer ( cron:* 0/15 * * * ? )</code></pre></div></div><br class="example-break"><p>间隔（由“ int：”指示）计时器遵循java.util的语义。计时器对象，具有初始延迟和可选的重复间隔。Cron（用“ cron：”指示）计时器遵循标准的Unix cron表达式：</p><div class="example"><a id="d0e9368"></a><p class="title"><strong>示例8.51Cron示例</strong></p><div class="example-contents"><pre><code class="language-java">rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end</code></pre></div></div><br class="example-break"><p>由计时器控制的规则在匹配时将变为活动状态，并且每次单独匹配一次。根据计时器的设置，其结果将重复执行。只要条件不再匹配，此操作就会停止。</p><p>即使控制从对fireUntilHalt的调用返回后，结果也将执行。此外，引擎对工作内存所做的任何更改都会保持反应。例如，删除触发计时器规则的执行所涉及的事实会导致重复执行终止，或者插入事实以使某些规则匹配会触发该规则。但是无论出于何种原因，只有在规则触发后，引擎才会持续处于活动状态。因此，直到下一次执行计时器控制的规则时，才会异步执行插入操作。处置会话将终止所有计时器活动。</p><p>相反，默认情况下，当规则引擎在被动模式下运行时（即：使用fireAllRules代替fireUntilHalt），除非再次调用fireAllRules，否则不会触发定时规则的结果。但是，可以通过使用以下命令配置KieSession来更改此默认行为： <code class="code">TimedRuleExectionOption</code>如以下示例所示。</p><div class="example"><a id="d0e9382"></a><p class="title"><strong>示例8.52配置KieSession以自动执行定时规则</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExectionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, null);</code></pre></div></div><br class="example-break"><p>也可以对必须自动执行的定时规则进行更精细的控制。为此，必须设置一个<code class="code">FILTERED</code><code class="code">TimedRuleExectionOption</code>可以定义一个回调来过滤这些规则，如下面的示例所示。</p><div class="example"><a id="d0e9395"></a><p class="title"><strong>示例8.53配置过滤器以选择应自动执行哪些定时规则</strong></p><div class="example-contents"><pre><code class="language-java">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( new TimedRuleExectionOption.FILTERED(new TimedRuleExecutionFilter() {
    public boolean accept(Rule[] rules) {
        return rules[0].getName().equals("MyRule");
    }
}) );</code></pre></div></div><br class="example-break"><p>关于间隔计时器，还可以将延迟和间隔定义为表达式而不是固定值。为此，必须使用表达式计时器（由“ expr：”指示），如以下示例所示：</p><div class="example"><a id="d0e9402"></a><p class="title"><strong>示例8.54表达式计时器示例</strong></p><div class="example-contents"><pre><code class="language-java">declare Bean
    delay   : String = "30s"
    period  : long = 60000
end

rule "Expression timer"
    timer( expr: $d, $p )
when
    Bean( $d : delay, $p : period )
then
end</code></pre></div></div><br class="example-break"><p>在这种情况下，表达式$ d和$ p可以使用规则的模式匹配部分中定义的任何变量，并且可以是可以在一段时间内解析的任何String或可以在内部进行长时间转换的任何数值。代表以毫秒为单位的持续时间。</p><p>时间间隔和表达式计时器都可以具有3个可选参数，分别名为“开始”，“结束”和“重复限制”。当使用这些参数中的一个或多个时，计时器定义的第一部分必须后跟分号“;”。并且参数必须用逗号“，”分隔，如以下示例所示：</p><div class="example"><a id="d0e9411"></a><p class="title"><strong>示例8.55具有开始和结束的间隔计时器</strong></p><div class="example-contents"><pre><code class="language-java">timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)</code></pre></div></div><br class="example-break"><p>start和end参数的值可以是Date，代表Date的String或长整数，或者通常是任何Number，可以用以下转换在Java Date中进行转换：</p><pre><code class="language-java">new Date( ((Number) n).longValue() )</code></pre><p>相反，repeat-limit只能是整数，它定义计时器允许的最大重复次数。如果同时设置了end和repeat-limit参数，则当两者中的第一个匹配时，计时器将停止。</p><p>使用start参数意味着为计时器定义了一个阶段，其中阶段的开始由开始本身加上最终的延迟给出。换句话说，在这种情况下，有时会安排定时规则：</p><pre><code class="language-java">start + delay + n*period</code></pre><p>最多可重复限制时间，且不得迟于结束时间戳记（以先到者为准）。例如具有以下间隔计时器的规则</p><pre><code class="language-java">timer ( int: 30s 1m; start="3-JAN-2010" )</code></pre><p>排定在2010年1月3日午夜之后的每分钟30秒。这也意味着，例如，如果您在3-FEB-2010的午夜打开系统，则不会立即进行安排，但会保留计时器定义的阶段，因此将在30秒后第一次进行安排午夜。如果由于某种原因系统被暂停（例如，会话被序列化，然后在一段时间后反序列化），则该规则将仅计划一次以从丢失的激活中恢复（无论我们错过了多少激活），随后将再次计划该规则。与计时器的相位。</p><p>日历用于控制规则何时可以触发。Calendar API在<a class="link" href="http://www.quartz-scheduler.org/">Quartz</a>上建模：</p><div class="example"><a id="d0e9437"></a><p class="title"><strong>示例8.56调整石英日历</strong></p><div class="example-contents"><pre><code class="language-java">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</code></pre></div></div><br class="example-break"><p>日历已在KieSession中注册：</p><div class="example"><a id="d0e9444"></a><p class="title"><strong>示例8.57注册日历</strong></p><div class="example-contents"><pre><code class="language-java">ksession.getCalendars().set( "weekday", weekDayCal );</code></pre></div></div><br class="example-break"><p>它们可以与常规规则和包括计时器的规则结合使用。规则属性“ calendars”可以包含一个或多个用逗号分隔的日历名称，这些名称以字符串文字形式表示。</p><div class="example"><a id="d0e9451"></a><p class="title"><strong>示例8.58一起使用日历和计时器</strong></p><div class="example-contents"><pre><code class="language-java">rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm" );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm" );
end</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3。左侧语法（当）"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9456"></a> 8.8.3。左侧语法（当）</h3></div></div></div><div class="section" title="8.8.3.1。什么是左手边？"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9459"></a> 8.8.3.1。什么是左手边？</h4></div></div></div><p>左侧（LHS）是规则条件部分的通用名称。它由零个或多个条件元素组成。如果LHS为空，则它将被视为始终为true的条件元素，并且在创建新的WorkingMemory会话时将被激活一次。</p><div class="figure"><a id="d0e9464"></a><p class="title"><strong>图8.11。左手边</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/lhs.png" align="middle" alt="左手边"></div></div></div><br class="figure-break"><div class="example"><a id="d0e9470"></a><p class="title"><strong>示例8.59没有条件元素的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "no CEs"
when
    // empty
then
    ... // actions (executed once)
end

// The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    ... // actions (executed once)
end</code></pre></div></div><br class="example-break"><p>条件元素适用于一种或多种<span class="emphasis"><em>模式</em></span> （如下所述）。最常见的条件元素是“ <code class="literal">and"</code> 。因此，当规则的LHS中有多个未以任何方式连接的模式时，它是隐式的：</p><div class="example"><a id="d0e9483"></a><p class="title"><strong>示例8.60隐式和</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "2 unconnected patterns"
when
    Pattern1()
    Pattern2()
then
    ... // actions
end

// The above rule is internally rewritten as:

rule "2 and connected patterns"
when
    Pattern1()
    and Pattern2()
then
    ... // actions
end</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>一个“ <code class="literal">and"</code>不能有前导声明绑定（例如<code class="literal">or</code> ）。这很明显，因为声明一次只能引用一个事实，而当“ <code class="literal">and"</code>是否满足这两个事实-声明将绑定到哪个事实？</p><pre><code class="no-highlight">// Compile error
$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))</code></pre></div></div><div class="section" title="8.8.3.2。模式（条件元素）"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9502"></a> 8.8.3.2。模式（条件元素）</h4></div></div></div><div class="section" title="8.8.3.2.1。什么是模式？"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9505"></a> 8.8.3.2.1。什么是模式？</h5></div></div></div><p>模式元素是最重要的条件元素。它可以潜在地匹配插入工作内存中的每个事实。</p><p>模式包含零个或多个约束，并具有可选的模式绑定。下面的铁路图显示了此语法。</p><div class="figure"><a id="d0e9512"></a><p class="title"><strong>图8.12。图案</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/pattern.png" align="middle" alt="图案"></div></div></div><br class="figure-break"><p>在没有约束的最简单形式中，模式与给定类型的事实匹配。在以下情况下，类型为<code class="code">Cheese</code> ，这意味着该模式将与所有<code class="code">Person</code>工作内存中的对象：</p><pre><code class="no-highlight">Person()</code></pre><p>类型不必是某个事实对象的实际类。模式可以引用超类甚至接口，从而可能匹配来自许多不同类的事实。</p><pre><code class="no-highlight">Object() // matches all objects in the working memory</code></pre><p>模式括号内是所有动作发生的地方：它定义了该模式的约束。例如，与年龄相关的约束：</p><pre><code class="no-highlight">Person( age == 100 )</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>出于向后兼容的原因，允许在模式后缀<code class="literal">;</code>字符。但是不建议这样做。</p></div></div><div class="section" title="8.8.3.2.2。模式绑定"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9542"></a> 8.8.3.2.2。模式绑定</h5></div></div></div><p>要引用匹配的对象，请使用模式绑定变量，例如<code class="code">$p</code> 。</p><div class="example"><a id="d0e9550"></a><p class="title"><strong>示例8.61具有绑定变量的模式</strong></p><div class="example-contents"><pre><code class="no-highlight">rule ...
when
    $p : Person()
then
    System.out.println( "Person " + $p );
end</code></pre></div></div><br class="example-break"><p>前缀美元符号（ <code class="literal">$</code> ）只是一个约定；它在复杂的规则中很有用，因为它有助于轻松地区分变量和字段，但这不是强制性的。</p></div></div><div class="section" title="8.8.3.3。约束（模式的一部分）"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9560"></a> 8.8.3.3。约束（模式的一部分）</h4></div></div></div><div class="section" title="8.8.3.3.1。什么是约束？"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9563"></a> 8.8.3.3.1。什么是约束？</h5></div></div></div><p>约束是返回的表达式<code class="literal">true</code>要么<code class="literal">false</code> 。此示例的约束条件是状态<span class="emphasis"><em>5小于6</em></span> ：</p><pre><code class="no-highlight">Person( 5 &lt; 6 )  // just an example, as constraints like this would be useless in a real pattern</code></pre><p>从本质上讲，它是一个Java表达式，具有一些增强功能（例如属性访问）和一些区别（例如<code class="literal">equals()</code>的语义<code class="literal">==</code> ）。让我们更深入地看看。</p></div><div class="section" title="8.8.3.3.2。Java Bean（POJO）上的属性访问"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9587"></a> 8.8.3.3.2。Java Bean（POJO）上的属性访问</h5></div></div></div><p>任何bean属性都可以直接使用。使用标准Java bean getter公开bean属性：方法<code class="literal">getMyProperty()</code> （要么<code class="literal">isMyProperty()</code>对于原始布尔值），该参数不接受任何参数并返回某些内容。例如：age属性写为<code class="literal">age</code>在DRL中而不是在getter中<code class="literal">getAge()</code> ：</p><pre><code class="no-highlight">Person( age == 50 )

// this is the same as:
Person( getAge() == 50 )</code></pre><p>Drools使用标准的JDK <code class="literal">Introspector</code>类执行此映射，因此它遵循标准Java bean规范。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>我们建议您使用媒体资源访问权限（ <code class="literal">age</code> ）明确使用getters（ <code class="literal">getAge()</code> ），因为通过字段索引可以提高性能。</p></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>属性访问器不得以可能影响规则的方式更改对象的状态。请记住，规则引擎在两次调用之间有效地缓存了其匹配的结果，以使其更快。</p><pre><code class="no-highlight">public int getAge() {
    age++; // Do NOT do this
    return age;
}</code></pre><pre><code class="no-highlight">public int getAge() {
    Date now = DateUtil.now(); // Do NOT do this
    return DateUtil.differenceInYears(now, birthday);
}</code></pre><p>要解决后一种情况，请插入一个将当前日期包装到工作内存中的事实，并在<code class="literal">fireAllRules</code>如所须。</p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>以下回退适用：如果找不到属性的getter，则编译器将诉诸使用属性名称作为方法名称且不带参数的情况：</p><pre><code class="no-highlight">Person( age == 50 )

// If Person.getAge() does not exists, this falls back to:
Person( age() == 50 )</code></pre></div><p>还支持嵌套属性访问：</p><pre><code class="no-highlight">Person( address.houseNumber == 50 )

// this is the same as:
Person( getAddress().getHouseNumber() == 50 )</code></pre><p>嵌套属性也被索引。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>在有状态会话中，使用嵌套访问器时应格外小心，因为工作内存不知道任何嵌套值，也不知道它们何时更改。当它们的任何父引用插入到工作内存中时，要么将它们视为不可变的。或者，相反，如果您希望修改嵌套值，则应将所有外部事实标记为已更新。在上面的示例中，当<code class="literal">houseNumber</code>变化，任何<code class="literal">Person</code>接着就，随即<code class="literal">Address</code>必须标记为已更新。</p></div></div><div class="section" title="8.8.3.3.3。Java表达式"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9655"></a> 8.8.3.3.3。Java表达式</h5></div></div></div><p>您可以使用任何返回以下内容的Java表达式： <code class="literal">boolean</code>作为模式括号内的约束。Java表达式可以与其他表达式增强功能（例如属性访问）混合使用：</p><pre><code class="no-highlight">Person( age == 50 )</code></pre><p>可以在任何逻辑或数学表达式中使用括号来更改评估优先级：</p><pre><code class="no-highlight">Person( age &gt; 100 &amp;&amp; ( age % 10 == 0 ) )</code></pre><p>可以重用Java方法：</p><pre><code class="no-highlight">Person( Math.round( weight / ( height * height ) ) &lt; 25.0 )</code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>对于属性访问器，方法不得以可能影响规则的方式更改对象的状态。在LHS中对事实执行的任何方法都应该是<span class="emphasis"><em>只读</em></span>方法。</p><pre><code class="no-highlight">Person( incrementAndGetAge() == 10 ) // Do NOT do this</code></pre></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>事实的状态不应在规则调用之间更改（除非这些事实在每次更改时都标记为已更新到工作内存）：</p><pre><code class="no-highlight">Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this</code></pre></div><p>普通的Java运算符优先级适用，请参阅下面的运算符优先级列表。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>所有运算符都具有正常的Java语义，除了<code class="literal">==</code>和<code class="literal">!=</code> 。</p><p>的<code class="literal">==</code>运算符具有null安全<code class="literal">equals()</code>语义：</p><pre><code class="no-highlight">// Similar to: java.util.Objects.equals(person.getFirstName(), "John")
// so (because "John" is not null) similar to:
// "John".equals(person.getFirstName())
Person( firstName == "John" )</code></pre><p>的<code class="literal">!=</code>运算符具有null安全<code class="literal">!equals()</code>语义：</p><pre><code class="no-highlight">// Similar to: !java.util.Objects.equals(person.getFirstName(), "John")
Person( firstName != "John" )</code></pre></div><p>如果字段和值的类型不同，则总是尝试强制类型转换。如果尝试强制强制，则会引发异常。例如，如果在数字求值器中以字符串形式提供“十”，则会引发异常，而“ 10”将强制为数字10。强制总是支持字段类型而不是值类型：</p><pre><code class="no-highlight">Person( age == "10" ) // "10" is coerced to 10</code></pre></div><div class="section" title="8.8.3.3.4。逗号分隔且"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9721"></a> 8.8.3.3.4。逗号分隔且</h5></div></div></div><p>逗号字符（' <code class="literal">,</code> '）用于分隔约束组。它具有隐式<span class="emphasis"><em>和</em></span>连接语义。</p><pre><code class="no-highlight">// Person is at least 50 and weighs at least 80 kg
Person( age &gt; 50, weight &gt; 80 )</code></pre><pre><code class="no-highlight">// Person is at least 50, weighs at least 80 kg and is taller than 2 meter.
Person( age &gt; 50, weight &gt; 80, height &gt; 2 )</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>虽然<code class="literal">&&</code>和<code class="literal">,</code>运算符具有相同的语义，它们具有不同的优先级来解析： <code class="literal">&&</code>运算符先于<code class="literal">||</code>操作员。这俩<code class="literal">&&</code>和<code class="literal">||</code>运算符先于<code class="literal">,</code>操作员。请参阅下面的运算符优先级列表。</p><p>在顶级约束条件下，最好使用逗号运算符，因为它使约束条件更易于阅读，并且引擎通常能够更好地优化它们。</p></div><p>逗号（ <code class="literal">,</code> ）运算符不能嵌入到复合约束表达式中，例如括号：</p><pre><code class="no-highlight">Person( ( age &gt; 50, weight &gt; 80 ) || height &gt; 2 ) // Do NOT do this: compile error

// Use this instead
Person( ( age &gt; 50 &amp;&amp; weight &gt; 80 ) || height &gt; 2 )</code></pre></div><div class="section" title="8.8.3.3.5。绑定变量"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9769"></a> 8.8.3.3.5。绑定变量</h5></div></div></div><p>属性可以绑定到变量：</p><pre><code class="no-highlight">// 2 persons of the same age
Person( $firstAge : age ) // binding
Person( age == $firstAge ) // constraint expression</code></pre><p>前缀美元符号（ <code class="literal">$</code> ）只是一个约定；它在复杂的规则中很有用，因为它有助于轻松地区分变量和字段。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>出于向后兼容的原因，允许（但不建议）如下混合约束绑定和约束表达式：</p><pre><code class="no-highlight">// Not recommended
Person( $age : age * 2 &lt; 100 )</code></pre><pre><code class="no-highlight">// Recommended (separates bindings and constraint expressions)
Person( age * 2 &lt; 100, $age : age )</code></pre></div><p>使用运算符的绑定变量限制<code class="literal">==</code>提供了非常快的执行速度，因为它使用哈希索引来提高性能。</p></div><div class="section" title="8.8.3.3.6。统一性"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9793"></a> 8.8.3.3.6。统一性</h5></div></div></div><p>Drools不允许绑定到同一声明。但是，这是派生查询统一的重要方面。虽然位置参数始终以统一方式处理，但为名为arguments的命名参数引入了特殊的统一符号'：='。以下内容将两个人的年龄论点“统一”起来。</p><pre><code class="no-highlight">Person( $age := age ) 
Person( $age := age) </code></pre><p>本质上，统一将声明第一次出现的绑定，并约束序列出现的绑定字段的相同值。</p></div><div class="section" title="8.8.3.3.7。嵌套对象的分组访问器"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9802"></a> 8.8.3.3.7。嵌套对象的分组访问器</h5></div></div></div><p>通常，经常需要访问嵌套对象的多个属性，如以下示例所示</p><pre><code class="no-highlight">Person( name == "mark", address.city == "london", address.country == "uk" )</code></pre><p>这些嵌套对象的访问器可以用'。（...）分组。的语法提供了更具可读性的规则，如</p><pre><code class="no-highlight">Person( name == "mark", address.( city == "london", country == "uk") )</code></pre><p>注意“。”前缀，这是区分嵌套对象约束和方法调用所必需的。</p></div><div class="section" title="8.8.3.3.8。内联强制转换和强制"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9815"></a> 8.8.3.3.8。内联强制转换和强制</h5></div></div></div><p>在处理嵌套对象时，也很常见需要转换为子类型。可以通过＃符号来实现，如下所示：</p><pre><code class="no-highlight">Person( name == "mark", address#LongAddress.country == "uk" )</code></pre><p>此示例将Address强制转换为LongAddress，使其可用的getter可用。如果无法进行强制转换（instanceof返回false），则评估将被视为false。还支持全限定名称：</p><pre><code class="no-highlight">Person( name == "mark", address#org.domain.LongAddress.country == "uk" )</code></pre><p>可以在同一表达式中使用多个内联强制转换：</p><pre><code class="no-highlight">Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</code></pre><p>此外，由于我们还支持instanceof运算符，因此如果使用了instanceof运算符，我们将在该模式内推断其结果以供该字段的进一步使用：</p><pre><code class="no-highlight">Person( name == "mark", address instanceof LongAddress, address.country == "uk" )</code></pre></div><div class="section" title="8.8.3.3.9。特殊文字支持"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9834"></a> 8.8.3.3.9。特殊文字支持</h5></div></div></div><p>除了普通的Java文字（包括Java 5枚举）之外，还支持以下文字：</p><div class="section" title="8.8.3.3.9.1。日期文字"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9839"></a> 8.8.3.3.9.1。日期文字</h6></div></div></div><p>日期格式<code class="literal">dd-mmm-yyyy</code>默认情况下受支持。您可以通过提供备用日期格式掩码作为System属性命名来自定义此属性<code class="code">drools.dateformat</code> 。如果需要更多控制，请使用限制。</p><div class="example"><a id="d0e9850"></a><p class="title"><strong>示例8.62日期文字限制</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( bestBefore &lt; "27-Oct-2009" )</code></pre></div></div><br class="example-break"></div></div><div class="section" title="8.8.3.3.10。列表和地图访问"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9855"></a> 8.8.3.3.10。列表和地图访问</h5></div></div></div><p>可以直接访问<code class="literal">List</code>索引值：</p><pre><code class="no-highlight">// Same as childList(0).getAge() == 18
Person( childList[0].age == 18 )</code></pre><p>也可以直接访问<code class="literal">Map</code>按键值：</p><pre><code class="no-highlight">// Same as credentialMap.get("jsmith").isValid()
Person( credentialMap["jsmith"].valid )</code></pre></div><div class="section" title="8.8.3.3.11。缩写组合关系条件"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9872"></a> 8.8.3.3.11。缩写组合关系条件</h5></div></div></div><p>这使您可以使用限制连接词在一个字段上放置多个限制<code class="literal">&&</code>要么<code class="literal">||</code> 。允许通过括号分组，从而产生递归语法模式。</p><div class="figure"><a id="d0e9883"></a><p class="title"><strong>图8.13。缩写组合关系条件</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/abbreviatedCombinedRelationCondition.png" align="middle" alt="缩写组合关系条件"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e9889"></a><p class="title"><strong>图8.14。带括号的组合关系条件的缩写</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/abbreviatedCombinedRelationConditionGroup.png" align="middle" alt="带括号的组合关系条件的缩写"></div></div></div><br class="figure-break"><pre><code class="no-highlight">// Simple abbreviated combined relation condition using a single &amp;&amp;
Person( age &gt; 30 &amp;&amp; &lt; 40 )</code></pre><pre><code class="no-highlight">// Complex abbreviated combined relation using groupings
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) ||
              (&gt; 20 &amp;&amp; &lt; 25) ) )</code></pre><pre><code class="no-highlight">// Mixing abbreviated combined relation with constraint connectives
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" )</code></pre></div><div class="section" title="8.8.3.3.12。特殊DRL运营商"><div class="titlepage"><div><div><h5 class="title"><a id="d0e9901"></a> 8.8.3.3.12。特殊DRL运营商</h5></div></div></div><div class="figure"><a id="d0e9904"></a><p class="title"><strong>图8.15。经营者</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/operator.png" align="middle" alt="经营者"></div></div></div><br class="figure-break"><p>尝试将强制值强制为评估者和字段。</p><div class="section" title="8.8.3.3.12.1。运算符<<=>> ="><div class="titlepage"><div><div><h6 class="title"><a id="d0e9912"></a> 8.8.3.3.12.1。经营者<code class="literal"><</code><code class="literal"><=</code><code class="literal">></code>
          <code class="literal">>=</code></h6></div></div></div><p>这些运算符可用于具有自然顺序的属性。例如，对于日期字段， <code class="literal"><</code>表示<span class="emphasis"><em>在之前</em></span> <code class="literal">String</code>字段，则表示字母顺序较低。</p><pre><code class="no-highlight">Person( firstName &lt; $otherFirstName )</code></pre><pre><code class="no-highlight">Person( birthDate &lt; $otherBirthDate )</code></pre><p>仅适用于<code class="literal">Comparable</code>属性。</p></div><div class="section" title="8.8.3.3.12.2。空安全解引用运算符"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9946"></a> 8.8.3.3.12.2。空安全解引用运算符</h6></div></div></div><p>！！运算符允许以null安全的方式取消引用。更详细地，匹配算法需要！左侧的值。运算符不能为null，以便为模式匹配本身提供肯定的结果。换句话说，模式：</p><pre><code class="no-highlight">Person( $streetName : address!.street )</code></pre><p>将内部翻译为：</p><pre><code class="no-highlight">Person( address != null, $streetName : address.street )</code></pre></div><div class="section" title="8.8.3.3.12.3。运算符匹配"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9957"></a> 8.8.3.3.12.3。运营商<code class="literal">matches</code></h6></div></div></div><p>将字段与任何有效的Java匹配<a id="d0e9964" class="indexterm"></a>正则表达式。通常，该regexp是字符串文字，但是也可以使用解析为有效regexp的变量。</p><div class="example"><a id="d0e9968"></a><p class="title"><strong>示例8.63正则表达式约束</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( type matches "(Buffalo)?\\S*Mozarella" )</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>像Java中一样，以字符串文字形式编写的正则表达式<span class="emphasis"><em>需要转义' <code class="literal">\</code></em></span> '。</p></div><p>仅适用于<code class="literal">String</code>属性。使用<code class="literal">matches</code>针对<code class="literal">null</code>值始终评估为false。</p></div><div class="section" title="8.8.3.3.12.4。运算符不匹配"><div class="titlepage"><div><div><h6 class="title"><a id="d0e9992"></a> 8.8.3.3.12.4。运营商<code class="literal">not matches</code></h6></div></div></div><p>如果String与正则表达式不匹配，则运算符返回true。相同的规则适用于<code class="literal">matches</code>操作员。例：</p><div class="example"><a id="d0e10002"></a><p class="title"><strong>示例8.64正则表达式约束</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( type not matches "(Buffulo)?\\S*Mozarella" )</code></pre></div></div><br class="example-break"><p>仅适用于<code class="literal">String</code>属性。使用<code class="literal">not matches</code>针对<code class="literal">null</code>值始终评估为true。</p></div><div class="section" title="8.8.3.3.12.5。运算符包含"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10018"></a> 8.8.3.3.12.5。运营商<code class="literal">contains</code></h6></div></div></div><p>运营商<code class="literal">contains</code>用于检查字段是否为<a id="d0e10028" class="indexterm"></a>集合或元素包含指定的值。</p><div class="example"><a id="d0e10032"></a><p class="title"><strong>示例8.65包含收藏</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</code></pre></div></div><br class="example-break"><p>仅适用于<code class="literal">Collection</code>属性。</p><p>运营商<code class="literal">contains</code>也可以代替<code class="literal">String.contains()</code>约束检查。</p><div class="example"><a id="d0e10050"></a><p class="title"><strong>示例8.66包含字符串文字</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( name contains "tilto" )
Person( fullName contains "Jr" )
String( this contains "foo" )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.3.12.6。运算符不包含"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10055"></a> 8.8.3.3.12.6。运营商<code class="literal">not contains</code></h6></div></div></div><p>运营商<code class="literal">not contains</code>用于检查字段是否为<a id="d0e10065" class="indexterm"></a>集合或元素<span class="emphasis"><em>不</em></span>包含指定的值。</p><div class="example"><a id="d0e10072"></a><p class="title"><strong>示例8.67具有集合的文字约束</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</code></pre></div></div><br class="example-break"><p>仅适用于<code class="literal">Collection</code>属性。</p><div class="blockquote"><blockquote class="blockquote"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>为了向后兼容， <code class="literal">excludes</code>支持将运算符作为的同义词<code class="literal">not contains</code> 。</p></div></blockquote></div><p>运营商<code class="literal">not contains</code>也可以代替逻辑否定<code class="literal">String.contains()</code>用于约束检查-即：<code class="literal">! String.contains()</code></p><div class="example"><a id="d0e10102"></a><p class="title"><strong>示例8.68包含字符串文字</strong></p><div class="example-contents"><pre><code class="no-highlight">Cheese( name not contains "tilto" )
Person( fullName not contains "Jr" )
String( this not contains "foo" )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.3.12.7。操作员memberOf"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10107"></a> 8.8.3.3.12.7。运营商<code class="literal">memberOf</code></h6></div></div></div><p>运营商<code class="literal">memberOf</code>用于检查字段是否为集合或元素的成员；该集合必须是一个变量。</p><div class="example"><a id="d0e10117"></a><p class="title"><strong>示例8.69具有集合的文字约束</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheese memberOf $matureCheeses )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.3.12.8。运算符不是memberOf"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10122"></a> 8.8.3.3.12.8。运营商<code class="literal">not memberOf</code></h6></div></div></div><p>运营商<code class="literal">not memberOf</code>用于检查字段是否不是集合或元素的成员；该集合必须是一个变量。</p><div class="example"><a id="d0e10132"></a><p class="title"><strong>示例8.70具有集合的文字约束</strong></p><div class="example-contents"><pre><code class="no-highlight">CheeseCounter( cheese not memberOf $matureCheeses )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.3.12.9。操作员听起来像"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10137"></a> 8.8.3.3.12.9。运营商<code class="literal">soundslike</code></h6></div></div></div><p>该运算符类似于<code class="literal">matches</code> ，但它会检查一个单词是否具有与给定值几乎相同的声音（使用英语发音）。这基于Soundex算法（请参阅<code class="code">http://en.wikipedia.org/wiki/Soundex</code> ）。</p><div class="example"><a id="d0e10150"></a><p class="title"><strong>示例8.71听起来像测试</strong></p><div class="example-contents"><pre><code class="no-highlight">// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.3.12.10。运算符str"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10155"></a> 8.8.3.3.12.10。运营商<code class="literal">str</code></h6></div></div></div><p>这个运算符<code class="literal">str</code>用于检查字段是否为<code class="literal">String</code>以某个值开头或结尾。它也可以用来检查字符串的长度。</p><pre><code class="no-highlight">Message( routingValue str[startsWith] "R1" )</code></pre><pre><code class="no-highlight">Message( routingValue str[endsWith] "R2" )</code></pre><pre><code class="no-highlight">Message( routingValue str[length] 17 )</code></pre></div><div class="section" title="8.8.3.3.12.11。运算符in和not in（复合值限制）"><div class="titlepage"><div><div><h6 class="title"><a id="d0e10174"></a> 8.8.3.3.12.11。经营者<code class="literal">in</code>和<code class="literal">not in</code> （化合物值限制）</h6></div></div></div><p>复合值限制用于存在多个可能匹配的值的情况。目前只有<code class="literal">in</code>和<code class="literal">not in</code>评估人员对此表示支持。此运算符的第二个操作数必须是用逗号分隔的值列表，并用括号括起来。值可以作为变量，文字，返回值或合格标识符给出。两个评估器实际上都是<span class="emphasis"><em>语法糖</em></span> ，使用运算符在内部重写为多个限制的列表<code class="literal">!=</code>和<code class="literal">==</code> 。</p><div class="figure"><a id="d0e10200"></a><p class="title"><strong>图8.16。复合值限制</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/compoundValueRestriction.png" align="middle" alt="复合值限制"></div></div></div><br class="figure-break"><div class="example"><a id="d0e10206"></a><p class="title"><strong>示例8.72复合限制使用“ in”</strong></p><div class="example-contents"><pre><code class="no-highlight">Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese ) )</code></pre></div></div><br class="example-break"></div></div><div class="section" title="8.8.3.3.13。内联eval运算符（已弃用）"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10211"></a> 8.8.3.3.13。内联eval运算符（已弃用）</h5></div></div></div><div class="figure"><a id="d0e10214"></a><p class="title"><strong>图8.17。内联评估表达式</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/inlineEvalConstraint.png" align="middle" alt="内联评估表达式"></div></div></div><br class="figure-break"><p>一个<a id="d0e10222" class="indexterm"></a>内联eval约束可以使用任何有效的方言表达式，只要其结果是原始布尔值即可。该表达式必须随时间恒定。可以使用来自当前或先前模式的任何先前绑定的变量； autovivification也用于自动创建字段绑定变量。当找到不是当前变量的标识符时，构建器将查看该标识符是否是当前对象类型上的字段，如果是，则字段绑定将自动创建为同名变量。这称为内联eval内部字段变量的自动生存。</p><p>此示例将查找所有男性-女性对，其中男性比女性大2岁；变量<code class="code">age</code>通过自动生存过程以第二种模式自动创建。</p><div class="example"><a id="d0e10231"></a><p class="title"><strong>示例8.73返回值运算符</strong></p><div class="example-contents"><pre><code class="no-highlight">Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' ) // eval() is actually obsolete in this example</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>内联eval实际上已经过时了，因为现在直接支持其内部语法。建议不要使用它们。只需编写表达式，而无需在其周围包裹eval（）。</p></div></div><div class="section" title="8.8.3.3.14。运算符优先级"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10239"></a> 8.8.3.3.14。运算符优先级</h5></div></div></div><p>运算符按以下优先级进行评估：</p><div class="table"><a id="d0e10244"></a><p class="title"><strong>表8.1。运算符优先级</strong></p><div class="table-contents"><table border="1" summary="Operator precedence"><colgroup><col><col><col></colgroup><thead><tr><th align="center">操作员类型</th><th align="center">经营者</th><th align="center">笔记</th></tr></thead><tbody><tr><td>（嵌套/空安全）属性访问</td><td><code class="literal">.</code> <code class="literal">!.</code></td><td>不正常的Java语义</td></tr><tr><td>列表/地图访问</td><td><code class="literal">[ ]</code></td><td>不正常的Java语义</td></tr><tr><td>约束约束</td><td><code class="literal">:</code></td><td>不正常的Java语义</td></tr><tr><td>可乘的</td><td><code class="literal">*</code> <code class="literal">/</code>
                <code class="literal">%</code></td><td> </td></tr><tr><td>添加剂</td><td><code class="literal">+</code> <code class="literal">-</code></td><td> </td></tr><tr><td>转移</td><td><code class="literal"><<</code> <code class="literal">>></code>
                <code class="literal">>>></code></td><td> </td></tr><tr><td>关系的</td><td><code class="literal"><</code> <code class="literal">></code>
                <code class="literal"><=</code> <code class="literal">>=</code>
                <code class="literal">instanceof</code></td><td> </td></tr><tr><td>平等</td><td><code class="literal">==</code> <code class="literal">!=</code></td><td>不使用与普通Java（ <span class="emphasis"><em>not</em></span> ） <span class="emphasis"><em>相同的</em></span>语义：使用（ <span class="emphasis"><em>not</em></span> ） <span class="emphasis"><em>等于</em></span>语义。</td></tr><tr><td>非短路与</td><td><code class="literal">&</code></td><td> </td></tr><tr><td>非短路异或</td><td><code class="literal">^</code></td><td> </td></tr><tr><td>非短路包含或</td><td><code class="literal">|</code></td><td> </td></tr><tr><td>逻辑与</td><td><code class="literal">&&</code></td><td> </td></tr><tr><td>逻辑或</td><td><code class="literal">||</code></td><td> </td></tr><tr><td>三元</td><td><code class="literal">? :</code></td><td> </td></tr><tr><td>逗号分隔且</td><td><code class="literal">,</code></td><td>不正常的Java语义</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="8.8.3.4。位置参数"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10412"></a> 8.8.3.4。位置参数</h4></div></div></div><p>模式现在支持类型声明中的位置参数。</p><p>位置参数是不需要指定字段名称的参数，因为位置映射到已知的命名字段。即，Person（name ==“ mark”）可以重写为Person（“ mark”;）。分号“;”重要的是，引擎必须知道位置之前的所有内容。否则，我们可能会假定它是一个布尔表达式，这就是在分号之后如何解释它的方式。您可以使用分号“;”在模式上混合位置参数和命名参数分开他们。位置中尚未绑定的任何变量都将绑定到映射到该位置的字段。</p><pre><code class="no-highlight">declare Cheese
    name : String
    shop : String
    price : int
end
</code></pre><p>示例模式，具有两个约束和一个绑定。记住分号“;”用于区分位置部分和命名参数部分。位置参数支持变量，文字和仅使用文字的表达式，但不支持变量。位置参数始终使用统一解析。</p><pre><code class="no-highlight">Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
</code></pre><p>预先声明了绑定的位置参数将限制使用统一参数；这些被称为输入参数。如果绑定尚不存在，它将创建将其绑定到position参数表示的字段的声明；这些被称为输出参数。</p></div><div class="section" title="8.8.3.5。细粒度的属性更改侦听器"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10427"></a> 8.8.3.5。细粒度的属性更改侦听器</h4></div></div></div><p>当您在给定对象上调用modify（）（请参见modify语句部分）时，它将触发对知识库中匹配对象类型的所有模式的重新评估。这可能会导致不必要和无用的评估，并且在最坏的情况下可能导致无限递归。避免这种情况的唯一解决方法是将您的对象拆分为与原始对象具有一对一关系的较小对象。</p><p>此功能允许模式匹配仅对给定模式内部实际约束或绑定的属性的修改作出反应。这将有助于性能和递归，并避免人为对象分裂。</p><p>默认情况下，此功能是关闭的，以使规则引擎的行为与以前的版本向后兼容。如果要在特定的Bean上激活它，则必须使用@propertyReactive对其进行注释。此注释对DRL类型声明均适用：</p><pre><code class="no-highlight">declare Person
@propertyReactive
    firstName : String
    lastName : String
end</code></pre><p>在Java类上：</p><pre><code class="no-highlight">@PropertyReactive
    public static class Person {
    private String firstName;
    private String lastName;
}</code></pre><p>例如，以这种方式，如果您具有如下规则：</p><pre><code class="no-highlight">rule "Every person named Mario is a male" when
    $person : Person( firstName == "Mario" )
then
    modify ( $person )  { setMale( true ) }
end</code></pre><p>您无需在其中添加no-loop属性来避免无限递归，因为引擎会识别出在“ firstName”属性上进行了模式匹配，而规则的RHS修改了“ male”属性。请注意，此功能不适用于update（），这是我们推广Modify（）的原因之一，因为它将字段更改封装在语句内。此外，在Java类上，您还可以注释任何方法，以说其调用实际上会修改其他属性。例如，在以前的Person类中，您可以使用类似以下的方法：</p><pre><code class="no-highlight">@Modifies( { "firstName", "lastName" } )
public void setName(String name) {
    String[] names = name.split("\\s");
    this.firstName = names[0];
    this.lastName = names[1];
}</code></pre><p>这意味着如果规则具有如下RHS：</p><pre><code class="no-highlight">modify($person) { setName("Mario Fusco") }</code></pre><p>它会正确地识别出属性“ firstName”和“ lastName”的值都可能已被修改并采取相应的行动，而不会丢失重新评估约束在其上的模式的信息。目前，不允许在字段上使用@Modify，而只能在方法上使用。这与最常见的情况一致，在该情况下，@ Modify将用于与类字段无关的方法，如前一个示例中的Person.setName（）所示。还要注意，@Modify不是可传递的，这意味着，如果另一种方法内部调用Person.setName（），则用@Modify（{“ name”}）对其进行注释是不够的，但是必须使用@即使在它上面也要修改（{“ firstName”，“ lastName”}）。@Modified可传递性很有可能在下一个版本中实现。</p><p>出于嵌套访问器的考虑，仅针对顶级字段通知引擎。换句话说，模式匹配如下：</p><pre><code class="no-highlight">Person ( address.city.name == "London ) </code></pre><p>将仅在修改Person对象的'address'属性时重新评估。以同样的方式，约束分析目前严格限于模式内的内容。另一个示例可以帮助阐明这一点。类似于以下的LHS：</p><pre><code class="no-highlight">$p : Person( )
Car( owner = $p.name )</code></pre><p>不会听取此人姓名的修改，而此操作会：</p><pre><code class="no-highlight">Person( $name : name )
Car( owner = $name )</code></pre><p>为了克服这个问题，可以使用@watch注释一个模式，如下所示：</p><pre><code class="no-highlight">$p : Person( ) @watch ( name )
Car( owner = $p.name )</code></pre><p>的确，使用@watch注释模式可让您修改该模式将对其做出反应的推断属性集。请注意，@ watch批注中命名的属性实际上已添加到自动推断的属性中，但是也可以显式排除其中一个或多个属性，其名称前带有!！并使模式分别使用wildcrds *和！来监听模式中使用的类型的全部或全部属性。*。因此，例如，您可以在LHS中注释规则的模式，例如：</p><pre><code class="no-highlight">// listens for changes on both firstName (inferred) and lastName
Person( firstName == $expectedFirstName ) @watch( lastName )

// listens for all the properties of the Person bean
Person( firstName == $expectedFirstName ) @watch( * )

// listens for changes on lastName and explicitly exclude firstName
Person( firstName == $expectedFirstName ) @watch( lastName, !firstName )

// listens for changes on all the properties except the age one
Person( firstName == $expectedFirstName ) @watch( *, !age )</code></pre><p>由于在没有使用@PropertyReactive注释的类型的模式上使用此注释没有意义，因此如果尝试这样做，规则编译器将引发编译错误。还有@watch中相同属性的重复用法（例如，类似：@watch（firstName，！firstName））将最终导致编译错误。在下一个发行版中，我们将通过甚至在模式之外进行分析来使要侦听的属性的自动检测更加智能。</p><p>默认情况下，还可以在模型的所有类型上启用此功能，或者通过使用KnowledgeBuilderConfiguration的on选项完全禁用此功能。特别是，此新PropertySpecificOption可以具有以下3个值之一：</p><pre><code class="no-highlight">- DISABLED =&gt; the feature is turned off and all the other related annotations are just ignored
- ALLOWED =&gt; this is the default behavior: types are not property reactive unless they are not annotated with @PropertySpecific
- ALWAYS =&gt; all types are property reactive by default</code></pre><p>因此，例如，要使KnowledgeBuilder默认情况下生成属性反应类型，您可以执行以下操作：</p><pre><code class="no-highlight">KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
config.setOption(PropertySpecificOption.ALWAYS);
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);</code></pre><p>在这最后一种情况下，可以通过使用@ClassReactive对其进行注释来禁用特定类型的属性反应性功能。</p></div><div class="section" title="8.8.3.6。基本条件要素"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10488"></a> 8.8.3.6。基本条件要素</h4></div></div></div><div class="section" title="8.8.3.6.1。条件元素和"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10491"></a> 8.8.3.6.1。条件元素<code class="literal">and</code></h5></div></div></div><p>条件元素<code class="literal">"and"</code>用于将其他条件元素分组为逻辑合取。Drools支持两个前缀<code class="literal">and</code>和中缀<code class="literal">and</code> 。</p><div class="figure"><a id="d0e10507"></a><p class="title"><strong>图8.18。 infixAnd</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/infixAnd.png" align="middle" alt="infixAnd"></div></div></div><br class="figure-break"><p>传统中缀<code class="literal">and</code>支持：</p><pre><code class="no-highlight">//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</code></pre><p>还支持带括号的显式分组：</p><pre><code class="no-highlight">//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>符号<code class="literal">&&</code> （作为替代<code class="literal">and</code> ）已弃用。但语法仍支持向后兼容。</p></div><div class="figure"><a id="d0e10533"></a><p class="title"><strong>图8.19。 prefixAnd</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/prefixAnd.png" align="middle" alt="prefixAnd"></div></div></div><br class="figure-break"><p>字首<code class="literal">and</code>还受支持：</p><pre><code class="no-highlight">(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )</code></pre><p>LHS的根元素是隐式前缀<code class="literal">and</code>不需要指定：</p><div class="example"><a id="d0e10551"></a><p class="title"><strong>示例8.74隐式根前缀And</strong></p><div class="example-contents"><pre><code class="no-highlight">when
    Cheese( cheeseType : type )
    Person( favouriteCheese == cheeseType )
then
    ...</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.6.2。条件元素或"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10556"></a> 8.8.3.6.2。条件元素<code class="literal">or</code></h5></div></div></div><p>条件元素<code class="literal">or</code>用于将其他条件元素分组为逻辑分离。Drools支持两个前缀<code class="literal">or</code>和中缀<code class="literal">or</code> 。</p><div class="figure"><a id="d0e10572"></a><p class="title"><strong>图8.20。 infixOr</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/infixOr.png" align="middle" alt="infixOr"></div></div></div><br class="figure-break"><p>传统中缀<code class="literal">or</code>支持：</p><pre><code class="no-highlight">//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )</code></pre><p>还支持带括号的显式分组：</p><pre><code class="no-highlight">//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>符号<code class="literal">||</code> （作为替代<code class="literal">or</code> ）已弃用。但语法仍支持向后兼容。</p></div><div class="figure"><a id="d0e10598"></a><p class="title"><strong>图8.21。 prefixOr</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/prefixOr.png" align="middle" alt="prefixOr"></div></div></div><br class="figure-break"><p>字首<code class="literal">or</code>还受支持：</p><pre><code class="no-highlight">(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>条件元素的行为<code class="literal">or</code>与结语不同<code class="literal">||</code>对于约束和字段约束的约束。引擎实际上不了解条件元素<code class="literal">or</code> 。相反，通过许多不同的逻辑转换， <code class="literal">or</code>被重写为许多子规则。此过程最终导致一条规则具有单个<code class="literal">or</code>作为其每个CE的根节点和一个子规则。每个子规则都可以像任何正常规则一样激活和触发；这些子规则之间没有特殊的行为或相互作用。 -这可能会使新规则作者感到困惑。</p></div><p>条件元素<code class="literal">or</code>还允许可选的模式绑定。这意味着每个结果子规则会将其模式绑定到模式绑定。每个模式必须使用同义变量分别绑定：</p><pre><code class="no-highlight">pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</code></pre><pre><code class="no-highlight">(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</code></pre><p>由于条件元素<code class="literal">or</code>结果产生多个子规则，每个可能的逻辑结果一个，上面的示例将内部产生两个规则。这两个规则在工作记忆中独立工作，这意味着它们都可以匹配，激活和触发-没有捷径。</p><p>考虑条件要素的最佳方法<code class="literal">or</code>是生成两个或更多相似规则的捷径。当您以这种方式考虑时，很明显，如果两个或多个析取项为真，则对于单个规则可能会有多个激活。</p></div><div class="section" title="8.8.3.6.3。没有条件元素"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10648"></a> 8.8.3.6.3。条件元素<code class="literal">not</code></h5></div></div></div><div class="figure"><a id="d0e10653"></a><p class="title"><strong>图8.22。不</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/not.png" align="middle" alt="不"></div></div></div><br class="figure-break"><p>行政长官<code class="literal">not</code>是一阶逻辑的不存在量词，用于检查工作内存中是否存在某物。将“ not”理解为“必须不存在...”。</p><p>关键字<code class="literal">not</code>可能会在适用的CE后面加上括号。在单个模式的最简单情况下（如下所示），您可以选择省略括号。</p><div class="example"><a id="d0e10669"></a><p class="title"><strong>示例8.75没有巴士</strong></p><div class="example-contents"><pre><code class="no-highlight">not Bus()</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e10674"></a><p class="title"><strong>示例8.76没有红色巴士</strong></p><div class="example-contents"><pre><code class="no-highlight">// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix <code class="literal">and</code> - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )</code></pre></div></div><br class="example-break"></div><div class="section" title="8.8.3.6.4。条件元素存在"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10682"></a> 8.8.3.6.4。条件元素<code class="literal">exists</code></h5></div></div></div><div class="figure"><a id="d0e10687"></a><p class="title"><strong>图8.23。存在</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/exists.png" align="middle" alt="存在"></div></div></div><br class="figure-break"><p>行政长官<code class="literal">exists</code>是一阶逻辑的存在量词，用于检查工作内存中是否存在某些内容。认为“存在”是指“至少有一个..”。它与仅拥有模式不同，后者更像是说“针对……中的每一个”。如果您使用<code class="literal">exists</code>如果使用模式，则该规则最多只会激活一次，无论工作内存中有多少数据与内部条件相匹配<code class="literal">exists</code>图案。由于仅存在很重要，因此不会建立任何绑定。</p><p>关键字<code class="literal">exists</code>必须在适用的CE后面加上括号。在单个模式的最简单情况下（如下所示），您可以省略括号。</p><div class="example"><a id="d0e10709"></a><p class="title"><strong>示例8.77至少一辆巴士</strong></p><div class="example-contents"><pre><code class="no-highlight">exists Bus()</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e10714"></a><p class="title"><strong>示例8.78至少一辆红色巴士</strong></p><div class="example-contents"><pre><code class="no-highlight">exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix <code class="literal">and</code>,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )</code></pre></div></div><br class="example-break"></div></div><div class="section" title="8.8.3.7。高级条件元素"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10722"></a> 8.8.3.7。高级条件元素</h4></div></div></div><div class="section" title="8.8.3.7.1。全部条件元素"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10725"></a> 8.8.3.7.1。条件元素<code class="literal">forall</code></h5></div></div></div><div class="figure"><a id="d0e10730"></a><p class="title"><strong>图8.24。对所有人</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/forall.png" align="middle" alt="对所有人"></div></div></div><br class="figure-break"><p>条件元素<code class="literal">forall</code>完成了Drools中的一阶逻辑支持。条件元素<code class="literal">forall</code>当与第一个模式匹配的所有事实与所有其余模式匹配时，计算结果为true。例：</p><pre><code class="no-highlight">rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    // all English buses are red
end</code></pre><p>在上述规则中，我们“选择”所有类型为“英语”的Bus对象。然后，对于与该模式匹配的每个事实，我们将评估以下模式，如果它们匹配，则所有CE都将评估为true。</p><p>要声明工作内存中给定类型的所有事实都必须与一组约束匹配， <code class="literal">forall</code>为了简单起见，可以用单个模式编写。例：</p><div class="example"><a id="d0e10753"></a><p class="title"><strong>示例8.79单一模式</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    // all Bus facts are red
end</code></pre></div></div><br class="example-break"><p>另一个示例显示了<code class="literal">forall</code> ：</p><div class="example"><a id="d0e10763"></a><p class="title"><strong>示例8.80多模式</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    // all employees have health and dental care
end</code></pre></div></div><br class="example-break"><p>Forall可以嵌套在其他CE中。例如， <code class="literal">forall</code>可以在内部使用<code class="literal">not</code> CE。请注意，只有单个模式具有可选的括号，因此带有嵌套<code class="literal">forall</code>必须使用括号：</p><div class="example"><a id="d0e10779"></a><p class="title"><strong>示例8.81将Forall与Not CE相结合</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    // not all employees have health and dental care
end</code></pre></div></div><br class="example-break"><p>作为旁注， <code class="code">forall( p1 p2 p3...)</code>等同于写作：</p><pre><code class="no-highlight">not(p1 and not(and p2 p3...))</code></pre><p>另外，请务必注意<code class="literal">forall</code>是<span class="emphasis"><em>范围定界符</em></span> 。因此，它可以使用任何先前绑定的变量，但是在其内部没有绑定的变量将无法在其外部使用。</p></div><div class="section" title="8.8.3.7.2。来自的条件元素"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10799"></a> 8.8.3.7.2。条件元素<code class="literal">from</code></h5></div></div></div><div class="figure"><a id="d0e10804"></a><p class="title"><strong>图8.25。从</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/from.png" align="middle" alt="从"></div></div></div><br class="figure-break"><p>条件元素<code class="literal">from</code>使用户能够为LHS模式匹配的数据指定任意来源。这使引擎可以推理不在工作内存中的数据。数据源可以是绑定变量上的子字段，也可以是方法调用的结果。它是一种强大的结构，可以与其他应用程序组件和框架进行现成的集成。一个常见的示例是与使用休眠命名查询从数据库按需检索的数据集成。</p><p>用于定义对象源的表达式是遵循常规MVEL语法的任何表达式。因此，它使您可以轻松地使用对象属性导航，执行方法调用以及访问映射和集合元素。</p><p>这是在另一个模式子字段上进行推理和绑定的简单示例：</p><pre><code class="no-highlight">rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    // zip code is ok
end</code></pre><p>凭借Drools引擎新的表现力所带来的全部灵活性，您可以通过多种方式将这个问题切成小方块。这是相同的，但是显示了如何在'from'中使用图形符号：</p><pre><code class="no-highlight">rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    // zip code is ok
end</code></pre><p>先前的示例是使用单个模式的评估。行政长官<code class="literal">from</code>还支持返回对象集合的对象源。在这种情况下， <code class="literal">from</code>将遍历集合中的所有对象，并尝试分别匹配每个对象。例如，如果我们想要一个对订单中的每个商品应用10％折扣的规则，我们可以这样做：</p><pre><code class="no-highlight">rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    // apply discount to $item
end</code></pre><p>上面的示例将使规则针对每个给定订单的值大于100的每个商品触发一次。</p><p>但是，使用时必须小心<code class="literal">from</code> ，尤其是与<code class="literal">lock-on-active</code>规则属性，因为它可能会产生意外的结果。考虑前面提供的示例，但现在进行了如下修改：</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} // Apply discount to person in a modify block
end</code></pre><p>在上面的示例中，应将北卡罗来纳州罗利市的人员分配到销售区域1并获得折扣；也就是说，您希望这两个规则都可以激活并触发。相反，您会发现只有第二条规则触发。</p><p>如果要打开审核日志，则还会看到第二条规则触发时，它会停用第一条规则。由于规则属性<code class="literal">lock-on-active</code>防止一组事实发生变化时规则创建新的激活，第一个规则无法重新激活。尽管事实没有改变，但使用<code class="literal">from</code>每次评估时都会出于所有意图和目的返回一个新事实。</p><p>首先，回顾为什么要使用上述模式很重要。您可能在不同的规则流组中有许多规则。当规则修改工作记忆并且需要重新评估RuleFlow下游（在不同规则流组中）的其他规则时，使用<code class="literal">modify</code>至关重要。但是，您不希望同一规则流组中的其他规则将激活递归地放置在一起。在这种情况下， <code class="literal">no-loop</code>属性无效，因为它只会阻止规则递归激活自身。因此，您诉诸<code class="literal">lock-on-active</code> 。</p><p>有几种方法可以解决此问题：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>避免使用<code class="literal">from</code>您可以将所有事实断言到工作内存中，或者在约束表达式中使用嵌套的对象引用（如下所示）。</p></li><li class="listitem"><p>将在修改块中使用的已分配变量放在条件（LHS）中的最后一句。</p></li><li class="listitem"><p>避免使用<code class="literal">lock-on-active</code>您可以显式管理同一规则流组中的规则如何相互激活（如下所述）。</p></li></ul></div><p>首选解决方案是尽量减少使用<code class="literal">from</code>您可以将所有事实直接声明到工作记忆中。在上面的示例中，可以将Person和Address实例声明为工作内存。在这种情况下，因为图形非常简单，所以一个更简单的解决方案是按如下所示修改规则：</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} //Apply discount to person in a modify block
end</code></pre><p>现在，您将发现这两个规则均按预期启动。但是，并非总是能够如上所述访问嵌套事实。考虑一个示例，其中一个人拥有一个或多个地址，并且您希望使用一个存在量词来匹配具有至少一个满足某些条件的地址的人。在这种情况下，您将不得不诉诸于<code class="literal">from</code>对收集进行推理。</p><p>有几种使用方法<code class="literal">from</code>为了实现这一目标，并非所有人都在使用<code class="literal">lock-on-active</code> 。例如下面的用法<code class="literal">from</code>导致两个规则均按预期触发：</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} // Apply discount to person in a modify block
end</code></pre><p>但是，以下略有不同的方法确实会出现此问题：</p><pre><code class="no-highlight">rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} // Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} // Modify assessment in a modify block
end</code></pre><p>在上面的示例中，$ addresses变量是通过使用返回的<code class="literal">from</code> 。该示例还引入了一个新的评估对象，以突出显示这种情况下的一种可能解决方案。如果将条件（LHS）中分配的$ assessment变量移到每个规则中的最后一个条件，则两个规则均会按预期触发。</p><p>尽管以上示例演示了如何结合使用<code class="literal">from</code>与<code class="literal">lock-on-active</code>在没有丢失规则激活的情况下，它们的缺点是依赖于LHS的条件顺序。另外，就跟踪哪些条件可能产生问题而言，解决方案为规则作者带来了更大的复杂性。</p><p>更好的选择是将更多事实断言保存在工作记忆中。在这种情况下，可以将一个人的地址声明为工作记忆并使用<code class="literal">from</code>没必要。</p><p>但是，在某些情况下，将所有数据声明到工作内存中是不切实际的，我们需要找到其他解决方案。另一种选择是重新评估<code class="literal">lock-on-active</code> 。的替代品<code class="literal">lock-on-active</code>通过在每个规则中包含防止修改工作存储器时规则相互递归激活的条件，来直接管理同一规则流组中的规则如何相互激活。例如，在以上将折扣应用于罗利公民的情况下，可以将条件添加到检查折扣是否已经被应用的规则中。如果是这样，则规则不会激活。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>包含from子句的模式不能跟随以括号开头的另一模式，如以下示例所示</p><pre><code class="no-highlight">rule R when
    $l : List( )
    String() from $l
    (String() or Number())
then end</code></pre><p>这是因为在这种情况下，DRL解析器将from表达式读取为<code class="literal">from $l (String() or Number())</code>并且无法从函数调用中消除此表达式的歧义。对此的直接解决方案是将from子句也包装在括号中，如下所示：</p><pre><code class="no-highlight">rule R when
    $l : List( )
    (String() from $l)
    (String() or Number())
then end</code></pre></div></div><div class="section" title="8.8.3.7.3。条件元素收集"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10953"></a> 8.8.3.7.3。条件元素<code class="literal">collect</code></h5></div></div></div><div class="figure"><a id="d0e10958"></a><p class="title"><strong>图8.26。搜集</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/collect.png" align="middle" alt="搜集"></div></div></div><br class="figure-break"><p>条件元素<code class="literal">collect</code>允许规则对从给定源或工作内存中获得的对象集合进行推理。用第一阶逻辑的术语来说，这是基数量词。一个简单的例子：</p><pre><code class="no-highlight">import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    // Raise priority, because system $system has
    // 3 or more alarms pending. The pending alarms
    // are $alarms.
end</code></pre><p>在上面的示例中，规则将在每个给定系统的工作内存中查找所有待处理的警报，并将它们分组在ArrayLists中。如果为给定系统找到3个或更多警报，该规则将触发。</p><p>的结果模式<code class="literal">collect</code>可以是实现<code class="code">java.util.Collection</code>接口并提供默认的无参数公共构造函数。这意味着您可以使用ArrayList，LinkedList，HashSet等Java集合或您自己的类，只要它实现了<code class="code">java.util.Collection</code>接口并提供默认的无参数公共构造函数。</p><p>源和结果模式都可以像其他任何模式一样受到约束。</p><p>变量绑定在<code class="literal">collect</code> CE属于源模式和结果模式，因此可以使用它们来约束源模式和结果模式。但请注意<code class="literal">collect</code>是绑定的范围定界符，因此在其内部进行的任何绑定都不能在其外部使用。</p><p>收集接受嵌套<code class="literal">from</code> CE。以下示例是对“ collect”的有效使用：</p><pre><code class="no-highlight">import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    // send a message to all mothers
end</code></pre></div><div class="section" title="8.8.3.7.4。条件元素累积"><div class="titlepage"><div><div><h5 class="title"><a id="d0e11001"></a> 8.8.3.7.4。条件元素<code class="literal">accumulate</code></h5></div></div></div><div class="figure"><a id="d0e11006"></a><p class="title"><strong>图8.27。积累</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/accumulate.png" align="middle" alt="积累"></div></div></div><br class="figure-break"><p>条件元素<code class="literal">accumulate</code>是一种更灵活，更强大的形式<code class="literal">collect</code>在某种意义上说，它可以用来做什么<code class="literal">collect</code>确实并且取得了CE的成果<code class="literal">collect</code>无法实现。累积允许规则迭代对象的集合，对每个元素执行自定义操作，最后，它返回结果对象。</p><p>累积支持使用预定义的累积函数或内联自定义代码。但是，应避免使用内联自定义代码，因为规则创建者难以维护它，并且经常导致代码重复。累积功能更易于测试和重用。</p><p>累积CE还支持多种不同的语法。如下面所述，首选语法是顶层累加，但是为了向后兼容，还支持所有其他语法。</p><div class="section" title="8.8.3.7.4.1。积累CE（首选语法）"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11030"></a> 8.8.3.7.4.1。积累CE（首选语法）</h6></div></div></div><p>最高级别的累积语法是最紧凑和最灵活的语法。简化语法如下：</p><pre><code class="no-highlight"><code class="literal">accumulate( </code><em class="replaceable"><code>&lt;source pattern&gt;</code></em><code class="literal">; </code><em class="replaceable"><code>&lt;functions&gt;</code></em><code class="literal"> [;</code><em class="replaceable"><code>&lt;constraints&gt;</code></em><code class="literal">] )</code>
</code></pre><p>例如，可以使用以下方式使用“累计”以以下方式编写一条规则：计算给定传感器的最小，最大和平均温度读数，如果最低温度低于20C度且平均值超过70C度，则会发出警报。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>DRL语言定义了“ <code class="code">acc</code> “作为”的同义词<code class="code">accumulate</code> ”。作者可能更喜欢使用“ <code class="code">acc</code> “作为不太冗长的关键字或完整关键字” <code class="code">accumulate</code>为清晰起见。</p></div><pre><code class="no-highlight">rule "Raise alarm"
when
    $s : Sensor()
    accumulate( Reading( sensor == $s, $temp : temperature );
                $min : min( $temp ),
                $max : max( $temp ),
                $avg : average( $temp );
                $min &lt; 20, $avg &gt; 70 )
then
    // raise the alarm
end</code></pre><p>在上面的示例中，最小值，最大值和平均值是“累积函数”，将针对每个传感器的所有读数计算最小，最大和平均温度值。</p><p>Drools附带了几个内置的累加功能，包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>平均</p></li><li class="listitem"><p>分</p></li><li class="listitem"><p>最高</p></li><li class="listitem"><p>计数</p></li><li class="listitem"><p>和</p></li><li class="listitem"><p>collectList</p></li><li class="listitem"><p>collectSet</p></li></ul></div><p>这些通用函数接受任何表达式作为输入。例如，如果某人想要计算订单所有项目的平均利润，则可以使用平均值函数编写一条规则：</p><pre><code class="no-highlight">rule "Average profit"
when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
then
    // average profit for $order is $avgProfit
end</code></pre><p>累计功能都是可插拔的。这意味着，如果需要，可以轻松地将自定义的，特定于域的功能添加到引擎中，并且规则可以不受任何限制地开始使用它们。要实现新的“累积函数”，所有需要做的就是创建一个Java类，该类实现<code class="code">org.drools.core.runtime.rule.TypedAccumulateFunction</code>接口。作为“累积函数”实现的示例，以下是<code class="literal">average</code>功能：</p><pre><code class="language-java">/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements org.drools.core.runtime.rule.TypedAccumulateFunction {

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public static class AverageData implements Externalizable {
        public int    count = 0;
        public double total = 0;

        public AverageData() {}

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            count   = in.readInt();
            total   = in.readDouble();
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(count);
            out.writeDouble(total);
        }

    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Serializable createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object)
     */
    public void accumulate(Serializable context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object)
     */
    public void reverse(Serializable context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.core.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

    /**
     * {@inheritDoc}
     */
    public Class&lt; ? &gt; getResultType() {
        return Number.class;
    }

}
</code></pre><p>如我们所料，该函数的代码非常简单，因为所有“脏”集成工作都是由引擎完成的。最后，要在规则中使用该函数，作者可以使用“导入累积”语句将其导入：</p><pre><code class="no-highlight">import accumulate &lt;class_name&gt; &lt;function_name&gt;</code></pre><p>例如，如果实现该类<code class="code">some.package.VarianceFunction</code>实现<code class="code">variance</code>功能并想在规则中使用它，他将执行以下操作：</p><div class="example"><a id="d0e11122"></a><p class="title"><strong>示例8.82导入和使用自定义“ <code class="code">variance</code>累计功能</strong></p><div class="example-contents"><pre><code class="no-highlight"><span class="bold"><strong>import accumulate</strong></span> some.package.VarianceFunction variance

<span class="bold"><strong>rule</strong></span> "Calculate Variance"
<span class="bold"><strong>when</strong></span>
    <span class="bold"><strong>accumulate</strong></span>( Test( $s : score ), $v : variance( $s ) )
<span class="bold"><strong>then</strong></span>
    <span class="italic">// the variance of the test scores is $v</span>
<span class="bold"><strong>end</strong></span></code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>引擎会自动导入内置函数（求和，平均值等）。只需要显式导入用户定义的自定义累加函数。</p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>为了向后兼容，Drools仍支持通过配置文件和系统属性配置累加函数，但这是不建议使用的方法。为了使用配置文件或系统属性来配置上一个示例中的方差函数，用户可以设置如下属性：</p><pre><code class="no-highlight">drools.accumulate.function.variance = some.package.VarianceFunction</code></pre><p>请注意，“ <code class="code">drools.accumulate.function.</code> “是必须始终使用的前缀，” <code class="code">variance</code> “是如何在drl文件中使用该功能，以及“ <code class="code">some.package.VarianceFunction</code> “是实现函数行为的类的标准名称。</p></div></div><div class="section" title="8.8.3.7.4.2。备用语法：具有返回类型的单个函数"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11168"></a> 8.8.3.7.4.2。备用语法：具有返回类型的单个函数</h6></div></div></div><p>累积语法随着时间的推移而发展，目的是变得更加紧凑和富有表现力。尽管如此，Drools仍支持以前的语法以实现向后兼容。</p><p>如果规则在给定的累加上使用单个累加函数，则作者可以为结果对象添加一个模式，并使用“ from”关键字将其链接到累加结果。示例：对订单金额超过100美元的商品应用10％折扣的规则可以通过以下方式编写：</p><pre><code class="no-highlight">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    // apply discount to $order
end</code></pre><p>在上面的示例中，accumulate元素仅使用一个函数（求和），因此规则创建者选择为accumulate函数（Number）的结果类型显式编写一个模式，并在其中写入约束。与以前介绍的紧凑语法相比，使用此语法没有任何问题，除了稍微冗长一些。还要注意，不允许在同一累积语句中同时使用返回类型和绑定的函数。</p><p>进行编译时检查是为了确保与“ from”关键字一起使用的模式可以从所使用的累加函数的结果中分配出来。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>使用这种语法，“ <code class="code">from</code> ”绑定到accumulate函数返回的单个结果，并且不会迭代。
           </p></div><p>在上面的示例中， <code class="code">$total</code> ”绑定到累加器返回的结果<code class="code">sum()</code>功能。</p><p>但是，作为另一个示例，如果accumulate函数的结果是一个集合，则“ <code class="code">from</code> ”仍绑定到单个结果，并且不会迭代：</p><pre><code class="no-highlight">rule "Person names"
when
  $x : Object() from accumulate(MyPerson( $val : name ); 
                                collectList( $val ) )
then
  // $x is a List
end</code></pre><p>绑定的“ <code class="code">$x : Object()</code> ”是列表本身，由<code class="code">collectList</code>累积使用的函数。
           </p><p>这是需要强调的重要区别，因为<code class="code">from</code>关键字也可以单独使用<code class="code">accumulate</code> ，以遍历集合的元素：</p><pre><code class="no-highlight">rule "Iterate the numbers"
when
    $xs : List()
    $x : Integer() from $xs
then
  // $x matches and binds to each Integer in the collection
end</code></pre><p>
           </p><p>尽管出于向后兼容的目的仍支持此语法，但是出于此原因和其他原因，我们鼓励规则作者使用而不是Accumulate CE首选语法（在上一章中进行了描述），从而避免了潜在的陷阱，如这些示例所述。 。
           </p></div><div class="section" title="8.8.3.7.4.3。内联自定义代码"><div class="titlepage"><div><div><h6 class="title"><a id="d0e11222"></a> 8.8.3.7.4.3。内联自定义代码</h6></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>内联自定义代码的累加使用不是一个好习惯，这有几个原因，包括难以维护和测试使用它们的规则，以及无法重用该代码。实现自己的累加函数非常简单明了，易于单元测试和使用。仅支持向后兼容的这种形式的累加。</p></div><p>累加的另一种可能语法是定义内联自定义代码，而不是使用累加函数。如前所述，尽管出于上述原因，我们不建议这样做。</p><p>的一般语法<code class="literal">accumulate</code>具有内联定制代码的CE是：</p><pre><code class="no-highlight"><em class="replaceable"><code>&lt;result pattern&gt;</code></em> <code class="literal">from accumulate(</code> <em class="replaceable"><code>&lt;source pattern&gt;</code></em><code class="literal">,</code>
                                  <code class="literal">init(</code> <em class="replaceable"><code>&lt;init code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">action(</code> <em class="replaceable"><code>&lt;action code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">reverse(</code> <em class="replaceable"><code>&lt;reverse code&gt;</code></em> <code class="literal">),</code>
                                  <code class="literal">result(</code> <em class="replaceable"><code>&lt;result expression&gt;</code></em> <code class="literal">) )</code>
</code></pre><p>每个元素的含义如下：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em><source pattern=""></em></span> ：源模式是引擎将尝试与每个源对象匹配的常规模式。</p></li><li class="listitem"><p><span class="emphasis"><em><init></init></em></span> ：这是所选方言中的语义代码块，在遍历源对象之前，将对每个元组执行一次。</p></li><li class="listitem"><p><span class="emphasis"><em><action></action></em></span> ：这是所选方言中的语义代码块，将为每个源对象执行。</p></li><li class="listitem"><p><span class="emphasis"><em><reverse></reverse></em></span> ：这是所选方言中的一个可选语义代码块，如果存在，将为与该源模式不再匹配的每个源对象执行该代码块。该代码块的目的是撤销在<span class="emphasis"><em><action></action></em></span>块，以便引擎可以在修改或删除源对象时进行减量计算，从而极大地提高了这些操作的性能。</p></li><li class="listitem"><p><span class="emphasis"><em><result expression=""></result></em></span> ：这是所选方言中的语义表达式，在所有源对象都经过迭代之后执行。</p></li><li class="listitem"><p><span class="emphasis"><em><result pattern=""></result></em></span> ：这是一种常规模式，引擎会尝试将其与从中返回的对象进行匹配<span class="emphasis"><em><result expression=""></result></em></span> 。如果匹配，则<code class="literal">accumulate</code>条件元素的评估结果为<span class="emphasis"><em>true</em></span> ，引擎将继续评估规则中的下一个CE。如果不匹配，则<code class="literal">accumulate</code> CE评估为<span class="emphasis"><em>假</em></span> ，引擎停止评估该规则的CE。</p></li></ul></div><p>如果看一个例子，更容易理解：</p><pre><code class="no-highlight">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    // apply discount to $order
end</code></pre><p>在上面的示例中，对于每个<code class="code">Order</code>在工作内存中，引擎将执行<span class="emphasis"><em>初始化代码，</em></span>将总变量初始化为零。然后它将遍历所有对象<code class="code">OrderItem</code>顺序的对象，对每个对象执行该<span class="emphasis"><em>操作</em></span> （在示例中，它将所有项目的值加到total变量中）。遍历所有之后<code class="code">OrderItem</code>对象，它将返回与<span class="emphasis"><em>结果表达式</em></span>相对应的值（在上面的示例中，变量的值<code class="code">total</code> ）。最后，引擎将尝试将结果与<code class="code">Number</code>模式，如果double值大于100，则规则将触发。</p><p>该示例使用Java作为语义方言，因此，请注意在初始化，操作和反向代码块中，必须使用分号作为语句定界符。结果是一个表达式，因此，它不接受“;”。如果用户使用任何其他方言，则他必须遵守该方言的特定语法。</p><p>如前所述， <span class="emphasis"><em>反向代码</em></span>是可选的，但是强烈建议用户编写<span class="emphasis"><em>反向代码</em></span> ，以便从<span class="emphasis"><em>update和delete</em></span>的<span class="emphasis"><em>改进性能中</em></span>受益。</p><p>的<code class="literal">accumulate</code> CE可用于对源对象执行任何操作。下面的示例实例化并填充一个自定义对象：</p><pre><code class="no-highlight">rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</code></pre></div></div></div><div class="section" title="8.8.3.8。条件元素评估"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11381"></a> 8.8.3.8。条件元素<code class="literal">eval</code></h4></div></div></div><div class="figure"><a id="d0e11386"></a><p class="title"><strong>图8.28。评估</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/eval.png" align="middle" alt="评估"></div></div></div><br class="figure-break"><p>条件元素<code class="literal">eval</code>本质上是一个包罗万象的东西，它允许执行任何语义代码（返回原始布尔值）。该代码可以引用规则的LHS中绑定的变量，以及规则包中的函数。过度使用eval会降低规则的声明性，并可能导致引擎性能下降。而<code class="literal">eval</code>可以在模式的任何地方使用，最佳实践是将其添加为规则的LHS中的最后一个条件元素。</p><p>评估无法建立索引，因此效率不如字段约束。但是，这使它们成为函数返回随时间变化的值（字段约束中不允许使用）的理想选择。</p><p>对于熟悉Drools 2.x世系的人们，旧的Drools参数和条件标记等效于将变量绑定到适当的类型，然后在eval节点中使用它。</p><pre><code class="no-highlight">p1 : Parameter()
p2 : Parameter()
eval( p1.getList().containsKey( p2.getItem() ) )</code></pre><pre><code class="no-highlight">p1 : Parameter()
p2 : Parameter()
// call function isValid in the LHS
eval( isValid( p1, p2 ) )</code></pre></div><div class="section" title="8.8.3.9。铁路图"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11408"></a> 8.8.3.9。铁路图</h4></div></div></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateAction.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateClause.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateFunction.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateInit.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateResult.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateReverse.png"></div><div class="mediaobject"><img src="images/LanguageReference/AccumulateSteps.png"></div><div class="mediaobject"><img src="images/LanguageReference/Accumulations.png"></div><div class="mediaobject"><img src="images/LanguageReference/AdditiveExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/Annotation.png"></div><div class="mediaobject"><img src="images/LanguageReference/Arguments.png"></div><div class="mediaobject"><img src="images/LanguageReference/ArrayCreatorRest.png"></div><div class="mediaobject"><img src="images/LanguageReference/ArrayInitializer.png"></div><div class="mediaobject"><img src="images/LanguageReference/AssignmentOperator.png"></div><div class="mediaobject"><img src="images/LanguageReference/BindingPattern.png"></div><div class="mediaobject"><img src="images/LanguageReference/Block.png"></div><div class="mediaobject"><img src="images/LanguageReference/BooleanLiteral.png"></div><div class="mediaobject"><img src="images/LanguageReference/CompilationUnit.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalAnd.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementAccumulate.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementEval.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementExists.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementForall.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElementNot.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalElement.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalOrExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/ConditionalOr.png"></div><div class="mediaobject"><img src="images/LanguageReference/Constraints.png"></div><div class="mediaobject"><img src="images/LanguageReference/CreatedName.png"></div><div class="mediaobject"><img src="images/LanguageReference/Creator.png"></div><div class="mediaobject"><img src="images/LanguageReference/Definition.png"></div><div class="mediaobject"><img src="images/LanguageReference/Digit.png"></div><div class="mediaobject"><img src="images/LanguageReference/ExplicitGenericInvocationSuffix.png"></div><div class="mediaobject"><img src="images/LanguageReference/ExplicitGenericInvocation.png"></div><div class="mediaobject"><img src="images/LanguageReference/Exponent.png"></div><div class="mediaobject"><img src="images/LanguageReference/ExpressionList.png"></div><div class="mediaobject"><img src="images/LanguageReference/Expression.png"></div><div class="mediaobject"><img src="images/LanguageReference/Field.png"></div><div class="mediaobject"><img src="images/LanguageReference/Fraction.png"></div><div class="mediaobject"><img src="images/LanguageReference/FromAccumulateClause.png"></div><div class="mediaobject"><img src="images/LanguageReference/FromClause.png"></div><div class="mediaobject"><img src="images/LanguageReference/FromCollectClause.png"></div><div class="mediaobject"><img src="images/LanguageReference/FunctionDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/GlobalDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/IdentifierSuffix.png"></div><div class="mediaobject"><img src="images/LanguageReference/ImportDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/InExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/InlineListExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/InlineMapExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/InnerCreator.png"></div><div class="mediaobject"><img src="images/LanguageReference/InstanceOfExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/IntLiteral.png"></div><div class="mediaobject"><img src="images/LanguageReference/Literal.png"></div><div class="mediaobject"><img src="images/LanguageReference/ModifyStatement.png"></div><div class="mediaobject"><img src="images/LanguageReference/NonWildcardTypeArguments.png"></div><div class="mediaobject"><img src="images/LanguageReference/OrRestriction.png"></div><div class="mediaobject"><img src="images/LanguageReference/OverClause.png"></div><div class="mediaobject"><img src="images/LanguageReference/Parameters.png"></div><div class="mediaobject"><img src="images/LanguageReference/Pattern.png"></div><div class="mediaobject"><img src="images/LanguageReference/Placeholders.png"></div><div class="mediaobject"><img src="images/LanguageReference/Primary.png"></div><div class="mediaobject"><img src="images/LanguageReference/PrimitiveType.png"></div><div class="mediaobject"><img src="images/LanguageReference/QualifiedName.png"></div><div class="mediaobject"><img src="images/LanguageReference/QueryDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/QueryOptions.png"></div><div class="mediaobject"><img src="images/LanguageReference/RealLiteral.png"></div><div class="mediaobject"><img src="images/LanguageReference/RealTypeSuffix.png"></div><div class="mediaobject"><img src="images/LanguageReference/RelationalExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/RelationalOperator.png"></div><div class="mediaobject"><img src="images/LanguageReference/RhsStatement.png"></div><div class="mediaobject"><img src="images/LanguageReference/RuleAttributes.png"></div><div class="mediaobject"><img src="images/LanguageReference/RuleAttribute.png"></div><div class="mediaobject"><img src="images/LanguageReference/RuleDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/RuleOptions.png"></div><div class="mediaobject"><img src="images/LanguageReference/Selector.png"></div><div class="mediaobject"><img src="images/LanguageReference/ShiftExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/SingleRestriction.png"></div><div class="mediaobject"><img src="images/LanguageReference/SourcePattern.png"></div><div class="mediaobject"><img src="images/LanguageReference/StringId.png"></div><div class="mediaobject"><img src="images/LanguageReference/SuperSuffix.png"></div><div class="mediaobject"><img src="images/LanguageReference/ThenPart.png"></div><div class="mediaobject"><img src="images/LanguageReference/TypeArguments.png"></div><div class="mediaobject"><img src="images/LanguageReference/TypeArgument.png"></div><div class="mediaobject"><img src="images/LanguageReference/TypeDefinition.png"></div><div class="mediaobject"><img src="images/LanguageReference/TypeOptions.png"></div><div class="mediaobject"><img src="images/LanguageReference/Type.png"></div><div class="mediaobject"><img src="images/LanguageReference/UnaryExprNotPlusMinus.png"></div><div class="mediaobject"><img src="images/LanguageReference/UnaryExpr.png"></div><div class="mediaobject"><img src="images/LanguageReference/Value.png"></div><div class="mediaobject"><img src="images/LanguageReference/VariableInitializer.png"></div><div class="mediaobject"><img src="images/LanguageReference/WhenPart.png"></div></div></div><div class="section" title="8.8.4。右侧（然后）"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11687"></a> 8.8.4。右侧（然后）</h3></div></div></div><div class="section" title="8.8.4.1。用法"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11690"></a> 8.8.4.1。用法</h4></div></div></div><p>右侧（RHS）是规则的结果或操作部分的通用名称；这部分应包含要执行的动作的列表。在规则的RHS中使用命令性代码或条件代码是一种不好的做法。通常来说，本质上应该是原子的-“何时执行此操作”，而不是“何时执行此操作”。规则的RHS部分也应保持较小，从而使其具有声明性和可读性。如果发现在RHS中需要命令性和/或条件性代码，则可能应该将该规则分解为多个规则。RHS的主要目的是插入，删除或修改工作存储器数据。为了帮助实现这一点，您可以使用一些便捷的方法来修改工作内存。无需先引用工作内存实例。</p><p><code class="literal">update(</code> <span class="emphasis"><em>对象，句柄</em></span> <code class="literal">);</code>会告诉引擎一个对象已更改（一个对象已绑定到LHS上的某个对象），并且可能需要重新考虑规则。</p><p><code class="literal">update(</code> <span class="emphasis"><em>宾语</em></span> <code class="literal">);</code>也可以使用在这里，知识帮手将通过身份检查为您查找传递的对象的事实处理。（请注意，如果您为要插入到引擎中的Java Bean提供属性更改侦听器，则可以避免调用<code class="code">update()</code>当对象更改时。）。事实的字段值更改后，必须在更改另一个事实之前调用update，否则会导致规则引擎中的索引编制出现问题。Modify关键字避免了此问题。</p><p><code class="literal">insert(new</code> <span class="emphasis"><em>东西</em></span> <code class="literal">());</code>会将您创建的新对象放入工作记忆。</p><p><code class="literal">insertLogical(new</code> <span class="emphasis"><em>东西</em></span> <code class="literal">());</code>与insert类似，但是当没有更多事实支持当前触发规则的真相时，该对象将被自动删除。</p><p><code class="literal">delete(</code> <span class="emphasis"><em>处理</em></span> <code class="literal">);</code>从工作内存中删除一个对象。</p><p>这些便利方法基本上是宏，可为<code class="code">KnowledgeHelper</code>实例，使您可以从规则文件访问工作内存。预定义变量<code class="code">drools</code>类型的<code class="code">KnowledgeHelper</code>让您调用其他几种有用的方法。（请参阅<code class="code">KnowledgeHelper</code>界面文档进行更高级的操作）。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>通话<code class="code">drools.halt()</code>立即终止规则执行。这是将控制权返回到当前会话所处的位置所必需的<code class="code">fireUntilHalt()</code> 。</p></li><li class="listitem"><p>方法<code class="code">insert(Object o)</code> ， <code class="code">update(Object o)</code>和<code class="code">delete(Object o)</code>可以调用<code class="code">drools</code>同样，但是由于它们的频繁使用，可以在没有对象引用的情况下调用它们。</p></li><li class="listitem"><p><code class="code">drools.getWorkingMemory()</code>返回<code class="code">WorkingMemory</code>宾语。</p></li><li class="listitem"><p><code class="code">drools.setFocus( String s)</code>将焦点设置到指定的议程组。</p></li><li class="listitem"><p><code class="code">drools.getRule().getName()</code>从规则的RHS调用，返回规则的名称。</p></li><li class="listitem"><p><code class="code">drools.getTuple()</code>返回与当前执行的规则匹配的元组，并且<code class="code">drools.getActivation()</code>提供相应的激活。（这些调用对于记录和调试目的很有用。）</p></li></ul></div><p>完整的Knowledge Runtime API通过另一个预定义变量公开， <code class="code">kcontext</code> ，类型<code class="code">KieContext</code> 。它的方法<code class="code">getKieRuntime()</code>提供一个类型的对象<code class="code">KieRuntime</code>依次提供了许多方法，其中许多方法对于RHS逻辑编码非常有用。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>通话<code class="code">kcontext.getKieRuntime().halt()</code>立即终止规则执行。</p></li><li class="listitem"><p>存取器<code class="code">getAgenda()</code>返回对该会话的引用<code class="code">Agenda</code> ，进而可以访问各种规则组：激活组，议程组和规则流组。一个相当常见的范例是某个议程组的激活，这可以通过冗长的调用来完成：</p><pre><code class="language-java">// give focus to the agenda group CleanUp
kcontext.getKieRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</code></pre><p>（您可以使用<code class="code">drools.setFocus( "CleanUp" )</code> ）</p></li><li class="listitem"><p>要运行查询，请致电<code class="code">getQueryResults(String query)</code> ，然后您可以处理结果，如<a class="link" href="#QuerySection" title="8.9。询问">Query</a>部分中所述。使用<code class="code">kcontext.getKieRuntime().getQueryResults(...)</code>或使用<code class="code">drools.getKieRuntime().getQueryResults(...)</code>是从规则的RHS运行查询的正确方法，也是唯一受支持的方法。
          </p></li><li class="listitem"><p>一组用于事件管理的方法使您可以为工作记忆库和议程添加和删除事件侦听器。</p></li><li class="listitem"><p>方法<code class="code">getKieBase()</code>返回<code class="code">KieBase</code>对象，系统中所有知识的骨干以及当前会话的发起者。</p></li><li class="listitem"><p>您可以使用<code class="code">setGlobal(...)</code> ， <code class="code">getGlobal(...)</code>和<code class="code">getGlobals()</code> 。</p></li><li class="listitem"><p>方法<code class="code">getEnvironment()</code>返回运行时的<code class="code">Environment</code>它的工作方式与您所知道的操作系统环境非常相似。</p></li></ul></div></div><div class="section" title="8.8.4.2。修改语句"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11890"></a> 8.8.4.2。的<code class="literal">modify</code>声明</h4></div></div></div><p>此语言扩展提供了一种用于事实更新的结构化方法。它将更新操作与许多setter调用结合在一起，以更改对象的字段。这是<code class="literal">modify</code>声明：</p><pre><code class="no-highlight"><code class="literal">modify ( </code><em class="replaceable"><code>&lt;fact-expression&gt;</code></em><code class="literal"> ) {</code>
    <em class="replaceable"><code>&lt;expression&gt;</code></em> [ <code class="literal">,</code> <em class="replaceable"><code>&lt;expression&gt;</code></em> ]*
<code class="literal">}</code></code></pre><p>括号内<span class="emphasis"><em><fact-expression></fact-expression></em></span>必须产生一个事实对象引用。块中的表达式列表应包含对给定对象的setter调用，这些调用将在没有常规对象引用的情况下编写，该引用由编译器自动添加。</p><p>该示例说明了一个简单的事实修改。</p><div class="example"><a id="d0e11927"></a><p class="title"><strong>示例8.83修改语句</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end</code></pre></div></div><br class="example-break"><p>当与细粒度的属性更改侦听器一起使用时，使用修改语句的优势特别明显。有关更多详细信息，请参见相应部分。</p></div></div><div class="section" title="8.8.5。有条件的命名后果"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11934"></a> 8.8.5。有条件的命名后果</h3></div></div></div><p>有时，对每个规则只有一个结果的约束可能会有所限制，并导致冗长且难以维护的重复，如以下示例所示：</p><pre><code class="no-highlight">rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</code></pre><p>通过使第二条规则扩展第一个规则，已经可以部分地克服此问题，如下所示：</p><pre><code class="no-highlight">rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
    extends "Give 10% discount to customers older than 60"
when
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</code></pre><p>无论如何，此功能可以在一条规则中定义除默认结果以外的更多带标签的结果，因此，例如，可以将前两个规则压缩成一个类似以下内容的规则：</p><pre><code class="no-highlight">rule "Give 10% discount and free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</code></pre><p>一旦发现知识库中有60岁以上的客户，此最后一条规则就会产生2种后果，通常是默认的后果，再加上另一种使用关键字do激活的名为“ giveDiscount”的后果，无论该客户的拥有权是什么有没有汽车。命名结果的激活还可以通过其他条件来保护，例如在下面的示例中：</p><pre><code class="no-highlight">rule "Give free parking to customers older than 60 and 10% discount to golden ones among them"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</code></pre><p>if语句中的条件总是在紧接其之前的模式上求值。最后，最后一个更复杂的示例显示了如何使用嵌套的if / else语句切换不同的条件：</p><pre><code class="no-highlight">rule "Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount10]
    else if ( type == "Silver" ) break[giveDiscount5]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount10]
    modify($customer) { setDiscount( 0.1 ) };
then[giveDiscount5]
    modify($customer) { setDiscount( 0.05 ) };
end</code></pre><p>这里的目的是给60岁以上的Golden客户10％的折扣和免费停车，但Silver乘客仅提供5％的折扣（无免费停车）。通过使用关键字break代替do激活名为“ giveDiscount5”的结果，可以实现此结果。实际上，确实只是将结果安排在议程中，从而允许LHS的其余部分继续按照正常方式进行评估，而中断也会阻止任何进一步的模式匹配评估。当然，请注意，没有任何中断条件保护的命名结果的激活是没有意义的（并且会产生编译时错误），因为否则将无法达到其后的LHS部分。</p></div><div class="section" title="8.8.6。关于自动装箱和原始类型的注释"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11959"></a> 8.8.6。关于自动装箱和原始类型的注释</h3></div></div></div><p>Drools尝试将数字保留为原始或对象包装形式，因此绑定到int原语的变量在代码块或表达式中使用时，将不再需要手动拆箱。与Drools 3.0不同，在Drools 3.0中所有原语都自动装箱，需要手动拆箱。绑定到对象包装器的变量将保留为对象。在这种情况下，将使用现有的处理自动装箱和拆箱的JDK 1.5和JDK 5规则。在评估字段约束时，系统尝试将其中一个值强制转换为可比较的格式。因此基元可与对象包装器相提并论。</p></div></strong></strong></div><div class="section" title="8.9。询问"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="QuerySection"></a> 8.9。询问</strong></strong></h2></div></div></div><div class="figure"><strong><strong><a id="d0e11967"></a><p class="title"><strong>图8.29。询问</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/LanguageReference/query.png" align="middle" alt="询问"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>查询是一种简单的方法，可以在工作存储器中搜索符合指定条件的事实。因此，它仅包含规则的LHS的结构，因此您既不指定“ when”，也不指定“ then”。查询具有一组可选参数，每个参数都可以选择键入。如果未提供类型，则假定为对象类型。引擎将尝试根据需要强制更改这些值。查询名称是KieBase的全局名称；因此，请勿将相同名称的查询添加到同一RuleBase的不同包中。</p><p>要返回结果，请使用<code class="code">ksession.getQueryResults("name")</code> ，其中“名称”是查询的名称。这将返回查询结果列表，使您可以检索与查询匹配的对象。</p><p>第一个示例为30岁以上的所有人提供了一个简单的查询。第二个参数使用参数将年龄限制与位置组合在一起。</p><div class="example"><a id="d0e11982"></a><p class="title"><strong>示例8.84查询30岁以上的人</strong></p><div class="example-contents"><pre><code class="no-highlight">query "people over the age of 30" 
    person : Person( age &gt; 30 )
end</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e11987"></a><p class="title"><strong>示例8.85查询x岁以上，y岁以下人士</strong></p><div class="example-contents"><pre><code class="no-highlight">query "people over the age of x"  (int x, String y)
    person : Person( age &gt; x, location == y )
end</code></pre></div></div><br class="example-break"><p>我们使用标准的“ for”循环遍历返回的QueryResults。每个元素都是一个QueryResultsRow，我们可以使用它访问元组中的每个列。可以通过绑定声明名称或索引位置访问这些列。</p><div class="example"><a id="d0e11994"></a><p class="title"><strong>示例8.86查询30岁以上的人</strong></p><div class="example-contents"><pre><code class="no-highlight">QueryResults results = ksession.getQueryResults( "people over the age of 30" );
System.out.println( "we have " + results.size() + " people over the age  of 30" );

System.out.println( "These people are are over 30:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</code></pre></div></div><br class="example-break"><p>添加了对位置语法的支持，以获得更紧凑的代码。默认情况下，类型声明中声明的类型顺序与参数位置匹配。但是可以使用@position注释覆盖它们。这允许模式与位置参数一起使用，而不是更冗长的命名参数。</p><pre><code class="no-highlight">declare Cheese
    name : String @position(1)
    shop : String @position(2)
    price : int @position(0)
end
</code></pre><p>org.drools.definition.type包中的@Position批注可用于在类路径上批注原始pojo。当前，仅可以注释类中的字段。支持类的继承，但不支持接口或方法。下面的isContainedIn查询演示了模式中位置参数的使用； <code class="literal">Location(x, y;)</code>代替<code class="literal">Location( thing == x, location == y).</code></p><p>查询现在可以调用其他查询，此查询与可选查询参数结合在一起可提供派生查询样式的反向链接。参数支持位置语法和命名语法。也可以将位置和名称混合使用，但是位置必须首先出现，并用半冒号分隔。文字表达式可以作为查询参数传递，但是在此阶段，您不能将表达式与变量混合使用。这是一个调用另一个查询的查询示例。请注意，这里的“ z”将始终是“输出”变量。'？'符号表示查询仅是拉式查询，返回结果后，随着基础数据的更改，您将不会再收到进一步的结果。</p><pre><code class="no-highlight">declare Location
    thing : String 
    location : String 
end

query isContainedIn( String x, String y ) 
    Location(x, y;)
    or 
    ( Location(z, y;) and ?isContainedIn(x, z;) )
end</code></pre><p>如前所述，您可以使用实时“开放式”查询来随时间从查询结果中接收更改，作为针对更改查询的基础数据。注意，“ look”规则不使用'？来调用查询。'。</p><pre><code class="no-highlight">query isContainedIn( String x, String y ) 
    Location(x, y;)
    or 
    ( Location(z, y;) and isContainedIn(x, z;) )
end

rule look when 
    Person( $l : likes ) 
    isContainedIn( $l, 'office'; )
then
   insertLogical( $l 'is in the office' );
end 
</code></pre><p>Drools支持派生查询的统一，简而言之，这意味着参数是可选的。可以使用静态字段org.drools.core.runtime.rule从Java调用查询，而无需指定参数。Variable.v-请注意，您必须使用“ v”，而不是Variable的替代实例。这些称为“输出”参数。请注意，查询本身不会在编译时声明参数是in还是out，这可以在每次使用时纯在运行时定义。以下示例将返回办公室中包含的所有对象。</p><pre><code class="no-highlight">results = ksession.getQueryResults( "isContainedIn", new Object[] {  Variable.v, "office" } );
l = new ArrayList&lt;List&lt;String&gt;&gt;();
for ( QueryResultsRow r : results ) {
    l.add( Arrays.asList( new String[] { (String) r.get( "x" ), (String) r.get( "y" ) } ) );
}  
</code></pre><p>该算法使用堆栈来处理递归，因此方法堆栈不会崩溃。</p><p>也可以将事实的字段用作查询的输入参数，例如：</p><pre><code class="no-highlight">query contains(String $s, String $c)
    $s := String( this.contains( $c ) )
end

rule PersonNamesWithA when
    $p : Person()
    contains( $p.name, "a"; )
then
end</code></pre><p>通常，还有任何一种有效的表达式，例如：</p><pre><code class="no-highlight">query checkLength(String $s, int $l)
    $s := String( length == $l )
end

rule CheckPersonNameLength when
    $i : Integer()
    $p : Person()
    checkLength( $p.name, 1 + $i + $p.age; )
then
end</code></pre><p>尚不支持以下功能：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>列表和地图统一</p></li><li class="listitem"><p>表达式统一-pred（X，X + 1，X * Y / 7）</p></li></ul></div></strong></strong></div><div class="section" title="8.10。领域特定语言"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12041"></a> 8.10。领域特定语言</strong></strong></h2></div></div></div><p><strong><strong><a id="d0e12045" class="indexterm"></a>域特定语言（或DSL）是一种创建专用于您的问题域的规则语言的方法。一组DSL定义包括从DSL“语句”到DRL结构的转换，这使您可以使用所有潜在的规则语言和引擎功能。在给定DSL的情况下，您可以在DSL规则（或DSLR）文件中编写规则，然后将其转换为DRL文件。</strong></strong></p><p><strong><strong>DSL和DSLR文件是纯文本文件，您可以使用任何文本编辑器来创建和修改它们。但是，IDE和基于Web的BRMS中也都有DSL和DSLR编辑器，尽管它们可能无法为您提供完整的DSL功能，但您也可以使用它们。
  </strong></strong></p><div class="section" title="8.10.1。何时使用DSL"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12051"></a> 8.10.1。何时使用DSL</strong></strong></h3></div></div></div><p><strong><strong>DSL可以充当规则创作（和规则作者）与域对象建模以及规则引擎的本地语言和方法所导致的技术复杂性之间的隔离层。如果非程序员的领域专家（例如，业务分析师）需要阅读和验证您的规则，则应考虑使用DSL。它隐藏了实现细节，并专注于适当的规则逻辑。DSL语句还可以用作条件元素和结果操作的“模板”，这些条件元素和结果操作在规则中重复使用，可能会有微小的变化。您可以将DSL句子定义为映射到这些重复的短语，并使用参数来提供适应这些变化的方式。</strong></strong></p><p><strong><strong>DSL在运行时对规则引擎没有影响，它们只是编译时功能，需要特殊的解析器和转换器。</strong></strong></p></div><div class="section" title="8.10.2。DSL基础"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12058"></a> 8.10.2。DSL基础</strong></strong></h3></div></div></div><p><strong><strong>Drools DSL机制允许您自定义条件表达式和结果操作。全局替换机制（“关键字”）也可用。</strong></strong></p><div class="example"><strong><strong><a id="d0e12063"></a><p class="title"><strong>示例8.87例<a id="d0e12066" class="indexterm"></a> DSL映射</strong></p><div class="example-contents"><pre><code class="no-highlight">[when]Something is {colour}=Something(colour=="{colour}")</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>在前面的示例中， <code class="code">[when]</code>指示表达式的范围，即，它对于规则的LHS还是RHS有效。方括号关键字之后的部分是您在规则中使用的表达式；通常是自然语言表达，但不一定必须如此。等号（“ =”）右边的部分是表达式到规则语言的映射。该字符串的形式取决于其目的地RHS或LHS。如果是用于LHS，则应该是按照常规LHS语法的术语。如果用于RHS，则可能是Java语句。</p><p>每当DSL解析器将DSL中写入的规则文件中的一行与DSL定义中的表达式匹配时，它就会执行三个字符串操作步骤。首先，它提取出现在表达式中包含大括号的变量名的字符串值（此处： <code class="code">{colour}</code> ）。然后，将从这些捕获获得的值进行插值，直到该名称（再次用大括号括起来）出现在映射的右侧。最后，内插字符串替换DSL规则文件行中整个表达式所匹配的内容。</p><p>请注意，表达式（即，等号左侧的字符串）在针对DSL规则文件的一行的模式匹配操作中用作正则表达式，与一行的全部或部分匹配。这意味着您可以（例如）使用'？'表示前面的字符是可选的。使用此功能的一个很好的理由是要克服DSL自然语言短语的变化。但是，由于这些表达式是正则表达式模式，因此这也意味着必须用前面的反斜杠（'\'）来转义Java模式语法的所有“魔术”字符。</p><p>重要的是要注意，编译器逐行转换DSL规则文件。在上面的示例中，“ Something is”之后到行尾的所有文本均被捕获为“ {colour}”的替换值，并用于插值目标字符串。这可能不完全是您想要的。例如，当您打算合并不同的DSL表达式以生成复合DRL模式时，您需要通过几个独立的操作来转换DSLR线路。实现此目的的最佳方法是确保捕获内容被特征性文本（单词或单个字符）包围。结果，解析器完成的匹配操作从该行中的某处拔出了子字符串。在下面的示例中，引号用作特殊字符。请注意，插值过程中不包括捕获周围的字符，只是它们之间的内容。</p><p>根据经验，对规则编辑器可能要输入的文本数据使用引号。您也可以用文字将捕获内容括起来，以确保文本正确匹配。以下示例说明了两者。请注意，单行例如<code class="code">Something is "green" and another solid thing</code>现在已正确展开。</p><div class="example"><a id="d0e12091"></a><p class="title"><strong>示例8.88带引号的示例</strong></p><div class="example-contents"><pre><code class="no-highlight">[when]something is "{colour}"=Something(colour=="{colour}")
[when]another {state} thing=OtherThing(state=="{state})"</code></pre></div></div><br class="example-break"><p>最好避免DSL表达式中出现标点符号（引号或撇号除外）。主要原因是使用DSL的规则作者容易忘记标点符号。另一个原因是括号，句号和问号是魔术字符，需要转义DSL定义。</p><p>在DSL映射中，大括号“ {”和“}”仅应用于封装变量定义或引用，以进行捕获。如果它们应在字面上出现，无论是在表达式中还是在右侧的替换文本中，都必须使用前面的反斜杠（“ \”）进行转义：</p><pre><code class="no-highlight">[then]do something= if (foo) \{ doSomething(); \}
    </code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>如果括号“ {”和“}”应出现在DSL定义的替换字符串中，请用反斜杠（'\'）对其进行转义。</p></div><div class="example"><a id="d0e12105"></a><p class="title"><strong>示例8.89DSL映射条目示例</strong></p><div class="example-contents"><pre><code class="no-highlight"># This is a comment to be ignored.
[when]There is a person with name of "{name}"=Person(name=="{name}")
[when]Person is at least {age} years old and lives in "{location}"=
      Person(age &gt;= {age}, location=="{location}")
[then]Log "{message}"=System.out.println("{message}");
[when]And = and</code></pre></div></div><br class="example-break"><p>给定上述DSL示例，以下示例显示了各种DSLR片段的扩展：</p><div class="example"><a id="d0e12112"></a><p class="title"><strong>示例8.90DSL扩展示例</strong></p><div class="example-contents"><pre><code class="no-highlight">There is a person with name of "Kitty"
   ==&gt; Person(name="Kitty")
Person is at least 42 years old and lives in "Atlanta"
   ==&gt; Person(age &gt;= 42, location="Atlanta")
Log "boo"
   ==&gt; System.out.println("boo");
There is a person with name of "Bob" and Person is at least 30 years old and lives in "Utah"
   ==&gt; Person(name="Bob") and Person(age &gt;= 30, location="Utah")</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>不要忘记，如果要从DSL规则行捕获纯文本，并想在扩展中将其用作字符串文字，则必须在映射的右侧提供引号。</p></div><p>您可以将DSL表达式链接在一起，只要解析器可以清楚地知道DSL表达式的结束位置和下一句开始的位置以及表示参数的文本的结束位置。（否则，您将冒着将所有文本直到行尾作为参数值的风险。）根据DSL定义文件中的顺序依次尝试DSL表达式。进行任何匹配后，还将调查所有剩余的DSL表达式。</p><p>生成的DRL文本可能包含多行。行尾在替换文本中写为<code class="code">\n</code> 。</p></strong></strong></div><div class="section" title="8.10.3。向事实添加约束"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12127"></a> 8.10.3。向事实添加约束</strong></strong></h3></div></div></div><p><strong><strong>编写规则条件时的一个常见要求是能够向模式添加约束的任意组合。考虑到事实类型可能具有许多字段，必须为每种组合提供单独的DSL语句将是愚蠢的。</strong></strong></p><p><strong><strong>DSL功能允许您通过简单的约定将约束添加到模式：如果DSL表达式以连字符（减号“-”）开头，则假定它是字段约束，因此被添加到最后一个前面的图案线。</strong></strong></p><p><strong><strong>例如，让我们看一下课程<code class="code">Cheese</code> ，其中包含以下字段：类型，价格，年龄和国家/地区。我们可以在正常DRL中表达一些LHS条件，如下所示</strong></strong></p><pre><code class="no-highlight">Cheese(age &lt; 5, price == 20, type=="stilton", country=="ch")</code></pre><p><strong><strong>下面给出的DSL定义产生了三个DSL短语，可用于创建涉及这些字段的约束的任何组合。</strong></strong></p><pre><code class="no-highlight">[when]There is a Cheese with=Cheese()
[when]- age is less than {age}=age&lt;{age}
[when]- type is '{type}'=type=='{type}'
[when]- country equal to '{country}'=country=='{country}'</code></pre><p><strong><strong>然后，您可以使用以下条件编写规则：</strong></strong></p><pre><code class="no-highlight">There is a Cheese with
        - age is less than 42
        - type is 'stilton'</code></pre><p><strong><strong>解析器将选择以“-”开头的行，并将其作为约束添加到前面的模式中，并在需要时插入逗号。对于前面的示例，生成的DRL为：</strong></strong></p><pre><code class="no-highlight">Cheese(age&lt;42, type=='stilton')</code></pre><p><strong><strong>
    </strong></strong></p><p><strong><strong>将所有数字字段与所有关系运算符组合在一起（根据前面的示例中的DSL表达式“ age小于...”）会产生大量的DSL条目。但是，您可以为各种运算符甚至是处理任何字段约束的通用表达式定义DSL短语，如下所示。（请注意，表达式定义除变量名外还包含正则表达式。）</strong></strong></p><pre><code class="no-highlight">[when][]is less than or equal to=&lt;=
[when][]is less than=&lt;
[when][]is greater than or equal to=&gt;=
[when][]is greater than=&gt;
[when][]is equal to===
[when][]equals===
[when][]There is a Cheese with=Cheese()
[when][]- {field:\w*} {operator} {value:\d*}={field} {operator} {value} </code></pre><p><strong><strong>给定这些DSL定义，您可以使用以下条件编写规则：</strong></strong></p><pre><code class="no-highlight">There is a Cheese with
   - age is less than 42
   - rating is greater than 50
   - type equals 'stilton'</code></pre><p><strong><strong>在这种特定情况下，用“小于”等短语替换为<code class="code"><</code> ，然后该行与最后一个DSL条目匹配。这样可以除去连字符，但最终结果仍作为约束添加到前面的模式中。处理完所有行后，得到的DRL文本为：</strong></strong></p><pre><code class="no-highlight">Cheese(age&lt;42, rating &gt; 50, type=='stilton')</code></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>如果要使单独的DSL表达式一个接一个地匹配同一行，则DSL中条目的顺序很重要。</strong></strong></p></div></div><div class="section" title="8.10.4。开发DSL"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12171"></a> 8.10.4。开发DSL</strong></strong></h3></div></div></div><p><strong><strong>一个很好的入门方法是编写应用程序所需规则的代表性示例，并在开发时对其进行测试。这将为您提供条件元素及其约束的稳定框架。DRL和DSLR中的规则都是根据表示代表应遵循规则中定义的推理过程的应用程序数据的数据模型来指代实体。注意，如果大多数数据模型的类型都是事实，那么编写规则通常会更容易。</strong></strong></p><p><strong><strong>给定初始规则集，应该可以识别重复出现的代码段或相似的代码段，并将可变部分标记为参数。这为可能是方便的DSL条目提供了可靠的线索。另外，请确保您充分了解域专家正在使用的术语，并根据此词汇表来使用DSL短语。</strong></strong></p><p><strong><strong>您可以通过在第一个设计阶段中将某些条件元素和操作以DRL形式保留，并在其前面加上一个大号（“>”）来延迟有关条件和操作的实现决策。（这对于插入调试语句也很方便。）</strong></strong></p><p><strong><strong>在下一个开发阶段，您应该发现DSL配置可以很快稳定下来。可以通过重用现有的DSL定义或将参数添加到现有条件或结果条目来编写新规则。</strong></strong></p><p><strong><strong>尝试使DSL条目的数量保持较小。使用参数可以将相同的DSL语句应用于相似的规则模式或约束。但是请不要夸张：使用DSL的作者仍然应该能够通过某些固定文本来识别DSL短语。</strong></strong></p></div><div class="section" title="8.10.5。DSL和DSLR参考"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12184"></a> 8.10.5。DSL和DSLR参考</strong></strong></h3></div></div></div><p><strong><strong>DSL文件是面向行格式的文本文件。它的条目用于根据DRL语法将DSLR文件转换为文件。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>以“＃”或“ //”开头的行（带或不带前空格）被视为注释。扫描以“＃/”开头的注释行，查找请求调试选项的单词，请参见下文。</strong></strong></p></li><li class="listitem"><p><strong><strong>任何以左方括号（“ [”）开头的行均被视为DSL条目定义的第一行。</strong></strong></p></li><li class="listitem"><p><strong><strong>任何其他行都将附加到前面的DSL条目定义中，并且该行的末尾用空格代替。</strong></strong></p></li></ul></div><p><strong><strong>DSL条目包括以下四个部分：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>范围定义，用关键词“ when”或“ condition”，“ then”或“ consequence”，“ *”和“ keyword”之一括在方括号（“ [”和“]”）中。这表明DSL条目对于条件或规则结果是否有效，或两者均有效。作用域指示“关键字”表示该条目具有全局重要性，即，它在DSLR文件中的任何位置都可以识别。</strong></strong></p></li><li class="listitem"><p><strong><strong>用Java类名编写的类型定义，括在方括号中。除非下一部分以开括号开头，否则此部分是可选的。一个空的方括号也有效。</strong></strong></p></li><li class="listitem"><p><strong><strong>DSL表达式由（Java）正则表达式组成，该正则表达式具有任意数量的嵌入<span class="emphasis"><em>变量定义，</em></span>并以等号（“ =”）终止。变量定义用大括号（“ {”和“}”）括起来。它由变量名和两个可选的附件组成，并用冒号（“：”）分隔。如果有一个附件，则它是一个正则表达式，用于匹配要分配给变量的文本。如果有两个附件，则第一个是GUI编辑器的提示，第二个是正则表达式。</strong></strong></p><p><strong><strong>请注意，如果正则表达式中的所有“魔术”字符都应出现在表达式中，则必须使用反斜杠（“ \”）对其进行转义。</strong></strong></p></li><li class="listitem"><p><strong><strong>在等号后的行的其余部分是与正则表达式匹配的所有DSLR文本的替换文本。它可能包含变量引用，即用大括号括起来的变量名称。（可选）变量名后可以带有感叹号（“！”“）和转换函数，请参见下文。</strong></strong></p><p><strong><strong>请注意，如果大括号（“ {”和“}”）在字面上出现在替换字符串中，则必须使用反斜杠（“ \”）进行转义。</strong></strong></p></li></ul></div><p><strong><strong>通过使用以“＃/”开头的注释行（可以包含下表中的一个或多个单词），可以有选择地打开DSL扩展的调试。结果输出将写入标准输出。</strong></strong></p><div class="table"><strong><strong><a id="d0e12223"></a><p class="title"><strong>表8.2。DSL扩展的调试选项</strong></p><div class="table-contents"><table border="1" summary="Debug options for DSL expansion"><colgroup><col><col></colgroup><thead><tr><th>字</th><th>描述</th></tr></thead><tbody><tr><td>结果</td><td>打印带有行号的结果DRL文本。</td></tr><tr><td>脚步</td><td>打印条件和结果行的每个扩展步骤。</td></tr><tr><td>关键词</td><td>转储具有范围“关键字”的所有DSL条目的内部表示。</td></tr><tr><td>什么时候</td><td>转储范围为“ when”或“ *”的所有DSL条目的内部表示。</td></tr><tr><td>然后</td><td>转储范围为“ then”或“ *”的所有DSL条目的内部表示。</td></tr><tr><td>用法</td><td>显示所有DSL条目的使用情况统计信息。</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><p>下面是一些DSL定义示例，其中的注释描述了它们说明的语言功能。</p><pre><code class="no-highlight"># Comment: DSL examples

#/ debug: display result and usage

# keyword definition: replaces "regula" by "rule"
[keyword][]regula=rule

# conditional element: "T" or "t", "a" or "an", convert matched word
[when][][Tt]here is an? {entity:\w+}=
        ${entity!lc}: {entity!ucfirst} ()

# consequence statement: convert matched word, literal braces
[then][]update {entity:\w+}=modify( ${entity!lc} )\{ \}
</code></pre><p>DSLR文件的转换过程如下：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>文本被读入内存。</p></li><li class="listitem"><p>每个“关键字”条目都应用于整个文本。首先，通过以下方式修改关键字定义的正则表达式：用匹配任意数量的空格字符的模式替换空白序列，并用由定义所提供的正则表达式或默认值（ ”。*？”）。然后，在DSLR文本中详尽搜索与匹配的正则表达式匹配的字符串的出现。提取与变量捕获对应的匹配字符串的子字符串，并替换相应替换文本中的变量引用，并且此文本替换DSLR文本中的匹配字符串。</p></li><li class="listitem"><p>如下所述，分别以统一的方式逐行定位和处理DSLR文本中“何时”和“然后”，“然后”和“结束”之间的部分。</p><p>对于一条线路，与线路部分有关的每个DSL条目都按照在DSL文件中出现的顺序依次获取。修改了它的正则表达式部分：用匹配任意数量空格字符的模式替换空格；具有正则表达式的变量定义将被具有该正则表达式的捕获所替代，其默认值为“。*？”。如果结果正则表达式与行的全部或部分匹配，则将匹配的部分替换为适当修改的替换文本。</p><p>通过用对应于正则表达式捕获的文本替换变量引用来完成替换文本的修改。可以根据变量参考中提供的字符串转换函数来修改此文本；有关详情，请参见下文。</p><p>如果在同一条目中有一个变量引用命名未定义的变量，则扩展器将替换绑定到该名称的变量的值，前提是该变量是在当前规则的前几行中定义的。</p></li><li class="listitem"><p>如果条件中的DSLR行写有前导连字符，则将扩展结果插入到最后一行，该行应包含模式CE，即类型名称后跟一对括号。如果该对为空，则仅插入扩展行（应包含有效约束），否则将事先插入逗号（“，”）。</p><p>如果结果中的DSLR行写有前导连字符，则扩展结果将插入到最后一行，该行应包含“ modify”语句，并以一对大括号（“ {”和“}”）结尾。如果该对为空，则仅插入扩展行（应包含有效的方法调用），否则将事先插入逗号（“，”）。
        </p></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>这是目前<span class="emphasis"><em>无法</em></span>使用符合领先的连字符插入文字等条件元素形式（例如，“收集”），也可以只用第一插入操作（例如，“EVAL”）。</p></div><p>下表描述了所有字符串转换函数。</p><div class="table"><a id="d0e12299"></a><p class="title"><strong>表8.3。字符串转换功能</strong></p><div class="table-contents"><table border="1" summary="String transformation functions"><colgroup><col><col></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>uc</td><td>将所有字母转换为大写。</td></tr><tr><td>lc</td><td>将所有字母转换为小写。</td></tr><tr><td>ucfirst</td><td>将第一个字母转换为大写，并将所有其他字母转换为小写。</td></tr><tr><td>数</td><td>从字符串中提取所有数字和“-”。如果原始字符串的最后两位数字以“。”开头。或“，”，在相应位置插入一个小数点。</td></tr><tr><td><span class="emphasis"><em>一个</em></span> ？<span class="emphasis"><em>b</em></span> / <span class="emphasis"><em>c</em></span></td><td>将字符串与字符串<span class="emphasis"><em>a</em></span>比较，如果相等，则将其替换为<span class="emphasis"><em>b</em></span> ，否则将其替换为<span class="emphasis"><em>c</em></span> 。但是<span class="emphasis"><em>c</em></span>可以是另一个三元组<span class="emphasis"><em>a</em></span> ， <span class="emphasis"><em>b</em></span> ， <span class="emphasis"><em>c</em></span> ，因此整个结构实际上是一个转换表。</td></tr></tbody></table></div></div><br class="table-break"><p>以下DSL示例显示了如何使用字符串转换功能。</p><pre><code class="no-highlight"># definitions for conditions
[when][]There is an? {entity}=${entity!lc}: {entity!ucfirst}()
[when][]- with an? {attr} greater than {amount}={attr} &lt;= {amount!num}
[when][]- with a {what} {attr}={attr} {what!positive?&gt;0/negative?%lt;0/zero?==0/ERROR}</code></pre><p>包含DSL定义的文件必须放置在resources文件夹或其任何子文件夹下，就像其他所有drools工件一样。它必须具有扩展名<code class="code">.dsl</code> ，或者用类型标记<code class="code">ResourceType.DSL</code> 。以编程方式添加到<code class="code">KieFileSystem</code> 。对于使用DSL定义的文件，扩展名<code class="code">.dslr</code>应该使用，但可以将其添加到<code class="code">KieFileSystem</code>与类型<code class="code">ResourceType.DSLR</code> 。</p><p>为了解析和扩展DSLR文件，需要读取DSL配置并将其提供给解析器。因此，解析器可以“识别” DSL表达式并将其转换为本地规则语言表达式。</p></strong></strong></div></div></div><div class="chapter" title="第九章复杂事件处理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="DroolsComplexEventProcessingChapter"></a>第九章复杂事件处理</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e12392">9.1。复杂事件处理</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12443">9.2。流口水融合</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12545">9.3。事件语义</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12597">9.4。事件处理模式</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12604">9.4.1。云模式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12635">9.4.2。流模式</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e12715">9.5。会话时钟</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12746">9.5.1。可用时钟实现</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e12773">9.6。滑动窗</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12786">9.6.1。滑动时间窗</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12809">9.6.2。滑动长度窗</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12845">9.6.3。窗口声明</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e12866">9.7。流支持</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12888">9.7.1。声明和使用入口点</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e12922">9.8。事件的内存管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e12940">9.8.1。显式过期偏移</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e12958">9.8.2。推断的过期时间偏移</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e12978">9.9。时间推理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13050">9.9.1。时间运算符</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="9.1。复杂事件处理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12392"></a> 9.1。复杂事件处理</strong></strong></h2></div></div></div><p><strong><strong>关于术语“复杂事件处理”，没有广泛接受的定义。术语事件本身经常被重载，并根据使用的上下文来指代几种不同的事物。定义术语不是本指南的目的，因此，让我们采用一个宽松的定义，尽管它不是正式的，但将使我们能够达成共识。</strong></strong></p><p><strong><strong>因此，在本指南的范围内：</strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong><a id="d0e12401" class="indexterm"></a> <span class="bold"><strong>事件</strong></span> ，是在给定时间点应用程序域中状态发生重大变化的记录。</strong></strong></p></div><p><strong><strong>例如，在Stock Broker应用程序上，当执行销售操作时，它将导致域中的状态更改。可以在域中的多个实体上观察到这种状态变化，例如，为匹配操作价值而更改的证券价格，从卖方到买方的交易资产所有权，账户余额状态和状态的变化可能由单个事件，多个原子事件或相关事件的层次结构表示，具体取决于域的建模方式。无论如何，在本指南的上下文中，事件是域中特定数据的更改的记录。</strong></strong></p><p><strong><strong>自事件被发明以来，事件一直由计算机系统处理，并且在整个历史过程中，负责事件的系统被赋予了不同的名称和不同的方法。直到90年代，才开始着重于EDA（事件驱动架构）的工作，并对事件处理的要求和目标进行更正式的定义。为了满足这些要求，旧的消息传递系统开始发生变化，而出于事件处理的单一目的开始开发新的系统。在事件流处理和复杂事件处理的名称下诞生了两种趋势。</strong></strong></p><p><strong><strong>从一开始，事件流处理就专注于（近）实时处理事件流的功能，而复杂事件处理的主要重点在于将原子事件与复杂（复合）事件进行关联和组合。一个重要的（也许是最重要的）里程碑是2002年David Luckham博士的著作《事件的力量》的出版。在这本书中，Luckham博士介绍了复杂事件处理的概念以及如何使用它来增强处理事件的系统。多年来，这两种趋势趋于一致，今天，这些系统都被称为CEP系统。</strong></strong></p><p><strong><strong>这是对一个非常复杂和富饶的研究领域的非常简单的解释，但是对本指南将要介绍的概念建立了高水平的共识。</strong></strong></p><p><strong><strong>当前对什么是复杂事件处理的理解可以简短地描述为Wikipedia的以下引用：</strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>” <a id="d0e12426" class="indexterm"></a> <span class="bold"><strong>复杂事件处理</strong></span> （CEP）主要是一种事件处理概念，用于处理多个事件，以识别事件云中有意义的事件为目标。CEP采用了诸如检测许多事件的复杂模式，事件相关性和抽象性，事件层次结构以及事件之间的因果关系，成员资格和时间关系以及事件驱动过程之类的技术。”</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">- <span class="attribution"><em class="citetitle"><a class="link" href="http://en.wikipedia.org/wiki/Complex_event_processing">维基百科</a></em></span></td></tr></tbody></table></div></div><p><strong><strong>换句话说，CEP是关于从事件云中检测并选择有趣的事件（仅它们），找到它们之间的关系，并从它们及其关系中推断出新数据。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>在本指南的其余部分中，我们将使用术语“ <span class="bold"><strong>复杂事件处理”</strong></span>和“ <span class="bold"><strong>CEP”</strong></span>作为任何相关技术的广泛参考，包括但不限于CEP，复杂事件处理，ESP，事件流处理和事件处理一般来说。</strong></strong></p></div></div><div class="section" title="9.2。流口水融合"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12443"></a> 9.2。流口水融合</strong></strong></h2></div></div></div><p><strong><strong>通常，事件处理用例与业务规则用例共享一些需求和目标。这些重叠发生在业务端和技术端。</strong></strong></p><p><strong><strong>在业务方面：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>经常根据事件触发的场景的发生来定义业务规则。例如：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>在算法交易应用程序上：如果证券价格与当日开盘价相比上涨X％，则采取措施，其中价格上涨通常由“股票交易”应用程序中的事件表示。</strong></strong></p></li><li class="listitem"><p><strong><strong>在监视应用程序上：如果服务器机房的温度在Y分钟内升高X度，则应采取措施，其中传感器读数通常由事件表示。</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>业务规则和事件处理查询都经常更改，需要业务部门立即做出响应，以使其适应新的市场条件，新的法规和新的企业策略。</strong></strong></p></li></ul></div><p><strong><strong>从技术角度来看：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>两者都需要与企业基础架构和应用程序无缝集成，特别是在自治治理方面，包括但不限于生命周期管理，审计，安全性等。</strong></strong></p></li><li class="listitem"><p><strong><strong>两者都有功能需求（例如模式匹配）和非功能需求（例如响应时间和查询/规则说明）。</strong></strong></p></li></ul></div><p><strong><strong>即使是共享需求和目标，从历史上看，这两个领域都是与生俱来的。尽管行业不断发展，人们可以在市场上找到好的产品，但它们要么专注于事件处理，要么专注于业务规则管理。这不仅是由于历史原因，而且还因为用例即使部分重叠也确实有一些不同的要求。</strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>Drools也是几年前诞生的一个规则引擎，但是随着成为行为建模的单一平台的愿景，它很快意识到，只有对三种互补的业务建模技术给予同样的重视，才能实现这一目标：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>业务规则管理</strong></strong></p></li><li class="listitem"><p><strong><strong>业务流程管理</strong></strong></p></li><li class="listitem"><p><strong><strong>复杂事件处理</strong></strong></p></li></ul></div></div><p><strong><strong>在这种情况下，Drools Fusion是负责将事件处理功能添加到平台中的模块。</strong></strong></p><p><strong><strong>但是，支持复杂事件处理不仅仅是简单地了解事件是什么。CEP方案具有几个共同的独特特征：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>通常需要处理大量事件，但是只有一小部分事件是真正有意义的。</strong></strong></p></li><li class="listitem"><p><strong><strong>事件通常是不可变的，因为它们是状态变化的记录。</strong></strong></p></li><li class="listitem"><p><strong><strong>通常，事件的规则和查询必须以反应性模式运行，即对事件模式的检测做出反应。</strong></strong></p></li><li class="listitem"><p><strong><strong>通常，相关事件之间存在很强的时间关系。</strong></strong></p></li><li class="listitem"><p><strong><strong>个别事件通常并不重要。系统关注相关事件的模式及其关系。</strong></strong></p></li><li class="listitem"><p><strong><strong>通常，系统需要执行事件的组合和聚集。</strong></strong></p></li></ul></div><p><strong><strong>基于这种普遍的共同特征，Drools Fusion定义了要适当支持复杂事件处理的一组目标：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>以一流的公民身份支持活动，并具有适当的语义。</strong></strong></p></li><li class="listitem"><p><strong><strong>允许检测，关联，聚合和组合事件。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持事件流的处理。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持时间约束以便对事件之间的时间关系建模。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持有趣事件的滑动窗口。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持会话范围的统一时钟。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持CEP用例所需的事件量。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持（重新）活动规则。</strong></strong></p></li><li class="listitem"><p><strong><strong>支持将事件输入引擎（管道）的适配器。</strong></strong></p></li></ul></div><p><strong><strong>上面的目标列表基于Drools Expert本身未涵盖的要求，因为在统一平台中，一个模块的所有功能均被其他模块利用。这样，Drools Fusion诞生了企业级功能，例如模式匹配，这对CEP产品至关重要，但是Drools Expert已经提供了该功能。以相同的方式，Drools Flow利用了Drools Fusion提供的所有功能（反之亦然），使流程管理意识到事件处理，反之亦然。</strong></strong></p><p><strong><strong>在本指南的其余部分，我们将介绍Drools Fusion添加到平台的每个功能。所有这些功能都可用于支持CEP世界中的不同用例，并且用户可以自由选择和使用将帮助他为业务用例建模的功能。</strong></strong></p></div><div class="section" title="9.3。事件语义"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12545"></a> 9.3。事件语义</strong></strong></h2></div></div></div><p><strong><strong><span class="emphasis"><em>事件</em></span>是一个事实，具有一些明显的特征：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong>通常是不可变的：</strong></span>由于按照前面讨论的定义，事件是应用程序域中状态更改的记录，即，已发生的事情的记录，并且过去的事件无法“更改”，因此事件是不可变的。此约束是开发多个优化和事件生命周期的规范的重要要求。这并不意味着代表该对象的Java对象必须是不可变的。恰恰相反，引擎不会强制执行对象模型的不变性，因为规则最常见的用例之一是事件数据充实。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>最佳做法是，允许应用程序填充未填充的事件属性（以用推断的数据丰富事件），但是永远不要更改已填充的属性。</strong></strong></p></div></li><li class="listitem"><p><strong><strong><span class="bold"><strong>强大的时间约束：</strong></span>涉及事件的规则通常需要多个事件的相关性，尤其是时间相关性，在这种情况下，事件被称为相对于其他事件在某个时间点发生。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>托管生命周期：</strong></span>由于事件的不变性和时间限制，事件通常只会在有限的时间范围内匹配其他事件和事实，从而使引擎有可能自动管理事件的生命周期。换句话说，一个事件被插入到工作存储器中，引擎有可能找出一个事件何时不再与其他事实匹配，并自动删除该事件，从而释放其关联资源。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>滑动窗口的使用：</strong></span>由于所有事件都具有与之关联的时间戳，因此可以在其上定义和使用滑动窗口，从而允许在一段时间内创建关于值聚合的规则。示例：60分钟内事件值的平均值。</strong></strong></p></li></ul></div><p><strong><strong>Drools支持两种语义的事件声明和使用： <span class="bold"><strong>时间点</strong></span>事件和<span class="bold"><strong>基于间隔的</strong></span>事件。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>理解语义统一性的一种简单方法是将<span class="emphasis"><em>时间点</em></span>事件视为<span class="emphasis"><em>持续时间为零</em></span> <span class="emphasis"><em>的基于间隔的</em></span>事件。</strong></strong></p></div></div><div class="section" title="9.4。事件处理模式"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12597"></a> 9.4。事件处理模式</strong></strong></h2></div></div></div><p><strong><strong>规则引擎通常具有处理数据和规则并向应用程序提供结果的众所周知的方式。同样，对于如何将事实呈现给规则引擎也没有太多要求，特别是因为通常，处理本身是时间独立的。对于大多数场景而言，这是一个很好的假设，但对于所有场景而言并非如此。当需求包括实时或近实时事件的处理时，时间成为推理过程的重要变量。</strong></strong></p><p><strong><strong>以下各节将说明时间对规则推理的影响以及Drools为推理过程提供的两种模式。
  </strong></strong></p><div class="section" title="9.4.1。云模式"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12604"></a> 9.4.1。云模式</strong></strong></h3></div></div></div><p><strong><strong>CLOUD处理模式是默认处理模式。规则引擎的用户熟悉此模式，因为它的行为与任何纯正向链接规则引擎（包括Drools的早期版本）完全相同。</strong></strong></p><p><strong><strong>在CLOUD模式下运行时，引擎会在工作内存中看到所有事实，无论它们是常规事实还是事件，都没有关系。尽管事件具有通常的时间戳，但没有时间流的概念。换句话说，尽管引擎知道某个给定事件是在2009年1月1日09：35：40.767上创建的，但由于存在以下情况，引擎无法确定该事件的“发生时间”没有“现在”的概念。</strong></strong></p><p><strong><strong>在这种模式下，引擎将应用其通常的多对多模式匹配算法，使用规则约束来查找匹配的元组，并照常激活和触发规则。</strong></strong></p><p><strong><strong>此模式不对事实施加任何其他要求。因此，例如：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>没有时间观念。无需时钟同步。
      </strong></strong></p></li><li class="listitem"><p><strong><strong>对事件排序没有要求。引擎将事件视为无序的云，引擎尝试匹配规则。</strong></strong></p></li></ul></div><p><strong><strong>另一方面，由于没有要求，因此某些好处也不可用。例如，在CLOUD模式下，无法使用滑动窗口，因为滑动窗口基于“ now”的概念，而在CLOUD模式下没有“ now”的概念。</strong></strong></p><p><strong><strong>由于对事件没有排序要求，因此引擎无法确定何时不再匹配事件，因此，没有针对事件的自动生命周期管理。即，应用程序必须在不再需要事件时显式删除事件，就像应用程序处理常规事实一样。</strong></strong></p><p><strong><strong>云模式是Drools的默认执行模式，但是无论如何，与Drools中的任何其他配置一样，可以通过设置系统属性，使用配置属性文件或使用API来更改此行为。相应的属性是：</strong></strong></p><pre><code class="language-java">KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();
config.setOption( EventProcessingOption.CLOUD );</code></pre><p><strong><strong>等效属性为：</strong></strong></p><pre><code class="no-highlight">drools.eventProcessingMode = cloud</code></pre><p></p></div><div class="section" title="9.4.2。流模式"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12635"></a> 9.4.2。流模式</strong></strong></h3></div></div></div><p><strong><strong>当应用程序需要处理事件流时，选择STREAM处理模式。它为常规处理增加了一些通用要求，但启用了许多功能，这些功能使流事件处理变得更加简单。</strong></strong></p><p><strong><strong>使用STREAM模式的主要要求是：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>每个流中的事件必须按时间排序。即，在给定的流中，首先发生的事件必须首先插入引擎。</strong></strong></p></li><li class="listitem"><p><strong><strong>引擎将通过使用会话时钟来强制流之间的同步，因此，尽管应用程序不需要在流之间强制执行时间排序，但使用非时间同步的流可能会导致某些意外结果。</strong></strong></p></li></ul></div><p><strong><strong>鉴于满足了以上要求，应用程序可以使用以下API启用STREAM模式：</strong></strong></p><pre><code class="language-java">KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();
config.setOption( EventProcessingOption.STREAM );</code></pre><p><strong><strong>或者，等效属性：</strong></strong></p><pre><code class="no-highlight">drools.eventProcessingMode = stream</code></pre><p><strong><strong>使用STREAM时，引擎会了解时间流的概念和“现在”的概念，即引擎会根据从会话时钟读取的当前时间戳来了解旧事件的发生情况。此特征使引擎可以为应用程序提供以下附加功能：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>滑动窗支架</strong></strong></p></li><li class="listitem"><p><strong><strong>自动事件生命周期管理</strong></strong></p></li><li class="listitem"><p><strong><strong>使用负模式时的自动规则延迟</strong></strong></p></li></ul></div><p><strong><strong>以下各节将说明所有这些功能。</strong></strong></p><div class="section" title="9.4.2.1。会话时钟在流模式下的作用"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e12671"></a> 9.4.2.1。会话时钟在流模式下的作用</strong></strong></h4></div></div></div><p><strong><strong>在CLOUD模式下运行引擎时，会话时钟仅用于为没有预先定义的timestamp属性的到达事件加时间戳。尽管在STREAM模式下，会话时钟扮演着更为重要的角色。</strong></strong></p><p><strong><strong>在STREAM模式下，会话时钟负责保持当前时间戳，并基于该时间戳，引擎对事件的老化进行所有时间计算，同步来自多个源的流，安排将来的任务等。</strong></strong></p><p><strong><strong>查看“会话时钟”部分的文档，以了解如何配置和使用不同的会话时钟实现。</strong></strong></p></div><div class="section" title="9.4.2.2。流模式下的负模式"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e12680"></a> 9.4.2.2。流模式下的负模式</strong></strong></h4></div></div></div><p><strong><strong>与云模式相比，负模式在STREAM模式下的行为有所不同。在CLOUD模式下，引擎假定所有事实和事件都是事先已知的（没有时间流的概念），因此，否定模式会立即得到评估。</strong></strong></p><p><strong><strong>在STREAM模式下运行时，具有时间限制的否定模式可能要求引擎在激活规则之前等待一段时间。该时间段由引擎以用户无需使用任何技巧即可获得所需结果的方式自动计算。</strong></strong></p><p><strong><strong>例如：</strong></strong></p><div class="example"><strong><strong><a id="d0e12689"></a><p class="title"><strong>示例9.1匹配后立即激活的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( ) )
then
    // sound the alarm
end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>上面的规则没有需要延迟规则的时间约束，因此规则立即激活。另一方面，以下规则在激活前必须等待10秒钟，因为喷淋头最多可能需要10秒钟才能激活：</p><div class="example"><a id="d0e12696"></a><p class="title"><strong>示例9.2由于时间限制而自动延迟激活的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</code></pre></div></div><br class="example-break"><p>当同时处理否定模式和时间约束时，此行为可使引擎保持一致性。上面的内容与下面的编写规则相同，但是不会给用户增加计算和显式编写适当的duration参数的负担：</p><div class="example"><a id="d0e12703"></a><p class="title"><strong>示例9.3具有明确持续时间参数的相同规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
    duration( 10s )
when
    $f : FireDetected( )
    not( SprinklerActivated( this after[0s,10s] $f ) )
then
    // sound the alarm
end</code></pre></div></div><br class="example-break"><p>以下规则要求每10秒至少发生一次“心跳”事件，否则将触发该规则。此规则的特殊情况是，我们在第一个模式和否定模式中使用相同类型的对象。负模式具有时间限制，要在触发前等待0到10秒，并且排除绑定到$ h的心跳。排除绑定的心跳非常重要，因为时间约束[0s，...]本身并不排除绑定事件$ h被再次匹配，从而阻止了规则触发。</p><div class="example"><a id="d0e12710"></a><p class="title"><strong>示例9.4排除负面事件的约束事件</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm"
when
    $h: Heartbeat( ) from entry-point "MonitoringStream"
    not( Heartbeat( this != $h, this after[0s,10s] $h ) from entry-point "MonitoringStream" )
then
    // Sound the alarm
end</code></pre></div></div><br class="example-break"></strong></strong></div></div></div><div class="section" title="9.5。会话时钟"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12715"></a> 9.5。会话时钟</strong></strong></h2></div></div></div><p><strong><strong>随着时间的流逝需要一个参考时钟。仅举一个例子，如果规则超过了过去60分钟内给定股票的平均价格，那么引擎如何知道过去60分钟内发生了什么股价变化以计算平均值？明显的响应是：通过将事件的时间戳与“当前时间”进行比较。引擎如何知道<span class="bold"><strong>现在</strong></span>几点？同样，很明显，通过查询会话时钟。</strong></strong></p><p><strong><strong>会话时钟实现了一种策略模式，允许引擎插入和使用不同类型的时钟。这非常重要，因为引擎可能在可能需要不同时钟实现的不同场景的元素中运行。仅举几例：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong>规则测试：</strong></span>测试始终需要受控的环境，并且当测试包含具有时间限制的规则时，不仅需要控制输入规则和事实，还必须控制时间流。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>定期执行：</strong></span>通常，在生产中运行规则时，应用程序将需要一个实时时钟，该时钟可使规则引擎立即对时间进度做出反应。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>特殊环境：</strong></span>特定环境可能对时间控制有特定要求。群集环境可能需要通过心跳进行时钟同步，或者JEE环境可能需要使用AppServer提供的时钟等。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>规则重播或模拟：</strong></span>要重播场景或模拟场景，应用程序还必须控制时间流。</strong></strong></p></li></ul></div><div class="section" title="9.5.1。可用时钟实现"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12746"></a> 9.5.1。可用时钟实现</strong></strong></h3></div></div></div><p><strong><strong>Drools 5提供了两种开箱即用的时钟实现。基于系统时钟的默认实时时钟，以及由应用程序控制的可选伪时钟。</strong></strong></p><div class="section" title="9.5.1.1。实时时钟"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e12751"></a> 9.5.1.1。实时时钟</strong></strong></h4></div></div></div><p><strong><strong>默认情况下，Drools使用实时时钟实现，该实现在内部使用系统时钟来确定当前时间戳。</strong></strong></p><p><strong><strong>要将引擎显式配置为使用实时时钟，只需将会话配置参数设置为实时：</strong></strong></p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
</code></pre></div><div class="section" title="9.5.1.2。伪时钟"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e12760"></a> 9.5.1.2。伪时钟</strong></strong></h4></div></div></div><p><strong><strong>Drools还提供了开箱即用的时钟实现，该时钟由应用程序控制，称为“伪时钟”。该时钟对于单元测试时间规则特别有用，因为它可以由应用程序控制，因此结果变得确定。</strong></strong></p><p><strong><strong>要配置伪会话时钟，请执行以下操作：</strong></strong></p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );</code></pre><p><strong><strong>作为如何控制伪会话时钟的示例：</strong></strong></p><pre><code class="language-java">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( ClockTypeOption.get( "pseudo" ) );
KieSession session = kbase.newKieSession( conf, null );
        
SessionPseudoClock clock = session.getSessionClock();

// then, while inserting facts, advance the clock as necessary:
FactHandle handle1 = session.insert( tick1 );
clock.advanceTime( 10, TimeUnit.SECONDS );
FactHandle handle2 = session.insert( tick2 );
clock.advanceTime( 30, TimeUnit.SECONDS );
FactHandle handle3 = session.insert( tick3 );

</code></pre></div></div></div><div class="section" title="9.6。滑动窗"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12773"></a> 9.6。滑动窗</strong></strong></h2></div></div></div><p><strong><strong>滑动窗口是一种通过定义不断移动的窗口来确定感兴趣事件范围的方法。滑动窗口实现的两种最常见类型是基于时间的窗口和基于长度的窗口。</strong></strong></p><p><strong><strong>下一节将详细介绍它们。</strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>只有在STREAM模式下运行引擎时，才可以使用滑动Windows。查看“事件处理模式”部分，以获取有关STREAM模式工作方式的详细信息。</strong></strong></p></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>滑动窗口开始立即匹配，并且定义滑动窗口并不意味着规则必须等待滑动窗口“满”才能匹配。例如，计算window：length（10）上事件属性平均值的规则将立即开始计算平均值，无事件将从0（零）开始，并在事件到达时更新平均值逐一。</strong></strong></p></div><div class="section" title="9.6.1。滑动时间窗"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12786"></a> 9.6.1。滑动时间窗</strong></strong></h3></div></div></div><p><strong><strong>滑动时间窗口允许用户编写仅匹配最近X个时间单位中发生的事件的规则。</strong></strong></p><p><strong><strong>例如，如果用户只想考虑最近2分钟内发生的“股票报价”，则模式如下所示：</strong></strong></p><pre><code class="no-highlight">StockTick() over window:time( 2m )</code></pre><p><strong><strong>Drools使用“ over”关键字将窗口关联到模式。</strong></strong></p><p><strong><strong>在一个更详细的示例中，如果用户希望在从传感器读取的最近10分钟内的平均温度高于阈值的情况下发出警报，则规则如下所示：</strong></strong></p><div class="example"><strong><strong><a id="d0e12799"></a><p class="title"><strong>示例9.5在时间范围内汇总值</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:time( 10m ),
        average( $temp ) )
then
    // sound the alarm
end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>引擎将自动忽略任何超过10分钟的SensorReading，并保持计算出的平均值一致。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>请注意，在计算事件在过期之前仍在工作存储器中保留的时间间隔时，会考虑基于时间的窗口，但是事件从滑动窗口中脱落并不意味着事件本身会从工作存储器中丢弃，因为这可能取决于该事件的其他规则。仅当没有其他规则依赖该事件并且满足该事件类型的过期策略时，引擎才会丢弃事件。</p></div></strong></strong></div><div class="section" title="9.6.2。滑动长度窗"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12809"></a> 9.6.2。滑动长度窗</strong></strong></h3></div></div></div><p><strong><strong>“滑动长度”窗口的工作方式与“时间窗口”相同，但根据事件在会话中的插入顺序而不是时间流来考虑事件。</strong></strong></p><p><strong><strong>例如，如果用户只考虑最近的10个RHT股票报价，而与它们的年龄无关，则模式如下所示：</strong></strong></p><pre><code class="no-highlight">StockTick( company == "RHT" ) over window:length( 10 )</code></pre><p><strong><strong>如您所见，该模式与上一节中介绍的模式类似，但是它没有使用window：time定义滑动窗口，而是使用window：length。</strong></strong></p><p><strong><strong>使用与上一部分类似的示例，如果用户希望在传感器的最近100个读数上的平均温度高于阈值的情况下发出警报，则规则如下所示：</strong></strong></p><div class="example"><strong><strong><a id="d0e12822"></a><p class="title"><strong>示例9.6在长度窗口上汇总值</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Sound the alarm in case temperature rises above threshold"
when
    TemperatureThreshold( $max : max )
    Number( doubleValue &gt; $max ) from accumulate(
        SensorReading( $temp : temperature ) over window:length( 100 ),
        average( $temp ) )
then
    // sound the alarm
end</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>引擎将仅考虑最近的100个读数来计算平均温度。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>请注意，脱离基于长度的窗口不是会话中事件到期的标准。引擎在计算窗口时会忽略掉掉窗口的事件，但不会仅根据该条件从会话中删除事件，因为可能还有其他规则依赖于该事件。</p></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>请注意，基于长度的窗口没有为会话中的事件过期定义时间限制，引擎不会考虑它们。如果事件没有其他定义时间约束的规则，也没有明确的到期策略，则引擎将无限期地将其保留在会话中。</p></div><p>使用滑动窗口时，将在考虑窗口之前评估alpha约束，但是之后将评估beta（联接）约束。在考虑时间窗口时，这通常没有什么区别，但是在使用长度窗口时很重要。例如此模式：</p><pre><code class="no-highlight">StockTick( company == "RHT" ) over window:length( 10 )</code></pre><p>定义一个（最多）10个股票提示的窗口，所有股票提示的公司都等于“ RHT”，而以下窗口则：</p><pre><code class="no-highlight">$s : String()
StockTick( company == $s ) over window:length( 10 )</code></pre><p>首先创建一个（最多）10个股票标题的窗口，而不管其公司属性的值如何，然后仅在其中筛选公司名称等于从工作内存中选择的字符串的股票标题。</p></strong></strong></div><div class="section" title="9.6.3。窗口声明"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12845"></a> 9.6.3。窗口声明</strong></strong></h3></div></div></div><p><strong><strong>该引擎还支持Windows的声明。这促进了在应用于窗口的过滤器和应用于窗口结果的约束之间的明确区分。它还允许在多个规则之间轻松重用窗口。</strong></strong></p><p><strong><strong>另一个好处是引擎中基本窗口支持的新实现，从而提高了使用滑动窗口的规则的整体性能。</strong></strong></p><p><strong><strong>声明窗口的简化EBNF为：</strong></strong></p><pre><code class="no-highlight">windowDeclaration := DECLARE WINDOW ID annotation* lhsPatternBind END</code></pre><p><strong><strong>例如，可以定义仅包含来自给定来源的最后10个股票报价的窗口，如下所示：</strong></strong></p><pre><code class="no-highlight">declare window Ticks
    StockTick( source == "NYSE" )
        over window:length( 10 )
        from entry-point STStream
end</code></pre><p><strong><strong>然后，规则可以通过将其用作FROM的来源来使用此声明的窗口，如下所示：</strong></strong></p><pre><code class="no-highlight">rule "RHT ticks in the window"
    when
        accumulate( StockTick( company == "RHT" ) from window Ticks,
                    $cnt : count(1) )
    then
        // there has been $cnt RHT ticks over the last 10 ticks
end</code></pre><p><strong><strong>请注意，此示例还演示了窗口声明如何允许将应用于窗口的约束（仅包含“ NYSE”作为源的StockTicks包含在窗口中的10个事件中）和应用于窗口结果的约束（在最后一个事件中）仅选择10个以“ NYSE”作为来源的事件（公司名称等于“ RHT”的事件）。</strong></strong></p></div></div><div class="section" title="9.7。流支持"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12866"></a> 9.7。流支持</strong></strong></h2></div></div></div><p><strong><strong>大多数CEP用例必须处理事件流。流可以以各种形式（从JMS队列到纯文本文件，从数据库表到原始套接字，甚至通过Web服务调用）提供给应用程序。在任何情况下，流都具有一组共同的特征：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>流中的事件按时间戳排序。对于不同的流，时间戳可能具有不同的语义，但始终在内部对其进行排序。</strong></strong></p></li><li class="listitem"><p><strong><strong>事件数量通常很高。</strong></strong></p></li><li class="listitem"><p><strong><strong>原子事件本身很少有用。通常，从流以及其他来源的多个事件之间的相关性中提取含义。</strong></strong></p></li><li class="listitem"><p><strong><strong>流可以是同质的，即包含单一类型的事件，也可以是异质的，即包含多种类型的事件。</strong></strong></p></li></ul></div><p><strong><strong>Drools将流的概念概括为引擎的“入口”。一个入口是流口水事实的大门。事实可以是常规事实，也可以是特殊事实，例如事件。</strong></strong></p><p><strong><strong>在Drools中，来自一个入口点（流）的事实可能与来自任何其他入口点或事件的事实以及来自工作内存的事实结合在一起。尽管它们从不混合，也就是说，它们从不丢失对进入引擎的入口点的引用。这很重要，因为通过多个入口点进入引擎可能具有相同类型的事实，但是通过入口点A插入引擎中的一个事实将永远不会匹配例如来自入口点B的模式。</strong></strong></p><div class="section" title="9.7.1。声明和使用入口点"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12888"></a> 9.7.1。声明和使用入口点</strong></strong></h3></div></div></div><p><strong><strong>通过在规则中直接使用入口点在Drools中隐式声明。即，在规则中引用入口点将使引擎在编译时识别并创建适当的内部结构以支持该入口点。</strong></strong></p><p><strong><strong>因此，例如，假设有一个银行应用程序，其中交易是从流中输入到系统中的。流之一包含在ATM机中执行的所有事务。因此，如果其中一条规则说：仅当帐户余额超过所要求的提款金额时，才允许提款，该规则如下所示：</strong></strong></p><div class="example"><strong><strong><a id="d0e12895"></a><p class="title"><strong>示例9.7流使用示例</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "authorize withdraw"
when
    WithdrawRequest( $ai : accountId, $am : amount ) from entry-point "ATM Stream"
    CheckingAccount( accountId == $ai, balance &gt; $am )
then
    // authorize withdraw
end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>在前面的示例中，引擎编译器将识别出该模式已绑定到入口点“ ATM流”，并且将为规则库创建所有必要的结构以支持“ ATM流”，并且只会匹配来自“ ATM流”。在前面的示例中，规则还将流中的事件与主工作内存中的事实（CheckingAccount）结合在一起。</p><p>现在，让我们想象第二条规则，该规则规定对在银行分行提出提款请求的任何帐户必须收取2美元的费用：</p><div class="example"><a id="d0e12904"></a><p class="title"><strong>示例9.8使用其他流</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "apply fee on withdraws on branches"
when
    WithdrawRequest( $ai : accountId, processed == true ) from entry-point "Branch Stream"
    CheckingAccount( accountId == $ai )
then
    // apply a $2 fee on the account
end
</code></pre></div></div><br class="example-break"><p>先前的规则将匹配与第一条规则（WithdrawRequest）完全相同类型的事件，但是来自两个不同的流，因此插入到“ ATM流”中的事件将永远不会根据第二条规则的模式进行评估它只对“分支流”中的模式感兴趣。</p><p>因此，入口点不仅是对流的适当抽象，而且还是一种在工作内存中确定事实范围的方法，并且是减少跨产品爆炸的有价值的工具。但这是另一个话题。</p><p>将事件插入入口点同样简单。与其将事件直接插入工作存储器中，不如将其插入入口点，如下例所示：</p><div class="example"><a id="d0e12915"></a><p class="title"><strong>示例9.9将事实插入切入点</strong></p><div class="example-contents"><pre><code class="language-java">// create your rulebase and your session as usual
KieSession session = ...

// get a reference to the entry point
EntryPoint atmStream = session.getEntryPoint( "ATM Stream" );

// and start inserting your facts into the entry point
atmStream.insert( aWithdrawRequest );
</code></pre></div></div><br class="example-break"><p>前面的示例显示了如何将事实手动插入给定的入口点。尽管通常情况下，应用程序将使用许多适配器之一将流端点（如JMS队列）直接插入引擎入口点，而无需手动编码插入。Drools管道API具有多个适配器和帮助程序来做到这一点，以及有关如何执行此操作的示例。</p></strong></strong></div></div><div class="section" title="9.8。事件的内存管理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12922"></a> 9.8。事件的内存管理</strong></strong></h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>仅在STREAM模式下运行引擎时，才会执行事件的自动内存管理。查看“事件处理模式”部分，以获取有关STREAM模式工作方式的详细信息。</strong></strong></p></div><p><strong><strong>在STREAM模式下运行引擎的好处之一是，引擎可以检测到事件由于其时间限制而不再与任何规则匹配的时间。发生这种情况时，引擎可以安全地从会话中删除事件而没有副作用，并释放该事件使用的任何资源。</strong></strong></p><p><strong><strong>引擎基本上有2种方法来计算给定事件的匹配窗口：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>明确地，使用到期策略</strong></strong></p></li><li class="listitem"><p><strong><strong>隐式地分析事件的时间约束</strong></strong></p></li></ul></div><p></p><div class="section" title="9.8.1。显式过期偏移"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12940"></a> 9.8.1。显式过期偏移</strong></strong></h3></div></div></div><p><strong><strong>允许引擎为给定事件类型计算关注窗口的第一种方法是通过显式设置它。为此，只需使用clarify语句并为事实类型定义到期时间：</strong></strong></p><div class="example"><strong><strong><a id="d0e12945"></a><p class="title"><strong>示例9.10为StockTick事件明确定义30分钟的到期时间偏移</strong></p><div class="example-contents"><pre><code class="no-highlight">declare StockTick
    @expires( 30m )
end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>上面的示例声明了StockTick事件的30分钟过期偏移。在那之后，假设没有规则仍然需要该事件，则引擎将过期并自动从会话中删除该事件。</p><p>
    </p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>给定事件类型的显式过期策略将覆盖该相同类型的任何推断的过期偏移。</p></div><p>
  </p></strong></strong></div><div class="section" title="9.8.2。推断的过期时间偏移"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e12958"></a> 9.8.2。推断的过期时间偏移</strong></strong></h3></div></div></div><p><strong><strong>引擎针对给定事件计算过期偏移的另一种方法是通过分析规则中的时间约束来隐式地进行计算。例如，给定以下规则：</strong></strong></p><div class="example"><strong><strong><a id="d0e12963"></a><p class="title"><strong>示例9.11具有时间约束的示例规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "correlate orders"
when
    $bo : BuyOrderEvent( $id : id ) 
    $ae : AckEvent( id == $id, this after[0,10s] $bo )
then
    // do something
end
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>分析上述规则，引擎会自动计算出，每当BuyOrderEvent匹配时，它需要将其存储最多10秒钟，以等待与AckEvent匹配。因此，BuyOrderEvent的隐式过期偏移为10秒。另一方面，AckEvent只能与现有的BuyOrderEvent匹配，因此其到期时间偏移为零秒。</p><p>引擎将对整个规则库进行分析，并找到每种事件类型的偏移量。</p><p>
        </p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2>重要</h2><p>给定事件类型的显式过期策略将覆盖该相同类型的任何推断的过期偏移。</p></div><p>
    </p></strong></strong></div></div><div class="section" title="9.9。时间推理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e12978"></a> 9.9。时间推理</strong></strong></h2></div></div></div><p><strong><strong>时间推理是任何CEP系统的另一个要求。如前所述，事件的显着特征之一是事件之间的牢固时间关系。</strong></strong></p><p><strong><strong>时间推理是一个广泛的研究领域，从其起源于时间模态逻辑到其在业务系统中的更实际应用。有数百篇论文和论文以及针对几种应用的方法进行了描述。Drools再次基于多种来源采取务实而简单的方法，但特别值得注意的是以下论文：</strong></strong></p><div class="bibliolist"><div class="biblioentry" title="基于时间间隔的时间知识表示"><strong><strong><a id="d0e12987"></a><p>[ <abbr class="abbrev">ALLEN81</abbr> ] <span class="author">JF艾伦。</span><span class="title"><em>基于时间间隔的时间知识表示</em> 。</span><span class="pubdate">1981年。</span></p></strong></strong></div><div class="biblioentry" title="维护有关时间间隔的知识"><strong><strong><a id="d0e12998"></a><p>[ <abbr class="abbrev">ALLEN83</abbr> ] <span class="author">JF艾伦。</span><span class="title"><em>保持关于时间间隔的知识</em> 。</span><span class="pubdate">1983年。</span></p></strong></strong></div><div class="biblioentry" title="时间和事件的统一语义"><strong><strong><a id="d0e13009"></a><p>[ <abbr class="abbrev">BENNE00</abbr> ] <span class="authorgroup">Bennet，Brandon和Galton，Antony P ..</span><span class="title"><em>时间与事件的统一语义学</em> 。</span><span class="pubdate">2005。</span></p></strong></strong></div><div class="biblioentry" title="混合网络环境中时间和空间上事件关联的统一语义"><strong><strong><a id="d0e13024"></a><p>[ <abbr class="abbrev">YONEK05</abbr> ] <abbr class="abbrev">Yikoki</abbr> <span class="authorgroup">，Eiko和Bacon，Jean。</span><span class="title"><em>混合网络环境下时空事件关联的统一语义</em> 。</span><span class="pubdate">2005。</span></p></strong></strong></div></div><p><strong><strong>Drools实现了Allen描述的基于间隔的时间事件语义，并将时间点事件表示为持续时间为0（零）的基于间隔的偶数。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>对于所有时间运算符间隔，“ *”（星号）符号用于表示<span class="emphasis"><em>正无穷大</em></span> ，而“-*”（负星号）用于表示<span class="emphasis"><em>负无穷大</em></span> 。</strong></strong></p></div><div class="section" title="9.9.1。时间运算符"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13050"></a> 9.9.1。时间运算符</strong></strong></h3></div></div></div><p><strong><strong>Drools实现Allen定义的所有13个运算符以及它们的逻辑补码（取反）。本节详细介绍了每个运算符及其参数。</strong></strong></p><div class="section" title="9.9.1.1。后"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13055"></a> 9.9.1.1。后</strong></strong></h4></div></div></div><p><strong><strong>后评估器关联两个事件，并在从当前事件到关联事件的时间距离属于为操作员声明的距离范围时进行匹配。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this after[ 3m30s, 4m ] $eventB ) </code></pre><p><strong><strong>当且仅当$ eventB完成的时间与$ eventA开始的时间之间的时间距离在（3分钟至30秒）和（4分钟）之间时，上一个模式才会匹配。换一种说法：</strong></strong></p><pre><code class="no-highlight"> 3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m </code></pre><p><strong><strong>after运算符的时间距离间隔是可选的：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值（如下面的示例所示），则间隔从第一个值开始，在第二个值结束。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果仅定义一个值，则间隔从该值开始并以正无穷大结束。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果未定义任何值，则假定初始值为1ms，最终值为正无穷大。</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>可以为此操作员定义负距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) </code></pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>如果第一值大于第二值，则引擎会自动将其反转，因为没有理由使第一值大于第二值。示例：以下两种模式被认为具有相同的语义：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this after[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this after[ -2m, -3m30s ] $eventB ) </code></pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong><span class="emphasis"><em>after</em></span> ， <span class="emphasis"><em>before</em></span>和<span class="emphasis"><em>巧合</em></span>运算符可用于定义事件java.util之间的约束。日期属性和长属性（自时代以来解释为时间戳）任意组合。例：</strong></strong></p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.2。之前"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13104"></a> 9.9.1.2。之前</strong></strong></h4></div></div></div><p><strong><strong>事前评估器将两个事件关联起来，并在从事件关联到当前关联的事件的时间距离属于为操作员声明的距离范围时匹配。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this before[ 3m30s, 4m ] $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA完成的时间与$ eventB开始的时间之间的时间距离在（3分钟至30秒）和（4分钟）之间时，先前的模式才匹配。换一种说法：</strong></strong></p><pre><code class="no-highlight"> 3m30s &lt;= $eventB.startTimestamp - $eventA.endTimeStamp &lt;= 4m </code></pre><p><strong><strong>before运算符的时间距离间隔是可选的：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值（如下面的示例所示），则间隔从第一个值开始，在第二个值结束。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果仅定义一个值，则间隔从该值开始并在正无穷大处结束。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果未定义任何值，则假定初始值为1ms，最终值为正无穷大。</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>可以为此操作员定义负距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) </code></pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>如果第一值大于第二值，则引擎会自动将其反转，因为没有理由使第一值大于第二值。示例：以下两种模式被认为具有相同的语义：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this before[ -3m30s, -2m ] $eventB ) 
$eventA : EventA( this before[ -2m, -3m30s ] $eventB ) </code></pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong><span class="emphasis"><em>after</em></span> ， <span class="emphasis"><em>before</em></span>和<span class="emphasis"><em>巧合</em></span>运算符可用于定义事件java.util之间的约束。日期属性和长属性（自时代以来解释为时间戳）任意组合。例：</strong></strong></p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.3。巧合"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13153"></a> 9.9.1.3。巧合</strong></strong></h4></div></div></div><p><strong><strong>符合评估器将两个事件关联，并且两个事件同时发生时进行匹配。可选地，评估者接受事件开始时间戳和结束时间戳之间的距离阈值。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this coincides $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA和$ eventB的开始时间戳相同且$ eventA和$ eventB的结束时间戳相同时，上一个模式才会匹配。</strong></strong></p><p><strong><strong>（可选）此运算符接受一个或两个参数。这些参数是匹配时间戳之间的距离的阈值。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果仅给出一个参数，则该参数将同时用于开始和结束时间戳记。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果给出了两个参数，则第一个用作开始时间戳的阈值，第二个用作结束时间戳的阈值。</strong></strong></p></li></ul></div><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this coincides[15s, 10s] $eventB ) </code></pre><p><strong><strong>只有在以下情况下，上述模式才匹配：</strong></strong></p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 15s &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 10s </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发错误。</strong></strong></p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong><span class="emphasis"><em>after</em></span> ， <span class="emphasis"><em>before</em></span>和<span class="emphasis"><em>巧合</em></span>运算符可用于定义事件java.util之间的约束。日期属性和长属性（自时代以来解释为时间戳）任意组合。例：</strong></strong></p><pre><code class="no-highlight">EventA( this after $someDate )</code></pre></div></div><div class="section" title="9.9.1.4。中"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13198"></a> 9.9.1.4。中</strong></strong></h4></div></div></div><p><strong><strong>期间评估器关联两个事件，并在关联事件发生期间当前事件发生时进行匹配。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this during $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA在$ eventB开始之后开始并在$ eventB完成之前结束时，先前的模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt;= $eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p><strong><strong>期间运算符接受1、2或4个可选参数，如下所示：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了一个值，这将是两个事件的开始时间戳之间的最大距离与两个事件的结束时间戳之间的最大距离，以便与操作员匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this during[ 5s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">0 &lt; $eventA.startTimestamp - $eventB.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventB.endTimestamp - $eventA.endTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值，则第一个值将是两个事件的时间戳之间的最小距离，而第二个值将是两个事件的时间戳之间的最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this during[ 5s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">5s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了四个值，则前两个值将是两个事件的开始时间戳之间的最小和最大距离，而后两个值将是两个事件的结束时间戳之间的最小和最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this during[ 2s, 6s, 4s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">2s &lt;= $eventA.startTimestamp - $eventB.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventB.endTimestamp - $eventA.endTimestamp &lt;= 10s</code></pre></li></ul></div></div><div class="section" title="9.9.1.5。饰面"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13245"></a> 9.9.1.5。饰面</strong></strong></h4></div></div></div><p><strong><strong>Finishes评估程序将两个事件相关联，并在相关事件的开始时间戳记之后发生当前事件的开始时间戳记时进行匹配，但是两个结束时间戳记都同时发生。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this finishes $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA在$ eventB开始并在$ eventB完成的同时结束后，$ eventA开始时，先前的模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </code></pre><p><strong><strong>Finishes评估程序接受一个可选参数。如果已定义，它将确定两个事件的结束时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this finishes[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div><div class="section" title="9.9.1.6。完成者"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13271"></a> 9.9.1.6。完成者</strong></strong></h4></div></div></div><p><strong><strong>finishby评估程序将两个事件相关联，并在当前事件开始时间戳记发生在相关事件开始时间戳记之前发生匹配，但是两个结束时间戳记都同时发生。这是涂饰评估师的对立面。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this finishedby $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA在$ eventB开始并在$ eventB完成的同时结束时才与前一个模式匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp == $eventB.endTimestamp </code></pre><p><strong><strong>finishby评估程序接受一个可选参数。如果已定义，它将确定两个事件的结束时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this finishedby[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &amp;&amp; 
abs( $eventA.endTimestamp - $eventB.endTimestamp ) &lt;= 5s </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div><div class="section" title="9.9.1.7。包括"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13297"></a> 9.9.1.7。包括</strong></strong></h4></div></div></div><p><strong><strong>包含评估程序将两个事件关联起来，并在当前事件期间发生关联事件时进行匹配。它是评估程序期间的对称对立面。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this includes $eventB ) </code></pre><p><strong><strong>当且仅当$ eventB在$ eventA开始之后开始并在$ eventA完成之前结束时，先前的模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt;= $eventB.endTimestamp &lt; $eventA.endTimestamp </code></pre><p><strong><strong>include运算符接受1、2或4个可选参数，如下所示：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了一个值，这将是两个事件的开始时间戳之间的最大距离与两个事件的结束时间戳之间的最大距离，以便与操作员匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this includes[ 5s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">0 &lt; $eventB.startTimestamp - $eventA.startTimestamp &lt;= 5s &amp;&amp; 
0 &lt; $eventA.endTimestamp - $eventB.endTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值，则第一个值将是两个事件的时间戳之间的最小距离，而第二个值将是两个事件的时间戳之间的最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this includes[ 5s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">5s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 10s &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了四个值，则前两个值将是两个事件的开始时间戳之间的最小和最大距离，而后两个值将是两个事件的结束时间戳之间的最小和最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this includes[ 2s, 6s, 4s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">2s &lt;= $eventB.startTimestamp - $eventA.startTimestamp &lt;= 6s &amp;&amp; 
4s &lt;= $eventA.endTimestamp - $eventB.endTimestamp &lt;= 10s </code></pre></li></ul></div></div><div class="section" title="9.9.1.8。遇见"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13344"></a> 9.9.1.8。遇见</strong></strong></h4></div></div></div><p><strong><strong>当当前事件的结束时间戳记与相关事件的开始时间戳记同时发生时，遇见评估器将两个事件关联起来并进行匹配。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this meets $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA同时启动$ eventB时，上一个模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">abs( $eventB.startTimestamp - $eventA.endTimestamp ) == 0 </code></pre><p><strong><strong>mets评估程序接受一个可选参数。如果已定义，它将确定当前事件的结束时间戳与相关事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this meets[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">abs( $eventB.startTimestamp - $eventA.endTimestamp) &lt;= 5s </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div><div class="section" title="9.9.1.9。遇见"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13370"></a> 9.9.1.9。遇见</strong></strong></h4></div></div></div><p><strong><strong>metby评估程序将两个事件关联起来，并在当前事件的开始时间戳记与关联事件的结束时间戳记同时发生时进行匹配。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this metby $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA在$ eventB完成的同时开始时，上一个模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.endTimestamp ) == 0 </code></pre><p><strong><strong>metby评估程序接受一个可选参数。如果已定义，它将确定相关事件的结束时间戳与当前事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this metby[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.endTimestamp) &lt;= 5s </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div><div class="section" title="9.9.1.10。重叠"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13396"></a> 9.9.1.10。重叠</strong></strong></h4></div></div></div><p><strong><strong>重叠评估器将两个事件关联起来，并在关联事件开始之前的当前事件开始时进行匹配，并在关联事件开始之后但关联事件结束之前完成关联。换句话说，两个事件都有一个重叠的时期。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlaps $eventB ) </code></pre><p><strong><strong>只有在以下情况下，上一个模式才会匹配：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p><strong><strong>重叠运算符接受1或2个可选参数，如下所示：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了一个参数，则这将是相关事件的开始时间戳与当前事件的结束时间戳之间的最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlaps[ 5s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
0 &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值，则第一个值将是相关事件的开始时间戳和当前事件的结束时间戳之间的最小距离，而第二个值将是最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlaps[ 5s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp &lt; $eventB.startTimestamp &lt; $eventA.endTimestamp &lt; $eventB.endTimestamp &amp;&amp; 
5s &lt;= $eventA.endTimestamp - $eventB.startTimestamp &lt;= 10s </code></pre></li></ul></div></div><div class="section" title="9.9.1.11。重叠者"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13431"></a> 9.9.1.11。重叠者</strong></strong></h4></div></div></div><p><strong><strong>overlaypedby评估程序会关联两个事件，并在相关事件在当前事件开始之前开始时匹配，并且在当前事件开始之后但在当前事件结束之前完成时匹配。换句话说，两个事件都有一个重叠的时期。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlappedby $eventB ) </code></pre><p><strong><strong>只有在以下情况下，上一个模式才会匹配：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp </code></pre><p><strong><strong>overlaypedby运算符接受1或2个可选参数，如下所示：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了一个参数，这将是当前事件的开始时间戳与相关事件的结束时间戳之间的最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlappedby[ 5s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
0 &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 5s</code></pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果定义了两个值，则第一个值将是当前事件的开始时间戳和相关事件的结束时间戳之间的最小距离，而第二个值将是最大距离。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this overlappedby[ 5s, 10s ] $eventB )</code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">$eventB.startTimestamp &lt; $eventA.startTimestamp &lt; $eventB.endTimestamp &lt; $eventA.endTimestamp &amp;&amp; 
5s &lt;= $eventB.endTimestamp - $eventA.startTimestamp &lt;= 10s</code></pre></li></ul></div><p></p></div><div class="section" title="9.9.1.12。开始"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13467"></a> 9.9.1.12。开始</strong></strong></h4></div></div></div><p><strong><strong>当当前事件的结束时间戳记在相关事件的结束时间戳记之前发生时，开始评估程序会关联两个事件并进行匹配，但是两个开始时间戳记都同时发生。</strong></strong></p><p><strong><strong>让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this starts $eventB ) </code></pre><p><strong><strong>当且仅当$ eventA在$ eventB完成并在$ eventB开始的同时开始时，先前的模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><p><strong><strong>启动评估程序接受一个可选参数。如果已定义，它将确定两个事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this starts[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &lt; $eventB.endTimestamp </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div><div class="section" title="9.9.1.13。开始于"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13493"></a> 9.9.1.13。开始于</strong></strong></h4></div></div></div><p><strong><strong>当相关事件的结束时间戳记发生在当前事件的结束时间戳记之前，startedby评估程序将两个事件进行关联并进行匹配，但是两个开始时间戳记都同时发生。让我们看一个例子：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this startedby $eventB ) </code></pre><p><strong><strong>当且仅当$ eventB在$ eventA完成并在$ eventB开始的同时开始之前，先前的模式才匹配。</strong></strong></p><p><strong><strong>换一种说法：</strong></strong></p><pre><code class="no-highlight">$eventA.startTimestamp == $eventB.startTimestamp &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </code></pre><p><strong><strong>startsby评估程序接受一个可选参数。如果已定义，它将确定两个事件的开始时间戳之间的最大距离，以便操作员进行匹配。例：</strong></strong></p><pre><code class="no-highlight">$eventA : EventA( this starts[ 5s ] $eventB ) </code></pre><p><strong><strong>仅在以下情况下匹配：</strong></strong></p><pre><code class="no-highlight">abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s &amp;&amp; 
$eventA.endTimestamp &gt; $eventB.endTimestamp </code></pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>对参数使用负的间隔值是没有意义的，如果发生这种情况，引擎将引发异常。</strong></strong></p></div></div></div></div></div><div class="chapter" title="第十章实验特征"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ExperimentalFeaturesChapter"></a>第十章实验特征</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e13520">10.1。声明性议程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13581">10.2。使用OOPath浏览对象图</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13688">10.2.1。反应式和非反应式OOPath</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="10.1。声明性议程"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e13520"></a> 10.1。声明性议程</strong></strong></h2></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>声明式议程是实验性的，将来所有方面都可能发生变化。@Eager和@Direct是临时注释，用于控制规则的行为，随着声明式议程的发展，它们也会发生变化。注解而不是属性，以反映其实验性质。</strong></strong></p></div><p><strong><strong>声明式议程允许使用规则控制哪些其他规则可以触发以及何时触发。虽然这将比简单使用显着性增加更多的开销，但优点是它是声明性的，因此更具可读性和可维护性，并且应允许以更简单的方式实现更多用例。</strong></strong></p><p><strong><strong>此功能默认情况下处于关闭状态，必须显式启用，这是因为该功能目前被认为是实验性的，并且可能会发生变化，但是可以通过在相应的KieBase上添加declarativeAgenda ='enabled'属性来激活该功能。 kmodule.xml文件的kbase标记，如以下示例所示。
  </strong></strong></p><div class="example"><strong><strong><a id="d0e13530"></a><p class="title"><strong>示例10.1启用声明性议程</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns="http://www.drools.org/xsd/kmodule"&gt;
      &lt;kbase name="DeclarativeKBase" declarativeAgenda="enabled"&gt;
      &lt;ksession name="KSession"&gt;
      &lt;/kbase&gt;
      &lt;/kmodule&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>基本思想是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>所有规则的匹配项都作为事实插入到WorkingMemory中。因此，您现在可以针对“匹配”进行模式匹配。规则的元数据和声明可作为Match对象上的字段使用。</p></li><li class="listitem"><p>您可以对当前规则使用kcontext.blockMatch（Match match）来阻止选定的匹配。只有当该规则变为假时，比赛才有资格被解雇。如果它已经符合触发条件并在以后被阻止，它将从议程中删除，直到被取消阻止为止。</p></li><li class="listitem"><p>一场比赛可能有多个阻止者，并且会保留一个计数。为了使计数器达到零，所有阻止程序都必须变为false，计数器才能触发。</p></li><li class="listitem"><p>kcontext.unblockAllMatches（Match match）是一个覆盖规则，它将删除所有阻止程序，无论</p></li><li class="listitem"><p>激活也可能被取消，因此它永远不会与cancelMatch一起触发</p></li><li class="listitem"><p>无障碍比赛将添加到议程中，并遵循正常的显着性，议程组，规则流组等。</p></li><li class="listitem"><p>@Direct批注允许规则在被匹配后立即触发，这将用于阻止/取消阻止匹配的规则，这些规则不希望有在其他地方产生影响的副作用。</p></li></ul></div><div class="example"><a id="d0e13559"></a><p class="title"><strong>示例10.2新的RuleContext方法</strong></p><div class="example-contents"><pre><code class="no-highlight">void blockMatch(Match match);
      void unblockAllMatches(Match match);
      void cancelMatch(Match match);</code></pre></div></div><br class="example-break"><p>这是一个基本示例，它将阻止来自具有元数据@department（'sales'）的规则的所有匹配。它们将一直处于阻塞状态，直到blockerAllSalesRules规则变为假，即“ go2”被收回。</p><div class="example"><a id="d0e13566"></a><p class="title"><strong>示例10.3根据规则元数据阻止规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule rule1 @Eager @department('sales') when
      $s : String( this == 'go1' )
      then
      list.add( kcontext.rule.name + ':' + $s );
      end
      rule rule2 @Eager @department('sales') when
      $s : String( this == 'go1' )
      then
      list.add( kcontext.rule.name + ':' + $s );
      end
      rule blockerAllSalesRules @Direct @Eager when
      $s : String( this == 'go2' )
      $i : Match( department == 'sales' )
      then
      list.add( $i.rule.name + ':' + $s  );
      kcontext.blockMatch( $i );
      end</code></pre></div></div><br class="example-break"><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>除了使用@Direct注释阻止规则之外，还必须使用@Eager注释所有可能被其阻止的规则。这是因为，由于必须通过阻止规则的模式匹配来评估匹配，因此不能懒惰地评估潜在被阻止的匹配，否则就不会是任何要评估的匹配。</p></div><p>本示例说明了如何使用active属性来计算活动或不活动（已触发）匹配的数量。</p><div class="example"><a id="d0e13576"></a><p class="title"><strong>示例10.4计算有效/无效匹配的数量</strong></p><div class="example-contents"><pre><code class="no-highlight">rule rule1 @Eager @department('sales') when
      $s : String( this == 'go1' )
      then
      list.add( kcontext.rule.name + ':' + $s );
      end
      rule rule2 @Eager @department('sales') when
      $s : String( this == 'go1' )
      then
      list.add( kcontext.rule.name + ':' + $s );
      end
      rule rule3 @Eager @department('sales') when
      $s : String( this == 'go1' )
      then
      list.add( kcontext.rule.name + ':' + $s );
      end
      rule countActivateInActive @Direct @Eager when
      $s : String( this == 'go2' )
      $active : Number( this == 1 ) from accumulate( $a : Match( department == 'sales', active == true ), count( $a ) )
      $inActive : Number( this == 2 ) from  accumulate( $a : Match( department == 'sales', active == false ), count( $a ) )
      then
      kcontext.halt( );
      end </code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="10.2。使用OOPath浏览对象图"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e13581"></a> 10.2。使用OOPath浏览对象图</strong></strong></h2></div></div></div><p><strong><strong>当事实的字段是一个集合时，可以使用<code class="literal">from</code>关键词。但是，当需要浏览对象图时，会广泛使用<code class="literal">from</code>条件元素可能会导致冗长而繁琐的语法，如以下示例所示：</strong></strong></p><div class="example"><strong><strong><a id="d0e13592"></a><p class="title"><strong>示例10.5浏览来自的对象图</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Find all grades for Big Data exam" when
      $student: Student( $plan: plan )
      $exam: Exam( course == "Big Data" ) from $plan.exams
      $grade: Grade() from $exam.grades
      then /* RHS */ end</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>在此示例中，假设使用的领域模型包括<code class="literal">Student</code>谁有一个<code class="literal">Plan</code>研究： <code class="literal">Plan</code>可以有零个或多个<code class="literal">Exam</code> s和<code class="literal">Exam</code>零或更多<code class="literal">Grade</code> s。请注意，只有图的根对象（ <code class="literal">Student</code>在这种情况下）必须位于工作存储器中才能正常工作。</p><p>通过从XPath借用思想，可以使此语法更加简洁，因为XPath具有紧凑的符号，可以在处理集合和过滤约束时浏览相关元素。这种受XPath启发的符号被称为<code class="literal">OOPath</code>因为它专门用于浏览对象图。使用此表示法，可以按如下方式重写前一个示例：</p><div class="example"><a id="d0e13625"></a><p class="title"><strong>示例10.6使用OOPath浏览对象图</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Find all grades for Big Data exam" when
      Student( $grade: /plan/exams{course == "Big Data"}/grades )
      then /* RHS */ end</code></pre></div></div><br class="example-break"><p>形式上，核心语法<code class="literal">OOPath</code>可以通过这种方式在EBNF表示法中定义表达式。</p><pre><code class="no-highlight">OOPExpr = ( "/" | "?/" ) OOPSegment { ( "/" | "?/" | "." ) OOPSegment } ;
    OOPSegment = [ID ( ":" | ":=" )] ID ["[" Number "]"] ["{" Constraints "}"];</code></pre><p>在实践中<code class="literal">OOPath</code>表达式具有以下功能。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>它必须以<code class="literal">/</code>或与<code class="literal">?/</code>如果是完全非反应性的OOPath（请参见下文）。</p></li><li class="listitem"><p>它可以通过以下方式取消引用对象的单个属性： <code class="literal">.</code>算子</p></li><li class="listitem"><p>它可以使用<code class="literal">/</code>操作员。如果返回一个集合，它将遍历该集合中的值</p></li><li class="listitem"><p>在遍历引用的对象时，它可以过滤掉不满足一个或多个约束的对象，它们写成大括号之间的谓词表达式，例如：</p><pre><code class="no-highlight">Student( $grade: /plan/exams{ course == "Big Data" }/grades )</code></pre></li><li class="listitem"><p>约束还可以引用当前迭代对象之前遍历的图形对象。例如以下OOPath：</p><pre><code class="no-highlight">Student( $grade: /plan/exams/grades{ result &gt; ../averageResult } )</code></pre><p>将仅匹配成绩高于通过考试平均水平的成绩。</p></li><li class="listitem"><p>约束也可以递归地成为另一个OOPath，如下所示：</p><pre><code class="no-highlight">Student( $exam: /plan/exams{ /grades{ result &gt; 20 } } )</code></pre></li><li class="listitem"><p>也可以通过将项目放在方括号之间来按其索引访问项目，例如：</p><pre><code class="no-highlight">Student( $grade: /plan/exams[0]/grades )</code></pre><p>为了遵守Java约定，与基于XPath 1的索引相比，OOPath索引的基于0的索引</p></li></ul></div><div class="section" title="10.2.1。反应式和非反应式OOPath"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13688"></a> 10.2.1。反应式和非反应式OOPath</h3></div></div></div><p>目前，Drools无法对包含评估过程中遍历的深层嵌套对象的更新做出反应。 <code class="literal">OOPath</code>表达。为了使这些对象对更改具有反应性，则有必要使它们扩展类<code class="literal">org.drools.core.phreak.ReactiveObject</code> 。计划通过实现一种自动检测属于特定域模型的类的机制来克服此限制。</p><p>通过扩展该类，域对象可以通过调用继承的方法来通知引擎其字段之一已更新。 <code class="literal">notifyModification</code>如以下示例所示：</p><div class="example"><a id="d0e13704"></a><p class="title"><strong>示例10.7通知引擎考试已移至其他课程</strong></p><div class="example-contents"><pre><code class="no-highlight">public void setCourse(String course) {
        this.course = course;
        notifyModification(this);
        }</code></pre></div></div><br class="example-break"><p>这样，在使用如下所示的OOPath时：</p><pre><code class="no-highlight">Student( $grade: /plan/exams{ course == "Big Data" }/grades )</code></pre><p>如果将考试移到其他课程，则重新触发该规则，并重新计算与该规则匹配的成绩列表。</p><p>也可能只在OOPath的一个子部分中具有反应性，如下所示：</p><pre><code class="no-highlight">Student( $grade: /plan/exams{ course == "Big Data" }?/grades )</code></pre><p>在这里，使用<code class="literal">?/</code>分隔符而不是<code class="literal">/</code>一个是，引擎将对对考试所做的更改做出反应，或者如果将考试添加到了计划中，但是如果对现有考试添加了新的成绩，则引擎不会做出反应。当然，如果OOPath块不是反应性的，则从那里到表达式结尾的所有OOPath其余部分也将是非反应性的。例如以下OOPath</p><pre><code class="no-highlight">Student( $grade: ?/plan/exams{ course == "Big Data" }/grades )</code></pre><p>将完全无反应。因此，不允许使用<code class="literal">?/</code>分隔符在同一OOPath中不止一次，所以表达式如下：</p><pre><code class="no-highlight">Student( $grade: /plan?/exams{ course == "Big Data" }?/grades )</code></pre><p>会导致编译时错误。</p></div></strong></strong></div></div></div><div class="part" title="第四部分流口水整合"><div class="titlepage"><div><div><h1 class="title"><strong><strong><a id="d0e13738"></a>第四部分流口水整合</strong></strong></h1></div></div></div><div class="partintro" title="流口水整合"><div></div><p><strong><strong>整合文件</strong></strong></p><div class="toc"><p><strong><strong><strong>目录</strong></strong></strong></p><dl><dt><strong><strong><span class="chapter"><a href="#ch.commands">11。流口水的命令</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#CommandsAPISection">11.1。API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13764">11.1.1。XStream的</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13780">11.1.2。JSON格式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13796">11.1.3。杰克斯</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e13824">11.2。支持的命令</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13904">11.2.1。BatchExecutionCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13972">11.2.2。InsertObjectCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14054">11.2.3。缩回命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14121">11.2.4。修改命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14188">11.2.5。GetObjectCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14256">11.2.6。InsertElementsCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14334">11.2.7。FireAllRulesCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14409">11.2.8。StartProcessCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14479">11.2.9。SignalEventCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14548">11.2.10。CompleteWorkItemCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14615">11.2.11。AbortWorkItemCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14676">11.2.12。QueryCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14748">11.2.13。SetGlobalCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14826">11.2.14。GetGlobalCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14894">11.2.15。GetObjectsCommand</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#CDIChapter">12CDI</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e14965">12.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14972">12.2。注解</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e14977">12.2.1。@KReleaseId</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14982">12.2.2。@KContainer</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15002">12.2.3。@KBase</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15029">12.2.4。KieSession的@KSession</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15056">12.2.5。@KSession用于StatelessKieSession</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e15083">12.3。API示例比较</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="chapter"><a href="#ch.kie.spring">13与Spring整合</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e15103">13.1。Drools 6.0的重要更改</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15157">13.2。与Drools Expert集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e15165">13.2.1。KieModule</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15212">13.2.2。凯基</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15312">13.2.3。重要的提示</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15337">13.2.4。KieSessions</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15425">13.2.5。凯：ReleaseId</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15482">13.2.6。凯：进口</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15565">13.2.7。注解</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15688">13.2.8。事件监听器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15844">13.2.9。记录仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15933">13.2.10。定义批处理命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16013">13.2.11。坚持不懈</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16043">13.2.12。利用其他Spring功能</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e16083">13.3。与jBPM人工任务集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16088">13.3.1。如何使用jBPM人工任务配置Spring</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#ch.kie.android">14。Android整合</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16206">14.1。与Drools Expert集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16214">14.1.1。预序列化规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16242">14.1.2。具有drools-compiler依赖性的KieContainer API</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e16257">14.2。与Roboguice集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16260">14.2.1。Roboguice的预序列化规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16290">14.2.2。具有流口水编译器依赖性和Roboguice的KieContainer</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#ch.camel">15Apache Camel集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16370">15.1。骆驼</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="chapter"><a href="#ch.server">16。Drools骆驼服务器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16423">16.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16428">16.2。部署方式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16433">16.3。组态</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16473">16.3.1。REST /骆驼服务配置</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#RHQChapter">17。带有RHQ / JON的JMX监视</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16550">17.1。介绍</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16555">17.1.1。在Drools应用程序中启用JMX监视</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16574">17.1.2。安装并运行RHQ / JON插件</a></span></strong></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第十一章流口水的命令"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.commands"></a>第十一章流口水的命令</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#CommandsAPISection">11.1。API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13764">11.1.1。XStream的</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13780">11.1.2。JSON格式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13796">11.1.3。杰克斯</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e13824">11.2。支持的命令</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e13904">11.2.1。BatchExecutionCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e13972">11.2.2。InsertObjectCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14054">11.2.3。缩回命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14121">11.2.4。修改命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14188">11.2.5。GetObjectCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14256">11.2.6。InsertElementsCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14334">11.2.7。FireAllRulesCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14409">11.2.8。StartProcessCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14479">11.2.9。SignalEventCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14548">11.2.10。CompleteWorkItemCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14615">11.2.11。AbortWorkItemCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14676">11.2.12。QueryCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14748">11.2.13。SetGlobalCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14826">11.2.14。GetGlobalCommand</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14894">11.2.15。GetObjectsCommand</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="11.1。API"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="CommandsAPISection"></a> 11.1。API</strong></strong></h2></div></div></div><p><strong><strong>Drools命令的XML编组/解组需要使用特殊的类，以下各节将对此进行描述。</strong></strong></p><p><strong><strong>以下网址显示了使用以下命令进行jaxb，xstream和json编组的示例脚本示例：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/jaxb.mvt?r=HEAD</strong></strong></p></li><li class="listitem"><p><strong><strong>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/jaxb.mvt?r=HEAD</strong></strong></p></li><li class="listitem"><p><strong><strong>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/xstream.mvt?r=HEAD</strong></strong></p></li></ul></div><div class="section" title="11.1.1。XStream的"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13764"></a> 11.1.1。XStream的</strong></strong></h3></div></div></div><p><strong><strong>要使用XStream命令编组，您需要使用DroolsHelperProvider获得XStream实例。我们需要使用它，因为它已注册了命令转换器。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>编组</strong></strong></p><p><strong><strong>BatchExecutionHelperProviderImpl.newXStreamMarshaller（）。toXML（command）;</strong></strong></p></li><li class="listitem"><p><strong><strong>解组</strong></strong></p><p><strong><strong>BatchExecutionHelperProviderImpl.newXStreamMarshaller（）。fromXML（xml）</strong></strong></p></li></ul></div></div><div class="section" title="11.1.2。JSON格式"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13780"></a> 11.1.2。JSON格式</strong></strong></h3></div></div></div><p><strong><strong>编组/解组的JSON API与XStream API相似：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>编组</strong></strong></p><p><strong><strong>BatchExecutionHelper.newJSonMarshaller（）。toXML（command）;</strong></strong></p></li><li class="listitem"><p><strong><strong>解组</strong></strong></p><p><strong><strong>BatchExecutionHelper.newJSonMarshaller（）。fromXML（xml）</strong></strong></p></li></ul></div></div><div class="section" title="11.1.3。杰克斯"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13796"></a> 11.1.3。杰克斯</strong></strong></h3></div></div></div><p><strong><strong>使用JAXB有两种选择，您可以在XSD文件中定义模型，也可以拥有POJO模型。在这两种情况下，您都必须在JAXBContext中声明模型，并且为此，您需要使用Drools Helper类。拥有JAXBContext后，需要根据需要创建Unmarshaller / Marshaller。</strong></strong></p><div class="section" title="11.1.3.1。使用XSD文件定义模型"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13801"></a> 11.1.3.1。使用XSD文件定义模型</strong></strong></h4></div></div></div><p><strong><strong>在XSD文件中定义模型后，您需要具有一个将XSD模型添加为资源的知识库。</strong></strong></p><p><strong><strong>为此，必须将XSD文件作为XSD ResourceType添加到KnowledgeBuilder中。最后，您可以使用使用KnowledgeBuilder创建的KnowledgeBase创建JAXBContext。 </strong></strong></p><pre><code class="language-java">Options xjcOpts = new Options();
xjcOpts.setSchemaLanguage(Language.XMLSCHEMA);
JaxbConfiguration jaxbConfiguration = KnowledgeBuilderFactory.newJaxbConfiguration( xjcOpts, "xsd" );
kbuilder.add(ResourceFactory.newClassPathResource("person.xsd", getClass()), ResourceType.XSD, jaxbConfiguration);
KnowledgeBase kbase = kbuilder.newKnowledgeBase();

List&lt;String&gt; classesName = new ArrayList&lt;String&gt;();
classesName.add("org.drools.compiler.test.Person");
   
JAXBContext jaxbContext = KnowledgeBuilderHelper.newJAXBContext(classesName.toArray(new String[classesName.size()]), kbase);</code></pre></div><div class="section" title="11.1.3.2。使用POJO模型"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e13810"></a> 11.1.3.2。使用POJO模型</strong></strong></h4></div></div></div><p><strong><strong>在这种情况下，您需要使用DroolsJaxbHelperProviderImpl创建JAXBContext。此类具有两个参数：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>classNames：一个列表，其中包含要在编组/解组过程中使用的类的规范名称。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性：JAXB定制属性</strong></strong></p></li></ol></div><pre><code class="language-java">List&lt;String&gt; classNames = new ArrayList&lt;String&gt;();
classNames.add("org.drools.compiler.test.Person");
JAXBContext jaxbContext = DroolsJaxbHelperProviderImpl.createDroolsJaxbContext(classNames, null);
Marshaller marshaller = jaxbContext.createMarshaller();</code></pre></div></div></div><div class="section" title="11.2。支持的命令"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e13824"></a> 11.2。支持的命令</strong></strong></h2></div></div></div><p><strong><strong>当前，支持以下命令：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>BatchExecutionCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>InsertObjectCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>缩回命令</strong></strong></p></li><li class="listitem"><p><strong><strong>修改命令</strong></strong></p></li><li class="listitem"><p><strong><strong>GetObjectCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>InsertElementsCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>FireAllRulesCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>StartProcessCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>SignalEventCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>CompleteWorkItemCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>AbortWorkItemCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>QueryCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>SetGlobalCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>GetGlobalCommand</strong></strong></p></li><li class="listitem"><p><strong><strong>GetObjectsCommand</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>在下一个代码片段中，我们将使用具有两个字段的POJO org.drools.compiler.test.Person</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>名称：字符串</strong></strong></p></li><li class="listitem"><p><strong><strong>年龄：整数</strong></strong></p></li></ul></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>在下面的示例中，为了编组命令，我们使用了以下代码段代码：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-java">String xml = BatchExecutionHelper.newXStreamMarshaller().toXML(command);</code></pre></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="language-java">String xml = BatchExecutionHelper.newJSonMarshaller().toXML(command);</code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-java">Marshaller marshaller = jaxbContext.createMarshaller();
StringWriter xml = new StringWriter();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.marshal(command, xml);</code></pre></li></ul></div></div><div class="section" title="11.2.1。BatchExecutionCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13904"></a> 11.2.1。BatchExecutionCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：该命令包含将发送和执行的命令列表。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e13915"></a><p class="title"><strong>表11.1。BatchExecutionCommand属性</strong></p><div class="table-contents"><table border="1" summary="BatchExecutionCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">抬头</td><td>设置将在其上执行命令的知识会话ID</td><td>真正</td></tr><tr><td align="center">命令</td><td>要执行的命令列表</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
InsertObjectCommand insertObjectCommand = new InsertObjectCommand(new Person("john", 25));
FireAllRulesCommand fireAllRulesCommand = new FireAllRulesCommand();
command.getCommands().add(insertObjectCommand);
command.getCommands().add(fireAllRulesCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;insert&gt;
    &lt;org.drools.compiler.test.Person&gt;
      &lt;name&gt;john&lt;/name&gt;
      &lt;age&gt;25&lt;/age&gt;
    &lt;/org.drools.compiler.test.Person&gt;
  &lt;/insert&gt;
  &lt;fire-all-rules/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":[{"insert":{"object":{"org.drools.compiler.test.Person":{"name":"john","age":25}}}},{"fire-all-rules":""}]}} </code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;insert&gt;
        &lt;object xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
            &lt;age&gt;25&lt;/age&gt;
            &lt;name&gt;john&lt;/name&gt;
        &lt;/object&gt;
    &lt;/insert&gt;
    &lt;fire-all-rules max="-1"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.2。InsertObjectCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e13972"></a> 11.2.2。InsertObjectCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>描述：在知识会话中插入一个对象。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e13983"></a><p class="title"><strong>表11.2InsertObjectCommand属性</strong></p><div class="table-contents"><table border="1" summary="InsertObjectCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">宾语</td><td>要插入的对象</td><td>真正</td></tr><tr><td align="center">outIdentifier</td><td>标识在对象插入中创建并添加到执行结果中的FactHandle</td><td>假</td></tr><tr><td align="center">returnObject</td><td>用于确定是否必须在执行结果中返回对象的布尔值。默认值：true</td><td>假</td></tr><tr><td align="center">入口点</td><td>插入的入口点</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">List&lt;Command&gt; cmds = ArrayList&lt;Command&gt;();

Command insertObjectCommand = CommandFactory.newInsert(new Person("john", 25), "john", false, null);
cmds.add( insertObjectCommand );

BatchExecutionCommand command = CommandFactory.createBatchExecution(cmds, "ksession1" );
</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;insert out-identifier="john" entry-point="my stream" return-object="false"&gt;
    &lt;org.drools.compiler.test.Person&gt;
      &lt;name&gt;john&lt;/name&gt;
      &lt;age&gt;25&lt;/age&gt;
    &lt;/org.drools.compiler.test.Person&gt;
  &lt;/insert&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"insert":{"entry-point":"my stream", "out-identifier":"john","return-object":false,"object":{"org.drools.compiler.test.Person":{"name":"john","age":25}}}}}}
</code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;insert out-identifier="john" entry-point="my stream" &gt;
        &lt;object xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
            &lt;age&gt;25&lt;/age&gt;
            &lt;name&gt;john&lt;/name&gt;
        &lt;/object&gt;
    &lt;/insert&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.3。缩回命令"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14054"></a> 11.2.3。缩回命令</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：从知识会话中撤消对象。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14065"></a><p class="title"><strong>表11.3RetractCommand属性</strong></p><div class="table-contents"><table border="1" summary="RetractCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">处理</td><td>与要收回的对象关联的FactHandle</td><td>真正</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建：我们有两个选项，具有相同的输出结果：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>从字符串创建事实句柄</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
RetractCommand retractCommand = new RetractCommand();
retractCommand.setFactHandleFromString("123:234:345:456:567");
command.getCommands().add(retractCommand);</code></pre></li><li class="listitem"><p><strong><strong>设置插入对象时收到的事实句柄</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
RetractCommand retractCommand = new RetractCommand(factHandle);
command.getCommands().add(retractCommand);</code></pre></li></ol></div><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;retract fact-handle="0:234:345:456:567"/&gt;
&lt;/batch-execution&gt;</code></pre></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"retract":{"fact-handle":"0:234:345:456:567"}}}}</code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;retract fact-handle="0:234:345:456:567"/&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.4。修改命令"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14121"></a> 11.2.4。修改命令</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>描述：允许您修改知识会话中先前插入的对象。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14132"></a><p class="title"><strong>表11.4。ModifyCommand属性</strong></p><div class="table-contents"><table border="1" summary="ModifyCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">处理</td><td>与要收回的对象关联的FactHandle</td><td>真正</td></tr><tr><td align="center">二传手</td><td>setter对象的修改列表</td><td>真正</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
ModifyCommand modifyCommand = new ModifyCommand();
modifyCommand.setFactHandleFromString("123:234:345:456:567");
List&lt;Setter&gt; setters = new ArrayList&lt;Setter&gt;();
setters.add(new SetterImpl("age", "30"));
modifyCommand.setSetters(setters);
command.getCommands().add(modifyCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;modify fact-handle="0:234:345:456:567"&gt;
    &lt;set accessor="age" value="30"/&gt;
  &lt;/modify&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"modify":{"fact-handle":"0:234:345:456:567","setters":{"accessor":"age","value":30}}}}} </code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;modify fact-handle="0:234:345:456:567"&gt;
        &lt;set value="30" accessor="age"/&gt;
    &lt;/modify&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.5。GetObjectCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14188"></a> 11.2.5。GetObjectCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>描述：用于从知识会议中获取对象</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14199"></a><p class="title"><strong>表11.5。GetObjectCommand属性</strong></p><div class="table-contents"><table border="1" summary="GetObjectCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">factHandle</td><td>与要收回的对象关联的FactHandle</td><td>真正</td></tr><tr><td align="center">outIdentifier</td><td>标识在对象插入中创建并添加到执行结果中的FactHandle</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
GetObjectCommand getObjectCommand = new GetObjectCommand();
getObjectCommand.setFactHandleFromString("123:234:345:456:567");
getObjectCommand.setOutIdentifier("john");
command.getCommands().add(getObjectCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;get-object fact-handle="0:234:345:456:567" out-identifier="john"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"get-object":{"fact-handle":"0:234:345:456:567","out-identifier":"john"}}}}
</code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;get-object out-identifier="john" fact-handle="0:234:345:456:567"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.6。InsertElementsCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14256"></a> 11.2.6。InsertElementsCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：用于插入对象列表。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14267"></a><p class="title"><strong>表11.6。InsertElementsCommand属性</strong></p><div class="table-contents"><table border="1" summary="InsertElementsCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">对象</td><td>知识会话中要插入的对象列表</td><td>真正</td></tr><tr><td align="center">outIdentifier</td><td>标识在对象插入中创建并添加到执行结果中的FactHandle</td><td>假</td></tr><tr><td align="center">returnObject</td><td>用于确定是否必须在执行结果中返回对象的布尔值。默认值：true</td><td>假</td></tr><tr><td align="center">入口点</td><td>插入的入口点</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">List&lt;Command&gt; cmds = ArrayList&lt;Command&gt;();

List&lt;Object&gt; objects = new ArrayList&lt;Object&gt;();
objects.add(new Person("john", 25));
objects.add(new Person("sarah", 35));

Command insertElementsCommand = CommandFactory.newInsertElements( objects );
cmds.add( insertElementsCommand );

BatchExecutionCommand command = CommandFactory.createBatchExecution(cmds, "ksession1" );</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;insert-elements&gt;
    &lt;org.drools.compiler.test.Person&gt;
      &lt;name&gt;john&lt;/name&gt;
      &lt;age&gt;25&lt;/age&gt;
    &lt;/org.drools.compiler.test.Person&gt;
    &lt;org.drools.compiler.test.Person&gt;
      &lt;name&gt;sarah&lt;/name&gt;
      &lt;age&gt;35&lt;/age&gt;
    &lt;/org.drools.compiler.test.Person&gt;
  &lt;/insert-elements&gt;
&lt;/batch-execution&gt;</code></pre></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"insert-elements":{"objects":[{"containedObject":{"@class":"org.drools.compiler.test.Person","name":"john","age":25}},{"containedObject":{"@class":"Person","name":"sarah","age":35}}]}}}} </code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;insert-elements return-objects="true"&gt;
        &lt;list&gt;
            &lt;element xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;age&gt;25&lt;/age&gt;
                &lt;name&gt;john&lt;/name&gt;
            &lt;/element&gt;
            &lt;element xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;age&gt;35&lt;/age&gt;
                &lt;name&gt;sarah&lt;/name&gt;
            &lt;/element&gt;
        &lt;list&gt;
    &lt;/insert-elements&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div></div><div class="section" title="11.2.7。FireAllRulesCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14334"></a> 11.2.7。FireAllRulesCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：允许执行创建的规则激活。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14345"></a><p class="title"><strong>表11.7。FireAllRulesCommand属性</strong></p><div class="table-contents"><table border="1" summary="FireAllRulesCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">最高</td><td>要执行的最大规则激活数。默认值为-1，不会对执行施加任何限制</td><td>假</td></tr><tr><td align="center">outIdentifier</td><td>添加执行结果上触发的规则激活次数</td><td>假</td></tr><tr><td align="center">议程过滤器</td><td>允许使用议程过滤器执行规则</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
FireAllRulesCommand fireAllRulesCommand = new FireAllRulesCommand();
fireAllRulesCommand.setMax(10);
fireAllRulesCommand.setOutIdentifier("firedActivations");
command.getCommands().add(fireAllRulesCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;fire-all-rules max="10" out-identifier="firedActivations"/&gt;
&lt;/batch-execution&gt;
</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"fire-all-rules":{"max":10,"out-identifier":"firedActivations"}}}}</code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
   &lt;fire-all-rules out-identifier="firedActivations" max="10"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.8。StartProcessCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14409"></a> 11.2.8。StartProcessCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：允许您使用ID启动进程。您也可以传递参数和要插入的初始数据。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14420"></a><p class="title"><strong>表11.8。StartProcessCommand属性</strong></p><div class="table-contents"><table border="1" summary="StartProcessCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">processId</td><td>要启动的进程的ID</td><td>真正</td></tr><tr><td align="center">参数</td><td><string, object="">在流程启动时传递参数</string,>的Map</td><td>假</td></tr><tr><td align="center">数据</td><td>在流程启动之前要在知识会话中插入的对象列表</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
StartProcessCommand startProcessCommand = new StartProcessCommand();
startProcessCommand.setProcessId("org.drools.task.processOne");
command.getCommands().add(startProcessCommand);</code></pre></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;start-process processId="org.drools.task.processOne"/&gt;
&lt;/batch-execution&gt;</code></pre></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"start-process":{"process-id":"org.drools.task.processOne"}}}} </code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;start-process processId="org.drools.task.processOne"&gt;
        &lt;parameter/&gt;
    &lt;/start-process&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div></div><div class="section" title="11.2.9。SignalEventCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14479"></a> 11.2.9。SignalEventCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：发送信号事件。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14490"></a><p class="title"><strong>表11.9。SignalEventCommand属性</strong></p><div class="table-contents"><table border="1" summary="SignalEventCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">事件类型</td><td> </td><td>真正</td></tr><tr><td align="center">processInstanceId</td><td> </td><td>假</td></tr><tr><td align="center">事件</td><td> </td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
SignalEventCommand signalEventCommand = new SignalEventCommand();
signalEventCommand.setProcessInstanceId(1001);
signalEventCommand.setEventType("start");
signalEventCommand.setEvent(new Person("john", 25));
command.getCommands().add(signalEventCommand);</code></pre></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;signal-event process-instance-id="1001" event-type="start"&gt;
    &lt;org.drools.pipeline.camel.Person&gt;
      &lt;name&gt;john&lt;/name&gt;
      &lt;age&gt;25&lt;/age&gt;
    &lt;/org.drools.pipeline.camel.Person&gt;
  &lt;/signal-event&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"signal-event":{"process-instance-id":1001,"@event-type":"start","event-type":"start","object":{"org.drools.pipeline.camel.Person":{"name":"john","age":25}}}}}}</code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;signal-event event-type="start" process-instance-id="1001"&gt;
        &lt;event xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
            &lt;age&gt;25&lt;/age&gt;
            &lt;name&gt;john&lt;/name&gt;
        &lt;/event&gt;
    &lt;/signal-event&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.10。CompleteWorkItemCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14548"></a> 11.2.10。CompleteWorkItemCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>描述：允许您完成一个工作项。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14559"></a><p class="title"><strong>表11.10。CompleteWorkItemCommand属性</strong></p><div class="table-contents"><table border="1" summary="CompleteWorkItemCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">workItemId</td><td>要完成的工作项的ID</td><td>真正</td></tr><tr><td align="center">结果</td><td> </td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();
completeWorkItemCommand.setWorkItemId(1001);
command.getCommands().add(completeWorkItemCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;complete-work-item id="1001"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"complete-work-item":{"id":1001}}}} </code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;complete-work-item id="1001"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.11。AbortWorkItemCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14615"></a> 11.2.11。AbortWorkItemCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>描述：允许您中止工作项。与session.getWorkItemManager（）。abortWorkItem（workItemId）相同</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14626"></a><p class="title"><strong>表11.11。AbortWorkItemCommand属性</strong></p><div class="table-contents"><table border="1" summary="AbortWorkItemCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">workItemId</td><td>要完成的工作项的ID</td><td>真正</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
AbortWorkItemCommand abortWorkItemCommand = new AbortWorkItemCommand();
abortWorkItemCommand.setWorkItemId(1001);
command.getCommands().add(abortWorkItemCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;abort-work-item id="1001"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"abort-work-item":{"id":1001}}}} </code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;abort-work-item id="1001"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.12。QueryCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14676"></a> 11.2.12。QueryCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：执行在知识库中定义的查询。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14687"></a><p class="title"><strong>表11.12。QueryCommand属性</strong></p><div class="table-contents"><table border="1" summary="QueryCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">名称</td><td>查询名称</td><td>真正</td></tr><tr><td align="center">outIdentifier</td><td>查询结果的标识符。查询结果将使用此标识符添加到执行结果中</td><td>假</td></tr><tr><td align="center">论点</td><td>要作为查询参数传递的对象列表</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
QueryCommand queryCommand = new QueryCommand();
queryCommand.setName("persons");
queryCommand.setOutIdentifier("persons");
command.getCommands().add(queryCommand);</code></pre></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;query out-identifier="persons" name="persons"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"query":{"out-identifier":"persons","name":"persons"}}}} </code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;query name="persons" out-identifier="persons"/&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.13。SetGlobalCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14748"></a> 11.2.13。SetGlobalCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：允许您设置全局。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14759"></a><p class="title"><strong>表11.13。SetGlobalCommand属性</strong></p><div class="table-contents"><table border="1" summary="SetGlobalCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">识别码</td><td>知识库中定义的全局标识符</td><td>真正</td></tr><tr><td align="center">宾语</td><td>要设置为全局的对象</td><td>假</td></tr><tr><td align="center">出</td><td>将设置的全局结果添加或不添加到执行结果中的布尔值</td><td>假</td></tr><tr><td align="center">outIdentifier</td><td>全局执行结果的标识符</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
SetGlobalCommand setGlobalCommand = new SetGlobalCommand();
setGlobalCommand.setIdentifier("helper");
setGlobalCommand.setObject(new Person("kyle", 30));
setGlobalCommand.setOut(true);
setGlobalCommand.setOutIdentifier("output");
command.getCommands().add(setGlobalCommand);</code></pre></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;set-global identifier="helper" out-identifier="output"&gt;
    &lt;org.drools.compiler.test.Person&gt;
      &lt;name&gt;kyle&lt;/name&gt;
      &lt;age&gt;30&lt;/age&gt;
    &lt;/org.drools.compiler.test.Person&gt;
  &lt;/set-global&gt;
&lt;/batch-execution&gt;</code></pre></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"set-global":{"identifier":"helper","out-identifier":"output","object":{"org.drools.compiler.test.Person":{"name":"kyle","age":30}}}}}}</code></pre></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;set-global out="true" out-identifier="output" identifier="helper"&gt;
        &lt;object xsi:type="person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
            &lt;age&gt;30&lt;/age&gt;
            &lt;name&gt;kyle&lt;/name&gt;
        &lt;/object&gt;
    &lt;/set-global&gt;
&lt;/batch-execution&gt;</code></pre></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.14。GetGlobalCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14826"></a> 11.2.14。GetGlobalCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：允许您获取先前定义的全局变量。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14837"></a><p class="title"><strong>表11.14。GetGlobalCommand属性</strong></p><div class="table-contents"><table border="1" summary="GetGlobalCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">识别码</td><td>知识库中定义的全局标识符</td><td>真正</td></tr><tr><td align="center">outIdentifier</td><td>执行结果中使用的标识符</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
GetGlobalCommand getGlobalCommand = new GetGlobalCommand();
getGlobalCommand.setIdentifier("helper");
getGlobalCommand.setOutIdentifier("helperOutput");
command.getCommands().add(getGlobalCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;get-global identifier="helper" out-identifier="helperOutput"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"get-global":{"identifier":"helper","out-identifier":"helperOutput"}}}} </code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;get-global out-identifier="helperOutput" identifier="helper"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div><div class="section" title="11.2.15。GetObjectsCommand"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14894"></a> 11.2.15。GetObjectsCommand</strong></strong></h3></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>说明：将当前会话中的所有对象作为集合返回。</strong></strong></p></li><li class="listitem"><p><strong><strong>属性</strong></strong></p><div class="table"><strong><strong><a id="d0e14905"></a><p class="title"><strong>表11.15。GetObjectsCommand属性</strong></p><div class="table-contents"><table border="1" summary="GetObjectsCommand attributes"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="center">objectFilter</td><td>一个ObjectFilter来过滤当前会话返回的对象</td><td>假</td></tr><tr><td align="center">outIdentifier</td><td>执行结果中使用的标识符</td><td>假</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></li><li class="listitem"><p><strong><strong>命令创建</strong></strong></p><pre><code class="language-java">BatchExecutionCommand command = new BatchExecutionCommand();
command.setLookup("ksession1");
GetObjectsCommand getObjectsCommand = new GetObjectsCommand();
getObjectsCommand.setOutIdentifier("objects");
command.getCommands().add(getObjectsCommand);</code></pre><p></p></li><li class="listitem"><p><strong><strong>XML输出</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>XStream的</strong></strong></p><pre><code class="language-xml">&lt;batch-execution lookup="ksession1"&gt;
  &lt;get-objects out-identifier="objects"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li><li class="listitem"><p><strong><strong>JSON格式</strong></strong></p><pre><code class="no-highlight">{"batch-execution":{"lookup":"ksession1","commands":{"get-objects":{"out-identifier":"objects"}}}}</code></pre><p></p></li><li class="listitem"><p><strong><strong>杰克斯</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="ksession1"&gt;
    &lt;get-objects out-identifier="objects"/&gt;
&lt;/batch-execution&gt;</code></pre><p></p></li></ul></div></li></ul></div><p></p></div></div></div><div class="chapter" title="第十二章CDI"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="CDIChapter"></a>第十二章CDI</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e14965">12.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14972">12.2。注解</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e14977">12.2.1。@KReleaseId</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e14982">12.2.2。@KContainer</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15002">12.2.3。@KBase</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15029">12.2.4。KieSession的@KSession</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15056">12.2.5。@KSession用于StatelessKieSession</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e15083">12.3。API示例比较</a></span></strong></strong></dt></dl></div><div class="section" title="12.1。介绍"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e14965"></a> 12.1。介绍</strong></strong></h2></div></div></div><p><strong><strong><a class="link" href="http://www.cdi-spec.org">CDI</a> （上下文和依赖注入）是Java规范，它为应用程序提供声明性控件和结构。KIE可以使用它来自动实例化和绑定事物，而无需使用编程API。</strong></strong></p></div><div class="section" title="12.2。注解"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e14972"></a> 12.2。注解</strong></strong></h2></div></div></div><p><strong><strong>@ KContainer，@ KBase和@KSession均支持可选的“名称”属性。CDI通常在注入时执行“ getOrCreate”，所有注入针对同一组注解接收相同的实例。 “名称”注释会为每个名称强制一个唯一的实例，尽管该名称的所有实例都将具有相同的身份。</strong></strong></p><div class="section" title="12.2.1。@KReleaseId"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14977"></a> 12.2.1。@KReleaseId</strong></strong></h3></div></div></div><p><strong><strong>用于将实例绑定到KieModule的特定版本。如果kie-ci在类路径中，它将自动解决依赖关系，并从远程存储库下载。</strong></strong></p></div><div class="section" title="12.2.2。@KContainer"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e14982"></a> 12.2.2。@KContainer</strong></strong></h3></div></div></div><p><strong><strong>@KContainer是可选的，因为可以通过使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><div class="figure"><strong><strong><a id="d0e14987"></a><p class="title"><strong>图12.1注入Classpath KieContainer</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieContainer kContainer;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e14992"></a><p class="title"><strong>图12.2。为动态KieModule注入KieContainer</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KReleaseId(groupId = "jar1", artifactId = "art1", version = "1.1")
private KieContainer kContainer;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e14997"></a><p class="title"><strong>图12.3为动态KieModule注入名为KieContainer的对象</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KContainer(name = "kc1")
@KReleaseId(groupId = "jar1", artifactId = "art1", version = "1.1")
private KieContainer kContainer;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="12.2.3。@KBase"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15002"></a> 12.2.3。@KBase</strong></strong></h3></div></div></div><p><strong><strong>@KBase是可选的，因为可以通过使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieBase的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15009"></a><p class="title"><strong>图12.4。从类路径KieContainer注入默认的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieBase kbase;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15014"></a><p class="title"><strong>图12.5。从动态KieModule注入默认的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")   
private KieBase kbase;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15019"></a><p class="title"><strong>图12.6。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KBase("kbase1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieBase kbase1v10;

@Inject
@KBase("kbase1") 
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.1")
private KieBase kbase1v10;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15024"></a><p class="title"><strong>图12.7。使用“名称”属性将新实例强制为“ jar1”。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession(value="kbase1", name="kb1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieBase kbase1kb1;

@Inject  
@KSession(value="kbase1", name="kb2")    
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieBase kbase1kb2;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="12.2.4。KieSession的@KSession"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15029"></a> 12.2.4。KieSession的@KSession</strong></strong></h3></div></div></div><p><strong><strong>@KSession是可选的，因为可以使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15036"></a><p class="title"><strong>图12.8。从类路径KieContainer注入默认KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15041"></a><p class="title"><strong>图12.9。从动态KieModule注入默认的KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")   
private KieSession ksession;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15046"></a><p class="title"><strong>图12.10。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksessionv10;

@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.1")
private KieSession ksessionv11;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15051"></a><p class="title"><strong>图12.11。使用“名称”属性将新实例强制为“ jar1”。KBase1'KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession(value="ksession1", name="ks1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession1ks1

@Inject  
@KSession(value="ksession1", name="ks2")    
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession1ks2</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="12.2.5。@KSession用于StatelessKieSession"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15056"></a> 12.2.5。@KSession用于StatelessKieSession</strong></strong></h3></div></div></div><p><strong><strong>@KSession是可选的，因为可以使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15063"></a><p class="title"><strong>图12.12。从类路径KieContainer注入默认的StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private StatelessKieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15068"></a><p class="title"><strong>图12.13。从动态KieModule注入默认的StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")   
private StatelessKieSession ksession;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15073"></a><p class="title"><strong>图12.14。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.0")
private StatelessKieSession ksessionv10;

@Inject
@KSession("ksession1") 
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.1")
private StatelessKieSession ksessionv11;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15078"></a><p class="title"><strong>图12.15。使用“名称”属性将新实例强制为“ jar1”。KBase1'StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession(value="ksession1", name="ks1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private StatelessKieSession ksession1ks1

@Inject  
@KSession(value="ksession1", name="ks2")    
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private StatelessKieSession ksession1ks2</code></pre></div></div><br class="figure-break"></strong></strong></div></div><div class="section" title="12.3。API示例比较"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e15083"></a> 12.3。API示例比较</strong></strong></h2></div></div></div><p><strong><strong>CDI可以将实例注入字段，甚至可以将其作为参数传递。在此示例中，使用了场注入。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15088"></a><p class="title"><strong>图12.16。名为KieSession的CDI示例</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1")
KieSession kSession;

public void go(PrintStream out) {
    kSession.setGlobal("out", out);
    kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
    kSession.fireAllRules();
}</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><p>与API方法相比，此代码更少，更具声明性。</p><div class="figure"><a id="d0e15095"></a><p class="title"><strong>图12.17。名为KieSession的API等效示例</strong></p><div class="figure-contents"><pre><code class="language-java">public void go(PrintStream out) {
    KieServices ks = KieServices.Factory.get();
    KieContainer kContainer = ks.getKieClasspathContainer();

    KieSession kSession = kContainer.newKieSession("ksession1");
    kSession.setGlobal("out", out);
    kSession.insert(new Message("Dave", "Hello, HAL. Do you read me, HAL?"));
    kSession.fireAllRules();
}</code></pre></div></div><br class="figure-break"></strong></strong></div></div><div class="chapter" title="第十三章与Spring整合"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.kie.spring"></a>第十三章与Spring整合</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e15103">13.1。Drools 6.0的重要更改</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15157">13.2。与Drools Expert集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e15165">13.2.1。KieModule</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15212">13.2.2。凯基</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15312">13.2.3。重要的提示</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15337">13.2.4。KieSessions</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15425">13.2.5。凯：ReleaseId</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15482">13.2.6。凯：进口</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15565">13.2.7。注解</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15688">13.2.8。事件监听器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15844">13.2.9。记录仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e15933">13.2.10。定义批处理命令</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16013">13.2.11。坚持不懈</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16043">13.2.12。利用其他Spring功能</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e16083">13.3。与jBPM人工任务集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16088">13.3.1。如何使用jBPM人工任务配置Spring</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="13.1。Drools 6.0的重要更改"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e15103"></a> 13.1。Drools 6.0的重要更改</strong></strong></h2></div></div></div><p><strong><strong>Drools Spring集成已对Drools 6.0的更改进行了完整的内联转换。以下是一些主要更改</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>Drools Spring的建议前缀已从“ drools：”更改为“ kie：”</strong></strong></p></li><li class="listitem"><p><strong><strong>6.0中的新顶级标签</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>kie：kmodule</strong></strong></p></li><li class="listitem"><p><strong><strong>kie：import（从6.2版开始）</strong></strong></p></li><li class="listitem"><p><strong><strong>kie：releaseId（从6.2版开始）</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>以下标签不再作为顶级标签有效。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>kie：kbase- <span class="emphasis"><em>kie：kmodule</em></span>标记的<span class="emphasis"><em>子代</em></span> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>kie：ksession- <span class="emphasis"><em>kie：kbase</em></span>标记的<span class="emphasis"><em>子代</em></span> 。</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>从以前的版本Drools 5.x中删除标签</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>流口水：资源</strong></strong></p></li><li class="listitem"><p><strong><strong>流口水：资源</strong></strong></p></li><li class="listitem"><p><strong><strong>流口水：网格</strong></strong></p></li><li class="listitem"><p><strong><strong>流口水：网格节点</strong></strong></p></li></ul></div></li></ul></div></div><div class="section" title="13.2。与Drools Expert集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e15157"></a> 13.2。与Drools Expert集成</strong></strong></h2></div></div></div><p><strong><strong>在本节中，我们将解释<span class="emphasis"><em>kie</em></span>命名空间。</strong></strong></p><div class="section" title="13.2.1。KieModule"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15165"></a> 13.2.1。KieModule</strong></strong></h3></div></div></div><p><strong><strong>
      </strong></strong></p><p><strong><strong>的<span class="emphasis"><em><kie:kmodule></kie:kmodule></em></span>定义KieBase和相关KieSession的集合。<span class="emphasis"><em>kmodule</em></span>标记具有一个MANDATORY参数“ id”。</strong></strong></p><div class="table"><strong><strong><a id="d0e15178"></a><p class="title"><strong>表13.1。样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">Bean的<span class="emphasis"><em>ID</em></span>是要从其他Bean引用的名称。标准Spring ID语义适用。</td><td align="left">是</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><p><span class="emphasis"><em>kmodule</em></span>标记只能包含以下标记作为子标记。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>kie：kbase</p></li></ul></div><p>有关对kmodule需求的详细说明，请参阅Drools Expert文档中的kmodule.xml文档。</p></strong></strong></div><div class="section" title="13.2.2。凯基"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15212"></a> 13.2.2。凯基</strong></strong></h3></div></div></div><div class="section" title="13.2.2.1。 <kie：kbase>的参数作为属性："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15215"></a> 13.2.2.1。 <kie:kbase>的参数作为属性：</kie:kbase></strong></strong></h4></div></div></div><div class="table"><strong><strong><a id="d0e15218"></a><p class="title"><strong>表13.2样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="left">名称</td><td align="left">KieBase的名称</td><td align="left">是</td></tr><tr><td align="left">包装</td><td align="left">用逗号分隔的要包含在此kbase中的资源包列表</td><td align="left">没有</td></tr><tr><td align="left">包括</td><td align="left">要包括的kbase名称。来自相应kbase的所有资源都包含在此kbase中。</td><td align="left">没有</td></tr><tr><td align="left">默认</td><td align="left">布尔值（TRUE / FALSE）。默认的kbase，如果未提供，则假定为FALSE</td><td align="left">没有</td></tr><tr><td align="left">范围</td><td align="left">原型|单身人士。如果未提供，则假定为单例（默认）</td><td align="left">没有</td></tr><tr><td align="left">eventProcessingMode</td><td align="left">事件处理模式。有效选项是STREAM，CLOUD</td><td align="left">没有</td></tr><tr><td align="left">等于行为</td><td align="left">有效选项是IDENTITY，EQUALITY</td><td align="left">没有</td></tr><tr><td align="left">声明性议程</td><td align="left">有效选项启用，禁用，true，false</td><td align="left">没有</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></div><div class="section" title="13.2.2.2。kbase标记只能包含以下标记作为子标记。"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15287"></a> 13.2.2.2。<span class="emphasis"><em>kbase</em></span>标记只能包含以下标记作为子标记。</strong></strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>kie：ksession</strong></strong></p></li></ul></div></div><div class="section" title="13.2.2.3。 <kie：kbase>的定义示例"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15297"></a> 13.2.2.3。 <kie:kbase>的定义示例</kie:kbase></strong></strong></h4></div></div></div><p><strong><strong>一个kmodule可以包含多个（1..n）kbase元素。</strong></strong></p><div class="example"><strong><strong><a id="d0e15302"></a><p class="title"><strong>示例13.1 kbase定义示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="sample_module"&gt;
   &lt;kie:kbase name="kbase1" packages="org.drools.spring.sample"&gt;
     ...
   &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="13.2.2.4。Spring Bean范围（用于KieBase和KieSession）"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15307"></a> 13.2.2.4。Spring Bean范围（用于KieBase和KieSession）</strong></strong></h4></div></div></div><p><strong><strong>定义KieBase或KieSession时，可以选择声明该bean的作用域。例如，要强制Spring每次需要一个新的bean实例时，应将bean的scope属性声明为'prototype'。如果希望Spring每次需要返回相同的bean实例时，以类似的方式，则应将bean的scope属性声明为'singleton'。
        </strong></strong></p></div></div><div class="section" title="13.2.3。重要的提示"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15312"></a> 13.2.3。重要的提示</strong></strong></h3></div></div></div><p><strong><strong>为了正确初始化kmodule对象（kbase / ksession），对于类型为的Bean是强制性的<code class="code">org.kie.spring.KModuleBeanFactoryPostProcessor</code>要么<code class="code">org.kie.spring.annotations.KModuleAnnotationPostProcessor</code>被定义。</strong></strong></p><div class="example"><strong><strong><a id="d0e15323"></a><p class="title"><strong>示例13.2常规Kie-Spring Post ProcessorBean定义</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p></p><div class="example"><a id="d0e15329"></a><p class="title"><strong>示例13.3使用注解时的kie-spring后处理器bean定义</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="kiePostProcessor"
          class="org.kie.spring.annotations.KModuleAnnotationPostProcessor"/&gt;</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>没有org.kie.spring。KModuleBeanFactoryPostProcessor或org.kie.spring.annotations。如果使用KModuleAnnotationPostProcessor bean定义，则kie-spring集成将无法正常工作。</p></div></strong></strong></div><div class="section" title="13.2.4。KieSessions"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15337"></a> 13.2.4。KieSessions</strong></strong></h3></div></div></div><p><strong><strong><kie:ksession>元素定义KieSessions。相同的标记用于定义两个有状态（ <span class="emphasis"><em>org.kie.api.runtime。KieSession</em></span> ）和无状态（ <span class="emphasis"><em>org.kie.api.runtime。StatelessKieSession</em></span> ）会话。</kie:ksession></strong></strong></p><div class="section" title="13.2.4.1。 <kie：ksession>的参数作为属性："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15348"></a> 13.2.4.1。 <kie:ksession>的参数作为属性：</kie:ksession></strong></strong></h4></div></div></div><div class="table"><strong><strong><a id="d0e15351"></a><p class="title"><strong>表13.3样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="left">名称</td><td align="left">ksession的名称。</td><td align="left">是</td></tr><tr><td align="left">类型</td><td align="left">会话是<span class="emphasis"><em>有状态</em></span>还是<span class="emphasis"><em>无状态？</em></span> 。如果此属性为空或丢失，则假定该会话为有状态类型。</td><td align="left">没有</td></tr><tr><td align="left">默认</td><td align="left">这是默认会话吗？</td><td align="left">没有</td></tr><tr><td align="left">范围</td><td align="left">原型|单身人士。如果未提供，则假定为单例（默认）</td><td align="left">没有</td></tr><tr><td align="left">clockType</td><td align="left">实时或伪</td><td align="left">没有</td></tr><tr><td align="left">听众参考</td><td align="left">指定对事件侦听器组的引用（请参阅下面的<a class="link" href="#kie-grouping-listeners" title="13.2.8.2. Defining a Group of listeners:">“定义</a>侦听器组<a class="link" href="#kie-grouping-listeners" title="13.2.8.2。定义一组侦听器：">”</a>部分）。</td><td align="left">没有</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="example"><a id="d0e15415"></a><p class="title"><strong>示例13.4 ksession定义示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="sample-kmodule"&gt;
  &lt;kie:kbase name="drl_kiesample3" packages="drl_kiesample3"&gt;
    &lt;kie:ksession name="ksession1" type="stateless"/&gt;
    &lt;kie:ksession name="ksession2"/&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="13.2.4.2。Spring Bean范围（用于KieBase和KieSession）"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15420"></a> 13.2.4.2。Spring Bean范围（用于KieBase和KieSession）</strong></strong></h4></div></div></div><p><strong><strong>定义KieBase或KieSession时，可以选择声明该bean的作用域。例如，要强制Spring每次需要一个新的bean实例时，应将bean的scope属性声明为'prototype'。如果希望Spring每次需要返回相同的bean实例时，以类似的方式，则应将bean的scope属性声明为'singleton'。
        </strong></strong></p></div></div><div class="section" title="13.2.5。凯：ReleaseId"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15425"></a> 13.2.5。凯：ReleaseId</strong></strong></h3></div></div></div><p><strong><strong>
      </strong></strong></p><div class="section" title="13.2.5.1。 <kie：releaseId>的参数作为属性："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15430"></a> 13.2.5.1。 <kie:releaseid>的参数作为属性：</kie:releaseid></strong></strong></h4></div></div></div><div class="table"><strong><strong><a id="d0e15433"></a><p class="title"><strong>表13.4。样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">Bean的<span class="emphasis"><em>ID</em></span>是要从其他Bean引用的名称。标准Spring ID语义适用。</td><td align="left">是</td></tr><tr><td align="left">groupId</td><td align="left">来自Maven GAV的groupId</td><td align="left">是</td></tr><tr><td align="left">artifactId</td><td align="left">来自Maven GAV的artifactId</td><td align="left">是</td></tr><tr><td align="left">版</td><td align="left">来自Maven GAV的版本</td><td align="left">是</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="example"><a id="d0e15477"></a><p class="title"><strong>示例13.5 releaseId定义示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:releaseId id="beanId" groupId="org.kie.spring"
            artifactId="named-artifactId" version="1.0.0-SNAPSHOT"/&gt;</code></pre></div></div><br class="example-break"></strong></strong></div></div><div class="section" title="13.2.6。凯：进口"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15482"></a> 13.2.6。凯：进口</strong></strong></h3></div></div></div><p><strong><strong>从6.2版开始，kie-spring允许从类路径中找到的kjars中导入kie对象。当前支持两种导入kie对象的模式。</strong></strong></p><div class="table"><strong><strong><a id="d0e15487"></a><p class="title"><strong>表13.5。</strong></p><div class="table-contents"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">需要</th></tr></thead><tbody><tr><td align="left">releaseId</td><td align="left">引用Bean ID。标准Spring ID语义适用。</td><td align="left">没有</td></tr><tr><td align="left">enableScanner</td><td align="left">启用扫描仪。仅当指定了“ releaseId”时，才使用此属性。</td><td align="left">没有</td></tr><tr><td align="left">ScannerInterval</td><td align="left">扫描间隔（以毫秒为单位）。仅当指定了“ releaseId”时，才使用此属性。</td><td align="left">没有</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="section" title="13.2.6.1。全球进口"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15519"></a> 13.2.6.1。全球进口</h4></div></div></div><p><span class="emphasis"><em>import</em></span>标签将强制自动扫描类路径上的所有jar，初始化Kie对象（Kbase / KSessions）并将这些对象导入spring上下文。</p><div class="figure"><a id="d0e15527"></a><p class="title"><strong>图13.1。全球进口</strong></p><div class="figure-contents"><pre><code class="language-xml">&lt;kie:import /&gt;</code></pre></div></div><br class="figure-break"></div><div class="section" title="13.2.6.2。特定导入-ReleaseId"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15532"></a> 13.2.6.2。特定导入-ReleaseId</h4></div></div></div><p>在import标签上使用<span class="emphasis"><em>releaseId-ref</em></span>属性将初始化特定的Kie对象（Kbase / KSessions），并将这些对象导入spring上下文。</p><div class="figure"><a id="d0e15540"></a><p class="title"><strong>图13.2使用releaseId导入Kie对象</strong></p><div class="figure-contents"><pre><code class="language-xml">&lt;kie:import releaseId-ref="namedKieSession"/&gt;
&lt;kie:releaseId id="namedKieSession" groupId="org.drools"
            artifactId="named-kiesession" version="6.5.0.Final"/&gt;
          </code></pre></div></div><br class="figure-break"><p>可以为使用特定releaseId导入的KieBase启用Kie扫描功能。此功能当前不适用于全局导入。</p><div class="figure"><a id="d0e15547"></a><p class="title"><strong>图13.3使用releaseId导入Kie对象-启用扫描仪</strong></p><div class="figure-contents"><pre><code class="language-xml">&lt;kie:import releaseId-ref="namedKieSession"
            enableScanner="true" scannerInterval="1000"/&gt;

&lt;kie:releaseId id="namedKieSession" groupId="org.drools"
            artifactId="named-kiesession" version="6.5.0.Final"/&gt;
          </code></pre></div></div><br class="figure-break"><p>如果定义并启用了扫描程序，则会创建一个隐式<span class="emphasis"><em>KieScanner</em></span>对象，并将其插入到spring上下文中。可以从spring上下文中检索出来。</p><div class="figure"><a id="d0e15557"></a><p class="title"><strong>图13.4。从Spring Context检索KieScanner</strong></p><div class="figure-contents"><pre><code class="language-java">
// the implicit name would be releaseId#scanner
KieScanner releaseIdScanner = context.getBean("namedKieSession#scanner", KieScanner.class);
releaseIdScanner.scanNow();
          </code></pre></div></div><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>kie-ci必须在类路径上可用，才能使releaseId导入功能起作用。</p></div></div></strong></strong></div><div class="section" title="13.2.7。注解"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15565"></a> 13.2.7。注解</strong></strong></h3></div></div></div><p><strong><strong>@ KContainer，@ KBase和@KSession均支持可选的“名称”属性。Spring通常在注入时会“获取”，所有注入针对同一组注释都接收相同的实例。 “名称”注释会为每个名称强制一个唯一的实例，尽管该名称的所有实例都将具有相同的身份。</strong></strong></p><div class="section" title="13.2.7.1。@KReleaseId"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15570"></a> 13.2.7.1。@KReleaseId</strong></strong></h4></div></div></div><p><strong><strong>用于将实例绑定到KieModule的特定版本。如果kie-ci在类路径中，它将自动解决依赖关系，并从远程存储库下载。</strong></strong></p></div><div class="section" title="13.2.7.2。@KContainer"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15575"></a> 13.2.7.2。@KContainer</strong></strong></h4></div></div></div><div class="figure"><strong><strong><a id="d0e15578"></a><p class="title"><strong>图13.5。注入Classpath KieContainer</strong></p><div class="figure-contents"><pre><code class="language-java">@KContainer
private KieContainer kContainer;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15583"></a><p class="title"><strong>图13.6。为动态KieModule注入KieContainer</strong></p><div class="figure-contents"><pre><code class="language-java">@KContainer
@KReleaseId(groupId = "jar1", artifactId = "art1", version = "1.1")
private KieContainer kContainer;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15588"></a><p class="title"><strong>图13.7。为动态KieModule注入名为KieContainer的对象</strong></p><div class="figure-contents"><pre><code class="language-java">@KContainer(name = "kc1")
@KReleaseId(groupId = "jar1", artifactId = "art1", version = "1.1")
private KieContainer kContainer;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="13.2.7.3。@KBase"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15593"></a> 13.2.7.3。@KBase</strong></strong></h4></div></div></div><p><strong><strong>如果提供了默认参数，则默认参数将映射到value属性，并从spring xml文件中指定KieBase的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15598"></a><p class="title"><strong>图13.8。从类路径KieContainer注入默认的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KBase
private KieBase kbase;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15603"></a><p class="title"><strong>图13.9。从动态KieModule注入默认的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KBase
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieBase kbase;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15608"></a><p class="title"><strong>图13.10。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KBase("kbase1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieBase kbase1v10;

@KBase("kbase1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.1")
private KieBase kbase1v11;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15613"></a><p class="title"><strong>图13.11。“ jar1.ksession1” KieSession的并行版本加载</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession11kb2;

@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.1")
private KieSession ksession11kb2;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="13.2.7.4。KieSession的@KSession"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15618"></a> 13.2.7.4。KieSession的@KSession</strong></strong></h4></div></div></div><p><strong><strong>如果提供默认参数，则默认参数将映射到value属性，并从kmodule.xml或spring xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15623"></a><p class="title"><strong>图13.12。从类路径KieContainer注入默认KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession
private KieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15628"></a><p class="title"><strong>图13.13。从动态KieModule注入默认的KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15633"></a><p class="title"><strong>图13.14。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksessionv10;

@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.1")
private KieSession ksessionv11;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15638"></a><p class="title"><strong>图13.15。使用“名称”属性将新实例强制为“ jar1”。KBase1'KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession1ks1

@KSession("ksession1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private KieSession ksession1ks2</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="13.2.7.5。@KSession用于StatelessKieSession"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15643"></a> 13.2.7.5。@KSession用于StatelessKieSession</strong></strong></h4></div></div></div><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml或spring xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e15648"></a><p class="title"><strong>图13.16。从类路径KieContainer注入默认的StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession
private StatelessKieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e15653"></a><p class="title"><strong>图13.17。从动态KieModule注入默认的StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private StatelessKieSession ksession;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15658"></a><p class="title"><strong>图13.18。“ jar1”的并行版本加载。KBase1'KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession("ksession1")
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.0")
private StatelessKieSession ksessionv10;

@KSession("ksession1")
@KReleaseId( groupId = "jar1", rtifactId = "art1", version = "1.1")
private StatelessKieSession ksessionv11;</code></pre></div></div><br class="figure-break"><div class="figure"><a id="d0e15663"></a><p class="title"><strong>图13.19。</strong></p><div class="figure-contents"><pre><code class="language-java">@KSession(value="ksession1", name="ks1")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private StatelessKieSession ksession1ks1

@KSession(value="ksession1", name="ks2")
@KReleaseId( groupId = "jar1", artifactId = "art1", version = "1.0")
private StatelessKieSession ksession1ks2</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="13.2.7.6。重要的提示"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15666"></a> 13.2.7.6。重要的提示</strong></strong></h4></div></div></div><p><strong><strong>当使用批注时，为了正确初始化kmodule对象（kbase / ksession），对于任一类型的Bean都是强制性的<code class="code">org.kie.spring.annotations.KModuleAnnotationPostProcessor</code>被定义</strong></strong></p><strong><strong>或启用弹簧组件扫描。如下所示是其中一个代码段。

        <div class="example"><a id="d0e15675"></a><p class="title"><strong>示例13.6 kie-spring批注后处理器bean定义</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="kiePostProcessor"
            class="org.kie.spring.annotations.KModuleAnnotationPostProcessor"/&gt;</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e15680"></a><p class="title"><strong>示例13.7 kie-spring批注-组件扫描</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;context:component-scan base-package="org.kie.spring.annotations"/&gt;</code></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>使用注释时，后处理器是不同的。</p></div></strong></strong></div></div><div class="section" title="13.2.8。事件监听器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15688"></a> 13.2.8。事件监听器</strong></strong></h3></div></div></div><p><strong><strong>Drools支持向KieSessions添加3种类型的侦听器<span class="emphasis"><em>-AgendaListener</em></span> ， <span class="emphasis"><em>WorkingMemoryListener</em></span> ， <span class="emphasis"><em>ProcessEventListener</em></span></strong></strong></p><p><strong><strong>通过kie-spring模块，您可以使用XML标签将这些侦听器配置为KieSessions。这些标记的名称与实际的侦听器接口相同，即<kie:agendaeventlistener....><kie:ruleruntimeeventlistener....>和<kie:processeventlistener....>。</kie:processeventlistener....></kie:ruleruntimeeventlistener....></kie:agendaeventlistener....></strong></strong></p><p><strong><strong>kie-spring提供了将侦听器定义为独立（个体）侦听器并将它们定义为一组的功能。</strong></strong></p><div class="section" title="13.2.8.1。定义独立的侦听器："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15705"></a> 13.2.8.1。定义独立的侦听器：</strong></strong></h4></div></div></div><div class="section" title="13.2.8.1.1。属性："><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15708"></a> 13.2.8.1.1。属性：</strong></strong></h5></div></div></div><div class="table"><strong><strong><a id="d0e15711"></a><p class="title"><strong>表13.6。样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">需要</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">参考</td><td align="left">没有</td><td align="left">对另一个声明的bean的引用。</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="example"><a id="d0e15731"></a><p class="title"><strong>示例13.8侦听器配置示例-使用bean：ref。</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="mock-agenda-listener" class="mocks.MockAgendaEventListener"/&gt;
&lt;bean id="mock-rr-listener" class="mocks.MockRuleRuntimeEventListener"/&gt;
&lt;bean id="mock-process-listener" class="mocks.MockProcessEventListener"/&gt;

&lt;kie:kmodule id="listeners_kmodule"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ksession2"&gt;
      &lt;kie:agendaEventListener ref="mock-agenda-listener"/&gt;
      &lt;kie:processEventListener ref="mock-process-listener"/&gt;
      &lt;kie:ruleRuntimeEventListener ref="mock-rr-listener"/&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="13.2.8.1.2。嵌套元素："><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15736"></a> 13.2.8.1.2。嵌套元素：</strong></strong></h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>豆</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>类=字符串</strong></strong></p></li><li class="listitem"><p><strong><strong>名称=字符串（可选）</strong></strong></p></li></ul></div></li></ul></div><div class="example"><strong><strong><a id="d0e15750"></a><p class="title"><strong>示例13.9侦听器配置示例-使用嵌套bean。</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="listeners_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
   &lt;kie:ksession name="ksession1"&gt;
	  &lt;kie:agendaEventListener&gt;
      &lt;bean class="mocks.MockAgendaEventListener"/&gt;
      &lt;/kie:agendaEventListener&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="13.2.8.1.3。空标签：没有“ ref”且没有嵌套bean的声明"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15755"></a> 13.2.8.1.3。空标签：没有“ ref”且没有嵌套bean的声明</strong></strong></h5></div></div></div><p><strong><strong>如果定义了侦听器而不引用实现的bean，并且不包含嵌套的bean， <span class="emphasis"><em><drools:ruleruntimeeventlistener></drools:ruleruntimeeventlistener></em></span>基础实现将添加API中定义的侦听器的Debug版本。</strong></strong></p><p><strong><strong>调试侦听器将相应的Event toString消息打印到<span class="emphasis"><em>System.err。</em></span></strong></strong></p><div class="example"><strong><strong><a id="d0e15767"></a><p class="title"><strong>示例13.10侦听器配置示例-默认为Knowledge-API提供的调试版本。</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="mock-agenda-listener" class="mocks.MockAgendaEventListener"/&gt;
&lt;bean id="mock-rr-listener" class="mocks.MockRuleRuntimeEventListener"/&gt;
&lt;bean id="mock-process-listener" class="mocks.MockProcessEventListener"/&gt;

&lt;kie:kmodule id="listeners_module"&gt;
 &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ksession2"&gt;
      &lt;kie:agendaEventListener /&gt; 
      &lt;kie:processEventListener /&gt;
      &lt;kie:ruleRuntimeEventListener /&gt;
    &lt;/kie:ksession&gt;
 &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="13.2.8.1.4。混合和匹配不同的声明样式"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15772"></a> 13.2.8.1.4。混合和匹配不同的声明样式</strong></strong></h5></div></div></div><p><strong><strong>drools-spring模块允许您在同一KieSession中混合和匹配不同的声明式样式。下面的示例更加清晰。</strong></strong></p><div class="example"><strong><strong><a id="d0e15777"></a><p class="title"><strong>示例13.11侦听器配置示例-混合使用“ ref” /嵌套豆/空样式。</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="mock-agenda-listener" class="mocks.MockAgendaEventListener"/&gt;
&lt;bean id="mock-rr-listener" class="mocks.MockRuleRuntimeEventListener"/&gt;
&lt;bean id="mock-process-listener" class="mocks.MockProcessEventListener"/&gt;

&lt;kie:kmodule id="listeners_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ksession1"&gt;
      &lt;kie:agendaEventListener&gt;
          &lt;bean class="org.kie.spring.mocks.MockAgendaEventListener"/&gt;
      &lt;/kie:agendaEventListener&gt;
    &lt;/kie:ksession&gt;
    &lt;kie:ksession name="ksession2"&gt;
      &lt;kie:agendaEventListener ref="mock-agenda-listener"/&gt;
      &lt;kie:processEventListener ref="mock-process-listener"/&gt;
      &lt;kie:ruleRuntimeEventListener ref="mock-rr-listener"/&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="13.2.8.1.5。定义多个相同类型的侦听器"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15782"></a> 13.2.8.1.5。定义多个相同类型的侦听器</strong></strong></h5></div></div></div><p><strong><strong>为KieSession定义具有相同事件侦听器类型的多个bean也有效。</strong></strong></p><div class="example"><strong><strong><a id="d0e15787"></a><p class="title"><strong>示例13.12侦听器配置示例-多个相同类型的侦听器。</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="mock-agenda-listener" class="mocks.MockAgendaEventListener"/&gt;

&lt;kie:kmodule id="listeners_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ksession1"&gt;
      &lt;kie:agendaEventListener ref="mock-agenda-listener"/&gt;
      &lt;kie:agendaEventListener&gt;
          &lt;bean class="org.kie.spring.mocks.MockAgendaEventListener"/&gt;
      &lt;/kie:agendaEventListener&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div></div><div class="section" title="13.2.8.2。定义一组侦听器："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="kie-grouping-listeners"></a> 13.2.8.2。定义一组侦听器：</strong></strong></h4></div></div></div><p><strong><strong>drools-spring允许听众分组。当您定义一组侦听器并将其附加到多个会话时，此功能特别有用。当我们定义一组用于“测试”的侦听器，然后想要将其切换为“生产”用途时，分组功能也非常有用。</strong></strong></p><div class="section" title="13.2.8.2.1。属性："><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15797"></a> 13.2.8.2.1。属性：</strong></strong></h5></div></div></div><div class="table"><strong><strong><a id="d0e15800"></a><p class="title"><strong>表13.7。样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">需要</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">是</td><td align="left">唯一标识符</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></div><div class="section" title="13.2.8.2.2。嵌套元素："><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15820"></a> 13.2.8.2.2。嵌套元素：</strong></strong></h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>kie：agendaEventListener ...</strong></strong></p></li><li class="listitem"><p><strong><strong>kie：ruleRuntimeEventListener ...</strong></strong></p></li><li class="listitem"><p><strong><strong>kie：processEventListener ...</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>上面提到的子元素可以以任何顺序声明。组中仅允许每种类型的一个声明。</strong></strong></p></div></div><div class="section" title="13.2.8.2.3。例："><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e15836"></a> 13.2.8.2.3。例：</strong></strong></h5></div></div></div><div class="example"><strong><strong><a id="d0e15839"></a><p class="title"><strong>示例13.13听众组-示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="mock-agenda-listener" class="mocks.MockAgendaEventListener"/&gt;
&lt;bean id="mock-rr-listener" class="mocks.MockRuleRuntimeEventListener"/&gt;
&lt;bean id="mock-process-listener" class="mocks.MockProcessEventListener"/&gt;

&lt;kie:kmodule id="listeners_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="statelessWithGroupedListeners" type="stateless" 
             listeners-ref="debugListeners"/&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

  &lt;kie:eventListeners id="debugListeners"&gt;
  &lt;kie:agendaEventListener ref="mock-agenda-listener"/&gt;
  &lt;kie:processEventListener ref="mock-process-listener"/&gt;
  &lt;kie:ruleRuntimeEventListener ref="mock-rr-listener"/&gt;
&lt;/kie:eventListeners&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div></div></div><div class="section" title="13.2.9。记录仪"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15844"></a> 13.2.9。记录仪</strong></strong></h3></div></div></div><p><strong><strong>Drools的支持添加2种类型的记录器，以KieSessions - <span class="emphasis"><em><span class="emphasis"><em>ConsoleLogger，FileLogger。</em></span></em></span></strong></strong></p><p><strong><strong>通过kie-spring模块，您可以使用XML标签将这些记录器配置为KieSessions。这些标签的名称与实际的记录器接口相同，即<kie:consolelogger....>和<kie:filelogger....>。</kie:filelogger....></kie:consolelogger....></strong></strong></p><div class="section" title="13.2.9.1。定义控制台记录器："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15856"></a> 13.2.9.1。定义控制台记录器：</strong></strong></h4></div></div></div><p><strong><strong>控制台记录器可以通过使用以下命令附加到KieSession： <span class="emphasis"><em><kie:consolelogger></kie:consolelogger></em></span>标签。该标签没有属性，必须直接出现在<kie:ksession....>元素下。</kie:ksession....></strong></strong></p><div class="example"><strong><strong><a id="d0e15864"></a><p class="title"><strong>示例13.14定义控制台记录器-示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="loggers_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ConsoleLogger-statefulSession" type="stateful"&gt;
      &lt;kie:consoleLogger/&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="13.2.9.2。定义文件记录器："><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e15869"></a> 13.2.9.2。定义文件记录器：</strong></strong></h4></div></div></div><p><strong><strong>可以使用以下命令将文件记录器附加到KieSession： <span class="emphasis"><em><kie:filelogger></kie:filelogger></em></span>标签。此标记具有以下属性，并且必须直接出现在<kie:ksession....>元素下。</kie:ksession....></strong></strong></p><div class="table"><strong><strong><a id="d0e15877"></a><p class="title"><strong>表13.8。样品</strong></p><div class="table-contents"><table border="1" summary="Sample"><colgroup><col><col><col></colgroup><thead><tr><th align="center">属性</th><th align="center">需要</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">是</td><td align="left">唯一标识符</td></tr><tr><td align="left">文件</td><td align="left">是</td><td align="left">磁盘上实际文件的路径</td></tr><tr><td align="left">螺纹的</td><td align="left">没有</td><td align="left">默认为false。有效值为“ true”或“ false”</td></tr><tr><td align="left">间隔</td><td align="left">没有</td><td align="left">整数。指定将内容从内存刷新到磁盘的时间间隔。</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="example"><a id="d0e15918"></a><p class="title"><strong>示例13.15定义文件记录器-示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="loggers_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ConsoleLogger-statefulSession" type="stateful"&gt;
      &lt;kie:fileLogger id="fl_logger" file="#{ systemProperties['java.io.tmpdir'] }/log1"/&gt;
      &lt;kie:fileLogger id="tfl_logger" file="#{ systemProperties['java.io.tmpdir'] }/log2" 
                          threaded="true" interval="5"/&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></div><br class="example-break"><div class="section" title="13.2.9.2.1。关闭FileLogger"><div class="titlepage"><div><div><h5 class="title"><a id="d0e15923"></a> 13.2.9.2.1。关闭FileLogger</h5></div></div></div><p>为防止泄漏，建议关闭<span class="emphasis"><em><kie:filelogger ...=""> </kie:filelogger></em></span>以编程方式</p><pre><code class="language-java">LoggerAdaptor adaptor = (LoggerAdaptor) context.getBean("fl_logger");
adaptor.close();</code></pre></div></strong></strong></div></div><div class="section" title="13.2.10。定义批处理命令"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e15933"></a> 13.2.10。定义批处理命令</strong></strong></h3></div></div></div><p><strong><strong>一种<span class="emphasis"><em><kie:batch></kie:batch></em></span>元素可用于为给定的ksession定义一组批处理命令。该标签没有属性，必须直接出现在<kie:ksession....>元素下。支持的命令是</kie:ksession....></strong></strong></p><div class="figure"><strong><strong><a id="d0e15941"></a><p class="title"><strong>图13.20。初始化批处理命令</strong></p><div class="figure-contents"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>插入对象</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ref =字符串（可选）</p></li><li class="listitem"><p>匿名豆</p></li></ul></div></li><li class="listitem"><p>全局设置</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>标识符=字符串（必填）</p></li><li class="listitem"><p>reg =字符串（可选）</p></li><li class="listitem"><p>匿名豆</p></li></ul></div></li><li class="listitem"><p>全面执行</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>最大：n</p></li></ul></div></li><li class="listitem"><p>直到停火</p></li><li class="listitem"><p>开始过程</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>参数</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>标识符=字符串（必填）</p></li><li class="listitem"><p>ref =字符串（可选）</p></li><li class="listitem"><p>匿名豆</p></li></ul></div></li></ul></div></li><li class="listitem"><p>信号事件</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ref =字符串（可选）</p></li><li class="listitem"><p>event-type =字符串（必需）</p></li><li class="listitem"><p>process-instance-id = n（可选）</p></li></ul></div></li></ul></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="example"><a id="d0e16008"></a><p class="title"><strong>示例13.16批处理命令-示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kmodule id="batch_commands_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ksessionForCommands" type="stateful"&gt;
      &lt;kie:batch&gt;
        &lt;kie:insert-object ref="person2"/&gt;
        &lt;kie:set-global identifier="persons" ref="personsList"/&gt;
        &lt;kie:fire-all-rules max="10"/&gt;
      &lt;/kie:batch&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="13.2.11。坚持不懈"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16013"></a> 13.2.11。坚持不懈</strong></strong></h3></div></div></div><div class="figure"><strong><strong><a id="d0e16016"></a><p class="title"><strong>图13.21。持久性配置选项</strong></p><div class="figure-contents"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>持久性</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>交易经理</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ref =字串</p></li></ul></div></li><li class="listitem"><p>实体经理工厂</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ref =字串</p></li></ul></div></li></ul></div></li></ul></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="example"><a id="d0e16038"></a><p class="title"><strong>示例13.17 ksession JPA配置示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie:kstore id="kstore" /&gt; &lt;!-- provides KnowledgeStoreService implementation --&gt;

&lt;bean id="myEmf" 
       class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
   &lt;property name="dataSource" ref="ds" /&gt;
   &lt;property name="persistenceUnitName" 
       value="org.drools.persistence.jpa.local" /&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
   &lt;property name="entityManagerFactory" ref="myEmf" /&gt;
&lt;/bean&gt;

&lt;kie:kmodule id="persistence_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="jpaSingleSessionCommandService"&gt;
      &lt;kie:configuration&gt;
         &lt;kie:jpa-persistence&gt;
           &lt;kie:transaction-manager ref="txManager"/&gt;
           &lt;kie:entity-manager-factory ref="myEmf"/&gt;
         &lt;/kie:jpa-persistence&gt;
      &lt;/kie:configuration&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor" 
          class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;
</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="13.2.12。利用其他Spring功能"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16043"></a> 13.2.12。利用其他Spring功能</strong></strong></h3></div></div></div><p><strong><strong>本节提供了与Drools Expert集成时如何利用其他标准弹簧功能的详细信息。</strong></strong></p><div class="section" title="13.2.12.1。使用弹簧表达式（拼写）"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16048"></a> 13.2.12.1。使用弹簧表达式（拼写）</strong></strong></h4></div></div></div><p></p><pre><code class="language-xml">&lt;kie:kmodule id="batch_commands_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="#{packageRepository.packages}"&gt;
    &lt;kie:ksession name="ksessionForCommands" type="stateful"/&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor"
      class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;

&lt;bean id="packageRepository" class="sample.package.class.PackageRepo"&gt;
  &lt;property name="packages" value="drl_kiesample3"&gt;
&lt;/bean&gt;
          </code></pre><p></p><pre><code class="language-xml">&lt;kie:kmodule id="loggers_module"&gt;
  &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
    &lt;kie:ksession name="ConsoleLogger-statefulSession" type="stateful"&gt;
      &lt;kie:fileLogger id="fl" file="#{ systemProperties['java.io.tmpdir'] }/log1"/&gt;
      &lt;kie:fileLogger id="tfl" file="#{ systemProperties['java.io.tmpdir'] }/log2"
            threaded="true" interval="5"/&gt;
    &lt;/kie:ksession&gt;
  &lt;/kie:kbase&gt;
&lt;/kie:kmodule&gt;

&lt;bean id="kiePostProcessor"
            class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;</code></pre></div><div class="section" title="13.2.12.2。使用Spring配置文件"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16057"></a> 13.2.12.2。使用Spring配置文件</strong></strong></h4></div></div></div><p><strong><strong>Spring 3.1为spring-beans模式的bean元素引入了一个新的profile属性。在不同环境中启用和禁用概要文件时，此属性充当开关。此属性的一个潜在用途是在'dev'环境中使用调试记录器定义相同的kbase，而在'prod'环境中使用记录器定义的kbase。</strong></strong></p><p><strong><strong>下面的代码段说明了“配置文件”的概念。
        </strong></strong></p><pre><code class="language-xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:kie="http://drools.org/schema/kie-spring"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
http://drools.org/schema/kie-spring http://drools.org/schema/kie-spring.xsd"&gt;
  &lt;beans profile="development"&gt;
    &lt;kie:kmodule id="test-kmodule"&gt;
      &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
        &lt;kie:ksession name="ksession1" type="stateless"&gt;
            &lt;kie:consoleLogger /&gt;
        &lt;/kie:ksession&gt;
      &lt;/kie:kbase&gt;
    &lt;/kie:kmodule&gt;
    ...
  &lt;/beans&gt;

  &lt;beans profile="production"&gt;
    &lt;kie:kmodule id="test-kmodule"&gt;
      &lt;kie:kbase name="drl_kiesample" packages="drl_kiesample"&gt;
        &lt;kie:ksession name="ksession1" type="stateless"/&gt;
      &lt;/kie:kbase&gt;
    &lt;/kie:kmodule&gt;
    ...
  &lt;/beans&gt;
&lt;/beans&gt;</code></pre></div><p><strong><strong>如上所示，Spring XML包含配置文件的定义。在加载<span class="emphasis"><em>ApplicationContext时，</em></span>您必须告诉Spring您正在加载哪个配置文件。
      </strong></strong></p><p><strong><strong>有多种选择配置文件的方法，最有用的是使用“ spring.profiles.active”系统属性。
      </strong></strong></p><pre><code class="no-highlight">System.setProperty("spring.profiles.active", "development");
ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");</code></pre><p><strong><strong>显然，对上面所示的内容进行硬编码不是一个好习惯，建议的做法是使系统属性定义独立于应用程序。
      </strong></strong></p><pre><code class="no-highlight">-Dspring.profiles.active="development"</code></pre><p><strong><strong>还可以通过编程方式加载和启用配置文件</strong></strong></p><pre><code class="no-highlight">...
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext("beans.xml");
ConfigurableEnvironment env = ctx.getEnvironment();
env.setActiveProfiles("development");
ctx.refresh();
...
      </code></pre></div></div><div class="section" title="13.3。与jBPM人工任务集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16083"></a> 13.3。与jBPM人工任务集成</strong></strong></h2></div></div></div><p><strong><strong>本章描述了在使用Spring配置人工任务服务器时使用的基础结构，以及在进行此操作时使用的基础结构。</strong></strong></p><div class="section" title="13.3.1。如何使用jBPM人工任务配置Spring"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16088"></a> 13.3.1。如何使用jBPM人工任务配置Spring</strong></strong></h3></div></div></div><p><strong><strong>可以将jBPM人工任务服务器配置为使用Spring持久性。<a class="xref" href="#kie-spring-human-task-example" title="示例13.18使用Spring配置人工任务">例13.18“使用Spring配置人工任务”</a>是使用本地事务和Spring的线程安全EntityManager代理的示例。</strong></strong></p><p><strong><strong>下图显示了<a class="xref" href="#kie-spring-human-task-example" title="示例13.18使用Spring配置人工任务">示例13.18“使用Spring配置人工任务”中</a>使用的依赖关系图。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16099"></a><p class="title"><strong>图13.22。Spring Human Task集成注入依赖项</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Spring/ht-spring-deps.png" align="middle" alt="Spring Human Task集成注入依赖项"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>一种<code class="code">TaskService</code>实例依赖于其他两种bean类型：流口水<code class="code">SystemEventListener</code>豆以及<code class="code">TaskSessionSpringFactoryImpl</code>豆。的<code class="code">TaskSessionSpringFactoryImpl</code>豆是<span class="emphasis"><em>不</em></span>注入<code class="code">TaskService</code> bean，因为这将导致循环依赖。为了解决这个问题，当<code class="code">TaskService</code>豆被注入<code class="code">TaskSessionSpringFactoryImpl</code>豆，使用的setter方法会秘密注入<code class="code">TaskSessionSpringFactoryImpl</code>实例回到<code class="code">TaskService</code> bean并初始化<code class="code">TaskService</code>豆也是。</p><p>的<code class="code">TaskSessionSpringFactoryImpl</code> bean负责在人工任务中创建所有内部实例，以处理事务和持久性上下文管理。除了一个<code class="code">TaskService</code>例如，此bean还需要注入事务管理器和持久性上下文。具体来说，它需要一个<code class="code">HumanTaskSpringTransactionManager</code> bean（作为事务管理器）和一个实例<code class="code">SharedEntityManagerBean</code> bean（作为持久性上下文实例）。</p><p>为了配置持久性，我们还使用了一些标准的Spring bean：有一个bean可以容纳<code class="code">EntityManagerFactory</code>实例以及<code class="code">SharedEntityManagerBean</code>实例。的<code class="code">SharedEntityManagerBean</code>提供实际的共享的线程安全代理<code class="code">EntityManager</code> 。</p><p>的<code class="code">HumanTaskSpringTransactionManager</code> bean充当Spring事务管理器的包装，在这种情况下， <code class="code">JpaTransactionManager</code> 。一个实例<code class="code">JpaTransactionManager</code>因此也实例化了bean。</p><div class="example"><a id="kie-spring-human-task-example"></a><p class="title"><strong>示例13.18使用Spring配置人工任务</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jbpm="http://drools.org/schema/drools-spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://drools.org/schema/drools-spring org/drools/container/spring/drools-spring-1.2.0.xsd"&gt;

  &lt;!-- persistence &amp; transactions--&gt;
  &lt;bean id="htEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="persistenceUnitName" value="org.jbpm.task" /&gt;
  &lt;/bean&gt;

  &lt;bean id="htEm" class="org.springframework.orm.jpa.support.SharedEntityManagerBean"&gt;
    &lt;property name="entityManagerFactory" ref="htEmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="jpaTxMgr" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="htEmf" /&gt;
    &lt;!-- this must be true if using the SharedEntityManagerBean, and false otherwise --&gt;
    &lt;property name="nestedTransactionAllowed" value="true"/&gt;
  &lt;/bean&gt;

  &lt;bean id="htTxMgr" class="org.drools.container.spring.beans.persistence.HumanTaskSpringTransactionManager"&gt;
    &lt;constructor-arg ref="jpaTxMgr" /&gt;
  &lt;/bean&gt;

  &lt;!-- human-task beans --&gt;

  &lt;bean id="systemEventListener" class="org.drools.SystemEventListenerFactory" factory-method="getSystemEventListener" /&gt;

  &lt;bean id="taskService" class="org.jbpm.task.service.TaskService" &gt;
    &lt;property name="systemEventListener" ref="systemEventListener" /&gt;
  &lt;/bean&gt;

  &lt;bean id="springTaskSessionFactory" class="org.jbpm.task.service.persistence.TaskSessionSpringFactoryImpl"
        init-method="initialize" depends-on="taskService" &gt;
    &lt;!-- if using the SharedEntityManagerBean, make sure to enable nested transactions --&gt;
    &lt;property name="entityManager" ref="htEm" /&gt;
    &lt;property name="transactionManager" ref="htTxMgr" /&gt;
    &lt;property name="useJTA" value="false" /&gt;
    &lt;property name="taskService" ref="taskService" /&gt;
  &lt;/bean&gt;

&lt;/beans&gt;
</code></pre></div></div><br class="example-break"><p>使用时<code class="code">SharedEntityManagerBean</code>例如，配置Spring事务管理器以使用嵌套事务很重要。这是因为<code class="code">SharedEntityManagerBean</code>是<span class="emphasis"><em>事务</em></span>性持久性上下文，它将在每次操作后关闭持久性上下文。但是，人工任务服务器需要能够在操作后访问（持久化）实体。嵌套事务使我们仍然可以访问原本可以分离的实体，并且无法再访问它们，尤其是在使用使用实体的惰性初始化的ORM框架时。</p><p>另外， <code class="code">TaskSessionSpringFactoryImpl</code> bean带有一个<span class="quote">“ <span class="quote">useJTA</span> ”</span>参数，目前，与Spring的JTA事务尚未经过全面测试。</p></strong></strong></div></div></div><div class="chapter" title="第十四章Android整合"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.kie.android"></a>第十四章Android整合</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e16206">14.1。与Drools Expert集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16214">14.1.1。预序列化规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16242">14.1.2。具有drools-compiler依赖性的KieContainer API</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e16257">14.2。与Roboguice集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16260">14.2.1。Roboguice的预序列化规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16290">14.2.2。具有流口水编译器依赖性和Roboguice的KieContainer</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="14.1。与Drools Expert集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16206"></a> 14.1。与Drools Expert集成</strong></strong></h2></div></div></div><p><strong><strong>Drools Android集成有两种版本，有无Drools <span class="emphasis"><em>-compiler</em></span>依赖项。由于没有drools-compiler依赖性，因此在构建时使用kie-maven-plugin对知识库进行了预序列化。然后可以使用API对它们进行反序列化，或者使用Roboguice直接注入它们。使用drools-compiler依赖项时，有两种选择：（1）标准KieContainer API或（2）使用Roboguice进行CDI式注入。
    </strong></strong></p><div class="section" title="14.1.1。预序列化规则"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16214"></a> 14.1.1。预序列化规则</strong></strong></h3></div></div></div><p><strong><strong>通过在构建时对已编译的知识库进行预序列化，然后在运行时对其进行反序列化，可以使用不依赖drools-compiler依赖项的Drools，从而导致apk较小。
        </strong></strong></p><div class="section" title="14.1.1.1。Maven配置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16219"></a> 14.1.1.1。Maven配置</strong></strong></h4></div></div></div><p><strong><strong>必须在构建期间使用<span class="emphasis"><em>kie-maven-plugin</em></span>序列化KieBase。</strong></strong></p><div class="example"><strong><strong><a id="d0e16227"></a><p class="title"><strong>例14.1预序列化的KieBase Maven pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;drools-bom&lt;/artifactId&gt;
      &lt;version&gt;6.5.0.Final&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-android&lt;/artifactId&gt;
    &lt;exclusions&gt;
     &lt;exclusion&gt;
       &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
       &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-core&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.kie&lt;/groupId&gt;
      &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;6.5.0.Final&lt;/version&gt;
      &lt;configuration&gt;
        &lt;kiebases&gt;
        &lt;kiebase&gt;HelloKB&lt;/kiebase&gt;
        &lt;/kiebases&gt;
        &lt;resDirectory&gt;${basedir}/src/main/res/raw&lt;/resDirectory&gt;
      &lt;/configuration&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;touch&lt;/id&gt;
            &lt;goals&gt;
              &lt;goal&gt;touch&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;initialize&lt;/phase&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;compile-kbase&lt;/id&gt;
              &lt;goals&gt;
                &lt;goal&gt;build&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;phase&gt;compile&lt;/phase&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;serialize&lt;/id&gt;
            &lt;goals&gt;
              &lt;goal&gt;serialize&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;compile&lt;/phase&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
     &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
                  </code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="14.1.1.2。加载KieBase"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16232"></a> 14.1.1.2。加载KieBase</strong></strong></h4></div></div></div><p><strong><strong>创建会话之前，必须对KieBase进行反序列化。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16237"></a><p class="title"><strong>图14.1加载序列化的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">private class LoadKieBaseTask extends AsyncTask&lt;InputStream, Void, KieBase&gt; {
   @Override
   protected KieBase doInBackground(InputStream... params) {
      try {
         logger.debug("Loading knowledge base");
         final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
         kbase.addKnowledgePackages((List&lt;KnowledgePackage&gt;) DroolsStreamUtils.streamIn(params[0]));
         return kbase;
      }catch(Exception e) {
         logger.error("Drools exception", e);
         return null;
      }
   }
}
                  </code></pre></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="14.1.2。具有drools-compiler依赖性的KieContainer API"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16242"></a> 14.1.2。具有drools-compiler依赖性的KieContainer API</strong></strong></h3></div></div></div><p><strong><strong>通过drools-compiler依赖关系标准，可以使用KieContainer API。这需要较大的apk成本。为了避免65K限制，可以使用multidex（或proguard）。
        </strong></strong></p><div class="section" title="14.1.2.1。使用Drools-compiler和multidex的Maven配置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16247"></a> 14.1.2.1。使用Drools-compiler和multidex的Maven配置</strong></strong></h4></div></div></div><p><strong><strong>必须配置kie-maven-plugin才能构建kiebase。必须使用Multidex来增加依赖性。apk中还有一些用于合并各种Drools XML文件的设置。
              </strong></strong></p><div class="example"><strong><strong><a id="d0e16252"></a><p class="title"><strong>示例14.2带drools-compiler和multidex的pom.xml</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.drools&lt;/groupId&gt;
      &lt;artifactId&gt;drools-bom&lt;/artifactId&gt;
      &lt;version&gt;6.5.0.Final&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-android&lt;/artifactId&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;/exclusion&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;xmlpull&lt;/groupId&gt;
         &lt;artifactId&gt;xmlpull&lt;/artifactId&gt;
      &lt;/exclusion&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;xpp3&lt;/groupId&gt;
         &lt;artifactId&gt;xpp3_min&lt;/artifactId&gt;
      &lt;/exclusion&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
         &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
      &lt;/exclusion&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
         &lt;artifactId&gt;ecj&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.kie&lt;/groupId&gt;
      &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;6.5.0.Final&lt;/version&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;compile-kbase&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;build&lt;/goal&gt;
          &lt;/goals&gt;
          &lt;phase&gt;compile&lt;/phase&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;com.simpligility.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;4.2.1&lt;/version&gt;
      &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;configuration&gt;
        &lt;sdk&gt;
          &lt;platform&gt;21&lt;/platform&gt;
        &lt;/sdk&gt;
        &lt;dex&gt;
          &lt;coreLibrary&gt;true&lt;/coreLibrary&gt;
          &lt;jvmArguments&gt;&lt;jvmArgument&gt;-Xmx2048m&lt;/jvmArgument&gt;&lt;/jvmArguments&gt;
          &lt;multiDex&gt;true&lt;/multiDex&gt;
          &lt;mainDexList&gt;maindex.txt&lt;/mainDexList&gt;
        &lt;/dex&gt;
        &lt;extractDuplicates&gt;true&lt;/extractDuplicates&gt;
        &lt;apk&gt;
          &lt;metaInf&gt;
            &lt;includes&gt;
              &lt;include&gt;services/**&lt;/include&gt;
              &lt;include&gt;kmodule.*&lt;/include&gt;
              &lt;include&gt;HelloKB/**&lt;/include&gt;
              &lt;include&gt;drools**&lt;/include&gt;
              &lt;include&gt;maven/${project.groupId}/${project.artifactId}/**&lt;/include&gt;
            &lt;/includes&gt;
          &lt;/metaInf&gt;
        &lt;/apk&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
                  </code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div></div></div><div class="section" title="14.2。与Roboguice集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16257"></a> 14.2。与Roboguice集成</strong></strong></h2></div></div></div><div class="section" title="14.2.1。Roboguice的预序列化规则"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16260"></a> 14.2.1。Roboguice的预序列化规则</strong></strong></h3></div></div></div><p><strong><strong>使用Roboguice，可以使用@KBase批注注入预序列化的知识库。</strong></strong></p><div class="section" title="14.2.1.1。注解"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16265"></a> 14.2.1.1。注解</strong></strong></h4></div></div></div><p><strong><strong>@KBase支持可选的“名称”属性。CDI通常在注入时执行“ getOrCreate”，所有注入针对同一组注解接收相同的实例。 “名称”注释会为每个名称强制一个唯一的实例，尽管该名称的所有实例都将具有相同的身份。
              </strong></strong></p><div class="section" title="14.2.1.1.1。@KBase"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e16270"></a> 14.2.1.1.1。@KBase</strong></strong></h5></div></div></div><p><strong><strong>默认参数映射到value属性，并从kmodule.xml文件中指定KieBase的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16275"></a><p class="title"><strong>图14.2。通过名称从预序列化资源中注入KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@KBase("kbase1")
private KieBase kbase;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="14.2.1.2。AndroidManifest.xml配置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16280"></a> 14.2.1.2。AndroidManifest.xml配置</strong></strong></h4></div></div></div><p><strong><strong>Roboguice模块需要在清单中指定。</strong></strong></p><div class="example"><strong><strong><a id="d0e16285"></a><p class="title"><strong>示例14.3Roboguice清单具有预序列化的知识库</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;application
   android:largeHeap="true"
   android:allowBackup="true"
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme"&gt;
      &lt;meta-data
         android:name="roboguice.modules"
         android:value="org.drools.android.roboguice.DroolsModule"/&gt;
      &lt;activity
         android:label="@string/app_name"
         android:name="org.drools.examples.android.SplashActivity"&gt;
      &lt;intent-filter&gt;
         &lt;action android:name="android.intent.action.MAIN"/&gt;
         &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
      &lt;/intent-filter&gt;
   &lt;/activity&gt;
&lt;/application&gt;
                  </code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div></div><div class="section" title="14.2.2。具有流口水编译器依赖性和Roboguice的KieContainer"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16290"></a> 14.2.2。具有流口水编译器依赖性和Roboguice的KieContainer</strong></strong></h3></div></div></div><p><strong><strong>使用Roboguice和drools-compiler，几乎可以使用完整的CDI语法来注入KieContainers，KieBases和KieSessions。</strong></strong></p><div class="section" title="14.2.2.1。注解"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16295"></a> 14.2.2.1。注解</strong></strong></h4></div></div></div><p><strong><strong>@ KContainer，@ KBase和@KSession均支持可选的“名称”属性。CDI通常在注入时执行“ getOrCreate”，所有注入针对同一组注解接收相同的实例。 “名称”注释会为每个名称强制一个唯一的实例，尽管该名称的所有实例都将具有相同的身份。</strong></strong></p><div class="section" title="14.2.2.1.1。@KContainer"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e16300"></a> 14.2.2.1.1。@KContainer</strong></strong></h5></div></div></div><div class="figure"><strong><strong><a id="d0e16303"></a><p class="title"><strong>图14.3注入Classpath KieContainer</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieContainer kContainer;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="14.2.2.1.2。@KBase"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e16308"></a> 14.2.2.1.2。@KBase</strong></strong></h5></div></div></div><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieBase的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16313"></a><p class="title"><strong>图14.4。从类路径KieContainer注入默认的KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieBase kbase;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e16318"></a><p class="title"><strong>图14.5。从类路径KieContainer中按名称注入KieBase</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KBase("kbase1")
private KieBase kbase;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="14.2.2.1.3。KieSession的@KSession"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e16323"></a> 14.2.2.1.3。KieSession的@KSession</strong></strong></h5></div></div></div><p><strong><strong>@KSession是可选的，因为可以使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16330"></a><p class="title"><strong>图14.6。从类路径KieContainer注入默认KieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private KieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e16335"></a><p class="title"><strong>图14.7。从类路径KieContainer中按名称注入StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1")
private KieSession ksession;</code></pre></div></div><br class="figure-break"></strong></strong></div><div class="section" title="14.2.2.1.4。@KSession用于StatelessKieSession"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e16340"></a> 14.2.2.1.4。@KSession用于StatelessKieSession</strong></strong></h5></div></div></div><p><strong><strong>@KSession是可选的，因为可以使用@Inject和变量类型推断来检测和添加它。</strong></strong></p><p><strong><strong>如果提供了默认参数，则默认参数会映射到value属性，并从kmodule.xml文件中指定KieSession的名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16347"></a><p class="title"><strong>图14.8。从类路径KieContainer注入默认的StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
private StatelessKieSession ksession;</code></pre></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e16352"></a><p class="title"><strong>图14.9。从类路径KieContainer中按名称注入StatelessKieSession</strong></p><div class="figure-contents"><pre><code class="language-java">@Inject
@KSession("ksession1")
private StatelessKieSession ksession;</code></pre></div></div><br class="figure-break"></strong></strong></div></div><div class="section" title="14.2.2.2。AndroidManifest.xml配置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16357"></a> 14.2.2.2。AndroidManifest.xml配置</strong></strong></h4></div></div></div><p><strong><strong>Roboguice模块需要在清单中指定。</strong></strong></p><div class="example"><strong><strong><a id="d0e16362"></a><p class="title"><strong>示例14.4Roboguice清单配置</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;application
   android:largeHeap="true"
   android:allowBackup="true"
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme"&gt;
   &lt;meta-data
      android:name="roboguice.modules"
      android:value="org.drools.android.roboguice.DroolsContainerModule"/&gt;
   &lt;activity
      android:label="@string/app_name"
      android:name="org.drools.examples.android.SplashActivity"&gt;
      &lt;intent-filter&gt;
         &lt;action android:name="android.intent.action.MAIN"/&gt;
         &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
      &lt;/intent-filter&gt;
   &lt;/activity&gt;
&lt;/application&gt;
                  </code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div></div></div></div><div class="chapter" title="第十五章Apache Camel集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.camel"></a>第十五章Apache Camel集成</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e16370">15.1。骆驼</a></span></strong></strong></dt></dl></div><div class="section" title="15.1。骆驼"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16370"></a> 15.1。骆驼</strong></strong></h2></div></div></div><p><strong><strong>Camel提供了一个轻量级的总线框架，用于将信息传入和传出Drools。</strong></strong></p><p><strong><strong>Drools引入了两个元素来简化集成。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>流口水政策</strong></strong></p><p><strong><strong>增强任何JAXB或XStream数据加载器。对于JAXB，它在上下文路径中添加了Drools相关路径，对于XStream，它为Drools类添加了自定义转换器和别名。它还处理将ClassLoader设置为目标ksession。</strong></strong></p></li><li class="listitem"><p><strong><strong>流口水端点</strong></strong></p><p><strong><strong>针对指定的流口水会话执行有效负载</strong></strong></p></li></ul></div><p><strong><strong>可以像配置任何常规骆驼组件一样配置Drools，但是请注意包装Drools相关段的策略。这会将所有有效负载路由到ksession1</strong></strong></p><div class="example"><strong><strong><a id="d0e16390"></a><p class="title"><strong>示例15.1使用CXFRS生产者配置的Drools EndPoint</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;

&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;  
   &lt;route&gt;
      &lt;from uri="cxfrs://bean://rsServer"/&gt;
         &lt;policy ref="kiePolicy"&gt;
            &lt;unmarshal ref="xstream" /&gt;       
            &lt;to uri="kie:ksession1" /&gt;
            &lt;marshal ref="xstream" /&gt;
       &lt;/policy&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>可以不在drools端点uri中指定会话，而可以基于属性或标头进行“多路复用”。在此示例中，该策略将检查标题字段“ DroolsLookup”以执行要执行的命名会话，如果未指定，则将检查传入有效负载上的“ lookup”属性。</p><div class="example"><a id="d0e16397"></a><p class="title"><strong>示例15.2使用CXFRS生产者配置的Drools EndPoint</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;

&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;  
   &lt;route&gt;
      &lt;from uri="cxfrs://bean://rsServer"/&gt;
         &lt;policy ref="kiePolicy"&gt;
            &lt;unmarshal ref="xstream" /&gt;       
            &lt;to uri="kie:dynamic" /&gt;
            &lt;marshal ref="xstream" /&gt;
       &lt;/policy&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e16402"></a><p class="title"><strong>示例15.3Java代码针对Spring和Camel上下文中的Route执行</strong></p><div class="example-contents"><pre><code class="no-highlight">public class MyTest extends CamelSpringTestSupport {
    
    @Override
    protected AbstractXmlApplicationContext createApplicationContext() {        
        return new ClassPathXmlApplicationContext("org/drools/camel/component/CxfRsSpring.xml");
    }  

    public void test1() throws Exception {
        String cmd = "";
        cmd += "&lt;batch-execution lookup=\"ksession1\"&gt;\n";
        cmd += "  &lt;insert out-identifier=\"salaboy\"&gt;\n";
        cmd += "      &lt;org.drools.pipeline.camel.Person&gt;\n";
        cmd += "         &lt;name&gt;salaboy&lt;/name&gt;\n";
        cmd += "      &lt;/org.drools.pipeline.camel.Person&gt;\n";
        cmd += "   &lt;/insert&gt;\n";
        cmd += "   &lt;fire-all-rules/&gt;\n";
        cmd += "&lt;/batch-execution&gt;\n";
                
        Object object = this.context.createProducerTemplate().requestBody("direct://client", cmd);
        System.out.println( object ); 
    }
}    </code></pre></div></div><br class="example-break"><p>以下网址显示了使用以下命令进行jaxb，xstream和json编组的示例脚本示例：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/jaxb.mvt?r=HEAD</p></li><li class="listitem"><p>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/jaxb.mvt?r=HEAD</p></li><li class="listitem"><p>http://fisheye.jboss.org/browse/JBossRules/trunk/drools-camel/src/test/resources/org/drools/camel/component/xstream.mvt?r=HEAD</p></li></ul></div></strong></strong></div></div><div class="chapter" title="第十六章Drools骆驼服务器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.server"></a>第十六章Drools骆驼服务器</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e16423">16.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16428">16.2。部署方式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16433">16.3。组态</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16473">16.3.1。REST /骆驼服务配置</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="16.1。介绍"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16423"></a> 16.1。介绍</strong></strong></h2></div></div></div><p><strong><strong>Drools骆驼服务器（drools-camel-server）模块是一场战争，您可以部署它以远程方式针对任何类型的客户端应用程序执行KnowledgeBase。这不限于JVM应用程序客户端，而是可以通过REST接口使用HTTP的任何技术。此版本的执行服务器以本机方式支持无状态和有状态会话。</strong></strong></p></div><div class="section" title="16.2。部署方式"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16428"></a> 16.2。部署方式</strong></strong></h2></div></div></div><p><strong><strong>Drools Camel Server是一个war文件，可以将其部署在应用程序服务器（例如JBoss AS）中。由于该服务是无状态的，因此可以根据您的需要为客户负载部署尽可能多的这些服务。在JBoss AS 4.x上进行部署/ Tomcat 6.x即开即用，相反，必须添加一些外部依赖项，并且必须更改配置才能在JBoss AS 5中进行部署</strong></strong></p></div><div class="section" title="16.3。组态"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16433"></a> 16.3。组态</strong></strong></h2></div></div></div><p><strong><strong>在war文件中，您将找到一些XML配置文件。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>beans.xml</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>导入Knowledge-services.xml和camel-server.xml的骨架XML</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>camel-server.xml</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>使用骆驼路由配置CXF端点</strong></strong></p></li><li class="listitem"><p><strong><strong>将管道消息路由到各种已配置的知识服务</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>Knowledge-services.xml</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>各种知识库和会议</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>camel-client.xml</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>示例骆驼客户端，显示如何发送和接收消息</strong></strong></p></li><li class="listitem"><p><strong><strong>由“开箱即用” test.jsp使用</strong></strong></p></li></ul></div></li></ul></div><div class="section" title="16.3.1。REST /骆驼服务配置"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16473"></a> 16.3.1。REST /骆驼服务配置</strong></strong></h3></div></div></div><p><strong><strong>下一步是配置将通过drools-server公开的服务。您可以在camel-server.xml文件中修改此配置。</strong></strong></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cxf="http://camel.apache.org/schema/cxf"
  xmlns:jaxrs="http://cxf.apache.org/jaxrs"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
  http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd
  http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

&lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt;
&lt;import resource="classpath:META-INF/cxf/cxf-extension-jaxrs-binding.xml"/&gt; 
&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt;

  &lt;!--
   !   If you are running on JBoss you will need to copy a camel-jboss.jar into the lib and set this ClassLoader configuration
   !  http://camel.apache.org/camel-jboss.html
   !   &lt;bean id="jbossResolver" class="org.apache.camel.jboss.JBossPackageScanClassResolver"/&gt;
   --&gt;

  &lt;!--
   !   Define the server end point.
   !   Copy and paste this element, changing id and the address, to expose services on different urls.
   !   Different Camel routes can handle different end point paths.
   --&gt;
  &lt;cxf:rsServer id="rsServer"  
                address="/rest"
                serviceClass="org.kie.jax.rs.CommandExecutorImpl"&gt;
       &lt;cxf:providers&gt;
           &lt;bean class="org.kie.jax.rs.CommandMessageBodyReader"/&gt;
       &lt;/cxf:providers&gt;
  &lt;/cxf:rsServer&gt;  
  
  &lt;cxf:cxfEndpoint id="soapServer"
            address="/soap"
             serviceName="ns:CommandExecutor"
             endpointName="ns:CommandExecutorPort"
          wsdlURL="soap.wsdl"
          xmlns:ns="http://soap.jax.drools.org/" &gt;
    &lt;cxf:properties&gt;
      &lt;entry key="dataFormat" value="MESSAGE"/&gt;
      &lt;entry key="defaultOperationName" value="execute"/&gt;
    &lt;/cxf:properties&gt;
  &lt;/cxf:cxfEndpoint&gt;

  &lt;!-- Leave this, as it's needed to make Camel "drools" aware --&gt;
  &lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;

  &lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;    
    &lt;!-- 
     ! Routes incoming messages from end point id="rsServer".
     ! Example route unmarshals the messages with xstream and executes against ksession1.
     ! Copy and paste this element, changing marshallers and the 'to' uri, to target different sessions, as needed.
     !--&gt;
     
    &lt;route&gt;
       &lt;from uri="cxfrs://bean://rsServer"/&gt;
       &lt;policy ref="kiePolicy"&gt;
         &lt;unmarshal ref="xstream" /&gt;
         &lt;to uri="kie:ksession1" /&gt;
         &lt;marshal ref="xstream" /&gt;
       &lt;/policy&gt;
    &lt;/route&gt;    

    &lt;route&gt;
      &lt;from uri="cxf://bean://soapServer"/&gt;
      &lt;policy ref="kiePolicy"&gt;
        &lt;unmarshal ref="xstream" /&gt;       
        &lt;to uri="kie:ksession1" /&gt;
        &lt;marshal ref="xstream" /&gt;
      &lt;/policy&gt;
    &lt;/route&gt;
        
  &lt;/camelContext&gt;
  
&lt;/beans&gt; </code></pre><div class="section" title="16.3.1.1。RESTful服务端点创建"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16480"></a> 16.3.1.1。RESTful服务端点创建</strong></strong></h4></div></div></div><p><strong><strong>在下一个XML代码段中，我们将创建一个绑定到/ kservice / rest地址的RESTful（JAX-RS）端点，并使用org.drools.jax.rs。CommandExecutorImpl作为服务实现者。此类仅用于实例化服务端点，因为所有内部实现均由Camel管理，并且您可以在源文件中看到必须永远不要调用公开的执行服务。</strong></strong></p><p><strong><strong>还提供了JAX-RS提供程序来确定是否可以在此服务端点中处理传输的消息。</strong></strong></p><pre><code class="language-xml">&lt;cxf:rsServer id="rsServer"  
              address="/rest"
              serviceClass="org.kie.jax.rs.CommandExecutorImpl"&gt;
     &lt;cxf:providers&gt;
         &lt;bean class="org.kie.jax.rs.CommandMessageBodyReader"/&gt;
     &lt;/cxf:providers&gt;
&lt;/cxf:rsServer&gt;  </code></pre><p><strong><strong>理想情况下，不需要修改此配置，至少不需要修改服务类和JAX-RS提供程序，但是您可以添加更多与不同地址关联的终结点，以在其他骆驼路由中使用它们。</strong></strong></p><p><strong><strong>完成所有这些初始配置之后，您可以开始配置自己的知识服务。</strong></strong></p></div><div class="section" title="16.3.1.2。Camel Kie政策和环境创建"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16493"></a> 16.3.1.2。Camel Kie政策和环境创建</strong></strong></h4></div></div></div><p><strong><strong>KiePolicy用于在骆驼中添加Drools支持，基本上它的作用是在骆驼路线中添加拦截器，以动态创建骆驼处理器并修改内部导航路线。如果要获得SOAP支持，则需要创建自定义的Drools策略，但它将在下一个版本中添加。</strong></strong></p><p><strong><strong>但是您不需要了解更多内部细节，只需实例化此bean：</strong></strong></p><pre><code class="language-xml">&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;</code></pre><p><strong><strong>接下来是创建骆驼路线，该路线将负责执行通过JAX-RS发送的命令。基本上，我们创建一个与JAX-RS定义相关联的路由定义作为数据输入，要使用的骆驼策略以及在“执行路由”或ProcessorDefinitions内部。如您所见，我们将XStream设置为marshaller / unmarshaller和drools执行路线定义</strong></strong></p><pre><code class="language-xml">&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;    
   &lt;route&gt;
      &lt;from uri="cxfrs://bean://rsServer"/&gt;
      &lt;policy ref="kiePolicy"&gt;
        &lt;unmarshal ref="xstream" /&gt;
        &lt;to uri="kie:ksession1" /&gt;
        &lt;marshal ref="xstream" /&gt;
      &lt;/policy&gt;
   &lt;/route&gt;    
   &lt;route&gt;
     &lt;from uri="cxf://bean://soapServer"/&gt;
     &lt;policy ref="kiePolicy"&gt;
       &lt;unmarshal ref="xstream" /&gt;       
       &lt;to uri="kie:ksession1" /&gt;
       &lt;marshal ref="xstream" /&gt;
     &lt;/policy&gt;
   &lt;/route&gt;
&lt;/camelContext&gt;</code></pre><p><strong><strong>Drools端点创建具有下一个参数</strong></strong></p><pre><code class="language-xml">&lt;to uri="kie:{1}/{2}" /&gt;</code></pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>在CamelContext中注册的执行节点标识符</strong></strong></p></li><li class="listitem"><p><strong><strong>在执行节点中注册的知识会话标识符，标识符为{1}</strong></strong></p></li></ol></div><p><strong><strong>这两个参数都在Knowledge-services.xml文件中配置。</strong></strong></p></div><div class="section" title="16.3.1.3。知识服务配置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16520"></a> 16.3.1.3。知识服务配置</strong></strong></h4></div></div></div><p><strong><strong>下一步是创建您将要使用的知识会议。</strong></strong></p><pre><code class="language-xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:kie="http://drools.org/schema/kie-spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                          http://drools.org/schema/kie-spring http://drools.org/schema/kie-spring.xsd"&gt;

  &lt;kie:kmodule id="drools-camel-server"&gt;
    &lt;kie:kbase name="kbase1" packages="org.drools.server"&gt;
      &lt;kie:ksession name="ksession1" type="stateless"/&gt;
    &lt;/kie:kbase&gt;
  &lt;/kie:kmodule&gt;

  &lt;bean id="kiePostProcessor" 
            class="org.kie.spring.KModuleBeanFactoryPostProcessor"/&gt;

&lt;/beans&gt;</code></pre><p><strong><strong>执行节点是上下文或已注册的kbase和ksession，此处kbase1和ksession1是在node1上下文中规划的。kbase本身包含两个知识定义：DRL和XSD。 Spring文档包含有关配置这些知识服务的更多信息。</strong></strong></p></div><div class="section" title="16.3.1.4。测试"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e16529"></a> 16.3.1.4。测试</strong></strong></h4></div></div></div><p><strong><strong>随着drools-server war的解压缩，您应该能够看到一个test.jsp并运行它。本示例仅执行一个简单的“ echo”类型的应用程序。它向规则服务器发送一条消息，该消息将单词“ echo”预先添加到前面，然后再发送回去。默认情况下，消息为“ Hello World”，可以使用url参数msg-test.jsp传递不同的消息？msg =“我的自定义消息”。</strong></strong></p><p><strong><strong>在后台，jsp调用Test.java类，然后调用Camel进行相遇。camel-client.xml仅使用几行XML定义客户端：</strong></strong></p><pre><code class="language-xml">&lt;!-- Leave this, as it's needed to make Camel "drools" aware --&gt;
&lt;bean id="kiePolicy" class="org.kie.camel.component.KiePolicy" /&gt;
  
&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;route&gt;
     &lt;from uri="direct://kservice/rest"/&gt;
     &lt;policy ref="kiePolicy"&gt;
       &lt;to uri="cxfrs://http://localhost:8080/drools-server/kservice/rest"/&gt;
     &lt;/policy&gt;
  &lt;/route&gt;
  &lt;route&gt;
    &lt;from uri="direct://kservice/soap"/&gt;
    &lt;policy ref="kiePolicy"&gt;
      &lt;to uri="cxfrs://http://localhost:8080/drools-server/kservice/soap"/&gt;
    &lt;/policy&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre><p><strong><strong>“ direct：// kservice”只是一个命名的钩子，允许Java获取引用并将数据推入其中。在这个例子中，数据已经是XML格式，因此我们不需要添加任何数据<code class="code">DataFormat</code>进行编组。KiePolicy在路由中添加了一些技巧，您还将看到它在服务器端也得到了使用。如果使用JAXB或XStream，它将注入自定义路径和转换器，它也可以在服务器端设置ClassLoader，在客户端它会自动解包Response对象。</strong></strong></p><p><strong><strong>规则本身可以在这里找到：test.drl。请注意，消息类型声明为DRL的一部分，因此在类路径中不存在。</strong></strong></p><pre><code class="no-highlight">declare Message
   text : String
end
    
  
rule "echo" dialect "mvel"
when
   $m : Message();
then
   $m.text = "echo:" + $m.text;
end
</code></pre></div></div></div></div><div class="chapter" title="第十七章带有RHQ / JON的JMX监视"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="RHQChapter"></a>第十七章带有RHQ / JON的JMX监视</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e16550">17.1。介绍</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e16555">17.1.1。在Drools应用程序中启用JMX监视</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e16574">17.1.2。安装并运行RHQ / JON插件</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="17.1。介绍"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e16550"></a> 17.1。介绍</strong></strong></h2></div></div></div><p><strong><strong>Drools引擎支持通过JMX标准MBean进行运行时监视。这些MBean公开了从实时知识库和会话到内部详细信息（如规则执行时间）的配置和指标数据。任何与JMX兼容的控制台都可以用来访问该数据。本章详细介绍了如何使用RHQ / JON进行此操作，但是类似的步骤也可以用于任何其他控制台。</strong></strong></p><div class="section" title="17.1.1。在Drools应用程序中启用JMX监视"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16555"></a> 17.1.1。在Drools应用程序中启用JMX监视</strong></strong></h3></div></div></div><p><strong><strong>要在Drools应用程序中启用JMX监视，必须在JVM中启用远程监视。关于如何在Internet上执行此操作，有一些教程，但是我们建议您检查特定JVM的文档。使用Oracle / Sun JVM，它可以像运行带有几个命令行系统属性的引擎一样简单。</strong></strong></p><p><strong><strong>例如，要使用禁用的身份验证在端口19988上启用远程监视（应仅用于测试/演示，如应启用生产身份验证），只需使用以下命令行参数运行应用程序：</strong></strong></p><pre><code class="language-xml"> -Dcom.sun.management.jmxremote.port=19988 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false
</code></pre><p><strong><strong>第二步是启用Drools MBean。与任何Drools配置一样，可以通过设置系统属性或将该属性添加到配置文件中或使用API来完成。</strong></strong></p><p><strong><strong>要在命令行中启用它，请使用：</strong></strong></p><pre><code class="language-xml"> -Dkie.mbeans=enabled</code></pre><p><strong><strong>要使用API启用ID，请使用：</strong></strong></p><pre><code class="language-xml"> KieBaseConfiguration conf = ...
 conf.setOption( MBeansOption.ENABLED );</code></pre></div><div class="section" title="17.1.2。安装并运行RHQ / JON插件"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e16574"></a> 17.1.2。安装并运行RHQ / JON插件</strong></strong></h3></div></div></div><p><strong><strong>以下步骤序列可用于将JON配置为监视Drools应用程序：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>下载JON服务器和代理。</strong></strong></p></li><li class="listitem"><p><strong><strong>下载包含在“ Drools和jBPM工具”捆绑包中的Drools插件（http://www.jboss.org/drools/downloads.html）。</strong></strong></p></li><li class="listitem"><p><strong><strong>安装服务器，代理和插件。</strong></strong></p></li><li class="listitem"><p><strong><strong>检查服务器是否正在运行，代理是否正在运行以及插件是否已安装。</strong></strong></p></li><li class="listitem"><p><strong><strong>执行drools应用程序[请参阅上一节中的详细信息]。</strong></strong></p></li><li class="listitem"><p><strong><strong>在代理控制台上，为代理键入“发现”命令以找到drools应用程序，该应用程序将在端口19988上找到。</strong></strong></p></li><li class="listitem"><p><strong><strong>在JON控制台上，单击自动发现队列。</strong></strong></p></li><li class="listitem"><p><strong><strong>选择那里显示的在端口19988上运行的JMX Server进程。</strong></strong></p></li><li class="listitem"><p><strong><strong>单击导入。</strong></strong></p></li><li class="listitem"><p><strong><strong>单击资源->服务器。</strong></strong></p></li><li class="listitem"><p><strong><strong>单击JMX服务器。</strong></strong></p></li><li class="listitem"><p><strong><strong>在左侧的JMXServer下，您有Drools Service。</strong></strong></p></li></ol></div></div></div></div></div><div class="part" title="第五部分Drools工作台"><div class="titlepage"><div><div><h1 class="title"><strong><strong><a id="d0e16616"></a>第五部分Drools工作台</strong></strong></h1></div></div></div><div class="partintro" title="Drools工作台"><div></div><p><strong><strong>Drools工作台是使用UberFire框架构建的，并使用Guvnor插件。Drools提供了一组额外的丰富插件，用于规则创作隐喻。</strong></strong></p><div class="toc"><p><strong><strong><strong>目录</strong></strong></strong></p><dl><dt><strong><strong><span class="chapter"><a href="#wb.Workbench">18岁工作台（常规）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.Installation">18.1。安装</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.warInstallation">18.1.1。战争安装</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.workbenchData">18.1.2。工作台数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.systemProperties">18.1.3。系统属性</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.troubleShooting">18.1.4。故障排除</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.QuickStart">18.2。快速开始</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.QuickStartAddRepository">18.2.1。添加资料库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartAddProject">18.2.2。添加项目</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartDefineDataModel">18.2.3。定义数据模型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartDefineRule">18.2.4。定义规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartBuildAndDeloy">18.2.5。构建和部署</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Administration">18.3。管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.administrationOverview">18.3.1。管理概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.OrganizationalUnit">18.3.2。组织单元</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.VFSRepository">18.3.3。储存库</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Configuration">18.4。组态</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.UserManagement">18.4.1。基本用户管理</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Roles">18.4.2。的角色</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.RestrictedAccess">18.4.3。限制对存储库的访问</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.CommandLineConfig">18.4.4。命令行配置工具</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Introduction">18.5。介绍</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.LogInAndLogOut">18.5.1。登录并注销</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.HomeScreen">18.5.2。主屏幕</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.WorkbenchConcepts">18.5.3。工作台概念</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.InitialLayout">18.5.4。初始布局</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.ChangingLayout">18.6。改变布局</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.Resizing">18.6.1。调整大小</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Repositioning">18.6.2。重新定位</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Authoring">18.7。创作（一般）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.ArtifactRepository">18.7.1。工件存储库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.AssetEditor">18.7.2。资产编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.TagsEditor">18.7.3。标签编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ProjectExplorer">18.7.4。项目浏览器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ProjectEditor">18.7.5。项目编辑</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Validation">18.7.6。验证方式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.DataModeller">18.7.7。数据建模师</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.DataSets">18.7.8。数据集</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.UserAndGroupMgmt">18.8。用户和组管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e19602">18.8.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19623">18.8.2。安全管理提供商</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19730">18.8.3。安装与设定</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19860">18.8.4。用法</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Embedding">18.9。在您的应用程序中嵌入工作台</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.AssetManagement">18.10。资产管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.assetMgmtOverview">18.10.1。资产管理概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtManagedVsUnmanaged">18.10.2。托管与非托管存储库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtProcesses">18.10.3。资产管理流程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtUsageFlow">18.10.4。使用流程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtRepositoryStructure">18.10.5。储存库结构</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtManagedRepositoryOperations">18.10.6。托管存储库操作</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.ExecServerUI">18.11。执行服务器管理UI</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.ExecServerUITemplate">18.11.1。服务器模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ExecServerUIContainer">18.11.2。容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ExecServerUIRemoteServer">18.11.3。远端伺服器</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#drools.AuthoringAssets">19创作规则资产</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.NewPackage">19.1。创建一个包</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e20580">19.1.1。空包装</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e20599">19.1.2。复制，重命名和删除软件包</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditor">19.2。指导编辑的业务规则</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorParts">19.2.1。指导规则编辑器的部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorLHS">19.2.2。规则的“何时”（左侧）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorRHS">19.2.3。规则的“ THEN”（右侧）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorOptionalAttributes">19.2.4。可选属性</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorToolbar">19.2.5。模式/动作工具栏</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorEnumerations">19.2.6。用户驱动的下拉列表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorDSL">19.2.7。DSL句子增强</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorComplexExample">19.2.8。一个更复杂的示例：</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditor">19.3。资产/规则模板</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorCreating">19.3.1。创建规则模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefining">19.3.2。定义模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefiningData">19.3.3。定义模板数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorGeneratedDRL">19.3.4。生成的DRL</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditor">19.4。指导决策表（基于Web）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorTypesOfDecisionTable">19.4.1。决策表类型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorConcepts">19.4.2。主要组成部分\概念</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorDefining">19.4.3。定义基于Web的决策表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorRuleDefinitions">19.4.4。规则定义</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorAuditLog">19.4.5。审核日志</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorVerification">19.4.6。实时验证与确认</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTreeEditor">19.5。指导决策树</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e21644">19.5.1。初始编辑器布局</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21692">19.5.2。第一步</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21730">19.5.3。编辑数据对象节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21743">19.5.4。编辑字段约束节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21756">19.5.5。编辑动作节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21789">19.5.6。管理树</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.XLSDecisionTable">19.6。电子表格决策表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditor">19.7。计分卡</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditorSetupParameters">19.7.1。 （a）设定参数</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditorCharacteristics">19.7.2。 （b）特征</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditor">19.8。测试场景</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.KSessionSelector">19.8.1。知识会议选择器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorGivenSection">19.8.2。给定部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorExpectedSection">19.8.3。期望部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorGlobalSection">19.8.4。全球部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorInpuotSection">19.8.5。新输入部分</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.FunctionEditor">19.9。功能</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.DSLEditor">19.10。DSL编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.EnumerationEditor">19.11。数据枚举（下拉列表配置）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.AdvancedEnumConcepts">19.11.1。高级枚举概念</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.DRLEditor">19.12。技术规则（DRL）</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="chapter"><a href="#wb.WorkbenchIntegration">20工作台整合</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.WorkbenchRemoteAPI">20.1。休息</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e22427">20.1.1。求职电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22531">20.1.2。储存库调用</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22706">20.1.3。组织单位电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22837">20.1.4。Maven电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22953">20.1.5。REST摘要</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#kie.KeycloakSSOIntegration">20.2。Keycloak SSO集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e23153">20.2.1。情境</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23178">20.2.2。安装和设置Keycloak服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23222">20.2.3。创建并设置演示领域</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23351">20.2.4。安装和设置jBPM Workbench</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23519">20.2.5。通过Keycloak保护工作台远程服务</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23565">20.2.6。通过Keycloak保护工作台的文件系统服务</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23668">20.2.7。执行服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23850">20.2.8。消费远程服务</a></span></strong></strong></dt></dl></dd></dl></dd><dt><strong><strong><span class="chapter"><a href="#wb.WorkbenchHighAvailability">21工作台高可用性</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.HighAvailability">21.1。</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.vfsClustering">21.1.1。VFS群集</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24193">21.1.2。 jBPM集群</a></span></strong></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第十八章工作台（常规）"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Workbench"></a>第十八章工作台（常规）</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#wb.Installation">18.1。安装</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.warInstallation">18.1.1。战争安装</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.workbenchData">18.1.2。工作台数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.systemProperties">18.1.3。系统属性</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.troubleShooting">18.1.4。故障排除</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.QuickStart">18.2。快速开始</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.QuickStartAddRepository">18.2.1。添加资料库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartAddProject">18.2.2。添加项目</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartDefineDataModel">18.2.3。定义数据模型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartDefineRule">18.2.4。定义规则</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.QuickStartBuildAndDeloy">18.2.5。构建和部署</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Administration">18.3。管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.administrationOverview">18.3.1。管理概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.OrganizationalUnit">18.3.2。组织单元</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.VFSRepository">18.3.3。储存库</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Configuration">18.4。组态</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.UserManagement">18.4.1。基本用户管理</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Roles">18.4.2。的角色</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.RestrictedAccess">18.4.3。限制对存储库的访问</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.CommandLineConfig">18.4.4。命令行配置工具</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Introduction">18.5。介绍</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.LogInAndLogOut">18.5.1。登录并注销</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.HomeScreen">18.5.2。主屏幕</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.WorkbenchConcepts">18.5.3。工作台概念</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.InitialLayout">18.5.4。初始布局</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.ChangingLayout">18.6。改变布局</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.Resizing">18.6.1。调整大小</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Repositioning">18.6.2。重新定位</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Authoring">18.7。创作（一般）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.ArtifactRepository">18.7.1。工件存储库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.AssetEditor">18.7.2。资产编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.TagsEditor">18.7.3。标签编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ProjectExplorer">18.7.4。项目浏览器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ProjectEditor">18.7.5。项目编辑</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.Validation">18.7.6。验证方式</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.DataModeller">18.7.7。数据建模师</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.DataSets">18.7.8。数据集</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.UserAndGroupMgmt">18.8。用户和组管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e19602">18.8.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19623">18.8.2。安全管理提供商</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19730">18.8.3。安装与设定</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e19860">18.8.4。用法</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.Embedding">18.9。在您的应用程序中嵌入工作台</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.AssetManagement">18.10。资产管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.assetMgmtOverview">18.10.1。资产管理概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtManagedVsUnmanaged">18.10.2。托管与非托管存储库</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtProcesses">18.10.3。资产管理流程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtUsageFlow">18.10.4。使用流程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtRepositoryStructure">18.10.5。储存库结构</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.assetMgmtManagedRepositoryOperations">18.10.6。托管存储库操作</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#wb.ExecServerUI">18.11。执行服务器管理UI</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.ExecServerUITemplate">18.11.1。服务器模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ExecServerUIContainer">18.11.2。容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#wb.ExecServerUIRemoteServer">18.11.3。远端伺服器</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="18.1。安装"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Installation"></a> 18.1。安装</strong></strong></h2></div></div></div><div class="section" title="18.1.1。战争安装"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.warInstallation"></a> 18.1.1。战争安装</strong></strong></h3></div></div></div><p><strong><strong>使用<code class="literal">war</code>从与您的应用程序服务器相对应的工作台分发zip中获取。这些之间的区别<code class="literal">war</code>文件主要是肤浅的。例如，如果应用程序服务器已经提供了某些JAR，则可能会排除它们。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="literal">eap6_4</code> ：针对Red Hat JBoss企业应用平台6.4量身定制</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">tomcat7</code> ：针对Apache Tomcat 7量身定制</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>Apache Tomcat需要其他配置才能正确安装Workbench。请咨询<code class="literal">README.md</code>在里面<code class="literal">war</code>最新的程序。</strong></strong></p></div></li><li class="listitem"><p><strong><strong><code class="literal">was8</code> ：针对IBM WebSphere Application Server 8量身定制</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="literal">weblogic12</code> ：针对Oracle WebLogic Server 12c量身定制</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>Oracle WebLogic需要其他配置才能正确安装Workbench。请咨询<code class="literal">README.md</code>在里面<code class="literal">war</code>最新的程序。</strong></strong></p></div></li><li class="listitem"><p><strong><strong><code class="literal">wildfly8</code> ：专为Red Hat JBoss Wildfly 8设计</strong></strong></p></li></ul></div></div><div class="section" title="18.1.2。工作台数据"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.workbenchData"></a> 18.1.2。工作台数据</strong></strong></h3></div></div></div><p><strong><strong>工作台默认将其数据存储在目录中<code class="literal">$WORKING_DIRECTORY/.niogit</code> ， 例如<code class="literal">wildfly-8.0.0.Final/bin/.niogit</code> ，但是可以使用<a class="link" href="#wb.systemProperties" title="18.1.3。系统属性">system属性</a>覆盖它<code class="literal">-Dorg.uberfire.nio.git.dir</code> 。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>在生产中，请确保备份工作台数据目录。</strong></strong></p></div></div><div class="section" title="18.1.3。系统属性"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.systemProperties"></a> 18.1.3。系统属性</strong></strong></h3></div></div></div><p><strong><strong>这是所有系统属性的列表：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.dir</code></strong></span> ：目录的位置<code class="literal">.niogit</code> 。默认值：工作目录</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.daemon.enabled</code></strong></span> ：启用/禁用git守护程序。默认：<code class="literal">true</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.daemon.host</code></strong></span> ：如果启用了git daemon，则将此属性用作本地主机标识符。默认：<code class="literal">localhost</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.daemon.port</code></strong></span> ：如果启用了git daemon，则将此属性用作端口号。默认：<code class="literal">9418</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.ssh.enabled</code></strong></span> ：启用/禁用ssh守护程序。默认：<code class="literal">true</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.ssh.host</code></strong></span> ：如果启用了ssh守护程序，则将此属性用作本地主机标识符。默认：<code class="literal">localhost</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.ssh.port</code></strong></span> ：如果启用了ssh守护程序，则将此属性用作端口号。默认：<code class="literal">8001</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.ssh.cert.dir</code></strong></span> ：目录的位置<code class="literal">.security</code>存储本地证书的位置。默认值：工作目录</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.hooks</code></strong></span> ：包含Git钩子脚本的目录的位置，这些脚本已安装到在工作台中创建（或克隆）的每个存储库中。默认值：N / A</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.nio.git.ssh.passphrase</code></strong></span> ：克隆时使用密码短语访问您的操作系统公用密钥库<code class="literal">git</code>具有的存储库<code class="literal">scp</code>样式网址；例如<code class="literal">git@github.com:user/repository.git</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.metadata.index.dir</code></strong></span> ：Lucene的地方<code class="literal">.index</code>文件夹将被存储。默认值：工作目录</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.cluster.id</code></strong></span> ：螺旋簇的名称，例如：<code class="literal">kie-cluster</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.cluster.zk</code></strong></span> ：与Zookeeper的连接字符串。这是形式<code class="literal">host1:port1,host2:port2,host3:port3</code> ， 例如：<code class="literal">localhost:2188</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.cluster.local.id</code></strong></span> ：螺旋群集节点的唯一ID，请注意，“ <code class="literal">:</code> '替换为' <code class="literal">_</code> '， 例如：<code class="literal">node1_12345</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.cluster.vfs.lock</code></strong></span> ：在螺旋集群上定义的资源名称，例如：<code class="literal">kie-vfs</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.cluster.autostart</code></strong></span> ：将VFS群集延迟到应用程序完全初始化之前，以避免所有群集成员创建本地克隆时发生冲突。默认：<code class="literal">false</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.sys.repo.monitor.disabled</code></strong></span> ：禁用配置监视器（除非您知道自己在做什么，否则不要禁用）。默认：<code class="literal">false</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.secure.key</code></strong></span> ：密码加密使用的秘密密码。默认：<code class="literal">org.uberfire.admin</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.secure.alg</code></strong></span> ：密码加密所使用的加密算法。默认：<code class="literal">PBEWithMD5AndDES</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.uberfire.domain</code></strong></span> ：uberfire使用的安全域名。默认：<code class="literal">ApplicationRealm</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.guvnor.m2repo.dir</code></strong></span> ：Maven存储库文件夹的存储位置。默认值：工作目录/存储库/基</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.guvnor.project.gav.check.disabled</code></strong></span> ：禁用GAV检查。默认：<code class="literal">false</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.kie.example.repositories</code></strong></span> ：将在其中克隆演示存储库的文件夹。演示存储库需要已获取并放置在此文件夹中。可以从kie-wb-6.2.0-SNAPSHOT-example-repositories.zip工件获得演示存储库。此系统属性优先于org.kie.demo和org.kie.example。默认值：不使用。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.kie.demo</code></strong></span> ：从GitHub启用演示应用程序的外部克隆。此系统属性优先于org.kie.example。默认：<code class="literal">true</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.kie.example</code></strong></span> ：启用由存储库，组织单位和项目组成的示例结构。默认：<code class="literal">false</code></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong><code class="literal">org.kie.build.disable-project-explorer</code></strong></span> ：在项目资源管理器中禁用所选项目的自动构建。默认：<code class="literal">false</code></strong></strong></p></li></ul></div><p><strong><strong>要在WildFly或JBoss EAP集群中更改这些系统属性之一：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>编辑档案<code class="literal">$JBOSS_HOME/domain/configuration/host.xml</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>找到XML元素<code class="literal">server</code>属于<code class="literal">main-server-group</code>并添加系统属性，例如：</strong></strong></p><pre><code class="language-xml">&lt;system-properties&gt;
  &lt;property name="org.uberfire.nio.git.dir" value="..." boot-time="false"/&gt;
  ...
&lt;/system-properties&gt;</code></pre></li></ol></div></div><div class="section" title="18.1.4。故障排除"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.troubleShooting"></a> 18.1.4。故障排除</strong></strong></h3></div></div></div><div class="section" title="18.1.4.1。加载中..不会消失，Workbench无法显示"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.troubleShootingLoadingSpinner"></a> 18.1.4.1。加载中..不会消失，Workbench无法显示</strong></strong></h4></div></div></div><p><strong><strong>有报告说，服务器和浏览器之间的防火墙可能会干扰工作台使用的服务器发送事件（SSE）。</strong></strong></p><p><strong><strong>该问题导致“正在加载...”微调器仍然可见，并且工作台无法实现。</strong></strong></p><p><strong><strong>解决方法是通过添加文件来禁用工作台对服务器发送事件的使用<code class="literal">/WEB-INF/classes/ErraiService.properties</code>到包含值的爆炸WAR <code class="literal">errai.bus.enable_sse_support=false</code> 。重新包装WAR，然后重新部署。</strong></strong></p></div></div></div><div class="section" title="18.2。快速开始"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.QuickStart"></a> 18.2。快速开始</strong></strong></h2></div></div></div><p><strong><strong>这些步骤可帮助您以最小的努力入门。</strong></strong></p><p><strong><strong>它们不能代替完整阅读文档。</strong></strong></p><div class="section" title="18.2.1。添加资料库"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.QuickStartAddRepository"></a> 18.2.1。添加资料库</strong></strong></h3></div></div></div><p><strong><strong>通过选择管理透视图，创建一个新的存储库来保存您的项目。</strong></strong></p><div class="figure"><strong><strong><a id="d0e16980"></a><p class="title"><strong>图18.1。选择管理角度</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart1.png" align="middle" alt="选择管理角度"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>从菜单中选择“新存储库”选项。</p><div class="figure"><a id="d0e16988"></a><p class="title"><strong>图18.2。创建新的存储库</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart2.png" align="middle" alt="创建新的存储库"></div></div></div><br class="figure-break"><p>输入所需的信息。</p><div class="figure"><a id="d0e16996"></a><p class="title"><strong>图18.3。输入存储库信息步骤1/2</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart3.png" align="middle" alt="输入存储库信息步骤1/2"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e17002"></a><p class="title"><strong>图18.4。输入存储库信息步骤2/2（仅适用于托管存储库）</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart3b.png" align="middle" alt="输入存储库信息步骤2/2（仅适用于托管存储库）"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.2.2。添加项目"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.QuickStartAddProject"></a> 18.2.2。添加项目</strong></strong></h3></div></div></div><p><strong><strong>选择Authoring Perspective创建一个新项目。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17013"></a><p class="title"><strong>图18.5。选择创作透视图</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart4.png" align="middle" alt="选择创作透视图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>从“新建项目”菜单中选择“项目”。</p><div class="figure"><a id="d0e17021"></a><p class="title"><strong>图18.6。建立新专案</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart5.png" align="middle" alt="建立新专案"></div></div></div><br class="figure-break"><p>首先输入项目名称。</p><div class="figure"><a id="d0e17029"></a><p class="title"><strong>图18.7。输入项目名称</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart6.png" align="middle" alt="输入项目名称"></div></div></div><br class="figure-break"><p>接下来输入项目详细信息。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>组ID遵循Maven约定。</p></li><li class="listitem"><p>项目名称中已预先填充工件ID。</p></li><li class="listitem"><p>默认情况下，版本设置为1.0。</p></li></ul></div><div class="figure"><a id="d0e17047"></a><p class="title"><strong>图18.8。输入项目详细信息</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart7.png" align="middle" alt="输入项目详细信息"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.2.3。定义数据模型"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.QuickStartDefineDataModel"></a> 18.2.3。定义数据模型</strong></strong></h3></div></div></div><p><strong><strong>创建项目后，您需要定义规则要使用的类型。</strong></strong></p><p><strong><strong>从“新建项目”菜单中选择“数据对象”。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>您还可以使用现有JAR中包含的类型。</strong></strong></p><p><strong><strong>有关详细信息，请查阅完整的文档。</strong></strong></p></div><div class="figure"><strong><strong><a id="d0e17065"></a><p class="title"><strong>图18.9。创建“数据对象”</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart8.png" align="middle" alt="创造" data="" objec="" =""></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>设置名称并为新类型选择一个包。</p><div class="figure"><a id="d0e17073"></a><p class="title"><strong>图18.10。创建一个新类型</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart9.png" align="middle" alt="创建一个新类型"></div></div></div><br class="figure-break"><p>设置字段名称和类型，然后单击“创建”以创建类型的字段。</p><div class="figure"><a id="d0e17081"></a><p class="title"><strong>图18.11。点击“创建”并添加字段</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart10.png" align="middle" alt="请点击" creat="=" =""></div></div></div><br class="figure-break"><p>单击“保存”以更新模型。</p><div class="figure"><a id="d0e17089"></a><p class="title"><strong>图18.12。点击“保存”</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart11.png" align="middle" alt="点击" sav="" =""></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.2.4。定义规则"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.QuickStartDefineRule"></a> 18.2.4。定义规则</strong></strong></h3></div></div></div><p><strong><strong>从“新建项目”菜单中选择“ DRL文件”（例如）。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17100"></a><p class="title"><strong>图18.13。从“新建项目”菜单中选择“ DRL文件”</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart12.png" align="middle" alt="选择中" drl="" fil="=" new="" ite="=" =""></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>输入新规则的文件名。</p><div class="figure"><a id="d0e17108"></a><p class="title"><strong>图18.14。输入规则的文件名</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart13.png" align="middle" alt="输入规则的文件名"></div></div></div><br class="figure-break"><p>输入规则的定义。</p><p>定义过程因资产类型而异。</p><p>完整的文档包含有关不同编辑器的详细信息。</p><div class="figure"><a id="d0e17120"></a><p class="title"><strong>图18.15。定义规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart14.png" align="middle" alt="定义规则"></div></div></div><br class="figure-break"><p>一旦定义了规则，将需要保存它。</p><div class="figure"><a id="d0e17128"></a><p class="title"><strong>图18.16。保存规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart15.png" align="middle" alt="保存规则"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.2.5。构建和部署"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.QuickStartBuildAndDeloy"></a> 18.2.5。构建和部署</strong></strong></h3></div></div></div><p><strong><strong>一旦在项目中定义了规则；可以构建该项目并将其部署到Workbench的Maven Artifact信息库。</strong></strong></p><p><strong><strong>要构建项目，请从“项目”菜单中选择“项目编辑器”。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17141"></a><p class="title"><strong>图18.17。选择“项目编辑器”</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart16.png" align="middle" alt="选择中" project="" edito="" =""></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>单击“构建并部署”以构建项目并将其部署到Workbench的Maven Artifact存储库。</p><p>当选择Build＆Deploy时，工作台将部署到工作台项目pom的Dependency Management部分中定义的任何存储库。您可以在项目浏览器的“存储库视图”下编辑与您的工作台项目关联的pom.xml文件。可以在以下位置找到有关Maven中的依赖管理的详细信息：http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</p><p>如果在构建过程中出现错误，则将在“问题面板”中报告这些错误。</p><div class="figure"><a id="d0e17153"></a><p class="title"><strong>图18.18。建立和部署项目</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/QuickStart/QuickStart17.png" align="middle" alt="建立和部署项目"></div></div></div><br class="figure-break"><p>现在，该项目已构建并部署；可以像其他任何Maven Artifact一样从您自己的项目中引用它。</p><p>完整的文档包含有关将项目与您自己的应用程序集成的详细信息。</p></strong></strong></div></div><div class="section" title="18.3。管理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Administration"></a> 18.3。管理</strong></strong></h2></div></div></div><div class="section" title="18.3.1。管理概述"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.administrationOverview"></a> 18.3.1。管理概述</strong></strong></h3></div></div></div><p><strong><strong>工作台由组织单位，VFS存储库和项目构成：</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Administration/workbenchStructureOverview.png"></strong></strong></div></div><div class="section" title="18.3.2。组织单元"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.OrganizationalUnit"></a> 18.3.2。组织单元</strong></strong></h3></div></div></div><p><strong><strong>组织单位对于模拟部门和部门很有用。</strong></strong></p><p><strong><strong>一个组织单位可以容纳多个存储库。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Administration/organizationalUnitManager.png"></strong></strong></div></div><div class="section" title="18.3.3。储存库"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.VFSRepository"></a> 18.3.3。储存库</strong></strong></h3></div></div></div><p><strong><strong>存储库是存储资产的地方，每个存储库由项目进行组织，并且属于单个组织单位。</strong></strong></p><p><strong><strong>信息库实际上是基于虚拟文件系统的存储，默认情况下使用GIT作为后端。这样的设置允许工作台与多个后端一起工作，并同时充分利用后端特定功能，例如在GIT案例版本控制，分支甚至外部访问中。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Administration/repositoriesEditor.png"></strong></strong></div><p><strong><strong>可以从头开始创建新存储库，也可以从现有存储库克隆新存储库。</strong></strong></p><p><strong><strong>将GIT用作后端的最大优势之一是能够从外部克隆存储库并使用首选工具来编辑和构建资产的能力。</strong></strong></p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong><span class="bold"><strong>切勿</strong></span>直接从<a class="link" href="#wb.systemProperties" title="18.1.3。系统属性">.niogit</a>目录克隆您的存储库。始终使用存储库编辑器中显示的可用协议。</strong></strong></p></div><div class="section" title="18.3.3.1。资料库编辑器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.VFSRepositoryEditor"></a> 18.3.3.1。资料库编辑器</strong></strong></h4></div></div></div><p><strong><strong>使用GIT作为后端的另一个好处是可以将您的存储库恢复到以前的状态。您可以直接从存储库编辑器中进行操作，方法是浏览其提交历史记录，然后单击“ <span class="bold"><strong>还原”</strong></span>按钮。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Administration/repositoryEditor.png"></strong></strong></div></div></div></div><div class="section" title="18.4。组态"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Configuration"></a> 18.4。组态</strong></strong></h2></div></div></div><div class="section" title="18.4.1。基本用户管理"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.UserManagement"></a> 18.4.1。基本用户管理</strong></strong></h3></div></div></div><p><strong><strong>工作台根据应用程序服务器的身份验证和授权（JAAS）对用户进行身份验证。</strong></strong></p><p><strong><strong>在JBoss EAP和WildFly上，使用脚本添加用户<code class="literal">$JBOSS_HOME/bin/add-user.sh</code> （要么<code class="literal">.bat</code> ）：</strong></strong></p><pre><code class="no-highlight">$ ./add-user.sh
// Type: Application User
// Realm: empty (defaults to ApplicationRealm)
// Role: admin</code></pre><p><strong><strong>无需重新启动应用程序服务器。</strong></strong></p></div><div class="section" title="18.4.2。的角色"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.Roles"></a> 18.4.2。的角色</strong></strong></h3></div></div></div><p><strong><strong>工作台使用以下角色：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>管理员</strong></strong></p></li><li class="listitem"><p><strong><strong>分析员</strong></strong></p></li><li class="listitem"><p><strong><strong>开发商</strong></strong></p></li><li class="listitem"><p><strong><strong>经理</strong></strong></p></li><li class="listitem"><p><strong><strong>用户</strong></strong></p></li></ul></div><div class="section" title="18.4.2.1。管理员"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17258"></a> 18.4.2.1。管理员</strong></strong></h4></div></div></div><p><strong><strong>管理BPMS系统。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>管理用户</strong></strong></p></li><li class="listitem"><p><strong><strong>管理VFS存储库</strong></strong></p></li><li class="listitem"><p><strong><strong>有权进行任何必要的更改</strong></strong></p></li></ul></div></div><div class="section" title="18.4.2.2。开发者"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17273"></a> 18.4.2.2。开发者</strong></strong></h4></div></div></div><p><strong><strong>除克隆存储库外，开发人员几乎可以执行管理员可以做的所有事情。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>管理规则，模型，流程，表单和仪表板</strong></strong></p></li><li class="listitem"><p><strong><strong>管理资产存储库</strong></strong></p></li><li class="listitem"><p><strong><strong>可以创建，构建和部署项目</strong></strong></p></li><li class="listitem"><p><strong><strong>可以使用JBDS连接来查看进程</strong></strong></p></li></ul></div></div><div class="section" title="18.4.2.3。分析员"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17291"></a> 18.4.2.3。分析员</strong></strong></h4></div></div></div><p><strong><strong>Analyst是开发人员的较弱版本，无法访问资产存储库或部署项目的能力。</strong></strong></p></div><div class="section" title="18.4.2.4。业务用户"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17296"></a> 18.4.2.4。业务用户</strong></strong></h4></div></div></div><p><strong><strong>系统的日常用户，对流程继续进行所需的业务任务执行操作。主要与任务列表一起使用。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>是否进行流程管理</strong></strong></p></li><li class="listitem"><p><strong><strong>处理任务和仪表板</strong></strong></p></li></ul></div></div><div class="section" title="18.4.2.5。仅限管理员/查看者的用户"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17308"></a> 18.4.2.5。仅限管理员/查看者的用户</strong></strong></h4></div></div></div><p><strong><strong>对系统感兴趣的系统查看者，对有关业务流程及其性能，业务指标以及系统的其他报告以及与系统进行交互的人员的统计信息感兴趣。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>仅有权访问仪表板</strong></strong></p></li></ul></div></div></div><div class="section" title="18.4.3。限制对存储库的访问"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.RestrictedAccess"></a> 18.4.3。限制对存储库的访问</strong></strong></h3></div></div></div><p><strong><strong>可以使用角色和组织组来限制对存储库的访问。让用户访问存储库。</strong></strong></p><p><strong><strong>用户要么必须属于有权访问该存储库的角色，要么必须属于一个有权访问该存储库的组织组的角色。这些限制可以使用命令行配置工具进行管理。</strong></strong></p></div><div class="section" title="18.4.4。命令行配置工具"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.CommandLineConfig"></a> 18.4.4。命令行配置工具</strong></strong></h3></div></div></div><p><strong><strong>提供从命令行管理系统存储库的功能。系统存储库包含有关常规工作台设置的数据：编辑器的行为方式，组织组，安全性以及用户无法编辑的其他设置。系统存储库位于.niogit文件夹中，位于所有已创建或克隆到工作台中的存储库旁边。</strong></strong></p><div class="section" title="18.4.4.1。配置工具模式"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17329"></a> 18.4.4.1。配置工具模式</strong></strong></h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>联机（默认和推荐）-启动时使用KIE Workbench提供的Git服务器连接到Git存储库。所有更改均在本地进行，并在以下情况下发布到上游：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>明确执行“ push-changes”命令</strong></strong></p></li><li class="listitem"><p><strong><strong>“退出”用于关闭工具</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>脱机-直接在服务器上创建和操作系统存储库（无丢弃选项）</strong></strong></p></li></ul></div></div><div class="section" title="18.4.4.2。可用命令"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17346"></a> 18.4.4.2。可用命令</strong></strong></h4></div></div></div><div class="table"><strong><strong><a id="d0e17349"></a><p class="title"><strong>表18.1。可用命令</strong></p><div class="table-contents"><table border="1" summary="Available Commands"><colgroup><col><col></colgroup><tbody><tr><td align="left">出口</td><td align="left">发布本地更改，清理临时目录并退出命令行工具</td></tr><tr><td align="left">丢弃</td><td align="left">放弃本地更改而不发布它们，清理临时目录并退出命令行工具</td></tr><tr><td align="left">救命</td><td align="left">打印可用命令列表</td></tr><tr><td align="left">列表仓库</td><td align="left">列出可用的存储库</td></tr><tr><td align="left">List-org-units</td><td align="left">列出可用的组织单位</td></tr><tr><td align="left">列表部署</td><td align="left">列出可用的部署</td></tr><tr><td align="left">创建组织单位</td><td align="left">创建新的组织单位</td></tr><tr><td align="left">删除组织单位</td><td align="left">删除现有的组织单位</td></tr><tr><td align="left">增加部署</td><td align="left">添加新的部署单元</td></tr><tr><td align="left">撤消部署</td><td align="left">删除现有部署</td></tr><tr><td align="left">创建仓库</td><td align="left">创建新的git仓库</td></tr><tr><td align="left">删除回购</td><td align="left">删除现有存储库（仅从config）</td></tr><tr><td align="left">add-repo-org-unit</td><td align="left">将存储库添加到组织单位</td></tr><tr><td align="left">删除repo-org-unit</td><td align="left">从组织单位中删除存储库</td></tr><tr><td align="left">添加角色回购</td><td align="left">向存储库添加角色</td></tr><tr><td align="left">删除角色回购</td><td align="left">从存储库中删除角色</td></tr><tr><td align="left">add-role-org-unit</td><td align="left">向组织单位添加角色</td></tr><tr><td align="left">删除角色组织单位</td><td align="left">从组织单位中删除角色</td></tr><tr><td align="left">角色项目</td><td align="left">向项目添加角色</td></tr><tr><td align="left">删除角色项目</td><td align="left">从项目中删除角色</td></tr><tr><td align="left">推零钱</td><td align="left">将更改推送到上游存储库（仅在联机模式下）</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></div><div class="section" title="18.4.4.3。如何使用"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e17459"></a> 18.4.4.3。如何使用</strong></strong></h4></div></div></div><p><strong><strong>该工具可以从kie-config-cli-$ {version} -dist.zip中找到。执行kie-config-cli.sh脚本，默认情况下它将以在线模式启动，要求连接Git网址（默认值为ssh：// localhost / system）。要连接到远程服务器，请使用适当的值替换主机和端口，例如ssh：// kie-wb-host / system。</strong></strong></p><pre><code class="no-highlight">./kie-config-cli.sh </code></pre><p><strong><strong>要在离线模式下运行，请将offline参数附加到kie-config-cli.sh命令中。这将改变行为，并要求.niogit（系统存储库）所在的文件夹。如果.niogit还不存在，则文件夹值可以保留为空，并创建一个全新的设置。</strong></strong></p><pre><code class="no-highlight">./kie-config-cli.sh offline</code></pre></div></div></div><div class="section" title="18.5。介绍"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Introduction"></a> 18.5。介绍</strong></strong></h2></div></div></div><div class="section" title="18.5.1。登录并注销"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.LogInAndLogOut"></a> 18.5.1。登录并注销</strong></strong></h3></div></div></div><p><strong><strong>创建一个具有角色的用户<code class="literal">admin</code>并使用这些凭据登录。</strong></strong></p><p><strong><strong>成功登录后，帐户用户名显示在右上角。单击它以查看当前帐户的角色。</strong></strong></p></div><div class="section" title="18.5.2。主屏幕"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.HomeScreen"></a> 18.5.2。主屏幕</strong></strong></h3></div></div></div><p><strong><strong>登录后，显示主屏幕。主屏幕的实际内容取决于工作台变体（Drools，jBPM等）。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/General/home.png"></strong></strong></div></div><div class="section" title="18.5.3。工作台概念"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.WorkbenchConcepts"></a> 18.5.3。工作台概念</strong></strong></h3></div></div></div><p><strong><strong>工作台由不同的逻辑实体组成：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>部分</strong></strong></p><p><strong><strong>部件是用户可以与之交互以执行操作的屏幕或编辑器。</strong></strong></p><p><strong><strong>示例零件为“项目资源管理器”，“项目编辑器”，“指导规则编辑器”等。可以重新放置零件。</strong></strong></p></li><li class="listitem"><p><strong><strong>面板</strong></strong></p><p><strong><strong>面板是一个或多个零件的容器。</strong></strong></p><p><strong><strong>面板可以调整大小。</strong></strong></p></li><li class="listitem"><p><strong><strong>透视</strong></strong></p><p><strong><strong>透视图是相关面板和零件的逻辑分组。</strong></strong></p><p><strong><strong>用户可以通过单击顶级菜单项之一来切换视角。例如“首页”，“创作”，“部署”等。</strong></strong></p></li></ul></div><p><strong><strong>
  </strong></strong></p></div><div class="section" title="18.5.4。初始布局"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.InitialLayout"></a> 18.5.4。初始布局</strong></strong></h3></div></div></div><p><strong><strong>工作台包括三个主要部分。但是其布局和内容可以更改。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17524"></a><p class="title"><strong>图18.19。工作台</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/General/workbench.png" align="middle" alt="工作台"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>初始工作台显示以下组件：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>项目浏览器</p><p>这为用户提供了浏览其配置的能力。组织单位（在上面的“示例”中是组织单位），存储库（在上面的“ uf-playground”中是存储库）和项目（在上面的“抵押”中是项目）。</p></li><li class="listitem"><p>问题</p><p>这为用户提供了有关活动项目中错误的实时反馈。</p></li><li class="listitem"><p>空的空间</p><p>此空白空间将包含一个用于从“项目资源管理器”中选择的资产的编辑器。</p><p>默认情况下，其他屏幕也将占用此空间。例如项目编辑器。</p></li></ul></div></strong></strong></div></div><div class="section" title="18.6。改变布局"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.ChangingLayout"></a> 18.6。改变布局</strong></strong></h2></div></div></div><p><strong><strong>默认布局可能不适合用户。因此，可以调整面板的大小或位置。</strong></strong></p><p><strong><strong>例如，这在运行测试时可能很有用；因为测试定义和规则可以并排放置。</strong></strong></p><div class="section" title="18.6.1。调整大小"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.Resizing"></a> 18.6.1。调整大小</strong></strong></h3></div></div></div><p><strong><strong>以下屏幕截图显示了正在调整尺寸的面板。</strong></strong></p><p><strong><strong>将鼠标指针移到面板拆分器上（面板之间的灰色水平或垂直线）。</strong></strong></p><p><strong><strong>光标将改变，表明它已正确放置在分离器上。按住鼠标左键并将分离器拖动到所需位置；然后释放鼠标左键。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17566"></a><p class="title"><strong>图18.20。调整大小</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/General/workbench-resizing.png" align="middle" alt="调整大小"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.6.2。重新定位"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.Repositioning"></a> 18.6.2。重新定位</strong></strong></h3></div></div></div><p><strong><strong>以下屏幕截图显示了重新定位的面板。</strong></strong></p><p><strong><strong>将鼠标指针移到面板标题上（在此示例中为“指导的编辑器[没有不良信用检查]”）。</strong></strong></p><p><strong><strong>光标将改变，表明它已正确定位在面板标题上。按住鼠标左键。将鼠标拖动到所需的位置。目标位置用浅蓝色矩形指示。通过将鼠标指针悬停在不同的蓝色箭头上可以选择不同的位置。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17581"></a><p class="title"><strong>图18.21。重新定位-拖动</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/General/workbench-repositioning-before.png" align="middle" alt="重新定位-拖动"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e17587"></a><p class="title"><strong>图18.22。重新定位-完成</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/General/workbench-repositioning-after.png" align="middle" alt="重新定位-完成"></div></div></div><br class="figure-break"></strong></strong></div></div><div class="section" title="18.7。创作（一般）"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Authoring"></a> 18.7。创作（一般）</strong></strong></h2></div></div></div><div class="section" title="18.7.1。工件存储库"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.ArtifactRepository"></a> 18.7.1。工件存储库</strong></strong></h3></div></div></div><p><strong><strong>项目通常在类路径中需要外部构件以进行构建，例如域模型JAR。工件存储库保存了这些工件。</strong></strong></p><p><strong><strong>Artifact资料库是功能齐全的Maven资料库。它遵循Maven远程存储库的语义：所有快照都带有时间戳。但是它通常存储在本地硬盘上。</strong></strong></p><p><strong><strong>默认情况下，工件存储库存储在<code class="literal">$WORKING_DIRECTORY/repositories/kie</code> ，但是可以使用<a class="link" href="#wb.systemProperties" title="18.1.3。系统属性">system属性</a>覆盖它<code class="literal">-Dorg.guvnor.m2repo.dir</code> 。每个安装只有1个Maven存储库。</strong></strong></p><p><strong><strong>Artifact存储库屏幕显示了Maven存储库中的工件列表：</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Authoring/ArtifactRepository/mavenRepositoryExplorer.png"></strong></strong></div><p><strong><strong>要将新工件添加到该Maven存储库，请执行以下任一操作：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>使用上传按钮，然后选择一个JAR。如果JAR在以下位置包含POM文件<code class="literal">META-INF/maven</code> （Maven的每个JAR构建都具有），不需要进一步的信息。否则，也需要给出groupId，artifactId和版本。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Authoring/ArtifactRepository/mavenRepositoryUpload.png"></strong></strong></div></li><li class="listitem"><p><strong><strong>使用Maven， <code class="literal">mvn deploy</code>到那个Maven仓库。刷新列表以使其显示。</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>该远程Maven存储库相对简单。它不支持代理，镜像，例如Nexus或Archiva。</strong></strong></p></div></div><div class="section" title="18.7.2。资产编辑器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.AssetEditor"></a> 18.7.2。资产编辑器</strong></strong></h3></div></div></div><p><strong><strong>资产编辑器是工作台用户界面的主要组件。它由两个主要视图“编辑器”和“概述”组成。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>观点</strong></strong></p><div class="figure"><strong><strong><a id="d0e17649"></a><p class="title"><strong>图18.23。资产编辑器-“编辑器”标签</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/AssetEditor/AssetEditor-edit.png" align="middle" alt="资产编辑器-“编辑器”标签"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>答：编辑区域-编辑器采用哪种格式取决于资产类型。一次只能由一位用户编辑资产，以避免冲突。当用户开始编辑资产时，将自动获取锁。这由资产标题栏以及<a class="xref" href="#wb.ProjectExplorer" title="18.7.4. Project Explorer">项目资源管理器</a>视图中显示的锁定符号指示（有关详细信息<a class="xref" href="#wb.ProjectExplorer" title="18.7.4. Project Explorer">，</a>请参见<a class="xref" href="#wb.ProjectExplorer" title="18.7.4。项目浏览器">第18.7.4节“项目资源管理器”</a> ）。如果用户开始编辑已经锁定的资产，则会显示一个弹出通知，通知用户该资产当前无法编辑，因为该资产正在由另一个用户使用。在编辑用户保存或关闭资产，或退出工作台之前，将无法进行更改。会话超时也将导致锁被释放。如果需要，每个用户还可以选择强制释放锁定（请参阅下面的“元数据”部分）。</p></li><li class="listitem"><p>B：此菜单栏包含资产的各种操作；例如保存，重命名，复制等。请注意，如果资产由其他用户锁定，则保存，重命名和删除操作将被停用。</p></li><li class="listitem"><p>C：资产内容或资产信息的不同视图。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>编辑器显示资产的主要编辑器</p></li><li class="listitem"><p>概述包含此编辑器的元数据和对话视图。在下面更详细地解释。</p></li><li class="listitem"><p>来源以纯DRL显示资产。注意：仅当可以将资产内容生成到DRL中时，此选项卡才可见。</p></li><li class="listitem"><p>数据对象包含可用于创作的模型。默认情况下，仅与资产位于同一包中的数据对象可用于创作。可以导入此包外部的数据对象以使其可用于创作资产。</p></li></ul></div></li></ul></div><div class="figure"><a id="d0e17680"></a><p class="title"><strong>图18.24。资产编辑器-数据对象选项卡</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/AssetEditor/AssetEditor-dataobjects.png" align="middle" alt="资产编辑器-数据对象选项卡"></div></div></div><br class="figure-break"></strong></strong></li><li class="listitem"><p><strong><strong>总览</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>答：有关资产及其描述的一般信息。</strong></strong></p><p><strong><strong>“类型：”资产类型的格式名称。</strong></strong></p><p><strong><strong>“描述：”资产描述。</strong></strong></p><p><strong><strong>“在项目中使用：”为使用此规则的项目命名。</strong></strong></p><p><strong><strong>“上次修改时间：”谁进行了最后一次更改以及何时进行。</strong></strong></p><p><strong><strong>“创建日期：”创建资产的人和时间。</strong></strong></p></li><li class="listitem"><p><strong><strong>B：资产的版本历史。选择一个版本会将所选版本加载到该编辑器中。</strong></strong></p></li><li class="listitem"><p><strong><strong>C：元数据（来自“ Dublin Core”标准）</strong></strong></p></li><li class="listitem"><p><strong><strong>D：可以在此处记录有关资产开发的评论。</strong></strong></p></li></ul></div><div class="figure"><strong><strong><a id="d0e17712"></a><p class="title"><strong>图18.25。资产编辑器-概述标签</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/AssetEditor/Overview.png" align="middle" alt="资产编辑器-概述标签"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></li><li class="listitem"><p><strong><strong>元数据</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>答：元数据：</strong></strong></p><p><strong><strong>“标签：”用于对资产进行分组的标签系统。</strong></strong></p><p><strong><strong>“注意：”资产上次更新时发表的评论（即为什么进行更改）</strong></strong></p><p><strong><strong>“ URI：” Git存储库中资产的URI。</strong></strong></p><p><strong><strong>“主题/类型/外部链接/来源”：资产的其他各种元数据。</strong></strong></p><p><strong><strong>“锁定状态”：显示资产的锁定状态，如果锁定，则允许强制解锁资产。</strong></strong></p></li></ul></div><div class="figure"><strong><strong><a id="d0e17735"></a><p class="title"><strong>图18.26。元数据标签</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/AssetEditor/Metadata.png" align="middle" alt="元数据标签"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></li><li class="listitem"><p><strong><strong>锁定</strong></strong></p><p><strong><strong>工作台支持资产的悲观锁定。当一个用户开始编辑资产时，其他用户将锁定该资产以进行更改。该锁定将一直保持到一段时间不活动，关闭编辑器或应用程序停止并重新启动为止。也可以在“概述”选项卡的“元数据”部分上强制删除锁。</strong></strong></p><p><strong><strong>当资产被锁定时，“挂锁”图标显示在编辑器的标题栏中以及项目浏览器中资产的旁边。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17748"></a><p class="title"><strong>图18.27。资产编辑器-锁定资产不能由其他用户编辑</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/AssetEditor/AssetEditor-locked.png" align="middle" alt="资产编辑器-锁定资产不能由其他用户编辑"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></li></ul></div></div><div class="section" title="18.7.3。标签编辑器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.TagsEditor"></a> 18.7.3。标签编辑器</strong></strong></h3></div></div></div><p><strong><strong>标签允许使用您定义的任意数量的标签来标记资产。这些标签可用于在项目浏览器上过滤资产，以启用“标签过滤”。</strong></strong></p><div class="section" title="18.7.3.1。创建标签"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.managingTags"></a> 18.7.3.1。创建标签</strong></strong></h4></div></div></div><p><strong><strong>要创建标签，您只需将其写在“标签”输入上，然后按“添加新标签”按钮。标记编辑器允许一一创建标记，也可以编写多个标记，并用空格隔开。
    </strong></strong></p><div class="figure"><strong><strong><a id="d0e17764"></a><p class="title"><strong>图18.28。创建标签</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/TagsEditor/CreatingTags.png" align="middle" alt="创建标签"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>创建新标签后，它们将出现在编辑器上，允许您通过按需删除它们来将其删除。
    </p><div class="figure"><a id="d0e17772"></a><p class="title"><strong>图18.29。现有标签</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/TagsEditor/ExistingTags.png" align="middle" alt="现有标签"></div></div></div><br class="figure-break"></strong></strong></div></div><div class="section" title="18.7.4。项目浏览器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.ProjectExplorer"></a> 18.7.4。项目浏览器</strong></strong></h3></div></div></div><p><strong><strong>Project Explorer提供了浏览不同的组织单位，存储库，项目及其文件的功能。</strong></strong></p><div class="section" title="18.7.4.1。初步观点"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerEmpty"></a> 18.7.4.1。初步观点</strong></strong></h4></div></div></div><p><strong><strong>首次打开时，初始视图可能为空。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17788"></a><p class="title"><strong>图18.30。空的初始视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Empty.png" alt="空的初始视图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>用户可能必须从下拉框中选择组织单位，存储库和项目。</p><div class="figure"><a id="d0e17796"></a><p class="title"><strong>图18.31。选择一个仓库</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Selecting-Repository.png" alt="选择一个仓库"></div></div></div><br class="figure-break"><p>默认配置从视图中隐藏“软件包详细信息”。</p><p>为了显示软件包，请单击以下屏幕快照中所示的图标。</p><div class="figure"><a id="d0e17806"></a><p class="title"><strong>图18.32。显示包裹</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Project-Show-Packages.png" alt="显示包裹"></div></div></div><br class="figure-break"><p>选择了组织单位，存储库，项目和包的适当组合后，项目浏览器将显示内容。选择的确切组合完全取决于Workbench安装和项目中定义的结构。每个部分都包含相关文件组。如果当前正在由另一个用户编辑文件，则文件名前将显示一个锁定符号。如果锁由当前经过身份验证的用户拥有，则该符号为蓝色，否则为黑色。将鼠标指针移到锁符号上将显示一个工具提示，其中提供了当前正在编辑文件（因此拥有锁）的用户的名称。要了解有关锁定的更多信息，请参见<a class="xref" href="#wb.AssetEditor" title="18.7.2。资产编辑器">第18.7.2节“资产编辑器”</a> 。</p><div class="figure"><a id="d0e17816"></a><p class="title"><strong>图18.33。扩大资产组</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Project-Expanded.png" alt="扩大资产组"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.7.4.2。不同的看法"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerSwitchingView"></a> 18.7.4.2。不同的看法</strong></strong></h4></div></div></div><p><strong><strong>Project Explorer支持多个视图。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>专案检视</strong></strong></p><p><strong><strong>基础项目结构的简化视图。某些系统文件从视图中隐藏。</strong></strong></p></li><li class="listitem"><p><strong><strong>仓库视图</strong></strong></p><p><strong><strong>底层项目结构的完整视图，包括所有文件；用户定义的或系统生成的。</strong></strong></p></li></ul></div><p><strong><strong>可以通过单击Project Explorer中的图标来选择视图，如下所示。</strong></strong></p><p><strong><strong>通过选择“显示为文件夹”或“显示为链接”，可以进一步完善项目视图和存储库视图。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17842"></a><p class="title"><strong>图18.34。切换检视</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Switching-View.png" alt="切换检视"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="18.7.4.2.1。项目视图示例"><div class="titlepage"><div><div><h5 class="title"><a id="wb.ProjectExplorerBusinessView"></a> 18.7.4.2.1。项目视图示例</h5></div></div></div><div class="figure"><a id="d0e17851"></a><p class="title"><strong>图18.35。项目视图-文件夹</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Project-Folders.png" alt="项目视图-文件夹"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e17857"></a><p class="title"><strong>图18.36。项目视图-链接</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Project-Links.png" alt="项目视图-链接"></div></div></div><br class="figure-break"></div><div class="section" title="18.7.4.2.2。存储库查看示例"><div class="titlepage"><div><div><h5 class="title"><a id="wb.ProjectExplorerTechnicalView"></a> 18.7.4.2.2。存储库查看示例</h5></div></div></div><div class="figure"><a id="d0e17866"></a><p class="title"><strong>图18.37。储存库视图-文件夹</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Repository-Folders.png" alt="储存库视图-文件夹"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e17872"></a><p class="title"><strong>图18.38。存储库视图-链接</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Repository-Links.png" alt="存储库视图-链接"></div></div></div><br class="figure-break"></div></strong></strong></div><div class="section" title="18.7.4.3。下载项目或资源库"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerDownloads"></a> 18.7.4.3。下载项目或资源库</strong></strong></h4></div></div></div><p><strong><strong>通过下载项目和下载存储库，可以将项目或存储库下载为zip文件。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17883"></a><p class="title"><strong>图18.39。资料库和项目下载</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Downloads.png" alt="资料库和项目下载"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.4.4。分支选择器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerBranchSelector"></a> 18.7.4.4。分支选择器</strong></strong></h4></div></div></div><p><strong><strong>如果存储库具有多个分支，则分支选择器将可见。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17894"></a><p class="title"><strong>图18.40。分支选择器</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Branch-Selector.png" alt="分支选择器"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.4.5。按标签过滤"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerFilteringByTag"></a> 18.7.4.5。按标签过滤</strong></strong></h4></div></div></div><p><strong><strong>要轻松查看包含大量资产的程序包中的元素，可以启用“标记”过滤器，该过滤器允许您按其标记过滤资产。</strong></strong></p><p><strong><strong>要查看如何向资产添加标签，请参见： <a class="xref" href="#wb.TagsEditor" title="18.7.3。标签编辑器">第18.7.3节“标签编辑器”</a></strong></strong></p><div class="figure"><strong><strong><a id="d0e17908"></a><p class="title"><strong>图18.41。启用标签过滤</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Tag-Filter-Enable.png" alt="启用标签过滤"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e17914"></a><p class="title"><strong>图18.42。按标签过滤</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Tag-Filter-Show.png" alt="按标签过滤"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e17920"></a><p class="title"><strong>图18.43。按标签过滤</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Tag-Filter-Working.png" alt="按标签过滤"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.7.4.6。复制，重命名，删除和下载操作"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProjectExplorerCopyRenameDeleteActions"></a> 18.7.4.6。复制，重命名，删除和下载操作</strong></strong></h4></div></div></div><p><strong><strong>复制，重命名和删除操作在<span class="italic">链接</span>模式下可用，对于包（在项目视图中）以及文件和目录（在存储库视图中）也可用。下载操作可用于目录。下载将所选目录下载为zip文件。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>复印件</strong></strong></p></li><li class="listitem"><p><strong><strong>B：重命名</strong></strong></p></li><li class="listitem"><p><strong><strong>C：删除</strong></strong></p></li><li class="listitem"><p><strong><strong>D：下载</strong></strong></p></li></ul></div><div class="figure"><strong><strong><a id="d0e17947"></a><p class="title"><strong>图18.44。项目视图-打包操作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Project-Links-Copy-Rename-Delete.png" alt="项目视图-打包操作"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e17953"></a><p class="title"><strong>图18.45。存储库视图-文件和目录操作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Repository-Copy-Rename-Delete.png" alt="存储库视图-文件和目录操作"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.7.4.7。"><div class="titlepage"></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>警告</strong></strong></h2><p><strong><strong>工作台路线图包括重构和影响分析工具，但目前还没有。在提供两种工具之前，请确保对包，文件或目录的更改（复制/重命名/删除）对您的项目没有重大影响。</strong></strong></p><p><strong><strong>如果您的更改产生了意外的影响，Workbench允许您使用“ <a class="link" href="#wb.VFSRepositoryEditor" title="18.3.3.1. Repository Editor">资源库编辑器”</a>来还原您的资源<a class="link" href="#wb.VFSRepositoryEditor" title="18.3.3.1。资料库编辑器">库</a> 。</strong></strong></p></div><div class="section" title="18.7.4.7.1。"><div class="titlepage"></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>在释放相应的锁之前，不能重命名或删除由其他用户锁定的文件以及包含此类文件的目录。在这种情况下，重命名和删除符号将被禁用。要了解有关锁定的更多信息，请参见<a class="xref" href="#wb.AssetEditor" title="18.7.2。资产编辑器">第18.7.2节“资产编辑器”</a> 。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/Authoring/ProjectExplorer/ProjectExplorer-Delete-NotAllowed.png"></strong></strong></div></div></div></div></div><div class="section" title="18.7.5。项目编辑"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.ProjectEditor"></a> 18.7.5。项目编辑</strong></strong></h3></div></div></div><p><strong><strong>可以从Project Explorer访问Project Editor屏幕。项目编辑器显示当前活动项目的设置。</strong></strong></p><p><strong><strong>与大多数工作台编辑器不同，项目编辑器可以编辑多个文件。在一处显示配置KIE项目所需的一切。</strong></strong></p><div class="figure"><strong><strong><a id="d0e17984"></a><p class="title"><strong>图18.46。项目画面和不同的视图</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/ProjectEditor/project_editor_menu.png" align="middle" alt="项目画面和不同的视图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="18.7.5.1。建立与部署"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17990"></a> 18.7.5.1。建立与部署</h4></div></div></div><p>Build＆Depoy构建当前项目，并将KJAR部署到工作台内部Maven存储库中。</p></div><div class="section" title="18.7.5.2。项目设定"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17995"></a> 18.7.5.2。项目设定</h4></div></div></div><p>项目设置可编辑Maven使用的pom.xml文件。</p><div class="section" title="18.7.5.2.1。项目常规设置"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18000"></a> 18.7.5.2.1。项目常规设置</h5></div></div></div><p>常规设置提供了用于项目名称和GAV数据（组，工件，版本）的工具。GAV值用作标识符以区分项目和同一项目的版本。</p><div class="figure"><a id="d0e18005"></a><p class="title"><strong>图18.47。项目设定</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/ProjectEditor/general_settings.png" align="middle" alt="项目设定"></div></div></div><br class="figure-break"></div><div class="section" title="18.7.5.2.2。依存关系"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18011"></a> 18.7.5.2.2。依存关系</h5></div></div></div><p>该项目可以具有任意数量的内部或外部依赖项。依赖关系是一个已构建并部署到Maven存储库的项目。内部依赖项是在与项目相同的工作台中构建和部署的项目。外部依赖项是从当前工作台外部的存储库中检索的。每个依赖项使用GAV值来指定项目使用的项目名称和版本。</p><div class="figure"><a id="d0e18016"></a><p class="title"><strong>图18.48。依存关系</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/ProjectEditor/dependencies.png" align="middle" alt="依存关系"></div></div></div><br class="figure-break"><div class="section" title="18.7.5.2.2.1。包装名称白名单"><div class="titlepage"><div><div><h6 class="title"><a id="d0e18022"></a> 18.7.5.2.2.1。包装名称白名单</h6></div></div></div><p>白名单包中的类和声明的类型显示为可导入资产中的数据对象。完整列表存储在每个项目根目录中存储的package-name-white-list文件中。
      </p><p>软件包白名单有三种模式：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>包括的所有软件包：此jar中定义的每个软件包都列出了白色。</p></li></ul></div><p>  
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>不包含的软件包：此jar中列出的所有软件包均未列入白名单。</p></li></ul></div><p>
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>其中包括一些软件包：jar中仅部分软件包列出了白色。</p></li></ul></div><p>

      </p></div></div><div class="section" title="18.7.5.2.3。元数据"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18044"></a> 18.7.5.2.3。元数据</h5></div></div></div><p>pom.xml文件的元数据。</p></div></div><div class="section" title="18.7.5.3。知识库设置"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18049"></a> 18.7.5.3。知识库设置</h4></div></div></div><p>知识库设置可编辑Drools使用的kmodule.xml文件。</p><div class="figure"><a id="d0e18054"></a><p class="title"><strong>图18.49。知识库设置</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/ProjectEditor/kmodule.png" align="middle" alt="知识库设置"></div></div></div><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>有关知识库属性的更多信息，请参阅Drools Expert文档中的kmodule.xml。</p></div><div class="section" title="18.7.5.3.1。知识库和会议"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18063"></a> 18.7.5.3.1。知识库和会议</h5></div></div></div><p>知识库和会话列出了为项目指定的知识库和知识会话。</p><div class="section" title="18.7.5.3.1.1。知识库列表"><div class="titlepage"><div><div><h6 class="title"><a id="d0e18068"></a> 18.7.5.3.1.1。知识库列表</h6></div></div></div><p>按名称列出所有知识库。默认只能设置一个知识库。</p></div><div class="section" title="18.7.5.3.1.2。知识库属性"><div class="titlepage"><div><div><h6 class="title"><a id="d0e18073"></a> 18.7.5.3.1.2。知识库属性</h6></div></div></div><p>知识库可以包括其他知识库。当前选择的知识库将显示并使用所包含知识库中的模型，规则和任何其他内容。</p><p>规则和模型存储在包中。软件包属性指定此知识库中包含哪些软件包。</p><p>文档的Drools Expert部分中说明了均等行为。</p><p>事件处理模式在文档的Drools Fusion部分中进行了说明。</p></div><div class="section" title="18.7.5.3.1.3。知识会议"><div class="titlepage"><div><div><h6 class="title"><a id="d0e18084"></a> 18.7.5.3.1.3。知识会议</h6></div></div></div><p>该表列出了所选知识库中的所有知识会话。每种类型只能有一个默认值。类型是无状态的和有状态的。单击笔形图标将打开一个弹出窗口，该弹出窗口显示知识会话的更多属性。</p></div></div><div class="section" title="18.7.5.3.2。元数据"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18089"></a> 18.7.5.3.2。元数据</h5></div></div></div><p>kmodule.xml的元数据</p></div></div><div class="section" title="18.7.5.4。进口货"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18094"></a> 18.7.5.4。进口货</h4></div></div></div><p>设置将编辑工作台编辑器使用的project.imports文件。</p><div class="figure"><a id="d0e18099"></a><p class="title"><strong>图18.50。进口货</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/ProjectEditor/ExternalDataObjects.png" align="middle" alt="进口货"></div></div></div><br class="figure-break"><div class="section" title="18.7.5.4.1。外部数据对象"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18105"></a> 18.7.5.4.1。外部数据对象</h5></div></div></div><p>Java Runtime环境提供的数据对象可能需要注册才能用于规则创作，在这种情况下，此类数据对象不是作为工作台或项目依赖项中定义的现有数据对象的一部分隐式可用的。例如，作者可能想定义一个规则来检查<code class="code">java.util.ArrayList</code>在工作记忆中。如果域数据对象的字段类型为<code class="code">java.util.ArrayList</code>无需创建注册。</p></div><div class="section" title="18.7.5.4.2。元数据"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18116"></a> 18.7.5.4.2。元数据</h5></div></div></div><p>project.imports文件的元数据。</p></div></div><div class="section" title="18.7.5.5。重复GAV检测"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18121"></a> 18.7.5.5。重复GAV检测</h4></div></div></div><p>执行以下任何操作时，现在将检查为项目解析的所有Maven存储库，以查看是否存在项目的GroupId，ArtifactId和Version。如果发现冲突，则阻止该操作；尽管用户可以使用<code class="code">admin</code>角色。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>可以通过设置系统属性来禁用该功能<code class="code">org.guvnor.project.gav.check.disabled</code>至<code class="code">true</code> 。</p></div><p>解析的存储库是在以下位置发现的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>项目的<code class="code">POM</code><code class="code"><repositories></code>部分（或任何父母<code class="code">POM</code> ）。</p></li><li class="listitem"><p>项目的<code class="code">POM</code><code class="code"><distributionManagement></code>部分。</p></li><li class="listitem"><p>Maven的全球<code class="code">settings.xml</code>配置文件。</p></li></ul></div><p>
    </p><p>受影响的操作：-</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>创建新的托管存储库。</p></li><li class="listitem"><p>使用项目编辑器保存项目定义。</p></li><li class="listitem"><p>将新模块添加到托管多模块存储库。</p></li><li class="listitem"><p>保存<code class="code">pom.xml</code>文件。</p></li><li class="listitem"><p>使用项目编辑器构建和安装项目。</p></li><li class="listitem"><p>使用项目编辑器构建和部署项目。</p></li><li class="listitem"><p>资产管理部门负责建设，安装或部署项目。</p></li><li class="listitem"><p><code class="code">REST</code>创建，安装或部署项目的操作。</p></li></ul></div><p>
    </p><p>的用户<code class="code">Admin</code>角色可以覆盖使用项目编辑器中“存储库”设置检查的存储库列表。</p><div class="figure"><a id="d0e18207"></a><p class="title"><strong>图18.51。项目编辑器-查看已解决的存储库</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories1.png" alt="项目编辑器-查看已解决的存储库"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18214"></a><p class="title"><strong>图18.52。项目编辑器-解析的存储库列表</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories2.png" alt="项目编辑器-解析的存储库列表"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18221"></a><p class="title"><strong>图18.53。检测到重复的GAV</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/ReleaseNotes/MavenRepositories3.png" alt="检测到重复的GAV"></div></div></div></div><br class="figure-break"></div></strong></strong></div><div class="section" title="18.7.6。验证方式"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.Validation"></a> 18.7.6。验证方式</strong></strong></h3></div></div></div><p><strong><strong>Workbench为用户提供了一个通用且一致的服务，以了解该环境中创作的文件是否有效。</strong></strong></p><div class="section" title="18.7.6.1。问题面板"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.ProblemsPanel"></a> 18.7.6.1。问题面板</strong></strong></h4></div></div></div><p><strong><strong>问题面板显示项目中资产的实时验证结果。</strong></strong></p><p><strong><strong>从“项目资源管理器”中选择一个项目后，“问题面板”将刷新并显示所选项目的验证结果。</strong></strong></p><p><strong><strong>在创建，保存或删除文件时，“问题面板”内容将更新以显示新的验证错误，或者在删除文件后删除现有的错误。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18242"></a><p class="title"><strong>图18.54。问题面板</strong></p><div class="figure-contents"><p>此处已创建并保存了无效的DRL文件。</p><p>问题面板显示验证错误。</p><div class="mediaobject" align="center"><img src="images/Workbench/Authoring/Validation/workbench-problems-panel.png" align="middle" alt="问题面板"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.6.2。按需验证"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.OnDemandValidation"></a> 18.7.6.2。按需验证</strong></strong></h4></div></div></div><p><strong><strong>为了确定文件是否处于有效状态，并不总是希望保存文件。</strong></strong></p><p><strong><strong>所有文件编辑器都可以在保存内容之前对其进行验证。</strong></strong></p><p><strong><strong>单击“验证”按钮将显示验证错误（如果有）。</strong></strong></p><div class="mediaobject" align="center"><strong><strong><img src="images/Workbench/Authoring/Validation/workbench-validation.png" align="middle"></strong></strong></div></div></div><div class="section" title="18.7.7。数据建模师"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.DataModeller"></a> 18.7.7。数据建模师</strong></strong></h3></div></div></div><div class="section" title="18.7.7.1。创建数据模型的第一步"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-firstSteps"></a> 18.7.7.1。创建数据模型的第一步</strong></strong></h4></div></div></div><p><strong><strong>默认情况下，数据模型始终受限于项目的上下文。就本教程而言，我们将假定已经存在正确配置的项目，并且创作透视图是打开的。
  </strong></strong></p><p><strong><strong>要在项目内部开始创建数据模型，请执行以下步骤：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>从主页面板中，选择创作透视图，然后使用项目浏览器浏览到给定的项目。
      </strong></strong></p><div class="figure"><strong><strong><a id="d0e18278"></a><p class="title"><strong>图18.55。转到创作透视图并选择一个项目</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/authoring.jpg" alt="转到创作透视图并选择一个项目"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p></strong></strong></li><li class="listitem"><p><strong><strong>通过单击数据对象文件或使用“新建项->数据对象”菜单选项，打开数据建模器工具。
      </strong></strong></p><div class="figure"><strong><strong><a id="d0e18289"></a><p class="title"><strong>图18.56。单击数据对象</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/open_data_model.jpg" alt="单击数据对象"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p></strong></strong></li></ol></div><p><strong><strong>这将启动Data Modeller工具，该工具具有以下一般方面：</strong></strong></p><div class="figure"><strong><strong><a id="d0e18299"></a><p class="title"><strong>图18.57。数据建模器概述</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/overview.png" alt="数据建模器概述"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>“编辑器”选项卡分为以下几部分：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>新字段部分专用于创建新字段，并在按下“添加字段”按钮时打开。
      </p><div class="figure"><a id="d0e18313"></a><p class="title"><strong>图18.58。新领域的创造</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/create-new-field.png" alt="新领域的创造"></div></div></div></div><br class="figure-break"><p></p></li><li class="listitem"><p>数据对象的“字段浏览器”部分显示带有数据对象字段的列表。
      </p><div class="figure"><a id="d0e18324"></a><p class="title"><strong>图18.59。数据对象的字段浏览器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-field-browser.png" alt="数据对象的字段浏览器"></div></div></div></div><br class="figure-break"><p></p></li><li class="listitem"><p>“数据对象/字段的常规属性”部分。这是“数据建模器”编辑器的最右侧部分，根据用户选择，可视化“数据对象”或“字段”常规属性。
      </p><p>可以通过单击数据对象选择器来选择数据对象的常规属性。</p><div class="figure"><a id="d0e18337"></a><p class="title"><strong>图18.60。数据对象选择器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-selector.png" alt="数据对象选择器"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18344"></a><p class="title"><strong>图18.61。数据对象的常规属性</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-general-properties.png" alt="数据对象的常规属性"></div></div></div></div><br class="figure-break"><p>可以通过单击字段来选择字段常规属性。</p><p></p><div class="figure"><a id="d0e18354"></a><p class="title"><strong>图18.62。字段选择器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-selector.png" alt="字段选择器"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18361"></a><p class="title"><strong>图18.63。字段的一般属性</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-general-properties.png" alt="字段的一般属性"></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>在工作台的右侧，提供了一个新的“工具栏”，可以选择不同的上下文相关工具窗口，这些窗口将允许用户执行特定于域的配置。当前为以下域“ Drools＆jBPM”，“ OptaPlanner”，“ Persistence”和“ Advanced”配置提供了四个工具窗口。
      </p><div class="figure"><a id="d0e18371"></a><p class="title"><strong>图18.64。数据建模工具栏</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/tool-window-selector.png" alt="数据建模工具栏"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18378"></a><p class="title"><strong>图18.65。Drools＆jBPM工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-drools-tool-window.png" alt="Drools＆jBPM工具窗口"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18385"></a><p class="title"><strong>图18.66。OptaPlanner工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-optaplanner-tool-window.png" alt="OptaPlanner工具窗口"></div></div></div></div><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>要查看和使用OptaPlanner工具窗口，用户需要具有该角色<code class="literal">plannermgmt</code> 。</p></div><div class="figure"><a id="d0e18398"></a><p class="title"><strong>图18.67。持久性工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-persistence-tool-window.png" alt="持久性工具窗口"></div></div></div></div><br class="figure-break"><div class="figure"><a id="d0e18405"></a><p class="title"><strong>图18.68。高级工具窗口</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-or-field-advanced-tool-window.png" alt="高级工具窗口"></div></div></div></div><br class="figure-break"></li></ul></div><p></p><p>“源”选项卡显示一个编辑器，该编辑器允许可视化和修改所生成的Java代码。
  </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>“编辑器”和“源代码”选项卡之间的往返是可能的，并且还提供了源代码保存。这意味着无论在何处生成Java代码（例如Eclipse，Data Modeller），数据建模器都只会更新必要的代码块以保持模型更新。
    </p><div class="figure"><a id="d0e18419"></a><p class="title"><strong>图18.69。源代码编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/source-editor-tab.png" alt="源代码编辑器"></div></div></div></div><br class="figure-break"></li></ul></div><p>“概述”选项卡显示标准的元数据和版本信息以及其他工作台编辑器。
  </p></strong></strong></div><div class="section" title="18.7.7.2。数据对象"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-entities"></a> 18.7.7.2。数据对象</strong></strong></h4></div></div></div><p><strong><strong>数据模型由数据对象组成，这些对象是某些实际数据的逻辑表示。Such data objects have a fixed set
    of modeller (or application-owned) properties, such as its internal
    identifier, a label, description, package etc. Besides those, a data object also
    has a variable set of user-defined fields, which are an abstraction of a
    real-world property of the type of data that this logical data object
    represents.
  </strong></strong></p><p><strong><strong>Creating a data object can be achieved using the workbench "New Item - Data Object" menu option.

  </strong></strong></p><div class="figure"><strong><strong><a id="d0e18435"></a><p class="title"><strong>Figure 18.70. New Data Object menu option</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/create-new-data-object.png" alt="新建数据对象菜单选项"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>Both resource name and location are mandatory parameters. When the "Ok" button is pressed a new Java file will
    be created and a new editor instance will be opened for the file edition.
    The optional "Persistable" attribute will add by default configurations on the data object in order to make it a
    JPA entity. Use this option if your jBPM project needs to store data object's information in a data base.
  </p><p></p></strong></strong></div><div class="section" title="18.7.7.3。属性和关系"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-propertyRelationships"></a>18.7.7.3. Properties & relationships</strong></strong></h4></div></div></div><p><strong><strong>Once the data object has been created, it now has to be completed by
    adding user-defined properties to its definition. This can be achieved by
    pressing the "add field" button. The "New Field" dialog will be opened and the
    new field can be created by pressing the "Create" button. The "Create and continue" button
    will also add the new field to the Data Object, but won't close the dialog. In this way multiple fields
    can be created avoiding the popup opening multiple times.

    The following fields can (or must) be filled out:
  </strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>The field's internal identifier (mandatory). The value of this
        field must be unique per data object, i.e. if the proposed identifier
        already exists within current data object, an error message will be
        displayed.
      </strong></strong></p></li><li class="listitem"><p><strong><strong>A label (optional): as with the data object definition, the user can
        define a user-friendly label for the data object field which is
        about to be created. This has no further implications on how fields
        from objects of this data object will be treated. If a label is defined, then
        this is how the field will be displayed throughout the data modeller
        tool.
      </strong></strong></p></li><li class="listitem"><p><strong><strong>A field type (mandatory): each data object field needs to be
        assigned with a type.
      </strong></strong></p><p><strong><strong>This type can be either of the following:</strong></strong></p><p></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>A 'primitive java object' type: these include most of the object
            equivalents of the standard Java primitive types, such as Boolean,
            Short, Float, etc, as well as String, Date, BigDecimal and
            BigInteger.
          </strong></strong></p><div class="figure"><strong><strong><a id="d0e18468"></a><p class="title"><strong>Figure 18.71. Primitive object field types</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/create-field-with-primitive-type.png" alt="原始对象字段类型"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p></p></strong></strong></li><li class="listitem"><p><strong><strong>A 'data object' type: any user defined data object automatically
            becomes a candidate to be defined as a field type of another
            data object, thus enabling the creation of relationships between
            them. A data object field can be created either in 'single'
            or in 'multiple' form, the latter implying that the field will
            be defined as a collection of this type, which will be indicated by
            selecting "List" checkbox.
          </strong></strong></p><div class="figure"><strong><strong><a id="d0e18480"></a><p class="title"><strong>Figure 18.72. Data object field types</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/types_entity.jpg" alt="数据对象字段类型"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p></p></strong></strong></li><li class="listitem"><p><strong><strong>A 'primitive java' type: these include java primitive types byte, short, int, long, float, double, char
            and boolean.
          </strong></strong></p><div class="figure"><strong><strong><a id="d0e18492"></a><p class="title"><strong>Figure 18.73. Primitive field types</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/types_primitive.jpg" alt="原始字段类型"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p></p></strong></strong></li></ol></div></li></ul></div><p><strong><strong>When finished introducing the initial information for a new field,
    clicking the 'Create' button will add the newly created field to the end
    of the data object's fields table below:
  </strong></strong></p><div class="figure"><strong><strong><a id="d0e18503"></a><p class="title"><strong>Figure 18.74. New field has been created</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/new-field-was-created.png" alt="新字段已创建"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>The new field will also automatically be selected in the data object's
    field list, and its properties will be shown in the Field general properties editor.
    Additionally the field properties will be loaded in the different tool windows, in this way
    the field will be ready for edition in whatever selected tool window.
  </p><p>At any time, any field (without restrictions) can be deleted from
    a data object definition by clicking on the corresponding 'x' icon in the
    data object's fields table.
  </p><p></p></strong></strong></div><div class="section" title="18.7.7.4。附加选项"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-additionalOptions"></a>18.7.7.4. Additional options</strong></strong></h4></div></div></div><p><strong><strong>As stated before, both Data Objects as well as Fields require
    some of their initial properties to be set upon creation. Additionally there are three domains of properties that
    can be configured for a given Data Object. A domain is basically a set of properties related to a given business area.
    Current available domains are, "Drools & jJBPM", "Persistence" and the "Advanced" domain.
    To work on a given domain the user should select the corresponding "Tool window" (see below) on the right side toolbar.
    Every tool window usually provides two editors, the "Data Object" level editor and the "Field" level editor, that will
    be shown depending on the last selected item, the Data Object or the Field.
  </strong></strong></p><div class="section" title="18.7.7.4.1。Drools和jBPM域"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e18521"></a>18.7.7.4.1. Drools & jBPM domain</strong></strong></h5></div></div></div><p><strong><strong>The Drools & jBPM domain editors manages the set of Data Object or Field properties related to
    drools applications.</strong></strong></p><div class="section" title="18.7.7.4.1.1。Drools和jBPM对象编辑器"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18526"></a>18.7.7.4.1.1. Drools & jBPM object editor</strong></strong></h6></div></div></div><p><strong><strong>The Drools & jBPM object editor manages the object level drools properties</strong></strong></p><div class="figure"><strong><strong><a id="d0e18531"></a><p class="title"><strong>Figure 18.75. The data object's properties</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-drools-tool-window.png" alt="数据对象的属性"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>TypeSafe: this property allows to enable/disable the type safe behaviour for current type.
            By default all type declarations are compiled with type safety enabled. (See Drools for more information
            on this matter).
          </p></li><li class="listitem"><p>ClassReactive: this property allows to mark this type to be treated as "Class Reactive" by the Drools engine.
            (See Drools for more information on this matter).
          </p></li><li class="listitem"><p>PropertyReactive: this property allows to mark this type to be treated as "Property Reactive" by the Drools engine.
            (See Drools for more information on this matter).
          </p></li><li class="listitem"><p>Role: this property allows to configure how the Drools engine should handle instances of this type: either as
            regular facts or as events. By default all types are handled as a regular fact, so for the time being the
            only value that can be set is "Event" to declare that this type should be handled as an event.
            (See Drools Fusion for more information on this matter).
          </p></li><li class="listitem"><p>Timestamp: this property allows to configure the "timestamp" for an event, by selecting one of his attributes.
            If set the engine will use the timestamp from the given attribute instead of reading it from the Session Clock.
            If not, the engine will automatically assign a timestamp to the event.
            (See Drools Fusion for more information on this matter).
          </p></li><li class="listitem"><p>Duration: this property allows to configure the "duration" for an event, by selecting one of his attributes.
            If set the engine will use the duration from the given attribute instead of using the default event duration = 0.
            (See Drools Fusion for more information on this matter).
          </p></li><li class="listitem"><p>Expires: this property allows to configure the "time offset" for an event expiration.
            If set, this value must be a temporal interval in the form: [#d][#h][#m][#s][#[ms]] Where [ ] means an
            optional parameter and # means a numeric value.
            e.g.: 1d2h, means one day and two hours.
            (See Drools Fusion for more information on this matter).
          </p></li><li class="listitem"><p>Remotable: If checked this property makes the Data Object available to be used with jBPM remote services as
            REST, JMS and WS. (See jBPM for more information on this matter).
          </p><p></p></li></ul></div></strong></strong></div><div class="section" title="18.7.7.4.1.2。Drools＆jJBPM现场编辑器"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18565"></a>18.7.7.4.1.2. Drools & jJBPM field editor</strong></strong></h6></div></div></div><p><strong><strong>The Drools & jBPM object editor manages the field level drools properties</strong></strong></p><div class="figure"><strong><strong><a id="d0e18570"></a><p class="title"><strong>图18.76。数据对象的字段属性</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-drools-tool-window.png" alt="数据对象的字段属性"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>相等：检查此属性的“数据对象”字段意味着在代码生成级别考虑在生成的Java类中同时创建equals（）和hashCode（）方法时将其考虑在内。我们将在下一节中对此进行更详细的说明。
          </p></li><li class="listitem"><p>位置：此字段需要零或正整数。设置后，该字段将被Drools引擎解释为位置参数（有关此主题的更多信息，请参见以下部分以及Drools文档）。
          </p></li></ul></div></strong></strong></div></div><div class="section" title="18.7.7.4.2。持久域"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e18585"></a> 18.7.7.4.2。持久域</strong></strong></h5></div></div></div><p><strong><strong>持久性域编辑器管理与持久性相关的数据对象或字段属性集。</strong></strong></p><div class="section" title="18.7.7.4.2.1。持久域对象编辑器"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18590"></a> 18.7.7.4.2.1。持久域对象编辑器</strong></strong></h6></div></div></div><p><strong><strong>持久性域对象编辑器管理对象级别的持久性属性</strong></strong></p><div class="figure"><strong><strong><a id="d0e18595"></a><p class="title"><strong>图18.77。数据对象的属性</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-persistence-tool-window.png" alt="数据对象的属性"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>持久的：此属性允许将当前数据对象配置为可持久。</p></li><li class="listitem"><p>表名：此属性允许为当前数据对象设置用户定义的数据库表名。</p></li></ul></div></strong></strong></div><div class="section" title="18.7.7.4.2.2。持久性域字段编辑器"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18610"></a> 18.7.7.4.2.2。持久性域字段编辑器</strong></strong></h6></div></div></div><p><strong><strong>持久性域字段编辑器管理字段级别的持久性属性，并分为三个部分。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18615"></a><p class="title"><strong>图18.78。持久性域字段编辑器部分</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-persistence-tool-window-sections.png" alt="持久性域字段编辑器部分"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><div class="section" title="18.7.7.4.2.2.1。识别码："><div class="titlepage"><div><div><h6 class="title"><a id="d0e18623"></a> 18.7.7.4.2.2.1。识别码：</h6></div></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-persistence-tool-window-sections-identifier.png"></div></div><p>一个可持久的数据对象应该只有一个字段定义为数据对象标识符。标识符通常是一个唯一数字，用于将给定的数据对象实例与同一类的所有其他实例区分开。
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>是标识符：将当前字段标记为数据对象标识符。一个可持久的数据对象应该只有一个字段标记为标识符，并且它应该是基本的Java类型，例如String，Integer，Long等。引用数据对象的字段或者是多个字段不能被标记作为标识符。而且此版本不支持复合标识符。创建持久性数据对象时，默认情况下会使用正确的初始化创建一个标识符字段，强烈建议使用此标识符。
            </p></li><li class="listitem"><p>生成策略：生成策略确定在创建数据对象实例并将其存储在数据库中时如何自动生成标识符值。 （例如，通过与jBPM相关的表单来处理人工任务。）在默认情况下创建标识符字段时，也会自动设置生成策略，强烈建议使用此配置。
            </p></li><li class="listitem"><p>序列生成器：生成器代表将由“生成策略”使用的值的种子。默认情况下，创建标识符字段后，序列生成器也会自动生成并正确配置，以供生成策略使用。
            </p></li></ul></div></div><div class="section" title="18.7.7.4.2.2.2。列属性："><div class="titlepage"><div><div><h6 class="title"><a id="d0e18642"></a> 18.7.7.4.2.2.2。列属性：</h6></div></div></div><p>列属性部分允许自定义将存储字段值的数据库列的某些属性。
        </p><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-persistence-tool-window-sections-column.png"></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>列名：可选值，用于设置给定字段的数据库列名。
            </p></li><li class="listitem"><p>唯一：选中后，唯一属性会确定当前字段值在存储在数据库中时应该是唯一键。 （如果未设置，则默认值为false）</p></li><li class="listitem"><p>可为空：如果选中，则表明当存储在数据库中时，当前字段值可以为空。（如果未设置，则默认值为true）</p></li><li class="listitem"><p>可插入的：选中后，将确定该列将包含在持久性提供程序生成的SQL INSERT语句中。 （如果未设置，则默认值为true）</p></li><li class="listitem"><p>可更新：选中后，将确定该列将包含在持久性提供程序生成的SQL UPDATE语句中。 （如果未设置，则默认值为true）</p></li></ul></div></div><div class="section" title="18.7.7.4.2.2.3。关系属性："><div class="titlepage"><div><div><h6 class="title"><a id="d0e18667"></a> 18.7.7.4.2.2.3。关系属性：</h6></div></div></div><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-persistence-tool-window-sections-relationship.png"></div></div><p>当字段的类型是数据对象类型或数据对象类型的列表时，应设置一个关系类型，以使持久性提供程序可以管理该关系。幸运的是，当将这种类型的字段添加到已经标记为可持久性的数据对象时，将自动设置此关系类型。关系类型由以下弹出窗口设置。
      </p><div class="figure"><a id="d0e18676"></a><p class="title"><strong>图18.79。关系配置弹出</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/field-persistence-tool-window-sections-relationship-dialog.png" alt="关系配置弹出"></div></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>关系类型：从以下选项之一设置关系的类型：</p><p>一对一：通常用于1：1关系，其中“ A与B的一个实例相关”，并且B仅在A存在时才存在。例如PurchaseOrder-> PurchaseOrderHeader（仅当PurchaseOrder存在时，PurchaseOrderHeader才存在）</p><p>一对多：通常用于1：N关系，其中“ A与B的N个实例相关”，并且B的相关实例仅在A存在时存在。例如PurchaseOrder-> PurchaseOrderLine（只有存在PurchaseOrder时，PurchaseOrderLine才存在）</p><p>多对一：通常用于1：1关系，其中“ A与B的一个实例相关”，并且即使没有A也可以存在B。例如PurchaseOrder-> Client（即使没有关联的PurchaseOrder，客户端也可以存在于数据库中）</p><p>多对多：通常用于N：N关系，其中“ A可以与B的N个实例相关，并且B可以同时与A的M个实例相关”，并且两个B以及A实例都可以在数据库中退出独立于相关实例。例如课程->学生。（课程可以与N名学生相关，并且指定的学生可以参加M门课程）</p><p>将类型为“数据对象”的字段添加到给定的可持久数据对象时，默认情况下会生成“多对一”关系类型。
          </p><p>并且，将类型为“数据对象列表”的字段添加到给定的持久性数据对象时，默认情况下会生成“一对多”关系。
          </p></li><li class="listitem"><p>级联模式：定义一组可级联的操作，这些操作将传播到关联的实体。值层叠=全部等于层叠= {PERSIST，合并，删除，刷新}。例如，当A-> B，并且级联设置为“ PERSIST或ALL”时，如果保存了A，则也将保存B。
          </p><p>数据建模者默认创建的级联模式为“ ALL”，强烈建议在jBPM流程和表单使用数据对象时使用此模式。
          </p></li><li class="listitem"><p>提取模式：定义在读取时如何从数据库中提取相关数据。
          </p><p>EAGER：相关数据将同时读取。例如，如果A-> B，则从数据库B读取A时将同时读取。
          </p><p>懒惰：相关数据的读取通常会延迟到需要它们的那一刻。例如，如果PurchaseOrder-> PurchaseOrderLine，则将推迟行的读取，直到在PurchaseOrder实例上调用方法“ getLines（）”为止。
          </p><p>数据建模者创建的默认获取模式是“ EAGER”，强烈建议在jBPM流程和表单使用数据对象时使用此模式。
          </p></li><li class="listitem"><p>可选：确定关系的右侧成员是否可以为null。
          </p></li><li class="listitem"><p>映射人：用于反向关系。
          </p></li></ul></div></div></strong></strong></div></div><div class="section" title="18.7.7.4.3。进阶网域"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e18719"></a> 18.7.7.4.3。进阶网域</strong></strong></h5></div></div></div><p><strong><strong>通过高级域，可以配置其他域设置的任何参数以及添加任意参数。如代码生成部分所示，每个“数据对象/字段”参数都由一个Java注释表示。高级模式启用此注释的配置。</strong></strong></p><div class="section" title="18.7.7.4.3.1。高级域数据对象/字段编辑器。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18724"></a> 18.7.7.4.3.1。高级域数据对象/字段编辑器。</strong></strong></h6></div></div></div><p><strong><strong>高级域编辑器的数据对象和字段具有相同的形状。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18729"></a><p class="title"><strong>图18.80。高级域编辑器。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/data-object-or-field-advanced-tool-window.png" alt="高级域编辑器。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>可以进行以下操作</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>delete：删除指定的数据对象或字段注释。
          </p></li><li class="listitem"><p>clear：清除给定的注释参数值。
          </p></li><li class="listitem"><p>编辑：启用给定注释参数值的版本。
          </p></li><li class="listitem"><p>添加注释：添加注释按钮将启动一个向导，该向导将允许添加项目依赖项中可用的所有Java注释。
          </p><p>添加注释向导步骤1：向导的第一步要求输入注释的完全合格的类名称，然后通过按“搜索”按钮，注释定义将被加载到向导中。此外，在加载注释定义时，将创建不同的向导步骤，以使不同注释参数的完成成为可能。必填参数将标有“ *”。
          </p><div class="figure"><a id="d0e18754"></a><p class="title"><strong>图18.81。注释定义已加载到向导中。
            </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/add-annotation-wizard-step1-annotation-loaded.png" alt="注释定义已加载到向导中。"></div></div></div></div><br class="figure-break"><p>向导将尽可能为给定的参数提供合适的编辑器。
          </p><div class="figure"><a id="d0e18763"></a><p class="title"><strong>图18.82。自动为Enumeration注释参数生成的枚举值编辑器。
            </strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/add-annotation-wizard-step2-enum-param-editor.png" alt="自动为Enumeration注释参数生成的枚举值编辑器。"></div></div></div></div><br class="figure-break"><p>当无法计算自定义编辑器时，将提供通用参数编辑器</p><div class="figure"><a id="d0e18772"></a><p class="title"><strong>图18.83。通用注释参数编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/add-annotation-wizard-step2-generic-param-editor.png" alt="通用注释参数编辑器"></div></div></div></div><br class="figure-break"><p>输入并验证所有必需参数后，将启用“完成”按钮，并且可以通过将注释添加到给定的“数据对象”或“字段”来完成向导。
          </p></li></ul></div></strong></strong></div></div></div><div class="section" title="18.7.7.5。生成数据模型代码。"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-generateCode"></a> 18.7.7.5。生成数据模型代码。</strong></strong></h4></div></div></div><p><strong><strong>数据模型本身只是一个可视化工具，它允许用户定义高级数据结构，以便它们一方面与Drools Engine交互，另一方面与jBPM平台交互。为了使这成为可能，必须将这些高级视觉结构转换为可被这些平台有效使用的低级工件。这些工件是Java POJO（普通的旧Java对象），它们在每次保存数据模型时都会生成，通过按下顶部的Data Modeller菜单中的“保存”按钮来生成。另外，当用户在“编辑器”和“源”选项卡之间往返时，将自动生成代码以保持与“编辑器”视图的一致性，反之亦然。
  </strong></strong></p><div class="figure"><strong><strong><a id="d0e18786"></a><p class="title"><strong>图18.84。从顶部菜单保存数据模型</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/save_top.jpg" alt="从顶部菜单保存数据模型"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>根据以下转换规则生成结果代码：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>数据对象的identifier属性将成为Java类的名称。因此，它必须是有效的Java标识符。
      </p></li><li class="listitem"><p>数据对象的package属性成为Java类的package声明。
      </p></li><li class="listitem"><p>数据对象的超类属性（如果存在）成为Java类的扩展声明。
      </p></li><li class="listitem"><p>数据对象的标签和描述属性将转换为Java注释“ @ org.kie.api.definition.type。标签”和“ @ org.kie.api.definition.type”。说明”。这些注释仅仅是保存相关信息的一种方式，目前还没有进一步处理。
      </p></li><li class="listitem"><p>数据对象的角色属性（如果存在）将转换为“ @ org.kie.api.definition.type”。角色的” Java注解，那<span class="emphasis"><em>就是</em></span>应用程序平台的解释，在某种意义上说，它标志着这个Java类的Drools的事件事实型。
      </p></li><li class="listitem"><p>数据对象的类型安全属性（如果存在）将转换为“ @ org.kie.api.definition.type”。TypeSafe Java批注。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的类反应性属性（如果存在）将转换为“ @ org.kie.api.definition.type”。ClassReactive Java注释。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的属性反应性属性（如果存在）将转换为“ @ org.kie.api.definition.type”。PropertyReactive Java注释。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的timestamp属性（如果存在）将转换为“ @ org.kie.api.definition.type”。时间戳记Java注释。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的duration属性（如果存在）将转换为“ @ org.kie.api.definition.type”。持续时间Java批注。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的expires属性（如果存在）将转换为“ @ org.kie.api.definition.type”。使Java注释过期。（请参阅Drools）</p></li><li class="listitem"><p>数据对象的远程属性（如果存在）将转换为“ @ org.kie.api.remote”。远程Java注释。（请参阅jBPM）</p></li></ul></div><p></p><p>生成标准的Java默认值（或无参数）构造函数，以及完整的参数构造函数，即，该构造函数接受每个数据对象的用户定义字段的值作为参数。
  </p><p>数据对象的用户定义字段将转换为Java类字段，每个字段都有其自己的getter和setter方法，并遵循以下转换规则：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>数据对象字段的标识符将成为Java字段标识符。因此，它必须是有效的Java标识符。
      </p></li><li class="listitem"><p>数据对象字段的类型直接转换为Java类的字段类型。如果该字段被声明为多个（即“列表”），则生成的字段属于“ java.util”。列表”类型。
      </p></li><li class="listitem"><p>equals属性：为特定字段设置时，该类属性将使用“ @ org.kie.api.definition.type”进行注释。键”注解，由Drools Engine解释，它将“参与”生成的equals（）方法，该方法将覆盖Object类的equals（）方法。后者意味着，如果字段是“原始”类型，则equals方法将简单地将其值与该类的另一个实例中相应字段的值进行比较。如果该字段是子实体或集合类型，则equals方法将对相应数据对象的Java类或java.util的equals方法进行方法调用。分别列出标准Java类。
      </p><p>如果在equals属性中检查了数据对象的用户定义字段中的<span class="emphasis"><em>任何</em></span>字段，则这还意味着除默认生成的构造函数外，还将生成另一个构造函数，将标记有Equals的所有字段作为参数接受。此外，equals（）方法的生成还意味着Object类的hashCode（）方法也将被覆盖，以这种方式将调用相应Java类类型（无论是“原始”还是用户）的hashCode（）方法。定义的类型），用于在数据模型中标记为“等于”的所有字段。
      </p></li><li class="listitem"><p>position属性：自动为所有用户定义的字段设置此字段属性，该属性从0开始，并为每个随后的新字段加1。但是，用户可以自由更改字段之间的位置。在代码生成时，此属性被转换为“ @ org.kie.api.definition.type”。位置”注释，可以由Drools Engine解释。同样，已建立的属性顺序确定了生成的Java类中构造函数参数的顺序。
      </p></li></ul></div><p></p><p>例如，在本章底部的图中可视化了为采购订单数据对象生成的Java类代码，该对象对应于其定义，如下图Purchase_example.jpg所示。请注意，数据对象的两个字段，即“标题”和“行”都标记为Equals，并分别分配了位置2和1。
  </p><div class="figure"><a id="d0e18862"></a><p class="title"><strong>图18.85。采购订单配置</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/6.3/generate-purchase-example.png" alt="采购订单配置"></div></div></div></div><br class="figure-break"><p></p><pre><code class="language-java">

    package org.jbpm.examples.purchases;

    /**
    * This class was automatically generated by the data modeler tool.
    */
    @org.kie.api.definition.type.Label("Purchase Order")
    @org.kie.api.definition.type.TypeSafe(true)
    @org.kie.api.definition.type.Role(org.kie.api.definition.type.Role.Type.EVENT)
    @org.kie.api.definition.type.Expires("2d")
    @org.kie.api.remote.Remotable
    public class PurchaseOrder implements java.io.Serializable
    {

    static final long serialVersionUID = 1L;

    @org.kie.api.definition.type.Label("Total")
    @org.kie.api.definition.type.Position(3)
    private java.lang.Double total;

    @org.kie.api.definition.type.Label("Description")
    @org.kie.api.definition.type.Position(0)
    private java.lang.String description;

    @org.kie.api.definition.type.Label("Lines")
    @org.kie.api.definition.type.Position(2)
    @org.kie.api.definition.type.Key
    private java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; lines;

    @org.kie.api.definition.type.Label("Header")
    @org.kie.api.definition.type.Position(1)
    @org.kie.api.definition.type.Key
    private org.jbpm.examples.purchases.PurchaseOrderHeader header;

    @org.kie.api.definition.type.Position(4)
    private java.lang.Boolean requiresCFOApproval;

    public PurchaseOrder()
    {
    }

    public java.lang.Double getTotal()
    {
    return this.total;
    }

    public void setTotal(java.lang.Double total)
    {
    this.total = total;
    }

    public java.lang.String getDescription()
    {
    return this.description;
    }

    public void setDescription(java.lang.String description)
    {
    this.description = description;
    }

    public java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; getLines()
    {
    return this.lines;
    }

    public void setLines(java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; lines)
    {
    this.lines = lines;
    }

    public org.jbpm.examples.purchases.PurchaseOrderHeader getHeader()
    {
    return this.header;
    }

    public void setHeader(org.jbpm.examples.purchases.PurchaseOrderHeader header)
    {
    this.header = header;
    }

    public java.lang.Boolean getRequiresCFOApproval()
    {
    return this.requiresCFOApproval;
    }

    public void setRequiresCFOApproval(java.lang.Boolean requiresCFOApproval)
    {
    this.requiresCFOApproval = requiresCFOApproval;
    }

    public PurchaseOrder(java.lang.Double total, java.lang.String description,
    java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; lines,
    org.jbpm.examples.purchases.PurchaseOrderHeader header,
    java.lang.Boolean requiresCFOApproval)
    {
    this.total = total;
    this.description = description;
    this.lines = lines;
    this.header = header;
    this.requiresCFOApproval = requiresCFOApproval;
    }

    public PurchaseOrder(java.lang.String description,
    org.jbpm.examples.purchases.PurchaseOrderHeader header,
    java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; lines,
    java.lang.Double total, java.lang.Boolean requiresCFOApproval)
    {
    this.description = description;
    this.header = header;
    this.lines = lines;
    this.total = total;
    this.requiresCFOApproval = requiresCFOApproval;
    }

    public PurchaseOrder(
    java.util.List&lt;org.jbpm.examples.purchases.PurchaseOrderLine&gt; lines,
    org.jbpm.examples.purchases.PurchaseOrderHeader header)
    {
    this.lines = lines;
    this.header = header;
    }

    @Override
    public boolean equals(Object o)
    {
    if (this == o)
    return true;
    if (o == null || getClass() != o.getClass())
    return false;
    org.jbpm.examples.purchases.PurchaseOrder that = (org.jbpm.examples.purchases.PurchaseOrder) o;
    if (lines != null ? !lines.equals(that.lines) : that.lines != null)
    return false;
    if (header != null ? !header.equals(that.header) : that.header != null)
    return false;
    return true;
    }

    @Override
    public int hashCode()
    {
    int result = 17;
    result = 31 * result + (lines != null ? lines.hashCode() : 0);
    result = 31 * result + (header != null ? header.hashCode() : 0);
    return result;
    }

    }

  </code></pre><p></p></strong></strong></div><div class="section" title="18.7.7.6。使用外部模型"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="sect-datamodeler-externalModels"></a> 18.7.7.6。使用外部模型</strong></strong></h4></div></div></div><p><strong><strong>使用外部模型意味着可以在当前项目上下文中将集合用于已定义的POJO。为了使这些POJO可用，应添加对给定JAR的依赖关系。一旦添加了依赖性，就可以从当前项目数据模型中引用外部POJO。</strong></strong></p><p><strong><strong>有两种向外部JAR文件添加依赖项的方法：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>对当前本地M2存储库中已安装的JAR文件的依赖（通常与用户主目录关联）。</strong></strong></p></li><li class="listitem"><p><strong><strong>对当前KIE Workbench / Drools工作台“ Guvnor M2存储库”中安装的JAR文件的依赖性。（在应用程序内部）</strong></strong></p></li></ul></div><div class="section" title="18.7.7.6.1。对本地M2存储库中JAR文件的依赖"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e18887"></a> 18.7.7.6.1。对本地M2存储库中JAR文件的依赖</strong></strong></h5></div></div></div><p><strong><strong>要将依赖项添加到本地M2存储库中的JAR文件中，请遵循以下步骤。</strong></strong></p><div class="section" title="18.7.7.6.1.1。打开当前项目的项目编辑器，然后选择“依赖关系”视图。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18892"></a> 18.7.7.6.1.1。打开当前项目的项目编辑器，然后选择“依赖关系”视图。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18895"></a><p class="title"><strong>图18.86。项目编辑。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-1.png" alt="项目编辑。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.1.2。点击" ad="=" =""><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18902"></a> 18.7.7.6.1.2。单击“添加”按钮以添加新的依赖行。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18905"></a><p class="title"><strong>图18.87。新的依赖线。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-2.png" alt="新的依赖线。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.1.3。为本地M2存储库中已安装的JAR文件完成GAV。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18912"></a> 18.7.7.6.1.3。为本地M2存储库中已安装的JAR文件完成GAV。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18915"></a><p class="title"><strong>图18.88。依赖线版本。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-3.png" alt="依赖线版本。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.1.4。保存项目以更新其依赖项。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18922"></a> 18.7.7.6.1.4。保存项目以更新其依赖项。</strong></strong></h6></div></div></div><p><strong><strong>保存项目后，将可以使用在外部文件中定义的POJO。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18927"></a><p class="title"><strong>图18.89。保存项目。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-4.png" alt="保存项目。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="18.7.7.6.2。当前对JAR文件的依赖" guvnor="" m2="" repositor="." =""><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e18934"></a> 18.7.7.6.2。对当前“ Guvnor M2存储库”中的JAR文件的依赖性。</strong></strong></h5></div></div></div><p><strong><strong>要将依赖项添加到当前“ Guvnor M2存储库”中的JAR文件中，请遵循以下步骤。</strong></strong></p><div class="section" title="18.7.7.6.2.1。打开Maven Artifact存储库编辑器。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18939"></a> 18.7.7.6.2.1。打开Maven Artifact存储库编辑器。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18942"></a><p class="title"><strong>图18.90。Guvnor M2存储库编辑器。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-1.png" alt="Guvnor M2存储库编辑器。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.2.2。浏览您的本地文件系统，然后使用“浏览”按钮选择要上传的JAR文件。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18949"></a> 18.7.7.6.2.2。浏览您的本地文件系统，然后使用“浏览”按钮选择要上传的JAR文件。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18952"></a><p class="title"><strong>图18.91。文件浏览器。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-2-2.png" alt="文件浏览器。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.2.3。使用“上传”按钮上传文件。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18959"></a> 18.7.7.6.2.3。使用“上传”按钮上传文件。</strong></strong></h6></div></div></div><div class="figure"><strong><strong><a id="d0e18962"></a><p class="title"><strong>图18.92。文件上传成功。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-3.png" alt="文件上传成功。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.2.4。Guvnor M2存储库文件。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18969"></a> 18.7.7.6.2.4。Guvnor M2存储库文件。</strong></strong></h6></div></div></div><p><strong><strong>加载文件后，它将显示在存储库文件列表中。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18974"></a><p class="title"><strong>图18.93。文件列表。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-4.png" alt="文件列表。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.2.5。为上载的文件提供GAV（可选）。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e18981"></a> 18.7.7.6.2.5。为上载的文件提供GAV（可选）。</strong></strong></h6></div></div></div><p><strong><strong>如果上载的文件不是有效的Maven JAR（没有pom.xml文件），系统将提示用户以便为要安装的文件提供GAV。</strong></strong></p><div class="figure"><strong><strong><a id="d0e18986"></a><p class="title"><strong>图18.94。无效的POM。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-not-gav-1.png" alt="无效的POM。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e18993"></a><p class="title"><strong>图18.95。手动输入GAV。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-not-gav-2.png" alt="手动输入GAV。"></div></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="18.7.7.6.2.6。从存储库添加依赖项。"><div class="titlepage"><div><div><h6 class="title"><strong><strong><a id="d0e19000"></a> 18.7.7.6.2.6。从存储库添加依赖项。</strong></strong></h6></div></div></div><p><strong><strong>打开项目编辑器（请参见下文），然后单击“从存储库添加”按钮以打开JAR选择器，以查看当前“ Guvnor M2存储库”中所有已安装的JAR文件。选择所需的文件后，应保存项目，以使新的依赖项可用。</strong></strong></p><div class="figure"><strong><strong><a id="d0e19005"></a><p class="title"><strong>图18.96。从“ Maven Artifact存储库”中选择JAR。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-guvnor-m2-5.png" alt="从中选择JAR" maven="" artifact="" repositor="." =""></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="18.7.7.6.3。使用外部对象"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e19012"></a> 18.7.7.6.3。使用外部对象</strong></strong></h5></div></div></div><p><strong><strong>设置对外部JAR的依赖关系后，可以通过以下方式在当前项目数据模型的上下文中使用外部POJO：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>外部POJO可以由当前模型数据对象扩展。</strong></strong></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>外部POJO可用作当前模型数据对象的字段类型。</strong></strong></p></li></ul></div><p><strong><strong>以下屏幕截图显示了如何为外部对象添加字符串“ -ext-”作为前缀，以便快速识别它们。</strong></strong></p><p></p><div class="figure"><strong><strong><a id="d0e19028"></a><p class="title"><strong>图18.97。识别外部对象。</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/add-dependency-select-external-pojo.png" alt="识别外部对象。"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="18.7.7.7。往返和并发"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19035"></a> 18.7.7.7。往返和并发</strong></strong></h4></div></div></div><p><strong><strong>当前版本在Data Modeller和Java源代码之间实现往返和代码保存。无论Java代码在哪里生成（例如Eclipse，Data Modeller），数据建模器都只会创建/删除/更新必要的代码元素以保持模型更新，即字段，getter / setter，构造函数，equals方法和hashCode方法。同样，当Java来源由数据建模者更新时，任何不受数据建模者管理的Type或Field注释也将被保留。
  </strong></strong></p><p><strong><strong>除了保留代码外，就像在其他工作台编辑器中一样，并发修改方案仍然可行。常见的场景是两个不同的用户正在为同一项目更新模型，例如使用数据建模器或执行修改项目源的“ git push命令”。
  </strong></strong></p><p><strong><strong>从应用程序上下文的角度来看，我们基本上可以确定两种不同的主要方案：</strong></strong></p><div class="section" title="18.7.7.7.1。没有通过应用程序进行任何更改"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e19044"></a> 18.7.7.7.1。没有通过应用程序进行任何更改</strong></strong></h5></div></div></div><p><strong><strong>在这种情况下，应用程序用户基本上只是浏览数据模型，而没有对其进行任何更改。同时，另一个用户在外部修改数据模型。</strong></strong></p><p><strong><strong>在这种情况下，不会立即向应用程序用户发出警告。但是，一旦用户尝试进行任何类型的更改（例如添加或删除数据对象或属性，或更改任何现有的对象或属性），就会显示以下弹出窗口：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19051"></a><p class="title"><strong>图18.98。外部变更警告</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/extchanges_reopen_ignore.jpg" alt="外部变更警告"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>用户可以选择：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>重新打开数据模型，从而加载所有外部更改，然后执行他将要进行的修改，或者</p></li><li class="listitem"><p>忽略任何外部更改，然后继续对模型进行修改。在这种情况下，当尝试保留这些更改时，将显示另一个弹出警告：</p><div class="figure"><a id="d0e19068"></a><p class="title"><strong>图18.99。强制保存/重新打开</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/extchanges_forcesave_reopen.jpg" alt="强制保存/重新打开"></div></div></div></div><br class="figure-break"><p>“强制保存”选项将有效覆盖所有外部更改，而“重新打开”将放弃所有本地更改并重新加载模型。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><h2>警告</h2><p>“强制保存”将覆盖所有外部更改！</p></div></li></ul></div><p></p></strong></strong></div><div class="section" title="18.7.7.7.2。通过应用程序进行了更改"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="d0e19081"></a> 18.7.7.7.2。通过应用程序进行了更改</strong></strong></h5></div></div></div><p><strong><strong>应用程序用户已对数据模型进行了更改。同时，另一个用户同时从应用程序上下文外部修改数据模型。</strong></strong></p><p><strong><strong>在此替代方案中，在外部用户将其更改提交到资产存储库后（或例如，在不同的会话中使用数据建模器保存模型）之后，立即向应用程序用户发出警告：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19088"></a><p class="title"><strong>图18.100。外部变更警告</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/extchanges_reopen_ignore.jpg" alt="外部变更警告"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p></p><p>与以前的方案一样，用户可以选择以下任一项：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>重新打开数据模型，从而丢失通过应用程序进行的任何修改，或者</p></li><li class="listitem"><p>忽略任何外部更改，然后继续处理模型。</p><p>现在可能发生以下情况之一：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>用户尝试通过单击数据建模器顶级菜单中的“保存”按钮来保留对模型所做的更改。这将导致以下警告消息：</p><div class="figure"><a id="d0e19111"></a><p class="title"><strong>图18.101。强制保存/重新打开</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataModeller/extchanges_forcesave_reopen.jpg" alt="强制保存/重新打开"></div></div></div></div><br class="figure-break"><p>“强制保存”选项将有效覆盖所有外部更改，而“重新打开”将放弃所有本地更改并重新加载模型。</p></li></ul></div></li></ul></div></strong></strong></div></div></div><div class="section" title="18.7.8。数据集"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.DataSets"></a> 18.7.8。数据集</strong></strong></h3></div></div></div><p><strong><strong><span class="bold"><strong>数据集</strong></span>基本上是一组由一些行组成的列，这是由时间戳，文本和数字组成的数据矩阵。数据集可以存储在不同的系统中：数据库，excel文件，内存中或许多其他不同的系统中。另一方面， <span class="bold"><strong>数据集定义</strong></span>告诉工作台模块如何访问，读取和解析此类数据。
  </strong></strong></p><p><strong><strong>请注意，弄清数据集及其定义之间的区别非常重要，因为工作台不负责存储任何数据，它只是提供了一种标准方法来定义对那些数据集的访问，而不管数据存储在何处。
  </strong></strong></p><p><strong><strong>让我们以存储在远程数据库中的数据为例。有效数据集可以是例如整个数据库表或SQL查询的结果。在这两种情况下，数据库都会返回一堆列和行。现在，假设我们想访问这些数据以在新的工作台透视图中提供一些图表。第一件事是创建并注册数据集定义，以指示以下内容：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>数据集的存储位置</strong></strong></p></li><li class="listitem"><p><strong><strong>如何访问，读取和解析以及</strong></strong></p></li><li class="listitem"><p><strong><strong>哪些列包含哪些类型。</strong></strong></p></li></ul></div><p><strong><strong>本章介绍了用于注册和处理数据集定义的可用工作台工具，以及如何在其他工作台模块（例如，透视编辑器）中使用这些定义。
  </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>为简单起见，我们将使用<span class="emphasis"><em>数据集</em></span>一词来指代实际的数据集定义，因为在数据集创作上下文中， <span class="emphasis"><em>数据集</em></span>和<span class="emphasis"><em>数据集定义</em></span>可以视为同义词。
    </strong></strong></p></div><div class="section" title="18.7.8.1。数据集创作视角"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetAuthoringPerspective"></a> 18.7.8.1。数据集创作视角</strong></strong></h4></div></div></div><p><strong><strong>与数据集创作相关的所有内容都可以在“ <span class="emphasis"><em>数据集创作”</em></span>透视图中找到，可从以下顶级菜单条目访问： <span class="emphasis"><em>扩展>数据集</em></span> ，如以下屏幕快照所示。</strong></strong></p><div class="figure"><strong><strong><a id="d0e19171"></a><p class="title"><strong>图18.102。数据集创作视角</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetAuthoringPerspective.png" alt="数据集创作视角"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>中间面板显示欢迎屏幕，而左侧面板包含<span class="emphasis"><em>数据集资源管理器，其中</em></span>列出了所有可用数据集</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>此观点仅适用于管理员用户，因为定义数据集可被视为低级任务。
      </p></div></strong></strong></div><div class="section" title="18.7.8.2。数据集浏览器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetExplorer"></a> 18.7.8.2。数据集浏览器</strong></strong></h4></div></div></div><p><strong><strong><span class="emphasis"><em>数据集资源管理器</em></span>列出了系统中存在的数据集。每次用户单击数据集时，它都会显示一个简短的摘要以及以下信息：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19194"></a><p class="title"><strong>图18.103。数据集浏览器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetExplorer.png" alt="数据集浏览器"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>（1）用于创建新数据集的按钮</p></li><li class="listitem"><p>（2）当前可用数据集的列表</p></li><li class="listitem"><p>（3）代表数据集提供程序类型（Bean，SQL，CSV等）的图标</p></li><li class="listitem"><p>（4）当前缓存和刷新策略状态的详细信息</p></li><li class="listitem"><p>（5）后端当前大小（以行为单位）和客户端当前大小（以字节为单位）的详细信息</p></li><li class="listitem"><p>（6）用于编辑数据集的按钮。单击后，将在中心面板上打开“数据集编辑器”屏幕。</p></li></ul></div><p>下一节将说明如何创建，编辑和微调数据集定义。
    </p></strong></strong></div><div class="section" title="18.7.8.3。数据集创建"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetCreation"></a> 18.7.8.3。数据集创建</strong></strong></h4></div></div></div><p><strong><strong>单击“ <span class="emphasis"><em>新建数据集”</em></span>按钮将打开一个新屏幕，用户可以通过该屏幕通过三个步骤创建新数据集定义：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>
          <span class="emphasis"><em>提供者类型选择</em></span>
          </strong></strong></p><p><strong><strong>指定远程存储系统的类型（BEAN，SQL，CSV，ElasticSearch）</strong></strong></p><p><strong><strong>
        </strong></strong></p></li><li class="listitem"><p><strong><strong>
          <span class="emphasis"><em>提供者配置</em></span>
          </strong></strong></p><p><strong><strong>指定能够从远程系统中查找数据的属性。该配置因所选的数据提供程序类型而异。
          </strong></strong></p><p><strong><strong>
        </strong></strong></p></li><li class="listitem"><p><strong><strong>
          <span class="emphasis"><em>数据集列和过滤器</em></span>
          </strong></strong></p><p><strong><strong>实时数据预览，列类型和初始过滤器配置。
          </strong></strong></p><p><strong><strong>
        </strong></strong></p></li></ul></div><div class="section" title="18.7.8.3.1。步骤1：提供者类型选择"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="wb.DataSetCreationTypeSelection"></a> 18.7.8.3.1。步骤1：提供者类型选择</strong></strong></h5></div></div></div><p><strong><strong>允许用户指定要创建的数据集的数据提供者的类型。
      </strong></strong></p><p><strong><strong>该屏幕列出了所有当前可用的数据提供者类型以及说明的帮助程序弹出窗口。每个数据提供者都用一个描述性图像表示：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19266"></a><p class="title"><strong>图18.104。提供者类型选择</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefTypeSelection.png" alt="提供者类型选择"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>当前支持四种类型：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Bean（Java类）-直接从Java生成数据集</p></li><li class="listitem"><p>SQL-用于从任何符合ANSI-SQL的数据库中获取数据</p></li><li class="listitem"><p>CSV-上传远程或本地CSV文件的内容</p></li><li class="listitem"><p>Elastic Search-查询和获取存储在Elastic Search节点上的文档作为数据集</p></li></ul></div><p>选择类型后，单击“下一步”按钮继续下一个工作流程步骤。
      </p></strong></strong></div><div class="section" title="18.7.8.3.2。步骤2：设定"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="wb.DataSetCreationConfiguration"></a> 18.7.8.3.2。步骤2：设定</strong></strong></h5></div></div></div><strong><strong>下面的屏幕截图显示了CSV数据集配置表单。完成所有必需的设置后，单击“测试”按钮。系统将尝试获取少量数据，然后再进行下一个工作流程步骤。

      <div class="figure"><a id="d0e19294"></a><p class="title"><strong>图18.105。CSV配置</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefConfigScreen.png" alt="CSV配置"></div></div></div></div><br class="figure-break"><p>在上一步中选择的提供者类型将确定系统要求的配置设置。
      </p><div class="figure"><a id="d0e19303"></a><p class="title"><strong>图18.106。每种数据集类型的配置屏幕</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefConfigTypes.png" alt="每种数据集类型的配置屏幕"></div></div></div></div><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>UUID属性是系统生成的只读字段。仅适用于API调用或特定操作。
        </p></div></strong></strong></div><div class="section" title="18.7.8.3.3。步骤3：资料集栏和预览"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="wb.DataSetCreationPreview"></a> 18.7.8.3.3。步骤3：资料集栏和预览</strong></strong></h5></div></div></div><p><strong><strong>单击“ <span class="emphasis"><em>测试”</em></span>按钮（请参阅上一步）后，系统将执行数据集查找测试调用，以检查远程系统是否已启动并且数据是否可用。如果一切正常，用户将看到以下屏幕：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19321"></a><p class="title"><strong>图18.107。数据集预览</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefLivePreview.png" alt="数据集预览"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>该屏幕显示实时数据预览以及用户希望成为结果数据集一部分的列。用户还可以浏览数据并将某些更改应用于数据集结构。完成后，我们可以单击“ <span class="emphasis"><em>保存”</em></span>按钮以注册新的数据集定义。
      </p><p>我们还可以随时返回配置标签来随时更改配置设置。我们可以根据需要重复“ <span class="emphasis"><em>配置”>“测试”>“预览”</em></span>循环，直到我们认为可以将其保存为止。
      </p><p>
        <span class="bold"><strong>列</strong></span>
      </p><p>在“ <span class="emphasis"><em>列”</em></span>选项卡区域中，用户可以选择哪些列是结果数据集定义的一部分。
      </p><div class="figure"><a id="d0e19349"></a><p class="title"><strong>图18.108。数据集列</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefColumns.png" alt="数据集列"></div></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>（1）添加或删除列。仅选择要成为结果数据集一部分的那些列</p></li><li class="listitem"><p>（2）使用下拉图像选择器更改列类型</p></li></ul></div><p>数据集只能包含以下4种类型的列：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>标签-对于支持组操作的文本值（类似于SQL“ group by”运算符），这意味着您可以执行数据查找调用并为每个不同的值获取一行。
          </p></li><li class="listitem"><p>文本-对于不支持组操作的文本值。通常用于建模大型文本列，例如摘要，描述等。
          </p></li><li class="listitem"><p>数字-用于数字值。它确实支持数据查询调用的聚合功能：求和，最小值，最大值，平均值，计数，区别。
          </p></li><li class="listitem"><p>日期-用于日期或时间戳记值。它确实支持通过不同时间间隔的基于时间的组操作：分钟，小时，天，月，年，...
          </p></li></ul></div><p>无论您要从哪个远程系统检索数据，结果数据集将始终返回上述四种类型之一的一组列。默认情况下，远程系统列类型和数据集类型之间存在映射。用户可以修改某些列的类型，具体取决于数据提供者和远程系统的列类型。系统支持对列类型的以下更改：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>标签<>文本-当我们想要启用/禁用目标列的分类（分组）时很有用。例如，假设有一个名为“文档”的数据库表，其中包含一个名为“抽象”的大文本列。由于我们不希望系统将此类列视为“标签”，因此可以将其列类型更改为“文本”。这样做，我们正在优化系统处理数据集的方式，并</p></li><li class="listitem"><p>数字<>标签-当我们要将数字列视为标签时很有用。例如，这可用于指示给定的数字列不是可在聚合函数中使用的数字值。尽管其值存储为数字，但我们还是希望将列作为“标签”来处理。此类列的一个示例是：项目的代码，评估ID，...
          </p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>BEAN数据集不支持更改列类型，因为由开发人员决定每个列的具体类型。
        </p></div><p>
        <span class="bold"><strong>过滤</strong></span>
      </p><p>数据集定义可以定义过滤器。过滤器的目标是省略用户认为不必要的行。过滤器功能适用于任何数据提供者类型，它使用户可以对任何可用的数据集列应用过滤器操作。
      </p><div class="figure"><a id="d0e19398"></a><p class="title"><strong>图18.109。数据集过滤器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefFilter.png" alt="数据集过滤器"></div></div></div></div><br class="figure-break"><p>在添加或删除过滤器条件和操作时，中心区域的预览表将使用反映当前过滤器状态的实时数据进行更新。
      </p><p>存在两种用于过滤数据集的策略，还需要注意的是，在两者之间进行选择具有重要的意义。想象一下一个仪表板，其中有一些图表是从费用报告数据集中获取的，而该数据集是建立在SQL表之上的。试想一下，我们只想从“伦敦”办公室检索费用报告。您可以定义一个数据集，其中包含过滤器“ office = London”，然后从该数据集中获取多个图表。这是推荐的方法。另一个选择是定义一个没有初始过滤器的数据集，然后让各个图表指定自己的过滤器。由用户决定最佳方法。
      </p><p>根据情况，最好在数据集级别定义过滤器以在其他模块之间重用。该决定可能还会影响性能，因为过滤后的缓存数据集将比许多单独的非缓存数据集查找请求具有更好的性能。（有关缓存数据集的更多信息，请参见下一部分）。
      </p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>请注意，对于SQL数据集，用户既可以使用引入的过滤器功能，也可以仅向SQL语句添加自定义过滤器条件。虽然，第一种方法更适合非技术用户，因为他们可能没有所需的SQL语言技能。
        </p></div></strong></strong></div></div><div class="section" title="18.7.8.4。数据集编辑器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetDefEditor"></a> 18.7.8.4。数据集编辑器</strong></strong></h4></div></div></div><p><strong><strong>要编辑现有数据集定义，请转到数据集浏览器，展开所需的数据集定义，然后单击“ <span class="emphasis"><em>编辑”</em></span>按钮。这将导致一个新的编辑器面板被打开并放置在屏幕中央，如以下屏幕截图所示：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19423"></a><p class="title"><strong>图18.110。数据集定义编辑器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefEditor.png" alt="数据集定义编辑器"></div></div></div></strong></strong></div><strong><strong><br class="figure-break">每次我们编辑项目时，其编辑器都会添加到中央面板。我们只需单击右上角编辑器工具栏上的向下箭头图标，即可浏览已打开的编辑器列表。

    <div class="figure"><a id="d0e19431"></a><p class="title"><strong>图18.111。编辑器选择器</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefEditorSelector.png" alt="编辑器选择器"></div></div></div></div><br class="figure-break">该编辑器提供了前面几节中描述的所有功能。我们可以更改配置设置，测试数据集定义并修改结果数据集结构。此外，编辑器在其工具栏中提供了一些其他按钮：<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>保存-验证当前更改并存储数据集定义。
        </p></li><li class="listitem"><p>删除-从存储中永久删除数据集定义。任何引用该数据集的客户端模块都可能受到影响。
        </p></li><li class="listitem"><p>验证-检查所有必需参数是否存在并且正确，以及验证可以毫无问题地检索数据集。
        </p></li><li class="listitem"><p>复制-创建一个全新的定义作为当前定义的副本。
        </p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>数据集定义作为JSON文件存储在基础GIT存储库中。所执行的所有操作都会在存储库日志中注册，因此以后可以审核更改日志。
      </p></div></strong></strong></div><div class="section" title="18.7.8.5。高级设置"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetAdvancedSettings"></a> 18.7.8.5。高级设置</strong></strong></h4></div></div></div><p><strong><strong>用户可以在“ <span class="emphasis"><em>高级设置”</em></span>选项卡区域中指定缓存和刷新设置。这些对于充分利用系统功能，提高性能和提高应用程序响应级别非常重要。
    </strong></strong></p><div class="figure"><strong><strong><a id="d0e19464"></a><p class="title"><strong>图18.112。高级设置</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefAdvanced.png" alt="高级设置"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>（1）启用或禁用客户端缓存并指定最大大小（字节）。
        </p></li><li class="listitem"><p>（2）启用或禁用后端缓存并指定最大缓存大小（行数）。
        </p></li><li class="listitem"><p>（3）启用或禁用数据集和刷新周期的自动刷新。
        </p></li><li class="listitem"><p>（4）启用或禁用陈旧数据刷新设置。
        </p></li></ul></div><p>让我们深入了解这些设置的含义。
    </p></strong></strong></div><div class="section" title="18.7.8.6。快取"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetCacheSettings"></a> 18.7.8.6。快取</strong></strong></h4></div></div></div><p><strong><strong>该系统提供了开箱即用的缓存机制，用于保存数据集并使用内存策略执行数据操作。这些功能的使用带来了很多优势，例如减少了网络流量，远程系统有效负载，处理时间等。另一方面，用户可以适当地调整缓存设置，以避免遇到性能问题。
    </strong></strong></p><p><strong><strong>支持两种缓存级别：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>客户等级</strong></strong></p></li><li class="listitem"><p><strong><strong>后端级别</strong></strong></p></li></ul></div><p><strong><strong>下图显示了任何数据集操作如何涉及缓存：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19503"></a><p class="title"><strong>图18.113。数据集缓存</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetCacheArchitecture.png" alt="数据集缓存"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>任何数据查找调用都会生成结果数据集，因此缓存技术的使用将确定执行数据查找调用的位置以及结果数据集的位置。
    </p><p>
      <span class="bold"><strong>客户端缓存</strong></span>
    </p><p>如果为ON，则查找操作中涉及的数据集将被推入Web浏览器，从而使从该数据集馈送的所有组件<span class="bold"><strong>都无需对后端执行任何请求，</strong></span>因为数据集操作是在客户端进行解析的：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>数据集存储在Web浏览器的内存中</p></li><li class="listitem"><p>客户端组件从存储在浏览器中的数据集提要</p></li><li class="listitem"><p>数据集操作（分组，聚合，过滤器和排序）是通过Java数据集操作引擎在Web浏览器中进行处理的。
        </p></li></ul></div><p>如果事先知道数据集将很小，则可以启用客户端缓存。它将减少后端请求的数量，包括对存储系统的请求。另一方面，如果您认为数据集会很大，请禁用客户端缓存，以免出现浏览器问题，例如性能降低或间歇性挂起。
    </p><p>
      <span class="bold"><strong>后端缓存</strong></span>
    </p><p>其目标是为后端的数据集提供一种缓存机制。
    </p><p>通过将数据集保存在内存中并使用内存引擎执行分组，过滤和排序操作，此功能可以<span class="bold"><strong>减少对远程存储系统的请求数量</strong></span> 。
    </p><p>这对于不经常更改的数据集很有用，并且可以认为它们的大小可以在内存中保存和处理。对于远程存储的低延迟连接问题，它也很有帮助。另一方面，如果您的数据集将经常更新，则最好禁用后端缓存，并在每个查找请求上执行对远程存储的请求，因此存储系统负责解决数据集查找请求。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>默认情况下，BEAN和CSV数据提供程序依赖于后端缓存，因为在两种情况下，必须始终将数据集加载到内存中，才能使用内存引擎解析任何数据查找操作。这就是为什么后端设置在“高级设置”选项卡中不可见的原因。
      </p></div></strong></strong></div><div class="section" title="18.7.8.7。刷新"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.DataSetRefreshSettings"></a> 18.7.8.7。刷新</strong></strong></h4></div></div></div><p><strong><strong>刷新功能允许在满足某些条件时使任何缓存的数据无效。
    </strong></strong></p><div class="figure"><strong><strong><a id="d0e19559"></a><p class="title"><strong>图18.114。刷新设置</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Workbench/Authoring/DataSets/DataSetDefRefreshSettings.png" alt="刷新设置"></div></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>（1）启用或禁用刷新功能。
        </p></li><li class="listitem"><p>（2）指定刷新间隔。
        </p></li><li class="listitem"><p>（3）在数据过时时启用或禁用数据集无效。
        </p></li></ul></div><p>数据集刷新策略与数据集缓存紧密相关，在上一节中进行了详细介绍。这种失效机制决定了缓存的生命周期。
    </p><p>根据数据的性质，存在三个主要用例：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
          <span class="bold"><strong>源数据的变化是可预测的</strong></span> -想象一下每晚都有一个数据库被更新。在这种情况下，建议的配置是使用“刷新间隔= 1天”并禁用“刷新陈旧数据”。这样，系统将始终每天使缓存的数据集无效。当我们事先知道数据将要更改时，这是正确的配置。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>源数据的变化无法预测</strong></span> -另一方面，如果我们不知道数据库是否每天都在更新，建议的配置是使用“刷新间隔= 1天”并启用“刷新陈旧数据”。如果是这样，系统将在使任何数据无效之前检查修改。在修改数据时，系统将使当前的过时数据集无效，以便在下一个数据集查找调用中用新数据填充缓存。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>实时方案</strong></span> -在实时方案中，缓存没有意义，因为数据将不断更新。在这种情况下，必须不断更新发送到客户端的数据，因此，与其启用刷新设置（请记住此设置会影响缓存，并且未启用缓存），不如由客户端使用数据集来决定何时刷新。当客户端是仪表板时，只需在Displayer Editor配置屏幕中修改刷新设置并设置适当的刷新周期即可，例如“刷新间隔= 1秒”。
        </p></li></ul></div></strong></strong></div></div></div><div class="section" title="18.8。用户和组管理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.UserAndGroupMgmt"></a> 18.8。用户和组管理</strong></strong></h2></div></div></div><div class="section" title="18.8.1。介绍"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e19602"></a> 18.8.1。介绍</strong></strong></h3></div></div></div><p><strong><strong>本节描述了一项功能，该功能允许使用集成在jBPM和Drools Workbenches中的直观友好的用户界面来管理应用程序的用户和组。</strong></strong></p><div class="figure"><strong><strong><a id="d0e19607"></a><p class="title"><strong>图18.115。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/home.png"></div></div></strong></strong></div><p><strong><strong><br class="figure-break"></strong></strong></p><p><strong><strong>在安装，设置和使用此功能之前，本节将讨论一些以前的概念，这些概念需要进一步了解才能进一步使用：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>安全管理提供者和功能</strong></strong></p></li><li class="listitem"><p><strong><strong>安装与设定</strong></strong></p></li><li class="listitem"><p><strong><strong>用法</strong></strong></p></li></ul></div></div><div class="section" title="18.8.2。安全管理提供商"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e19623"></a> 18.8.2。安全管理提供商</strong></strong></h3></div></div></div><p><strong><strong>通常通过使用<span class="emphasis"><em>领域</em></span>来提供安全环境。领域用于限制对不同应用程序资源的访问。因此，领域包含有关用户，组，角色，权限和任何其他相关信息的信息。</strong></strong></p><p><strong><strong>在大多数典型方案中，应用程序的安全性委派给容器的安全性机制，该机制同时消耗给定领域。必须考虑存在多个领域实现，例如，Wildfly提供了基于<span class="emphasis"><em>application-users.properties</em></span> / <span class="emphasis"><em>application-roles.properties</em></span>文件的领域，Tomcat提供了基于<span class="emphasis"><em>tomcat-users.xml</em></span>文件的领域，等等。请记住，没有单一的安全领域可依赖，在每个安装中它可以有所不同。</strong></strong></p><p><strong><strong>jBPM和Drools工作台也不例外，它们建立在顶级Uberfire框架（又名UF）上，该框架还将授权和身份验证委派给基础容器的安全环境，因此使用的领域由具体的部署配置提供。</strong></strong></p><div class="section" title="18.8.2.1。安全管理提供商"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19644"></a> 18.8.2.1。安全管理提供商</strong></strong></h4></div></div></div><p><strong><strong>由于必须支持潜在的不同安全环境，因此用户和组管理提供了定义良好的管理服务API，并带有一些默认的内置安全管理提供程序。<span class="bold"><strong>安全管理提供程序</strong></span>是给定领域的具体用户和组管理服务实现的正式名称。</strong></strong></p><p><strong><strong>目前，默认情况下有两个安全管理提供程序可用：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong>Wildfly / EAP安全管理提供程序</strong></span> -用于基于属性文件的Wildfly或EAP领域。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>Tomcat安全管理提供程序</strong></span> -用于基于XML文件的Tomcat领域。</strong></strong></p></li></ul></div><p><strong><strong>如果内置提供程序不适合应用程序的安全领域，则可以轻松构建和注册自己的安全管理提供程序。</strong></strong></p></div><div class="section" title="18.8.2.2。安全管理提供程序功能"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19667"></a> 18.8.2.2。安全管理提供程序功能</strong></strong></h4></div></div></div><p><strong><strong>每个安全领域可以提供支持不同的操作。例如，考虑基于属性文件使用Wildfly领域，applications-users.properties的内容如下：</strong></strong></p><pre><code class="no-highlight">admin=207b6e0cc556d7084b5e2db7d822555c
salaboy=d4af256e7007fea2e581d539e05edd1b
maciej=3c8609f5e0c908a8c361ca633ed23844
kris=0bfd0f47d4817f2557c91cbab38bb92d
katy=fd37b5d0b82ce027bfad677a54fbccee
john=afda4373c6021f3f5841cd6c0a027244
jack=984ba30e11dda7b9ed86ba7b73d01481
director=6b7f87a92b62bedd0a5a94c98bd83e21
user=c5568adea472163dfc00c19c6348a665
guest=b5d048a237bfd2874b6928e1f37ee15e
kiewb=78541b7b451d8012223f29ba5141bcc2
kieserver=16c6511893651c9b4b57e0c027a96075</code></pre><p><strong><strong>请注意，它基于键值对，其中键是<span class="emphasis"><em>用户名</em></span> ，值是用户<span class="emphasis"><em>password</em></span>的哈希值。因此，仅通过键，其用户名来定义用户，它没有名称，地址或任何其他元信息。</strong></strong></p><p><strong><strong>另一方面，请考虑使用Keycloak服务器提供的领域。用户的信息由更多的用户元数据组成，例如姓，地址等，如下图所示：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19684"></a><p class="title"><strong>图18.116。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/admin_user_view.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>因此，与用户和组管理API不同的服务和客户端组件均基于<span class="emphasis"><em>功能</em></span> 。<span class="bold"><strong>功能</strong></span>用于公开或限制由不同服务和客户端组件提供的可用功能。功能示例包括：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>创建一个用户</p></li><li class="listitem"><p>更新用户</p></li><li class="listitem"><p>删除用户</p></li><li class="listitem"><p>更新用户的属性</p></li><li class="listitem"><p>建立群组</p></li><li class="listitem"><p>更新群组</p></li><li class="listitem"><p>为用户分配组</p></li><li class="listitem"><p>为用户分配角色</p></li></ul></div><p>每个安全管理提供程序必须指定一组支持的功能。从前面的示例中，您可以注意到Wildfly安全管理提供程序不支持用户属性的管理功能-用户仅由用户名组成。另一方面，Keycloak提供程序确实支持此功能。</p><p>不同的视图和用户界面组件依赖于每个提供程序支持的功能，因此，如果使用中的提供程序不支持该功能，则UI不会提供用于管理该功能的视图。例如，请考虑一个具体的提供者不支持删除用户-用户界面上的删除用户按钮将不可用。</p><p>请查看具体的服务提供商文档，以检查每种支持的所有功能，可以在<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">此处</a>找到默认功能。</p></strong></strong></div></div><div class="section" title="18.8.3。安装与设定"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e19730"></a> 18.8.3。安装与设定</strong></strong></h3></div></div></div><p><strong><strong>在考虑安装和设置步骤之前，请注意，默认情况下，以下Drools和jBPM发行版附带内置的，预安装的安全管理提供程序：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong>Wildfly / EAP分发</strong></span> -两种分发都使用<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management/uberfire-security-management-wildfly">Wildfly安全管理提供程序</a> ，该<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management/uberfire-security-management-wildfly">提供程序</a>配置为使用默认领域文件<span class="italic">application-users.properties</span>和<span class="italic">application-roles.properties</span></strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>Tomcat分发</strong></span> -它使用为默认域文件<span class="italic">tomcat-users.xml</span>的使用而配置的<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management/uberfire-security-management-tomcat">Tomcat安全管理提供程序</a></strong></strong></p></li></ul></div><p><strong><strong>请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a> ，以将具体设置应用于目标部署环境。</strong></strong></p><p><strong><strong>另一方面，如果使用自定义安全管理提供程序或需要将其包含在现有应用程序中，请考虑以下安装选项：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>在现有的WAR发行版上启用安全管理功能</strong></strong></p></li><li class="listitem"><p><strong><strong>在现有或新项目中进行设置和安装</strong></strong></p></li></ul></div><p><strong><strong><span class="emphasis"><em>注意</em></span> ：如果应用程序中未安装任何安全管理提供程序，则将没有可用的用户界面来管理安全领域。安装和设置安全管理提供程序后，将自动启用用户和组管理用户界面，并可以从主菜单中对其进行访问。</strong></strong></p><div class="section" title="18.8.3.1。在现有的WAR发行版上启用安全管理功能"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19777"></a> 18.8.3.1。在现有的WAR发行版上启用安全管理功能</strong></strong></h4></div></div></div><p><strong><strong>给定Drools和jBPM工作台的现有WAR分发，请按照以下步骤安装和启用用户管理功能：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>确保<span class="italic">WEB-INF / lib</span>上存在以下库：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>WEB-INF / lib / uberfire-security-management-api-6.4.0。Final..jar</strong></strong></p></li><li class="listitem"><p><strong><strong>WEB-INF / lib / uberfire-security-management-backend-6.4.0。Final..jar</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>在<span class="italic">WEB-INF / lib中</span>添加供安全管理提供程序使用的具体库：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>例如：WEB-INF / lib / uberfire-security-management-wildfly-6.4.0。Final..jar</strong></strong></p></li><li class="listitem"><p><strong><strong>如果您使用的具体提供程序需要更多库，则也要添加这些库。请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a>以获取更多信息</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>将整个内容替换为文件<span class="italic">WEB-INF / classes / security-management.properties</span> ，如果不存在，则创建它。该文件上存在的设置取决于您所使用的具体实现。请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a>以获取更多信息。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果要在Wildfly或EAP上进行部署，请检查<span class="italic">WEB-INF / jboss-deployment-structure.xml是否</span>需要任何更新。请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a>以获取更多信息。</strong></strong></p></li></ul></div></div><div class="section" title="18.8.3.2。在现有或新项目中进行设置和安装"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19830"></a> 18.8.3.2。在现有或新项目中进行设置和安装</strong></strong></h4></div></div></div><p><strong><strong>如果您要构建基于<a class="link" href="http://uberfireframework.org/">Uberfire</a>的Web应用程序，并且要包括用户和组管理功能，请阅读<a class="link" href="https://github.com/uberfire/uberfire-extensions/blob/master/uberfire-security/uberfire-security-management/uberfire-security-management-client-wb/README.md">此说明</a> 。</strong></strong></p></div><div class="section" title="18.8.3.3。禁用安全管理功能"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e19841"></a> 18.8.3.3。禁用安全管理功能</strong></strong></h4></div></div></div><p><strong><strong>可以通过以下任何一种禁用安全管理功能，从而使任何服务或用户界面都不可用：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>从应用程序中卸载安全管理提供程序</strong></strong></p><p><strong><strong>如果在应用程序上未安装任何具体的安全管理提供程序，则将禁用用户和组管理功能，并且不会向用户提供任何服务或用户界面。</strong></strong></p></li><li class="listitem"><p><strong><strong>删除或注释安全管理配置文件</strong></strong></p><p><strong><strong>删除或注释位于<span class="italic">WEB-INF / classes / security-management.properties</span>的配置文件中的所有行将禁用用户和组管理功能，并且不会向用户提供任何服务或用户界面。</strong></strong></p></li></ul></div></div></div><div class="section" title="18.8.4。用法"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e19860"></a> 18.8.4。用法</strong></strong></h3></div></div></div><p><strong><strong>用户和组管理功能是使用两个不同的视角来呈现的，这些视角可从主“ <span class="italic">主页”</span>菜单中获得（考虑到该功能已启用），如下所示：</strong></strong></p><div class="figure"><strong><strong><a id="d0e19868"></a><p class="title"><strong>图18.117。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/main_menu.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>阅读以下各节，以同时使用用户和组管理透视图。</p><div class="section" title="18.8.4.1。用户管理"><div class="titlepage"><div><div><h4 class="title"><a id="d0e19874"></a> 18.8.4.1。用户管理</h4></div></div></div><p>用户管理界面可从“ <span class="italic">主页”</span>菜单中的“ <span class="italic">用户管理”</span>菜单项获得。</p><p>该界面使用两个主面板呈现：西面板上的用户浏览器和中间面板上的用户编辑器：</p><div class="figure"><a id="d0e19887"></a><p class="title"><strong>图18.118。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/users_perspective.png"></div></div></div><br class="figure-break"><p>西面板上的<span class="bold"><strong>用户浏览器</strong></span>默认情况下列出了应用程序安全领域中存在的所有用户：</p><div class="figure"><a id="d0e19896"></a><p class="title"><strong>图18.119。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/users_explorer.png"></div></div></div><br class="figure-break"><p>除了列出所有用户之外，用户资源管理器还允许：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>搜索用户</strong></span></p><p>在搜索框中指定搜索模式时，用户列表将减少，并且将仅显示与搜索模式匹配的用户。</p><div class="figure"><a id="d0e19909"></a><p class="title"><strong>图18.120。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/users_explorer_search.png"></div></div></div><br class="figure-break"><p>搜索模式取决于应用程序所使用的具体安全管理提供程序。请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a>以获取更多信息。</p></li><li class="listitem"><p><span class="bold"><strong>创建新用户</strong></span></p><p>通过单击<span class="italic">创建新用户</span>按钮，将在中心面板上显示一个新屏幕以执行新用户创建。</p><div class="figure"><a id="d0e19927"></a><p class="title"><strong>图18.121。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/create_new_user.png"></div></div></div><br class="figure-break"></li></ul></div><p>中央面板上的<span class="bold"><strong>用户编辑器</strong></span>用于创建，查看，更新或删除用户。创建新用户或在用户浏览器中单击现有用户后，将打开用户编辑器屏幕。</p><p>要<span class="bold"><strong>查看现有用户</strong></span> ，请在“用户资源管理器”中单击现有用户以打开“用户编辑器”屏幕。例如，在使用Wildfly安全管理提供程序时查看<span class="italic">管理员</span>用户将在以下屏幕中显示：</p><div class="figure"><a id="d0e19944"></a><p class="title"><strong>图18.122。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/admin_user_view_wf.png"></div></div></div><br class="figure-break"><p>相同的管理员用户视图操作，但是在使用Keycloak安全管理提供程序而不是Wildfly的提供程序时，将在以下屏幕中显示：</p><div class="figure"><a id="d0e19950"></a><p class="title"><strong>图18.123。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/admin_user_view.png"></div></div></div><br class="figure-break"><p>请注意，使用Keycloak sec时，用户编辑器。管理提供程序，包括用户属性管理部分，但使用Wildfly的部分不存在。因此，请记住，用户界面上可用的信息和操作取决于每个提供程序的功能（如前几节所述）。</p><p>在用户编辑器中查看用户将提供以下信息（如果提供程序支持的话）：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>用户名</p></li><li class="listitem"><p>用户的属性</p></li><li class="listitem"><p>分配的组</p></li><li class="listitem"><p>分配的角色</p></li></ul></div><p>为了<span class="bold"><strong>更新或删除现有用户</strong></span> ，请在用户编辑器屏幕中单击用户名旁边的“ <span class="italic">编辑”</span>按钮：</p><div class="figure"><a id="d0e19979"></a><p class="title"><strong>图18.124。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/admin_user_edit.png"></div></div></div><br class="figure-break"><p>一旦用户编辑器以编辑方式显示，就可以执行不同的操作（如果使用的安全管理提供程序支持它）：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>更新用户的属性</strong></span></p><p>单击<span class="italic">添加到组</span>按钮时， <span class="italic">将</span>显示一个组选择弹出窗口：</p><div class="figure"><a id="d0e19995"></a><p class="title"><strong>图18.125。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/kc_user_attributes.png"></div></div></div><br class="figure-break"><p>该弹出屏幕允许用户搜索并选择或取消选择为当前正在编辑的用户分配的组。</p></li><li class="listitem"><p><span class="bold"><strong>更新分配的组</strong></span></p><p>单击<span class="italic">添加到组</span>按钮时， <span class="italic">将</span>显示一个组选择弹出窗口：</p><div class="figure"><a id="d0e20010"></a><p class="title"><strong>图18.126。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/groups_selection.png"></div></div></div><br class="figure-break"><p>该弹出屏幕允许用户搜索并选择或取消选择为当前正在编辑的用户分配的组。</p></li><li class="listitem"><p><span class="bold"><strong>更新分配的角色</strong></span></p><p>单击<span class="italic">添加到角色</span>按钮时， <span class="italic">将</span>显示一个角色选择弹出窗口：</p><div class="figure"><a id="d0e20025"></a><p class="title"><strong>图18.127。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/roles_selection.png"></div></div></div><br class="figure-break"><p>该弹出屏幕允许用户搜索和选择或取消选择为当前正在编辑的用户分配的角色。</p></li><li class="listitem"><p><span class="bold"><strong>修改用户密码</strong></span></p><p>单击<span class="italic">更改密码</span>按钮时，将<span class="italic">显示</span>一个更改密码弹出屏幕：</p><div class="figure"><a id="d0e20040"></a><p class="title"><strong>图18.128。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/change_password.png"></div></div></div><br class="figure-break"></li><li class="listitem"><p><span class="bold"><strong>删除用户</strong></span></p><p>单击“ <span class="italic">删除”</span>按钮可以将当前正在编辑的用户从领域中<span class="italic">删除</span> 。</p></li></ul></div></div><div class="section" title="18.8.4.2。集团管理"><div class="titlepage"><div><div><h4 class="title"><a id="d0e20053"></a> 18.8.4.2。集团管理</h4></div></div></div><p>可以从“ <span class="italic">主页”</span>菜单中的“ <span class="italic">组管理”</span>菜单项访问组管理界面。</p><p>该界面使用两个主面板显示：西面板上的分组浏览器和中间面板上的分组编辑器：</p><div class="figure"><a id="d0e20066"></a><p class="title"><strong>图18.129。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/group_management_perspective.png"></div></div></div><br class="figure-break"><p>西面板上的“ <span class="bold"><strong>组资源管理器”</strong></span>默认情况下列出了应用程序安全领域中存在的所有组：</p><div class="figure"><a id="d0e20075"></a><p class="title"><strong>图18.130。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/groups_explorer.png"></div></div></div><br class="figure-break"><p>除了列出所有组，组浏览器还允许：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>搜索组</strong></span></p><p>在搜索框中指定搜索模式时，用户列表将减少，并且将仅显示与搜索模式匹配的用户。</p><div class="figure"><a id="d0e20088"></a><p class="title"><strong>图18.131。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/groups_explorer_search.png"></div></div></div><br class="figure-break"><p>搜索模式取决于应用程序所使用的具体安全管理提供程序。请阅读每个<a class="link" href="https://github.com/uberfire/uberfire-extensions/tree/master/uberfire-security/uberfire-security-management">提供商的文档</a>以获取更多信息。</p></li><li class="listitem"><p><span class="bold"><strong>建立新群组</strong></span></p><p>通过单击<span class="italic">创建新组</span>按钮，中心面板上将显示一个新屏幕，以执行新组创建。创建新组后，便可以为其分配用户：</p><div class="figure"><a id="d0e20106"></a><p class="title"><strong>图18.132。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/new_group_assign_users.png"></div></div></div><br class="figure-break"></li></ul></div><p>中心面板上的<span class="bold"><strong>组编辑器</strong></span>用于创建，查看或删除组。创建新组后，在组浏览器中单击现有组，将打开组编辑器屏幕。</p><p>要<span class="bold"><strong>查看现有组</strong></span> ，请在“组资源管理器”中单击现有用户以打开“组编辑器”屏幕。例如，在以下屏幕上查看<span class="italic">销售</span>组结果：</p><div class="figure"><a id="d0e20123"></a><p class="title"><strong>图18.133。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/UserAndGroupManagement/group_view.png"></div></div></div><br class="figure-break"><p>要<span class="bold"><strong>删除现有组，</strong></span>只需单击“ <span class="italic">删除”</span>按钮。</p></div></strong></strong></div></div><div class="section" title="18.9。在您的应用程序中嵌入工作台"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.Embedding"></a> 18.9。在您的应用程序中嵌入工作台</strong></strong></h2></div></div></div><p><strong><strong>众所周知，Workbench提供了一组编辑器以不同格式创作资产。根据资产的格式，使用专门的编辑器。</strong></strong></p><p><strong><strong>Workbench提供的另一项功能是可以通过<span class="bold"><strong>独立</strong></span>模式将其嵌入到自己的（Web）应用程序中。因此，如果您想在自己的应用程序中编辑规则，流程，决策表等，而无需切换到工作台，则可以。</strong></strong></p><p><strong><strong>为了将Workbench嵌入到您的应用程序中，您所需要做的就是在Web /应用程序服务器中部署并运行该Workbench应用程序，并在您自己的Web应用程序中运行一个iframe，该iframe具有正确的HTTP查询参数，如下表所述。</strong></strong></p><div class="table"><strong><strong><a id="d0e20147"></a><p class="title"><strong>表18.2。独立模式的HTTP查询参数</strong></p><div class="table-contents"><table border="1" summary="HTTP query parameters for standalone mode"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">参数名称</th><th align="center">说明</th><th align="center">允许多个值</th><th align="center">例</th></tr></thead><tbody><tr><td align="center">独立的</td><td>仅存在此参数，工作台将切换到独立模式。</td><td align="center">没有</td><td>（没有）</td></tr><tr><td align="center">路径</td><td>要编辑的资产的路径。请注意，资产应该已经存在。</td><td align="center">没有</td><td>git：//master@uf-playground/todo.md</td></tr><tr><td align="center">透视</td><td>引用现有的透视图名称。</td><td align="center">没有</td><td>org.guvnor.m2repo.client.perspectives。GuvnorM2RepoPerspective</td></tr><tr><td align="center">标头</td><td>定义应显示的标题名称（对于上下文菜单标题有用）。</td><td align="center">是</td><td>补全导航区</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>Path和Perspective参数是互斥的，因此不能一起使用。</p></div></strong></strong></div><div class="section" title="18.10。资产管理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.AssetManagement"></a> 18.10。资产管理</strong></strong></h2></div></div></div><div class="section" title="18.10.1。资产管理概述"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtOverview"></a> 18.10.1。资产管理概述</strong></strong></h3></div></div></div><p><strong><strong>文档的此部分描述了主要功能，这些主要功能有助于KIE Workbench和KIE Drools Workbench中提供的资产管理功能。此处描述的所有功能都是完全可选的，但是如果您打算有多个项目，建议您使用此功能。所有资产管理功能都试图在存储库结构上施加良好做法，这将使维护，版本控制和发布项目变得简单且基于标准。所有资产管理功能都是使用jBPM业务流程实现的，这意味着该逻辑可以重新用于外部应用程序，并在需要时适用于特定于域的需求。
        </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>您必须为用户设置“ kiemgmt”角色才能使用资产管理功能</strong></strong></p></div></div><div class="section" title="18.10.2。托管与非托管存储库"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtManagedVsUnmanaged"></a> 18.10.2。托管与非托管存储库</strong></strong></h3></div></div></div><p><strong><strong>由于创建了资产管理功能库，因此可以将存储库分为“托管”或“非托管”两类。
      </strong></strong></p><div class="section" title="18.10.2.1。托管存储库"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtManagedRepositories"></a> 18.10.2.1。托管存储库</strong></strong></h4></div></div></div><p><strong><strong>此类型的存储库提供所有新的资产管理功能。另外，托管存储库可以是“单个项目”或“多个项目”。
        </strong></strong></p><p><strong><strong>一个“单个项目”托管的存储库将仅包含一个项目。一个“多项目”托管存储库可以包含多个项目。它们都通过同一个父对象关联，并且它们将共享相同的组和版本信息。
        </strong></strong></p></div><div class="section" title="18.10.2.2。非托管存储库"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtUnManagedRepositories"></a> 18.10.2.2。非托管存储库</strong></strong></h4></div></div></div><p><strong><strong>资产管理功能不适用于此类型或存储库，它们的行为基本上与使用先前工作台版本创建的存储库相同。</strong></strong></p></div></div><div class="section" title="18.10.3。资产管理流程"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtProcesses"></a> 18.10.3。资产管理流程</strong></strong></h3></div></div></div><p><strong><strong>有四个主要过程代表资产管理功能的各个阶段：配置存储库，促进更改，构建和发布。</strong></strong></p><div class="section" title="18.10.3.1。配置存储库"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtConfigureProcess"></a> 18.10.3.1。配置存储库</strong></strong></h4></div></div></div><p><strong><strong>配置存储库过程负责存储库的后初始化。如果用户选择在新存储库向导上创建托管存储库，则将自动触发此过程。如果他们决定使用管理功能，则该过程将在存储库创建后立即开始。将创建一个新的开发和发行分支。请注意，第一次调用此过程时，将选择master分支，并且两个分支（dev和release）都将基于它。
            </strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/asset-mgmt-create-repo.png"></strong></strong></div><p><strong><strong>默认情况下，资产管理功能未启用，因此请确保在“新存储库向导”上选择“托管存储库”。当我们在托管存储库中工作时，将选择开发分支供用户使用。如果创建了多个开发分支，则用户将需要选择一个。
            </strong></strong></p></div><div class="section" title="18.10.3.2。促进变革过程"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtPromoteProcess"></a> 18.10.3.2。促进变革过程</strong></strong></h4></div></div></div><p><strong><strong>当开发部门完成一些工作并且用户到达需要在生产之前测试变更的点时，他们将启动新的“促进变更”流程，以便技术性更高的用户可以决定和审查需要推广的内容。属于“ kiemgmt”组的用户将在其“组任务列表”中看到一个新任务，其中将包含所有已更改的文件。用户需要选择将通过UI进行宣传的资产。基本过程将挑选用户选择的发布到发布分支。用户可以指定更多技术用户需要审阅。
            </strong></strong></p><p><strong><strong>如果需要，可以在创建该发行版的工件之前重复多次此过程。
            </strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/asset-mgmt-promote.png"></strong></strong></div></div><div class="section" title="18.10.3.3。建立过程"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtBuildProcess"></a> 18.10.3.3。建立过程</strong></strong></h4></div></div></div><p><strong><strong>可以触发构建过程以从不同分支构建我们的项目。这使我们能够采用更灵活的方式来构建项目并将其部署到不同的运行时。
            </strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/asset-mgmt-build.png"></strong></strong></div><p><strong><strong>

            </strong></strong></p></div><div class="section" title="18.10.3.4。发布过程"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="wb.assetMgmtReleaseProcess"></a> 18.10.3.4。发布过程</strong></strong></h4></div></div></div><p><strong><strong>当用户确定是时候生成他/她正在从事的项目的发布时，就会触发发布过程。该过程将构建项目（称为Build Process），并将所有Maven工件更新到下一个版本。
            </strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/asset-mgmt-release.png"></strong></strong></div></div></div><div class="section" title="18.10.4。使用流程"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtUsageFlow"></a> 18.10.4。使用流程</strong></strong></h3></div></div></div><p><strong><strong>本节描述了资产管理功能的常用用法，显示了所有涉及的屏幕。
        </strong></strong></p><p><strong><strong>与资产管理功能的首次联系始于创建存储库。</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/new-repo-1page-wizzard.png"></strong></strong></div><p><strong><strong>如果用户选择创建托管存储库，则会在向导中启用新页面：</strong></strong></p><div class="mediaobject"><strong><strong><img src="images/Workbench/AssetManagement/new-repo-2page-wizzard.png"></strong></strong></div><p><strong><strong>创建托管存储库后，资产管理配置过程将自动启动，以创建存储库分支，并且还将创建相应的项目结构。</strong></strong></p></div><div class="section" title="18.10.5。储存库结构"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtRepositoryStructure"></a> 18.10.5。储存库结构</strong></strong></h3></div></div></div><p><strong><strong>创建存储库后，即可通过“存储库结构”屏幕进行管理。</strong></strong></p><p><strong><strong>要打开给定存储库的存储库结构屏幕，请打开Project Authoring Perspective，浏览到给定存储库，然后选择“存储库->存储库结构”菜单选项。</strong></strong></p><div class="figure"><strong><strong><a id="d0e20296"></a><p class="title"><strong>图18.134。仓库结构菜单</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-menu.png" alt="仓库结构菜单"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="18.10.5.1。单个项目托管存储库"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtRepositoryStructureManagedSingle"></a> 18.10.5.1。单个项目托管存储库</h4></div></div></div><p>下图显示了单个项目管理的存储库结构的示例。</p><div class="figure"><a id="d0e20307"></a><p class="title"><strong>图18.135。单个项目托管存储库</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-managed-single.png" alt="单个项目托管存储库"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.5.2。多项目托管存储库"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtRepositoryStructureManagedMulti"></a> 18.10.5.2。多项目托管存储库</h4></div></div></div><p>下图显示了一个多项目托管存储库结构的示例。</p><div class="figure"><a id="d0e20318"></a><p class="title"><strong>图18.136。多项目托管存储库</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-managed-multi.png" alt="多项目托管存储库"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.5.3。非托管存储库"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtRepositoryStructureUnmanaged"></a> 18.10.5.3。非托管存储库</h4></div></div></div><p>下图显示了非托管存储库结构的示例。</p><div class="figure"><a id="d0e20329"></a><p class="title"><strong>图18.137。非托管存储库</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-unmanaged.png" alt="非托管存储库"></div></div></div><br class="figure-break"></div></strong></strong></div><div class="section" title="18.10.6。托管存储库操作"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.assetMgmtManagedRepositoryOperations"></a> 18.10.6。托管存储库操作</strong></strong></h3></div></div></div><p><strong><strong>下图显示了与托管存储库操作相关的屏幕区域。</strong></strong></p><div class="figure"><strong><strong><a id="d0e20340"></a><p class="title"><strong>图18.138。托管存储库操作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-areas.png" alt="托管存储库操作"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="18.10.6.1。分支选择器"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtManagedRepositoryOperationsBranchSelector"></a> 18.10.6.1。分支选择器</h4></div></div></div><p>分支选择器允许您在配置存储库过程创建的不同分支之间进行切换。</p><div class="figure"><a id="d0e20351"></a><p class="title"><strong>图18.139。分支选择器</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-branch-selector.png" alt="分支选择器"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.6.2。项目运作"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtManagedRepositoryAddProjectEditDelete"></a> 18.10.6.2。项目运作</h4></div></div></div><p>在存储库结构屏幕上，还可以从当前存储库创建，编辑或删除项目。</p><div class="figure"><a id="d0e20362"></a><p class="title"><strong>图18.140。将项目添加到当前结构</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-add-project.png" alt="将项目添加到当前结构"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e20368"></a><p class="title"><strong>图18.141。从当前结构编辑/删除项目</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-edit-delete-project.png" alt="从当前结构编辑/删除项目"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.6.3。启动资产管理流程"><div class="titlepage"><div><div><h4 class="title"><a id="wb.assetMgmtManagedRepositoryCallProcess"></a> 18.10.6.3。启动资产管理流程</h4></div></div></div><p>资产管理过程也可以从“项目结构”屏幕中启动。</p><div class="figure"><a id="d0e20379"></a><p class="title"><strong>图18.142。启动资产管理流程</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-lauch-processes.png" alt="启动资产管理流程"></div></div></div><br class="figure-break"><div class="section" title="18.10.6.3.1。启动配置存储库过程"><div class="titlepage"><div><div><h5 class="title"><a id="wb.assetMgmtManagedRepositoryCallConfigureProcess"></a> 18.10.6.3.1。启动配置存储库过程</h5></div></div></div><p>在下面填充参数可以启动配置存储库的新实例。 （请参阅配置存储库过程）</p><div class="figure"><a id="d0e20390"></a><p class="title"><strong>图18.143。配置存储库过程参数</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-launch-configure-process.png" alt="配置存储库过程参数"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.6.3.2。启动促进变更过程"><div class="titlepage"><div><div><h5 class="title"><a id="wb.assetMgmtManagedRepositoryCallPromoteProcess"></a> 18.10.6.3.2。启动促进变更过程</h5></div></div></div><p>在下面填充参数可以启动“促进更改过程”的新实例。 （请参阅促进更改过程）</p><div class="figure"><a id="d0e20401"></a><p class="title"><strong>图18.144。促进变更过程参数</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-launch-promote-changes-process.png" alt="促进变更过程参数"></div></div></div><br class="figure-break"></div><div class="section" title="18.10.6.3.3。启动发布过程"><div class="titlepage"><div><div><h5 class="title"><a id="wb.assetMgmtManagedRepositoryCallReleaseProcess"></a> 18.10.6.3.3。启动发布过程</h5></div></div></div><p>在下面填充参数可以启动“释放过程”的新实例。 （请参阅发布过程）</p><div class="figure"><a id="d0e20412"></a><p class="title"><strong>图18.145。发布过程参数</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/AssetManagement/repo-structure-screen-operation-launch-release-process.png" alt="发布过程参数"></div></div></div><br class="figure-break"></div></div></strong></strong></div></div><div class="section" title="18.11。执行服务器管理UI"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.ExecServerUI"></a> 18.11。执行服务器管理UI</strong></strong></h2></div></div></div><p><strong><strong>执行服务器管理UI允许用户创建和修改服务器模板和容器，还允许用户管理远程服务器。该屏幕可通过Deploy-> Rule Deployments菜单获得。
  </strong></strong></p><div class="figure"><strong><strong><a id="d0e20423"></a><p class="title"><strong>图18.146。执行服务器管理</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/NewExecServerUI.png" alt="执行服务器管理"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>管理UI仅适用于KIE受管服务器。</p></div><div class="section" title="18.11.1。服务器模板"><div class="titlepage"><div><div><h3 class="title"><a id="wb.ExecServerUITemplate"></a> 18.11.1。服务器模板</h3></div></div></div><p>服务器模板用于定义可用于多个服务器的通用配置，因此名称为：模板。</p><p>服务器模板可以直接从管理UI创建，也可以在服务器连接到控制器并且该远程服务器没有模板定义时自动创建。服务器模板可能具有一个或多个功能，这些功能无法修改，如果您需要修改功能，则必须创建一个新模板。这是当前功能的列表：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>规则（流口水）</p></li><li class="listitem"><p>流程（jBPM）</p></li><li class="listitem"><p>规划（Optaplanner）</p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>对于Planner功能，也必须启用Rule的功能。</p></div><p>为了创建新的服务器模板，您必须单击“新建服务器模板”按钮，然后按照向导进行操作。也可以在向导中创建一个容器，但是现在我们只限于模板。
    </p><div class="figure"><a id="d0e20454"></a><p class="title"><strong>图18.147。新服务器模板向导</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/NewServerTemplateWizard.png" alt="新服务器模板向导"></div></div></div><br class="figure-break"><p>创建后，您将在左侧列出新模板，突出显示新服务器模板。在右侧，您将获得第二级导航，该导航列出了与所选服务器模板相关的容器和远程服务器。
    </p><div class="figure"><a id="d0e20462"></a><p class="title"><strong>图18.148。服务器模板</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ServerTemplates.png" alt="服务器模板"></div></div></div><br class="figure-break"><p>在导航的顶部还可以删除当前的服务器模板或创建其副本。
    </p><div class="figure"><a id="d0e20470"></a><p class="title"><strong>图18.149。服务器模板动作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ServerTemplateActions.png" alt="服务器模板动作"></div></div></div><br class="figure-break"></div><div class="section" title="18.11.2。容器"><div class="titlepage"><div><div><h3 class="title"><a id="wb.ExecServerUIContainer"></a> 18.11.2。容器</h3></div></div></div><p>容器是服务器模板的KIE容器配置。单击添加容器按钮为当前服务器模板创建一个新容器。
    </p><p>搜索区域可以帮助用户找到他们要查找的特定KJAR。</p><div class="figure"><a id="d0e20483"></a><p class="title"><strong>图18.150。新容器向导</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/NewContainerWizard.png" alt="新容器向导"></div></div></div><br class="figure-break"><p>对于启用了“过程”功能的服务器模板，向导具有第二个可选步骤，用户可以在其中配置一些与过程相关的行为。
    </p><div class="figure"><a id="d0e20491"></a><p class="title"><strong>图18.151。工艺配置</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ProcessConfigNewContainerWizard.png" alt="工艺配置"></div></div></div><br class="figure-break"><p>创建新容器后，新容器将显示在远程服务器列表上方的容器列表中。刚创建完容器后，默认情况下为“已停止”，这是允许用户删除容器的唯一状态。
    </p><div class="figure"><a id="d0e20499"></a><p class="title"><strong>图18.152。容器</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/Container.png" alt="容器"></div></div></div><br class="figure-break"><p>容器具有以下选项卡可用于管理和/或配置：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>状态</p></li><li class="listitem"><p>版本配置</p></li><li class="listitem"><p>工艺配置</p></li></ul></div><p>“状态”选项卡列出了所有正在运行活动容器的远程服务器。每个远程服务器都呈现为卡，向用户显示状态和终结点。
    </p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>只有启动的容器才部署到远程服务器。</p></div><div class="figure"><a id="d0e20522"></a><p class="title"><strong>图18.153。状态容器</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ContainerStatus.png" alt="状态容器"></div></div></div><br class="figure-break"><p>版本配置选项卡允许用户更改容器的当前版本。用户可以使用“升级”按钮手动升级到特定版本，或启用/禁用扫描仪。也可以执行ScanNow操作，该操作仅扫描一次新版本。
    </p><div class="figure"><a id="d0e20530"></a><p class="title"><strong>图18.154。版本配置</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ContainerVersionConfiguration.png" alt="版本配置"></div></div></div><br class="figure-break"><p>进程配置与具有进程功能的模板服务器的新建容器向导中显示的表单相同。如果Template Server不具备此功能，则将禁用操作按钮。
    </p><div class="figure"><a id="d0e20538"></a><p class="title"><strong>图18.155。工艺配置</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/ContainerProcessConfiguration.png" alt="工艺配置"></div></div></div><br class="figure-break"></div><div class="section" title="18.11.3。远端伺服器"><div class="titlepage"><div><div><h3 class="title"><a id="wb.ExecServerUIRemoteServer"></a> 18.11.3。远端伺服器</h3></div></div></div><p>远程服务器是正在运行的托管KIE Server实例，已配置了控制器。
    </p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>默认情况下，Workbench内置有Controller。</p></div><p>远程服务器列表显示在容器列表的正下方。选择后，屏幕将显示“远程服务器”详细信息和卡列表，每个卡代表一个正在运行的容器。
    </p><div class="figure"><a id="d0e20554"></a><p class="title"><strong>图18.156。远端伺服器</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/ExecServer/RemoteServers.png" alt="远端伺服器"></div></div></div><br class="figure-break"></div></strong></strong></div></div><div class="chapter" title="第十九章创作规则资产"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.AuthoringAssets"></a>第十九章创作规则资产</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#drools.NewPackage">19.1。创建一个包</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e20580">19.1.1。空包装</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e20599">19.1.2。复制，重命名和删除软件包</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditor">19.2。指导编辑的业务规则</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorParts">19.2.1。指导规则编辑器的部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorLHS">19.2.2。规则的“何时”（左侧）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorRHS">19.2.3。规则的“ THEN”（右侧）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorOptionalAttributes">19.2.4。可选属性</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorToolbar">19.2.5。模式/动作工具栏</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorEnumerations">19.2.6。用户驱动的下拉列表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorDSL">19.2.7。DSL句子增强</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleEditorComplexExample">19.2.8。一个更复杂的示例：</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditor">19.3。资产/规则模板</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorCreating">19.3.1。创建规则模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefining">19.3.2。定义模板</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorDefiningData">19.3.3。定义模板数据</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedRuleTemplateEditorGeneratedDRL">19.3.4。生成的DRL</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditor">19.4。指导决策表（基于Web）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorTypesOfDecisionTable">19.4.1。决策表类型</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorConcepts">19.4.2。主要组成部分\概念</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorDefining">19.4.3。定义基于Web的决策表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorRuleDefinitions">19.4.4。规则定义</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorAuditLog">19.4.5。审核日志</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTableEditorVerification">19.4.6。实时验证与确认</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.GuidedDecisionTreeEditor">19.5。指导决策树</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e21644">19.5.1。初始编辑器布局</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21692">19.5.2。第一步</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21730">19.5.3。编辑数据对象节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21743">19.5.4。编辑字段约束节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21756">19.5.5。编辑动作节点</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e21789">19.5.6。管理树</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.XLSDecisionTable">19.6。电子表格决策表</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditor">19.7。计分卡</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditorSetupParameters">19.7.1。 （a）设定参数</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.GuidedScoreCardEditorCharacteristics">19.7.2。 （b）特征</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditor">19.8。测试场景</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.KSessionSelector">19.8.1。知识会议选择器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorGivenSection">19.8.2。给定部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorExpectedSection">19.8.3。期望部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorGlobalSection">19.8.4。全球部分</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.TestScenarioEditorInpuotSection">19.8.5。新输入部分</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.FunctionEditor">19.9。功能</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.DSLEditor">19.10。DSL编辑器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#drools.EnumerationEditor">19.11。数据枚举（下拉列表配置）</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#drools.AdvancedEnumConcepts">19.11.1。高级枚举概念</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#drools.DRLEditor">19.12。技术规则（DRL）</a></span></strong></strong></dt></dl></div><div class="section" title="19.1。创建一个包"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.NewPackage"></a> 19.1。创建一个包</strong></strong></h2></div></div></div><p><strong><strong>配置软件包通常是一次完成的工作，并且只有具有一定规则/模型经验的人才能完成。一般而言，很少有人需要配置软件包，并且一旦安装，便可以根据需要一遍又一遍地复制它们。软件包配置绝对是一项需要适当专业知识的技术任务。</strong></strong></p><p><strong><strong>所有资产都存在于Drools Workbench的“程序包”中-程序包就像一个文件夹（它也用作“命名空间”）。用于存放规则资产的主文件夹。规则尤其需要知道事实模型是什么，名称空间是什么等。</strong></strong></p><p><strong><strong>因此，尽管规则（通常是资产）可以出现在任意多个类别中，但它们仅存在于一个程序包中。如果您将Drools Workbench视为文件系统，则每个软件包都是一个文件夹，资产位于该文件夹中-作为文件的一大快乐清单。</strong></strong></p><p><strong><strong>要创建一个空包装，请从“新建项目”菜单中选择“包装”。</strong></strong></p><div class="figure"><strong><strong><a id="d0e20574"></a><p class="title"><strong>图19.1。新包装</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/newItemMenu.png" align="middle" alt="新包装"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="19.1.1。空包装"><div class="titlepage"><div><div><h3 class="title"><a id="d0e20580"></a> 19.1.1。空包装</h3></div></div></div><p>只需指定名称即可创建一个空包。</p><div class="figure"><a id="d0e20585"></a><p class="title"><strong>图19.2。新的空包</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/newItem-package.png" align="middle" alt="新的空包"></div></div></div><br class="figure-break"><p>创建包后，它将出现在项目资源管理器中。</p><div class="figure"><a id="d0e20593"></a><p class="title"><strong>图19.3。项目浏览器显示新软件包</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/newItem-package-project-explorer.png" align="middle" alt="项目浏览器显示新软件包"></div></div></div><br class="figure-break"></div><div class="section" title="19.1.2。复制，重命名和删除软件包"><div class="titlepage"><div><div><h3 class="title"><a id="d0e20599"></a> 19.1.2。复制，重命名和删除软件包</h3></div></div></div><p>如“ <a class="link" href="#wb.ProjectExplorerCopyRenameDeleteActions" title="18.7.4.6。复制，重命名，删除和下载操作">项目资源管理器”</a>部分所述，用户可以直接从“项目资源管理器”中复制，重命名或删除包。</p><p>如下面的屏幕快照所示，这些操作的行为与大多数工作台编辑器中的对应部件动作非常相似。</p><div class="figure"><a id="d0e20609"></a><p class="title"><strong>图19.4。复制包裹</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/package-copy.png" align="middle" alt="复制包裹"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e20615"></a><p class="title"><strong>图19.5。重命名程序包</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/package-rename.png" align="middle" alt="重命名程序包"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e20621"></a><p class="title"><strong>图19.6。不含包装</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/package-delete.png" align="middle" alt="不含包装"></div></div></div><br class="figure-break"></div></strong></strong></div><div class="section" title="19.2。指导编辑的业务规则"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.GuidedRuleEditor"></a> 19.2。指导编辑的业务规则</strong></strong></h2></div></div></div><p><strong><strong>使用用户界面编写了指导规则，以基于对象模型的知识来控制和提示用户输入。</strong></strong></p><p><strong><strong>这也可以通过DSL语句来增强。</strong></strong></p><div class="section" title="19.2.1。指导规则编辑器的部分"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorParts"></a> 19.2.1。指导规则编辑器的部分</strong></strong></h3></div></div></div><p><strong><strong>指导规则编辑器由三个主要部分组成。</strong></strong></p><p><strong><strong>下图显示了运行中的编辑器。以下说明适用于图中的字母框：-</strong></strong></p><div class="figure"><strong><strong><a id="d0e20641"></a><p class="title"><strong>图19.7。指导性BRL编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedEditor-overview.png" align="middle" alt="指导性BRL编辑器"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>答：规则的不同部分：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>规则的“何时”部分或条件。</p></li><li class="listitem"><p>规则的“ THEN”动作部分。</p></li><li class="listitem"><p>可能影响规则操作的可选属性。</p></li></ul></div></strong></strong></div><div class="section" title="19.2.2。的" whe="=" =""><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorLHS"></a> 19.2.2。规则的“何时”（左侧）</strong></strong></h3></div></div></div><p><strong><strong>B：这显示了一种模式，该模式声明该规则正在寻找“ LoanApplication”事实（以下列出了字段，在这种情况下，没有列出）。“贷款申请”下面列出了另一种模式“申请人”。列出了字段“ creditRating”和“ applicationDate”。单击事实名称（“ LoanApplication”）将弹出一个选项列表，以添加到事实声明中：-</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>添加更多字段（例如其“位置”）。</strong></strong></p></li><li class="listitem"><p><strong><strong>为事实分配一个变量名（如果需要，可以稍后使用）</strong></strong></p></li><li class="listitem"><p><strong><strong>添加“多字段”约束-即跨字段的约束（例如，年龄> 42或风险> 2）。</strong></strong></p></li></ul></div><p><strong><strong>C：“减号”图标（“ [-]”）表示您可以删除某些内容。在这种情况下，它将删除整个“ LoanApplication”事实声明。根据图标的位置，可以删除规则声明的不同部分，例如事实模式，字段约束，其他条件元素（“存在”，“不存在”，“来自”等）或动作。</strong></strong></p><p><strong><strong>D：“加号”图标（“ +”）允许您将更多模式添加到规则的条件或操作部分，或更多属性。在所有情况下，都会提供一个弹出选项框。对于规则的“何时”部分，您可以从条件元素列表中进行选择以添加：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>事实约束：它将为您提供事实清单。</strong></strong></p></li><li class="listitem"><p><strong><strong>“以下不存在”：事实加约束必须不存在。</strong></strong></p></li><li class="listitem"><p><strong><strong>“以下内容存在”：至少应存在一个匹配项（但只需存在一个-不会为每个匹配项触发）。</strong></strong></p></li><li class="listitem"><p><strong><strong>“以下任何一项均成立”：任何模式都可以匹配（然后将模式添加到这些更高级别的模式）。</strong></strong></p></li><li class="listitem"><p><strong><strong>“发件人”：这会将新的“发条条件元素”插入规则。</strong></strong></p></li><li class="listitem"><p><strong><strong>“从累积”：将向规则插入新的累积条件元素。</strong></strong></p></li><li class="listitem"><p><strong><strong>“来自收集”：这将在规则中插入新的收集条件元素。</strong></strong></p></li><li class="listitem"><p><strong><strong>“从入口点”：这允许您定义模式的入口点。</strong></strong></p></li><li class="listitem"><p><strong><strong>“自由格式DRL”：这将使您插入免费的DRL块。</strong></strong></p></li></ul></div><p><strong><strong>如果您只是提出一个事实（如上图所示），那么所有模式都将组合在一起，因此它们都是真实的（“和”）。</strong></strong></p><p><strong><strong>E：这显示了“ creditRating”字段的约束。从左向右看，您会发现：-</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字段名称：“ creditRating”。单击它可以为其分配变量名称，或访问其嵌套属性。</strong></strong></p></li><li class="listitem"><p><strong><strong>约束操作列表（已选择“等于”）：此列表的内容根据字段的数据类型而变化。</strong></strong></p></li><li class="listitem"><p><strong><strong>值字段：可以是以下之一：-</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字符串->文本框</strong></strong></p></li><li class="listitem"><p><strong><strong>任何数值->文本框都将输入限制为对数字子类型有效的值（例如，字节可以容纳-128到127的值）。还支持BigDecimal和BigInteger数据类型。请确保在“包”配置中导入了适当的类。如果上载的POJO模型公开了BigDecimal或BigInteger字段的访问器或更改器，则将自动添加导入。BigDecimal值会自动加上“ B”后缀，从而向基础引擎指示应将字面值解释为BigDecimal。BigIntegers的后缀为“ I”。用户不需要输入后缀。</strong></strong></p></li><li class="listitem"><p><strong><strong>日期->日历</strong></strong></p></li><li class="listitem"><p><strong><strong>枚举->列表框</strong></strong></p></li><li class="listitem"><p><strong><strong>布尔->复选框</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li><li class="listitem"><p><strong><strong>表达式-使用表达式生成器可以构建完整的mvel表达式。（目前仅支持基本表达式）</strong></strong></p></li></ol></div></li></ul></div><p><strong><strong>F：这显示了“ applicationDate”字段的约束。从左向右看，您会发现：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字段名称：“ applicationDate”。</strong></strong></p></li><li class="listitem"><p><strong><strong>约束操作列表：已选择“之后”。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“时钟”图标。由于“ applicationDate”是日期数据类型，因此可用运算符的列表包括与复杂事件处理（CEP）有关的运算符。当使用CEP操作员时，将显示此附加图标，使您可以输入其他CEP操作员参数。单击“时钟”将循环显示CEP操作员参数的可用组合。</strong></strong></p></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>当事实被声明为事件时，复杂事件处理运算符也可用。有关如何向事实模型添加注释的详细信息，请参阅本用户指南的“事实模型”一章。活动可以访问所有CEP运营商；日期字段类型仅限于“之后”，“之前”和“符合”。</strong></strong></p></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>注释为事件的事实也可以定义CEP滑动窗口。</strong></strong></p></div><div class="section" title="19.2.2.1。添加图案"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedRuleEditorAddingPatterns"></a> 19.2.2.1。添加图案</strong></strong></h4></div></div></div><p><strong><strong>单击“时间”部分的+按钮时，将出现一个新的弹出窗口，可让您向规则添加新的模式。弹出窗口将类似于下图。在此弹出窗口中，您可以通过选择列表项之一来选择要添加的图案类型。在列表中，除了已经提到的条件元素（例如“存在”，“不存在”，“来自”，“收集”，“累积”，“来自条目-点”和“自由格式DRL”。选择这些元素之一后，可以通过单击“确定”按钮添加新的图案。新模式将添加到规则左侧的底部。如果要选择其他位置，可以使用位于弹出窗口顶部的组合框。</strong></strong></p><p><strong><strong>您也可以通过单击阵列的动作工具栏中的[+]按钮来打开此弹出窗口。在这种情况下，出现的弹出窗口将不会限制位置组合框，因为新的模板将在您单击的模板之后添加。</strong></strong></p><div class="figure"><strong><strong><a id="d0e20770"></a><p class="title"><strong>图19.8。添加图案</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedLHSPatterns.png" align="middle" alt="添加图案"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.2.2.2。增加约束"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedRuleEditorAddingConstraints"></a> 19.2.2.2。增加约束</strong></strong></h4></div></div></div><p><strong><strong>下面的对话框是您要向事实添加约束时将看到的内容。上半部分是简单的选项：您可以立即添加字段约束（将显示适用事实的字段列表），也可以使用AND或OR操作数添加“多个字段约束”。在窗口的下半部分，您可以使用“高级”选项：您可以添加一个公式（解析为True或False-类似于上面的示例：“ ...薪金>（2500 * 4.1）”。您还可以为事实分配一个变量名称（这意味着您可以随后在规则的操作部分访问该变量，以设置值等）。</strong></strong></p><div class="figure"><strong><strong><a id="d0e20781"></a><p class="title"><strong>图19.9。增加约束</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedLHSConstraints.png" align="middle" alt="增加约束"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="19.2.3。的" the="=" =""><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorRHS"></a> 19.2.3。规则的“ THEN”（右侧）</strong></strong></h3></div></div></div><p><strong><strong>H：这表示规则的“动作”，规则的右侧包含动作列表。在这种情况下，我们将更新“ LoanApplication”事实的“说明”字段。您可以使用许多其他类型的动作：-</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>插入一个全新的事实，并选择在事实上设置一个字段。</strong></strong></p><p><strong><strong>值字段可以是以下之一：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字符串->文本框</strong></strong></p></li><li class="listitem"><p><strong><strong>任何数值->文本框都将输入限制为对数字子类型有效的值（例如，字节可以容纳-128到127的值）。还支持BigDecimal和BigInteger数据类型。请确保在“包”配置中导入了适当的类。如果上载的POJO模型公开了BigDecimal或BigInteger字段的访问器或更改器，则将自动添加导入。BigDecimal值会自动加上“ B”后缀，从而向基础引擎指示应将字面值解释为BigDecimal。BigIntegers的后缀为“ I”。用户不需要输入后缀。</strong></strong></p></li><li class="listitem"><p><strong><strong>日期->日历</strong></strong></p></li><li class="listitem"><p><strong><strong>枚举->列表框</strong></strong></p></li><li class="listitem"><p><strong><strong>布尔->复选框</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>绑定到事实或字段左侧的变量。要设置的字段的数据类型必须与变量的数据类型匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>逻辑上插入一个全新的事实（请参阅专家文档中的“真相维护”），并可以选择在事实上设置一个字段。</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><p><strong><strong>值字段可以是以下之一：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字符串->文本框</strong></strong></p></li><li class="listitem"><p><strong><strong>任何数值->文本框都将输入限制为对数字子类型有效的值（例如，字节可以容纳-128到127的值）。还支持BigDecimal和BigInteger数据类型。请确保在“包”配置中导入了适当的类。如果上载的POJO模型公开了BigDecimal或BigInteger字段的访问器或更改器，则将自动添加导入。BigDecimal值会自动加上“ B”后缀，从而向基础引擎指示应将字面值解释为BigDecimal。BigIntegers的后缀为“ I”。用户不需要输入后缀。</strong></strong></p></li><li class="listitem"><p><strong><strong>日期->日历</strong></strong></p></li><li class="listitem"><p><strong><strong>枚举->列表框</strong></strong></p></li><li class="listitem"><p><strong><strong>布尔->复选框</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>绑定到事实或字段左侧的变量。要设置的字段的数据类型必须与变量的数据类型匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>绑定到事实或字段左侧的变量。要设置的字段的数据类型必须与变量的数据类型匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>修改现有事实的字段（告诉引擎事实已更改）。</strong></strong></p><p><strong><strong>值字段可以是以下之一：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字符串->文本框</strong></strong></p></li><li class="listitem"><p><strong><strong>任何数值->文本框都将输入限制为对数字子类型有效的值（例如，字节可以容纳-128到127的值）。还支持BigDecimal和BigInteger数据类型。请确保在“包”配置中导入了适当的类。如果上载的POJO模型公开了BigDecimal或BigInteger字段的访问器或更改器，则将自动添加导入。BigDecimal值会自动加上“ B”后缀，从而向基础引擎指示应将字面值解释为BigDecimal。BigIntegers的后缀为“ I”。用户不需要输入后缀。</strong></strong></p></li><li class="listitem"><p><strong><strong>日期->日历</strong></strong></p></li><li class="listitem"><p><strong><strong>枚举->列表框</strong></strong></p></li><li class="listitem"><p><strong><strong>布尔->复选框</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>绑定到事实或字段左侧的变量。要设置的字段的数据类型必须与变量的数据类型匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>在事实上设置一个字段（在这种情况下，引擎不知道更改-通常是因为您要设置结果）。</strong></strong></p><p><strong><strong>值字段可以是以下之一：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>文字值：根据字段的数据类型，将显示不同的组件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>字符串->文本框</strong></strong></p></li><li class="listitem"><p><strong><strong>任何数值->文本框都将输入限制为对数字子类型有效的值（例如，字节可以容纳-128到127的值）。还支持BigDecimal和BigInteger数据类型。请确保在“包”配置中导入了适当的类。如果上载的POJO模型公开了BigDecimal或BigInteger字段的访问器或更改器，则将自动添加导入。BigDecimal值会自动加上“ B”后缀，从而向基础引擎指示应将字面值解释为BigDecimal。BigIntegers的后缀为“ I”。用户不需要输入后缀。</strong></strong></p></li><li class="listitem"><p><strong><strong>日期->日历</strong></strong></p></li><li class="listitem"><p><strong><strong>枚举->列表框</strong></strong></p></li><li class="listitem"><p><strong><strong>布尔->复选框</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>绑定到事实或字段左侧的变量。要设置的字段的数据类型必须与变量的数据类型匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>一个“公式”：这是一个经过计算的表达式（仅适用于高级用户）</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>从引擎的工作记忆中删除一个事实。</strong></strong></p></li><li class="listitem"><p><strong><strong>将事实添加到现有的全局列表中。</strong></strong></p></li><li class="listitem"><p><strong><strong>在变量上调用方法。</strong></strong></p></li><li class="listitem"><p><strong><strong>编写一段自由格式的代码。</strong></strong></p></li></ul></div></div><div class="section" title="19.2.4。可选属性"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorOptionalAttributes"></a> 19.2.4。可选属性</strong></strong></h3></div></div></div><p><strong><strong>规则的属性部分提供了定义元数据和属性（例如“显着性”，“无循环”等）的方法。</strong></strong></p><p><strong><strong>单击“ +”图标以添加新的元数据或属性定义。每个定义都将出现在本节中列出。</strong></strong></p><p><strong><strong>单击每个元数据或属性旁边的“-”图标以将其删除。</strong></strong></p><div class="section" title="19.2.4.1。显着性"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedRuleEditorOptionalAttributesSalience"></a> 19.2.4.1。显着性</strong></strong></h4></div></div></div><p><strong><strong>每个规则都有一个显着值，它是一个默认为零的整数值。显着性值表示规则的优先级，较高的显着性值表示较高的优先级。显着性值可以为正或负。
		</strong></strong></p></div></div><div class="section" title="19.2.5。模式/动作工具栏"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorToolbar"></a> 19.2.5。模式/动作工具栏</strong></strong></h3></div></div></div><p><strong><strong>G：在每个图案或动作旁边，您会发现一个包含3个按钮的工具栏。</strong></strong></p><p><strong><strong>第一个“ +”图标可让您在任意位置插入新的图案/动作。其他“ +”图标使您可以在所选的下方插入新的图案/动作。</strong></strong></p><p><strong><strong>其余的箭头图标允许您向上或向下移动当前的图案/动作。</strong></strong></p></div><div class="section" title="19.2.6。用户驱动的下拉列表"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorEnumerations"></a> 19.2.6。用户驱动的下拉列表</strong></strong></h3></div></div></div><div class="figure"><strong><strong><a id="d0e20965"></a><p class="title"><strong>图19.10。数据枚举显示为下拉列表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/EnumDropDown.png" align="middle" alt="数据枚举显示为下拉列表"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>请注意，可以将字段值限制为预配置列表中的项目。该列表可以由Java枚举定义，也可以配置为包的一部分（使用数据枚举为下拉列表提供值）。这些值可以是固定列表，也可以是（例如）从数据库加载的值。这对于代码以及具有设置值的其他字段很有用。还可以在屏幕上的下拉菜单中显示与规则中使用的值（或代码）不同的内容。请参阅有关数据枚举的部分以了解如何配置它们。</p><p>可以在同一事实中定义一个字段的值列表，该列表取决于一个或多个其他字段的值（例如，取决于所选“国家/地区”的“城市”列表）。请参考“枚举”部分以获取更多信息。</p></strong></strong></div><div class="section" title="19.2.7。DSL句子增强"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorDSL"></a> 19.2.7。DSL句子增强</strong></strong></h3></div></div></div><p><strong><strong>如果规则所在的程序包具有DSL配置，则在添加条件或操作时，它将提供“ DSL语句”列表，您可以从中选择-当您选择一个规则包时，它将在规则中添加一行-如果DSL指定值来自用户，则将显示一个编辑框（文本）（因此最终看起来有点像表单）。这是可选的，并且还有另一个DSL编辑器。请注意，此编辑器中的DSL功能比全套DSL功能略少（基本上，您只能执行DSL的[when]和[then]部分，这与实际的Drool 3没有区别）。</strong></strong></p><p><strong><strong>下图显示了指导编辑器中正在运行的DSL句子：</strong></strong></p><div class="figure"><strong><strong><a id="d0e20982"></a><p class="title"><strong>图19.11。DSL在向导式编辑器中</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDSL.png" align="middle" alt="DSL在向导式编辑器中"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.2.8。一个更复杂的示例："><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleEditorComplexExample"></a> 19.2.8。一个更复杂的示例：</strong></strong></h3></div></div></div><div class="figure"><strong><strong><a id="d0e20991"></a><p class="title"><strong>图19.12。一个更复杂的BRL示例</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedComplex.png" align="middle" alt="一个更复杂的BRL示例"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>在上面的示例中，您可以看到如何混合使用条件元素，文字值和公式。该规则具有4个“顶层”模式和1个操作。“顶级”模式是：</p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem"><p>关于人的事实模式。此模式包含两个字段约束：一个约束是birthDate字段，另一个约束是公式。请注意，birthDate限制的值是从日历中选择的。要注意的另一件事是，您可以进行计算并在公式限制中使用嵌套字段（即car.brand）。最后，我们将变量名称（$ p）设置为“人员事实类型”。然后，您可以在其他模式中使用此变量。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>从该模式生成的DRL将为：</p><pre><code class="no-highlight">$p : Person( birthDate &lt; "19-Dec-1982" , eval( car.brand == "Ford" &amp;&amp; salary &gt; (2500 * 4.1) ))</code></pre></div></li><li class="listitem"><p>A从模式。此条件将为街道名称为“ Elm St.”的每个地址创建一个匹配项。从此人的地址列表中。from的左侧是常规的事实模式，右侧是Expression Builder，可让我们检查变量的字段。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>从该模式生成的DRL将为：<code class="code">Address( street == "Elm St." ) from $p.addresses</code></p></div></li><li class="listitem"><p>“不存在”条件元素。当其内容未创建匹配项时，此条件将匹配。在这种情况下，其内容是常规的事实模式（基于人员）。在此事实模式中，您可以看到如何在公式值内使用变量（$ p）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>从该模式生成的DRL将为：<code class="code">not Person( salary == ( $p.salary * 2 ) )</code></p></div></li><li class="listitem"><p>“从累积”条件元素。这可能是您可以使用的最复杂的模式之一。它由左模式组成（必须是事实模式。在这种情况下是数字模式。该数字名为$ totalAddresses），一个源模式（可以是事实模式，来自，收集或累积条件元素）。在这种情况下，地址格式限制在其zip字段中具有字段限制）和公式部分，您可以在其中使用任何内置或自定义的累积功能（在此示例中，使用count（）函数）。基本上，此条件元素将从“人”的地址列表中计算邮政编码为43240的地址。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>从该模式生成的DRL将为：<code class="code">$totalAddresses : Number() from accumulate ($a : Address( zipCode == " 43240") from $p.addresses, count($a))</code></p></div></li></ol></div></strong></strong></div></div><div class="section" title="19.3。资产/规则模板"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.GuidedRuleTemplateEditor"></a> 19.3。资产/规则模板</strong></strong></h2></div></div></div><p><strong><strong>当您需要定义单个规则时，引导规则编辑器非常有用，但是，如果您需要遵循相同的结构但在字段约束或操作部分中使用不同的值来定义多个规则，则“规则模板”是一项宝贵的资产。规则模板允许用户为要从数据表内插的值定义一个带有占位符的规则结构。文字值，公式和表达式也可以继续使用。</strong></strong></p><p><strong><strong>规则模板通常可以用作Drools Workbench中决策表的替代方法。</strong></strong></p><div class="section" title="19.3.1。创建规则模板"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleTemplateEditorCreating"></a> 19.3.1。创建规则模板</strong></strong></h3></div></div></div><p><strong><strong>要为规则创建模板，只需从“新建项目”菜单中选择“指导规则模板”。</strong></strong></p></div><div class="section" title="19.3.2。定义模板"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleTemplateEditorDefining"></a> 19.3.2。定义模板</strong></strong></h3></div></div></div><p><strong><strong>创建规则模板后，将显示编辑器。该编辑器采用标准指导编辑器的形式，在“规则创作”部分中进行了详细说明。构造规则后，您就可以在字段约束和操作部分中插入“模板键”作为占位符。文字值，公式和表达式可以像在标准向导编辑器中一样继续使用。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21049"></a><p class="title"><strong>图19.13。模板键弹出</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template1.png" align="middle" alt="模板键弹出"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>下面的屏幕快照说明了一个简单的规则，该规则已为申请人的最大年龄，最小年龄和信用等级定义了“模板密钥”。模板键分别定义为“ $ max_age”，“ $ min_age”和“ $ cr”。</p><div class="figure"><a id="d0e21057"></a><p class="title"><strong>图19.14。指导编辑器中的规则模板</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template2.png" align="middle" alt="指导编辑器中的规则模板"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.3.3。定义模板数据"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleTemplateEditorDefiningData"></a> 19.3.3。定义模板数据</strong></strong></h3></div></div></div><p><strong><strong>完成规则模板的定义后，您需要输入将用于插值“ Template Key”占位符的数据。Drools Workbench提供了在向导编辑器屏幕内的灵活网格中输入数据的功能。数据输入部分位于编辑器中的“数据”选项卡上。</strong></strong></p><p><strong><strong>规则模板数据网格非常灵活；具有针对基础字段的数据类型的不同弹出式编辑器。列可以调整大小和排序；单元可以合并和分组以促进快速数据输入。</strong></strong></p><p><strong><strong>一行数据插入单个规则的“模板键”占位符；因此，一行成为一条规则。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>如果某行的任何单元格都留为空白，则不会生成适用行的规则。</strong></strong></p></div><div class="figure"><strong><strong><a id="d0e21075"></a><p class="title"><strong>图19.15。模板数据网格</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template3.png" align="middle" alt="模板数据网格"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="19.3.3.1。单元合并"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedRuleTemplateEditorCellMerging"></a> 19.3.3.1。单元合并</h4></div></div></div><p>网格左上方的图标可切换打开和关闭单元格合并。合并单元格时，将具有相同值的同一列中的单元格合并到单个单元格中。这简化了更改共享相同原始值的多个单元格的值。合并单元格时，它们还会在该单元格的左上方获得一个图标，该图标允许将合并后的单元格上的行进行分组。</p><div class="figure"><a id="d0e21086"></a><p class="title"><strong>图19.16。单元合并</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template4.png" align="middle" alt="单元合并"></div></div></div><br class="figure-break"></div><div class="section" title="19.3.3.2。单元分组"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedRuleTemplateEditorCellGrouping"></a> 19.3.3.2。单元分组</h4></div></div></div><p>合并的单元格可以进一步折叠为单行。单击合并单元格左上角的[+ \-]图标会将相应的行折叠为一个条目。跨越折叠行的其他列中具有相同值的单元格将保持不变。跨折叠行的其他列中具有不同值的单元格将突出显示，并显示第一个值。</p><div class="figure"><a id="d0e21097"></a><p class="title"><strong>图19.17。单元分组</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template5.png" align="middle" alt="单元分组"></div></div></div><br class="figure-break"><p>当分组的单元格的值更改时，所有已折叠的单元格也将更新其值。</p></div></strong></strong></div><div class="section" title="19.3.4。生成的DRL"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedRuleTemplateEditorGeneratedDRL"></a> 19.3.4。生成的DRL</strong></strong></h3></div></div></div><p><strong><strong>尽管不是必需的，规则创建者可以查看将为“规则模板”和相关数据生成的DRL。此功能及其操作与其他资产没有什么不同。从编辑器屏幕底部选择“源”选项卡。将显示所有规则的DRL。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21110"></a><p class="title"><strong>图19.18。生成的DRL</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-template6.png" align="middle" alt="生成的DRL"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="19.4。指导决策表（基于Web）"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditor"></a> 19.4。指导决策表（基于Web）</strong></strong></h2></div></div></div><p><strong><strong>指导性决策表功能允许决策表在Web上进行适当编辑。通过内省哪些事实和字段可用来指导决策表的创建，此工作类似于向导编辑器。可以以表格格式定义规则属性，元数据，条件和操作，从而有助于快速输入大量相关规则。与其他所有规则资产一样，基于Web的决策表规则被编译为DRL。</strong></strong></p><div class="section" title="19.4.1。决策表类型"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorTypesOfDecisionTable"></a> 19.4.1。决策表类型</strong></strong></h3></div></div></div><p><strong><strong>决策表大致分为两种，Drools Workbench支持两种：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>延长入境</strong></strong></p></li><li class="listitem"><p><strong><strong>限制进入</strong></strong></p></li></ul></div><div class="section" title="19.4.1.1。延长入境"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorExtendedEntryDecisionTable"></a> 19.4.1.1。延长入境</strong></strong></h4></div></div></div><p><strong><strong>扩展条目决策表是针对该表的列定义或存根指定模式，字段和运算符，但不指定值的表。值或状态本身保存在决策表的主体中。通过限制列表中值的输入来限制可能值的范围是正常的，但不是必须的。Drools Workbench支持使用Java枚举，Drools Workbench枚举或决策表“可选值列表”来限制值输入。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21138"></a><p class="title"><strong>图19.19。扩展进入决策表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-complete1.png" align="middle" alt="扩展进入决策表"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.1.2。限制进入"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorLimitedEntryDecisionTable"></a> 19.4.1.2。限制进入</strong></strong></h4></div></div></div><p><strong><strong>受限条目决策表是除“模式”，“字段”和“运算符”外，列定义还为其指定值的表。决策表状态（保留在表主体中）是布尔值，其中正值（选中的复选框）具有意味着应应用或匹配该列的效果。负值（清除的复选框）表示该列不适用。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21149"></a><p class="title"><strong>图19.20。限制进入决定表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-complete2.png" align="middle" alt="限制进入决定表"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="section" title="19.4.2。主要组成部分\概念"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorConcepts"></a> 19.4.2。主要组成部分\概念</strong></strong></h3></div></div></div><p><strong><strong>指导性决策表分为两个主要部分：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>上部允许定义表列，以表示规则属性，元数据，条件和操作。</strong></strong></p></li><li class="listitem"><p><strong><strong>下部包含实际的表本身；其中各个行定义了单独的规则。</strong></strong></p></li></ul></div><div class="figure"><strong><strong><a id="d0e21167"></a><p class="title"><strong>图19.21。主要成分</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-sections.png" align="middle" alt="主要成分"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="19.4.2.1。导航"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedDecisionTableEditorNavigation"></a> 19.4.2.1。导航</h4></div></div></div><p>可以通过多种方式选择单元：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>首先，可以双击单个单元格，然后将出现一个与基础数据类型相对应的弹出编辑器。可以通过单击第一个并拖动鼠标指针，或者单击第一个并在按住Shift键的同时单击所需范围的范围来选择同一列中的单元格组。</p></li><li class="listitem"><p>其次，键盘光标键可用于在桌子周围导航。按下回车键将弹出相应的编辑器。可以通过按Shift键并同时使用光标键扩展范围来选择范围。</p></li></ul></div><p>可以通过将鼠标悬停在表标题中的相应分隔符上来调整列的大小。鼠标光标将改变，然后将列宽拖动到更窄或更宽。</p></div><div class="section" title="19.4.2.2。单元合并"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedDecisionTableEditorCellMerging"></a> 19.4.2.2。单元合并</h4></div></div></div><p>决策表左上方的图标可切换打开和关闭单元格合并。合并单元格时，将具有相同值的同一列中的单元格合并到单个单元格中。这简化了更改共享相同原始值的多个单元格的值。合并单元格时，它们还会在该单元格的左上方获得一个图标，该图标允许将合并后的单元格上的行进行分组。</p><div class="figure"><a id="d0e21192"></a><p class="title"><strong>图19.22。单元合并</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-merged.png" align="middle" alt="单元合并"></div></div></div><br class="figure-break"></div><div class="section" title="19.4.2.3。单元分组"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedDecisionTableEditorCellGrouping"></a> 19.4.2.3。单元分组</h4></div></div></div><p>合并的单元格可以进一步折叠为单行。单击合并单元格左上角的[+ \-]图标会将相应的行折叠为一个条目。跨越折叠行的其他列中具有相同值的单元格将保持不变。跨折叠行的其他列中具有不同值的单元格将突出显示，并显示第一个值。</p><div class="figure"><a id="d0e21203"></a><p class="title"><strong>图19.23。单元分组</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-grouped.png" align="middle" alt="单元分组"></div></div></div><br class="figure-break"><p>当分组的单元格的值更改时，所有已折叠的单元格也将更新其值。</p></div><div class="section" title="19.4.2.4。操作" otherwis="" =""><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedDecisionTableEditorOtherwiseOperation"></a> 19.4.2.4。“否则”的操作</h4></div></div></div><p>使用使用等于（==）或不等于（！=）运算符可以利用特殊决策表单元格值“否则”。此特殊值允许定义一个规则，该规则与表中定义的所有其他规则中未明确定义的所有值匹配。最好用一个例子来说明：</p><pre><code class="no-highlight">when
  Cheese( name not in ("Cheddar", "Edam", "Brie") )
  ...
then
  ...
end</code></pre><pre><code class="no-highlight">when
  Cheese( name in ("Cheddar", "Edam", "Brie") )
  ...
then
  ...
end</code></pre></div><div class="section" title="19.4.2.5。重新排列栏"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedDecisionTableEditorRearrangeColumns"></a> 19.4.2.5。重新排列栏</h4></div></div></div><p>通过在屏幕的配置部分中拖放它们，可以重新排列整个模式和各个条件。通过将广义约束放在更具体的约束之前，这允许对约束进行重新排序以最大程度地提高结果规则的性能。动作列也可以通过拖放来重新排列。</p><div class="figure"><a id="d0e21225"></a><p class="title"><strong>图19.24。重新排列条件模式</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-rearranging-patterns.png" align="middle" alt="重新排列条件模式"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e21231"></a><p class="title"><strong>图19.25。重新排列栏</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-rearranging-columns.png" align="middle" alt="重新排列栏"></div></div></div><br class="figure-break"></div></strong></strong></div><div class="section" title="19.4.3。定义基于Web的决策表"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorDefining"></a> 19.4.3。定义基于Web的决策表</strong></strong></h3></div></div></div><div class="section" title="19.4.3.1。手动创建"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorDefiningManually"></a> 19.4.3.1。手动创建</strong></strong></h4></div></div></div><p><strong><strong>创建新的空决策表后，您需要为事实，其约束和相应的动作定义列。</strong></strong></p><div class="section" title="19.4.3.1.1。列配置"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorDefiningManuallyColumns"></a> 19.4.3.1.1。列配置</strong></strong></h5></div></div></div><p><strong><strong>展开“决策表”元素，您将看到“条件”，“操作”和“选项”的另外三个部分。展开“条件”或“操作”部分将显示“新列”图标。这可用于将新的列定义添加到相应的部分。通过单击每个列名旁边的“-”图标可以删除现有列，也可以通过单击每个列名旁边的“铅笔”图标进行编辑。“选项”部分的功能略有不同，但是原理是相同的：单击“添加属性/元数据”图标允许定义表属性的列（例如“显着性”，“无循环”等）或添加元数据。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21250"></a><p class="title"><strong>图19.26。列配置</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-config.png" align="middle" alt="列配置"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="19.4.3.1.1.1。实用列"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorDefinitionUtilityColumns"></a> 19.4.3.1.1.1。实用列</h6></div></div></div><p>所有决策表都包含两个实用程序列，其中包含规则编号和规则描述。</p></div><div class="section" title="19.4.3.1.1.2。添加列"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorAddingColumns"></a> 19.4.3.1.1.2。添加列</h6></div></div></div><p>要添加列，请单击“新建列”图标。</p><p>出现以下列类型选择弹出窗口。</p><div class="figure"><a id="d0e21268"></a><p class="title"><strong>图19.27。列类型弹出</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-type-popup.png" align="middle" alt="列类型弹出"></div></div></div><br class="figure-break"><p>默认情况下，列类型弹出窗口仅显示以下简单类型：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>添加新的元数据\属性列</p></li><li class="listitem"><p>添加一个简单条件</p></li><li class="listitem"><p>设置字段的值</p></li><li class="listitem"><p>在新事实上设置字段的值</p></li><li class="listitem"><p>删除现有事实</p></li></ul></div><p>单击“包括高级选项”可添加以下其他“高级”列类型，以用于更高级的用例：-</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>添加条件BRL片段</p></li><li class="listitem"><p>执行工作项</p></li><li class="listitem"><p>使用工作项参数设置字段的值</p></li><li class="listitem"><p>使用工作项参数在新事实上设置字段的值</p></li><li class="listitem"><p>添加操作BRL片段</p></li></ul></div></div><div class="section" title="19.4.3.1.1.3。简单列类型"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorSimpleColumns"></a> 19.4.3.1.1.3。简单列类型</h6></div></div></div><div class="section" title="19.4.3.1.1.3.1。元数据"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorMetaDataColumns"></a> 19.4.3.1.1.3.1。元数据</h6></div></div></div><p>可以定义零个或多个元数据列，每个列代表DRL规则上的常规元数据注释。</p></div><div class="section" title="19.4.3.1.1.3.2。属性"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorAttributeColumns"></a> 19.4.3.1.1.3.2。属性</h6></div></div></div><p>可以添加零个或多个代表任何DRL规则属性（例如，显着性，计时器，已启用等）的属性列。在指导决策表编辑器中提供了一个附加的伪属性，以“否定”规则。使用此属性可以否定完整的规则。例如，也可以否定以下简单规则。</p><pre><code class="no-highlight">when
  $c : Cheese( name == "Cheddar" )
then
  ...
end</code></pre><pre><code class="no-highlight">when
  not Cheese( name == "Cheddar" )
then
  ...
end</code></pre></div><div class="section" title="19.4.3.1.1.3.3。简单条件"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorSimpleCondition"></a> 19.4.3.1.1.3.3。简单条件</h6></div></div></div><p>条件表示对规则左侧或“时间”部分中定义的事实模式的约束。要定义条件列，您必须首先选择或定义绑定到模型类的事实模式。您可以选择否定模式。完成此操作后，您可以定义字段约束。如果使用相同的事实模式绑定定义了两个或更多列，则字段约束将成为同一模式上的复合字段约束。如果为单个模型类定义多个绑定，则每个绑定在规则的左侧将成为一个单独的模型类。</p><p>当您编辑或创建新列时，将选择约束类型：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>文字：将使用运算符将单元格中的值与该字段进行比较。</p></li><li class="listitem"><p>公式：将评估单元格中的表达式，然后将其与字段进行比较。</p></li><li class="listitem"><p>谓词：不需要字段，表达式将被评估为true或false。</p></li></ul></div><div class="figure"><a id="d0e21344"></a><p class="title"><strong>图19.28。简单条件弹出窗口</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-condition-popup.png" align="middle" alt="简单条件弹出窗口"></div></div></div><br class="figure-break"></div><div class="section" title="19.4.3.1.1.3.4。设置字段的值"><div class="titlepage"><div><div><h6 class="title"><a id="drools.DecisionTableSetField"></a> 19.4.3.1.1.3.4。设置字段的值</h6></div></div></div><p>用于设置先前绑定事实的字段值的操作。您可以选择将修改后的值通知规则引擎，这可能导致其他规则被重新激活。</p><div class="figure"><a id="d0e21355"></a><p class="title"><strong>图19.29。设置字段弹出窗口的值</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-setField-popup.png" align="middle" alt="设置字段弹出窗口的值"></div></div></div><br class="figure-break"></div><div class="section" title="19.4.3.1.1.3.5。在新事实上设置字段的值"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorSetFieldOnNewFact"></a> 19.4.3.1.1.3.5。在新事实上设置字段的值</h6></div></div></div><p>一种将新事实插入规则引擎工作存储器并设置新事实字段之一的值的动作。您可以选择“逻辑插入”新的事实，这意味着如果导致执行该操作的条件不再成立，它将自动删除。有关真实性维护和逻辑插入的详细信息，请参阅Drools Expert文档。</p><div class="figure"><a id="d0e21366"></a><p class="title"><strong>图19.30。在新的事实弹出窗口上设置字段的值</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-insertField-popup.png" align="middle" alt="在新的事实弹出窗口上设置字段的值"></div></div></div><br class="figure-break"></div><div class="section" title="19.4.3.1.1.3.6。删除现有事实"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorDeleteFact"></a> 19.4.3.1.1.3.6。删除现有事实</h6></div></div></div><p>删除绑定事实的动作。</p><div class="figure"><a id="d0e21377"></a><p class="title"><strong>图19.31。删除现有的事实弹出窗口</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-deleteFact-popup.png" align="middle" alt="删除现有的事实弹出窗口"></div></div></div><br class="figure-break"></div></div><div class="section" title="19.4.3.1.1.4。高级列类型"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorAdvancedColumns"></a> 19.4.3.1.1.4。高级列类型</h6></div></div></div><div class="section" title="19.4.3.1.1.4.1。条件BRL片段"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorConditionBRL"></a> 19.4.3.1.1.4.1。条件BRL片段</h6></div></div></div><p>允许在规则的左侧使用BRL片段的构造。BRL片段是使用“导引规则编辑器”创作的，因此该编辑器中可用的所有功能都可用于定义决策表列。例如“来自”，“收集”和“累积”等。使用嵌入式“导向规则编辑器”时，定义为“模板关键字”的字段值将在决策表中形成列。可以通过更简单的列类型来引用BRL片段中绑定的事实和事实字段，反之亦然。</p><p>在以下示例中，已定义了两个模板关键字，因此，决策表中将出现两列。</p><div class="figure"><a id="d0e21393"></a><p class="title"><strong>图19.32。使用BRL定义条件</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-condition-brl1-popup.png" align="middle" alt="使用BRL定义条件"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e21399"></a><p class="title"><strong>图19.33。结果决策表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-condition-brl2-popup.png" align="middle" alt="结果决策表"></div></div></div><br class="figure-break"></div><div class="section" title="19.4.3.1.1.4.2。执行工作项"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorExecuteWorkItem"></a> 19.4.3.1.1.4.2。执行工作项</h6></div></div></div><p>调用jBPM工作项处理程序的操作，将其输入参数设置为绑定的事实\事实字段值。</p></div><div class="section" title="19.4.3.1.1.4.3。使用工作项参数设置字段的值"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorSetWorkItemParameter"></a> 19.4.3.1.1.4.3。使用工作项参数设置字段的值</h6></div></div></div><p>将Fact字段的值设置为jBPM工作项处理程序的result参数的Action。</p></div><div class="section" title="19.4.3.1.1.4.4。使用工作项参数在新事实上设置字段的值"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorSetFactFromWorkItemParameter"></a> 19.4.3.1.1.4.4。使用工作项参数在新事实上设置字段的值</h6></div></div></div><p>将新的Fact字段的值设置为jBPM工作项处理程序的result参数的Action。</p></div><div class="section" title="19.4.3.1.1.4.5。动作BRL片段"><div class="titlepage"><div><div><h6 class="title"><a id="drools.GuidedDecisionTableEditorActionBRL"></a> 19.4.3.1.1.4.5。动作BRL片段</h6></div></div></div><p>允许在规则的右侧使用BRL片段的构造。BRL片段是使用“指导规则编辑器”创作的，因此可以使用该编辑器中的所有可用功能来定义决策表列。当使用嵌入式“指导规则编辑器”时，定义为“模板关键字”的字段值将在决策表中形成列。可以用更简单的列类型引用BRL片段中绑定的事实，反之亦然。</p><p>在以下示例中，已定义了两个模板关键字，因此，决策表中将出现两列。</p><div class="figure"><a id="d0e21427"></a><p class="title"><strong>图19.34。使用BRL定义动作</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-action-brl1-popup.png" align="middle" alt="使用BRL定义动作"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e21433"></a><p class="title"><strong>图19.35。结果决策表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-column-action-brl2-popup.png" align="middle" alt="结果决策表"></div></div></div><br class="figure-break"></div></div></strong></strong></div></div><div class="section" title="19.4.3.2。使用向导"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizard"></a> 19.4.3.2。使用向导</strong></strong></h4></div></div></div><p><strong><strong>向导也可以用来帮助定义决策表列。</strong></strong></p><p><strong><strong>第一次选择创建新规则时可以选择向导。该向导提供了许多页面来定义表：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>摘要</strong></strong></p></li><li class="listitem"><p><strong><strong>添加事实模式</strong></strong></p></li><li class="listitem"><p><strong><strong>添加约束</strong></strong></p></li><li class="listitem"><p><strong><strong>添加操作以更新事实</strong></strong></p></li><li class="listitem"><p><strong><strong>添加操作以插入事实</strong></strong></p></li><li class="listitem"><p><strong><strong>列展开</strong></strong></p></li></ul></div><div class="section" title="19.4.3.2.1。选择向导"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorSelectingWizard"></a> 19.4.3.2.1。选择向导</strong></strong></h5></div></div></div><p><strong><strong>“新建向导”对话框显示“使用向导”复选框。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21470"></a><p class="title"><strong>图19.36。选择向导</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard1.png" align="middle" alt="选择向导"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.2。摘要页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardSummaryPage"></a> 19.4.3.2.2。摘要页面</strong></strong></h5></div></div></div><p><strong><strong>摘要页面显示了有关决策表的一些基本详细信息，并允许更改资产名称。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21481"></a><p class="title"><strong>图19.37。摘要页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard2.png" align="middle" alt="摘要页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.3。添加事实模式页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardFactPatternsPage"></a> 19.4.3.2.3。添加事实模式页面</strong></strong></h5></div></div></div><p><strong><strong>该页面允许定义事实类型，这些事实类型将构成规则的“何时”列。模型中可用的事实类型将显示在左侧列表框中。选择事实类型，然后使用“ >>”按钮将其添加到右侧列表框中的所选事实列表中。删除是一个类似的过程：可以在右侧列表框中选择不再需要的事实，并使用“ <<”按钮将其删除。所有事实类型都需要绑定到变量。不完整的事实类型将突出显示，并显示警告消息。在解决所有警告之前，您将无法完成定义。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21492"></a><p class="title"><strong>图19.38。添加事实模式页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard3a.png" align="middle" alt="添加事实模式页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e21498"></a><p class="title"><strong>图19.39。事实定义不完整的示例</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard3b.png" align="middle" alt="事实定义不完整的示例"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.4。添加约束页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardAddConstraintPage"></a> 19.4.3.2.4。添加约束页面</strong></strong></h5></div></div></div><p><strong><strong>该页面允许您定义要在决策表中使用的事实类型的字段约束。在上一个“向导”页面上选择的事实类型在右侧列表框中列出。通过单击事实类型来选择它，将在中间列表框中显示一个可用字段的列表，以及一个创建不需要特定字段的谓词的选项。通过单击字段，然后单击“ >>”按钮，可以将字段添加到模式的约束中。通过单击右侧列表框中的“条件”，然后单击“ <<”按钮，可以从模式定义中删除字段。所有字段都必须具有列标题和运算符。不完整的字段将突出显示，并显示警告消息。在解决所有警告之前，您将无法完成定义。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21509"></a><p class="title"><strong>图19.40。添加约束页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard4.png" align="middle" alt="添加约束页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.5。添加操作以更新事实页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardUpdateFactsPage"></a> 19.4.3.2.5。添加操作以更新事实页面</strong></strong></h5></div></div></div><p><strong><strong>可以在规则的结果或操作中更新已定义的事实类型。该页面允许定义此类操作。左侧列表框中列出了添加到决策表定义的事实类型。通过单击选择事实类型，将在中间列表框中显示可用字段的列表。可以通过选择可用字段并按“ >>”按钮来添加需要由规则更新的字段。单击所选字段，然后单击“ <<”按钮，可以类似地删除字段。所有操作都需要一个列标题。任何未完成的操作将突出显示并显示警告消息。在解决所有警告之前，您将无法完成定义。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21520"></a><p class="title"><strong>图19.41。添加操作以更新事实页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard5.png" align="middle" alt="添加操作以更新事实页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.6。添加操作以插入事实页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardInsertFactsPage"></a> 19.4.3.2.6。添加操作以插入事实页面</strong></strong></h5></div></div></div><p><strong><strong>还可以定义动作以将新的事实插入规则引擎。左侧列表框中列出了模型中可用的事实类型的列表。通过单击它们，然后在最左侧的列表框和标题为“选择的模式”之间单击“ >>”按钮，选择要包含在决策表定义中的那些。去除是类似的过程，通过按下“ <<”按钮可以选择和去除所选的花样。对所选模式的选择为用户提供了可用字段的列表。通过选择需要设置值的字段，可以通过选择它们并在“可用字段”和“选择的字段”列表框之间按“ >>”按钮来添加。移除是与已描述的类似过程。新事实需要绑定到变量并指定列标题。不完整的事实和/或字段将突出显示，并显示警告消息。在解决所有警告之前，您将无法完成定义。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21531"></a><p class="title"><strong>图19.42。添加操作以插入事实页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard6.png" align="middle" alt="添加操作以插入事实页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.3.2.7。列展开页面"><div class="titlepage"><div><div><h5 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorWizardExpandColumnsPage"></a> 19.4.3.2.7。列展开页面</strong></strong></h5></div></div></div><p><strong><strong>该页面控制如何根据先前页面上定义的条件创建决策表。用可选的允许值列表定义的条件列可用于在决策表中创建行。如果已经用允许值列表定义了许多Condition列，则结果表将为每个值组合包含一行；即决策表将以扩展形式显示。默认情况下，使用值列表定义的所有Condition列都将包含在扩展中，但是您可以根据需要选择列的子集。这可以通过取消选中“完全展开”复选框并将列添加到右侧列表框来完成。如果不需要扩展，请取消选中“完全扩展”复选框，并确保将零列添加到右侧列表框中。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21542"></a><p class="title"><strong>图19.43。列展开页面</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard7a.png" align="middle" alt="列展开页面"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e21548"></a><p class="title"><strong>图19.44。条件列的示例，其中定义了可选值</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard7b.png" align="middle" alt="条件列的示例，其中定义了可选值"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e21554"></a><p class="title"><strong>图19.45。用扩展列生成决策表的示例</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-wizard7c.png" align="middle" alt="用扩展列生成决策表的示例"></div></div></div><br class="figure-break"></strong></strong></div></div></div><div class="section" title="19.4.4。规则定义"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorRuleDefinitions"></a> 19.4.4。规则定义</strong></strong></h3></div></div></div><p><strong><strong>本节允许使用前面定义的列来定义单个规则。</strong></strong></p><p><strong><strong>通过选择“添加行”按钮，可以将行添加到表的末尾。也可以通过单击现有行旁边的“ +”图标来插入行。“-”图标可用于删除行。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21567"></a><p class="title"><strong>图19.46。规则定义</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/dtable-body.png" align="middle" alt="规则定义"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.4.5。审核日志"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorAuditLog"></a> 19.4.5。审核日志</strong></strong></h3></div></div></div><p><strong><strong>审核日志已添加到网络引导的“决策表”编辑器中，以跟踪添加，删除和修改。</strong></strong></p><p><strong><strong>默认情况下，审核日志未配置为记录任何事件，但是，用户可以轻松选择他们感兴趣的事件。</strong></strong></p><p><strong><strong>每当签入资产时，审核日志就会保留。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21582"></a><p class="title"><strong>图19.47。空审核日志</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-dtable-audit-log1.png" align="middle" alt="空审核日志"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>一旦启用了事件捕获，就会记录所有可疑操作。用户能够执行以下操作：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>在每个事件旁边记录一个说明性注释。</p></li><li class="listitem"><p>从日志中删除事件。事件详细信息保留在基础存储库中。</p></li></ul></div><div class="figure"><a id="d0e21597"></a><p class="title"><strong>图19.48。审核事件示例</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/guided-dtable-audit-log2.png" align="middle" alt="审核事件示例"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.4.6。实时验证与确认"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorVerification"></a> 19.4.6。实时验证与确认</strong></strong></h3></div></div></div><p><strong><strong>每次更改单元后都会验证决策表。如果发现任何问题，结果将显示在表格右侧的列中。验证和验证涉及以下问题：</strong></strong></p><div class="section" title="19.4.6.1。冗余"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorVerificationRedundancy"></a> 19.4.6.1。冗余</strong></strong></h4></div></div></div><p><strong><strong>在给定相同事实集的情况下，如果两行执行相同的操作，则两行之间存在冗余。</strong></strong></p><p><strong><strong>如果冗余规则为现有事实设置值，则冗余可能不会成为问题，这只会将该值设置两次。当这两个规则增加一个计数器或向工作内存中添加更多事实时，就会出现问题，因为这会导致不必要的副作用。在这两种情况下，都不需要另一行。</strong></strong></p></div><div class="section" title="19.4.6.2。包容性"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorVerificationSubsumption"></a> 19.4.6.2。包容性</strong></strong></h4></div></div></div><p><strong><strong>如果在给定相同的事实集的情况下，一行执行与另一行相同的操作，则存在这种包含。这些行不是多余的，因为另一行更为复杂，并且可能会触发一组不会触发该附属行的事实。</strong></strong></p><p><strong><strong>包含的问题类似于具有冗余的情况。</strong></strong></p></div><div class="section" title="19.4.6.3。矛盾冲突"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorVerificationConflicts"></a> 19.4.6.3。矛盾冲突</strong></strong></h4></div></div></div><p><strong><strong>冲突可以存在于单行或行之间。</strong></strong></p><p><strong><strong>单行冲突会阻止执行行操作。</strong></strong></p><p><strong><strong>当两个规则的条件满足一组相同的事实时，就会存在两行之间的冲突，但是操作将事实字段设置为不同的值。条件可以是多余的，也可以只是包含的。冲突是一个问题，因为不可能知道最后采取什么行动。条件可能会将贷款设置为批准和拒绝。每次运行规则以及每个规则引擎软件版本的最终结果可能都不同。</strong></strong></p></div><div class="section" title="19.4.6.4。缺少列"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="drools.GuidedDecisionTableEditorVerificationMissingRHSLHS"></a> 19.4.6.4。缺少列</strong></strong></h4></div></div></div><p><strong><strong>在某些情况下，通常是偶然的情况，用户可以删除所有条件或操作列。删除条件后，将执行所有操作，并且当缺少操作列时，行将不执行任何操作。</strong></strong></p></div></div></div><div class="section" title="19.5。指导决策树"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.GuidedDecisionTreeEditor"></a> 19.5。指导决策树</strong></strong></h2></div></div></div><p><strong><strong>工作台支持创作简单的决策树。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>该编辑器目前不支持嵌套数据对象。因此，建议仅将引导式决策树与平面数据对象模型一起使用。</strong></strong></p></div><div class="section" title="19.5.1。初始编辑器布局"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21644"></a> 19.5.1。初始编辑器布局</strong></strong></h3></div></div></div><p><strong><strong>创建新的指导决策树时，编辑器最初为空白。</strong></strong></p><p><strong><strong>左侧是可用数据对象，其字段和操作的调色板。</strong></strong></p><p><strong><strong>右侧是您可以拖放数据对象，其字段或动作以构建树的区域。</strong></strong></p><p><strong><strong>编辑器将显示正在拖动的节点与可以连接的子节点之间的连接器。拖动完成后，新节点将附加到适用的子节点。根节点被拖到空树时不会显示连接器。完成拖动后，根节点将位于编辑器的中心。</strong></strong></p><p><strong><strong>组成树时有各种限制：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>一棵树的根必须有一个数据对象。</strong></strong></p></li><li class="listitem"><p><strong><strong>一棵树只能有一个根。</strong></strong></p></li><li class="listitem"><p><strong><strong>数据对象可以具有其他数据对象，字段约束或动作作为子代。</strong></strong></p><p><strong><strong>字段约束必须位于与父节点相同的数据对象的字段上。</strong></strong></p></li><li class="listitem"><p><strong><strong>字段约束可以具有其他字段约束，也可以具有“操作”作为子级。</strong></strong></p><p><strong><strong>字段约束必须位于与父节点相同的数据对象的字段上。</strong></strong></p></li><li class="listitem"><p><strong><strong>动作只能有其他动作作为子代。</strong></strong></p></li></ol></div><p><strong><strong>
    </strong></strong></p><div class="figure"><strong><strong><a id="d0e21678"></a><p class="title"><strong>图19.49。指导决策树-空编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor1.png" align="middle" alt="指导决策树-空编辑器"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>展开面板会显示数据对象及其字段的树节点。</p><div class="figure"><a id="d0e21686"></a><p class="title"><strong>图19.50。指导决策树-扩展的调色板</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor2.png" align="middle" alt="指导决策树-扩展的调色板"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.5.2。第一步"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21692"></a> 19.5.2。第一步</strong></strong></h3></div></div></div><p><strong><strong>将数据对象拖到树创作区域上。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21697"></a><p class="title"><strong>图19.51。指导决策树-数据对象根节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor3.png" align="middle" alt="指导决策树-数据对象根节点"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>单击一个节点将其选中。</p><p>选择节点后，将出现用于操作节点的图标。</p><p>图标是：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>删除</p><p>删除节点也将删除所有子节点。</p></li><li class="listitem"><p>编辑</p><p>折叠的节点包含多个子节点，因此无法对其进行编辑。</p></li><li class="listitem"><p>坍方</p></li></ol></div><p>
    </p><div class="figure"><a id="d0e21724"></a><p class="title"><strong>图19.52。指导决策树-选定节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor4.png" align="middle" alt="指导决策树-选定节点"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.5.3。编辑数据对象节点"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21730"></a> 19.5.3。编辑数据对象节点</strong></strong></h3></div></div></div><p><strong><strong>选择一个数据对象节点并单击编辑图标，将显示一个弹出窗口来管理该节点。</strong></strong></p><p><strong><strong>弹出窗口显示数据对象类型，并允许将其绑定到变量。绑定数据对象可以通过动作进行修改或收回。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21737"></a><p class="title"><strong>图19.53。指导决策树-数据对象编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor5.png" align="middle" alt="指导决策树-数据对象编辑器"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.5.4。编辑字段约束节点"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21743"></a> 19.5.4。编辑字段约束节点</strong></strong></h3></div></div></div><p><strong><strong>选择一个“字段约束”节点并单击“编辑”图标，将显示一个弹出窗口来管理该节点。</strong></strong></p><p><strong><strong>弹出窗口显示数据对象类型和字段，并允许将字段绑定到变量。可以选择适用于“数据模型”字段的数据类型的运算符，并输入相应的值。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21750"></a><p class="title"><strong>图19.54。指导决策树-字段约束编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditor6.png" align="middle" alt="指导决策树-字段约束编辑器"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.5.5。编辑动作节点"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21756"></a> 19.5.5。编辑动作节点</strong></strong></h3></div></div></div><p><strong><strong>选择一个“插入动作”节点并单击“编辑”图标，将显示一个弹出窗口来管理该节点。</strong></strong></p><p><strong><strong>弹出窗口允许选择要插入的数据对象，以及插入的对象是否为“逻辑”。请参阅有关真实维护的Drools文档以获取更多信息。新数据对象的字段可以设置值。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21763"></a><p class="title"><strong>图19.55。指导决策树-动作“插入”编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditorActionInsert.png" align="middle" alt="指导决策树-行动" inser="=" =""></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>选择一个插入撤回节点并单击编辑图标，将显示一个弹出窗口来管理该节点。</p><p>弹出窗口允许选择从选定节点到根节点的路径中绑定的任何数据对象以撤回。</p><div class="figure"><a id="d0e21773"></a><p class="title"><strong>图19.56。指导决策树-动作“撤回”编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditorActionRetract.png" align="middle" alt="指导决策树-行动" retrac="=" =""></div></div></div><br class="figure-break"><p>选择一个插入更新节点，然后单击编辑图标，将显示一个弹出窗口来管理该节点。</p><p>弹出窗口允许修改从选定节点到根节点的路径中绑定的任何数据对象。修改后的数据对象的字段可以设置值。</p><div class="figure"><a id="d0e21783"></a><p class="title"><strong>图19.57。指导决策树-动作“更新”编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditorActionUpdate.png" align="middle" alt="指导决策树-行动" updat="=" =""></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="19.5.6。管理树"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e21789"></a> 19.5.6。管理树</strong></strong></h3></div></div></div><p><strong><strong>即使是简单的树木也可能会长大，变得难以维护。</strong></strong></p><p><strong><strong>因此，可以折叠树的一部分，从而在用户界面中提供更多空间来维护树的不同部分。</strong></strong></p><p><strong><strong>如果节点具有子节点，则在选中该节点时，将具有一个用于折叠子节点的图标。单击此图标将折叠孩子。</strong></strong></p><p><strong><strong>通过选择折叠节点并单击exapnd图标，可以同样地对其进行扩展。折叠的节点包含许多子节点，因此无法进行编辑。删除折叠的节点也会删除所有子节点。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21800"></a><p class="title"><strong>图19.58。指导决策树-折叠节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditorCollapse1.png" align="middle" alt="指导决策树-折叠节点"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e21806"></a><p class="title"><strong>图19.59。指导决策树-折叠节点</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GuidedDecisionTreeEditorCollapse2.png" align="middle" alt="指导决策树-折叠节点"></div></div></div><br class="figure-break"></strong></strong></div></div><div class="section" title="19.6。电子表格决策表"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.XLSDecisionTable"></a> 19.6。电子表格决策表</strong></strong></h2></div></div></div><p><strong><strong>多个规则可以存储在电子表格中。电子表格中的每一行都是一条规则，每一列都是一个条件，一个动作或一个选项。本文的Drools Expert部分将更详细地讨论电子表格决策表。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21817"></a><p class="title"><strong>图19.60。电子表格决策表</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/DecisionTable.png" align="middle" alt="电子表格决策表"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>要使用电子表格，请上传XLS文件。要创建新的决策表：启动新的“决策表（电子表格）”向导，您将获得一个上载选项。</p></strong></strong></div><div class="section" title="19.7。计分卡"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.GuidedScoreCardEditor"></a> 19.7。计分卡</strong></strong></h2></div></div></div><p><strong><strong>计分卡是用于计算总分的公式的图形表示。记分卡可用于预测某个结果的可能性或概率。现在，Drools支持添加记分卡。加性计分卡通过添加分配给各个规则条件的所有部分分数来计算总分数。
  </strong></strong></p><p><strong><strong>另外，Drools记分卡将允许设置原因代码，这有助于识别对总体得分有贡献的特定规则（存储桶）。Drools记分卡将基于PMML 4.1标准。
  </strong></strong></p><p><strong><strong>现在，“新建项目”菜单允许创建计分卡资产。</strong></strong></p><div class="figure"><strong><strong><a id="d0e21834"></a><p class="title"><strong>图19.61。记分卡资产-指导编辑器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/scorecard_asset_webeditor.png" align="middle" alt="记分卡资产-指导编辑器"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>上图显示了具有一个特征的计分卡。每个计分卡均包括两个部分（a）设置参数（b）特征部分</p><div class="section" title="19.7.1。 （a）设定参数"><div class="titlepage"><div><div><h3 class="title"><a id="drools.GuidedScoreCardEditorSetupParameters"></a> 19.7.1。 （a）设定参数</h3></div></div></div><p>设置部分由定义此计分卡总体行为的参数组成。
    </p><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem"><p>事实：此下拉列表显示此资产可见的事实列表。</p></li><li class="listitem"><p>结果分数字段：显示所选事实的字段列表。仅显示“ double”类型的字段。如果此下拉列表为空，请仔细检查您的事实模型。最终计算出的分数将存储在此字段中。
        </p></li><li class="listitem"><p>初始分数：数字文本字段，用于捕获初始分数。生成的规则将使用该分数初始化“结果分数字段”，然后在对部分分数求和时将其添加到总分数中。
        </p></li><li class="listitem"><p>使用原因码：布尔指示器，用于计算原因码以及最终分数。在此字段中选择“是/否”将启用/禁用“结果原因代码字段”，“原因代码算法”和“基线分数”字段。
        </p></li><li class="listitem"><p>结果原因代码字段：显示所选事实的字段列表。仅类型为'java.util的字段。显示清单”。该集合将保存此计分卡选择的原因代码。
        </p></li><li class="listitem"><p>原因码算法：可以是“ none”，“ pointsAbove”或“ pointsBelow”，描述相对于每个特征的基线分数或在最高评分卡上设置的原因码的排名方式。
        </p></li><li class="listitem"><p>基线分数：确定原因码排名时，用作所有特征的基线比较分数的单个值。或者，可以为每个单独的特性设置唯一的基线得分，如下所示。仅当UseReasonCodes为“ true”且未为每个特性提供基线基线时，才需要此值。
        </p></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>如果UseReasonCodes为“ true”，则必须在记分卡级别或每个特征定义BaselineScore，并且必须为每个特征或其输入属性提供ReasonCode。如果UseReasonCodes为“ false”，则不需要baselineScore和原因码。
      </p></div></div><div class="section" title="19.7.2。 （b）特征"><div class="titlepage"><div><div><h3 class="title"><a id="drools.GuidedScoreCardEditorCharacteristics"></a> 19.7.2。 （b）特征</h3></div></div></div><p>单击“新特征”按钮后，会将新的空白特征编辑器添加到记分卡。为每个记分卡特征（数字或分类）定义点分配策略。每个计分卡特性都分配有一个单独的部分分数，该分数用于计算总分数。总体分数就是所有部分分数的总和。假定部分分数是“ double”类型的连续值。
    </p><div class="section" title="19.7.2.1。创建特征"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedScoreCardEditorCreatingCharacteristics"></a> 19.7.2.1。创建特征</h4></div></div></div><p>每个计分卡必须至少具有一个特征</p><div class="figure"><a id="d0e21882"></a><p class="title"><strong>图19.62。新特性</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/scorecards_new_characteristic.png" align="middle" alt="新特性"></div></div></div><br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem"><p>名称：此特征的描述性名称。仅供参考。
          </p></li><li class="listitem"><p>删除宪章：显示确认对话框后，将从记分卡中删除此特征。
          </p></li><li class="listitem"><p>添加属性：将为属性（箱）添加行条目。
          </p></li><li class="listitem"><p>事实：选择要评估的分数类别。
          </p></li><li class="listitem"><p>特征：显示所选事实的字段列表。仅显示类型为“字符串”，“整数”，“双精度”，“布尔值”的字段。
          </p></li><li class="listitem"><p>基线分数：设置特征的基线分数，在确定原因码的排名时，将其与实际部分分数进行比较。当useReasonCodes属性为“ true”且未在元素记分卡中定义baselineScore时，此值是必需的。只要为特性定义了baselineScore，它将优先于元素记分卡中定义的baselineScore值。
          </p></li><li class="listitem"><p>原因代码：包含特征的原因代码，通常与不利的决定相关联。
          </p></li></ol></div></div><div class="section" title="19.7.2.2。创建属性"><div class="titlepage"><div><div><h4 class="title"><a id="drools.GuidedScoreCardEditorCreatingAttributes"></a> 19.7.2.2。创建属性</h4></div></div></div><p>单击“新属性”按钮后，将出现一个新的空属性编辑器。在记分卡模型中，为特定特征定义属性的所有元素都必须都引用单个字段。
      </p><div class="figure"><a id="d0e21915"></a><p class="title"><strong>图19.63。新属性</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/scorecards_new_attribute.png" align="middle" alt="新属性"></div></div></div><br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem"><p>运算符：输入属性和部分分数之间进行映射的条件。操作员下拉列表将显示不同的值，具体取决于所选字段的数据类型。
            </p><div class="orderedlist"><ol class="orderedlist" type="a" compact><li class="listitem"><p>DataType字符串：“ =”，“ in”。
                </p></li><li class="listitem"><p>DataType整数：“ =”，“>”，“ <”，“> =”，“ <=”，“> .. <”，“> = .. <”，“> = .. <=”，“ > .. <=“。
                </p></li><li class="listitem"><p>DataType布尔值：“ true”，“ false”。
                </p></li></ol></div><p>有关更多详细信息，请参见下一部分（值）。
          </p></li><li class="listitem"><p>值：根据操作员选择的值，指定的值可以是单个值，也可以是用逗号（“，”）分隔的一组值。对于运算符类型boolean，禁用了value字段。
            </p><table id="d0e21939"><caption>表19.1。运算符/值</caption><thead><tr>
                  <td>数据类型</td>
                  <td>操作员</td>
                  <td>值</td>
                  <td>备注</td>
                </tr></thead><tbody><tr>
                  <td>串</td>
                  <td>=</td>
                  <td>单值</td>
                  <td>会寻找完全匹配的</td>
                </tr><tr>
                  <td>串</td>
                  <td>在</td>
                  <td>逗号分隔值（a，b，c，...）</td>
                  <td>如果字段值包含在逗号分隔的值列表中，则运算符“ in”表示评估为TRUE</td>
                </tr><tr>
                  <td>布尔型</td>
                  <td>是真的</td>
                  <td>不适用</td>
                  <td>值字段不可修改（只读）</td>
                </tr><tr>
                  <td>布尔型</td>
                  <td>是假的</td>
                  <td>不适用</td>
                  <td>值字段不可修改（只读）</td>
                </tr><tr>
                  <td>数字</td>
                  <td>=</td>
                  <td>单值</td>
                  <td>等于运算符</td>
                </tr><tr>
                  <td>数字</td>
                  <td>></td>
                  <td>单值</td>
                  <td>大于运算符</td>
                </tr><tr>
                  <td>数字</td>
                  <td><</td>
                  <td>单值</td>
                  <td>少于运算符</td>
                </tr><tr>
                  <td>数字</td>
                  <td>> =</td>
                  <td>单值</td>
                  <td>大于或等于</td>
                </tr><tr>
                  <td>数字</td>
                  <td><=</td>
                  <td>单值</td>
                  <td>小于或等于</td>
                </tr><tr>
                  <td>数字</td>
                  <td>> .. <</td>
                  <td>逗号分隔值（a，b）</td>
                  <td>（大于值“ a”）和（小于值“ b”）</td>
                </tr><tr>
                  <td>数字</td>
                  <td>> = .. <</td>
                  <td>逗号分隔值（a，b）</td>
                  <td>（大于或等于值'a'）和（小于值'b'）</td>
                </tr><tr>
                  <td>数字</td>
                  <td>> = .. <=</td>
                  <td>逗号分隔值（a，b）</td>
                  <td>（大于或等于值'a'）和（小于或等于值'b'）</td>
                </tr><tr>
                  <td>数字</td>
                  <td>> .. <=</td>
                  <td>逗号分隔值（a，b）</td>
                  <td>（大于值'a'）和（小于或等于值'b'）</td>
                </tr></tbody></table></li><li class="listitem"><p>部分分数：定义授予该属性的分数。
          </p></li><li class="listitem"><p>原因码：定义属性的原因码。如果在此级别使用了reasonCode属性，则它优先于与Characteristic元素关联的ReasonCode。
          </p></li><li class="listitem"><p>行动：删除此属性。提示用户进行确认。
          </p></li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>如果“使用原因代码”为“ true”，则必须在记分卡级别或为每个特征定义基线得分，并且必须为每个特征或其每个输入属性提供原因代码。如果“使用原因代码”为“ false”，则不需要BaselineScore和ReasonCode。
        </p></div></div></div></strong></strong></div><div class="section" title="19.8。测试场景"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.TestScenarioEditor"></a> 19.8。测试场景</strong></strong></h2></div></div></div><p><strong><strong>测试方案用于验证规则和知识库是否按预期工作。随着知识库的发展，测试方案可以防止回归。</strong></strong></p><div class="figure"><strong><strong><a id="d0e22157"></a><p class="title"><strong>图19.64。示例测试场景</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/TestScenario.png" align="middle" alt="示例测试场景"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>给定部分列出了行为所需的事实。预期部分列出了预期的更改和行为所采取的措施。在执行之前，已通过测试场景的给定事实。在规则执行期间，会记录知识库中的更改。执行结束记录的动作后，将知识库和知识库输出中的现有事实与期望进行比较。</p><div class="figure"><a id="d0e22165"></a><p class="title"><strong>图19.65。执行后的示例测试方案</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/TestScenarioAfterRunningIt.png" align="middle" alt="执行后的示例测试方案"></div></div></div><br class="figure-break"><div class="section" title="19.8.1。知识会议选择器"><div class="titlepage"><div><div><h3 class="title"><a id="drools.KSessionSelector"></a> 19.8.1。知识会议选择器</h3></div></div></div><div class="figure"><a id="d0e22174"></a><p class="title"><strong>图19.66。知识会议选择器</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/KSessionSelector.png" align="middle" alt="知识会议选择器"></div></div></div><br class="figure-break"><p>知识会话选择器用于选择运行规则的会话。当使用模拟时间时，知识会话必须是有状态的，并使用伪时钟。知识会话在“项目编辑器”的“知识库和会话”部分中定义。
    </p></div><div class="section" title="19.8.2。给定部分"><div class="titlepage"><div><div><h3 class="title"><a id="drools.TestScenarioEditorGivenSection"></a> 19.8.2。给定部分</h3></div></div></div><div class="figure"><a id="d0e22185"></a><p class="title"><strong>图19.67。给定弹出窗口</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/GivenSection.png" align="middle" alt="给定弹出窗口"></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>插入新事实-添加一个新事实，该新事实将在执行前插入到知识库中。</p></li><li class="listitem"><p>修改现有事实-允许在知识库执行之间编辑事实。</p></li><li class="listitem"><p>删除现有事实-允许在两次执行之间删除事实。</p></li><li class="listitem"><p>激活规则流组-通过预先激活组来允许测试规则流组中的规则。</p></li></ul></div></div><div class="section" title="19.8.3。期望部分"><div class="titlepage"><div><div><h3 class="title"><a id="drools.TestScenarioEditorExpectedSection"></a> 19.8.3。期望部分</h3></div></div></div><div class="figure"><a id="d0e22207"></a><p class="title"><strong>图19.68。预计弹出</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/ExpectSection.png" align="middle" alt="预计弹出"></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>规则-验证是否触发了特定规则。</p></li><li class="listitem"><p>事实值-验证在“给定”部分中创建的事实的事实值。</p></li><li class="listitem"><p>任何符合条件的事实-验证知识库中是否存在至少一个具有指定字段值的事实。</p></li></ul></div></div><div class="section" title="19.8.4。全球部分"><div class="titlepage"><div><div><h3 class="title"><a id="drools.TestScenarioEditorGlobalSection"></a> 19.8.4。全球部分</h3></div></div></div><div class="figure"><a id="d0e22226"></a><p class="title"><strong>图19.69。全球弹出</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/NewGlobal.png" align="middle" alt="全球弹出"></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>全局-验证全局字段值。</p></li></ul></div></div><div class="section" title="19.8.5。新输入部分"><div class="titlepage"><div><div><h3 class="title"><a id="drools.TestScenarioEditorInpuotSection"></a> 19.8.5。新输入部分</h3></div></div></div><div class="figure"><a id="d0e22239"></a><p class="title"><strong>图19.70。新输入弹出窗口</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/NewInput.png" align="middle" alt="新输入弹出窗口"></div></div></div><br class="figure-break"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>对现有事实调用方法-在规则执行开始时从事实调用方法。</p></li></ul></div></div></strong></strong></div><div class="section" title="19.9。功能"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.FunctionEditor"></a> 19.9。功能</strong></strong></h2></div></div></div><p><strong><strong>函数是另一种资产类型。它们不是规则，仅应在必要时使用。函数编辑器是文本编辑器。功能</strong></strong></p><div class="figure"><strong><strong><a id="d0e22254"></a><p class="title"><strong>图19.71。功能</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/Function.png" align="middle" alt="功能"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.10。DSL编辑器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.DSLEditor"></a> 19.10。DSL编辑器</strong></strong></h2></div></div></div><p><strong><strong>DSL编辑器允许创作DSL句子。读者应该花时间探索Drools Expert文档中的DSL功能。因为Drools Workbench的DSL编辑器中的语法是相同的。扩展了常规语法，以提供“提示”来控制如何在用户界面内呈现和验证DSL变量。</strong></strong></p><p><strong><strong>支持以下“提示”：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>{ <varname>： <regular expression="">}</regular></varname></strong></strong></p><p><strong><strong>当在向导编辑器中使用DSL Sentence时，它将代替DSL变量呈现一个文本字段。文本字段的内容将针对正则表达式进行验证。</strong></strong></p></li><li class="listitem"><p><strong><strong>{ <varname>：ENUM： <facttype.fieldname>}</facttype.fieldname></varname></strong></strong></p><p><strong><strong>当在指导编辑器中使用DSL句子时，这将代替DSL变量呈现一个枚举。
      <facttype.fieldname>将枚举绑定到模型“事实和字段”枚举定义。这可以是“ Drools Workbench枚举”（即在工作台中定义），也可以是Java枚举（即在模型POJO JAR文件中定义）。</facttype.fieldname></strong></strong></p></li><li class="listitem"><p><strong><strong>{{ <varname>：DATE： <dateformat>}</dateformat></varname></strong></strong></p><p><strong><strong>当在向导编辑器中使用DSL句子时，这将呈现一个日期选择器代替DSL变量。</strong></strong></p></li><li class="listitem"><p><strong><strong>{ <varname>：BOOLEAN：<[已检查|未选中]>}</varname></strong></strong></p><p><strong><strong>当在向导编辑器中使用DSL句子时，这将呈现一个下拉选择器来代替DSL变量，从而提供布尔选择。</strong></strong></p></li><li class="listitem"><p><strong><strong>{ <varname>：CF： <facttype.fieldname>}</facttype.fieldname></varname></strong></strong></p><p><strong><strong>这将呈现一个按钮，允许您使用“自定义表单”设置此变量的值。为了使用此功能，必须为包含factType.fieldName的自定义表单配置的工作集启用。如果没有这样的工作集，则使用一个简单的文本框（就像常规变量一样）。</strong></strong></p><p><strong><strong>有关更多信息，请阅读有关工作集和自定义表单配置的更多信息。</strong></strong></p></li></ul></div><div class="figure"><strong><strong><a id="d0e22295"></a><p class="title"><strong>图19.72。DSL规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/DSLEditor.png" align="middle" alt="DSL规则"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="19.11。数据枚举（下拉列表配置）"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.EnumerationEditor"></a> 19.11。数据枚举（下拉列表配置）</strong></strong></h2></div></div></div><p><strong><strong>数据枚举是技术人员可以配置的可选资产类型，以为向导式编辑器提供下拉列表。它们像其他资产一样被存储和编辑，并应用于它们所属的程序包。</strong></strong></p><p><strong><strong>枚举配置的内容是<code class="code">Fact.field</code>下拉列表中使用的值列表。字符串可以是要在下拉列表中显示的值，也可以是代码值（规则中最终使用的值）与显示值的映射。</strong></strong></p><div class="figure"><strong><strong><a id="d0e22311"></a><p class="title"><strong>图19.73。数据枚举</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/EnumConfig.png" align="middle" alt="数据枚举"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>如果希望在规则中使用的值和UI中显示的值之间使用映射，则需要将代码值和显示值用等号分开。例如：</p><pre><code class="no-highlight">'Person.gender' : ['M=Male','F=Female']</code></pre><p>在这个例子中<code class="code">F</code>将在规则中使用，但<code class="code">Female</code>在用户界面中显示。</p><p>下拉列表也可以取决于其他字段值。</p><p>让我们想象一个简单的事实模型，我们有一个名为Vehicle的类，它具有2个字段： <code class="code">engineType</code>和<code class="code">fuelType</code> 。我们希望有一个选择<code class="code">engineType</code> “汽油”或“柴油”。现在，显然，燃料的选择类型必须取决于发动机类型（因此，对于汽油，我们有ULP和PULP，对于柴油我们有BIO和NORMAL）。我们可以用枚举来表示这种依赖性：</p><div class="figure"><a id="d0e22341"></a><p class="title"><strong>图19.74。</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/EnumVehicleEngine.png" align="middle"></div></div></div><br class="figure-break"><p>这显示了如何根据其他字段值进行选择。请注意，一旦选择engineType，就会确定fuelType的选择列表。</p><div class="section" title="19.11.1。高级枚举概念"><div class="titlepage"><div><div><h3 class="title"><a id="drools.AdvancedEnumConcepts"></a> 19.11.1。高级枚举概念</h3></div></div></div><p>您还可以使用数据枚举进行其他一些高级操作。</p><div class="section" title="19.11.1.1。外部数据源"><div class="titlepage"><div><div><h4 class="title"><a id="drools.AdvanceEnumConcepts.external"></a> 19.11.1.1。外部数据源</h4></div></div></div><p>可以使用帮助程序类从外部数据源检索列表，而不是定义静态列表。</p><p>助手类必须在项目的类路径上；通过添加一个包含该类的JAR作为项目依赖项。helper类必须是可实例化的，并且具有返回一个<code class="code">java.util.List</code> 。该列表的填充特定于实现。</p><p>例如：</p><pre><code class="no-highlight">'Person.age' : (new org.yourco.DataHelper()).getListOfAges()</code></pre><p>在某些其他情况下，您可能希望完全从外部数据源（例如关系数据库）加载枚举数据。为此，您可以实现一个返回以下内容的类： <code class="code">Map<String, List<String>></code> 。地图的关键是<code class="code">Fact.field</code>值是<code class="code">java.util.List<String></code>所使用的值。</p><pre><code class="language-java">public class SampleDataSource2 {

  public Map&lt;String&gt;, List&lt;String&gt; loadData() {
    Map data = new HashMap();

    List d = new ArrayList();
    d.add("value1");
    d.add("value2");
    data.put("Fact.field", d);

    return data;
  }

}</code></pre><p>枚举定义将如下所示（不引用事实或字段名称）：</p><pre><code class="language-java">=(new SampleDataSource2()).loadData()</code></pre><p>的<code class="code">=</code>操作员通知工作台从助手类加载所有枚举数据。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2>注意</h2><p>当请求在编辑器中使用枚举定义时，将静态评估帮助器方法。</p></div></div><div class="section" title="19.11.1.2。动态查询"><div class="titlepage"><div><div><h4 class="title"><a id="drools.AdvanceEnumConcepts.dynamic"></a> 19.11.1.2。动态查询</h4></div></div></div><p>当编辑器需要枚举时，上述所有情况均通过静态评估枚举定义来检索值列表。</p><p>通过将对帮助器类的调用括在引号内，还可以从帮助器类动态加载依赖的枚举定义。例如：</p><pre><code class="no-highlight">'Country.region[countryCode]' : '(new org.yourco.DataHelper()).getListOfRegions("@{countryCode}")'</code></pre></div></div></strong></strong></div><div class="section" title="19.12。技术规则（DRL）"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.DRLEditor"></a> 19.12。技术规则（DRL）</strong></strong></h2></div></div></div><p><strong><strong>技术（DRL）规则以文本形式存储-可以在Drools Workbench中进行管理。DRL可以是整条规则，也可以是一条规则。如果这是一条单独的规则，则不需要package语句或导入（实际上，您可以完全跳过“ rule”语句，仅使用“ when”和“ then”分别标记条件和操作部分）。通常，您将使用IDE编辑原始DRL文件，因为它具有所有高级工具以及内容帮助和调试功能。但是，有时规则可能必须处理Drools Workbench软件包中的某些技术性问题。在任何典型的规则包中，通常都需要一些“技术规则”-当然，您可以混合并匹配所有规则类型。</strong></strong></p><div class="figure"><strong><strong><a id="d0e22405"></a><p class="title"><strong>图19.75。DRL技术规则</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Workbench/AuthoringAssets/DRLRule.png" align="middle" alt="DRL技术规则"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div></div><div class="chapter" title="第20章工作台整合"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.WorkbenchIntegration"></a>第20章工作台整合</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#drools.WorkbenchRemoteAPI">20.1。休息</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e22427">20.1.1。求职电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22531">20.1.2。储存库调用</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22706">20.1.3。组织单位电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22837">20.1.4。Maven电话</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e22953">20.1.5。REST摘要</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#kie.KeycloakSSOIntegration">20.2。Keycloak SSO集成</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e23153">20.2.1。情境</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23178">20.2.2。安装和设置Keycloak服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23222">20.2.3。创建并设置演示领域</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23351">20.2.4。安装和设置jBPM Workbench</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23519">20.2.5。通过Keycloak保护工作台远程服务</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23565">20.2.6。通过Keycloak保护工作台的文件系统服务</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23668">20.2.7。执行服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e23850">20.2.8。消费远程服务</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="20.1。休息"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="drools.WorkbenchRemoteAPI"></a> 20.1。休息</strong></strong></h2></div></div></div><p><strong><strong>对知识库的REST API调用使您能够管理知识库的内容并处理知识库中存储库中的静态数据。调用是异步的，也就是说，在将调用作为作业执行之后，它们将继续执行。每次调用都会返回作业ID，以允许在执行REST API调用之后请求作业状态并验证作业是否成功完成。这些调用的参数以JSON实体的形式提供。</strong></strong></p><p><strong><strong>当使用Java代码与REST API进行接口连接时，可以在POST操作中找到或通过各种操作返回的类。 <code class="code">(org.kie.workbench.services:)kie-wb-common-services</code>罐。下面提到的所有类都可以在<code class="code">org.kie.workbench.common.services.shared.rest</code>打包在该JAR中。</strong></strong></p><div class="section" title="20.1.1。求职电话"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e22427"></a> 20.1.1。求职电话</strong></strong></h3></div></div></div><p><strong><strong>发送后，每个Knowledge Store REST调用都会返回其作业ID。这是必需的，因为调用是异步的，并且您需要能够引用作业以检查其生命周期中的状态。在其生命周期中，作业可以具有以下状态：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="code">ACCEPTED</code> ：工作已被接受且正在处理中</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">BAD_REQUEST</code> ：该请求包含不正确的内容，因此不被接受</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">RESOURCE_NOT_EXIST</code> ：请求的资源（路径）不存在</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">DUPLICATE_RESOURCE</code> ：资源已经存在</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">SERVER_ERROR</code> ：服务器上发生错误</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">SUCCESS</code> ：工作成功完成</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">FAIL</code> ：工作失败</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">DENIED</code> ：工作被拒绝</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">GONE</code> ：找不到工作ID</strong></strong></p><p><strong><strong>在以下情况下，可以取消工作：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>该工作已明确删除</strong></strong></p></li><li class="listitem"><p><strong><strong>作业已完成，并且已从状态缓存中删除（在缓存达到其最大容量后，该作业将从状态缓存中删除）</strong></strong></p></li><li class="listitem"><p><strong><strong>这项工作不存在</strong></strong></p></li></ul></div></li></ul></div><p><strong><strong>下列<code class="code">job</code>提供电话：</strong></strong></p><div class="variablelist"><dl><dt><strong><strong><a id="url-get-job"></a> <span class="term">[GET] <span class="command"><strong>/ jobs / <span class="emphasis"><em>{jobID}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>返回工作状态</strong></strong></p><p><strong><strong>返回一个<code class="code">JobResult</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22511"></a><p class="title"><strong>示例20.1对存储库克隆请求的get作业调用的示例（格式化）响应正文</strong></p><div class="example-contents"><pre><code class="no-highlight">"{
  "status":"SUCCESS",
  "jodId":"1377770574783-27",
  "result":"Alias: testInstallAndDeployProject, Scheme: git, Uri: git://testInstallAndDeployProject",
  "lastModified":1377770578194,"detailedResult":null
}"</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-delete-job"></a> <span class="term">[删除] <span class="command"><strong>/ jobs / <span class="emphasis"><em>{jobID}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>删除作业：如果尚未处理该作业，则将从作业队列中删除该作业。但是，这不会取消或停止正在进行的作业</strong></strong></p><p><strong><strong>返回一个<code class="code">JobResult</code>实例</strong></strong></p></dd></dl></div></div><div class="section" title="20.1.2。储存库调用"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e22531"></a> 20.1.2。储存库调用</strong></strong></h3></div></div></div><p><strong><strong>存储库调用是对知识存储库的调用，可让您管理其Git存储库及其项目。</strong></strong></p><p><strong><strong>下列<code class="code">repositories</code>提供电话：</strong></strong></p><div class="variablelist"><dl><dt><strong><strong><a id="url-get-repositories"></a> <span class="term">[GET] <span class="command"><strong>/存储库</strong></span></span></strong></strong></dt><dd><p><strong><strong>获取有关知识库中存储库的信息</strong></strong></p><p><strong><strong>返回一个<code class="code">Collection<Map<String, String>></code>要么<code class="code">Collection<RepositoryRequest></code>实例，具体取决于所使用的JSON序列化库。在<code class="code">Map<String, String></code>实例匹配中的字段<code class="code">RepositoryRequest</code>类</strong></strong></p><div class="example"><strong><strong><a id="d0e22564"></a><p class="title"><strong>示例20.2get存储库调用的示例（格式化）响应正文</strong></p><div class="example-contents"><pre><code class="no-highlight">[
  {
    "name":"wb-assets",
    "description":"generic assets",
    "userName":null,
    "password":null,
    "requestType":null,
    "gitURL":"git://bpms-assets"
 },
 {
   "name":"loanProject",
   "description":"Loan processes and rules",
   "userName":null,
   "password":null,
   "requestType":null,
   "gitURL":"git://loansProject"
 }
]</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-get-repository"></a> <span class="term">[GET] <span class="command"><strong>/ repositories / {repositoryName}</strong></span></span></strong></strong></dt><dd><p><strong><strong>获取有关存储库的信息</strong></strong></p><p><strong><strong>返回一个<code class="code">Map<String, String></code>要么<code class="code">RepositoryRequest</code>实例，具体取决于所使用的JSON序列化库。在<code class="code">Map<String, String></code>实例匹配中的字段<code class="code">RepositoryRequest</code>类</strong></strong></p><div class="example"><strong><strong><a id="d0e22591"></a><p class="title"><strong>示例20.3get存储库调用的示例（格式化）响应正文</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"wb-assets",
  "description":"generic assets",
  "userName":null,
  "password":null,
  "requestType":null,
  "gitURL":"git://bpms-assets"
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-create-repository"></a> <span class="term">[POST] <span class="command"><strong>/存储库</strong></span></span></strong></strong></dt><dd><p><strong><strong>创建一个新的空存储库或从现有（git）存储库克隆的新存储库</strong></strong></p><p><strong><strong>消耗一个<code class="code">RepositoryRequest</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">CreateOrCloneRepositoryRequest</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22614"></a><p class="title"><strong>示例20.4创建存储库调用的示例（格式化）响应正文</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"new-project-repo",
  "description":"repo for my new project",
  "userName":null,"password":null,
  "requestType":"new",
  "gitURL":null
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-delete-repository"></a> <span class="term">[删除] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>从知识库中删除存储库</strong></strong></p><p><strong><strong>返回一个<code class="code">RemoveRepositoryRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-create-project"></a> <span class="term">[POST] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects /</strong></span></span></strong></strong></dt><dd><p><strong><strong>在存储库中创建一个项目</strong></strong></p><p><strong><strong>消耗一个<code class="code">Entity</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">CreateProjectRequest</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22655"></a><p class="title"><strong>示例20.5一个示例（格式化的）请求正文，定义了要创建的项目</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"myProject",
  "description": "my project"
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-delete-project"></a> <span class="term">[删除] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects /</strong></span></span></strong></strong></dt><dd><p><strong><strong>删除存储库中的项目</strong></strong></p><p><strong><strong>返回一个<code class="code">DeleteProjectRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-get-projects"></a> <span class="term">[GET] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects /</strong></span></span></strong></strong></dt><dd><p><strong><strong>获取有关项目的信息</strong></strong></p><p><strong><strong>返回一个<code class="code">Collection<Map<String, String>></code>要么<code class="code">Collection<ProjectResponse></code>实例，具体取决于所使用的JSON序列化库。在<code class="code">Map<String, String></code>实例匹配中的字段<code class="code">ProjectResponse</code>类</strong></strong></p><div class="example"><strong><strong><a id="d0e22701"></a><p class="title"><strong>示例20.6get项目调用的示例（格式化）响应正文</strong></p><div class="example-contents"><pre><code class="no-highlight">[
  {
    "name":"wb-assets",
    "description":"generic assets",
    "groupId":"org.test",
    "version":"1.0"
 },
 {
   "name":"loanProject",
   "description":"Loan processes and rules",
    "groupId":"com.bank",
    "version":"3.7"
 }
]</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd></dl></div></div><div class="section" title="20.1.3。组织单位电话"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e22706"></a> 20.1.3。组织单位电话</strong></strong></h3></div></div></div><p><strong><strong>组织单位调用是对知识存储的调用，该知识存储使您可以管理其组织单位，以组织连接的Git存储库。
          </strong></strong></p><p><strong><strong>下列<code class="code">organizationalUnits</code>提供电话：</strong></strong></p><div class="variablelist"><dl><dt><strong><strong><a id="url-create-org-unit"></a> <span class="term">[POST] <span class="command"><strong>/ organizationalunits</strong></span></span></strong></strong></dt><dd><p><strong><strong>在知识库中创建组织单位</strong></strong></p><p><strong><strong>消耗一个<code class="code">OrganizationalUnit</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">CreateOrganizationalUnitRequest</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22735"></a><p class="title"><strong>示例20.7一个示例（格式化的）请求正文，定义了要创建的新组织单位</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"testgroup",
  "description":"",
  "owner":"tester",
  "repositories":["testGroupRepository"]
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-get-org-unit"></a> <span class="term">[GET] <span class="command"><strong>/ organizationalunits / {orgUnitName}</strong></span></span></strong></strong></dt><dd><p><strong><strong>创建一个组织单位</strong></strong></p><p><strong><strong>消耗一个<code class="code">OrganizationalUnit</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">CreateOrganizationalUnitRequest</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22758"></a><p class="title"><strong>示例20.8一个示例（格式化的）请求正文，定义了要创建的新组织单位</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"testgroup",
  "description":"",
  "owner":"tester",
  "repositories":["testGroupRepository"]
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-update-org-unit"></a> <span class="term">[POST] <span class="command"><strong>/ organizationalunits / {orgUnitName}</strong></span></span></strong></strong></dt><dd><p><strong><strong>在知识库中创建组织单位</strong></strong></p><p><strong><strong>消耗一个<code class="code">UpdateOrganizationalUnit</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">UpdateOrganizationalUnitRequest</code>实例</strong></strong></p><div class="example"><strong><strong><a id="d0e22781"></a><p class="title"><strong>示例20.9一个示例（格式化的）请求正文，定义了要创建的新组织单位</strong></p><div class="example-contents"><pre><code class="no-highlight">{
  "name":"testgroup",
  "description":"",
  "owner":"tester",
  "repositories":["testGroupRepository"]
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></dd><dt><strong><strong><a id="url-remove-org-unit"></a> <span class="term">[删除] <span class="command"><strong>/ organizationalunits / <span class="emphasis"><em>{organizationalUnitName}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>删除组织单位</strong></strong></p><p><strong><strong>返回一个<code class="code">RemoveOrganizationalUnitRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-add-repo-to-org-unit"></a> <span class="term">[POST] <span class="command"><strong>/ organizationalunits / <span class="emphasis"><em>{organizationalUnitName}</em></span> / repositories / <span class="emphasis"><em>{repositoryName}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>将存储库添加到组织单位</strong></strong></p><p><strong><strong>返回一个<code class="code">AddRepositoryToOrganizationalUnitRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-remove-repo-to-org-unit"></a> <span class="term">[删除] <span class="command"><strong>/ organizationalunits / <span class="emphasis"><em>{organizationalUnitName}</em></span> / repositories / <span class="emphasis"><em>{repositoryName}</em></span></strong></span></span></strong></strong></dt><dd><p><strong><strong>从组织单位中删除存储库</strong></strong></p><p><strong><strong>返回一个<code class="code">RemoveRepositoryFromOrganizationalUnitRequest</code>实例</strong></strong></p></dd></dl></div></div><div class="section" title="20.1.4。Maven电话"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e22837"></a> 20.1.4。Maven电话</strong></strong></h3></div></div></div><p><strong><strong>Maven调用是对知识存储中的项目的调用，可让您编译和部署项目资源。</strong></strong></p><p><strong><strong>下列<code class="code">maven</code>提供电话：</strong></strong></p><div class="variablelist"><dl><dt><strong><strong><a id="url-compile-project"></a> <span class="term">[POST] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects / <span class="emphasis"><em>{projectName}</em></span> / maven / compile</strong></span></span></strong></strong></dt><dd><p><strong><strong>编译项目（相当于<code class="code">mvn compile</code> ）</strong></strong></p><p><strong><strong>消耗一个<code class="code">BuildConfig</code>实例。虽然必须提供此文件，但操作不需要它，可以将其留空。</strong></strong></p><p><strong><strong>返回一个<code class="code">CompileProjectRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-install-project"></a> <span class="term">[POST] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects / <span class="emphasis"><em>{projectName}</em></span> / maven / install</strong></span></span></strong></strong></dt><dd><p><strong><strong>安装项目（相当于<code class="code">mvn install</code> ）</strong></strong></p><p><strong><strong>消耗一个<code class="code">BuildConfig</code>实例。虽然必须提供此文件，但操作不需要它，可以将其留空。</strong></strong></p><p><strong><strong>返回一个<code class="code">InstallProjectRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-test-project"></a> <span class="term">[POST] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects / <span class="emphasis"><em>{projectName}</em></span> / maven / test</strong></span></span></strong></strong></dt><dd><p><strong><strong>编译项目作为编译的一部分运行测试</strong></strong></p><p><strong><strong>消耗一个<code class="code">BuildConfig</code>实例</strong></strong></p><p><strong><strong>返回一个<code class="code">TestProjectRequest</code>实例</strong></strong></p></dd><dt><strong><strong><a id="url-deploy-project"></a> <span class="term">[POST] <span class="command"><strong>/ repositories / <span class="emphasis"><em>{repositoryName}</em></span> / projects / <span class="emphasis"><em>{projectName}</em></span> / maven / deploy</strong></span></span></strong></strong></dt><dd><p><strong><strong>部署项目（相当于<code class="code">mvn deploy</code> ）</strong></strong></p><p><strong><strong>消耗一个<code class="code">BuildConfig</code>实例。虽然必须提供此文件，但操作不需要它，可以将其留空。</strong></strong></p><p><strong><strong>返回一个<code class="code">DeployProjectRequest</code>实例</strong></strong></p></dd></dl></div></div><div class="section" title="20.1.5。REST摘要"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e22953"></a> 20.1.5。REST摘要</strong></strong></h3></div></div></div><p><strong><strong>下表中的URL模板是相对于以下URL的：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong> 
              <code class="code">http://server:port/business-central/rest</code>
            </strong></strong></p></li></ul></div><p><strong><strong>
      </strong></strong></p><div class="table"><strong><strong><a id="kstore_rest_api_calls"></a><p class="title"><strong>表20.1。知识库REST调用</strong></p><div class="table-contents"><table border="1" summary="Knowledge Store REST calls"><colgroup><col width="62*" align="left" class="c1"><col width="8*" align="left" class="c2"><col width="30*" align="left" class="c3"></colgroup><thead><tr><th align="left">网址模板</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr valign="top"><td align="left" valign="top">/ jobs / {jobID}</td><td align="left" valign="top">得到</td><td align="left" valign="top">返回工作状态</td></tr><tr valign="top"><td align="left" valign="top">/ jobs / {jobID}</td><td align="left" valign="top">删除</td><td align="left" valign="top">删除工作</td></tr><tr valign="top"><td align="left" valign="top">/ organizationalunits</td><td align="left" valign="top">得到</td><td align="left" valign="top">返回组织单位列表</td></tr><tr valign="top"><td align="left" valign="top">/ organizationalunits</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">
              <p>在JSON描述的知识库中创建组织单位<code class="code">OrganizationalUnit</code>实体</p>
            </td></tr><tr valign="top"><td align="left" valign="top">/ organizationalunits / {organizationalUnitName} /存储库/ {repositoryName}</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">将存储库添加到组织单位</td></tr><tr valign="top"><td align="left" valign="top">/ organizationalunits / {organizationalUnitName} /存储库/ {repositoryName}</td><td align="left" valign="top">删除</td><td align="left" valign="top">从组织单位中删除存储库</td></tr><tr valign="top"><td align="left" valign="top">/存储库/</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">
              <p>将存储库添加到JSON描述的组织单位<code class="code">RepositoryReqest</code>实体</p>
            </td></tr><tr valign="top"><td align="left" valign="top">/存储库</td><td align="left" valign="top">得到</td><td align="left" valign="top">返回知识库中的存储库</td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName}</td><td align="left" valign="top">删除</td><td align="left" valign="top">从知识库中删除存储库</td></tr><tr valign="top"><td align="left" valign="top">/存储库/</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">创建或克隆JSON定义的存储库<code class="code">RepositoryRequest</code>实体</td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName} / projects /</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">在存储库中创建由JSON实体定义的项目</td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName} / projects / {projectName} / maven / compile /</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">编译项目</td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName} / projects / {projectName} / maven / install</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">安装项目</td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName} / projects / {projectName} / maven / test /</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">
              <p>编译项目并运行测试作为编译的一部分</p>
            </td></tr><tr valign="top"><td align="left" valign="top">/ repositories / {repositoryName} / projects / {projectName} / maven / deploy /</td><td align="left" valign="top">开机自检</td><td align="left" valign="top">部署项目</td></tr></tbody></table></div></strong></strong></div><strong><strong><br class="table-break"></strong></strong></div></div><div class="section" title="20.2。Keycloak SSO集成"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="kie.KeycloakSSOIntegration"></a> 20.2。Keycloak SSO集成</strong></strong></h2></div></div></div><p><strong><strong>单一登录（SSO）和相关令牌交换机制正在成为Web上不同环境中进行身份验证和授权的最常见方案，尤其是在迁移到云中时。</strong></strong></p><p><strong><strong>本节讨论Keycloak与jBPM或Drools应用程序的集成，以便使用Keycloak上提供的所有功能。Keycloak是用于浏览器应用程序和RESTful Web服务的集成SSO和IDM。在<a class="link" href="http://keycloak.jboss.org/">Keycloak的主页上</a>进一步了解它。</strong></strong></p><p><strong><strong>与Keycloak集成的结果具有许多优势，例如：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>为包括jBPM和Drools工作台在内的不同客户提供集成的SSO和IDM环境</strong></strong></p></li><li class="listitem"><p><strong><strong>社交登录-使用您的Facebook，Google，Linkedin等帐户</strong></strong></p></li><li class="listitem"><p><strong><strong>用户会话管理</strong></strong></p></li><li class="listitem"><p><strong><strong>以及更多...</strong></strong></p></li></ul></div><p><strong><strong>下一节将介绍Keycloak的以下集成点：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><strong>通过Keycloak服务器进行工作台身份验证</strong></span></strong></strong></p><p><strong><strong>它基本上包括通过Keycloak SSO保护Web客户端和远程服务客户端的安全。因此，Web界面或远程服务使用者（无论是用户还是服务）都将通过KC进行身份验证。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>通过Keycloak服务器进行执行服务器身份验证</strong></span></strong></strong></p><p><strong><strong>包括保护执行服务器提供的远程服务（因为它不提供Web界面）。任何远程服务使用者（无论是用户还是服务）都将通过KC验证身份。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><strong>消费远程服务</strong></span></strong></strong></p><p><strong><strong>本节描述第三方客户端如何使用由Workbench和Execution Server提供的远程服务端点，例如REST API或远程文件系统服务。</strong></strong></p></li></ul></div><div class="section" title="20.2.1。情境"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23153"></a> 20.2.1。情境</strong></strong></h3></div></div></div><p><strong><strong>考虑以下图表作为本文档示例的环境：</strong></strong></p><p><strong><strong>Keycloak是一个独立的过程，提供远程身份验证，授权和管理服务，这些服务可能会被一个或多个jBPM应用程序通过网络使用。</strong></strong></p><div class="figure"><strong><strong><a id="d0e23160"></a><p class="title"><strong>图20.1</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/KeycloakSSOIntegration/KeyCloak_sso_scenario.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>考虑以下用于构建此环境的主要步骤：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>安装和设置Keycloak服务器</p></li><li class="listitem"><p>为此示例创建和设置领域-配置领域的客户端，用户和角色</p></li><li class="listitem"><p>安装和设置SSO客户端适配器和jBPM应用程序</p></li></ul></div><p>注意：最终的环境和本文档的不同配置均基于jBPM（KIE）工作台，但是相同的环境也可以应用于KIE Drools工作台。</p></strong></strong></div><div class="section" title="20.2.2。安装和设置Keycloak服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23178"></a> 20.2.2。安装和设置Keycloak服务器</strong></strong></h3></div></div></div><p><strong><strong>Keycloak提供了广泛的文档以及有关在不同环境中进行安装的几篇文章。本节介绍了用于构建示例的集成环境的最小设置。如果需要更多信息，请参考<a class="link" href="http://keycloak.jboss.org/docs">Keycloak文档</a> 。</strong></strong></p><p><strong><strong>以下是最小化Keycloak安装和设置的步骤：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>从<a class="link" href="http://keycloak.jboss.org/downloads">下载</a>部分下载最新版本的Keycloak。本示例基于Keycloak 1.9.0。最后</strong></strong></p></li><li class="listitem"><p><strong><strong>将下载的Keycloak发行版解压缩到一个文件夹中，我们将其称为</strong></strong></p><pre><code class="no-highlight">$KC_HOME</code></pre></li><li class="listitem"><p><strong><strong>运行KC服务器-此示例基于在同一主机上同时运行Keycloak和jBPM。为了避免端口冲突，可以将Keycloak服务器的端口偏移量用作：</strong></strong></p><p><strong><strong>
            </strong></strong></p><pre><code class="no-highlight">$KC_HOME/bin/standalone.sh -Djboss.socket.binding.port-offset=100</code></pre><p><strong><strong>
          </strong></strong></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>创建Keycloak的管理用户-执行以下命令以创建此示例的管理员用户：</strong></strong></p><p><strong><strong>
            </strong></strong></p><pre><code class="no-highlight">$KC_HOME/bin/add-user.sh -r master -u 'admin' -p 'admin'</code></pre><p><strong><strong>
          </strong></strong></p></li></ul></div><p><strong><strong>Keycloak管理控制台将位于<a class="link" href="http://localhost:8180/auth/admin">http：// localhost：8180 / auth / admin</a> （使用admin / admin作为登录凭据）。</strong></strong></p></div><div class="section" title="20.2.3。创建并设置演示领域"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23222"></a> 20.2.3。创建并设置演示领域</strong></strong></h3></div></div></div><p><strong><strong>安全领域用于限制对不同应用程序资源的访问。</strong></strong></p><p><strong><strong>Keycloak服务器运行之后，下一步就是创建领域。该领域将为jBPM应用程序提供不同的用户，角色，会话等。</strong></strong></p><p><strong><strong>Keycloak提供了几个领域创建和管理的<a class="link" href="https://github.com/keycloak/keycloak/tree/master/examples">示例</a> ，从<a class="link" href="https://github.com/keycloak/keycloak/tree/master/examples">官方示例</a>到带有更多示例的不同文章。</strong></strong></p><p><strong><strong>请按照以下步骤操作，以创建本文档稍后使用的<span class="italic">演示</span>领域：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>转到Keycloak <a class="link" href="http://localhost:8180/auth/admin">管理控制台</a> ，然后单击“ <span class="italic">添加领域”</span>按钮。给它命名为<span class="italic">demo</span> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>转到“客户端”部分（从管理控制台主菜单），然后为<span class="italic">演示</span>领域创建一个新客户端：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>客户编号： <span class="emphasis"><em>kie</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>客户端协议： <span class="emphasis"><em>openid-connect</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>帐户类型： <span class="emphasis"><em>机密</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>根URL： <span class="emphasis"><em>http：// localhost：8080</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>基本网址： <span class="italic">/kie-wb-6.4.0。最后</span></strong></strong></p></li><li class="listitem"><p><strong><strong>重定向URI： <span class="italic">/kie-wb-6.4.0。最后/*</span></strong></strong></p></li></ul></div></li></ul></div><p><strong><strong>生成的<span class="italic">kie</span>客户端设置屏幕：</strong></strong></p><div class="figure"><strong><strong><a id="d0e23294"></a><p class="title"><strong>图20.2。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/KeycloakSSOIntegration/kie_client_settings.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p><span class="underline">注意</span> ：如您在上述设置中所看到的，它被认为是值<span class="italic">kie-wb-6.4.0。应用程序上下文路径的最终</span>值。如果您的jbpm应用程序将部署在其他上下文路径，主机或端口上，请在此处使用您的具体设置。</p><p>能够使用jBPM工作台中的<span class="italic">演示</span>领域的最后一步是创建应用程序的用户和角色：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>转到“角色”部分，并创建角色<span class="italic">admin，</span> <span class="italic">kimggmt</span>和<span class="italic">rest-all</span></p></li><li class="listitem"><p>转到“用户”部分并创建<span class="italic">管理员</span>用户。在“凭据”选项卡中设置值为“ password”的密码，然后取消设置临时开关。</p></li><li class="listitem"><p>在“用户”部分中，导航到“ <span class="italic">角色映射”</span>选项卡，然后将<span class="italic">admin，</span> <span class="italic">kiegmmt</span>和<span class="italic">rest-all</span>角色分配给<span class="italic">admin</span>用户</p><div class="figure"><a id="d0e23345"></a><p class="title"><strong>图20.3。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/KeycloakSSOIntegration/admin_user_roles.png"></div></div></div><br class="figure-break"></li></ul></div><p>此时，Keycloak服务器正在主机上运行，使用最小配置集进行设置。让我们转到jBPM工作台设置。</p></strong></strong></div><div class="section" title="20.2.4。安装和设置jBPM Workbench"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23351"></a> 20.2.4。安装和设置jBPM Workbench</strong></strong></h3></div></div></div><p><strong><strong>对于本教程，让我们将Wildfly用作jBPM工作台的应用程序服务器，就像jBPM安装程序默认情况下那样。</strong></strong></p><p><strong><strong>让我们假设，在运行jBPM安装程序之后，将<span class="italic">$ JBPM_HOME</span>作为已部署应用程序的Wildfly服务器的根路径。</strong></strong></p><div class="section" title="20.2.4.1。安装KC适配器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23361"></a> 20.2.4.1。安装KC适配器</strong></strong></h4></div></div></div><p><strong><strong>为了使用jBPM应用程序中的<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html">Keycloak</a>身份验证和授权模块，必须在<span class="italic">$ JBPM_HOME</span>的服务器上安装Wildfly的<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html">Keycloak适配器</a> 。 Keycloak开箱即用为不同容器提供了多个适配器，如果您正在使用另一个容器或需要使用另一个适配器，请查看Keycloak文档中的<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html">适配器配置</a> 。以下是安装和设置Wildfly 8.2.x适配器的步骤：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>从<a class="link" href="https://repository.jboss.org/nexus/service/local/repositories/central/content/org/keycloak/keycloak-wf8-adapter-dist/1.9.0.Final/keycloak-wf8-adapter-dist-1.9.0.Final.zip">此处</a>下载适配器</strong></strong></p></li><li class="listitem"><p><strong><strong>在您的外壳上执行以下命令：</strong></strong></p><p><strong><strong>
              </strong></strong></p><pre><code class="no-highlight">cd $JBPM_HOME/unzip keycloak-wf8-adapter-dist.zip // Install the KC client adapter

cd $JBPM_HOME/bin
./standalone.sh -c standalone-full.xml // Setup the KC client adapter.

// ** Once server is up, open a new command line terminal and run:
cd $JBPM_HOME/bin
./jboss-cli.sh -c --file=adapter-install.cli</code></pre><p><strong><strong>
            </strong></strong></p></li></ul></div></div><div class="section" title="20.2.4.2。配置KC适配器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23389"></a> 20.2.4.2。配置KC适配器</strong></strong></h4></div></div></div><p><strong><strong>将KC适配器安装到Wildfly中之后，下一步就是配置适配器，以指定不同的设置，例如身份验证服务器的位置，要使用的领域等。</strong></strong></p><p><strong><strong>Keycloak提供了两种配置适配器的方式：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>每个WAR配置</strong></strong></p></li><li class="listitem"><p><strong><strong>通过Keycloak子系统</strong></strong></p></li></ul></div><p><strong><strong>在此示例中，让我们使用第二个选项，使用Keycloak子系统，因此我们的WAR不受这种设置的影响。如果您想使用per WAR方法，请<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html#d4e932">在此处查看</a> 。</strong></strong></p><p><strong><strong>编辑配置文件<span class="italic">$ JBPM_HOME / standalone / configuration / standalone-full.xml</span>并找到子系统配置部分。添加以下内容：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">&lt;subsystem xmlns="urn:jboss:domain:keycloak:1.1"&gt;
  &lt;secure-deployment name="kie-wb-6.4.0-Final.war"&gt;
    &lt;realm&gt;demo&lt;/realm&gt;
    &lt;realm-public-key&gt;MIIBIjANBgkqhkiG9w0BAQEFAAOCA...&lt;/realm-public-key&gt;
    &lt;auth-server-url&gt;http://localhost:8180/auth&lt;/auth-server-url&gt;
    &lt;ssl-required&gt;external&lt;/ssl-required&gt;
    &lt;resource&gt;kie&lt;/resource&gt;
    &lt;enable-basic-auth&gt;true&lt;/enable-basic-auth&gt;
    &lt;credential name="secret"&gt;925f9190-a7c1-4cfd-8a3c-004f9c73dae6&lt;/credential&gt;
    &lt;principal-attribute&gt;preferred_username&lt;/principal-attribute&gt;
  &lt;/secure-deployment&gt;
&lt;/subsystem&gt;</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong>如果您在<span class="italic">步骤2中</span>从本文档中导入了示例json文件，则可以通过使用具体的部署名称来使用与上述相同的配置。否则，请使用您的值进行以下配置：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="underline">安全部署的名称</span> -使用具体应用程序的WAR文件名</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">领域</span> -应用程序将使用的领域，在我们的示例中， <span class="italic">演示</span>领域是上一步创建的。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">领域公钥</span> -在此处提供<span class="italic">演示</span>领域的公钥。它不是强制性的，如果未指定，将从服务器中检索它。否则，您可以在Keycloak管理控制台->领域设置（用于<span class="italic">演示</span>领域）->密钥中找到它</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">身份验证服务器URL</span> -Keycloak的身份验证服务器的URL</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">资源</span> -在步骤2中创建的客户端的名称。在我们的示例中，使用值<span class="italic">kie</span> 。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">启用基本身份验证</span> -在此示例中，我们还启用基本身份验证机制，因此客户端可以同时使用令牌（Baerer）和基本方法来执行请求。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="underline">凭据</span> -使用<span class="italic">kie</span>客户端的密码值。您可以在Keycloak管理控制台->客户端-> kie->凭据选项卡->复制<span class="italic">密钥</span>值中找到它。</strong></strong></p></li></ul></div><p><strong><strong>对于此示例，您必须注意将您的具体值用于<span class="italic">安全部署名称</span> ， <span class="italic">realm-public-key</span>和<span class="italic">凭据</span>密码。您可以<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html#adapter-config">在此处</a>找到有关KC适配器配置的详细信息。</strong></strong></p></div><div class="section" title="20.2.4.3。运行环境"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23491"></a> 20.2.4.3。运行环境</strong></strong></h4></div></div></div><p><strong><strong>此时，Keycloak服务器已在主机上启动并运行，并且已为jBPM应用程序服务器安装并配置了KC适配器。您可以使用以下命令运行该应用程序：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">$JBPM_HOME/bin/standalone.sh -c standalone-full.xml</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong>服务器启动后，您可以导航到该应用程序：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight"> <a class="link" href="http://localhost:8080/kie-wb-6.4.0.Final">http://localhost:8080/kie-wb-6.4.0.Final</a></code></pre><p><strong><strong>
      </strong></strong></p><div class="figure"><strong><strong><a id="d0e23510"></a><p class="title"><strong>图20.4。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/KeycloakSSOIntegration/jbpm_login_screen.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>使用Keycloak的管理员用户凭据登录： <span class="italic">admin / password</span> 。</p></strong></strong></div></div><div class="section" title="20.2.5。通过Keycloak保护工作台远程服务"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23519"></a> 20.2.5。通过Keycloak保护工作台远程服务</strong></strong></h3></div></div></div><p><strong><strong>jBPM和Drools工作台均提供了不同的远程服务端点，第三方客户端可以使用<a class="link" href="http://docs.jboss.org/jbpm/v6.3/userguide/ch17.html">远程API</a>来使用这些端点。</strong></strong></p><p><strong><strong>为了通过Keycloak验证这些服务，必须禁用<span class="italic">BasicAuthSecurityFilter</span> ，对jBPM的WAR文件中的<span class="italic">WEB-INF / web.xml</span>文件（应用程序部署描述符）进行那些修改：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>从部署描述符中删除以下过滤器：</strong></strong></p><p><strong><strong>
            </strong></strong></p><pre><code class="no-highlight">&lt;filter&gt;  
  &lt;filter-name&gt;HTTP Basic Auth Filter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.uberfire.ext.security.server.BasicAuthSecurityFilter&lt;/filter-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;realmName&lt;/param-name&gt;
    &lt;param-value&gt;KIE Workbench Realm&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;HTTP Basic Auth Filter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
  &lt;url-pattern&gt;/maven2/*&lt;/url-pattern&gt;
  &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre><p><strong><strong>
          </strong></strong></p></li><li class="listitem"><p><strong><strong>将远程服务URL模式限制为：</strong></strong></p><p><strong><strong>
            </strong></strong></p><pre><code class="no-highlight">&lt;security-constraint&gt;
  &lt;web-resource-collection&gt;
    &lt;web-resource-name&gt;remote-services&lt;/web-resource-name&gt;
    &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
    &lt;url-pattern&gt;/maven2/*&lt;/url-pattern&gt;
    &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;role-name&gt;rest-all&lt;/role-name&gt;
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;</code></pre><p><strong><strong>
          </strong></strong></p></li></ul></div><p><strong><strong><span class="underline">重要说明</span> ：使用远程服务的用户必须是角色<span class="italic">rest-all的</span>成员。如前面的步骤所述，该示例中的<span class="italic">admin</span>用户已经是<span class="italic">rest-all</span>角色的成员。</strong></strong></p></div><div class="section" title="20.2.6。通过Keycloak保护工作台的文件系统服务"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23565"></a> 20.2.6。通过Keycloak保护工作台的文件系统服务</strong></strong></h3></div></div></div><p><strong><strong>为了使用其他远程服务，例如文件系统服务（例如，远程GIT）， <span class="bold"><strong>必须</strong></span>在<span class="italic">$ JBPM_HOME / standalone / configuration / standalone-full.xml</span>文件<span class="italic">中将</span>特定的<span class="bold"><strong>Keycloak登录模块用于</strong></span>应用程序的安全域。默认情况下，工作台使用<span class="italic">其他</span>安全域，因此<span class="italic">$ JBPM_HOME / standalone / configuration / standalone-full.xml</span>上的最终配置应如下所示：</strong></strong></p><pre><code class="no-highlight">
      &lt;security-domain name="other" cache-type="default"&gt;
        &lt;authentication&gt;
          &lt;login-module code="org.keycloak.adapters.jaas.DirectAccessGrantsLoginModule" flag="required"&gt;
            &lt;!-- Parameter value can be a file system absolute path or a classpath (e.g. "classpath:/some-path/kie-git.json")--&gt;
            &lt;module-option name="keycloak-config-file" value="$JBPM_HOME/kie-git.json"/&gt;
          &lt;/login-module&gt;
        &lt;/authentication&gt;
      &lt;/security-domain&gt;
    </code></pre><p><strong><strong>注意：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="italic">$ JBPM_HOME / standalone / configuration / standalone-full.xml</span>文件中<span class="italic">另一个</span>安全域上的登录模块必须由上述给定的替换。</strong></strong></p></li><li class="listitem"><p><strong><strong>将<span class="italic">$ JBPM_HOME / kie-git.json</span>替换<span class="italic">为</span>用于远程服务客户端的json配置文件的路径（在文件系统上）或classpath（例如， <span class="italic">classpath：/some-path/kie-git.json</span> ）。请继续阅读以创建此Keycloak客户端以及如何获取此json文件。</strong></strong></p></li></ul></div><p><strong><strong>此时，Keycloak使用上述json配置文件中指定的客户端来保护使用JAAS进行身份验证过程的远程服务，例如文件系统服务（例如GIT）。因此，让我们在Keycloak上创建此客户端并生成所需的JSON文件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>导航到<a class="link" href="http://localhost:8180/auth/admin">KC管理控制台，</a>并使用<span class="italic">kie-git</span>作为名称为<span class="italic">演示</span>领域创建一个新客户端。</strong></strong></p></li><li class="listitem"><p><strong><strong>启用“启用<span class="italic">直接访问授权”</span>选项，禁用<span class="italic">“启用标准流”，</span>并为此客户端使用<span class="italic">机密</span>访问类型。参见下图示例：</strong></strong></p><div class="figure"><strong><strong><a id="d0e23632"></a><p class="title"><strong>图20.5。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Workbench/KeycloakSSOIntegration/kie_git_client_settings.png"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></li><li class="listitem"><p><strong><strong>转到同一<span class="italic">kie-git</span>客户端配置屏幕中的“ <span class="italic">安装”</span>选项卡，然后使用<span class="italic">Keycloak OIDC JSON</span>类型导出。</strong></strong></p></li><li class="listitem"><p><strong><strong>最后，将此生成的JSON文件复制到服务器文件系统上的可访问目录中，或将其添加到应用程序的类路径中。使用此路径值作为<span class="italic">org.keycloak.adapters.jaas</span>的上述配置的<span class="italic">keycloak-config-file</span>参数<span class="italic">。DirectAccessGrantsLoginModule</span>登录模块。
        </strong></strong></p></li><li class="listitem"><p><strong><strong>有关Keycloak JAAS登录模块的更多信息，请参见<a class="link" href="https://keycloak.gitbooks.io/securing-client-applications-guide/content/v/2.2/topics/oidc/java/jaas.html">此处</a> 。</strong></strong></p></li></ul></div><p><strong><strong>此时，所有通过Keycloak服务器认证的用户都可以克隆内部Git存储库。命令示例：</strong></strong></p><pre><code class="no-highlight">git clone ssh://admin@localhost:8001/system</code></pre><p><strong><strong>
    </strong></strong></p></div><div class="section" title="20.2.7。执行服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23668"></a> 20.2.7。执行服务器</strong></strong></h3></div></div></div><p><strong><strong>KIE Execution Server提供的<a class="link" href="https://docs.jboss.org/drools/release/latest/drools-docs/html/ch22.html">REST API</a>比任何第三方客户端都可以使用。本节介绍如何将KIE Execution Server与Keycloak SSO集成在一起，以便将第三方客户端身份管理委派给SSO服务器。</strong></strong></p><p><strong><strong>考虑到以上环境正在运行，因此请考虑具有以下条件：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>在http：// localhost：8180 / auth上运行并侦听的Keycloak服务器</strong></strong></p></li><li class="listitem"><p><strong><strong>一个名为<span class="italic">demo</span>的领域，其jBPM Workbench的客户端名为<span class="italic">kie</span></strong></strong></p></li><li class="listitem"><p><strong><strong>一个运行在http：// localhost：8080 / kie-wb-6.4.0-Final的jBPM Workbench</strong></strong></p></li></ul></div><p><strong><strong>请按照以下步骤将执行服务器添加到此环境中：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>在Keycloak上为执行服务器创建客户端</strong></strong></p></li><li class="listitem"><p><strong><strong>安装安装程序和执行服务器（带有KC客户端适配器）</strong></strong></p></li></ul></div><div class="section" title="20.2.7.1。在Keycloak上创建执行服务器的客户端"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23703"></a> 20.2.7.1。在Keycloak上创建执行服务器的客户端</strong></strong></h4></div></div></div><p><strong><strong>根据要部署的每个执行服务器，您必须在Keycloak的<span class="italic">演示</span>领域上创建一个新客户端。</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>转到<a class="link" href="https://mojo.redhat.com/external-link.jspa?url=http%3A%2F%2Flocalhost%3A8180%2Fauth%2Fadmin">KC管理控制台</a> ->客户端->新客户端</strong></strong></p></li><li class="listitem"><p><strong><strong>名称： <span class="italic">kie-execution-server</span></strong></strong></p></li><li class="listitem"><p><strong><strong>根URL： <span class="emphasis"><em>http：// localhost：8280 /</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>客户端协议： <span class="emphasis"><em>openid-connect</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>访问类型： <span class="emphasis"><em>机密</em></span> （如果需要，可以是<span class="emphasis"><em>公开的</em></span> ，但在生产环境中不建议使用）</strong></strong></p></li><li class="listitem"><p><strong><strong>有效的重定向URI： <span class="emphasis"><em>/kie-server-6.4.0。最后/*</em></span></strong></strong></p></li><li class="listitem"><p><strong><strong>基本网址： <span class="emphasis"><em>/kie-server-6.4.0。最后</em></span></strong></strong></p></li></ul></div><p><strong><strong>在此示例中，先前步骤中已经创建的<span class="italic">管理员</span>用户是用于客户端请求的<span class="italic">管理员</span>用户。因此，请确保<span class="italic">管理员</span>用户是角色<span class="italic">kie-server的</span>成员，以便使用执行服务器的远程服务。如果角色不存在，请创建它。</strong></strong></p><p><strong><strong>注意：此示例认为执行服务器将配置为使用200端口偏移量运行，因此HTTP端口可在localhost：8280处使用。</strong></strong></p></div><div class="section" title="20.2.7.2。在执行服务器上安装和设置KC适配器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23765"></a> 20.2.7.2。在执行服务器上安装和设置KC适配器</strong></strong></h4></div></div></div><p><strong><strong>此时，一个名为<span class="italic">kie-execution-server</span>的客户端已准备就绪，可以在KC服务器上从执行服务器上使用。</strong></strong></p><p><strong><strong>让我们安装，设置和部署执行服务器：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>安装另一个Wildfly服务器以用于执行服务器和KC客户端适配器。您可以按照上面有关工作台的说明进行操作，也可以遵循<a class="link" href="https://keycloak.github.io/docs/userguide/keycloak-server/html/ch08.html">官方适配器文档</a></strong></strong></p></li><li class="listitem"><p><strong><strong>从Wildfly服务器的配置路径中编辑<span class="italic">standalone-full.xml</span>文件，并将KC子系统适配器配置为：</strong></strong></p><p><strong><strong>
              </strong></strong></p><pre><code class="no-highlight">&lt;secure-deployment name="kie-server-6.4.0.Final.war"&gt;
    &lt;realm&gt;demo&lt;/realm&gt;
    &lt;realm-public-key&gt;MIGfMA0GCSqGSIb...&lt;/realm-public-key&gt;
    &lt;auth-server-url&gt;http://localhost:8180/auth&lt;/auth-server-url&gt;
    &lt;ssl-required&gt;external&lt;/ssl-required&gt;
    &lt;resource&gt;kie-execution-server&lt;/resource&gt;
    &lt;enable-basic-auth&gt;true&lt;/enable-basic-auth&gt;
    &lt;credential name="secret"&gt;e92ec68d-6177-4239-be05-28ef2f3460ff&lt;/credential&gt;
    &lt;principal-attribute&gt;preferred_username&lt;/principal-attribute&gt;
&lt;/secure-deployment&gt;</code></pre><p><strong><strong>
            </strong></strong></p></li></ul></div><p><strong><strong>如果与本示例不同，请考虑您的具体环境设置：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>安全部署名称->使用正在部署的执行服务器war文件的名称</strong></strong></p></li><li class="listitem"><p><strong><strong>公钥->使用演示领域公钥或将其保留为空白，如果是这样，服务器将提供一个</strong></strong></p></li><li class="listitem"><p><strong><strong>资源->这次，而不是WB配置中使用的<span class="italic">kie</span>客户端，使用<span class="italic">kie-execution-server</span>客户端</strong></strong></p></li><li class="listitem"><p><strong><strong>启用基本身份验证->由您决定。您可以为第三方服务使用者启用基本身份验证</strong></strong></p></li><li class="listitem"><p><strong><strong>凭据->将密钥用于<span class="italic">kie-execution-server</span>客户端。您可以在KC管理控制台的“ <span class="italic">凭据”</span>标签中找到它</strong></strong></p></li></ul></div></div><div class="section" title="20.2.7.3。部署并运行执行服务器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23819"></a> 20.2.7.3。部署并运行执行服务器</strong></strong></h4></div></div></div><p><strong><strong>只需使用任何可用机制在Wildfly中部署执行服务器即可。使用以下命令运行执行服务器：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">$EXEC_SERVER_HOME/bin/standalone.sh -c standalone-full.xml -Djboss.socket.binding.port-offset=200 -Dorg.kie.server.id=&lt;ID&gt; -Dorg.kie.server.user=&lt;USER&gt; -Dorg.kie.server.pwd=&lt;PWD&gt; -Dorg.kie.server.location=&lt;LOCATION_URL&gt;  -Dorg.kie.server.controller=&lt;CONTROLLER_URL&gt; -Dorg.kie.server.controller.user=&lt;CONTROLLER_USER&gt; -Dorg.kie.server.controller.pwd=&lt;CONTOLLER_PASSWORD&gt;</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong>例：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">$EXEC_SERVER_HOME/bin/standalone.sh -c standalone-full.xml -Djboss.socket.binding.port-offset=200 -Dorg.kie.server.id=kieserver1 -Dorg.kie.server.user=admin -Dorg.kie.server.pwd=password -Dorg.kie.server.location=http://localhost:8280/kie-server-6.4.0.Final/services/rest/server -Dorg.kie.server.controller=http://localhost:8080/kie-wb-6.4.0.Final/rest/controller -Dorg.kie.server.controller.user=admin -Dorg.kie.server.controller.pwd=password</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong><span class="underline">重要说明</span> ：将使用执行服务器远程服务端点的用户必须具有分配的角色kie-server。因此，在KC管理控制台中为将使用执行服务器远程服务的用户创建并分配此角色。</strong></strong></p><p><strong><strong>一旦启动，您可以将服务器状态检查为（考虑到对此请求使用基本身份验证，请参阅下一个使用<span class="italic">远程服务</span>以获取更多信息）：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">curl http://admin:password@localhost:8280/kie-server-6.4.0.Final/services/rest/server/</code></pre><p><strong><strong>
      </strong></strong></p></div></div><div class="section" title="20.2.8。消费远程服务"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e23850"></a> 20.2.8。消费远程服务</strong></strong></h3></div></div></div><p><strong><strong>为了使用Workbench或Execution Server提供的不同远程服务，您的客户端必须在KC服务器上进行身份验证并具有有效的令牌才能执行请求。</strong></strong></p><p><strong><strong>请记住，为了使用远程服务，经过身份验证的用户必须已分配：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>使用WB远程服务<span class="italic">的所有</span>角色</strong></strong></p></li><li class="listitem"><p><strong><strong>角色<span class="italic">kie-server，</span>用于使用Execution Server远程服务</strong></strong></p></li></ul></div><p><strong><strong>请确保创建了必要的角色并将其分配给将在Keycloak管理控制台上使用远程服务的用户。</strong></strong></p><p><strong><strong>您有两个选择可以使用不同的删除服务端点：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>如果应用程序的客户端支持基本身份验证，则使用它</strong></strong></p></li><li class="listitem"><p><strong><strong>使用基于承载（令牌）的身份验证</strong></strong></p></li></ul></div><div class="section" title="20.2.8.1。使用基本身份验证"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23881"></a> 20.2.8.1。使用基本身份验证</strong></strong></h4></div></div></div><p><strong><strong>如果KC客户端适配器配置启用了基本身份验证（如本指南中针对WB（ <span class="italic">步骤3.2</span> ）和Execution Server所建议的那样），则可以避免令牌授予/刷新调用，而只需调用服务即可，如以下示例所示。</strong></strong></p><p><strong><strong>WB远程存储库端点的示例：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">curl http://admin:password@localhost:8080/kie-wb-6.4.0.Final/rest/repositories</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong>检查执行服务器状态的示例：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">curl http://admin:password@localhost:8280/kie-server-6.4.0.Final/services/rest/server/</code></pre><p><strong><strong>
      </strong></strong></p></div><div class="section" title="20.2.8.2。使用基于令牌的身份验证"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e23903"></a> 20.2.8.2。使用基于令牌的身份验证</strong></strong></h4></div></div></div><p><strong><strong>第一步是在Keycloak上创建一个新客户端，该客户端允许第三方远程服务客户端获取令牌。可以通过以下方式完成：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>转到KC管理控制台，然后使用以下配置创建<span class="underline">新客户端</span> ：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>客户编号： <span class="italic">kie-remote</span></strong></strong></p></li><li class="listitem"><p><strong><strong>客户端协议： <span class="italic">openid-connect</span></strong></strong></p></li><li class="listitem"><p><strong><strong>访问类型： <span class="italic">公共</span></strong></strong></p></li><li class="listitem"><p><strong><strong>有效的重定向URI： <span class="italic">http：// localhost /</span></strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong>当我们要手动获取令牌并调用服务时，让我们稍微延长令牌的寿命。在生产访问令牌中，令牌应具有相对较低的超时，最好少于5分钟：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>转到KC管理控制台</strong></strong></p></li><li class="listitem"><p><strong><strong>单击您的领域设置</strong></strong></p></li><li class="listitem"><p><strong><strong>单击令牌选项卡</strong></strong></p></li><li class="listitem"><p><strong><strong>将“访问令牌寿命”的值更改为15分钟（这将使我们有足够的时间获取令牌并在服务到期之前调用服务）</strong></strong></p></li></ul></div></li></ul></div><p><strong><strong>一旦为我们的远程客户端创建了公共客户端，您现在就可以通过对KC服务器的令牌端点执行HTTP请求来获取令牌。这是命令行示例：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">RESULT=`curl --data "grant_type=password&amp;client_id=kie-remote&amp;username=admin&amp;passwordpassword=&lt;the_client_secret&gt;" http://localhost:8180/auth/realms/demo/protocol/openid-connect/token`</code></pre><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">TOKEN=`echo $RESULT | sed 's/.*access_token":"//g' | sed 's/".*//g'`</code></pre><p><strong><strong>
      </strong></strong></p><p><strong><strong>此时，如果您回显<span class="italic">$ TOKEN</span> ，它将输出从KC服务器获得的令牌字符串，该令牌字符串现在可用于授权对远程端点的进一步调用。例如，如果要检查内部jBPM存储库：</strong></strong></p><p><strong><strong>
        </strong></strong></p><pre><code class="no-highlight">curl -H "Authorization: bearer $TOKEN" http://localhost:8080/kie-wb-6.4.0.Final/rest/repositories</code></pre><p><strong><strong>
      </strong></strong></p></div></div></div></div><div class="chapter" title="第21章工作台高可用性"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="wb.WorkbenchHighAvailability"></a>第21章工作台高可用性</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#wb.HighAvailability">21.1。</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#wb.vfsClustering">21.1.1。VFS群集</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24193">21.1.2。 jBPM集群</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="21.1。"><div class="titlepage"></div><div class="section" title="21.1.1。VFS群集"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="wb.vfsClustering"></a> 21.1.1。VFS群集</strong></strong></h3></div></div></div><p><strong><strong><a class="link" href="#wb.VFSRepository" title="18.3.3。储存库">VFS存储库</a> （通常是git存储库）存储所有资产（例如规则，决策表，流程定义，表单等）。如果该VFS驻留在每个本地服务器上，则必须在群集的所有服务器之间使其保持同步。</strong></strong></p><p><strong><strong>使用<a class="link" href="http://zookeeper.apache.org/">Apache Zookeeper</a>和<a class="link" href="http://helix.incubator.apache.org/">Apache Helix</a>完成此任务。Zookeeper将所有零件粘合在一起。Helix是群集管理组件，用于注册所有群集详细信息（节点，资源和群集本身）。Uberfire（在其上构建Workbench的基础上）使用这两个组件来提供VFS集群。</strong></strong></p><p><strong><strong>要创建VFS集群：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>下载<a class="link" href="http://zookeeper.apache.org/">Apache Zookeeper</a>和<a class="link" href="http://helix.incubator.apache.org/">Apache Helix</a> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>同时安装：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>将Zookeeper解压缩到目录（ <code class="literal">$ZOOKEEPER_HOME</code> ）。</strong></strong></p></li><li class="listitem"><p><strong><strong>在<code class="literal">$ZOOKEEPER_HOME</code> ，复制<code class="literal">zoo_sample.conf</code>至<code class="literal">zoo.conf</code></strong></strong></p></li><li class="listitem"><p><strong><strong>编辑<code class="literal">zoo.conf</code> 。如果需要，请调整设置。通常只有以下两个属性是相关的：</strong></strong></p><pre><code class="no-highlight"># the directory where the snapshot is stored.
dataDir=/tmp/zookeeper
# the port at which the clients will connect
clientPort=2181</code></pre></li><li class="listitem"><p><strong><strong>将Helix解压缩到目录（ <code class="literal">$HELIX_HOME</code> ）。</strong></strong></p></li></ol></div></li><li class="listitem"><p><strong><strong>在Zookeeper中配置集群：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>转到其<code class="literal">bin</code>目录：</strong></strong></p><pre><code class="no-highlight">$ cd $ZOOKEEPER_HOME/bin</code></pre></li><li class="listitem"><p><strong><strong>启动Zookeeper服务器：</strong></strong></p><pre><code class="no-highlight">$ sudo ./zkServer.sh start</code></pre><p><strong><strong>如果服务器无法启动，请验证<code class="literal">dataDir</code> （如<code class="literal">zoo.conf</code> ）可访问。</strong></strong></p></li><li class="listitem"><p><strong><strong>要查看Zookeeper的活动，请打开<code class="literal">zookeeper.out</code> ：</strong></strong></p><pre><code class="no-highlight">$ cat $ZOOKEEPER_HOME/bin/zookeeper.out</code></pre></li></ol></div></li><li class="listitem"><p><strong><strong>在Helix中配置集群：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>转到其<code class="literal">bin</code>目录：</strong></strong></p><pre><code class="no-highlight">$ cd $HELIX_HOME/bin</code></pre></li><li class="listitem"><p><strong><strong>创建集群：</strong></strong></p><pre><code class="no-highlight">$ ./helix-admin.sh --zkSvr localhost:2181 --addCluster kie-cluster</code></pre><p><strong><strong>的<code class="literal">zkSvr</code>值必须与使用的Zookeeper服务器匹配。集群名称（ <code class="literal">kie-cluster</code> ）可以根据需要进行更改。</strong></strong></p></li><li class="listitem"><p><strong><strong>将节点添加到集群：</strong></strong></p><pre><code class="no-highlight"># Node 1
$ ./helix-admin.sh --zkSvr localhost:2181 --addNode kie-cluster nodeOne:12345
# Node 2
$ ./helix-admin.sh --zkSvr localhost:2181 --addNode kie-cluster nodeTwo:12346
...</code></pre><p><strong><strong>通常，群集中的节点数a等于群集中的应用程序服务器数。节点名称（ <code class="literal">nodeOne:12345</code> ，...）可以根据需要进行更改。</strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong><code class="literal">nodeOne:12345</code>是节点的唯一标识符，稍后将在配置应用程序服务器时引用该标识符。它不是主机和端口号，而是用于唯一标识逻辑节点。</strong></strong></p></div></li><li class="listitem"><p><strong><strong>向集群添加资源：</strong></strong></p><pre><code class="no-highlight">$ ./helix-admin.sh --zkSvr localhost:2181 --addResource kie-cluster vfs-repo 1 LeaderStandby AUTO_REBALANCE</code></pre><p><strong><strong>资源名称（ <code class="literal">vfs-repo</code> ）可以根据需要进行更改。</strong></strong></p></li><li class="listitem"><p><strong><strong>重新平衡集群以将其初始化：</strong></strong></p><pre><code class="no-highlight">$ ./helix-admin.sh --zkSvr localhost:2181 --rebalance kie-cluster vfs-repo 2</code></pre></li><li class="listitem"><p><strong><strong>启动Helix控制器来管理集群：</strong></strong></p><pre><code class="no-highlight">$  ./run-helix-controller.sh --zkSvr localhost:2181 --cluster kie-cluster 2&gt;&amp;1 &gt; /tmp/controller.log &amp;</code></pre></li></ol></div></li><li class="listitem"><p><strong><strong>在应用程序服务器上正确配置安全域。例如在WildFly和JBoss EAP上：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>编辑档案<code class="literal">$JBOSS_HOME/domain/configuration/domain.xml</code> 。</strong></strong></p><p><strong><strong>为了简单起见，假设我们使用使用配置文件的默认域配置<code class="literal">full</code>定义两个服务器节点作为<code class="literal">main-server-group</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>找到个人资料<code class="literal">full</code>并通过复制默认情况下已经在此处定义的其他安全域来添加新的安全域：</strong></strong></p><pre><code class="no-highlight">&lt;security-domain name="kie-ide" cache-type="default"&gt;
    &lt;authentication&gt;
         &lt;login-module code="Remoting" flag="optional"&gt;
             &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
         &lt;/login-module&gt;
         &lt;login-module code="RealmDirect" flag="required"&gt;
             &lt;module-option name="password-stacking" value="useFirstPass"/&gt;
         &lt;/login-module&gt;
    &lt;/authentication&gt;
&lt;/security-domain&gt;</code></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>安全域名是一个神奇的值。</strong></strong></p></div></li></ol></div></li><li class="listitem"><p><strong><strong>在应用程序服务器上为集群配置<a class="link" href="#wb.systemProperties" title="18.1.3。系统属性">系统属性</a> 。例如在WildFly和JBoss EAP上：</strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><strong><strong>编辑档案<code class="literal">$JBOSS_HOME/domain/configuration/host.xml</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>找到XML元素<code class="literal">server</code>属于<code class="literal">main-server-group</code>并添加必要的系统属性。</strong></strong></p><p><strong><strong>例如，nodeOne：</strong></strong></p><pre><code class="language-xml">&lt;system-properties&gt;
  &lt;property name="jboss.node.name" value="nodeOne" boot-time="false"/&gt;
  &lt;property name="org.uberfire.nio.git.dir" value="/tmp/kie/nodeone" boot-time="false"/&gt;
  &lt;property name="org.uberfire.metadata.index.dir" value="/tmp/kie/nodeone" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.id" value="kie-cluster" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.zk" value="localhost:2181" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.local.id" value="nodeOne_12345" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/&gt;
  &lt;!-- If you're running both nodes on the same machine: --&gt;
  &lt;property name="org.uberfire.nio.git.daemon.port" value="9418" boot-time="false"/&gt;
&lt;/system-properties&gt;</code></pre><p><strong><strong>对于nodeTwo：</strong></strong></p><pre><code class="language-xml">&lt;system-properties&gt;
  &lt;property name="jboss.node.name" value="nodeTwo" boot-time="false"/&gt;
  &lt;property name="org.uberfire.nio.git.dir" value="/tmp/kie/nodetwo" boot-time="false"/&gt;
  &lt;property name="org.uberfire.metadata.index.dir" value="/tmp/kie/nodetwo" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.id" value="kie-cluster" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.zk" value="localhost:2181" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.local.id" value="nodeTwo_12346" boot-time="false"/&gt;
  &lt;property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/&gt;
  &lt;!-- If you're running both nodes on the same machine: --&gt;
  &lt;property name="org.uberfire.nio.git.daemon.port" value="9419" boot-time="false"/&gt;
&lt;/system-properties&gt;</code></pre><p><strong><strong>确保群集，节点和资源名称与在Helix中配置的名称匹配。</strong></strong></p></li></ol></div></li></ol></div></div><div class="section" title="21.1.2。 jBPM集群"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24193"></a> 21.1.2。 jBPM集群</strong></strong></h3></div></div></div><p><strong><strong>除上述信息外，jBPM集群还需要其他配置。请参阅<a class="link" href="http://mswiderski.blogspot.com.br/2013/06/clustering-in-jbpm-v6.html">此博客文章</a>以正确配置数据库等。</strong></strong></p></div></div></div></div><div class="part" title="第六部分KIE服务器"><div class="titlepage"><div><div><h1 class="title"><strong><strong><a id="d0e24201"></a>第六部分KIE服务器</strong></strong></h1></div></div></div><div class="partintro" title="KIE服务器"><div></div><p><strong><strong>KIE服务器是用于规则的独立执行服务器。</strong></strong></p><div class="toc"><p><strong><strong><strong>目录</strong></strong></strong></p><dl><dt><strong><strong><span class="chapter"><a href="#ch.kie.server">22KIE执行服务器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24210">22.1总览</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24254">22.1.1。词汇表</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24323">22.2。安装KIE服务器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24374">22.2.1。自举开关</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24677">22.2.2。不同容器的安装详细信息</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24798">22.3。Kie服务器设置</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24807">22.3.1。托管Kie服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24889">22.3.2。非托管KIE执行服务器</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24914">22.4。创建一个Kie容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24991">22.5。管理容器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24996">22.5.1。启动容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25005">22.5.2。停止和删除容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25010">22.5.3。更新容器</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25070">22.6。Kie Server REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25090">22.6.1。[获取] /</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25100">22.6.2。[POST] /</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25140">22.6.3。[GET] /容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25171">22.6.4。 ⁠[GET] /容器/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25184">22.6.5。[PUT] /容器/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25207">22.6.6。[删除] / containers / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25220">22.6.7。[POST] /容器/实例/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25288">22.6.8。[GET] /容器/ {id} /版本ID</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25298">22.6.9。[POST] / containers / {id} / release-id</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25315">22.6.10。[GET] /容器/ {id} /扫描仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25325">22.6.11。[POST] /容器/ {id} /扫描仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25350">22.6.12。执行服务器的本机REST客户端</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25373">22.7。OptaPlanner REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25410">22.7.1。[GET] / containers / {containerId} / solvers</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25425">22.7.2。[PUT] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25458">22.7.3。[GET] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25479">22.7.4。[POST] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25530">22.7.5。[GET] / containers / {containerId} / solvers / {solverId} / bestsolution</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25548">22.7.6。[删除] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25569">22.8。控制器REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25587">22.8.1。[GET] /管理/服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25597">22.8.2。[GET] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25607">22.8.3。[PUT] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25617">22.8.4。[删除] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25622">22.8.5。[GET] /管理/服务器/ {id} /容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25632">22.8.6。[GET] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25642">22.8.7。[PUT] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25652">22.8.8。[删除] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25657">22.8.9。[POST] / management / server / {id} / containers / {containerId} / status / started</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25662">22.8.10。[POST] / management / server / {id} / containers / {containerId} / status / stopped</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25667">22.9。Kie Server Java客户端API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25672">22.9.1。Maven配置</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25690">22.9.2。客户端配置</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25753">22.9.3。服务器响应</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25777">22.9.4。服务器功能</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25798">22.9.5。基氏容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25826">22.9.6。管理容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25837">22.9.7。决策服务器的可用客户端</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25870">22.9.8。将命令发送到服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25897">22.9.9。列出可用的业务流程</a></span></strong></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第22章KIE执行服务器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="ch.kie.server"></a>第22章KIE执行服务器</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e24210">22.1总览</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24254">22.1.1。词汇表</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24323">22.2。安装KIE服务器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24374">22.2.1。自举开关</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24677">22.2.2。不同容器的安装详细信息</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24798">22.3。Kie服务器设置</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24807">22.3.1。托管Kie服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24889">22.3.2。非托管KIE执行服务器</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e24914">22.4。创建一个Kie容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e24991">22.5。管理容器</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e24996">22.5.1。启动容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25005">22.5.2。停止和删除容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25010">22.5.3。更新容器</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25070">22.6。Kie Server REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25090">22.6.1。[获取] /</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25100">22.6.2。[POST] /</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25140">22.6.3。[GET] /容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25171">22.6.4。 ⁠[GET] /容器/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25184">22.6.5。[PUT] /容器/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25207">22.6.6。[删除] / containers / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25220">22.6.7。[POST] /容器/实例/ {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25288">22.6.8。[GET] /容器/ {id} /版本ID</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25298">22.6.9。[POST] / containers / {id} / release-id</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25315">22.6.10。[GET] /容器/ {id} /扫描仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25325">22.6.11。[POST] /容器/ {id} /扫描仪</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25350">22.6.12。执行服务器的本机REST客户端</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25373">22.7。OptaPlanner REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25410">22.7.1。[GET] / containers / {containerId} / solvers</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25425">22.7.2。[PUT] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25458">22.7.3。[GET] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25479">22.7.4。[POST] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25530">22.7.5。[GET] / containers / {containerId} / solvers / {solverId} / bestsolution</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25548">22.7.6。[删除] / containers / {containerId} / solvers / {solverId}</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25569">22.8。控制器REST API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25587">22.8.1。[GET] /管理/服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25597">22.8.2。[GET] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25607">22.8.3。[PUT] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25617">22.8.4。[删除] / management / server / {id}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25622">22.8.5。[GET] /管理/服务器/ {id} /容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25632">22.8.6。[GET] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25642">22.8.7。[PUT] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25652">22.8.8。[删除] / management / server / {id} / containers / {containerId}</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25657">22.8.9。[POST] / management / server / {id} / containers / {containerId} / status / started</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25662">22.8.10。[POST] / management / server / {id} / containers / {containerId} / status / stopped</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e25667">22.9。Kie Server Java客户端API</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25672">22.9.1。Maven配置</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25690">22.9.2。客户端配置</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25753">22.9.3。服务器响应</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25777">22.9.4。服务器功能</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25798">22.9.5。基氏容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25826">22.9.6。管理容器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25837">22.9.7。决策服务器的可用客户端</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25870">22.9.8。将命令发送到服务器</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25897">22.9.9。列出可用的业务流程</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="22.1总览"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e24210"></a> 22.1总览</strong></strong></h2></div></div></div><p><strong><strong><span class="emphasis"><em>Kie Server</em></span>是一个模块化的独立服务器组件，可用于实例化和执行规则和流程。它通过REST，JMS和Java接口向客户端应用程序公开此功能。它还提供了与<span class="emphasis"><em>Kie Workbench的</em></span>无缝集成。</strong></strong></p><p><strong><strong><span class="emphasis"><em>Kie Server的</em></span>核心是打包为WAR文件的可配置Web应用程序。发行版可用于纯Web容器（例如Tomcat）以及JEE 6和JEE 7容器。</strong></strong></p><p><strong><strong>Kie Server上的大多数功能都是可扩展的，并且基于扩展的概念。每个扩展都可以独立启用/禁用，从而允许用户根据需要配置服务器。</strong></strong></p><p><strong><strong>当前版本的Kie Server附带两个默认扩展名：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>BRM：为使用Drools规则引擎执行业务规则提供支持。</strong></strong></p></li><li class="listitem"><p><strong><strong>BPM：为使用jBPM流程引擎执行业务流程提供支持。它支持：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>流程执行</strong></strong></p></li><li class="listitem"><p><strong><strong>任务执行</strong></strong></p></li><li class="listitem"><p><strong><strong>异步作业执行</strong></strong></p></li></ul></div></li></ul></div><p><strong><strong>这两个扩展默认都启用，但可以通过设置相应的属性来禁用（有关详细信息，请参见配置章节）。</strong></strong></p><p><strong><strong>该服务器设计为占用空间小，内存消耗最少，因此易于在云环境中部署。该服务器的每个实例都可以打开和实例化多个<span class="emphasis"><em>Kie容器</em></span> ，这使您可以并行执行多个服务。</strong></strong></p><div class="section" title="22.1.1。词汇表"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24254"></a> 22.1.1。词汇表</strong></strong></h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>Kie Server</strong></span> ：执行服务器纯粹专注于为规则和流程提供运行时环境。这些功能由<span class="emphasis"><em>Kie Server Extensions提供</em></span> 。可以通过进一步的扩展来添加更多功能（例如，客户可以在缺少功能的情况下添加自己的扩展，这些功能随后将使用KIE Server的基础结构）。Kie Server实例是在给定的应用程序服务器/ Web容器上执行的独立Kie Server。一个Kie Server实例化并提供对多个Kie Containers的支持。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>Kie Server Extension</strong></span> ： <span class="bold"><strong>Kie Server</strong></span>的“插件”，用于向服务器添加功能。Kie Server随附两个默认的kie服务器扩展：BRM和BPM。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>Kie容器</strong></span> ：kjar在内存中的实例化，允许实例化和使用其资产（域模型，流程，规则等）。Kie Server通过诸如REST和JMS之类的传输协议通过标准API公开Kie容器。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>控制器</strong></span> ：服务器支持的REST端点，将负责管理KIE Server实例。该端点必须提供以下功能：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>响应连接请求</strong></strong></p></li><li class="listitem"><p><strong><strong>在相应的<span class="emphasis"><em>Kie Server ID</em></span>上同步所有已注册的容器</strong></strong></p></li><li class="listitem"><p><strong><strong>响应断开请求</strong></strong></p></li></ul></div></li><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>Kie Server状态</strong></span> ：给定Kie Server实例的当前已知状态。这是本地存储（默认情况下在文件中），维护以下信息：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>注册控制器列表</strong></strong></p></li><li class="listitem"><p><strong><strong>已知容器列表</strong></strong></p></li><li class="listitem"><p><strong><strong>kie服务器配置</strong></strong></p></li></ul></div><p><strong><strong>在receival等事件的服务器状态被持久： <span class="emphasis"><em>纪伊容器</em></span>中创建， <span class="emphasis"><em>纪伊容器</em></span>被配置，控制器接受<span class="emphasis"><em>纪伊Server</em></span>实例的登记等</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="bold"><a id="docs-internal-guid-81eb08e8-d2fc-a4e7-6584-b666315fc14d"></a> <strong>Kie Server ID</strong></span> ：一个任意分配的标识符，分配了配置。在启动时，为每个Kie Server实例分配一个ID，并且该ID与控制器上的配置匹配。Kie服务器实例将获取并使用该配置进行自我设置。</strong></strong></p></li></ul></div></div></div><div class="section" title="22.2。安装KIE服务器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e24323"></a> 22.2。安装KIE服务器</strong></strong></h2></div></div></div><p><strong><strong>KIE服务器作为Web应用程序存档（WAR）文件分发。WAR文件采用三种不同的包装：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><strong><strong><span class="emphasis"><em>webc-</em></span>像Tomcat这样的普通Web（Servlet）容器的WAR</strong></strong></li><li class="listitem"><strong><strong><span class="emphasis"><em>ee6</em></span> -JavaEE 6容器（例如JBoss EAP 6.x）的WAR</strong></strong></li><li class="listitem"><strong><strong><span class="emphasis"><em>ee7</em></span> -JavaEE 7容器（如WildFly 8.x）的WAR</strong></strong></li></ul></div><p><strong><strong>
  </strong></strong></p><p><strong><strong>要安装KIE Execution Server并验证其正在运行，请完成以下步骤：</strong></strong></p><p><strong><strong>
    </strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>将WAR文件部署到您的Web容器中。</strong></strong></p></li><li class="listitem"><p><strong><strong>创建一个具有以下角色的用户<code class="code">kie-server</code>在容器上。</strong></strong></p></li><li class="listitem"><p><strong><strong>通过浏览到浏览器窗口中的端点来测试您是否可以访问执行引擎： <code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>当提示您输入用户名/密码时，键入您在步骤2中创建的用户名和密码。</strong></strong></p></li><li class="listitem"><p><strong><strong>一旦通过身份验证，您将看到引擎状态形式的XML响应，类似于以下内容：</strong></strong></p><div class="example"><strong><strong><a id="d0e24368"></a><p class="title"><strong>示例22.1示例握手服务器响应</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="KIE Server info"&gt;
  &lt;kie-server-info&gt;
    &lt;version&gt;6.5.0.Final&lt;/version&gt;
  &lt;/kie-server-info&gt;
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></li></ol></div><p><strong><strong>
  </strong></strong></p><div class="section" title="22.2.1。自举开关"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24374"></a> 22.2.1。自举开关</strong></strong></h3></div></div></div><p><strong><strong>Kie Server接受许多引导开关（系统属性）以配置服务器的行为。下表是所有受支持的开关的表。</strong></strong></p><p><strong><strong>
      </strong></strong></p><div class="table"><strong><strong><a id="d0e24381"></a><p class="title"><strong>表22.1Kie Server引导程序开关</strong></p><div class="table-contents"><table border="1" summary="Kie Server bootstrap switches"><colgroup><col width="2.0*" class="c1"><col width="2.0*" class="c2"><col width="4.0*" class="c3"><col width="1.0*" class="c4"></colgroup><thead><tr><th>属性</th><th>值</th><th>描述</th><th>需要</th></tr></thead><tbody><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d278-cdbc-3277-34f586cd28ee"></a> <strong>org.drools.server.ext.disabled</strong></span></td><td>布尔值（默认为“ false”）</td><td>如果为true，则禁用BRM支持（即规则支持）。</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d27a-35ba-25c1-375f7ecf35d9"></a> <strong>org.jbpm.server.ext.disabled</strong></span></td><td>布尔值（默认为“ false”）</td><td>如果为true，则禁用BPM支持（即流程支持）</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d276-b920-8222-1515def0d382"></a> <strong>org.kie.server.id</strong></span></td><td>串</td><td>要分配给该服务器的任意ID。如果配置了远程控制器，则这是服务器将用来连接到控制器以获取kie容器配置的ID。</td><td>否。如果未提供，则会自动生成一个ID。</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d286-e838-9601-f36fb91cf626"></a> <strong>org.kie.server.user</strong></span></td><td>字符串（默认为“ kieserver”）</td><td>在管理模式下运行时用于从控制器与kieserver连接的用户名</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d288-28ab-6e4b-a529f64bf5cf"></a> <strong>org.kie.server.pwd</strong></span></td><td>字符串（默认为“ kieserver1！”）</td><td>在受管模式下运行时需要的用于从控制器与kieserver连接的密码</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d289-27cd-441b-87c88d1aac84"></a> <strong>org.kie.server.controller</strong></span></td><td>网址的逗号分隔列表</td><td>控制器REST端点的URL列表。例如：<code class="code">http://localhost:8080/kie-wb/rest/controller</code></td><td>是，使用控制器时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d28a-a44b-544c-ff3012ddd077"></a> <strong>org.kie.server.controller.user</strong></span></td><td>字符串（默认为“ kieserver”）</td><td>用于连接到控制器REST API的用户名</td><td>是，使用控制器时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d28b-6920-9056-ad5537e03b3d"></a> <strong>org.kie.server.controller.pwd</strong></span></td><td>字符串（默认为“ kieserver1！”）</td><td>用于连接到控制器REST API的密码</td><td>是，使用控制器时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d28c-0bcf-855f-17de4a1a154a"></a> <strong>org.kie.server.location</strong></span></td><td>Kie服务器实例的URL位置</td><td>控制器用于在此服务器上回叫的URL。例如：<code class="code">http://localhost:8230/kie-server/services/rest/server</code></td><td>是，使用控制器时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d290-70e3-4337-c0623e88997d"></a> <strong>org.kie.server.domain</strong></span></td><td>串</td><td>使用JMS时应用于认证用户的JAAS LoginContext域</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d291-35f6-a580-d9d9091ec570"></a> <strong>org.kie.server.bypass.auth.user</strong></span></td><td>布尔值（默认为“ false”）</td><td>允许绕过经过身份验证的用户执行与任务相关的操作，例如查询</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d297-a4e6-1f15-48a5fe5d736b"></a> <strong>org.kie.server.repo</strong></span></td><td>有效的文件系统路径（默认为“。”）</td><td>本地文件系统上将存储kie服务器状态文件的位置</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d298-77f0-49d2-43c1bdf73d67"></a> <strong>org.kie.server.persistence.ds</strong></span></td><td>串</td><td>数据源JNDI名称</td><td>是，当启用BPM支持时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d299-3d38-fcd9-3f423d7fecce"></a> <strong>org.kie.server.persistence.tm</strong></span></td><td>串</td><td>用于Hibernate属性集的事务管理器平台</td><td>是，当启用BPM支持时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29a-a314-2bf7-907d924fceae"></a> <strong>org.kie.server.persistence.dialect</strong></span></td><td>串</td><td>使用休眠方言</td><td>是，当启用BPM支持时</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29b-24df-ead1-cf206900593d"></a> <strong>org.jbpm.ht.callback</strong></span></td><td>串</td><td>任务服务支持的回调之一（默认jaas）</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29b-bb9f-8a9d-ab034d736caf"></a> <strong>org.jbpm.ht.custom.callback</strong></span></td><td>串</td><td>在org.jbpm.ht.callback设置为'custom'的情况下UserGroupCallback的自定义实现</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29c-2bab-5ef7-13cbec1d5a68"></a> <strong>kie.maven.settings.custom</strong></span></td><td>有效的文件系统路径</td><td>用于Maven配置的custom settings.xml的位置</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29d-4700-7f41-91fa6d386ecd"></a> <strong>org.kie.executor.interval</strong></span></td><td>整数（默认为3）</td><td>执行者在两次轮询之间的时间单位数</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29d-ee54-02a8-274ef9383f41"></a> <strong>org.kie.executor.pool.size</strong></span></td><td>整数（默认为1）</td><td>池中用于异步工作的线程数</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d29e-9d32-e7ba-421f2a23128d"></a> <strong>org.kie.executor.retry.count</strong></span></td><td>整数（默认为3）</td><td>重试处理错误的次数</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d2e4-4418-249a-eb8a85fb5da4"></a> <strong>org.kie.executor.timeunit</strong></span></td><td>TimeUnit（默认为“ SECONDS”）</td><td>TimeUnit代表间隔</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d2e5-23da-b5d3-f24703b68742"></a> <strong>org.kie.executor.disabled</strong></span></td><td>布尔值（默认为“ false”）</td><td>完全禁用执行器</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d2e5-d59e-d87d-48a3630399a9"></a> <strong>kie.server.jms.queues.response</strong></span></td><td>字符串（默认为“ queue / KIE.SERVER.RESPONSE”）</td><td>JMS响应队列的JNDI名称</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d2e6-a4d9-d10c-e3b89262924b"></a> <strong>org.kie.server.controller.connect</strong></span></td><td>长（默认为10000）</td><td>Kie Server启动时重复尝试将Kie Server连接到控制器之间的等待时间（以毫秒为单位）</td><td>没有</td></tr><tr><td><span class="bold"><a id="docs-internal-guid-81eb08e8-d2e6-a4d9-d10c-e3b89262924b"></a> <strong>org.drools.server.filter.classes</strong></span></td><td>布尔值（默认为“ false”）</td><td>如果为true，则仅接受带有@ org.kie.api.remote注释的类。可远程或@ javax.xml.bind.annotation。XmlRootElement作为额外的JAXB类</td><td>没有</td></tr><tr><td> </td><td> </td><td> </td><td> </td></tr></tbody></table></div></strong></strong></div><p><strong><strong><br class="table-break">
      </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>如果同时运行KIE Server和KIE Workbench，则必须使用<span class="bold"><strong>org.kie.server.persistence.ds</strong></span>属性将KIE Server配置为使用与KIE Workbench不同的数据源。KIE Workbench使用jBPM执行程序服务，如果它们共享相同的数据源，则该服务可能会与KIE Server发生冲突。</strong></strong></p></div><p><strong><strong>
    </strong></strong></p></div><div class="section" title="22.2.2。不同容器的安装详细信息"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24677"></a> 22.2.2。不同容器的安装详细信息</strong></strong></h3></div></div></div><div class="section" title="22.2.2.1。Tomcat 7.x / 8.x"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e24680"></a> 22.2.2.1。Tomcat 7.x / 8.x</strong></strong></h4></div></div></div><p><strong><strong>
        </strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>下载并解压缩Tomcat发行版。我们称其为分布的根<code class="code">TOMCAT_HOME</code> 。该目录以Tomcat版本命名，例如<code class="code">apache-tomcat-7.0.55</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>下载<span class="emphasis"><em>kie-server-6.5.0。Final-webc.war</em></span>并将其放入<code class="code">TOMCAT_HOME/webapps</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>配置用户和角色。确保该文件<code class="code">TOMCAT_HOME/conf/tomcat-users.xml</code>包含以下用户名和角色定义。您当然可以选择其他用户名和密码，只需确保用户具有角色即可<code class="code">kie-server</code> ：</strong></strong></p><div class="example"><strong><strong><a id="d0e24713"></a><p class="title"><strong>示例22.2Tomcat的用户名和角色定义</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;role rolename="kie-server"/&gt;
&lt;user username="serveruser" password="my.s3cr3t.pass" roles="kie-server"/&gt;</code></pre></div></strong></strong></div><p><strong><strong><br class="example-break">
            </strong></strong></p></li><li class="listitem"><p><strong><strong>通过运行启动服务器<code class="code">TOMCAT_HOME/bin/startup.[sh|bat]</code> 。您可以签出Tomcat登录<code class="code">TOMCAT_HOME/logs</code>查看应用程序是否成功部署。请阅读上表，了解可用于正确配置实例的引导程序开关。例如：</strong></strong></p><pre><code class="no-highlight">./startup.sh -Dorg.kie.server.id=first-kie-server
             -Dorg.kie.server.location=http://localhost:8080/kie-server/services/rest/server</code></pre></li><li class="listitem"><p><strong><strong>验证服务器正在运行。去<code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/</code>并输入指定的用户名和密码。您应该看到带有有关服务器基本信息的简单XML消息。</strong></strong></p></li></ol></div><p><strong><strong>
        </strong></strong></p><p><strong><strong>
          </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><strong><strong>在Tomcat或任何其他Web容器上运行时，不能利用JMS接口。WAR的Web容器版本仅包含REST接口。
          </strong></strong></div><p><strong><strong>
        </strong></strong></p><p><strong><strong>
      </strong></strong></p></div><div class="section" title="22.2.2.2。WildFly 8.x"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e24743"></a> 22.2.2.2。WildFly 8.x</strong></strong></h4></div></div></div><p><strong><strong>
        </strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>下载并解压缩WildFly发行版。我们称其为分布的根<code class="code">WILDFLY_HOME</code> 。该目录以WildFly版本命名，例如<code class="code">wildfly-8.2.0.Final</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>下载<span class="emphasis"><em>kie-server-6.5.0。Final-ee7.war</em></span>并将其放入<code class="code">WILDFLY_HOME/standalone/deployments</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>配置用户和角色。执行以下命令<code class="code">WILDFLY_HOME/bin/add-user.[sh|bat] -a -u 'kieserver' -p 'kieserver1!' -ro 'kie-server'</code> 。您当然可以选择其他用户名和密码，只需确保该用户具有角色即可<code class="code">kie-server</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong>通过运行启动服务器<code class="code">WILDFLY_HOME/bin/standalone.[sh|bat] -c standalone-full.xml <bootstrap_switches></code> 。您可以签出标准输出或WildFly登录<code class="code">WILDFLY_HOME/standalone/logs</code>查看应用程序是否成功部署。请阅读上表，了解可用于正确配置实例的引导程序开关。例如：</strong></strong></p><pre><code class="no-highlight">./standalone.sh  --server-config=standalone-full.xml
                 -Djboss.socket.binding.port-offset=150
                 -Dorg.kie.server.id=first-kie-server
                 -Dorg.kie.server.location=http://localhost:8230/kie-server/services/rest/server</code></pre></li><li class="listitem"><p><strong><strong>验证服务器正在运行。去<code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/</code>并输入指定的用户名和密码。您应该看到带有有关服务器基本信息的简单XML消息。</strong></strong></p><div class="screenshot"><div class="mediaobject"><strong><strong><img src="shared/images/KieServer/kie-server-info.png"></strong></strong></div></div></li></ol></div><p><strong><strong>
      </strong></strong></p></div></div></div><div class="section" title="22.3。Kie服务器设置"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e24798"></a> 22.3。Kie服务器设置</strong></strong></h2></div></div></div><p><strong><strong>
              </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>与6.2版及更低版本相比，服务器设置和注册已发生重大变化。以下内容仅适用于6.3版及更高版本。</strong></strong></p></div><p><strong><strong>
       </strong></strong></p><div class="section" title="22.3.1。托管Kie服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24807"></a> 22.3.1。托管Kie服务器</strong></strong></h3></div></div></div><p><strong><strong>托管实例是要求控制器可用以正确启动Kie Server实例的实例。</strong></strong></p><p><strong><strong>控制器是负责以集中方式维护和管理Kie Server配置的组件。每个控制器可以一次管理多个配置，并且环境中可以有多个控制器。托管KIE服务器可以配置有一系列控制器，但一次只能连接一个。</strong></strong></p><p><strong><strong>
                     </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><strong><strong>值得一提的是，即使可以有多个控制器，它们也应保持同步，以确保无论KIE Server实例与哪个控制器联系，它都将提供相同的配置。</strong></strong></div><p><strong><strong>
              </strong></strong></p><p><strong><strong>启动时，如果为Kie Server配置了一系列控制器，它将成功尝试连接到每个控制器，直到成功与其中一个建立连接为止。如果由于某种原因无法建立连接，则即使配置中有本地存储可用，服务器也不会启动。这是设计使然，以确保一致性。例如，如果Kie Server已关闭且配置已更改，则此限制可保证它将以最新配置运行或根本不运行。</strong></strong></p><p><strong><strong>
                     </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><strong><strong>为了在独立模式下运行Kie Server而不连接任何控制器，请参阅“非托管Kie Server”。</strong></strong></div><p><strong><strong>
              </strong></strong></p><p><strong><strong>该配置集包括：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>部署和启动Kie容器</strong></strong></p></li><li class="listitem"><p><strong><strong>配置项-当前是用于进一步增强功能的占位符，将允许远程配置KIE Execution Server组件-计时器，持久性等</strong></strong></p></li></ul></div><p><strong><strong>Controller除了提供配置管理外，还负责Kie Server的整体管理。它提供了一个REST API，分为两个部分：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>与KIE Execution Server实例进行交互的控制器本身</strong></strong></p></li><li class="listitem"><p><strong><strong>允许远程管理Kie Server实例的管理API：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>添加/删除服务器</strong></strong></p></li><li class="listitem"><p><strong><strong>向服务器添加容器或从服务器删除容器</strong></strong></p></li><li class="listitem"><p><strong><strong>在服务器上启动/停止容器</strong></strong></p></li></ul></div></li></ul></div><p><strong><strong>控制器仅处理Kie Server的配置或定义，以不同的方式进行处理。它不处理KIE Execution Server实例的任何运行时组件。他们总是被认为是远程的控制器。控制器负责保持配置，以保留控制器本身的重启。如果配置了多个控制器以使控制器的所有实例上的所有定义保持最新，它也应管理同步。</strong></strong></p><p><strong><strong>默认情况下，控制器随Kie Workbench一起提供，并提供功能齐全的管理界面（REST api和UI）。它使用基础git存储库作为持久性存储，因此，当将GIT存储库集群化（使用Apache Zookeeper和Apache Helix）时，它将也涵盖控制器同步。</strong></strong></p><div class="screenshot"><div class="mediaobject"><strong><strong><img src="shared/images/KieServer/kie-server-simple-architecture.png"></strong></strong></div></div><p><strong><strong>上图说明了单个控制器（工作台）的设置以及由其管理的多个Kie Server实例。</strong></strong></p><p><strong><strong>下图说明了集群设置，其中有多个通过Zookeeper同步的控制器实例。</strong></strong></p><div class="screenshot"><div class="mediaobject"><strong><strong><img src="shared/images/KieServer/kie-server-architecture.png"></strong></strong></div></div><p><strong><strong>在上图中，我们可以看到Kie Server实例能够连接到任何控制器，但是它们只能连接到一个。每个实例将尝试连接到控制器，只要它可以达到一个即可。与其中一个控制器建立连接后，它将跳过其他控制器。</strong></strong></p><div class="section" title="22.3.1.1。使用托管服务器"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e24873"></a> 22.3.1.1。使用托管服务器</strong></strong></h4></div></div></div><p><strong><strong>用户使用托管KIE Server实例时可以采用两种方法：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><span class="emphasis"><em>首先配置：</em></span>使用这种方法，用户将开始使用控制器（UI或REST api）并创建和配置Kie Server定义。这基本上包括服务器定义的标识（标识和名称+可选的版本，以提高可读性）和要在服务器上运行的Kie Containers的配置。</strong></strong></p></li><li class="listitem"><p><strong><strong><span class="emphasis"><em>首先注册：</em></span>使用这种方法，首先启动Kie Server实例，然后在控制器上自动注册自己。然后，用户可以配置Kie容器。此选项仅跳过第一种方法中完成的注册步骤，并在自动注册后直接用服务器ID，名称和版本填充它。两种方法之间没有其他区别。</strong></strong></p></li></ul></div></div></div><div class="section" title="22.3.2。非托管KIE执行服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24889"></a> 22.3.2。非托管KIE执行服务器</strong></strong></h3></div></div></div><p><strong><strong>反过来，非托管的Kie Server只是一个独立的实例，因此必须使用Kie Server本身的REST / JMS api进行单独配置。没有控制器参与。服务器自动将配置保存到一个文件中，以便在重新启动时用作内部服务器状态。</strong></strong></p><p><strong><strong>在以下操作期间将更新配置：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>部署Kie Container</strong></strong></p></li><li class="listitem"><p><strong><strong>取消部署Kie Container</strong></strong></p></li><li class="listitem"><p><strong><strong>启动Kie Container</strong></strong></p></li><li class="listitem"><p><strong><strong>停止Kie Container</strong></strong></p></li></ul></div><p><strong><strong>
                     </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><strong><strong>如果Kie Server重新启动，它将尝试重新建立与关机之前保持的状态相同的状态。这意味着正在运行的Kie容器将被启动，而之前已停止/处置的Kie容器将不会被启动。
                     </strong></strong></div><p><strong><strong>在大多数使用情况下，应该在托管模式下执行Kie Server，因为这样做可以带来一些好处，例如Web用户界面（如果使用工作台作为控制器）和一些集群功能。</strong></strong></p></div></div><div class="section" title="22.4。创建一个Kie容器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e24914"></a> 22.4。创建一个Kie容器</strong></strong></h2></div></div></div><p><strong><strong>一旦注册了执行服务器，就可以开始向其添加<span class="bold"><strong>Kie Containers</strong></span> 。</strong></strong></p><p><strong><strong><span class="bold"><strong>Kie容器</strong></span>是自包含的环境，已调配以容纳打包和部署的规则实例的实例。</strong></strong></p><p><strong><strong>
              </strong></strong></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><strong><strong>首先，单击要在其中部署容器的Execution Server旁边的<span class="bold"><strong>+</strong></span>图标。这将显示“新建容器”屏幕。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果您知道已部署程序包的<span class="bold"><strong>组名称</strong></span> ， <span class="bold"><strong>工件标识</strong></span>和<span class="bold"><strong>版本</strong></span> （GAV），则可以输入这些详细信息，然后单击“确定”按钮以选择该实例（并为容器提供名称）；</strong></strong></p></li><li class="listitem"><p><strong><strong>如果您不知道这些值，则可以在KIE Workbench中搜索所有可以部署的软件包。单击<span class="bold"><strong>搜索</strong></span>按钮，而不在搜索字段中输入任何值（您可以通过输入要部署的程序包中已知的任何术语来缩小搜索范围）。</strong></strong></p><p><strong><strong>
                                   </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>在此处插入屏幕快照</strong></strong></p></div><p><strong><strong>
                            </strong></strong></p><p><strong><strong>上图显示，有三个可部署的软件包可用作Execution Server上的容器。通过单击“选择”按钮选择所需的一个。这将自动填充<span class="bold"><strong>GAV</strong></span> ，然后您可以单击“ <span class="bold"><strong>确定”</strong></span>按钮以将此可部署项用作新的容器。</strong></strong></p></li><li class="listitem"><p><strong><strong>在顶部输入此容器的名称，然后按确定按钮。</strong></strong></p><p><strong><strong>
                                   </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>容器名称在每个执行服务器内必须唯一，并且不能包含任何空格。</strong></strong></p></div><p><strong><strong>
                            </strong></strong></p></li></ol></div><p><strong><strong>
       </strong></strong></p><p><strong><strong>
              </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>在<span class="bold"><strong>GAV</strong></span>行的正下方，您将看到一个不可编辑的行，该行向您显示您可以针对其执行REST命令的Container的<span class="bold"><strong>URL</strong></span> 。</strong></strong></p></div><p><strong><strong>
       </strong></strong></p></div><div class="section" title="22.5。管理容器"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e24991"></a> 22.5。管理容器</strong></strong></h2></div></div></div><p><strong><strong>可以在KIE Workbench中启动，停止和更新Execution Server中的容器。</strong></strong></p><div class="section" title="22.5.1。启动容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e24996"></a> 22.5.1。启动容器</strong></strong></h3></div></div></div><p><strong><strong>注册后，容器将处于“停止”模式。可以先选择它，然后单击“开始”按钮来启动它。您也可以选择多个容器并同时启动它们。</strong></strong></p><p><strong><strong>容器处于“运行”模式后，其旁边会出现一个绿色箭头。如果启动容器时发生任何错误，则在容器及其部署到的服务器和执行服务器旁边会出现红色图标。</strong></strong></p><p><strong><strong>在重新部署容器（和可能的执行服务器）之前，应该检查Execution Server和当前Business Central的日志，以查看错误所在。</strong></strong></p></div><div class="section" title="22.5.2。停止和删除容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25005"></a> 22.5.2。停止和删除容器</strong></strong></h3></div></div></div><p><strong><strong>与启动容器类似，选择要停止（或删除）的容器，然后单击“停止”按钮（一旦该容器进入“运行”模式，它将替换为“开始”按钮）或“删除”按钮。 ⁠</strong></strong></p></div><div class="section" title="22.5.3。更新容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25010"></a> 22.5.3。更新容器</strong></strong></h3></div></div></div><p><strong><strong>您可以更新部署<code class="code">KieContainers</code>无需重新启动执行服务器。这在业务规则更改，创建要配置的软件包的新版本的情况下很有用。</strong></strong></p><p><strong><strong>您可以配置和部署同一程序包的多个版本，每个版本都不同<code class="code">KieContainer</code> 。</strong></strong></p><p><strong><strong>更新服务器中的部署<code class="code">KieContainer</code>动态地，单击“容器”旁边的图标。这将打开“容器信息”屏幕。此屏幕的示例如下所示：</strong></strong></p><p><strong><strong>
                     </strong></strong></p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>重要</strong></strong></h2><p><strong><strong>在此处插入屏幕快照</strong></strong></p></div><p><strong><strong>
              </strong></strong></p><p><strong><strong>“容器信息”屏幕是一个有用的工具，因为它不仅允许您查看该端点<code class="code">KieContainer</code> ，但如果有更新，它还允许您手动或自动刷新配置。更新可以是手动的也可以是自动的：</strong></strong></p><p><strong><strong><span class="bold"><strong>手动更新：</strong></span>要手动更新<code class="code">KieContainer</code> ，在“版本”框中输入新的版本号，然后单击“ <span class="bold"><strong>更新”</strong></span>按钮。当然，您也可以更新Group ID或Artifact Id（如果它们也已更改）。更新后，执行服务器将更新容器，并在屏幕底部“ <span class="bold"><strong>已解决的发行ID”</strong></span>部分中显示<span class="bold"><strong>已</strong></span>解决的GAV属性。</strong></strong></p><p><strong><strong><span class="bold"><strong>自动更新：</strong></span>如果您希望已部署的Container始终具有最新版本的部署而无需手动编辑它，则需要将Version属性设置为的值。 <code class="code">LATEST</code>然后开始<code class="code">Scanner</code> 。这将确保部署的配置始终包含最新版本。单击“立即扫描”按钮可以按需启动扫描仪一次，也可以在后台以指定的间隔（以秒为单位）进行扫描的情况下启动扫描仪。您也可以将此值设置为<code class="code">LATEST</code>首次创建此部署时。在这种情况下， <span class="bold"><strong>已解决的发行ID</strong></span>将为您显示实际的最新版本号。</strong></strong></p></div></div><div class="section" title="22.6。Kie Server REST API"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25070"></a> 22.6。Kie Server REST API</strong></strong></h2></div></div></div><p><strong><strong>Execution Server通过REST API支持以下命令。</strong></strong></p><p><strong><strong>使用这些命令之前，请注意以下几点：</strong></strong></p><p><strong><strong>
              </strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>它们的基本URL将保留为先前定义的端点（例如： <code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/</code> ）</strong></strong></p></li><li class="listitem"><p><strong><strong>如前所述，所有请求都需要针对角色kie-server的基本HTTP身份验证。</strong></strong></p></li></ul></div><p><strong><strong>
       </strong></strong></p><div class="section" title="22.6.1。[获取] /"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25090"></a> 22.6.1。[获取] /</strong></strong></h3></div></div></div><p><strong><strong>返回执行服务器信息</strong></strong></p><div class="example"><strong><strong><a id="d0e25095"></a><p class="title"><strong>示例22.3服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="KIE Server info"&gt;
  &lt;kie-server-info&gt; 
    &lt;version&gt;6.2.0.redhat-1&lt;/version&gt; 
  &lt;/kie-server-info&gt; 
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.6.2。[POST] /"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25100"></a> 22.6.2。[POST] /</strong></strong></h3></div></div></div><p><strong><strong>使用POST HTTP方法，您可以在Execution Server上执行各种命令。例如：创建容器，列表容器，处置容器和调用容器。</strong></strong></p><strong><strong>以下是命令的完整列表：<p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>CreateContainerCommand</p></li><li class="listitem"><p>GetServerInfoCommand</p></li><li class="listitem"><p>ListContainersCommand</p></li><li class="listitem"><p>CallContainerCommand</p></li><li class="listitem"><p>DisposeContainerCommand</p></li><li class="listitem"><p>GetContainerInfoCommand</p></li><li class="listitem"><p>GetScannerInfoCommand</p></li><li class="listitem"><p>UpdateScannerCommand</p></li><li class="listitem"><p>UpdateReleaseIdCommand</p></li></ul></div><p>命令本身可以在<code class="code">org.kie.server.api.commands</code>包。
              </p></strong></strong></div><div class="section" title="22.6.3。[GET] /容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25140"></a> 22.6.3。[GET] /容器</strong></strong></h3></div></div></div><p><strong><strong>返回在此Execution Server上创建的容器的列表。</strong></strong></p><div class="example"><strong><strong><a id="d0e25145"></a><p class="title"><strong>示例22.4服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="List of created containers"&gt;
  &lt;kie-containers&gt; 
    &lt;kie-container container-id="MyProjectContainer" status="STARTED"&gt; 
      &lt;release-id&gt;
        &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
        &lt;group-id&gt;com.redhat&lt;/group-id&gt;
        &lt;version&gt;1.0&lt;/version&gt; 
      &lt;/release-id&gt; 
      &lt;resolved-release-id&gt;
        &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
        &lt;group-id&gt;com.redhat&lt;/group-id&gt;
        &lt;version&gt;1.0&lt;/version&gt; 
      &lt;/resolved-release-id&gt; 
    &lt;/kie-container&gt;
  &lt;/kie-containers&gt; 
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>端点还支持基于<code class="code">ReleaseId</code>和容器状态。例子：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="code">/containers?groupId=org.example</code> -仅返回具有指定groupId的容器</li><li class="listitem"><code class="code">/containers?groupId=org.example&artifactId=project1&version=1.0.0.Final</code> -只返回指定的容器<code class="code">ReleaseId</code></li><li class="listitem"><code class="code">/containers?status=started,failed</code> -返回已启动或失败的容器</li></ul></div><p>
           </p></strong></strong></div><div class="section" title="22.6.4。 ⁠[GET] /容器/ {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25171"></a> 22.6.4。 ⁠[GET] /容器/ {id}</strong></strong></h3></div></div></div><p><strong><strong>返回有关特定容器的状态和信息。例如执行<code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/containers/MyProjectContainer</code>可能会返回以下示例容器信息。</strong></strong></p><div class="example"><strong><strong><a id="d0e25179"></a><p class="title"><strong>示例22.5服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">⁠&lt;response type="SUCCESS" msg="Info for container MyProjectContainer"&gt;
  &lt;kie-container container-id="MyProjectContainer" status="STARTED"&gt; 
    &lt;release-id&gt;
      &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
      &lt;group-id&gt;com.redhat&lt;/group-id&gt;
      &lt;version&gt;1.0&lt;/version&gt; 
    &lt;/release-id&gt; 
    &lt;resolved-release-id&gt;
      &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
      &lt;group-id&gt;com.redhat&lt;/group-id&gt;
      &lt;version&gt;1.0&lt;/version&gt; 
    &lt;/resolved-release-id&gt; 
  &lt;/kie-container&gt;
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.6.5。[PUT] /容器/ {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25184"></a> 22.6.5。[PUT] /容器/ {id}</strong></strong></h3></div></div></div><p><strong><strong>允许您在执行服务器中创建新的容器。例如，要创建一个ID为<span class="bold"><strong>MyRESTContainer</strong></span>的容器，完整的端点将是： <code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/containers/MyRESTContainer</code> 。请求的示例是：⁠</strong></strong></p><div class="example"><strong><strong><a id="d0e25195"></a><p class="title"><strong>示例22.6创建容器的示例请求</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie-container container-id="MyRESTContainer"&gt;
  &lt;release-id&gt;
    &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
    &lt;group-id&gt;com.redhat&lt;/group-id&gt;
    &lt;version&gt;1.0&lt;/version&gt; 
  &lt;/release-id&gt; 
&lt;/kie-container&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>来自服务器的响应（如果成功）将是：</p><div class="example"><a id="d0e25202"></a><p class="title"><strong>示例22.7创建容器时的示例服务器响应</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="Container MyRESTContainer successfully deployed with module com.redhat:Project1:1.0"&gt;
  &lt;kie-container container-id="MyProjectContainer" status="STARTED"&gt; 
    &lt;release-id&gt;
      &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
      &lt;group-id&gt;com.redhat&lt;/group-id&gt;
      &lt;version&gt;1.0&lt;/version&gt; 
    &lt;/release-id&gt; 
    &lt;resolved-release-id&gt;
      &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
      &lt;group-id&gt;com.redhat&lt;/group-id&gt;
      &lt;version&gt;1.0&lt;/version&gt; 
    &lt;/resolved-release-id&gt; 
  &lt;/kie-container&gt;
&lt;/response&gt;</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="22.6.6。[删除] / containers / {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25207"></a> 22.6.6。[删除] / containers / {id}</strong></strong></h3></div></div></div><p><strong><strong>⁠处理ID所指定的容器。例如，执行<code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/containers/MyProjectContainer</code>使用DELETE HTTP方法将返回以下服务器响应：</strong></strong></p><div class="example"><strong><strong><a id="d0e25215"></a><p class="title"><strong>示例22.8服务器响应示例处理容器</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="Container MyProjectContainer successfully disposed."/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.6.7。[POST] /容器/实例/ {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25220"></a> 22.6.7。[POST] /容器/实例/ {id}</strong></strong></h3></div></div></div><p><strong><strong>针对指定的容器执行操作和命令。您可以在POST请求的正文中向该Container发送命令。例如，要为ID为MyRESTContainer的Container触发所有规则（ <code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/containers/instances/MyRESTContainer</code> ），您将向其发送fire-all-rules命令，如下所示（在POST请求的正文中）：</strong></strong></p><div class="example"><strong><strong><a id="d0e25228"></a><p class="title"><strong>示例22.9示例服务器请求触发所有规则</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;fire-all-rules/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>以下是受支持的命令列表：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>AgendaGroupSetFocusCommand</p></li><li class="listitem"><p>ClearActivationGroupCommand</p></li><li class="listitem"><p>ClearAgendaCommand</p></li><li class="listitem"><p>ClearAgendaGroupCommand</p></li><li class="listitem"><p>ClearRuleFlowGroupCommand</p></li><li class="listitem"><p>DeleteCommand</p></li><li class="listitem"><p>InsertObjectCommand</p></li><li class="listitem"><p>修改命令</p></li><li class="listitem"><p>GetObjectCommand</p></li><li class="listitem"><p>InsertElementsCommand</p></li><li class="listitem"><p>FireAllRulesCommand</p></li><li class="listitem"><p>QueryCommand</p></li><li class="listitem"><p>SetGlobalCommand</p></li><li class="listitem"><p>GetGlobalCommand</p></li><li class="listitem"><p>GetObjectsCommand</p></li><li class="listitem"><p>BatchExecutionCommand</p></li></ul></div><p>这些命令可以在<code class="code">org.drools.core.command.runtime</code>包。
              </p></strong></strong></div><div class="section" title="22.6.8。[GET] /容器/ {id} /版本ID"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25288"></a> 22.6.8。[GET] /容器/ {id} /版本ID</strong></strong></h3></div></div></div><p><strong><strong>返回由ID指定的容器的完整发行ID。</strong></strong></p><div class="example"><strong><strong><a id="d0e25293"></a><p class="title"><strong>示例22.10服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">⁠&lt;response type="SUCCESS" msg="ReleaseId for container MyProjectContainer"&gt;
  &lt;release-id&gt;
    &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
    &lt;group-id&gt;com.redhat&lt;/group-id&gt;
    &lt;version&gt;1.0&lt;/version&gt; 
  &lt;/release-id&gt; 
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.6.9。[POST] / containers / {id} / release-id"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25298"></a> 22.6.9。[POST] / containers / {id} / release-id</strong></strong></h3></div></div></div><p><strong><strong>允许您更新容器部署的发行版ID。将新的完整发行版ID发送到服务器。</strong></strong></p><div class="example"><strong><strong><a id="d0e25303"></a><p class="title"><strong>示例22.11服务器请求示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;release-id&gt;
  &lt;artifact-id&gt;Project1&lt;/artifact-id&gt;
  &lt;group-id&gt;com.redhat&lt;/group-id&gt;    
  &lt;version&gt;1.1&lt;/version&gt;
&lt;/release-id&gt; </code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>服务器将响应成功或错误消息，类似于以下消息：</p><div class="example"><a id="d0e25310"></a><p class="title"><strong>示例22.12服务器响应示例</strong></p><div class="example-contents"><pre><code class="no-highlight">&lt;response type="SUCCESS" msg="Release id successfully updated."&gt;
  &lt;release-id&gt;
    &lt;artifact-id&gt;Project1&lt;/artifact-id&gt; 
    &lt;group-id&gt;com.redhat&lt;/group-id&gt;
    &lt;version&gt;1.0&lt;/version&gt; 
  &lt;/release-id&gt; 
&lt;/response&gt;</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="22.6.10。[GET] /容器/ {id} /扫描仪"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25315"></a> 22.6.10。[GET] /容器/ {id} /扫描仪</strong></strong></h3></div></div></div><p><strong><strong>返回有关此容器自动更新的扫描仪的信息。</strong></strong></p><div class="example"><strong><strong><a id="d0e25320"></a><p class="title"><strong>示例22.13服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="Scanner info successfully retrieved"&gt;
  &lt;kie-scanner status="DISPOSED"/&gt; 
&lt;/response&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.6.11。[POST] /容器/ {id} /扫描仪"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25325"></a> 22.6.11。[POST] /容器/ {id} /扫描仪</strong></strong></h3></div></div></div><p><strong><strong>允许您启动或停止扫描程序，该扫描程序控制对更新的Container部署进行轮询。要启动扫描仪，请发送类似于以下内容的请求： <code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/containers/{container-id}/scanner</code>带有以下POST数据。</strong></strong></p><div class="example"><strong><strong><a id="d0e25333"></a><p class="title"><strong>示例22.14示例服务器请求启动扫描仪</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;kie-scanner status="STARTED" poll-interval="20"/&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>⁠poll-interval属性以秒为单位。服务器的响应类似于：</p><div class="example"><a id="d0e25340"></a><p class="title"><strong>示例22.15服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;response type="SUCCESS" msg="Kie scanner successfully created."&gt;
  &lt;kie-scanner status="STARTED"/&gt; 
&lt;/response&gt;</code></pre></div></div><br class="example-break"><p>要停止扫描仪，请将状态替换为<code class="code">DISPOSED</code>并删除poll-interval属性。</p></strong></strong></div><div class="section" title="22.6.12。执行服务器的本机REST客户端"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25350"></a> 22.6.12。执行服务器的本机REST客户端</strong></strong></h3></div></div></div><p><strong><strong>本节概述的命令可以与任何REST客户端一起发送，无论它是curl，RESTEasy还是基于.NET的应用程序。但是，当从基于Java的应用程序发送请求时，用户可以利用开箱即用的本机客户端与Execution Server进行远程通信。该客户端是<span class="bold"><strong>org.kie：kie-server-client</strong></span>项目的一部分。它不允许创建XML请求，因此有必要在例如使用Drools API之前生成它们。</strong></strong></p><div class="example"><strong><strong><a id="d0e25358"></a><p class="title"><strong>示例22.16生成XML请求</strong></p><div class="example-contents"><pre><code class="language-java"> 
import java.util.ArrayList;
import java.util.List;

import org.drools.core.command.impl.GenericCommand;
import org.drools.core.command.runtime.BatchExecutionCommandImpl;
import org.drools.core.command.runtime.rule.FireAllRulesCommand;
import org.drools.core.command.runtime.rule.InsertObjectCommand;
import org.kie.api.command.BatchExecutionCommand;
import org.kie.internal.runtime.helper.BatchExecutionHelper;

public class DecisionClient {

public static void main(String args[]) {
        Bean1 bean1 = new Bean1();
        bean1.setName("Robert");

        InsertObjectCommand insertObjectCommand = new InsertObjectCommand(bean1, "f1");
        FireAllRulesCommand fireAllRulesCommand = new FireAllRulesCommand("myFireCommand");

        List&lt;GenericCommand&lt;?&gt;&gt; commands = new ArrayList&lt;GenericCommand&lt;?&gt;&gt;();
        commands.add(insertObjectCommand);
        commands.add(fireAllRulesCommand);
        BatchExecutionCommand command = new BatchExecutionCommandImpl(commands);

        String xStreamXml = BatchExecutionHelper.newXStreamMarshaller().toXML(command); // actual XML request
	}
}
         </code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>生成请求后，可以使用<span class="bold"><strong>kie-server-client</strong></span>发送请求，如下所示：</p><div class="example"><a id="d0e25368"></a><p class="title"><strong>示例22.17使用kie-server-client发送XML请求</strong></p><div class="example-contents"><pre><code class="language-java"> 
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;

//user "anton" must have role "kie-server" assigned
KieServicesConfiguration config =  KieServicesFactory.
        newRestConfiguration("http://localhost:8080/kie-server/services/rest/server",
        "anton",
        "password1!");
 KieServicesClient client = KieServicesFactory.newKieServicesClient(config);
// the request "xStreamXml" we generated in previous step
// "ListenerReproducer" is the name of the Container
ServiceResponse&lt;String&gt; response = client.executeCommands("ListenerReproducer", xStreamXml); 
System.out.println(response.getResult());
			 </code></pre></div></div><br class="example-break"></strong></strong></div></div><div class="section" title="22.7。OptaPlanner REST API"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25373"></a> 22.7。OptaPlanner REST API</strong></strong></h2></div></div></div><p><strong><strong>启用计划程序功能后，Kie Server支持以下其他REST API。与往常一样，所有这些API也可以通过JMS和Java客户端API使用。另请注意：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>它们的基本URL将保留为先前定义的端点（例如<code class="code">http://SERVER:PORT/CONTEXT/services/rest/server/</code> ）。</strong></strong></p></li><li class="listitem"><p><strong><strong>如前所述，所有请求都需要针对角色kie-server的基本HTTP身份验证。</strong></strong></p></li><li class="listitem"><p><strong><strong>要获取特定的编组格式，请添加HTTP标头<code class="literal">Content-Type</code>和可选<code class="literal">X-KIE-ContentType</code>在HTTP请求中。例如：</strong></strong></p><pre><code class="no-highlight">Content-Type: application/xml
X-KIE-ContentType: xstream</code></pre></li></ul></div><p><strong><strong>下面使用的示例请求和响应假定使用OptaPlanner Workbench的optacloud示例通过调用a <code class="literal">PUT</code>上<code class="literal">/services/rest/server/containers/optacloud-kiecontainer-1</code>具有以下内容：</strong></strong></p><pre><code class="language-xml">&lt;kie-container container-id="optacloud-kiecontainer-1"&gt;
  &lt;release-id&gt;
    &lt;group-id&gt;opta&lt;/group-id&gt;
    &lt;artifact-id&gt;optacloud&lt;/artifact-id&gt; 
    &lt;version&gt;1.0.0&lt;/version&gt; 
  &lt;/release-id&gt; 
&lt;/kie-container&gt;</code></pre><div class="section" title="22.7.1。[GET] / containers / {containerId} / solvers"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25410"></a> 22.7.1。[GET] / containers / {containerId} / solvers</strong></strong></h3></div></div></div><p><strong><strong>返回在容器中创建的求解器列表。</strong></strong></p><div class="example"><strong><strong><a id="d0e25415"></a><p class="title"><strong>示例22.18示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solvers list successfully retrieved from container 'optacloud-kiecontainer-1'&lt;/msg&gt;
  &lt;result class="org.kie.server.api.model.instance.SolverInstanceList"&gt;
    &lt;solvers&gt;
      &lt;solver-instance&gt;
        &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
        &lt;solver-id&gt;solver1&lt;/solver-id&gt;
        &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
        &lt;status&gt;NOT_SOLVING&lt;/status&gt;
      &lt;/solver-instance&gt;
      &lt;solver-instance&gt;
        &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
        &lt;solver-id&gt;solver2&lt;/solver-id&gt;
        &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
        &lt;status&gt;NOT_SOLVING&lt;/status&gt;
      &lt;/solver-instance&gt;
    &lt;/solvers&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e25420"></a><p class="title"><strong>示例22.19示例服务器响应（JSON）</strong></p><div class="example-contents"><pre><code class="language-json">{
  "type" : "SUCCESS",
  "msg" : "Solvers list successfully retrieved from container 'optacloud-kiecontainer-1'",
  "result" : {
    "solver-instance-list" : {
      "solver" : [ {
        "status" : "NOT_SOLVING",
        "container-id" : "optacloud-kiecontainer-1",
        "solver-id" : "solver1",
        "solver-config-file" : "opta/optacloud/cloudSolverConfig.solver.xml"
      }, {
        "status" : "NOT_SOLVING",
        "container-id" : "optacloud-kiecontainer-1",
        "solver-id" : "solver2",
        "solver-config-file" : "opta/optacloud/cloudSolverConfig.solver.xml"
      } ]
    }
  }
}           </code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="22.7.2。[PUT] / containers / {containerId} / solvers / {solverId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25425"></a> 22.7.2。[PUT] / containers / {containerId} / solvers / {solverId}</strong></strong></h3></div></div></div><p><strong><strong>用给定的值创建一个新的求解器<code class="code">{solverId}</code>在容器中<code class="code">{containerId}</code> 。该请求的主体是必须指定求解器配置文件的已编组的SolverInstance实体。</strong></strong></p><p><strong><strong>以下是请求和相应响应的示例。</strong></strong></p><div class="example"><strong><strong><a id="d0e25438"></a><p class="title"><strong>示例22.20示例服务器请求（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;solver-instance&gt;
  &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
&lt;/solver-instance&gt;          </code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e25443"></a><p class="title"><strong>示例22.21。示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solver 'solver1' successfully created in container 'optacloud-kiecontainer-1'&lt;/msg&gt;
  &lt;result class="solver-instance"&gt;
    &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
    &lt;solver-id&gt;solver1&lt;/solver-id&gt;
    &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
    &lt;status&gt;NOT_SOLVING&lt;/status&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;         </code></pre></div></div><br class="example-break"><div class="example"><a id="d0e25448"></a><p class="title"><strong>示例22.22示例服务器请求（JSON）</strong></p><div class="example-contents"><pre><code class="language-json">{
  "solver-config-file" : "opta/optacloud/cloudSolverConfig.solver.xml"
}           </code></pre></div></div><br class="example-break"><div class="example"><a id="d0e25453"></a><p class="title"><strong>示例22.23示例服务器响应（JSON）</strong></p><div class="example-contents"><pre><code class="language-json">{
  "type" : "SUCCESS",
  "msg" : "Solver 'solver1' successfully created in container 'optacloud-kiecontainer-1'",
  "result" : {
    "solver-instance" : {
      "container-id" : "optacloud-kiecontainer-1",
      "solver-id" : "solver1",
      "solver-config-file" : "opta/optacloud/cloudSolverConfig.solver.xml",
      "status" : "NOT_SOLVING"
    }
  }
}</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="22.7.3。[GET] / containers / {containerId} / solvers / {solverId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25458"></a> 22.7.3。[GET] / containers / {containerId} / solvers / {solverId}</strong></strong></h3></div></div></div><p><strong><strong>返回求解器的当前状态<code class="code">{solverId}</code>在容器中<code class="code">{containerId}</code> 。</strong></strong></p><div class="example"><strong><strong><a id="d0e25469"></a><p class="title"><strong>示例22.24示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solver 'solver1' state successfully retrieved from container 'optacloud-kiecontainer-1'&lt;/msg&gt;
  &lt;result class="solver-instance"&gt;
    &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
    &lt;solver-id&gt;solver1&lt;/solver-id&gt;
    &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
    &lt;status&gt;NOT_SOLVING&lt;/status&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e25474"></a><p class="title"><strong>示例22.25示例服务器响应（JSON）</strong></p><div class="example-contents"><pre><code class="language-json">{
  "type" : "SUCCESS",
  "msg" : "Solver 'solver1' state successfully retrieved from container 'optacloud-kiecontainer-1'",
  "result" : {
    "solver-instance" : {
      "container-id" : "optacloud-kiecontainer-1",
      "solver-id" : "solver1",
      "solver-config-file" : "opta/optacloud/cloudSolverConfig.solver.xml",
      "status" : "NOT_SOLVING"
    }
  }
}</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="22.7.4。[POST] / containers / {containerId} / solvers / {solverId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25479"></a> 22.7.4。[POST] / containers / {containerId} / solvers / {solverId}</strong></strong></h3></div></div></div><p><strong><strong>更新容器{containerId}中的{solverId}的状态，最值得注意的是开始求解。请求的正文已编组<code class="code">SolverInstance</code>并且可以请求求解器解决计划问题，也可以停止求解。SolverInstance状态确定应执行哪个操作，并可以将其设置为两个可能值之一：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>求解：如果尚未执行，则启动求解器。请求的正文还必须包含要解决的问题的数据。</strong></strong></p></li><li class="listitem"><p><strong><strong>NOT_SOLVING：请求求解器（如果正在运行）提早终止。所有其他属性都将被忽略。</strong></strong></p></li></ul></div><div class="section" title="22.7.4.1。开始解决"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e25494"></a> 22.7.4.1。开始解决</strong></strong></h4></div></div></div><p><strong><strong>例如，要使用2台计算机和1个进程来解决optacloud问题：</strong></strong></p><div class="example"><strong><strong><a id="d0e25499"></a><p class="title"><strong>示例22.26示例服务器请求（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;solver-instance&gt;
  &lt;status&gt;SOLVING&lt;/status&gt;
  &lt;planning-problem class="opta.optacloud.CloudSolution"&gt;
    &lt;computerList&gt;
      &lt;opta.optacloud.Computer&gt;
        &lt;cpuPower&gt;10&lt;/cpuPower&gt;
        &lt;memory&gt;4&lt;/memory&gt;
        &lt;networkBandwidth&gt;100&lt;/networkBandwidth&gt;
        &lt;cost&gt;1000&lt;/cost&gt;
      &lt;/opta.optacloud.Computer&gt;
      &lt;opta.optacloud.Computer&gt;
        &lt;cpuPower&gt;20&lt;/cpuPower&gt;
        &lt;memory&gt;8&lt;/memory&gt;
        &lt;networkBandwidth&gt;100&lt;/networkBandwidth&gt;
        &lt;cost&gt;3000&lt;/cost&gt;
      &lt;/opta.optacloud.Computer&gt;
    &lt;/computerList&gt;
    &lt;processList&gt;
      &lt;opta.optacloud.Process&gt;
        &lt;requiredCpuPower&gt;1&lt;/requiredCpuPower&gt;
        &lt;requiredMemory&gt;7&lt;/requiredMemory&gt;
        &lt;requiredNetworkBandwidth&gt;1&lt;/requiredNetworkBandwidth&gt;
      &lt;/opta.optacloud.Process&gt;
    &lt;/processList&gt;
  &lt;/planning-problem&gt;
&lt;/solver-instance&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>请注意，响应尚未包含最佳解决方案，因为解决可能需要几秒钟，几分钟，几小时或几天，这会使HTTP请求超时：</p><div class="example"><a id="d0e25506"></a><p class="title"><strong>示例22.27示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solver 'solver1' from container 'optacloud-kiecontainer-1' successfully updated.&lt;/msg&gt;
  &lt;result class="solver-instance"&gt;
    &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
    &lt;solver-id&gt;solver1&lt;/solver-id&gt;
    &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
    &lt;status&gt;SOLVING&lt;/status&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></div><br class="example-break"><p>相反，它是异步解决的，您需要调用bestsolution URL以获得最佳解决方案。</p></strong></strong></div><div class="section" title="22.7.4.2。终止解决"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e25513"></a> 22.7.4.2。终止解决</strong></strong></h4></div></div></div><p><strong><strong>例如，终止求解：</strong></strong></p><div class="example"><strong><strong><a id="d0e25518"></a><p class="title"><strong>示例22.28示例服务器请求（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;solver-instance&gt;
  &lt;status&gt;NOT_SOLVING&lt;/status&gt;
&lt;/solver-instance&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e25523"></a><p class="title"><strong>示例22.29示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solver 'solver1' from container 'optacloud-kiecontainer-1' successfully updated.&lt;/msg&gt;
  &lt;result class="solver-instance"&gt;
    &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
    &lt;solver-id&gt;solver1&lt;/solver-id&gt;
    &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
    &lt;status&gt;TERMINATING_EARLY&lt;/status&gt;
    &lt;score class="org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore"&gt;
      &lt;hardScore&gt;0&lt;/hardScore&gt;
      &lt;softScore&gt;-3000&lt;/softScore&gt;
    &lt;/score&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></div><br class="example-break"><p>这不会删除求解器，仍然可以检索最佳解决方案。</p></strong></strong></div></div><div class="section" title="22.7.5。[GET] / containers / {containerId} / solvers / {solverId} / bestsolution"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25530"></a> 22.7.5。[GET] / containers / {containerId} / solvers / {solverId} / bestsolution</strong></strong></h3></div></div></div><p><strong><strong>返回提出请求时找到的最佳解决方案。如果求解器尚未终止（因此<code class="literal">status</code>领域仍然<code class="literal">SOLVING</code> ），它将返回到目前为止找到的最佳解决方案，但是以后的调用可以返回更好的解决方案。</strong></strong></p><p><strong><strong>例如，上面提交的问题将返回此解决方案，并将进程分配给第二台计算机（因为第一台计算机没有足够的内存）。</strong></strong></p><div class="example"><strong><strong><a id="d0e25543"></a><p class="title"><strong>示例22.30示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Best computed solution for 'solver1' successfully retrieved from container 'optacloud-kiecontainer-1'&lt;/msg&gt;
   &lt;result class="solver-instance"&gt;
    &lt;container-id&gt;optacloud-kiecontainer-1&lt;/container-id&gt;
    &lt;solver-id&gt;solver1&lt;/solver-id&gt;
    &lt;solver-config-file&gt;opta/optacloud/cloudSolverConfig.solver.xml&lt;/solver-config-file&gt;
    &lt;status&gt;SOLVING&lt;/status&gt;
    &lt;score class="org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore"&gt;
      &lt;hardScore&gt;0&lt;/hardScore&gt;
      &lt;softScore&gt;-3000&lt;/softScore&gt;
    &lt;/score&gt;
    &lt;best-solution class="opta.optacloud.CloudSolution"&gt;
      &lt;score class="org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore" reference="../../score" /&gt;
      &lt;computerList&gt;
        &lt;opta.optacloud.Computer&gt;
          &lt;cpuPower&gt;10&lt;/cpuPower&gt;
          &lt;memory&gt;4&lt;/memory&gt;
          &lt;networkBandwidth&gt;100&lt;/networkBandwidth&gt;
          &lt;cost&gt;1000&lt;/cost&gt;
        &lt;/opta.optacloud.Computer&gt;
        &lt;opta.optacloud.Computer&gt;
          &lt;cpuPower&gt;20&lt;/cpuPower&gt;
          &lt;memory&gt;8&lt;/memory&gt;
          &lt;networkBandwidth&gt;100&lt;/networkBandwidth&gt;
          &lt;cost&gt;3000&lt;/cost&gt;
        &lt;/opta.optacloud.Computer&gt;
      &lt;/computerList&gt;
      &lt;processList&gt;
        &lt;opta.optacloud.Process&gt;
          &lt;requiredCpuPower&gt;1&lt;/requiredCpuPower&gt;
          &lt;requiredMemory&gt;7&lt;/requiredMemory&gt;
          &lt;requiredNetworkBandwidth&gt;1&lt;/requiredNetworkBandwidth&gt;
          &lt;computer reference="../../../computerList/opta.optacloud.Computer[2]" /&gt;
        &lt;/opta.optacloud.Process&gt;
      &lt;/processList&gt;
    &lt;/best-solution&gt;
  &lt;/result&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.7.6。[删除] / containers / {containerId} / solvers / {solverId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25548"></a> 22.7.6。[删除] / containers / {containerId} / solvers / {solverId}</strong></strong></h3></div></div></div><p><strong><strong>⁠配置求解器<code class="code">{solverId}</code>在容器中<code class="code">{containerId}</code> 。如果尚未终止，则先终止它。</strong></strong></p><div class="example"><strong><strong><a id="d0e25559"></a><p class="title"><strong>示例22.31示例服务器响应（XStream）</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;org.kie.server.api.model.ServiceResponse&gt;
  &lt;type&gt;SUCCESS&lt;/type&gt;
  &lt;msg&gt;Solver 'solver1' successfully disposed from container 'optacloud-kiecontainer-1'&lt;/msg&gt;
&lt;/org.kie.server.api.model.ServiceResponse&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e25564"></a><p class="title"><strong>示例22.32示例服务器响应（JSON）</strong></p><div class="example-contents"><pre><code class="language-json">{
  "type" : "SUCCESS",
  "msg" : "Solver 'solver1' successfully disposed from container 'optacloud-kiecontainer-1'"
}</code></pre></div></div><br class="example-break"></strong></strong></div></div><div class="section" title="22.8。控制器REST API"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25569"></a> 22.8。控制器REST API</strong></strong></h2></div></div></div><p><strong><strong>在管理Kie Server设置后，您需要通过控制器管理Kie Server和容器。通常，这是通过工作台UI完成的，但是您也可以使用Controller REST API。</strong></strong></p><p><strong><strong>
              </strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>控制器基本URL由kie-wb war部署提供，与org.kie.server.controller属性相同。（例如： <code class="code">http://localhost:8080/kie-wb/rest/controller</code> ）</strong></strong></p></li><li class="listitem"><p><strong><strong>如前所述，所有请求都需要针对角色kie-server的基本HTTP身份验证。</strong></strong></p></li></ul></div><p><strong><strong>
       </strong></strong></p><div class="section" title="22.8.1。[GET] /管理/服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25587"></a> 22.8.1。[GET] /管理/服务器</strong></strong></h3></div></div></div><p><strong><strong>返回Kie Server模板列表</strong></strong></p><div class="example"><strong><strong><a id="d0e25592"></a><p class="title"><strong>示例22.33服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;server-template-list&gt;
    &lt;server-template&gt;
        &lt;server-id&gt;demo&lt;/server-id&gt;
        &lt;server-name&gt;demo&lt;/server-name&gt;
        &lt;container-specs&gt;
            &lt;container-id&gt;hr&lt;/container-id&gt;
            &lt;container-name&gt;hr&lt;/container-name&gt;
            &lt;server-template-key&gt;
                &lt;server-id&gt;demo&lt;/server-id&gt;
            &lt;/server-template-key&gt;
            &lt;release-id&gt;
                &lt;artifact-id&gt;HR&lt;/artifact-id&gt;
                &lt;group-id&gt;org.jbpm&lt;/group-id&gt;
                &lt;version&gt;1.0&lt;/version&gt;
            &lt;/release-id&gt;
            &lt;configs&gt;
                &lt;entry&gt;
                    &lt;key&gt;RULE&lt;/key&gt;
                    &lt;value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                        &lt;scanner-status&gt;STOPPED&lt;/scanner-status&gt;
                    &lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PROCESS&lt;/key&gt;
                    &lt;value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                        &lt;strategy&gt;Singleton&lt;/strategy&gt;
                        &lt;kie-base-name&gt;&lt;/kie-base-name&gt;
                        &lt;kie-session-name&gt;&lt;/kie-session-name&gt;
                        &lt;merge-mode&gt;Merge Collections&lt;/merge-mode&gt;
                    &lt;/value&gt;
                &lt;/entry&gt;
            &lt;/configs&gt;
            &lt;status&gt;STARTED&lt;/status&gt;
        &lt;/container-specs&gt;
        &lt;configs/&gt;
        &lt;server-instances&gt;
            &lt;server-instance-id&gt;demo@localhost:8230&lt;/server-instance-id&gt;
            &lt;server-name&gt;demo@localhost:8230&lt;/server-name&gt;
            &lt;server-template-id&gt;demo&lt;/server-template-id&gt;
            &lt;server-url&gt;http://localhost:8230/kie-server/services/rest/server&lt;/server-url&gt;
        &lt;/server-instances&gt;
        &lt;capabilities&gt;RULE&lt;/capabilities&gt;
        &lt;capabilities&gt;PROCESS&lt;/capabilities&gt;
        &lt;capabilities&gt;PLANNING&lt;/capabilities&gt;
    &lt;/server-template&gt;
&lt;/server-template-list&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.2。[GET] / management / server / {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25597"></a> 22.8.2。[GET] / management / server / {id}</strong></strong></h3></div></div></div><p><strong><strong>返回Kie Server模板</strong></strong></p><div class="example"><strong><strong><a id="d0e25602"></a><p class="title"><strong>示例22.34服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;server-template-details&gt;
    &lt;server-id&gt;product-demo&lt;/server-id&gt;
    &lt;server-name&gt;product-demo&lt;/server-name&gt;
    &lt;container-specs&gt;
        &lt;container-id&gt;hr&lt;/container-id&gt;
        &lt;container-name&gt;hr&lt;/container-name&gt;
        &lt;server-template-key&gt;
            &lt;server-id&gt;demo&lt;/server-id&gt;
        &lt;/server-template-key&gt;
        &lt;release-id&gt;
            &lt;artifact-id&gt;HR&lt;/artifact-id&gt;
            &lt;group-id&gt;org.jbpm&lt;/group-id&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/release-id&gt;
        &lt;configs&gt;
            &lt;entry&gt;
                &lt;key&gt;RULE&lt;/key&gt;
                &lt;value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                    &lt;scanner-status&gt;STOPPED&lt;/scanner-status&gt;
                &lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
                &lt;key&gt;PROCESS&lt;/key&gt;
                &lt;value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                    &lt;strategy&gt;Singleton&lt;/strategy&gt;
                    &lt;kie-base-name&gt;&lt;/kie-base-name&gt;
                    &lt;kie-session-name&gt;&lt;/kie-session-name&gt;
                    &lt;merge-mode&gt;Merge Collections&lt;/merge-mode&gt;
                &lt;/value&gt;
            &lt;/entry&gt;
        &lt;/configs&gt;
        &lt;status&gt;STARTED&lt;/status&gt;
    &lt;/container-specs&gt;
    &lt;configs/&gt;
    &lt;server-instances&gt;
        &lt;server-instance-id&gt;demo@localhost:8230&lt;/server-instance-id&gt;
        &lt;server-name&gt;demo@localhost:8230&lt;/server-name&gt;
        &lt;server-template-id&gt;demo&lt;/server-template-id&gt;
        &lt;server-url&gt;http://localhost:8230/kie-server/services/rest/server&lt;/server-url&gt;
    &lt;/server-instances&gt;
    &lt;capabilities&gt;RULE&lt;/capabilities&gt;
    &lt;capabilities&gt;PROCESS&lt;/capabilities&gt;
    &lt;capabilities&gt;PLANNING&lt;/capabilities&gt;
&lt;/server-template-details&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.3。[PUT] / management / server / {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25607"></a> 22.8.3。[PUT] / management / server / {id}</strong></strong></h3></div></div></div><p><strong><strong>用指定的ID创建一个新的Kie Server模板</strong></strong></p><div class="example"><strong><strong><a id="d0e25612"></a><p class="title"><strong>示例22.35创建新的Kie Server模板的示例请求</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;server-template-details&gt;
    &lt;server-id&gt;test-demo&lt;/server-id&gt;
    &lt;server-name&gt;test-demo&lt;/server-name&gt;    
    &lt;configs/&gt;
    &lt;capabilities&gt;RULE&lt;/capabilities&gt;
    &lt;capabilities&gt;PROCESS&lt;/capabilities&gt;
    &lt;capabilities&gt;PLANNING&lt;/capabilities&gt;
&lt;/server-template-details&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.4。[删除] / management / server / {id}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25617"></a> 22.8.4。[删除] / management / server / {id}</strong></strong></h3></div></div></div><p><strong><strong>删除具有指定ID的Kie Server模板</strong></strong></p></div><div class="section" title="22.8.5。[GET] /管理/服务器/ {id} /容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25622"></a> 22.8.5。[GET] /管理/服务器/ {id} /容器</strong></strong></h3></div></div></div><p><strong><strong>返回给定服务器上的所有容器</strong></strong></p><div class="example"><strong><strong><a id="d0e25627"></a><p class="title"><strong>示例22.36服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;container-spec-list&gt;
    &lt;container-spec&gt;
        &lt;container-id&gt;hr&lt;/container-id&gt;
        &lt;container-name&gt;hr&lt;/container-name&gt;
        &lt;server-template-key&gt;
            &lt;server-id&gt;demo&lt;/server-id&gt;
        &lt;/server-template-key&gt;
        &lt;release-id&gt;
            &lt;artifact-id&gt;HR&lt;/artifact-id&gt;
            &lt;group-id&gt;org.jbpm&lt;/group-id&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/release-id&gt;
        &lt;configs&gt;
            &lt;entry&gt;
                &lt;key&gt;RULE&lt;/key&gt;
                &lt;value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                    &lt;scanner-status&gt;STOPPED&lt;/scanner-status&gt;
                &lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
                &lt;key&gt;PROCESS&lt;/key&gt;
                &lt;value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                    &lt;strategy&gt;Singleton&lt;/strategy&gt;
                    &lt;kie-base-name&gt;&lt;/kie-base-name&gt;
                    &lt;kie-session-name&gt;&lt;/kie-session-name&gt;
                    &lt;merge-mode&gt;Merge Collections&lt;/merge-mode&gt;
                &lt;/value&gt;
            &lt;/entry&gt;
        &lt;/configs&gt;
        &lt;status&gt;STARTED&lt;/status&gt;
    &lt;/container-spec&gt;
&lt;/container-spec-list&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.6。[GET] / management / server / {id} / containers / {containerId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25632"></a> 22.8.6。[GET] / management / server / {id} / containers / {containerId}</strong></strong></h3></div></div></div><p><strong><strong>返回容器信息，包括其发行ID和配置</strong></strong></p><div class="example"><strong><strong><a id="d0e25637"></a><p class="title"><strong>示例22.37服务器响应示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;container-spec-details&gt;
    &lt;container-id&gt;hr&lt;/container-id&gt;
    &lt;container-name&gt;hr&lt;/container-name&gt;
    &lt;server-template-key&gt;
        &lt;server-id&gt;demo&lt;/server-id&gt;
    &lt;/server-template-key&gt;
    &lt;release-id&gt;
        &lt;artifact-id&gt;HR&lt;/artifact-id&gt;
        &lt;group-id&gt;org.jbpm&lt;/group-id&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/release-id&gt;
    &lt;configs&gt;
        &lt;entry&gt;
            &lt;key&gt;PROCESS&lt;/key&gt;
            &lt;value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;strategy&gt;Singleton&lt;/strategy&gt;
                &lt;kie-base-name&gt;&lt;/kie-base-name&gt;
                &lt;kie-session-name&gt;&lt;/kie-session-name&gt;
                &lt;merge-mode&gt;Merge Collections&lt;/merge-mode&gt;
            &lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;RULE&lt;/key&gt;
            &lt;value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;scanner-status&gt;STOPPED&lt;/scanner-status&gt;
            &lt;/value&gt;
        &lt;/entry&gt;
    &lt;/configs&gt;
    &lt;status&gt;STARTED&lt;/status&gt;
&lt;/container-spec-details&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.7。[PUT] / management / server / {id} / containers / {containerId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25642"></a> 22.8.7。[PUT] / management / server / {id} / containers / {containerId}</strong></strong></h3></div></div></div><p><strong><strong>创建一个具有指定containerId和给定发行版ID以及可选配置的新Container</strong></strong></p><div class="example"><strong><strong><a id="d0e25647"></a><p class="title"><strong>示例22.38服务器请求示例</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;container-spec-details&gt;
    &lt;container-id&gt;hr&lt;/container-id&gt;
    &lt;container-name&gt;hr&lt;/container-name&gt;
    &lt;server-template-key&gt;
        &lt;server-id&gt;demo&lt;/server-id&gt;
    &lt;/server-template-key&gt;
    &lt;release-id&gt;
        &lt;artifact-id&gt;HR&lt;/artifact-id&gt;
        &lt;group-id&gt;org.jbpm&lt;/group-id&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/release-id&gt;
    &lt;configs&gt;
        &lt;entry&gt;
            &lt;key&gt;PROCESS&lt;/key&gt;
            &lt;value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;strategy&gt;Singleton&lt;/strategy&gt;
                &lt;kie-base-name&gt;&lt;/kie-base-name&gt;
                &lt;kie-session-name&gt;&lt;/kie-session-name&gt;
                &lt;merge-mode&gt;Merge Collections&lt;/merge-mode&gt;
            &lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;RULE&lt;/key&gt;
            &lt;value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                &lt;scanner-status&gt;STOPPED&lt;/scanner-status&gt;
            &lt;/value&gt;
        &lt;/entry&gt;
    &lt;/configs&gt;
    &lt;status&gt;STARTED&lt;/status&gt;
&lt;/container-spec-details</code></pre></div></strong></strong></div><strong><strong><br class="example-break"></strong></strong></div><div class="section" title="22.8.8。[删除] / management / server / {id} / containers / {containerId}"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25652"></a> 22.8.8。[删除] / management / server / {id} / containers / {containerId}</strong></strong></h3></div></div></div><p><strong><strong>使用指定的containerId处置Container</strong></strong></p></div><div class="section" title="22.8.9。[POST] / management / server / {id} / containers / {containerId} / status / started"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25657"></a> 22.8.9。[POST] / management / server / {id} / containers / {containerId} / status / started</strong></strong></h3></div></div></div><p><strong><strong>启动容器。无需请求正文</strong></strong></p></div><div class="section" title="22.8.10。[POST] / management / server / {id} / containers / {containerId} / status / stopped"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25662"></a> 22.8.10。[POST] / management / server / {id} / containers / {containerId} / status / stopped</strong></strong></h3></div></div></div><p><strong><strong>停止容器。无需请求正文</strong></strong></p></div></div><div class="section" title="22.9。Kie Server Java客户端API"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25667"></a> 22.9。Kie Server Java客户端API</strong></strong></h2></div></div></div><p><strong><strong>Kie Server具有出色的Java API，用于包装要发送到服务器的REST或JMS请求。在本节中，我们将探讨该API的一些可能性。</strong></strong></p><div class="section" title="22.9.1。Maven配置"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25672"></a> 22.9.1。Maven配置</strong></strong></h3></div></div></div><p><strong><strong>如果您是Maven用户，请确保在项目的<span class="emphasis"><em>pom.xml中</em></span>至少具有以下依赖项</strong></strong></p><div class="example"><strong><strong><a id="d0e25679"></a><p class="title"><strong>示例22.39Maven依赖</strong></p><div class="example-contents"><pre><code class="no-highlight">&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;${kie.api.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Logging --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
  &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Drools Commands --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;version&gt;${kie.api.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>版本<span class="emphasis"><em>kie.api.version</em></span>取决于您使用的Kie Server版本。例如，对于jBPM 6.3，可以使用6.3.1-SNAPSHOT。</p></strong></strong></div><div class="section" title="22.9.2。客户端配置"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25690"></a> 22.9.2。客户端配置</strong></strong></h3></div></div></div><p><strong><strong>客户端需要一个配置对象，您可以在其中设置大多数服务器通信方面，例如协议（REST和JMS）凭据和有效载荷格式（当前支持XStream，JAXB和JSON格式）。首先要做的是创建您的配置，然后创建<span class="bold"><strong><code class="code">KieServicesClient</code></strong></span>对象，开始服务器通信的入口点。请参阅以下使用REST客户端配置的源：</strong></strong></p><div class="example"><strong><strong><a id="d0e25700"></a><p class="title"><strong>示例22.40客户端配置示例</strong></p><div class="example-contents"><pre><code class="language-java">import org.kie.server.api.marshalling.MarshallingFormat;  
import org.kie.server.client.KieServicesClient;  
import org.kie.server.client.KieServicesConfiguration;  
import org.kie.server.client.KieServicesFactory;  
  
public class DecisionServerTest {  
  
    private static final String URL = "http://localhost:8080/kie-server/services/rest/server";  
    private static final String USER = "kieserver";  
    private static final String PASSWORD = "kieserver1!";  
  
    private static final MarshallingFormat FORMAT = MarshallingFormat.JSON;  
  
    private KieServicesConfiguration conf;  
    private KieServicesClient kieServicesClient;  
  
    public void initialize() {  
        conf = KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD);  
        conf.setMarshallingFormat(FORMAT);  
        kieServicesClient = KieServicesFactory.newKieServicesClient(conf);  
    }  </code></pre></div></strong></strong></div><p><strong><strong><br class="example-break"></strong></strong></p><div class="section" title="22.9.2.1。JMS交互模式"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e25706"></a> 22.9.2.1。JMS交互模式</strong></strong></h4></div></div></div><p><strong><strong>在6.5版中，KIE Server Client JMS集成得到增强，可以使用各种交互模式。当前可用的是：</strong></strong></p><p><strong><strong>
                </strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>请求回复（默认设置）-使JMS集成同步-阻止客户端直到获得响应-不适合JMS事务用例</strong></strong></p></li><li class="listitem"><p><strong><strong>一劳永逸-仅使集成成为一种方式，适合于与kie服务器集成之类的通知-非常适合事务性JMS传递-仅在成功调用ckie服务器客户端的事务成功提交后才向kie服务器传递消息</strong></strong></p></li><li class="listitem"><p><strong><strong>与回调异步-允许在向kie服务器发送消息并异步接收响应后不阻止客户端-可以与事务性JMS交付集成</strong></strong></p></li></ul></div><p><strong><strong>
            </strong></strong></p><p><strong><strong>响应处理程序可以全局设置-创建KieServicesConfiguration时，也可以在运行时在单个客户端实例（例如RuleServiceClient，ProcessServicesClient等）上进行更改</strong></strong></p><p><strong><strong>虽然“即发即弃”和“请求答复”模式不需要任何其他配置，但“与回调异步”却需要。最主要的是实际上是回调。KIE Server CLient提供了一个开箱即用的功能-`BlockingResponseCallback`，它通过内部阻塞队列来提供基本支持。队列的大小是可配置的，因此允许接收多条消息，尽管此回调的目的是一次只接收一条消息-因此就像一个消息（请求），然后每次客户端交互一个响应。</strong></strong></p><p><strong><strong>
                </strong></strong></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><h2><strong><strong>注意</strong></strong></h2><p><strong><strong>当切换响应处理程序不是线程安全的Kie Server Client时，这意味着更改处理程序将影响使用同一客户端实例的所有线程。因此，如果处理程序发生动态更改，建议使用单独的客户端实例。一个好的方法是维护一组使用专用响应处理程序的客户端，然后根据所需的处理程序来使用这些客户端。</strong></strong></p></div><p><strong><strong>
            </strong></strong></p><p><strong><strong><span class="bold"><strong>例</strong></span></strong></strong></p><p><strong><strong>客户端1将使用开火并忘记，而客户端2将使用请求回复。因此，客户端1可用于启动进程，而客户端2可用于查询用户任务。</strong></strong></p><p><strong><strong>用户可以通过实现<span class="italic">org.kie.server.client.jms提供自己的回调<span class="italic">。ResponseCallback</span>接口。</span></strong></strong></p><pre><code class="no-highlight">InitialContext context = ...;
Queue requestQueue = (Queue) context.lookup("jms/queue/KIE.SERVER.REQUEST"));
Queue responseQueue = (Queue) context.lookup("jms/queue/KIE.SERVER.RESPONSE");
ConnectionFactory connectionFactory = (ConnectionFactory) context.lookup("jms/RemoteConnectionFactory");
KieServicesConfiguration jmsConfiguration = KieServicesFactory.newJMSConfiguration( connectionFactory, requestQueue, responseQueue, "user", "password");
// here you set response handler globally
jmsConfiguration.setResponseHandler(new FireAndForgetResponseHandler());</code></pre><p><strong><strong>或者，实际上可能更常见的是在使用它们之前在各个客户端上设置处理程序</strong></strong></p><p><strong><strong>
                </strong></strong></p><pre><code class="no-highlight">ProcessServiceClient processClient = client.getServicesClient(ProcessServicesClient.class);
// change response handler for processClient others are not affected
processClient.setResponseHandler(new FireAndForgetResponseHandler());</code></pre><p><strong><strong>
            </strong></strong></p></div></div><div class="section" title="22.9.3。服务器响应"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25753"></a> 22.9.3。服务器响应</strong></strong></h3></div></div></div><p><strong><strong>所有服务响应均由对象表示<code class="code">org.kie.server.api.model.ServiceResponse<T></code>其中T是有效载荷的类型。它具有以下属性：</strong></strong></p><p><strong><strong><span class="bold"><strong>字符串消息：</strong></span>响应消息；</strong></strong></p><p><strong><strong><code class="code">org.kie.server.api.model.ServiceResponse.ResponseType</code> <span class="bold"><strong>类型：</strong></span>响应类型的枚举，可以是SUCCESS或FAILURE；</strong></strong></p><p><strong><strong><span class="bold"><strong>结果：</strong></span>响应的实际有效负载，即请求的对象。</strong></strong></p><p><strong><strong>请注意，如果您使用的是REST或JMS，则返回的对象是同一对象，换句话说，它与协议无关。</strong></strong></p></div><div class="section" title="22.9.4。服务器功能"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25777"></a> 22.9.4。服务器功能</strong></strong></h3></div></div></div><p><strong><strong>Decision Server最初仅支持规则执行，从6.3版开始，它开始支持业务流程执行。要知道服务器到底支持什么，可以通过访问对象列出服务器功能<code class="code">org.kie.server.api.model.KieServerInfo</code> <span class="bold"><strong> </strong></span>使用客户端：</strong></strong></p><div class="example"><strong><strong><a id="d0e25788"></a><p class="title"><strong>示例22.41清单服务器功能</strong></p><div class="example-contents"><pre><code class="language-java">public void listCapabilities() {  
    KieServerInfo serverInfo = kieServicesClient.getServerInfo().getResult();  
    System.out.print("Server capabilities:");  
    for(String capability: serverInfo.getCapabilities()) {  
        System.out.print(" " + capability);  
    }  
    System.out.println();  
}</code></pre></div></strong></strong></div><p><strong><strong><br class="example-break">如果服务器支持规则和过程，则在运行上面的代码时应打印以下内容：</strong></strong></p><p><strong><strong><span class="emphasis"><em>服务器功能：BRM KieServer BPM</em></span></strong></strong></p></div><div class="section" title="22.9.5。基氏容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25798"></a> 22.9.5。基氏容器</strong></strong></h3></div></div></div><p><strong><strong>如果要发布一个kjar来接收请求，则必须将其发布到一个容器中。容器在客户端由对象表示<code class="code">org.kie.server.api.model.KieContainerResource</code> ，并且资源列表是<code class="code">org.kie.server.api.model.KieContainerResourceList</code> 。这是有关如何打印容器列表的示例：</strong></strong></p><div class="example"><strong><strong><a id="d0e25809"></a><p class="title"><strong>示例22.42列出基伊容器</strong></p><div class="example-contents"><pre><code class="language-java">public void listContainers() {  
    KieContainerResourceList containersList = kieServicesClient.listContainers().getResult();  
    List&lt;KieContainerResource&gt; kieContainers = containersList.getContainers();  
    System.out.println("Available containers: ");  
    for (KieContainerResource container : kieContainers) {  
        System.out.println("\t" + container.getContainerId() + " (" + container.getReleaseId() + ")");  
    }  
}</code></pre></div></strong></strong></div><p><strong><strong><br class="example-break">也可以根据具体情况列出容器<code class="code">ReleaseId</code> （及其各个部分）或容器状态：</strong></strong></p><div class="example"><strong><strong><a id="d0e25819"></a><p class="title"><strong>示例22.43列出带有自定义过滤器的Kie容器</strong></p><div class="example-contents"><pre><code class="language-java">public void listContainersWithFilter() {
    // the following filter will match only containers with ReleaseId "org.example:contatner:1.0.0.Final" and status FAILED
    KieContainerResourceFilter filter = new KieContainerResourceFilter.Builder()
            .releaseId("org.example", "container", "1.0.0.Final")
            .status(KieContainerStatus.FAILED)
            .build();
    KieContainerResourceList containersList = kieServicesClient.listContainers(filter).getResult();
    List&lt;KieContainerResource&gt; kieContainers = containersList.getContainers();
    System.out.println("Available containers: ");
    for (KieContainerResource container : kieContainers) {
        System.out.println("\t" + container.getContainerId() + " (" + container.getReleaseId() + ")");
    }
}</code></pre></div></strong></strong></div><p><strong><strong><br class="example-break">
    </strong></strong></p></div><div class="section" title="22.9.6。管理容器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25826"></a> 22.9.6。管理容器</strong></strong></h3></div></div></div><p><strong><strong>您可以使用客户端来处置和创建容器。如果处置容器，将返回带有Void有效载荷（无有效载荷）的ServiceResponse，如果创建了容器，则将在响应中返回KieContainerResource对象本身。样例代码：</strong></strong></p><div class="example"><strong><strong><a id="d0e25831"></a><p class="title"><strong>示例22.44处置和创建容器</strong></p><div class="example-contents"><pre><code class="language-java">public void disposeAndCreateContainer() {  
    System.out.println("== Disposing and creating containers ==");  
    List&lt;KieContainerResource&gt; kieContainers = kieServicesClient.listContainers().getResult().getContainers();  
    if (kieContainers.size() == 0) {  
        System.out.println("No containers available...");  
        return;  
    }  
    KieContainerResource container = kieContainers.get(0);  
    String containerId = container.getContainerId();  
    ServiceResponse&lt;Void&gt; responseDispose = kieServicesClient.disposeContainer(containerId);  
    if (responseDispose.getType() == ResponseType.FAILURE) {  
        System.out.println("Error disposing " + containerId + ". Message: ");  
        System.out.println(responseDispose.getMsg());  
        return;  
    }  
    System.out.println("Success Disposing container " + containerId);  
    System.out.println("Trying to recreate the container...");  
    ServiceResponse&lt;KieContainerResource&gt; createResponse = kieServicesClient.createContainer(containerId, container);  
    if(createResponse.getType() == ResponseType.FAILURE) {  
        System.out.println("Error creating " + containerId + ". Message: ");  
        System.out.println(responseDispose.getMsg());  
        return;  
    }  
     System.out.println("Container recreated with success!");  
}</code></pre></div></strong></strong></div><p><strong><strong><br class="example-break"></strong></strong></p></div><div class="section" title="22.9.7。决策服务器的可用客户端"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25837"></a> 22.9.7。决策服务器的可用客户端</strong></strong></h3></div></div></div><p><strong><strong>KieServicesClient还是其他客户端执行特定操作（例如发送BRMS命令和管理进程）的入口点。当前，您可以从KieServicesClient访问以下可用的服务： <code class="code">org.kie.server.client</code>包：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>JobServicesClient：此客户端允许您计划，取消，重新排队和获取工作请求；</strong></strong></p></li><li class="listitem"><p><strong><strong>ProcessServicesClient：允许您启动并发出中止过程的信号；完成和中止工作项目以及其他功能；</strong></strong></p></li><li class="listitem"><p><strong><strong>QueryServicesClient：强大的查询客户端，您可以查询流程，流程节点和流程变量；</strong></strong></p></li><li class="listitem"><p><strong><strong>RuleServicesClient：简单但功能强大的规则客户端可用于将命令发送到服务器以执行与规则相关的操作（将对象插入工作内存，启动规则，获取全局变量...）;</strong></strong></p></li><li class="listitem"><p><strong><strong>UserTaskServicesClient：最后，用户任务客户端使您可以对用户任务（开始，声明，取消等）执行所有操作，并通过某些字段（流程实例ID，用户等）查询任务。</strong></strong></p></li></ul></div><p><strong><strong>有关这些接口的更多信息，请检查github：https://github.com/droolsjbpm/droolsjbpm-integration/tree/master/kie-server-parent/kie-server-remote/kie-server-client/src/main/java / org / kie / server / client</strong></strong></p><p><strong><strong>您可以使用方法访问这些客户端中的任何一个<code class="code">getServicesClient</code>在KieServicesClient类中。例如：<code class="code">RuleServicesClient rulesClient = kieServicesClient.getServicesClient(RuleServicesClient.class);</code></strong></strong></p></div><div class="section" title="22.9.8。将命令发送到服务器"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25870"></a> 22.9.8。将命令发送到服务器</strong></strong></h3></div></div></div><p><strong><strong>要向服务器构建命令，必须使用org.kie.api.command类。可以使用以下命令创建的KieCommands <code class="code">org.kie.api.KieServices.get().getCommands()</code> 。要发送的命令必须是<span class="bold"><strong>BatchExecutionCommand</strong></span>或单个命令（如果发送单个命令，则服务器将其包装到BatchExecutionCommand中）：</strong></strong></p><div class="example"><strong><strong><a id="d0e25882"></a><p class="title"><strong>示例22.45将命令发送到容器</strong></p><div class="example-contents"><pre><code class="language-java">public void executeCommands() {  
    System.out.println("== Sending commands to the server ==");  
    RuleServicesClient rulesClient = kieServicesClient.getServicesClient(RuleServicesClient.class);  
    KieCommands commandsFactory = KieServices.Factory.get().getCommands();  
    Command&lt;?&gt; insert = commandsFactory.newInsert("Some String OBJ");  
    Command&lt;?&gt; fireAllRules = commandsFactory.newFireAllRules();  
    Command&lt;?&gt; batchCommand = commandsFactory.newBatchExecution(Arrays.asList(insert, fireAllRules));  
    ServiceResponse&lt;String&gt; executeResponse = rulesClient.executeCommands("hello", batchCommand);  
    if(executeResponse.getType() == ResponseType.SUCCESS) {  
        System.out.println("Commands executed with success! Response: ");  
        System.out.println(executeResponse.getResult());  
    }  
    else {  
        System.out.println("Error executing rules. Message: ");  
        System.out.println(executeResponse.getMsg());  
    }  
}  </code></pre><p>在这种情况下，结果是带有命令执行结果的字符串。在我们的情况下，它将打印以下内容：</p><pre><code class="no-highlight">    == Sending commands to the server ==  
    Commands executed with success! Response:   
    {  
      "results" : [ ],  
      "facts" : [ ]  
    }  </code></pre><p><span class="emphasis"><em>*您必须添加<span class="bold"><strong>org.drools：drools-compiler</strong></span>依赖关系才能使此部分正常工作</em></span></p></div></strong></strong></div><p><strong><strong><br class="example-break"></strong></strong></p></div><div class="section" title="22.9.9。列出可用的业务流程"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e25897"></a> 22.9.9。列出可用的业务流程</strong></strong></h3></div></div></div><p><strong><strong>要列出流程定义，我们使用QueryClient。QueryClient的方法通常使用分页，这意味着除了要进行的查询外，还必须提供当前页面和每页结果的数量。在下面的代码中，从给定容器中查询流程定义的查询从第0页开始，并列出1000个结果，换句话说，列出了1000个第一结果。</strong></strong></p><div class="example"><strong><strong><a id="d0e25903"></a><p class="title"><strong>示例22.46列出业务流程定义示例</strong></p><div class="example-contents"><pre><code class="language-java">public void listProcesses() {  
    System.out.println("== Listing Business Processes ==");  
    QueryServicesClient queryClient = kieServicesClient.getServicesClient(QueryServicesClient.class);  
    List&lt;ProcessDefinition&gt; findProcessesByContainerId = queryClient.findProcessesByContainerId("rewards", 0, 1000);  
    for (ProcessDefinition def : findProcessesByContainerId) {  
        System.out.println(def.getName() + " - " + def.getId() + " v" + def.getVersion());  
    }  
} </code></pre></div></strong></strong></div><p><strong><strong><br class="example-break"></strong></strong></p></div></div></div></div><div class="part" title="第七部分流口水的例子"><div class="titlepage"><div><div><h1 class="title"><strong><strong><a id="d0e25909"></a>第七部分流口水的例子</strong></strong></h1></div></div></div><div class="partintro" title="流口水的例子"><div></div><p><strong><strong>帮助您学习Drools的示例</strong></strong></p><div class="toc"><p><strong><strong><strong>目录</strong></strong></strong></p><dl><dt><strong><strong><span class="chapter"><a href="#d0e25915">23。例子</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e25918">23.1。得到例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25925">23.2。你好，世界</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e26213">23.3。状态示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e26218">23.3.1。了解状态示例</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e26472">23.4。斐波那契示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e26678">23.5。银行教程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27005">23.6。定价规则决策表示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e27029">23.6.1。执行示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27071">23.6.2。决策表</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e27136">23.7。宠物店的例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27716">23.8。诚实的政客例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27845">23.9。数独示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e27866">23.9.1。数独概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27880">23.9.2。运行示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27953">23.9.3。Java源代码和规则概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28083">23.9.4。数独验证器规则（validate.drl）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28092">23.9.5。数独求解规则（sudoku.drl）</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28128">23.10。猜数字</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28419">23.11。康威的人生游戏</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28568">23.12。侵略者</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28601">23.12.1。侵略者1</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28613">23.12.2。侵略者2</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28623">23.12.3。侵略者3</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28633">23.12.4。侵略者4</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28643">23.12.5。侵略者5</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28648">23.12.6。侵略者6</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28653">23.12.7。侵略者4</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28663">23.13。流口水的冒险</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28691">23.13.1。使用游戏。</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28725">23.13.2。代码</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28763">23.14。傍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28781">23.15。乌鸦世界</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28828">23.16。礼貌小姐和标杆管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28850">23.16.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28936">23.16.2。深入讨论</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29146">23.16.3。输出汇总</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e29201">23.17。后向链</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e29215">23.17.1。后向链系统</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29220">23.17.2。克隆传递性闭包</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29250">23.17.3。定义查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29275">23.17.4。传递闭包示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29347">23.17.5。反应式传递查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29372">23.17.6。具有未绑定参数的查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29391">23.17.7。多个未绑定参数</a></span></strong></strong></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" title="第23章例子"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25915"></a>第23章例子</strong></strong></h2></div></div></div><div class="toc"><dl><dt><strong><strong><span class="section"><a href="#d0e25918">23.1。得到例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e25925">23.2。你好，世界</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e26213">23.3。状态示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e26218">23.3.1。了解状态示例</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e26472">23.4。斐波那契示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e26678">23.5。银行教程</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27005">23.6。定价规则决策表示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e27029">23.6.1。执行示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27071">23.6.2。决策表</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e27136">23.7。宠物店的例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27716">23.8。诚实的政客例子</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27845">23.9。数独示例</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e27866">23.9.1。数独概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27880">23.9.2。运行示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e27953">23.9.3。Java源代码和规则概述</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28083">23.9.4。数独验证器规则（validate.drl）</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28092">23.9.5。数独求解规则（sudoku.drl）</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28128">23.10。猜数字</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28419">23.11。康威的人生游戏</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28568">23.12。侵略者</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28601">23.12.1。侵略者1</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28613">23.12.2。侵略者2</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28623">23.12.3。侵略者3</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28633">23.12.4。侵略者4</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28643">23.12.5。侵略者5</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28648">23.12.6。侵略者6</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28653">23.12.7。侵略者4</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28663">23.13。流口水的冒险</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28691">23.13.1。使用游戏。</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28725">23.13.2。代码</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e28763">23.14。傍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28781">23.15。乌鸦世界</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28828">23.16。礼貌小姐和标杆管理</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e28850">23.16.1。介绍</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e28936">23.16.2。深入讨论</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29146">23.16.3。输出汇总</a></span></strong></strong></dt></dl></dd><dt><strong><strong><span class="section"><a href="#d0e29201">23.17。后向链</a></span></strong></strong></dt><dd><dl><dt><strong><strong><span class="section"><a href="#d0e29215">23.17.1。后向链系统</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29220">23.17.2。克隆传递性闭包</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29250">23.17.3。定义查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29275">23.17.4。传递闭包示例</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29347">23.17.5。反应式传递查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29372">23.17.6。具有未绑定参数的查询</a></span></strong></strong></dt><dt><strong><strong><span class="section"><a href="#d0e29391">23.17.7。多个未绑定参数</a></span></strong></strong></dt></dl></dd></dl></div><div class="section" title="23.1。得到例子"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25918"></a> 23.1。得到例子</strong></strong></h2></div></div></div><p><strong><strong>确保已安装Drools Eclipse插件，该插件需要首先安装图形编辑框架（GEF）依赖项。然后下载并提取drools-examples zip文件，其中包括一个已经创建的Eclipse项目。将该项目导入到新的Eclipse工作区中。规则均具有执行规则的示例类。如果您想在另一个项目（或另一个IDE）中尝试这些示例，那么您当然需要手动设置依赖项。请享受下面的许多（但不是全部）示例！</strong></strong></p><p><strong><strong>一些示例要求Java 1.6才能运行。</strong></strong></p></div><div class="section" title="23.2。你好，世界"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e25925"></a> 23.2。你好，世界</strong></strong></h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Hello World
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.helloworld.HelloWorldExample
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HelloWorld.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate basic rules in use</pre><p><strong><strong>“ Hello World”示例显示了一个使用规则的简单应用程序，该规则同时使用MVEL和Java方言编写。</strong></strong></p><p><strong><strong>本示例说明了如何创建和使用<code class="code">KieSession</code> 。此外，还显示了审计日志记录和调试输出，由于它们非常相似，因此在其他示例中将其省略。</strong></strong></p><p><strong><strong>以下代码段显示了如何仅用3行代码创建会话。</strong></strong></p><div class="example"><strong><strong><a id="d0e25956"></a><p class="title"><strong>示例23.1HelloWorld：创建KieSession</strong></p><div class="example-contents"><pre><code class="language-java">        KieServices ks = KieServices.Factory.get();<a class="co" id="co.helloworld.pl.1" href="#helloworld.pl.1"><img src="images/callouts/1.png" alt="1" border="0"/></a>
        KieContainer kc = ks.getKieClasspathContainer();<a class="co" id="co.helloworld.pl.2" href="#helloworld.pl.2"><img src="images/callouts/2.png" alt="2" border="0"/></a>
        KieSession ksession = kc.newKieSession("HelloWorldKS");<a class="co" id="co.helloworld.pl.3" href="#helloworld.pl.3"><img src="images/callouts/3.png" alt="3" border="0"/></a> </code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a id="helloworld.pl.1"></a><a href="#co.helloworld.pl.1"><img src="images/callouts/1.png" alt="1个" border="0"></a> </p></td><td valign="top" align="left"><p>获得<code class="code">KieServices</code>厂。这是应用程序用来与引擎交互的主要界面。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a id="helloworld.pl.2"></a><a href="#co.helloworld.pl.2"><img src="images/callouts/2.png" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>创建一个<code class="code">KieContainer</code>从项目的类路径。这将寻找一个<code class="filename">/META-INF/kmodule.xml</code>文件来配置和实例化<code class="code">KieModule</code>进入<code class="code">KieContainer</code> 。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a id="helloworld.pl.3"></a><a href="#co.helloworld.pl.3"><img src="images/callouts/3.png" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>基于命名的“ HelloWorldKS”会话配置创建会话。</p></td></tr></tbody></table></div><p>Drools有一个事件模型，可以揭示内部发生的许多事情。提供了两个默认的调试侦听器， <code class="code">DebugAgendaEventListener</code>和<code class="code">DebugWorkingMemoryEventListener</code>将调试事件信息打印到<code class="code">System.err</code>控制台窗口中显示的流。如下面的代码片段所示，将侦听器添加到Session很简单。的<code class="code">KieRuntimeLogger</code>提供执行审计，其结果可以在图形查看器中查看。记录器实际上是基于<code class="code">Agenda</code>和<code class="code">RuleRuntime</code>听众。引擎执行完毕后， <code class="code">logger.close()</code>必须被调用。</p><p>大多数示例使用Drools的Audit日志记录功能来记录执行流，以供以后检查。</p><div class="example"><a id="d0e26017"></a><p class="title"><strong>示例23.2HelloWorld：事件记录和审核</strong></p><div class="example-contents"><pre><code class="language-java">        // The application can also setup listeners
        ksession.addEventListener( new DebugAgendaEventListener() );
        ksession.addEventListener( new DebugRuleRuntimeEventListener() );

        // To setup a file based audit logger, uncomment the next line 
        // KieRuntimeLogger logger = ks.getLoggers().newFileLogger( ksession, "./helloworld" );
        
        // To setup a ThreadedFileLogger, so that the audit view reflects events whilst debugging,
        // uncomment the next line
        // KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, "./helloworld", 1000 );</code></pre></div></div><br class="example-break"><p>本示例中使用的单个类非常简单。它有两个字段：消息，这是一个<code class="code">String</code>状态可以是两个整数之一<code class="code">HELLO</code>要么<code class="code">GOODBYE</code> 。</p><div class="example"><a id="d0e26033"></a><p class="title"><strong>示例23.3HelloWorld示例：消息类</strong></p><div class="example-contents"><pre><code class="language-java">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status; 
    ...
}</code></pre></div></div><br class="example-break"><p>一个<code class="code">Message</code>使用消息文本“ Hello World”和状态创建对象<code class="code">HELLO</code>然后插入引擎中<code class="code">fireAllRules()</code>被执行。</p><div class="example"><a id="d0e26049"></a><p class="title"><strong>示例23.4HelloWorld：执行</strong></p><div class="example-contents"><pre><code class="language-java">        // The application can insert facts into the session
        final Message message = new Message();
        message.setMessage( "Hello World" );
        message.setStatus( Message.HELLO );
        ksession.insert( message );

        // and fire the rules
        ksession.fireAllRules();</code></pre></div></div><br class="example-break"><p>要将示例作为Java应用程序执行：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开课<code class="code">org.drools.examples.helloworld.HelloWorldExample</code>在您的Eclipse IDE中</p></li><li class="listitem"><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>如果我们在<code class="code">fireAllRules()</code>方法，然后选择<code class="code">ksession</code>变量，我们可以看到“ Hello World”规则已在议程中激活。</p><div class="figure"><a id="d0e26074"></a><p class="title"><strong>图23.1你好世界：fireAllRules议程视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/HelloWorldExample/helloworld_agenda1.png" alt="你好世界：fireAllRules议程视图"></div></div></div><br class="figure-break"><p>应用程序打印输出到<code class="code">System.out</code>而调试侦听器的打印输出转到<code class="code">System.err</code> 。</p><div class="example"><a id="d0e26088"></a><p class="title"><strong>示例23.5HelloWorld：“控制台”窗口中的System.out</strong></p><div class="example-contents"><pre><code class="no-highlight">Hello World
Goodbye cruel world</code></pre></div></div><br class="example-break"><div class="example"><a id="d0e26093"></a><p class="title"><strong>示例23.6HelloWorld：“控制台”窗口中的System.err</strong></p><div class="example-contents"><pre><code class="no-highlight">==&gt;[ActivationCreated(0): rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                 object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World; 
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                old_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96;
                new_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye; 
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]  </code></pre></div></div><br class="example-break"><p>实际规则在文件内<code class="filename">src/main/resources/org/drools/examples/helloworld/HelloWorld.drl</code> ：</p><div class="example"><a id="d0e26103"></a><p class="title"><strong>示例23.7HelloWorld：规则“ Hello World”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Hello World"
      dialect "mvel"
  when
      m : Message( status == Message.HELLO, message : message )
  then
      System.out.println( message ); 
      modify ( m ) { message = "Goodbye cruel world",
                     status = Message.GOODBYE };
end</code></pre></div></div><br class="example-break"><p>LHS（后<code class="literal">when</code> ）部分指出，该规则将针对每个<code class="code">Message</code>插入状态为“规则运行时”的对象<code class="code">Message.HELLO</code> 。除此之外，还创建了两个变量绑定： <code class="code">message</code>绑定到<code class="code">message</code>属性和变量<code class="code">m</code>绑定到匹配项<code class="code">Message</code>对象本身。</p><p>RHS（之后<code class="literal">then</code> ）或规则的结果部分使用MVEL表达式语言（由规则的属性声明）编写<code class="code">dialect</code> 。打印完绑定变量的内容后<code class="code">message</code>至<code class="code">System.out</code> ，该规则会更改<code class="code">message</code>和<code class="code">status</code>的属性<code class="code">Message</code>绑定对象<code class="code">m</code> 。这是使用MVEL的<code class="literal">modify</code>语句，它使您可以在一个语句中应用分配的块，并在该块的末尾自动将更改通知引擎。</p><p>可以在DRL上设置一个断点<code class="literal">modify</code>调用，并在规则结果执行期间再次检查“议程”视图。这次我们通过“调试为”和“ Drools应用程序”开始执行，而不是通过运行“ Java应用程序”开始执行：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开课<code class="code">org.drools.examples.HelloWorld</code>在您的Eclipse IDE中。</p></li><li class="listitem"><p>右键单击该类，然后选择“调试为...”，然后选择“ Drools应用程序”。</p></li></ol></div><p>现在我们可以看到另一条规则<code class="code">"Good Bye"</code>使用Java语言的，被激活并放在议程中。</p><div class="figure"><a id="d0e26180"></a><p class="title"><strong>图23.2Hello World：规则“ Hello World”议程视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/HelloWorldExample/helloworld_agenda2.png" alt="你好世界：规则" hello="" worl="=" =""></div></div></div><br class="figure-break"><p>指定“ java”方言的“再见”规则与“ Hello World”规则相似，只不过它匹配<code class="code">Message</code>状态为<code class="code">Message.GOODBYE</code> 。</p><div class="example"><a id="d0e26194"></a><p class="title"><strong>示例23.8HelloWorld：规则“再见”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Good Bye"
      dialect "java"
  when
      Message( status == Message.GOODBYE, message : message )
  then
      System.out.println( message ); 
end</code></pre></div></div><br class="example-break"><p>实例化Java代码的Java代码<code class="code">KieRuntimeLogger</code>创建可以加载到“审核”视图中的审核日志文件。许多示例中都使用了Audit视图，以演示示例执行流程。在下面的视图屏幕快照中，我们可以看到已插入对象，从而为“ Hello World”规则创建了一个激活。然后执行激活，更新<code class="code">Message</code>导致“再见”规则激活的对象；最后，“再见”规则也将执行。在“审核”视图中选择一个事件，以绿色突出显示该原始事件；因此，“激活已创建”事件以绿色突出显示为“激活已执行”事件的来源。</p><div class="figure"><a id="d0e26207"></a><p class="title"><strong>图23.3Hello World：审核视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/HelloWorldExample/helloworld_auditview1.png" alt="Hello World：审核视图"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="23.3。状态示例"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e26213"></a> 23.3。状态示例</strong></strong></h2></div></div></div><p><strong><strong>此示例以两种不同的版本实现，以演示实现相同基本行为的不同方式：正向链接，即引擎必须基于工作内存中事实的变化依次评估，激活和触发规则的能力。</strong></strong></p><div class="section" title="23.3.1。了解状态示例"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e26218"></a> 23.3.1。了解状态示例</strong></strong></h3></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> State Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.state.StateExampleUsingSalience
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> StateExampleUsingSalience.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates basic rule use and Conflict Resolution for rule firing priority.</pre><p><strong><strong>每<code class="code">State</code>该类具有用于其名称和当前状态的字段（请参阅该类<code class="code">org.drools.examples.state.State</code> ）。每个对象的两种可能状态是：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="code">NOTRUN</code></strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">FINISHED</code></strong></strong></p></li></ul></div><div class="example"><strong><strong><a id="d0e26257"></a><p class="title"><strong>示例23.9州级</strong></p><div class="example-contents"><pre><code class="language-java">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>忽略<code class="code">PropertyChangeSupport</code> ，这将在后面解释，我们看到创建了四个<code class="code">State</code>对象名为A，B，C和D。最初，它们的状态设置为<code class="code">NOTRUN</code> ，这是所用构造函数的默认值。每个实例依次在Session中声明，然后<code class="code">fireAllRules()</code>叫做。</p><div class="example"><a id="d0e26276"></a><p class="title"><strong>示例23.10显着状态：执行</strong></p><div class="example-contents"><pre><code class="language-java">        final State a = new State( "A" );
        final State b = new State( "B" );
        final State c = new State( "C" );
        final State d = new State( "D" );

        ksession.insert( a );
        ksession.insert( b );
        ksession.insert( c );
        ksession.insert( d );

        ksession.fireAllRules();

        ksession.dispose(); // Stateful rule session must always be disposed when finished  </code></pre></div></div><br class="example-break"><p>要执行该应用程序：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开课<code class="code">org.drools.examples.state.StateExampleUsingSalience</code>在您的Eclipse IDE中。</p></li><li class="listitem"><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>您将在Eclipse控制台窗口中看到以下输出：</p><div class="example"><a id="d0e26295"></a><p class="title"><strong>示例23.11显着状态：控制台输出</strong></p><div class="example-contents"><pre><code class="no-highlight">A finished
B finished
C finished
D finished
</code></pre></div></div><br class="example-break"><p>共有四个规则。首先， <code class="code">Bootstrap</code>规则触发，将A设置为state <code class="code">FINISHED</code> ，然后导致B将其状态更改为<code class="code">FINISHED</code> 。C和D都依赖于B，从而导致冲突，该冲突由显着性值解决。让我们看看它的执行方式。</p><p>了解发生情况的最佳方法是使用“审核日志记录”功能以图形方式查看每个操作的结果。要查看此示例的运行生成的审核日志：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>如果看不到审计视图，请单击“窗口”，然后选择“显示视图”，然后选择“其他...”和“流口水”，最后选择“审计视图”。</p></li><li class="listitem"><p>在“审核视图”中，单击“打开日志”按钮，然后选择文件“ <drools-examples-dir>/log/state.log”。</drools-examples-dir></p></li></ol></div><p>之后，“审核视图”将类似于以下屏幕截图：</p><div class="figure"><a id="d0e26322"></a><p class="title"><strong>图23.4。显着性状态示例审核视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/StateExample/state_example_audit1.png" alt="显着性状态示例审核视图"></div></div></div><br class="figure-break"><p>从上至下阅读“审核视图”中的日志，我们会看到每个操作以及工作内存中的相应更改。这样，我们观察到状态中状态对象A的断言<code class="code">NOTRUN</code>激活<code class="code">Bootstrap</code>规则，而另一方的断言<code class="code">State</code>对象没有立竿见影的效果。</p><div class="example"><a id="d0e26339"></a><p class="title"><strong>示例23.12显着状态：规则“引导程序”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</code></pre></div></div><br class="example-break"><p>规则Bootstrap的执行将A的状态更改为<code class="code">FINISHED</code> ，依次激活规则“ A至B”。</p><div class="example"><a id="d0e26349"></a><p class="title"><strong>示例23.13显着状态：规则“ A至B”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</code></pre></div></div><br class="example-break"><p>规则“ A到B”的执行将B的状态更改为<code class="code">FINISHED</code> ，这会激活规则“ B到C”和“ B到D”，并将它们的激活置于议程中。从这一刻起，两条规则都可能启动，因此，它们被称为“冲突中”。冲突解决策略使引擎的议程可以决定要触发的规则。由于规则“ B到C”具有<span class="bold"><strong>更高的显着性值</strong></span> （10相对于默认显着性值0），因此它将首先触发，将对象C修改为状态<code class="code">FINISHED</code> 。上面显示的“审核”视图反映了对<code class="code">State</code>规则“ A到B”中的“对象”，则导致两次激活发生冲突。议程视图还可以用于调查议程的状态，将调试点放置在规则本身中，并打开议程视图。下面的屏幕快照显示了规则“ A至B”中的断点以及具有两个冲突规则的议程状态。</p><div class="figure"><a id="d0e26368"></a><p class="title"><strong>图23.5。状态示例议程视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/StateExample/state_example_agenda1.png" alt="状态示例议程视图"></div></div></div><br class="figure-break"><div class="example"><a id="d0e26374"></a><p class="title"><strong>示例23.14显着状态：规则“ B到C”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</code></pre></div></div><br class="example-break"><p>规则“ B to D”最后触发，将对象D修改为状态<code class="code">FINISHED</code> 。</p><div class="example"><a id="d0e26384"></a><p class="title"><strong>示例23.15显着状态：规则“ B到D”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</code></pre></div></div><br class="example-break"><p>没有更多要执行的规则，因此引擎停止了。</p><p>在这个例子中另一个值得注意的概念是使用<span class="emphasis"><em>动态事实</em></span>的基础上， <code class="code">PropertyChangeListener</code>对象。如文档中所述，为了使引擎能够查看事实属性的变化并对变化做出反应，应用程序必须告知引擎发生了变化。可以在规则中使用<code class="literal">modify</code>语句，或通过让引擎知道事实实现来隐式<code class="code">PropertyChangeSupport</code>由<span class="emphasis"><em>JavaBeans规范</em></span>定义。这个例子演示了如何使用<code class="code">PropertyChangeSupport</code>避免需要明确<code class="literal">modify</code>规则中的声明。要使用此功能，请确保您的事实得以实现<code class="code">PropertyChangeSupport</code> ，与上课方式相同<code class="code">org.drools.example.State</code>并在规则文件中使用以下代码将引擎配置为侦听这些事实的属性更改：</p><div class="example"><a id="d0e26420"></a><p class="title"><strong>示例23.16声明动态事实</strong></p><div class="example-contents"><pre><code class="language-java">declare type State
    @propertyChangeSupport
end</code></pre></div></div><br class="example-break"><p>使用时<code class="code">PropertyChangeListener</code>对象，每个设置器必须为通知实现一些额外的代码。这是二传手<code class="code">state</code>在课堂里<code class="code">org.drools.examples</code> ：</p><div class="example"><a id="d0e26436"></a><p class="title"><strong>示例23.17具有PropertyChangeSupport的Setter示例</strong></p><div class="example-contents"><pre><code class="language-java">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</code></pre></div></div><br class="example-break"><p>此示例中还有另一个类： <code class="code">StateExampleUsingAgendaGroup</code> 。如图所示，它从A到B到C到D执行，但是<code class="code">StateExampleUsingAgendaGroup</code>使用议程组控制规则冲突，首先触发哪个规则。</p><p>议程组是一种将议程划分为组并控制可以执行的组的方法。默认情况下，所有规则都在议程组“ MAIN”中。通过“议程组”属性，您可以为规则指定其他议程组。最初，工作记忆将重点放在议程组“ MAIN”上。只有当小组获得焦点时，小组的规则才会触发。ny可以使用<code class="code">setFocus()</code>或规则属性<code class="literal">auto-focus</code> 。 “自动聚焦”是指当规则被匹配并激活时，规则自动将焦点设置到其议程组。正是这种“自动聚焦”使规则“ B至C”在“ B至D”之前触发。</p><div class="example"><a id="d0e26457"></a><p class="title"><strong>示例23.18议程组状态示例：规则“ B到C”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</code></pre></div></div><br class="example-break"><p>规则“ B到C”调用<code class="code">setFocus()</code>议程组“ B to D”上的规则，从而激活其活动规则，从而激活规则“ B to D”。</p><div class="example"><a id="d0e26467"></a><p class="title"><strong>示例23.19议程组状态示例：规则“ B到D”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</code></pre></div></div><br class="example-break"></strong></strong></div></div><div class="section" title="23.4。斐波那契示例"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e26472"></a> 23.4。斐波那契示例</strong></strong></h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> Fibonacci 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.fibonacci.FibonacciExample
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> Fibonacci.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates Recursion,
  the CE <code class="literal">not</code> and cross product matching</pre><p><strong><strong>比萨的莱昂纳多（Leonardo）发现的斐波那契数字（参见<a class="link" href="http://en.wikipedia.org/wiki/Fibonacci_number">http://en.wikipedia.org/wiki/Fibonacci_number</a> ）（参见<a class="link" href="http://en.wikipedia.org/wiki/Fibonacci">http://en.wikipedia.org/wiki/Fibonacci</a> ）是一个以0和1开头的序列。通过将两个前面的斐波那契数相加来获得下一个斐波那契数。斐波那契数列以0、1、1、2、3、5、8、13、21、34、55、89、144、233、377、610、987、1597、2584、4181、6765、10946开始。 ..Fibonacci示例演示了具有显着性值的递归和冲突解决方案。</strong></strong></p><p><strong><strong>单一事实类<code class="code">Fibonacci</code>在此示例中使用。它具有两个字段，顺序和值。序列字段用于指示对象在斐波那契数列中的位置。值字段显示该斐波那契对象对该序列位置的值，使用-1指示仍需要计算的值。</strong></strong></p><div class="example"><strong><strong><a id="d0e26510"></a><p class="title"><strong>示例23.20斐波那契级</strong></p><div class="example-contents"><pre><code class="language-java">public static class Fibonacci {
    private int  sequence;
    private long value;

    public Fibonacci( final int sequence ) {
        this.sequence = sequence;
        this.value = -1;
    }

    ... setters and getters go here...
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>执行示例：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>开课<code class="classname">org.drools.examples.fibonacci.FibonacciExample</code>在您的Eclipse IDE中。</p></li><li class="listitem"><p>右键单击该类，然后选择“运行方式...”，然后选择“ Java应用程序”</p></li></ol></div><p>Eclipse在其控制台窗口中显示以下输出（“ ... snip ...”指示已删除以节省空间的行）：</p><div class="example"><a id="d0e26529"></a><p class="title"><strong>示例23.21。Fibonacci示例：控制台输出</strong></p><div class="example-contents"><pre><code class="no-highlight">recurse for 50
recurse for 49
recurse for 48
recurse for 47
...snip...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...snip...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025
</code></pre></div></div><br class="example-break"><p>为了从Java开始，我们只插入一个Fibonacci对象，其序列字段为50。然后使用递归规则插入其他49 <code class="code">Fibonacci</code>对象。这个例子不使用<code class="code">PropertyChangeSupport</code> 。它使用MVEL方言，这意味着我们可以使用<code class="literal">modify</code>关键字，它允许执行块设置程序操作，该操作还通知引擎更改。</p><div class="example"><a id="d0e26545"></a><p class="title"><strong>示例23.22斐波那契示例：执行</strong></p><div class="example-contents"><pre><code class="language-java">ksession.insert( new Fibonacci( 50 ) );
ksession.fireAllRules();</code></pre></div></div><br class="example-break"><p>规则递归非常简单。它匹配每个断言<code class="code">Fibonacci</code>值为-1的对象，创建并声明一个新的<code class="code">Fibonacci</code>序列比当前匹配的对象少一个的对象。每次添加Fibonacci对象时，不存在序列字段等于1的对象，规则都会重新匹配并重新触发。的<code class="literal">not</code>一旦我们在内存中存储了全部50个Fibonacci对象，就可以使用条件元素停止规则的匹配。该规则也具有显着性值，因为我们需要将所有50 <code class="code">Fibonacci</code>在执行Bootstrap规则之前断言的对象。</p><div class="example"><a id="d0e26564"></a><p class="title"><strong>示例23.23斐波那契示例：规则“递归”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule Recurse
    salience 10
    when
        f : Fibonacci ( value == -1 )
        not ( Fibonacci ( sequence == 1 ) )
    then
        insert( new Fibonacci( f.sequence - 1 ) );
        System.out.println( "recurse for " + f.sequence );
end</code></pre></div></div><br class="example-break"><p>审核视图显示了原始的断言<code class="code">Fibonacci</code>序列字段为50的对象（通过Java代码完成）。从那里开始，“审核”视图显示规则的连续递归，其中每个已断言<code class="code">Fibonacci</code>对象导致“递归”规则被激活并再次触发。</p><div class="figure"><a id="d0e26577"></a><p class="title"><strong>图23.6。Fibonacci示例：“递归”审核视图1</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/FibonacciExample/fibonacci1.png" alt="斐波那契示例：" recurs="=" =""></div></div></div><br class="figure-break"><p>当一个<code class="code">Fibonacci</code>断言序列字段为2的对象“ Bootstrap”规则与“ Recurse”规则一起被激活。请注意对字段的多重限制<code class="code">sequence</code> ，测试1或2的相等性。</p><div class="example"><a id="d0e26591"></a><p class="title"><strong>示例23.24斐波那契示例：规则“引导程序”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule Bootstrap
    when
        f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction
    then 
        modify ( f ){ value = 1 };
        System.out.println( f.sequence + " == " + f.value );
end</code></pre></div></div><br class="example-break"><p>此时，议程如下所示。但是，“ Bootstrap”规则不会触发，因为“ Recurse”规则的显着性更高。</p><div class="figure"><a id="d0e26598"></a><p class="title"><strong>图23.7。斐波那契示例：“递归”议程视图1</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/FibonacciExample/fibonacci_agenda1.png" alt="斐波那契示例：" recurs="=" =""></div></div></div><br class="figure-break"><p>当一个<code class="code">Fibonacci</code>断言序列为1的对象再次与Bootstrap规则匹配，从而导致对该规则的两次激活。请注意，“递归”规则不匹配并无法激活，因为<code class="literal">not</code>条件元素会在<code class="code">Fibonacci</code>存在序列为1的对象。</p><div class="figure"><a id="d0e26615"></a><p class="title"><strong>图23.8。斐波那契示例：“递归”议程视图2</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/FibonacciExample/fibonacci_agenda2.png" alt="斐波那契示例：" recurs="=" =""></div></div></div><br class="figure-break"><p>一旦我们有两个<code class="code">Fibonacci</code>值不等于-1的对象，则“计算”规则可以匹配。正是“引导程序”规则将序列1和2的对象设置为值1。此时，工作记忆中有50个斐波那契对象。现在我们需要选择一个合适的三元组依次计算它们的每个值。在没有字段约束的规则中使用三个斐波那契模式来限制可能的叉积会导致50x49x48的可能组合，导致大约125,000个可能的规则触发，其中大多数不正确。“计算”规则使用字段约束以正确的顺序正确约束您的斐波那契模式；这种技术称为<span class="emphasis"><em>跨产品匹配</em></span> 。第一个模式找到具有值的任何斐波那契！= -1并绑定模式和字段。第二个斐波那契也这样做，但是它添加了一个额外的字段约束，以确保其序列比绑定到的斐波那契序列大一个<code class="code">f1</code> 。首次触发此规则时，我们知道只有序列1和2的值为1，并且两个约束确保<code class="code">f1</code>引用序列1和<code class="code">f2</code>参考序列2。最终模式找到值为-1且序列大于1的斐波那契<code class="code">f2</code> 。至此，我们有三个<code class="code">Fibonacci</code>从可用的叉积中正确选择的对象，我们可以计算出第三个对象的值<code class="code">Fibonacci</code>绑定到的对象<code class="code">f3</code> 。</p><div class="example"><a id="d0e26650"></a><p class="title"><strong>示例23.25斐波那契示例：规则“计算”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule Calculate
    when
        // Bind f1 and s1
        f1 : Fibonacci( s1 : sequence, value != -1 )
        // Bind f2 and v2; refer to bound variable s1
        f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 )
        // Bind f3 and s3; alternative reference of f2.sequence
        f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )      
    then
        // Note the various referencing techniques.
        modify ( f3 ) { value = f1.value + v2 };
        System.out.println( s3 + " == " + f3.value );
end 
</code></pre></div></div><br class="example-break"><p>的<code class="literal">modify</code>语句更新了<code class="code">Fibonacci</code>绑定对象<code class="code">f3</code> 。这意味着我们现在有了另一个值不等于-1的新斐波那契对象，该对象允许“计算”规则重新匹配并计算下一个斐波那契数。下面的“审核”视图显示了最后一个“引导程序”的触发如何修改<code class="code">Fibonacci</code>对象，使“计算”规则匹配，然后修改另一个斐波那契对象，使“计算”规则再次匹配。一直持续到为所有值设置<code class="code">Fibonacci</code>对象。</p><div class="figure"><a id="d0e26672"></a><p class="title"><strong>图23.9。Fibonacci示例：“引导程序”审核视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/FibonacciExample/fibonacci4.png" alt="斐波那契示例：" bootstra="=" =""></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="23.5。银行教程"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e26678"></a> 23.5。银行教程</strong></strong></h2></div></div></div><pre class="screen"><span class="bold"><strong>Name:</strong></span> BankingTutorial
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.banking.BankingExamplesApp.java
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> org.drools.examples.banking.*.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate pattern matching, basic sorting and calculation rules.</pre><p><strong><strong>本教程演示了开发完整的个人银行业务应用程序以处理多个帐户上的贷方和借方的过程。它使用为该过程创建的一组设计模式。</strong></strong></p><p><strong><strong>班级<code class="code">RuleRunner</code>是一种简单的工具，可以针对一组数据执行一个或多个DRL文件。它编译软件包并为每次执行创建知识库，从而使我们能够轻松执行每种方案并检查输出。实际上，对于生产系统来说，这不是一个好的解决方案，在生产系统中，知识库仅应构建一次并进行缓存，但是就本教程而言，它就足够了。</strong></strong></p><div class="example"><strong><strong><a id="d0e26707"></a><p class="title"><strong>示例23.26银行教程：RuleRunner</strong></p><div class="example-contents"><pre><code class="language-java">public class RuleRunner {

    public RuleRunner() {
    }

    public void runRules(String[] rules,
                         Object[] facts) throws Exception {

        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        for ( int i = 0; i &lt; rules.length; i++ ) {
            String ruleFile = rules[i];
            System.out.println( "Loading file: " + ruleFile );
            kbuilder.add( ResourceFactory.newClassPathResource( ruleFile,
                                                                RuleRunner.class ),
                          ResourceType.DRL );
        }

        Collection&lt;KnowledgePackage&gt; pkgs = kbuilder.getKnowledgePackages();
        kbase.addKnowledgePackages( pkgs );
        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

        for ( int i = 0; i &lt; facts.length; i++ ) {
            Object fact = facts[i];
            System.out.println( "Inserting fact: " + fact );
            ksession.insert( fact );
        }

        ksession.fireAllRules();
    }
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>我们的第一个示例Java类加载并执行一个DRL文件， <code class="filename">Example.drl</code> ，但不插入任何数据。</p><div class="example"><a id="d0e26717"></a><p class="title"><strong>示例23.27银行业务教程：Java Example1</strong></p><div class="example-contents"><pre><code class="language-java">public class Example1 {
    public static void main(String[] args) throws Exception {
        new RuleRunner().runRules( new String[] { "Example1.drl" },
                                   new Object[0] );
    }
}</code></pre></div></div><br class="example-break"><p>第一条简单执行的规则只有一条<code class="literal">eval</code>条件始终为真，因此此规则将在启动后匹配并触发一次。</p><div class="example"><a id="d0e26727"></a><p class="title"><strong>示例23.28银行业务教程：Example1.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 01"   
    when
        eval( 1==1 )
    then
        System.out.println( "Rule 01 Works" );
end</code></pre></div></div><br class="example-break"><p>规则的输出如下所示，显示该规则匹配并执行单个print语句。</p><div class="example"><a id="d0e26734"></a><p class="title"><strong>示例23.29银行业务教程：Example1.java的输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Loading file: Example1.drl
Rule 01 Works</code></pre></div></div><br class="example-break"><p>下一步是断言一些简单的事实并打印出来。</p><div class="example"><a id="d0e26741"></a><p class="title"><strong>示例23.30银行业务教程：Java Example2</strong></p><div class="example-contents"><pre><code class="language-java">public class Example2 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example2.drl" },
                                   numbers );
    }
    
    private static Integer wrap( int i ) {
        return new Integer(i);
    }
}</code></pre></div></div><br class="example-break"><p>这不使用任何特定事实，而是断言一组<code class="code">java.lang.Integer</code>对象。这不是“最佳实践”，因为数字不是有用的事实，但是我们在这里使用它来演示基本技术，然后再添加更多复杂性。</p><p>现在，我们将创建一个简单的规则来打印这些数字。</p><div class="example"><a id="d0e26753"></a><p class="title"><strong>示例23.31银行业务教程：Example2.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 02"
    when
        Number( $intValue : intValue )
    then
        System.out.println( "Number found with value: " + $intValue ); 
end</code></pre></div></div><br class="example-break"><p>再一次，这个规则没有什么特别的。它确定了任何事实<code class="code">Number</code>对象并打印出值。注意抽象类的使用<code class="code">Number</code> ：我们插入了<code class="code">Integer</code>对象，但我们现在寻找任何类型的数字。模式匹配引擎能够匹配断言对象的接口和超类。</p><p>输出显示正在加载的DRL，已插入的事实，然后是已匹配并已触发的规则。我们可以看到，每个插入的数字都被匹配并触发并因此打印出来。</p><div class="example"><a id="d0e26771"></a><p class="title"><strong>示例23.32银行业务教程：Example2.java的输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Loading file: Example2.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 5
Number found with value: 1
Number found with value: 4
Number found with value: 1
Number found with value: 3
</code></pre></div></div><br class="example-break"><p>当然，还有比使用规则更好的数字排序方法，但是由于当我们开始查看银行业规则时，需要按日期顺序应用一些现金流量，因此我们将开发基于规则的简单排序技术。</p><div class="example"><a id="d0e26778"></a><p class="title"><strong>示例23.33银行业务教程：Example3.java</strong></p><div class="example-contents"><pre><code class="language-java">public class Example3 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example3.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</code></pre></div></div><br class="example-break"><p>再次，我们插入我们的<code class="code">Integer</code>对象，但这次的规则略有不同：</p><div class="example"><a id="d0e26788"></a><p class="title"><strong>示例23.34银行业务教程：Example3.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 03"
    when
        $number : Number( )
        not Number( intValue &lt; $number.intValue )
    then
        System.out.println("Number found with value: " + $number.intValue() ); 
        retract( $number );
end</code></pre></div></div><br class="example-break"><p>规则的第一行标识<code class="code">Number</code>并提取值。第二行确保不存在小于第一个模式找到的数目的数字。我们可能希望只匹配一个数字-集合中最小的数字。但是，在打印完数字后撤回该数字意味着已删除最小数字，显示下一个最小数字，依此类推。</p><p>结果输出显示数字现在已按数字排序。</p><div class="example"><a id="d0e26800"></a><p class="title"><strong>示例23.35银行业务教程：Example3.java的输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Loading file: Example3.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 1
Number found with value: 1
Number found with value: 3
Number found with value: 4
Number found with value: 5
</code></pre></div></div><br class="example-break"><p>我们准备开始迈向我们的个人会计准则。第一步是创建一个<code class="code">Cashflow</code>宾语。</p><div class="example"><a id="d0e26810"></a><p class="title"><strong>示例23.36银行教程：类现金流</strong></p><div class="example-contents"><pre><code class="language-java">public class Cashflow {
    private Date   date;
    private double amount;

    public Cashflow() {
    }

    public Cashflow(Date date, double amount) {
        this.date = date;
        this.amount = amount;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String toString() {
        return "Cashflow[date=" + date + ",amount=" + amount + "]";
    }
}</code></pre></div></div><br class="example-break"><p>类<code class="code">Cashflow</code>有两个简单的属性，日期和金额。（请注意，使用类型<code class="code">double</code>货币单位通常<span class="emphasis"><em>不是</em></span>一个好主意，因为浮点数不能准确表示大多数数字。）还有一个重载的构造函数来设置值和方法<code class="code">toString</code>打印现金流量。的Java代码<code class="filename">Example4.java</code>插入五个具有不同日期和金额的Cashflow对象。</p><div class="example"><a id="d0e26832"></a><p class="title"><strong>示例23.37银行业务教程：Example4.java</strong></p><div class="example-contents"><pre><code class="language-java">public class Example4 {
    public static void main(String[] args) throws Exception {
        Object[] cashflows = {
            new Cashflow(new SimpleDate("01/01/2007"), 300.00),
            new Cashflow(new SimpleDate("05/01/2007"), 100.00),
            new Cashflow(new SimpleDate("11/01/2007"), 500.00),
            new Cashflow(new SimpleDate("07/01/2007"), 800.00),
            new Cashflow(new SimpleDate("02/01/2007"), 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example4.drl" },
                                   cashflows );
    }
}</code></pre></div></div><br class="example-break"><p>便利班<code class="code">SimpleDate</code>延伸<code class="code">java.util.Date</code> ，提供以String作为输入并定义日期格式的构造函数。该代码在下面列出</p><div class="example"><a id="d0e26845"></a><p class="title"><strong>示例23.38银行业务教程：SimpleDate类</strong></p><div class="example-contents"><pre><code class="language-java">public class SimpleDate extends Date {
    private static final SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
    
    public SimpleDate(String datestr) throws Exception {             
        setTime(format.parse(datestr).getTime());
    }
}</code></pre></div></div><br class="example-break"><p>现在，让我们看一下<code class="filename">Example4.drl</code>看看我们如何打印排序<code class="code">Cashflow</code>对象：</p><div class="example"><a id="d0e26858"></a><p class="title"><strong>示例23.39银行业务教程：Example4.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 04"   
    when
        $cashflow : Cashflow( $date : date, $amount : amount )
        not Cashflow( date &lt; $date)
    then
        System.out.println("Cashflow: "+$date+" :: "+$amount);  
        retract($cashflow);
end</code></pre></div></div><br class="example-break"><p>在这里，我们确定一个<code class="code">Cashflow</code>并提取日期和金额。在规则的第二行中，我们确保没有现金流的日期早于找到的现金流。结果，我们打印了<code class="code">Cashflow</code>满足规则然后撤消它，为下一个最早的方法<code class="code">Cashflow</code> 。因此，我们生成的输出为：</p><div class="example"><a id="d0e26874"></a><p class="title"><strong>示例23.40银行业务教程：Example4.java的输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Loading file: Example4.drl
Inserting fact: Cashflow[date=Mon Jan 01 00:00:00 GMT 2007,amount=300.0]
Inserting fact: Cashflow[date=Fri Jan 05 00:00:00 GMT 2007,amount=100.0]
Inserting fact: Cashflow[date=Thu Jan 11 00:00:00 GMT 2007,amount=500.0]
Inserting fact: Cashflow[date=Sun Jan 07 00:00:00 GMT 2007,amount=800.0]
Inserting fact: Cashflow[date=Tue Jan 02 00:00:00 GMT 2007,amount=400.0]
Cashflow: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Cashflow: Tue Jan 02 00:00:00 GMT 2007 :: 400.0
Cashflow: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Cashflow: Sun Jan 07 00:00:00 GMT 2007 :: 800.0
Cashflow: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</code></pre></div></div><br class="example-break"><p>接下来，我们扩展我们的<code class="code">Cashflow</code> ，导致<code class="code">TypedCashflow</code>可以是贷记或借记操作。（通常，我们将其添加到<code class="code">Cashflow</code>类型，但我们使用扩展名来保留该类的先前版本。）</p><div class="example"><a id="d0e26890"></a><p class="title"><strong>示例23.41银行业务教程：类TypedCashflow</strong></p><div class="example-contents"><pre><code class="language-java">public class TypedCashflow extends Cashflow {
    public static final int CREDIT = 0;
    public static final int DEBIT  = 1;

    private int             type;

    public TypedCashflow() {
    }

    public TypedCashflow(Date date, int type, double amount) {
        super( date, amount );
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String toString() {
        return "TypedCashflow[date=" + getDate() +
               ",type=" + (type == CREDIT ? "Credit" : "Debit") +
               ",amount=" + getAmount() + "]";
    }
}</code></pre></div></div><br class="example-break"><p>有很多方法可以改进此代码，但是出于示例的目的，这可以做到。</p><p>现在让我们创建Example5，这是一个用于运行代码的类。</p><div class="example"><a id="d0e26899"></a><p class="title"><strong>示例23.42银行业务教程：Example5.java</strong></p><div class="example-contents"><pre><code class="language-java">public class Example5 {
    public static void main(String[] args) throws Exception {      
        Object[] cashflows = {
            new TypedCashflow(new SimpleDate("01/01/2007"),    
                              TypedCashflow.CREDIT, 300.00),
            new TypedCashflow(new SimpleDate("05/01/2007"),
                              TypedCashflow.CREDIT, 100.00),
            new TypedCashflow(new SimpleDate("11/01/2007"),
                              TypedCashflow.CREDIT, 500.00),
            new TypedCashflow(new SimpleDate("07/01/2007"),
                              TypedCashflow.DEBIT, 800.00),
            new TypedCashflow(new SimpleDate("02/01/2007"),
                              TypedCashflow.DEBIT, 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example5.drl" },
                                   cashflows );
    }
}</code></pre></div></div><br class="example-break"><p>在这里，我们只需创建一组<code class="code">Cashflow</code>贷项或借项操作的对象。我们提供它们， <code class="filename">Example5.drl</code>到RuleEngine。</p><p>现在，让我们看一下打印排序的规则<code class="code">Cashflow</code>对象。</p><div class="example"><a id="d0e26917"></a><p class="title"><strong>示例23.43银行业务教程：Example5.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 05"  
    when
        $cashflow : TypedCashflow( $date : date,
                                   $amount : amount,
                                   type == TypedCashflow.CREDIT )
        not TypedCashflow( date &lt; $date,
                           type == TypedCashflow.CREDIT )
    then
        System.out.println("Credit: "+$date+" :: "+$amount);   
        retract($cashflow);
end</code></pre></div></div><br class="example-break"><p>在这里，我们确定一个<code class="code">Cashflow</code>一种类型的事实<code class="code">CREDIT</code>并提取日期和金额。在规则的第二行中，我们确保没有<code class="code">Cashflow</code>相同类型的日期早于找到的日期。结果，我们打印出满足模式的现金流量，然后将其收回，为下一最早的现金流量类型腾出空间<code class="code">CREDIT</code> 。</p><p>因此，我们生成的输出是</p><div class="example"><a id="d0e26938"></a><p class="title"><strong>示例23.44银行业务教程：Example5.java的输出</strong></p><div class="example-contents"><pre class="screen">Loading file: Example5.drl
Inserting fact: TypedCashflow[date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: TypedCashflow[date=Fri Jan 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: TypedCashflow[date=Thu Jan 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: TypedCashflow[date=Sun Jan 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: TypedCashflow[date=Tue Jan 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Credit: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Credit: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>继续我们的银行业务，我们现在将处理两个银行帐户上的贷方和借方，以计算帐户余额。为此，我们创建两个单独的<code class="code">Account</code>对象并将其注入<code class="code">Cashflows</code>对象，然后再将它们传递给规则引擎。这样做的原因是可以轻松访问正确的帐户，而不必求助于助手类。让我们来看看<code class="code">Account</code>全班第一这是一个简单的Java对象，具有帐号和余额：</p><div class="example"><a id="d0e26954"></a><p class="title"><strong>示例23.45银行教程：班级账户</strong></p><div class="example-contents"><pre><code class="language-java">public class Account {
    private long   accountNo;
    private double balance = 0;

    public Account() {
    }

    public Account(long accountNo) {
        this.accountNo = accountNo;
    }

    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account[" + "accountNo=" + accountNo + ",balance=" + balance + "]";
    }
}</code></pre></div></div><br class="example-break"><p>现在让我们扩展我们的<code class="code">TypedCashflow</code> ， 导致<code class="code">AllocatedCashflow</code> ，包括一个<code class="code">Account</code>参考。</p><div class="example"><a id="d0e26970"></a><p class="title"><strong>示例23.46银行业务教程：类AllocatedCashflow</strong></p><div class="example-contents"><pre><code class="language-java">public class AllocatedCashflow extends TypedCashflow {
    private Account account;

    public AllocatedCashflow() {
    }

    public AllocatedCashflow(Account account, Date date, int type, double amount) {
        super( date, type, amount );
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public String toString() {
        return "AllocatedCashflow[" +
               "account=" + account +
               ",date=" + getDate() + 
               ",type=" + (getType() == CREDIT ? "Credit" : "Debit") + 
               ",amount=" + getAmount() + "]";
    }
}</code></pre></div></div><br class="example-break"><p>的Java代码<code class="filename">Example5.java</code>创建两个<code class="code">Account</code>对象，并在构造函数调用中将其中之一传递到每个现金流中。</p><div class="example"><a id="d0e26983"></a><p class="title"><strong>示例23.47银行业务教程：Example5.java</strong></p><div class="example-contents"><pre><code class="language-java">public class Example6 {
    public static void main(String[] args) throws Exception {      
        Account acc1 = new Account(1);
        Account acc2 = new Account(2);
           
        Object[] cashflows = {
            new AllocatedCashflow(acc1,new SimpleDate("01/01/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/02/2007"),
                                  TypedCashflow.CREDIT, 100.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/03/2007"),
                                  TypedCashflow.CREDIT, 500.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/02/2007"),
                                  TypedCashflow.DEBIT,  800.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/03/2007"),
                                  TypedCashflow.DEBIT,  400.00),
            new AllocatedCashflow(acc1,new SimpleDate("01/04/2007"),    
                                  TypedCashflow.CREDIT, 200.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/04/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/05/2007"),
                                  TypedCashflow.CREDIT, 700.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/05/2007"),
                                  TypedCashflow.DEBIT,  900.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/05/2007"),
                                  TypedCashflow.DEBIT,  100.00)           
        };
        
        new RuleRunner().runRules( new String[] { "Example6.drl" },
                                   cashflows );
    }
}</code></pre></div></div><br class="example-break"><p>现在，让我们来看一下<code class="filename">Example6.drl</code>了解我们如何按日期顺序应用每个现金流量，并计算和打印余额。</p><div class="example"><a id="d0e26993"></a><p class="title"><strong>示例23.48银行业务教程：Example6.drl中的规则</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Rule 06 - Credit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                                       $date : date,
                                       $amount : amount,
                                       type == TypedCashflow.CREDIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Credit: " + $date + " :: " + $amount);     
        $account.setBalance($account.getBalance()+$amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());          
        retract($cashflow);
end

rule "Rule 06 - Debit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                            $date : date,
                            $amount : amount,
                            type == TypedCashflow.DEBIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Debit: " + $date + " :: " + $amount);      
        $account.setBalance($account.getBalance() - $amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());           
        retract($cashflow);
end</code></pre></div></div><br class="example-break"><p>尽管我们对贷方和借方有单独的规则，但是在检查较早的现金流量时我们没有指定类型。这样，所有现金流量都按日期顺序应用，而不管现金流量类型如何。在条件下，我们确定要使用的帐户，在后果中，我们用现金流量金额对其进行更新。</p><div class="example"><a id="d0e27000"></a><p class="title"><strong>示例23.49银行业务教程：Example6.java的输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Loading file: Example6.drl
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0]
Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0
Account: 2 - new balance: -400.0
Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0
Account: 2 - new balance: 100.0
Debit: Wed May 02 00:00:00 BST 2007 :: 100.0
Account: 2 - new balance: 0.0
Credit: Fri May 11 00:00:00 BST 2007 :: 700.0
Account: 2 - new balance: 700.0
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Account: 1 - new balance: 300.0
Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0
Account: 1 - new balance: 400.0
Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0
Account: 1 - new balance: -400.0
Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0
Account: 1 - new balance: -200.0
Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0
Account: 1 - new balance: 100.0
Debit: Mon May 07 00:00:00 BST 2007 :: 900.0
Account: 1 - new balance: -800.0
</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="23.6。定价规则决策表示例"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e27005"></a> 23.6。定价规则决策表示例</strong></strong></h2></div></div></div><p><strong><strong>定价规则决策表演示了电子表格中决策表在Excel的XLS格式中的用法，用于计算保险单的零售成本。提供一组规则的目的是为申请特定策略的汽车驾驶员计算基本价格和折扣。驾驶员的年龄，历史和保单类型都对基本保费产生了影响，另外还有很多规则以折扣率来完善。</strong></strong></p><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Example Policy Pricing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.decisiontable.PricingRuleDTExample
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> ExamplePolicyPricing.xls
<span class="bold"><strong>Objective:</strong></span> demonstrate spreadsheet-based decision tables.</code></pre><div class="section" title="23.6.1。执行示例"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e27029"></a> 23.6.1。执行示例</strong></strong></h3></div></div></div><p><strong><strong>开启档案<code class="filename">PricingRuleDTExample.java</code>并将其作为Java应用程序执行。它应该在“控制台”窗口中产生以下输出：</strong></strong></p><pre><code class="no-highlight">Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20     </code></pre><p><strong><strong>执行该示例的代码遵循通常的模式。加载规则，插入事实并创建无状态会话。区别在于如何添加规则。</strong></strong></p><pre><code class="language-java">DecisionTableConfiguration dtableconfiguration =
    KnowledgeBuilderFactory.newDecisionTableConfiguration();
        dtableconfiguration.setInputType( DecisionTableInputType.XLS );

        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        Resource xlsRes = ResourceFactory.newClassPathResource( "ExamplePolicyPricing.xls",
                                                                getClass() );
        kbuilder.add( xlsRes,
                      ResourceType.DTABLE,
                      dtableconfiguration );
</code></pre><p><strong><strong>注意使用<code class="code">DecisionTableConfiguration</code>宾语。其输入类型设置为<code class="code">DecisionTableInputType.XLS</code> 。如果您使用BRMS，那么所有这些当然都会为您解决。</strong></strong></p><p><strong><strong>在此示例中使用了两种事实类型： <code class="code">Driver</code>和<code class="code">Policy</code> 。两者都使用其默认值。的<code class="code">Driver</code>年龄30岁，之前没有索偿要求，目前的风险状况为<code class="code">LOW</code> 。的<code class="code">Policy</code>正在申请的是<code class="code">COMPREHENSIVE</code> ，并且尚未被批准。</strong></strong></p></div><div class="section" title="23.6.2。决策表"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e27071"></a> 23.6.2。决策表</strong></strong></h3></div></div></div><p><strong><strong>在此决策表中，每一行都是一条规则，每一列都是一个条件或一个动作。</strong></strong></p><div class="figure"><strong><strong><a id="d0e27076"></a><p class="title"><strong>图23.10。决策表配置</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PricingExample/DT_Config.png" alt="决策表配置"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>参考上面显示的电子表格，我们有<code class="code">RuleSet</code>声明，提供包名称。您还可以在这里拥有其他可选项，例如<code class="code">Variables</code>用于全局变量，以及<code class="code">Imports</code>用于导入课程。在这种情况下，规则的名称空间与我们使用的事实类相同，因此我们可以忽略它。</p><p>再往下走，我们可以看到<code class="code">RuleTable</code>宣言。此后的名称（“价格”括号）用作所有生成的规则的前缀。在其下，我们具有“ CONDITION或ACTION”，指示该列的用途，即，它是构成条件的一部分还是要生成的规则的结果。</p><p>您可以看到有一个驱动程序，其数据跨越三个单元格，这意味着其下方的模板表达式适用于该事实。我们观察驾驶员的年龄范围（ <code class="code">$1</code>和<code class="code">$2</code> （以逗号分隔的值）， <code class="code">locationRiskProfile</code>和<code class="code">priorClaims</code>在相应的列中。在操作列中，我们设置了策略基本价格并记录了一条消息。</p><div class="figure"><a id="d0e27112"></a><p class="title"><strong>图23.11。底价计算</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PricingExample/DT_Table1.png" alt="底价计算"></div></div></div><br class="figure-break"><p>在前面的电子表格部分中，有最广泛的类别括号，由最左边一栏中的注释指示。据我们所知，我们的司机及其政策的细节，我们可以（稍加思索）告诉他们，他们应该与第18行匹配，因为他们以前没有发生过事故，并且已经30岁了。这使我们的基本价格为120。</p><div class="figure"><a id="d0e27120"></a><p class="title"><strong>图23.12。折扣计算</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PricingExample/DT_Table2.png" alt="折扣计算"></div></div></div><br class="figure-break"><p>上一节包含了我们可能给予驾驶员折扣的条件。折扣来自<code class="code">Age</code>括号，在先索赔的数量和保单类型。在我们的案例中，司机是30岁，没有任何先前的要求，并且正在申请<code class="code">COMPREHENSIVE</code>政策，这意味着我们可以给予20％的折扣。请注意，这实际上是一个单独的表，但是在同一工作表中，因此可以应用不同的模板。</p><p>重要的是要注意决策表会生成规则。这意味着它们不仅仅是简单的自上而下的逻辑，而是一种捕获产生规则的数据的方法。这是一个细微的差异，使某些人感到困惑。规则的评估不一定按给定的顺序进行，因为规则引擎的所有常规机制仍然适用。</p></strong></strong></div></div><div class="section" title="23.7。宠物店的例子"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e27136"></a> 23.7。宠物店的例子</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Pet Store 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.petstore.PetStoreExample
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> PetStore.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Agenda Groups, Global Variables and integration with a GUI,
including callbacks from within the rules
</code></pre><p><strong><strong>宠物商店示例显示了如何将规则与GUI（在本例中为基于Swing的桌面应用程序）集成在一起。在规则文件中，它演示了如何使用议程组和自动对焦来控制允许在任何给定时间触发一组规则中的哪一个。它还说明了规则中Java和MVEL方言的混合，累加函数的使用以及从规则集中调用Java函数的方式。</strong></strong></p><p><strong><strong>所有Java代码都包含在一个文件中， <code class="filename">PetStore.java</code> ，定义了以下主要类（除了几个用于处理Swing事件的类）：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong><code class="code">Petstore</code>包含<code class="code">main()</code>我们将很快介绍的方法。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">PetStoreUI</code>负责创建和显示基于Swing的GUI。它包含几个较小的类，主要用于响应各种GUI事件，例如鼠标单击。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">TableModel</code>保存表数据。将其视为扩展了Swing类的JavaBean <code class="code">AbstractTableModel</code> 。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">CheckoutCallback</code>允许GUI与规则进行交互。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">Ordershow</code>保留我们要购买的物品。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">Purchase</code>存储订单的详细信息以及我们要购买的产品。</strong></strong></p></li><li class="listitem"><p><strong><strong><code class="code">Product</code>是JavaBean，其中包含可购买的产品的详细信息及其价格。</strong></strong></p></li></ul></div><p><strong><strong>许多Java代码是纯JavaBean或基于Swing的。本节将仅讨论与Swing相关的几点，但是可以在Sun的Swing网站（ <a class="link" href="http://java.sun.com/docs/books/tutorial/uiswing/">http://java.sun.com/docs/books/tutorial/uiswing/）中</a>找到有关Swing组件的很好的教程。</strong></strong></p><p><strong><strong>中的Java代码片段<code class="filename">Petstore.java</code>与规则和事实有关的内容如下所示。</strong></strong></p><div class="example"><strong><strong><a id="d0e27217"></a><p class="title"><strong>示例23.50在PetStore.main中创建PetStore KieContainer</strong></p><div class="example-contents"><pre><code class="language-java">// KieServices is the factory for all KIE services 
KieServices ks = KieServices.Factory.get();

// From the kie services, a container is created from the classpath
KieContainer kc = ks.getKieClasspathContainer();

// Create the stock.
Vector&lt;Product&gt; stock = new Vector&lt;Product&gt;();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the
// Working Memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kc ) );
ui.createAndShowGUI();
</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>上面显示的代码创建了一个<code class="code">KieContainer</code>从类路径中并基于<code class="filename">kmodule.xml</code>文件。与其他事实被断言并立即触发的其他示例不同，此示例将这一步骤推迟到以后。这样做的方式是通过倒数第二行<code class="code">PetStoreUI</code>对象是使用接受<code class="code">Vector</code>宾语<code class="code">stock</code>收集我们的产品，以及<code class="code">CheckoutCallback</code>包含我们刚刚加载的Rule Base的类。</p><p>触发规则的Java代码位于<code class="code">CheckoutCallBack.checkout()</code>方法。（最终）当用户按下“签出”按钮时触发。</p><div class="example"><a id="d0e27247"></a><p class="title"><strong>示例23.51触发规则-从CheckoutCallBack.checkout（）中提取</strong></p><div class="example-contents"><pre><code class="language-java">public String checkout(JFrame frame, List&lt;Product&gt; items) {
    Order order = new Order();

    // Iterate through list and add to cart
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction

    // From the container, a session is created based on  
    // its definition and configuration in the META-INF/kmodule.xml file 
    KieSession ksession = kcontainer.newKieSession("PetStoreKS");

    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );
    ksession.fireAllRules();

    // Return the state of the cart
    return order.toString();
}
</code></pre></div></div><br class="example-break"><p>有两项传递给此方法。一个是处理<code class="code">JFrame</code>在GUI底部，围绕输出文本框的Swing组件。第二个是订单项列表；这来自<code class="code">TableModel</code>存储来自GUI右上角“表格”区域的信息。</p><p>for循环将来自GUI的订单项列表转换为<code class="code">Order</code> JavaBean，也包含在文件中<code class="filename">PetStore.java</code> 。请注意，可以直接在规则内引用Swing数据集，但是更好的编码实践是使用简单的Java对象以这种方式进行操作。这意味着如果我们想将样本转换为Web应用程序，我们就不会受到Swing的束缚。</p><p>重要的是要注意， <span class="emphasis"><em>此示例</em></span>中的<span class="emphasis"><em>所有状态都存储在Swing组件中，并且规则实际上是无状态的。</em></span> 每次按下“签出”按钮，此代码都会复制Swing的内容<code class="code">TableModel</code>进入会议的工作记忆。</p><p>在此代码中，有九个调用<code class="code">KieSession</code> 。第一个创建一个新的<code class="code">KieSession</code>来自<code class="code">KieContainer</code> 。请记住，我们通过了<code class="code">KieContainer</code>当我们创建<code class="code">CheckoutCallBack</code>中的课程<code class="code">main()</code>方法。接下来的两个调用传入两个我们将作为规则中的全局变量保存的对象：Swing文本区域和用于编写消息的Swing框架。</p><p>更多插页将有关产品的信息放入<code class="code">KieSession</code> ，以及订单列表。最终通话是标准<code class="code">fireAllRules()</code> 。接下来，我们看一下该方法导致规则文件中发生什么。</p><div class="example"><a id="d0e27304"></a><p class="title"><strong>示例23.52打包，导入，全局和方言：从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="language-java">package org.drools.examples

import org.kie.api.runtime.KieRuntime
import org.drools.examples.petstore.PetStoreExample.Order
import org.drools.examples.petstore.PetStoreExample.Purchase
import org.drools.examples.petstore.PetStoreExample.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame 
global javax.swing.JTextArea textArea</code></pre></div></div><br class="example-break"><p>文件的第一部分<code class="filename">PetStore.drl</code>包含标准的package和import语句，以使各种Java类可用于规则。对我们来说新来的是两个全球<code class="code">frame</code>和<code class="code">textArea</code> 。它们包含对Swing组件的引用<code class="code">JFrame</code>和<code class="code">JTextArea</code>之前由Java代码传递的组件<code class="code">setGlobal()</code>方法。不同于规则中的变量（规则触发后立即失效），全局变量在会话的生命周期内保留其值。</p><p>文件的下一个摘录<code class="filename">PetStore.drl</code>包含两个函数，这些规则将在稍后介绍。</p><div class="example"><a id="d0e27334"></a><p class="title"><strong>示例23.53规则中的Java函数：从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="language-java">function void doCheckout(JFrame frame, KieRuntime krt) {
        Object[] options = {"Yes",
                            "No"};
                            
        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to checkout?",
                                             "",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       if (n == 0) {
            krt.getAgenda().getAgendaGroup( "checkout" ).setFocus();
       }   
}

function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) {
        Object[] options = {"Yes",
                            "No"};
                            
        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to buy a tank for your " + total + " fish?",
                                             "Purchase Suggestion",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);
                                             
       System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                           + total + " fish? - " );

       if (n == 0) {
             Purchase purchase = new Purchase( order, fishTank );
             krt.insert( purchase );
             order.addItem( purchase );
             System.out.println( "Yes" );
       } else {
            System.out.println( "No" );
       }      
       return true;
}

</code></pre></div></div><br class="example-break"><p>在rules文件中具有这些功能只会使Pet Store示例更加紧凑。在现实生活中，您可能会将这些函数保存在自己的文件中，在相同的规则包内，或者作为标准Java类上的静态方法，然后使用以下命令将其导入<code class="code">import function my.package.Foo.hello</code> 。</p><p>这两个功能的目的是：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="code">doCheckout()</code>显示一个对话框，询问用户是否要结帐。如果这样做，则将焦点设置为<code class="code">checkout</code>议程组，从而允许该组中的规则（可能）触发。</p></li><li class="listitem"><p><code class="code">requireTank()</code>显示一个对话框，询问用户是否要购买坦克。如果是这样，新的鱼缸<code class="code">Product</code>被添加到工作存储器中的订单列表中。</p></li></ul></div><p>稍后我们将看到调用这些函数的规则。下一组示例来自Pet Store规则本身。第一个提取物是最先点火的，部分原因是它具有<code class="literal">auto-focus</code>属性设置为true。</p><div class="example"><a id="d0e27368"></a><p class="title"><strong>示例23.54将项目放入工作内存：从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="no-highlight">// Insert each item in the shopping cart into the Working Memory 
// Insert each item in the shopping cart into the Working Memory
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end</code></pre></div></div><br class="example-break"><p>此规则与所有尚无订单的订单匹配<code class="code">grossTotal</code>计算的。它针对该订单中的每个购买项目循环。应该熟悉“爆炸车”规则的某些部分：规则名称，显着性（建议触发规则的顺序）以及将方言设置为<code class="code">"java"</code> 。新增了三个功能：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">agenda-group</code><code class="code">"init"</code>定义议程组的名称。在这种情况下，组中只有一个规则。但是，Java代码和规则结果都没有将焦点放在该组上，因此，它的激发机会依赖于下一个属性。</p></li><li class="listitem"><p><code class="literal">auto-focus</code><code class="code">true</code>确保此规则虽然是议程组中的唯一规则，但有机会在<code class="code">fireAllRules()</code>从Java代码中调用。</p></li><li class="listitem"><p><code class="code">kcontext....setFocus()</code>将重点放在<code class="code">"show items"</code>和<code class="code">"evaluate"</code>反过来，让他们的规则被解散。实际上，我们遍历订单上的所有项目，将它们插入内存，然后在每次插入后触发其他规则。</p></li></ul></div><p>接下来的两个清单显示了<code class="code">"show items"</code>和<code class="code">evaluate</code>议程小组。我们按照它们被调用的顺序查看它们。</p><div class="example"><a id="d0e27420"></a><p class="title"><strong>示例23.55在GUI中显示项目-从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
</code></pre></div></div><br class="example-break"><p>的<code class="code">"show items"</code>议程组只有一个规则，称为“显示项目”（注意大小写不同）。对于当前在工作内存（或会话）中的订单的每次购买，它将详细信息记录到GUI底部的文本区域。的<code class="code">textArea</code>用于执行此操作的变量是我们前面介绍的全局变量之一。</p><p>的<code class="code">evaluate</code>议程小组也从<code class="code">"Explode Cart"</code>之前列出的规则。该议程组有两个规则， <code class="code">"Free Fish Food Sample"</code>和<code class="code">"Suggest Tank"</code> ，如下所示。</p><div class="example"><a id="d0e27447"></a><p class="title"><strong>示例23.56评估议程组：从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="no-highlight">// Free Fish Food sample when we buy a Gold Fish if we haven't already bought 
// Fish Food and don't already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate"
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;amp;&amp;amp; Purchase( product == $p ) )
    not ( $p : Product( name == "Fish Food Sample") &amp;amp;&amp;amp; Purchase( product == $p ) )
    exists ( $p : Product( name == "Gold Fish") &amp;amp;&amp;amp; Purchase( product == $p ) )
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

// Suggest a tank if we have bought more than 5 gold fish and don't already have one
rule "Suggest Tank"
    agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;amp;&amp;amp; Purchase( product == $p ) )
    ArrayList( $total : size &amp;gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) )
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); 
end
</code></pre></div></div><br class="example-break"><p>规则<code class="code">"Free Fish Food Sample"</code>只会在以下情况下触发</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>我们<span class="emphasis"><em>还没有</em></span>任何鱼类食品， <span class="emphasis"><em>并且</em></span></p></li><li class="listitem"><p>我们<span class="emphasis"><em>还没有</em></span>免费的鱼类食品样品， <span class="emphasis"><em>并且</em></span></p></li><li class="listitem"><p>我们的订单中<span class="emphasis"><em>确实</em></span>有一条金鱼。</p></li></ul></div><p>如果该规则触发，它将创建一个新产品（鱼类食品样品），并将其添加到工作记忆库中的订单中。</p><p>规则<code class="code">"Suggest Tank"</code>只会在以下情况下触发</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>我们的订单中<span class="emphasis"><em>还没有</em></span>鱼缸， <span class="emphasis"><em>并且</em></span></p></li><li class="listitem"><p>我们的订单中<span class="emphasis"><em>确实</em></span>有超过5种金鱼产品。</p></li></ul></div><p>如果该规则确实触发，它将调用<code class="code">requireTank()</code>我们之前看过的功能（向用户显示一个对话框，并在确认后将Tank添加到订单/工作记忆中）。调用<span class="italic">requireTank</span> （）函数时，规则将传递全局<span class="italic">框架</span>变量，以便该函数具有Swing GUI的句柄。</p><p>我们要看的下一条规则是<code class="code">"do checkout"</code> 。</p><div class="example"><a id="d0e27518"></a><p class="title"><strong>示例23.57执行结帐-从PetStore.drl中提取（6）</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, kcontext.getKieRuntime());
end</code></pre></div></div><br class="example-break"><p>规则<code class="code">"do checkout"</code> <span class="bold"><strong>没有设置议程组，也没有自动对焦属性</strong></span> 。因此，被视为默认（MAIN）议程组的一部分。当明确指定焦点的议程组中的所有规则都按照规定运行时，该组将默认成为焦点。</p><p>规则没有LHS，因此RHS始终会调用<code class="code">doCheckout()</code>功能。致电时<code class="code">doCheckout()</code>功能，规则通过全局<code class="code">frame</code>变量，为该函数提供Swing GUI的句柄。如我们先前所见， <code class="code">doCheckout()</code>功能向用户显示一个确认对话框。如果确认，该功能会将焦点设置到<span class="italic">结帐</span>议程组，从而触发下一组规则。</p><div class="example"><a id="d0e27548"></a><p class="title"><strong>示例23.58结帐规则：从PetStore.drl中提取</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue )
       from accumulate( Purchase( $price : product.price ), sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 10 &amp;amp;&amp;amp; &amp;lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal &amp;gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
</code></pre></div></div><br class="example-break"><p><span class="italic">结帐</span>议程组中有三个规则：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>如果我们还没有计算出总数， <code class="code">Gross Total</code>将产品价格累计到一个总计中，将此总计放入会话中，并通过Swing显示<code class="code">JTextArea</code> ， 使用<code class="code">textArea</code>全局变量了。</p></li><li class="listitem"><p>如果我们的总数在10到20之间， <code class="code">"Apply 5% Discount"</code>计算折扣后的总额并将其添加到会话中，并将其显示在文本区域中。</p></li><li class="listitem"><p>如果我们的总数不少于20， <code class="code">"Apply 10% Discount"</code>计算折扣后的总额并将其添加到会话中，并将其显示在文本区域中。</p></li></ul></div><p>现在我们已经遍历了代码中发生的一切，让我们看一下实际运行代码时发生的情况。文件<code class="filename">PetStore.java</code>包含一个<code class="code">main()</code>方法，以便可以从命令行或通过IDE作为标准Java应用程序运行。假设您正确设置了类路径。（有关更多信息，请参见示例部分的开头。）</p><p>我们看到的第一个屏幕是Pet Store Demo。它具有可用产品列表（左上方），空白产品列表（右上方），签出和重设按钮（中间）以及空白系统消息区域（底部）。</p><div class="figure"><a id="d0e27593"></a><p class="title"><strong>图23.13。发布后的PetStore演示</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PetStoreExample/1-PetStore-Start-Screen.png" alt="发布后的PetStore演示"></div></div></div><br class="figure-break"><p>为了达到这一点，发生了以下事情：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>的<code class="code">main()</code>方法已运行并加载了规则库， <span class="emphasis"><em>但尚未触发规则</em></span> 。到目前为止，这是与已运行的规则有关的唯一代码。</p></li><li class="listitem"><p>一个新的<code class="code">PetStoreUI</code>对象已创建，并具有规则库的句柄，以备后用。</p></li><li class="listitem"><p>各种Swing组件都在工作，上面的屏幕显示出来并<span class="emphasis"><em>等待用户输入</em></span> 。</p></li></ol></div><p>单击列表中的各种产品可能会给您一个类似于以下屏幕的画面。</p><div class="figure"><a id="d0e27625"></a><p class="title"><strong>图23.14。带有选定产品的PetStore演示</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PetStoreExample/2-stock-added-to-order-list.png" alt="带有选定产品的PetStore演示"></div></div></div><br class="figure-break"><p>请注意， <span class="emphasis"><em>此处未触发任何规则代码</em></span> 。这只是Swing代码，侦听鼠标单击事件，并将一些选定的产品添加到<code class="code">TableModel</code>显示在右上角的对象。（顺便说一句，请注意，这是Model View Controller设计模式的经典用法）。</p><p>只有当我们按下“签出”按钮时，我们才以与前面遍历代码大致相同的顺序触发业务规则。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>方法<code class="code">CheckOutCallBack.checkout()</code> （最终）由Swing类调用，以等待单击“签出”按钮。这将从<code class="code">TableModel</code>对象（在GUI的右上角），并将其插入到会话的工作内存中。然后触发规则。</p></li><li class="listitem"><p>的<code class="code">"Explode Cart"</code>规则是第一个被解雇的人<code class="literal">auto-focus</code>设置为true。它遍历购物车中的所有产品，确保产品在工作内存中，然后提供<code class="code">"Show Items"</code>和<code class="code">Evaluation</code>议程小组有解雇的机会。这些组中的规则将购物车中的内容添加到文本区域（在窗口底部），确定是否给我们免费的鱼类食品，并询问我们是否要购买鱼缸。如下图所示。</p></li></ol></div><div class="figure"><a id="d0e27666"></a><p class="title"><strong>图23.15。我们要买鱼缸吗？</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PetStoreExample/3-purchase-suggestion.png" alt="我们要买鱼缸吗？"></div></div></div><br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>“ <span class="italic">执行结帐”</span>规则是下一个<span class="italic">可行的</span>规则，因为它（a）当前没有其他议程组具有焦点，并且（b）它是默认（MAIN）议程组的一部分。它总是调用<span class="italic">doCheckout（）函数</span> ，该<span class="italic">函数</span>显示“您要结帐吗？' 对话框。</p></li><li class="listitem"><p>的<code class="code">doCheckout()</code>功能将焦点设置为<code class="code">checkout</code>议程组，为该组中的规则提供触发选项。</p></li><li class="listitem"><p>中的规则<code class="code">checkout</code>议程组显示购物车中的物品并应用适当的折扣。</p></li><li class="listitem"><p><span class="emphasis"><em>然后，Swing等待用户输入</em></span>以签出更多产品（并导致规则再次触发）或关闭GUI-参见下图。</p></li></ol></div><div class="figure"><a id="d0e27702"></a><p class="title"><strong>图23.16。触发所有规则后，Petstore演示。</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PetStoreExample/4-Petstore-final-screen.png" alt="触发所有规则后，Petstore演示。"></div></div></div><br class="figure-break"><p>我们可以添加更多System.out调用来演示事件流。下面的列表中给出了当前显示在“控制台”窗口中的输出。</p><div class="example"><a id="d0e27710"></a><p class="title"><strong>示例23.59运行PetStore GUI的控制台（System.out）</strong></p><div class="example-contents"><pre><code class="no-highlight">Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="23.8。诚实的政客例子"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e27716"></a> 23.8。诚实的政客例子</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Honest Politician
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.honestpolitician.HonestPoliticianExample
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> HonestPoliticianExample.drl
<span class="bold"><strong>Objective:</strong></span> Illustrate the concept of "truth maintenance" based on the logical insertion of facts
</code></pre><p><strong><strong>诚实的政治家示例演示了使用逻辑断言维护真相的方法。基本前提是对象只能在语句为真时存在。规则的结果可以在逻辑上插入带有<code class="code">insertLogical()</code>方法。这意味着只要逻辑上将其插入的规则保持为真，该对象将仅保留在工作内存中。当规则不再适用时，对象将自动缩回。</strong></strong></p><p><strong><strong>在这个例子中有<code class="code">Politician</code> ，具有诚实的名称和布尔值。插入了四个将诚实状态设置为true的政治人物。</strong></strong></p><div class="example"><strong><strong><a id="d0e27748"></a><p class="title"><strong>示例23.60班级政治家</strong></p><div class="example-contents"><pre><code class="language-java">public class Politician {
    private String name;
    private boolean honest;
    ...
}</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><div class="example"><a id="d0e27753"></a><p class="title"><strong>示例23.61诚实的政客：处决</strong></p><div class="example-contents"><pre><code class="language-java">Politician blair = new Politician("blair", true);
Politician bush = new Politician("bush", true);
Politician chirac = new Politician("chirac", true);
Politician schroder = new Politician("schroder", true);
    
ksession.insert( blair );
ksession.insert( bush );
ksession.insert( chirac );
ksession.insert( schroder );

ksession.fireAllRules();</code></pre></div></div><br class="example-break"><p>控制台窗口的输出显示，尽管至少有一位诚实的政治家，但民主仍然存在。但是，由于每个政客又被一家邪恶的公司腐败，以致所有政客变得不诚实，民主就死了。</p><div class="example"><a id="d0e27760"></a><p class="title"><strong>示例23.62诚实的政客：控制台输出</strong></p><div class="example-contents"><pre><code class="no-highlight">Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted schroder
I'm an evil corporation and I have corrupted chirac
I'm an evil corporation and I have corrupted bush
I'm an evil corporation and I have corrupted blair
We are all Doomed!!! Democracy is Dead
</code></pre></div></div><br class="example-break"><p>只要工作记忆中至少有一位诚实的政治家， <code class="code">Hope</code>对象在逻辑上被断言。只有在至少有一位诚实的政治家时，该对象才会存在。一旦所有政客都不诚实， <code class="code">Hope</code>物体将自动缩回。此规则的显着性为10，以确保它在其他任何规则之前触发，因为在此阶段，“希望死了”规则实际上是正确的。</p><div class="example"><a id="d0e27773"></a><p class="title"><strong>示例23.63诚实的政客：统治“我们有一个诚实的政客”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "We have an honest Politician"
    salience 10
    when
        exists( Politician( honest == true ) )
    then
        insertLogical( new Hope() );
end</code></pre></div></div><br class="example-break"><p>尽快<code class="code">Hope</code>对象存在“希望生命”规则匹配并触发。它的显着性为10，因此优先于“诚实的腐败”。</p><div class="example"><a id="d0e27783"></a><p class="title"><strong>示例23.64诚实的政客：统治“希望生活”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Hope Lives"
    salience 10
        when
            exists( Hope() )
        then
            System.out.println("Hurrah!!! Democracy Lives");
end</code></pre></div></div><br class="example-break"><p>现在有了希望，我们一开始就有四个诚实的政治家，我们有四个针对这一规则的激励措施，但都处于冲突之中。他们将依次解雇，使每位政客腐败，使他们不再诚实。当所有四个政治人物都被腐败时，我们就没有财产的政治人物<code class="code">honest == true</code> 。因此，“我们有一个诚实的政治家”规则不再是正确的，并且它在逻辑上插入了该对象（由于最后一次执行<code class="code">new Hope()</code> ）会自动缩回。</p><div class="example"><a id="d0e27796"></a><p class="title"><strong>示例23.65诚实的政客：统治“廉洁”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Corrupt the Honest"
    when
        politician : Politician( honest == true )   
        exists( Hope() )
    then
        System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
        modify ( politician ) { honest = false };
end</code></pre></div></div><br class="example-break"><p>随着<code class="code">Hope</code>通过真相维护系统自动撤回有条件的物体<code class="literal">not</code>应用于<code class="code">Hope</code>不再适用，因此以下规则将匹配并触发。</p><div class="example"><a id="d0e27812"></a><p class="title"><strong>示例23.66诚实的政客：规则“希望已死”</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Hope is Dead"
    when
        not( Hope() )
    then
        System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</code></pre></div></div><br class="example-break"><p>让我们看一下该应用程序的审计跟踪：</p><div class="figure"><a id="d0e27819"></a><p class="title"><strong>图23.17。诚实的政客示例审计视图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/HonestPoliticianExample/honest_politician_audit.png" alt="诚实的政客示例审计视图"></div></div></div><br class="figure-break"><p>插入第一位政治人物的那一刻，我们有两次激活。对于第一个插入的政治人物，“我们有一个诚实的政治人物”规则仅被激活一次，因为它使用了<code class="literal">exists</code>条件元素，该元素一次匹配任何数字。由于我们尚未插入“希望已死”规则，因此在此阶段也已激活<code class="code">Hope</code>宾语。首先触发“我们有一个诚实的政治家”规则，因为它比“希望死了”具有更高的显着性，该规则插入了<code class="code">Hope</code>宾语。（该操作以绿色突出显示。）的插入<code class="code">Hope</code>对象激活“希望生命”并取消激活“希望已死”；它还会为每个插入的诚实政客激活“廉洁”。执行“希望生活”规则，并打印“ Hurrah !!!！民主生活”。然后，对每个政治家，规则“ Corrupt the Honest”都将被执行，并打印“我是一家邪恶的公司，我已经破坏了X”，其中X是政治家的名字，并将该政治家的诚实价值修改为false。当最后一个诚实的政治家遭到破坏时， <code class="code">Hope</code>被真相维护系统自动收回，如蓝色突出显示的区域所示。绿色突出显示区域显示了当前选中的蓝色突出显示区域的来源。一旦<code class="code">Hope</code>事实撤回，“希望已死”激活并触发打印“我们都注定了！！！民主已死”。</p></strong></strong></div><div class="section" title="23.9。数独示例"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e27845"></a> 23.9。数独示例</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Sudoku
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.sudoku.SudokuExample
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> sudoku.drl, validate.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates the solving of logic problems, and complex pattern matching.
</code></pre><p><strong><strong>此示例演示了如何根据大量约束在大量潜在解决方案空间中使用Drools查找解决方案。我们使用数独的流行难题。此示例还显示了如何将Drools集成到图形界面中，以及如何使用回调与正在运行的Drools规则引擎进行交互，以便基于运行时工作内存中的更改来更新图形界面。</strong></strong></p><div class="section" title="23.9.1。数独概述"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e27866"></a> 23.9.1。数独概述</strong></strong></h3></div></div></div><p><strong><strong>数独是一个基于逻辑的数字放置难题。目的是填充一个9x9的网格，以便每一列，每一行以及9个3x3区域中的每一个都包含1到9的数字，一次且仅一次。</strong></strong></p><p><strong><strong>拼图设置器提供了部分完成的网格，拼图求解器的任务是在这些约束条件下完成网格。</strong></strong></p><p><strong><strong>解决该问题的一般策略是确保在插入新数字时，该数字在其特定的3x3区域，行和列中应该是唯一的。</strong></strong></p><p><strong><strong>有关详细说明，请参见<a class="link" href="http://en.wikipedia.org/wiki/Sudoku">Wikipedia</a> 。</strong></strong></p></div><div class="section" title="23.9.2。运行示例"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e27880"></a> 23.9.2。运行示例</strong></strong></h3></div></div></div><p><strong><strong>如上所述下载并安装drools-examples，然后执行<code class="filename">java org.drools.examples.DroolsExamplesApp</code>然后点击“ SudokuExample”。</strong></strong></p><p><strong><strong>该窗口包含一个空网格，但是程序附带了许多内部存储的网格，可以加载和求解这些网格。单击“文件”，然后单击“示例”，然后选择“简单”以加载示例之一。请注意，在加载网格之前，所有按钮均被禁用。
      </strong></strong></p><div class="figure"><strong><strong><a id="d0e27890"></a><p class="title"><strong>图23.18。初始画面</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Examples/SudokuExample/sudoku1.png" alt="初始画面"></div></div></div></strong></strong></div><p><strong><strong><br class="figure-break">
    </strong></strong></p><p><strong><strong>加载“简单”示例将根据拼图的初始状态填充网格。</strong></strong></p><div class="figure"><strong><strong><a id="d0e27900"></a><p class="title"><strong>图23.19。加载“简单”后</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Examples/SudokuExample/sudoku2.png" alt="加载后" simpl="" =""></div></div></div></strong></strong></div><p><strong><strong><br class="figure-break"></strong></strong></p><p><strong><strong>单击“解决”按钮，基于Drools的引擎将填写剩余的值，并且这些按钮再次处于非活动状态。</strong></strong></p><div class="figure"><strong><strong><a id="d0e27909"></a><p class="title"><strong>图23.20。 “简单”解决</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Examples/SudokuExample/sudoku3.png" alt="" simpl="=" =""></div></div></div></strong></strong></div><p><strong><strong><br class="figure-break"></strong></strong></p><p><strong><strong>或者，您可以单击“步骤”按钮以查看规则集找到的下一个数字。“控制台”窗口将以可读的形式显示有关正在解决该步骤的规则的详细信息。这些消息的一些示例如下所示。</strong></strong></p><pre class="screen">
single 8 at [0,1]
column elimination due to [1,2]: remove 9 from [4,2]
hidden single 9 at [1,2]
row elimination due to [2,8]: remove 7 from [2,4]
remove 6 from [3,8] due to naked pair at [3,2] and [3,7]
hidden pair in row at [4,6] and [4,4]
</pre><p><strong><strong>单击“转储”按钮以查看网格的状态，其中的单元格将显示既定值或剩余可能性候选者。</strong></strong></p><pre class="screen">
       Col: 0     Col: 1     Col: 2     Col: 3     Col: 4     Col: 5     Col: 6     Col: 7     Col: 8     
Row 0:   2 4  7 9   2 456        4567 9   23 56  9  --- 5 ---  --- 1 ---    3  67 9  --- 8 ---     4 67   
Row 1:  12    7 9  --- 8 ---  1    67 9   23  6  9  --- 4 ---   23  67    1 3  67 9    3  67 9  --- 5 --- 
Row 2:  1  4  7 9  1  456     --- 3 ---      56 89      5 78       5678   --- 2 ---     4 67 9  1  4 67   
Row 3:  1234       12345      1  45      12  5  8   --- 6 ---   2  5 78       5 78      45 7    --- 9 --- 
Row 4:  --- 6 ---  --- 7 ---      5      --- 4 ---   2  5  8   --- 9 ---      5  8   --- 1 ---  --- 3 --- 
Row 5:  --- 8 ---  12 45      1  45   9  12  5      --- 3 ---   2  5 7        567       4567     2 4 67   
Row 6:  1 3   7    1 3  6     --- 2 ---    3 56 8       5  8     3 56 8   --- 4 ---    3 567 9  1    678  
Row 7:  --- 5 ---  1 34 6     1  4 678     3  6 8   --- 9 ---    34 6 8   1 3  678   --- 2 ---  1    678  
Row 8:    34       --- 9 ---     4 6 8   --- 7 ---  --- 1 ---   23456 8     3 56 8     3 56          6 8  
</pre><p><strong><strong>现在，让我们加载一个故意无效的Sudoku网格。单击“文件”，“样本”和“！故意破碎！”。请注意，此网格从某些问题开始，例如，值5在第一行中出现两次。</strong></strong></p><div class="figure"><strong><strong><a id="d0e27928"></a><p class="title"><strong>图23.21。初始状态损坏</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Examples/SudokuExample/sudoku4.png" alt="初始状态损坏"></div></div></div></strong></strong></div><p><strong><strong><br class="figure-break"></strong></strong></p><p><strong><strong>在加载网格之后，一些简单的规则即可执行完整性检查。在这种情况下，以下消息将打印在标准输出上：</strong></strong></p><pre class="screen">
cell [0,8]: 5 has a duplicate in row 0
cell [0,0]: 5 has a duplicate in row 0
cell [6,0]: 8 has a duplicate in col 0
cell [4,0]: 8 has a duplicate in col 0
Validation complete.
</pre><p><strong><strong>但是，单击“解决”按钮可将求解规则应用于此无效网格。这不会完成；一些单元格保持为空。</strong></strong></p><div class="figure"><strong><strong><a id="d0e27942"></a><p class="title"><strong>图23.22。破碎的“已解决”状态</strong></p><div class="figure-contents"><div class="screenshot"><div class="mediaobject"><img src="images/Examples/SudokuExample/sudoku5.png" alt="破碎" solve="=" =""></div></div></div></strong></strong></div><p><strong><strong><br class="figure-break"></strong></strong></p><p><strong><strong>通过使用实现标准求解技术的规则来实现求解功能。它们基于仍然是单元格候选值的值集。例如，如果此类集合包含单个值，则这是单元格的值。不太明显的是在九个单元格的一组中的一个出现值。检测这些情况的规则会插入一个类型为Setting的事实，其中包含特定单元格的解决方案值。此事实导致从该单元所属的任何组的所有其他单元中消除了此值。最后，它缩回了。</strong></strong></p><p><strong><strong>其他规则仅减少某些单元格的允许值。规则“裸对”，“行中隐藏对”，“列中隐藏对”和“正方形中隐藏对”仅消除了可能性，但没有建立解决方案。通过“行中的X翼”，“列中的X翼”，“相交去除行”和“相交去除柱”可以进行更复杂的消除。</strong></strong></p></div><div class="section" title="23.9.3。Java源代码和规则概述"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e27953"></a> 23.9.3。Java源代码和规则概述</strong></strong></h3></div></div></div><p><strong><strong>Java源代码可以在/ src / main / java / org / drools / examples / sudoku目录中找到，其中两个DRL文件定义了位于/ src / main / rules / org / drools / examples / sudoku中的规则目录。</strong></strong></p><p><strong><strong>包装<code class="code">org.drools.examples.sudoku.swing</code>包含一组实现Sudoku拼图框架的类。请注意，该软件包对Drools库没有任何依赖关系。 <code class="code">SudokuGridModel</code>定义一个可以实现将Sudoku拼图存储为9x9网格的接口<code class="code">Cell</code>对象。 <code class="code">SudokuGridView</code>是一个Swing组件，可以可视化实现<code class="code">SudokuGridModel</code> 。 <code class="code">SudokuGridEvent</code>和<code class="code">SudokuGridListener</code>用于在模型和视图之间传递状态更改：解析或更改单元格的值时会触发事件。如果您熟悉其他Swing组件中的模型视图控制器模式，例如<code class="code">JTable</code>那么这种模式应该很熟悉。
      <code class="code">SudokuGridSamples</code>为演示目的提供了一些部分填充的数独难题。</strong></strong></p><p><strong><strong>包<code class="code">org.drools.examples.sudoku.rules</code>包含一个带有用于编译DRL文件的方法的实用程序类。</strong></strong></p><p><strong><strong>包装<code class="code">org.drools.examples.sudoku</code>包含一组实现基本的类<code class="code">Cell</code>对象及其各种集合： <code class="code">CellFile</code>亚型<code class="code">CellRow</code>和<code class="code">CellCol</code>以及<code class="code">CellSqr</code> ，它们都是的子类型<code class="code">CellGroup</code> 。有趣的是， <code class="code">Cell</code>和<code class="code">CellGroup</code>是的子类<code class="code">SetOfNine</code> ，它提供了一个属性<code class="code">free</code>与类型<code class="code">Set<Integer></code> 。为一个<code class="code">Cell</code>它代表单个候选集；为一个<code class="code">CellGroup</code>该集合是其像元的所有候选集合的并集，或者简单地讲，仍然是需要分配的数字集合。</strong></strong></p><p><strong><strong>与81 <code class="code">Cell</code>和27 <code class="code">CellGroup</code>对象和由<code class="code">Cell</code>属性<code class="code">cellRow</code> ， <code class="code">cellCol</code>和<code class="code">cellSqr</code>和<code class="code">CellGroup</code>属性<code class="code">cells</code> ， 的列表<code class="code">Cell</code>对于对象，可以编写规则来检测允许将值分配给单元格或从某个候选集中消除值的特定情况。</strong></strong></p><p><strong><strong>类的对象<code class="code">Setting</code>用于触发伴随值分配的操作：将其从同级单元和关联单元组的候选集中删除。而且，存在<code class="code">Setting</code>在所有应发现新情况的规则中都使用了事实；这是为了避免对不一致的中间状态做出反应。</strong></strong></p><p><strong><strong>类的对象<code class="code">Stepping</code>当“步骤”没有定期终止时，在低优先级规则中使用来执行紧急停止。这表明该程序无法解决难题。</strong></strong></p><p><strong><strong>班级<code class="code">org.drools.examples.sudoku.SudokuExample</code>实现结合了所描述组件的Java应用程序。</strong></strong></p></div><div class="section" title="23.9.4。数独验证器规则（validate.drl）"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e28083"></a> 23.9.4。数独验证器规则（validate.drl）</strong></strong></h3></div></div></div><p><strong><strong>验证规则检测单元格组中的重复编号。它们组合在一个议程组中，使我们能够在加载拼图后明确地激活它们。</strong></strong></p><p><strong><strong>这三个规则“在单元中重复...”非常相似。第一种模式定位具有分配值的单元格。第二种模式提取该单元所属的三个单元组中的任何一个。最终模式将找到一个单元格（第一个单元格除外），该单元格具有与第一个单元格相同的值，并且分别位于相同的行，列或正方形中。</strong></strong></p><p><strong><strong>规则“终止组”最后触发。它打印一条消息并呼叫暂停。</strong></strong></p></div><div class="section" title="23.9.5。数独求解规则（sudoku.drl）"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e28092"></a> 23.9.5。数独求解规则（sudoku.drl）</strong></strong></h3></div></div></div><p><strong><strong>此文件中包含三种类型的规则：一组处理分配给单元格的数字，另一组检测可行的分配，第三组从候选集中消除值。</strong></strong></p><p><strong><strong>规则“设置值”，“从单元格中消除值”和“撤回设置”取决于是否存在<code class="code">Setting</code>宾语。第一条规则处理对单元的分配以及从单元的三个组的“空闲”集中删除值的操作。另外，它递减一个计数器，该计数器为零时，将控制权返回给已调用的Java应用程序<code class="code">fireUntilHalt()</code> 。规则“从单元中消除值”的目的是减少与新分配的单元有关的所有单元的候选列表。最后，当所有消除都完成后，规则“撤回设置”撤消触发<code class="code">Setting</code>事实。</strong></strong></p><p><strong><strong>只有两个规则可以检测可能向单元格分配数字的情况。规则“单”触发<code class="code">Cell</code>包含单个数字的候选集。当不存在具有单个候选者的小区，但是当存在包含候选者的小区但该候选者所属的三个组之一中的所有其他小区都不存在此候选者时，将触发规则“隐藏的单个”。这两个规则都会创建并插入一个<code class="code">Setting</code>事实。</strong></strong></p><p><strong><strong>当手动求解数独难题时，将最大的一组规则中的规则单独或以两个或三个为一组来实施各种求解技术。</strong></strong></p><p><strong><strong>规则“裸对”在一组的两个像元中检测大小为2的相同候选集；可以从该组的所有其他候选集中删除这两个值。</strong></strong></p><p><strong><strong>一个相似的想法激发了“隐藏对……”这三个规则。在这里，规则在一组的两个单元格中查找两个数字的子集，该组的任何其他单元格中都没有值。那么，这意味着所有其他候选对象都可以从包含隐藏对的两个像元中消除。</strong></strong></p><p><strong><strong>一对规则处理行和列中的“ X翼”。当在两个不同的行（或列）中的每个中只有两个可能的值单元格并且这些候选值也位于同一列（或行）中时，则可以在列（或行）中将该值的所有其他候选值设为被淘汰。如果遵循这些规则之一中的模式序列，您将看到由诸如“相同”或“仅”之类的词方便地表达的条件如何导致具有适当约束或以“否”为前缀的模式。</strong></strong></p><p><strong><strong>规则对“交集删除...”基于在一个正方形内单行或单列中某个数字的有限出现。这意味着该数字必须位于行或列的两个或三个单元格之一中；因此可以将其从该组所有其他单元格的候选集中删除。该模式会建立受限事件，然后为正方形外部和同一单元文件内的每个单元触发。</strong></strong></p><p><strong><strong>这些规则足以满足许多要求，但对所有Sudoku谜题而言，肯定不够。为了解决非常困难的网格，需要使用更复杂的规则来扩展规则集。（最终，只有通过反复试验才能解决的难题。）</strong></strong></p></div></div><div class="section" title="23.10。猜数字"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28128"></a> 23.10。猜数字</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Number Guess
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.numberguess.NumberGuessExample
<span class="bold"><strong>Module:</strong></span> droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.)
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> NumberGuess.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Rule Flow to organise Rules
</code></pre><p><strong><strong>“数字猜测”示例显示了规则流的使用，这是一种控制规则触发顺序的方法。它使用广泛理解的工作流图来定义规则组的执行顺序。</strong></strong></p><div class="example"><strong><strong><a id="d0e28152"></a><p class="title"><strong>示例23.67创建数字猜测规则规则库：NumberGuessExample.main（）-第1部分</strong></p><div class="example-contents"><pre><code class="language-java">final KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.drl",
                                                    ShoppingExample.class ),
              ResourceType.DRL );
kbuilder.add( ResourceFactory.newClassPathResource( "NumberGuess.rf",
                                                    ShoppingExample.class ),
              ResourceType.DRF );

final KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );</code></pre></div></strong></strong></div><strong><strong><br class="example-break"><p>包的创建和规则的加载（使用<code class="code">add()</code>方法）与前面的示例相同。还有一行添加规则流（ <code class="filename">NumberGuess.rf</code> ），它提供了为同一知识库指定不同规则流的选项。否则，将以与以前相同的方式创建知识库。</p><div class="example"><a id="d0e28165"></a><p class="title"><strong>示例23.68启动RuleFlow：NumberGuessExample.main（）-第2部分</strong></p><div class="example-contents"><pre><code class="language-java">final StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();

KnowledgeRuntimeLogger logger =
  KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "log/numberguess");

ksession.insert( new GameRules( 100, 5 ) );
ksession.insert( new RandomNumber() );
ksession.insert( new Game() );

ksession.startProcess( "Number Guess" );
ksession.fireAllRules();

logger.close();

ksession.dispose();</code></pre></div></div><br class="example-break"><p>一旦有了知识库，我们就可以使用它来获得有状态的会话。在我们的会话中，我们插入事实，即标准Java对象。（为简单起见，在此示例中，这些类都包含在我们的<code class="filename">NumberGuessExample.java</code>文件。类<code class="code">GameRules</code>提供最大范围和允许的猜测数量。类<code class="code">RandomNumber</code>通过插入，自动生成0到100之间的数字并将其提供给我们的规则<code class="code">getValue()</code>方法。类<code class="code">Game</code>跟踪我们之前所做的猜测及其数量。</p><p>请注意，在我们称为标准之前<code class="code">fireAllRules()</code>方法，我们还可以通过来启动之前加载的过程<code class="code">startProcess()</code>方法。当我们在下面讨论规则流文件和图形化的规则流编辑器时，我们将学习从何处获取传递的参数（“数字猜测”，即规则流的标识符）。</p><p>在结束对Java代码的讨论之前，我们注意到在某些实际应用程序中，我们将检查对象的最终状态。（在这里，我们可以检索猜测的数量，将其添加到高分表中。）对于此示例，我们很高兴通过调用以下命令来确保清除“工作内存”会话<code class="code">dispose()</code>方法。</p><div class="figure"><a id="d0e28200"></a><p class="title"><strong>图23.23。NumberGuess示例的RuleFlow</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/NumberGuessExample/numberguess-ruleflow.png" alt="NumberGuess示例的RuleFlow"></div></div></div><br class="figure-break"><p>如果您打开<code class="filename">NumberGuess.rf</code>在Drools IDE中提供文件（前提是您已在Eclipse中正确安装了JBoss Rules扩展），您应该看到上面的图表，类似于标准流程图。其图标与JBoss jBPM工作流产品中的图标相似（但不完全相同）。如果您希望编辑该图，则在IDE中该图的左侧应该有一个可用组件的菜单，称为<span class="emphasis"><em>调色板</em></span> 。此图使用XStream以（几乎）人类可读的格式保存为XML。</p><p>如果尚未打开，请确保“属性视图”在IDE中可见。可以通过单击“窗口”，然后单击“显示视图”和“其他”来打开它，您可以在其中选择“属性”视图。如果您<span class="emphasis"><em>在</em></span>选择规则流中的任何项目<span class="emphasis"><em>之前</em></span>执行此操作（或单击规则流中的空白），则应该看到以下属性集。</p><div class="figure"><a id="d0e28219"></a><p class="title"><strong>图23.24。数字猜测规则流的属性</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/NumberGuessExample/numberguess-ruleflow-properties.png" alt="数字猜测规则流的属性"></div></div></div><br class="figure-break"><p>在我们查看示例的规则流时，请密切注意“属性视图”，因为它会提供有价值的信息。在这种情况下，当我们调用时，它为我们提供了在先前代码段中使用的规则流过程的标识<code class="code">session.startProcess()</code> 。</p><p>在“数字猜测”规则流中，我们遇到几种节点类型，其中许多由图标标识。</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>“开始”节点（绿色圆圈中的白色箭头）和“结束”节点（红色框）标记了规则流的开始和结束。</p></li><li class="listitem"><p>“规则流组”框（黄色，无图标）表示在我们的规则（DRL）文件中定义的“规则流组”，我们将在以后查看。例如，当流到达规则流组“太高”时，只有那些标记为属性的规则<code class="literal">ruleflow-group</code><code class="code">"Too High"</code>可能会开火。</p></li><li class="listitem"><p>动作节点（黄色，呈齿轮状的图标）执行标准的Java方法调用。在此示例调用中，大多数操作节点<code class="code">System.out.println()</code> ，向用户指示程序的进度。</p></li><li class="listitem"><p>拆分和合并节点（蓝色椭圆形，无图标），例如“猜对了吗？”和“更多猜测加入”标记位置，控制流可以根据各种条件进行拆分，然后分别重新加入</p></li><li class="listitem"><p>箭头指示各个节点之间的流。</p></li></ul></div><p>各种节点与规则结合使Number Guess游戏发挥作用。例如，“猜测”规则流组仅允许触发“获取用户猜测”规则，因为只有该规则的匹配属性为<code class="literal">ruleflow-group</code><code class="code">"Guess"</code> 。</p><div class="example"><a id="d0e28266"></a><p class="title"><strong>示例23.69仅在规则流中的特定点触发规则：NumberGuess.drl</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Get user Guess"
    ruleflow-group "Guess"
    no-loop
    when
        $r : RandomNumber()
        rules : GameRules( allowed : allowedGuesses )
        game : Game( guessCount &lt; allowed )
        not ( Guess() )
    then
        System.out.println( "You have " + ( rules.allowedGuesses - game.guessCount )
                            + " out of " + rules.allowedGuesses
                            + " guesses left.\nPlease enter your guess from 0 to "
                            + rules.maxRange );
        br = new BufferedReader( new InputStreamReader( System.in ) );
        i = br.readLine();        
        modify ( game ) { guessCount = game.guessCount + 1 }
        insert( new Guess( i ) );
end</code></pre></div></div><br class="example-break"><p>该规则的其余部分相当标准。LHS部分（之后<code class="literal">when</code> ）的规则指出，它将针对每个<code class="code">RandomNumber</code>对象插入工作存储器中的位置<code class="code">guessCount</code>小于<code class="code">allowedGuesses</code>来自<code class="code">GameRules</code>对象以及用户未猜到正确数字的位置。</p><p>RHS部分（或结果，之后<code class="literal">then</code> ）向用户显示一条消息，然后等待用户输入<code class="code">System.in</code> 。获得此输入后（ <code class="code">readLine()</code>方法调用将阻塞，直到按下返回键为止），它会修改猜测计数并插入新的猜测，从而使两者都可用于工作内存。</p><p>规则文件的其余部分相当标准：该程序包将方言声明为MVEL，并导入了各种Java类。此文件中总共有五个规则：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>获取用户猜测，即我们上面检查过的规则。</p></li><li class="listitem"><p>记录最高猜测的规则。</p></li><li class="listitem"><p>记录最低猜测的规则。</p></li><li class="listitem"><p>用于检查猜测并从内存中撤回猜测的规则。</p></li><li class="listitem"><p>通知用户所有猜测已用尽的规则。</p></li></ol></div><p>标准规则和RuleFlow之间的集成点是通过<code class="literal">ruleflow-group</code>属性，如上文所述。<span class="emphasis"><em>规则（.drl）文件和规则流.rf文件之间集成</em></span>的<span class="emphasis"><em>第二点</em></span>是，拆分节点（蓝色椭圆形）可以使用工作内存（由规则更新）中的值来决定采取哪种行动采取。要查看其工作原理，请单击“猜测正确的节点”。然后在“属性”视图中，通过单击“约束”属性行上出现的右侧按钮，打开约束编辑器。您应该看到类似于下图的内容。</p><div class="figure"><a id="d0e28325"></a><p class="title"><strong>图23.25。编辑“猜测正确”节点的约束</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/NumberGuessExample/numberguess-editconstraints.png" alt="编辑约束" guess="" correc="=" =""></div></div></div><br class="figure-break"><p>单击“到节点太高”旁边的“编辑”按钮，您将看到类似以下的对话框。“文本编辑器”窗口中的值遵循LHS的标准规则格式，并且可以引用工作存储器中的对象。结果（RHS）是：如果LHS表达式的计算结果为true，则控制流遵循此节点（即，“到节点太高”）。</p><div class="figure"><a id="d0e28333"></a><p class="title"><strong>图23.26。“猜测正确”节点的约束编辑器：值太高</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/NumberGuessExample/numberguess-constraint-toohigh.png" alt="约束编辑器" value="" guess="" correc="=" =""></div></div></div><br class="figure-break"><p>自文件<code class="filename">NumberGuess.java</code>包含一个<code class="code">main()</code>方法，它可以从命令行或通过IDE作为标准Java应用程序运行。一个典型的游戏可能会导致下面的互动。粗体数字由用户输入。</p><div class="example"><a id="d0e28347"></a><p class="title"><strong>示例23.70在数字猜想示例击败人类的示例控制台输出中！</strong></p><div class="example-contents"><pre><code class="no-highlight">You have 5 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>50</strong></span>
Your guess was too high
You have 4 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>25</strong></span>
Your guess was too low
You have 3 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>37</strong></span>
Your guess was too low
You have 2 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>44</strong></span>
Your guess was too low
You have 1 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>47</strong></span>
Your guess was too low
You have no more guesses
The correct guess was 48 

</code></pre></div></div><br class="example-break"><p>此样本中发生的情况的摘要是：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>的<code class="code">main()</code>的方法<code class="filename">NumberGuessExample.java</code>加载规则库，创建有状态会话并插入<code class="code">Game</code> ， <code class="code">GameRules</code>和<code class="code">RandomNumber</code> （包含目标编号）对象。该方法还设置了我们将要使用的流程，并触发了所有规则。控制权传递给规则流。</p></li><li class="listitem"><p>文件<code class="filename">NumberGuess.rf</code> ，规则流，从“开始”节点开始。</p></li><li class="listitem"><p>控制（通过“更多猜测”连接节点）传递到Guess节点。</p></li><li class="listitem"><p>在Guess节点上，启用了适当的Rule Flow Group（“获取用户Guess”）。在这种情况下，“猜测”规则（在<code class="filename">NumberGuess.drl</code>文件）被触发。该规则向用户显示一条消息，获取响应，并将其放入“工作内存”中。流传递到下一个“规则流节点”。</p></li><li class="listitem"><p>在下一个节点“猜测正确”处，约束条件检查当前会话并决定采用哪个路径。</p><p>如果步骤4中的猜测过高或过低，流程将沿着一条路径前进，该路径具有一个动作节点，该动作节点具有打印适当消息的正常Java代码和一个规则流组，从而触发最高猜测或最低猜测规则。流程从这些节点转到步骤6。</p><p>如果第4步中的猜测是正确的，那么我们将沿着规则流的结尾继续前进。在到达那里之前，具有常规Java代码的操作节点将打印一条语句“您猜对了”。这里（在规则流结束之前）有一个连接节点，因此我们的猜测路径（步骤7）也可以终止规则流。</p></li><li class="listitem"><p>控制根据规则流通过连接节点，将不正确的猜测流组（触发规则以从工作内存中撤回猜测）传递到“更多猜测”决策节点上。</p></li><li class="listitem"><p>“更多猜测”决策节点（在规则流的右侧）使用约束，再次查看规则已放入工作内存中的值，以确定是否有更多猜测，如果有，则转到步骤3。如果不是，我们通过一个规则流组来触发规则流，该规则流组将触发一条规则，指出“您没有更多的猜测”。</p></li><li class="listitem"><p>继续执行第3步到第7步的循环，直到正确猜出该数字为止，否则我们用完所有的猜测。</p></li></ol></div></strong></strong></div><div class="section" title="23.11。康威的人生游戏"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28419"></a> 23.11。康威的人生游戏</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Conway's Game Of Life
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.conway.ConwayAgendaGroupRun
            org.drools.examples.conway.ConwayRuleFlowGroupRun
<span class="bold"><strong>Module:</strong></span> droolsjbpm-integration-examples (Note: this is in a different download, the droolsjbpm-integration download.)
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> conway-ruleflow.drl conway-agendagroup.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates 'accumulate', 'collect' and 'from'</code></pre><p><strong><strong>在<a class="link" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a>和<a class="link" href="http://www.math.com/students/wonders/life/life.html">http://www.math.com/students/wonders/life/life.html中</a>描述的Conway的“生命游戏”是一种著名的蜂窝自动机。在1970年代初由数学家约翰·康威（John Conway）创作。虽然该系统被称为“ Conway的生活游戏”，但它实际上根本不是游戏。康威的系统更像是一种生活形式的模拟。不要被吓到该系统非常简单，而且非常有趣。数学和计算机科学专业的学生都对Conway的系统赞叹不已，已有30多年的历史了。这里介绍的应用程序是Conway的《生命游戏》的基于Swing的实现。使用Drools将管理系统的规则作为业务规则实施。本文档将解释驱动仿真的规则，并讨论实现的Drools部分。</strong></strong></p><p><strong><strong>我们将首先介绍为游戏的可视化而设计的网格视图，如下所示，其中显示了模拟生活的“竞技场”。最初，网格是空的，这意味着系统中没有活动单元。每个细胞要么活着要么死了，活细胞显示一个绿色的球。可以从“模式”下拉列表中选择活细胞的预选模式。或者，可以双击单个单元格以在活动状态和死亡状态之间切换。重要的是要了解每个单元都与其相邻的单元相关，这对于游戏规则至关重要。邻居不仅包括左侧，右侧，顶部和底部的单元，还包括对角连接的单元，因此每个单元共有8个邻居。四个角单元只有三个邻居，并且沿四个边界的单元各有五个邻居，这是个例外。</strong></strong></p><div class="figure"><strong><strong><a id="d0e28451"></a><p class="title"><strong>图23.27。康威的人生游戏：开始一个新游戏</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/ConwaysGameOfLifeExample/conway1.png" alt="康威的人生游戏：开始一个新游戏"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>那么，控制该游戏的基本规则是什么？它的目标是显示一代又一代人口的发展。基于对所有单元格的同时评估，每一代都是从前一个生成的。这是控制下一代外观的简单规则集：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>如果一个活细胞的活邻居少于2个，它将死于寂寞。</p></li><li class="listitem"><p>如果一个活细胞有三个以上的活细胞，则死于拥挤。</p></li><li class="listitem"><p>如果一个死细胞正好有3个活着的邻居，那么它就可以复活。</p></li></ul></div><p>这就是全部。不满足任何这些条件的任何单元将保留给下一代。牢记这些简单的规则，然后回过头来玩一点系统，一次又一次地经历几代人，然后注意这些规则开始生效。</p><p>下面的屏幕快照显示了一个示例世代，其中包含许多活动单元格。不必担心匹配屏幕快照中显示的确切模式。只需将一些单元格组添加到网格即可。一旦在网格中有几组活动单元，或者选择了预先设计的模式，请单击“ Next Generation”按钮，然后注意会发生什么。一些活细胞被杀死（绿色球消失），一些死细胞复活（出现绿色球）。历经几代人，看看是否注意到任何模式。如果单击“开始”按钮，系统将自行发展，因此您无需反复单击“下一代”按钮。稍微玩一下系统，然后返回此处以获取有关应用程序工作方式的更多详细信息。</p><div class="figure"><a id="d0e28473"></a><p class="title"><strong>图23.28。康威的人生游戏：跑步游戏</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/ConwaysGameOfLifeExample/conway2.png" alt="康威的人生游戏：跑步游戏"></div></div></div><br class="figure-break"><p>现在让我们深入研究代码。因为这是一个高级示例，所以我们假设到现在为止您已经了解了Drools框架，并且能够连接呈现的重点内容，因此我们将只专注于高层概述。该示例有两种执行方式，一种使用议程组来管理执行流，另一种使用规则流组来管理执行流。这两个版本在<code class="code">ConwayAgendaGroupRun</code>和<code class="code">ConwayRuleFlowGroupRun</code> ， 分别。在这里，我们将讨论Rule Flow版本，因为这是大多数人会使用的版本。</p><p>所有的<code class="code">Cell</code>对象被插入到Session中，并且规则<code class="literal">ruleflow-group</code>规则流程允许“注册邻居”执行。这四个规则组创建<code class="code">Neighbor</code>某个单元与其东北，北部，西北和西部邻居之间的关系。这种关系是双向的，它负责其他四个方向。边界单元不需要任何特殊处理-它们根本不会与没有任何边界单元的相邻单元配对。到所有激活均已激活这些规则时，所有单元格都与其所有相邻单元格相关。</p><div class="example"><a id="d0e28498"></a><p class="title"><strong>示例23.71康威的人生游戏：注册细胞邻居关系</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "register north east"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )            
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )    
then                    
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );        
end

rule "register north"
    ruleflow-group "register neighbor"  
when
    $cell: Cell( $row : row, $col : col )   
    $north : Cell( row  == ($row - 1), col == $col )    
then        
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );        
end

rule "register north west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )           
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )                        
then        
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );        
end

rule "register west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row, $col : col )          
    $west : Cell( row  == $row, col == ( $col - 1 ) )                       
then        
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );         
end</code></pre></div></div><br class="example-break"><p>插入所有单元格后，一些Java代码将模式应用于网格，将某些单元格设置为Live。然后，当用户单击“开始”或“下一代”时，它将执行“生成”规则流。此规则流负责管理每个生成周期中单元的所有更改。</p><div class="figure"><a id="d0e28505"></a><p class="title"><strong>图23.29。康威的人生游戏：规则流“生成”</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/ConwaysGameOfLifeExample/conway_ruleflow_generation.png" alt="康威的人生游戏：规则流程" generatio="" =""></div></div></div><br class="figure-break"><p>规则流过程首先进入“评估”组，这意味着该组中的任何活动规则都可以触发。该组中的规则应用示例开头讨论的生命游戏规则，确定要杀死的细胞和要赋予生命的细胞。我们使用“阶段”属性通过特定的规则组来驱动单元的推理；通常，该阶段与“规则流”流程定义中的“规则流组”相关。请注意，它实际上并没有改变任何状态<code class="code">Cell</code>在这一点上反对这是因为它依次评估网格，并且必须完成完整评估，直到可以应用这些更改。为此，它将单元格设置为“阶段”，即<code class="code">Phase.KILL</code>要么<code class="code">Phase.BIRTH</code> ，稍后用于控制应用于<code class="code">Cell</code>宾语。</p><div class="example"><a id="d0e28525"></a><p class="title"><strong>示例23.72康威的人生游戏：通过状态变化评估细胞</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
when
//  A live cell has fewer than 2 live neighbors
    theCell: Cell( liveNeighbors &lt; 2, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
when
//  A live cell has more than 3 live neighbors
    theCell: Cell( liveNeighbors &gt; 3, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
when
//  A dead cell has 3 live neighbors
    theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD,
                   phase == Phase.EVALUATE )
then
    modify( theCell ){
        theCell.setPhase( Phase.BIRTH );
    }
end
</code></pre></div></div><br class="example-break"><p>全部一次<code class="code">Cell</code>网格中的对象已被评估，我们首先清除任何先前数据更改引起的任何计算激活。这是通过“重置计算”规则完成的，该规则清除了“计算”组中的所有激活。然后，我们在规则流中输入一个拆分，该拆分允许“ kill”和“ birth”组中的任何激活都被触发。这些规则负责应用状态更改。</p><div class="example"><a id="d0e28535"></a><p class="title"><strong>示例23.73康威的人生游戏：应用状态更改</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "reset calculate"
    ruleflow-group "reset calculate"
when
then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
when
    theCell: Cell( phase == Phase.KILL )
then
    modify( theCell ){
        setCellState( CellState.DEAD ),
        setPhase( Phase.DONE );   
    }
end 
 
rule "birth"
    ruleflow-group "birth"
    no-loop
when
    theCell: Cell( phase == Phase.BIRTH )
then
    modify( theCell ){
        setCellState( CellState.LIVE ),
        setPhase( Phase.DONE );
    }
end </code></pre></div></div><br class="example-break"><p>在这个阶段， <code class="code">Cell</code>对象已被修改，状态更改为<code class="code">LIVE</code>要么<code class="code">DEAD</code> 。现在我们来看看<code class="code">Neighbor</code>定义细胞关系的事实。当一个单元变成活的或死的时，我们使用<code class="code">Neighbor</code>遍历所有周围细胞的关系，增加或减少<code class="code">liveNeighbor</code>计数。任何其计数已更改的单元也将设置为<code class="code">EVALUATE</code>阶段，以确保在规则流过程的评估阶段将其包括在推理中。注意，我们不必自己进行任何迭代；只需通过在规则中应用关系，我们就可以使规则引擎用最少的代码为我们完成所有艰苦的工作。确定并设置所有单元的实时计数后，“规则流过程”就会结束。如果用户最初单击“开始”按钮，则引擎将重新启动规则流；否则，引擎将重新启动规则流。否则，用户可以请求另一代。</p><div class="example"><a id="d0e28563"></a><p class="title"><strong>示例23.74康威的生命游戏：用状态变化评估细胞</strong></p><div class="example-contents"><pre><code class="no-highlight">rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.LIVE )
    Neighbor( cell == theCell, $neighbor : neighbor ) 
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ),
        setPhase( Phase.EVALUATE );   
    }
end 

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell( cellState == CellState.DEAD )
    Neighbor( cell == theCell, $neighbor : neighbor )
then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ),
        setPhase( Phase.EVALUATE );
    }
end </code></pre></div></div><br class="example-break"></strong></strong></div><div class="section" title="23.12。侵略者"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28568"></a> 23.12。侵略者</strong></strong></h2></div></div></div><p><strong><strong>太空侵略者游戏的简化版本。使用Z和K键左右移动，使用M键发射导弹。该示例由6个项目组成，每个项目都为最后一个增加了一些复杂性。</strong></strong></p><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Example Invaders
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders1Main
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders2Main
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders3Main
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders4Main
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders5Main
<span class="bold"><strong>Main class:</strong></span> org.drools.games.invaders.Invaders6Main</code></pre><div class="figure"><strong><strong><a id="d0e28595"></a><p class="title"><strong>图23.30。傍截图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/Invaders/invaders.png" alt="傍截图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="23.12.1。侵略者1"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28601"></a> 23.12.1。侵略者1</h3></div></div></div><p>Invaders1Main创建框架并附加KeyListener，将关键事件输入引擎。它还设置了主游戏循环，可以在“ Main.drl”中找到该循环。在本示例中使用的典型约定是每个文件有一个议程组，并且该文件中的所有规则都在同一议程组中。</p><p>运行事实用于驱动游戏循环的重复。最初只有一组被评估，即密钥。“ keys.drl”文件由几个示例共享，并说明了在multipel项目中重复使用规则。</p><div class="example"><a id="d0e28608"></a><p class="title"><strong>示例23.75游戏循环</strong></p><div class="example-contents"><pre><code class="language-drl">
rule "init" when
then
    insert( new Run() );
    setFocus( "Init" );
end

rule GameLoop when
    r : Run()
then
    setFocus( "Keys" );
end


rule Draw when
    r : Run()
then
    ui.show();
    modify( r ) {} // force loop
end        
      </code></pre></div></div><br class="example-break"></div><div class="section" title="23.12.2。侵略者2"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28613"></a> 23.12.2。侵略者2</h3></div></div></div><p>Invaders2Main在游戏循环中添加“绘制”阶段并绘制“太空飞船”</p><div class="example"><a id="d0e28618"></a><p class="title"><strong>示例23.76游戏循环</strong></p><div class="example-contents"><pre><code class="language-drl">
rule GameLoop when
    r : Run()
then
    setFocus( "Draw" );
    setFocus( "Keys" );
end    
      </code></pre></div></div><br class="example-break"></div><div class="section" title="23.12.3。侵略者3"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28623"></a> 23.12.3。侵略者3</h3></div></div></div><p>Invaders3Main向飞船添加了移动控件，请注意飞船已移出屏幕边界。检测到KeyPressed，并在船方向上设置dx的增量。然后将该增量重复应用于船的x位置</p><div class="example"><a id="d0e28628"></a><p class="title"><strong>示例23.77搬船</strong></p><div class="example-contents"><pre><code class="language-drl">
rule ShipDeltaMoveLeft agenda-group "Move" when
    s : Ship()
        KeyPressed( keyText == "Z" )
then
    modify( s ) { dx = 0 - s.speed }
end

rule ShipDeltaStopLeft agenda-group "Move" when
    s : Ship()
        not KeyPressed( keyText == "Z" )
then
    modify( s ) { dx = 0 }
end

rule ShipMove agenda-group "Move" when
    s : Ship( dx != 0 )
    Run()
then
    modify( s ) { x = s.x + s.dx }
end
      </code></pre></div></div><br class="example-break"></div><div class="section" title="23.12.4。侵略者4"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28633"></a> 23.12.4。侵略者4</h3></div></div></div><p>Invaders4Main在ShipMove规则中添加了boundari控件，因此它不会移出屏幕。注意使用“ @watch（！x）”，这样可以确保在规则修改x属性时，它不会对x的更改做出反应，从而避免了递归问题。</p><div class="example"><a id="d0e28638"></a><p class="title"><strong>示例23.78带边界移动船</strong></p><div class="example-contents"><pre><code class="language-drl">
rule ShipMove agenda-group "Move" when
    s : Ship( dx != 0, x + dx &gt; 0,  x + dx + width &lt; conf.windowWidth ) @watch( !x )
    Run()
then
    modify( s ) { x = s.x + s.dx }
end
      </code></pre></div></div><br class="example-break"></div><div class="section" title="23.12.5。侵略者5"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28643"></a> 23.12.5。侵略者5</h3></div></div></div><p>Invaders5Main更新“绘图”组以绘制5个Invaders。</p></div><div class="section" title="23.12.6。侵略者6"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28648"></a> 23.12.6。侵略者6</h3></div></div></div><p>Invaders6Main添加了更多的肉。按下“ M”键可发射一枚飞过屏幕的导弹，同时检查导弹和入侵者之间的碰撞。</p></div><div class="section" title="23.12.7。侵略者4"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28653"></a> 23.12.7。侵略者4</h3></div></div></div><p>Invaders4Main在ShipMove规则中添加了boundari控件，因此它不会移出屏幕。注意使用“ @watch（！x）”，这样可以确保在规则修改x属性时，它不会对x的更改做出反应，从而避免了递归问题。</p><div class="example"><a id="d0e28658"></a><p class="title"><strong>示例23.79消防导弹</strong></p><div class="example-contents"><pre><code class="language-drl">
rule InsertBullet agenda-group "Bullet" when
        KeyPressed( keyText == "M" )
    s : Ship()
    not Bullet()
then
    b = new Bullet();
    b.x = s.x + (s.width/2) - (b.width/2);
    b.y = s.y - s.height - b.height;
    b.width = conf.bulletWidth;
    b.height = conf.bulletHeight;
    b.dy = 0 - conf.bulletSpeed;
    insert( b );
end


rule BulletMove agenda-group "Bullet" when
    b : Bullet( y &gt; 0 ) @watch( !y )
    Run()
then
    modify( b ) { y = b.y + b.dy }
end

rule Collision agenda-group "Bullet" when
    b : Bullet( ) @watch( y )
    i : Invader( x &lt; b.x, x + width &gt; b.x, y &gt; b.y)
    Run()
then
    modify( i ) { alive = false }
end
      </code></pre></div></div><br class="example-break"></div></strong></strong></div><div class="section" title="23.13。流口水的冒险"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28663"></a> 23.13。流口水的冒险</strong></strong></h2></div></div></div><p><strong><strong>基于Prolog中的Adventure，在Amzi网站（ <a class="link" href="http://www.amzi.com/AdventureInProlog/">http://www.amzi.com/AdventureInProlog/）上</a> ，我们开始为Drools开发一款文字冒险游戏。它们是理想的选择，因为它们可以从简单开始，并随着时间的推移增加复杂性和规模，而且还演示了声明性关系编程的关键方面。</strong></strong></p><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Example Text Adventure
<span class="bold"><strong>Main class:</strong></span> org.drools.games.adventure.TextAdventure</code></pre><p><strong><strong>游戏允许您扮演英雄或怪物的角色。如果单击“新窗口”，则可以打开一个窗口作为英雄，另一个窗口作为怪物，并同时播放它们。游戏允许角色在房间中四处移动，捡起，放下或使用东西。使用出口处的钥匙可以锁定和解锁门，英雄可以使用怪物上的雨伞杀死怪物。</strong></strong></p><p><strong><strong>您可以在<a class="link" href="http://downloads.jboss.org/drools/videos/text-adventures.swf">http://downloads.jboss.org/drools/videos/text-adventures.swf中</a>查看该示例的8分钟演示和介绍。请注意，视频现在比当前的改进示例要古老得多。</strong></strong></p><div class="figure"><strong><strong><a id="d0e28685"></a><p class="title"><strong>图23.31。文字冒险截图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/TextAdventureExample/textadventure.png" alt="文字冒险截图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="23.13.1。使用游戏。"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28691"></a> 23.13.1。使用游戏。</h3></div></div></div><p>每个操作都遵循关联的Command java类的构造函数参数。</p><div class="example"><a id="d0e28696"></a><p class="title"><strong>示例23.80移动命令</strong></p><div class="example-contents"><pre><code class="language-java">
  @PropertyReactive
  public class MoveCommand extends Command {
  
      @Position(1)
      private Character character;
  
      @Position(2)
      private Room      room;
  
      public MoveCommand(Character character, Room room) {
          this.character = character;
          this.room = room;
      }    
    </code></pre></div></div><br class="example-break"><p>要发出移动动作，请选择“移动”按钮，然后选择退出房间。请注意，当您按“移动”时，会将文本添加到底部的白色栏中。选择退出室后，它也会被添加到白色栏中。然后按发送，游戏引擎将执行命令。在内部，它使用反射实例化Command并将其插入引擎。如果您选择了不正确的参数，例如多次按下退出键，则反射将失败，您可以再次尝试。
  </p><div class="figure"><a id="d0e28703"></a><p class="title"><strong>图23.32。移动动作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/TextAdventureExample/MoveCommand.png" alt="移动动作"></div></div></div><br class="figure-break"><p>“事物”列表显示了您在房间中看到的任何东西，但并非可以拾取所有事物。例如，您可以拿起钥匙和手电筒，但不能拿起怪物。拾取物品后，物品将从“物品”列表移至“库存列表”。当某些东西掉落时，情况正好相反。</p><div class="figure"><a id="d0e28711"></a><p class="title"><strong>图23.33。接送动作</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/TextAdventureExample/PickUpCommand.png" alt="接送动作"></div></div></div><br class="figure-break"><p>钥匙在办公室，上楼然后进入办公室。然后拿起钥匙。回到楼下，进入厨房。尝试走进地下室，注意它已被锁定。</p><p>选择“使用”操作，选择键，然后选择地下室出口。这将打开门锁，您现在可以穿过。</p><p>要杀死怪物，请从休息室拿起雨伞，然后选择“使用”，然后选择雨伞，最后选择怪物。</p><p>不要忘记打开“新窗口”来扮演怪物，尽管直到英雄用钥匙打开地下室后您才可以退出地下室。怪物和英雄还可以互相分配物品，在每个玩家清单之间移动物品。</p></div><div class="section" title="23.13.2。代码"><div class="titlepage"><div><div><h3 class="title"><a id="d0e28725"></a> 23.13.2。代码</h3></div></div></div><p>该模型用Java类编写。每个类都使用@PropertyReactive和@Position。@PropertyReactive允许控制模式对哪些字段做出反应，@ Position将字段映射到参数位置，从而为模式提供位置和命名参数。</p><div class="example"><a id="d0e28730"></a><p class="title"><strong>示例23.81游戏世界数据示例</strong></p><div class="example-contents"><pre><code class="language-java">
@PropertyReactive
public class Thing {
    @Position(0)
    private long id;

    @Position(1)
    private String name;

    public Thing(long id, String name) {
        this.id = id;
        this.name = name;
    }
    ...
}
    </code></pre></div></div><br class="example-break"><p>MVEL数据文件用于填充我们的世界，请参阅“ data.mvel”。您可以编辑此文件以添加新房间，物品和角色以及门锁。</p><div class="example"><a id="d0e28737"></a><p class="title"><strong>示例23.82游戏世界数据示例</strong></p><div class="example-contents"><pre><code class="language-xml">
rooms = [
    "basement" : new Room("basement"),
    "lounge" : new Room("lounge"),
    "kitchen" : new Room("kitchen"),
    "ground floor hallway" : new Room("ground floor hallway"),
    "bedroom" : new Room("bedroom"),
    "office" : new Room("office"),
    "first floor hallway" : new Room("first floor hallway")
];

doors = [
    "d1" : new Door( rooms["kitchen"], rooms["basement"] ),
    "d2" : new Door( rooms["ground floor hallway"], rooms["lounge"]),
    "d4" : new Door( rooms["ground floor hallway"], rooms["kitchen"]),
    "d5" : new Door( rooms["ground floor hallway"], rooms[ "first floor hallway"] ),
    "d8" : new Door( rooms["first floor hallway"], rooms[ "bedroom"] ),
    "d9" : new Door( rooms["first floor hallway"], rooms[ "office"] )
];

locations = [
    "monster" :  new Location( characters["monster"], rooms["basement"] ),
    "hero" :  new Location( characters["hero"], rooms["ground floor hallway"] ),
    "umbrella" :  new Location( items["umbrella"], rooms["lounge"] ),
    "key1" :  new Location( items["key1"], rooms["office"] )
];
    </code></pre></div></div><br class="example-break"><p>游戏创建命令，并将其插入引擎。这些命令然后用于更改世界的状态，并且该状态会反映在UI中。这些命令可以在“ commands.drl”文件中找到。以下规则与MoveCommand相匹配，如果有效，它将进行移动。</p><div class="example"><a id="d0e28744"></a><p class="title"><strong>示例23.83移动角色</strong></p><div class="example-contents"><pre><code class="language-drl">
rule validMove agenda-group "commands" when
    mc : MoveCommand( c : character, r : room )
    l  : Location( thing == c, ltarget : target ) @watch( !target )
    ?connect( d, r, ltarget; )
then
    exit = new ExitEvent( c, (Room) l.target );
    enter = new EnterEvent( c, r );

    modify( l ) { target = r };

    insert( exit );
    insert( enter );

    mc.session.channels["output"].send( "You have entered the " + l.target.name + "\n" );
end
    </code></pre></div></div><br class="example-break"><p>在上述规则中，请注意“连接”模式，这实际上是一个查询。在MVEL数据文件门中仅描述了一种方式，我们可以使用查询来双向检查连接。这些查询可以在“ queries.drl”文件中找到。</p><div class="example"><a id="d0e28751"></a><p class="title"><strong>示例23.84连接</strong></p><div class="example-contents"><pre><code class="language-drl">
query connect( Door $d, Room $x, Room $y )
    $d := Door($id, $name, $x, $y;)
    or 
    $d :=Door($id, $name, $y, $x;)
end
    </code></pre></div></div><br class="example-break"><p>UI的列表框由“ UiView.drl”中的规则填充，这些规则又使用查询。当世界变化时，这里是“事物”列表框的填充方式。</p><div class="example"><a id="d0e28758"></a><p class="title"><strong>示例23.85更新用户界面</strong></p><div class="example-contents"><pre><code class="language-drl">
rule updateThings salience 5  when                            
    session : UserSession( $char : character )
    things( $char, $things; )                                                      
then
    session.channels["things"].send( $things );
end

query things(Character $char, List $things)
    $char := Character()
    Location( $char, $room; )
    $things := List() from accumulate( Location($thing, $room; thing != $char),
                                       collectList( $thing ) )      
end
    </code></pre></div></div><br class="example-break"></div></strong></strong></div><div class="section" title="23.14。傍"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28763"></a> 23.14。傍</strong></strong></h2></div></div></div><p><strong><strong>经典游戏Pong的转换。使用键A，Z和K，M。每次反弹后，球应变快。</strong></strong></p><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Example Pong
<span class="bold"><strong>Main class:</strong></span> org.drools.games.pong.PongMain</code></pre><div class="figure"><strong><strong><a id="d0e28775"></a><p class="title"><strong>图23.34。傍截图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/PongExample/pong.png" alt="傍截图"></div></div></strong></strong></div><strong><strong><br class="figure-break"></strong></strong></div><div class="section" title="23.15。乌鸦世界"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28781"></a> 23.15。乌鸦世界</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Example Wumpus World
<span class="bold"><strong>Main class:</strong></span> org.drools.games.wumpus.WumpusWorldMain</code></pre><p><strong><strong>Wumpus World是“人工智能：一种现代方法”一书中涵盖的AI示例。游戏首次开始时，所有单元格均变灰。当您走动时，它们变得可见。这个山洞有坑，金黄色的东西。当您靠近一个坑时，您会感到微风，当您靠近wumpus时，您会闻到一股恶臭，并在靠近黄金时看到闪光。传感器图标显示在“移动”按钮上方。如果走进坑坑洼洼，就会死。可以在<a class="link" href="http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml">http://www.cis.temple.edu/~giorgio/cis587/readings/wumpus.shtml</a>上找到Wumpus World的详细概述。有关如何创建和运行游戏的20分钟视频， <a class="link" href="http://www.youtube.com/watch?v=4CvjKqUOEzM">请访问http://www.youtube.com/watch?v=4CvjKqUOEzM。</a></strong></strong></p><div class="figure"><strong><strong><a id="d0e28798"></a><p class="title"><strong>图23.35。乌鸦世界</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/WumpusWorldExample/wumpus1.png" alt="乌鸦世界"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="figure"><a id="d0e28804"></a><p class="title"><strong>图23.36。洞穴截图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/WumpusWorldExample/wumpus2.png" alt="洞穴截图"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e28810"></a><p class="title"><strong>图23.37。信号截图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/WumpusWorldExample/wumpus3.png" alt="信号截图"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e28816"></a><p class="title"><strong>图23.38。气味恶臭</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/WumpusWorldExample/wumpus4.png" alt="气味恶臭"></div></div></div><br class="figure-break"><div class="figure"><a id="d0e28822"></a><p class="title"><strong>图23.39。向上移动，腹部碰撞</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/WumpusWorldExample/wumpus5.png" alt="向上移动，腹部碰撞"></div></div></div><br class="figure-break"></strong></strong></div><div class="section" title="23.16。礼貌小姐和标杆管理"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e28828"></a> 23.16。礼貌小姐和标杆管理</strong></strong></h2></div></div></div><pre><code class="no-highlight"><span class="bold"><strong>Name:</strong></span> Miss Manners
<span class="bold"><strong>Main class:</strong></span> org.drools.benchmark.manners.MannersBenchmark
<span class="bold"><strong>Module:</strong></span> drools-examples
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> manners.drl
<span class="bold"><strong>Objective:</strong></span> Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth.</code></pre><div class="section" title="23.16.1。介绍"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e28850"></a> 23.16.1。介绍</strong></strong></h3></div></div></div><p><strong><strong>Manners小姐正在举办一个聚会，作为一个好主持人，她想安排好座位。她最初的设计使每个人都成对布置，但后来她担心人们有话要说。好的主人是做什么的？她决定记下每个客人的爱好，这样她不仅可以根据交替的性别安排他们的配对，而且可以确保一个客人至少在一侧有共同的爱好。</strong></strong></p><div class="figure"><strong><strong><a id="d0e28855"></a><p class="title"><strong>图23.40。礼仪小姐的客人</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Examples/MannersExample/guests_at_table.png" align="middle" alt="礼仪小姐的客人"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="23.16.1.1。基准测试"><div class="titlepage"><div><div><h4 class="title"><a id="d0e28861"></a> 23.16.1.1。基准测试</h4></div></div></div><p>1991年，David Brant，Timothy Grose，Bernie Lofaso和Daniel P. Miranker在论文“数据库大小对规则系统性能的影响：五个案例研究”中建立了五个基准：</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>礼节</strong></span>采用深度优先的搜索方法来确定男女交替的座位安排，并确保邻居的共同爱好。</p></li><li class="listitem"><p><span class="bold"><strong>Waltz</strong></span>通过约束传播的线标注来建立线图的三维解释。</p></li><li class="listitem"><p><span class="bold"><strong>WaltzDB</strong></span>是Waltz的更通用版本，支持多于三行的结点并使用数据库。</p></li><li class="listitem"><p><span class="bold"><strong>ARP</strong></span>是使用A *搜索算法来实现最低成本的机器人飞行器路线规划器。</p></li><li class="listitem"><p><span class="bold"><strong>Weaver</strong></span> VLSI路由器使用黑板技术，用于通道和盒。</p></li></ul></div><p>礼节已经成为事实上的规则引擎基准。但是，它的行为现已众所周知，许多引擎对此进行了优化，从而否定了它作为基准的有用性，这就是为什么Waltz变得越来越受欢迎的原因。这五个基准测试也已在德克萨斯大学（ <a class="link" href="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/）上发布</a> 。</p></div><div class="section" title="23.16.1.2。礼仪小姐执行流程"><div class="titlepage"><div><div><h4 class="title"><a id="d0e28897"></a> 23.16.1.2。礼仪小姐执行流程</h4></div></div></div><p>在分配了第一个座位安排之后，将进行深度优先递归，该递归会重复分配正确的座位安排，直到分配了最后一个座位。礼节使用<code class="code">Context</code>实例来控制执行流程。活动图被分区以显示规则执行与当前关系<code class="code">Context</code>州。</p><div class="figure"><a id="d0e28908"></a><p class="title"><strong>图23.41。礼节活动图</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Examples/MannersExample/manners_activity_diagram.png" align="middle" alt="礼节活动图"></div></div></div><br class="figure-break"></div><div class="section" title="23.16.1.3。数据与结果"><div class="titlepage"><div><div><h4 class="title"><a id="d0e28914"></a> 23.16.1.3。数据与结果</h4></div></div></div><p>在深入研究规则之前，让我们首先看一下所断言的数据以及由此产生的座位安排。数据是一组简单的五位客人，应该安排这些客人，以便性别交替和邻居有共同的爱好。</p><p><span class="bold"><strong>数据</strong></span></p><p>数据以OPS5语法给出，并带有括号的每个属性的名称和值对列表。每个人只有一个爱好。</p><div class="literallayout"><p>（客人（名字n1）（性别m）（爱好h1））<br>（客人（名字n2）（性别f）（爱好h1））<br>（客人（名字n2）（性别f）（爱好h3））<br>（客人（名字n3）（性别m）（爱好h3））<br>（客人（名字n4）（性别m）（爱好h1））<br>（客人（名字n4）（性别f）（爱好h2））<br>（客人（名字n4）（性别f）（爱好h3））<br>（客人（名字n5）（性别f）（爱好h2））<br>（客人（名字n5）（性别f）（爱好h1））<br>（last_seat（seat 5））</p></div><p><span class="bold"><strong>结果</strong></span></p><p>结果列表的每一行都是按照“分配席位”规则执行的。他们要注意的关键一点是，每行的“ pid”值都比最后一行大一。（其重要性将在规则“分配座位”中进行解释。）“ ls”，“ rs”，“ ln”和“ rn”分别是指左右座位和邻居的名字。实际的实现使用更长的属性名称（例如， <code class="code">leftGuestName</code> ，但在这里我们将坚持原始实现的表示法。</p><div class="literallayout"><p>[就座id = 1，pid = 0，完成= true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4]<br>[座位ID = 3，pid = 2，完成= false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[座位ID = 4，pid = 3，完成=假，ls = 3，rn = n3，rs = 4，rn = n2]<br>[座位ID = 5，pid = 4，完成=假，ls = 4，ln = n2，rs = 5，rn = n1]</p></div></div></strong></strong></div><div class="section" title="23.16.2。深入讨论"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e28936"></a> 23.16.2。深入讨论</strong></strong></h3></div></div></div><div class="section" title="23.16.2.1。作弊"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e28939"></a> 23.16.2.1。作弊</strong></strong></h4></div></div></div><p><strong><strong>礼节旨在进行跨产品联接和议程活动。许多人不了解此调整示例以获得更好的性能，使他们的方式礼貌基准毫无意义。礼貌小姐的作弊或移植错误是：</strong></strong></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><strong><strong>将数组用于来宾爱好，而不是将每个数组都声明为单个事实，从而大大减少了叉积。</strong></strong></p></li><li class="listitem"><p><strong><strong>更改数据顺序还可以减少匹配量，提高执行速度。</strong></strong></p></li><li class="listitem"><p><strong><strong>可以更改<code class="literal">not</code>条件元素，以便测试算法仅使用“第一最佳匹配”，这基本上是将测试算法转换为反向链接。结果仅可与其他向后链接规则引擎或礼节港口相提并论。</strong></strong></p></li><li class="listitem"><p><strong><strong>删除上下文，以便规则引擎过早地匹配来宾和座位。正确的端口将防止使用上下文开头匹配事实。</strong></strong></p></li><li class="listitem"><p><strong><strong>有可能阻止规则引擎执行组合模式匹配。</strong></strong></p></li><li class="listitem"><p><strong><strong>如果在推理周期中没有撤回任何事实，则由于<code class="literal">not</code> CE，端口错误。</strong></strong></p></li></ul></div></div><div class="section" title="23.16.2.2。解决冲突"><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e28969"></a> 23.16.2.2。解决冲突</strong></strong></h4></div></div></div><p><strong><strong>方式基准是针对OPS5编写的，该基准具有两种冲突解决策略，即LEX和MEA。 LEX是一系列策略的链，包括显着性，新近度和复杂性。策略的新近度部分驱动深度优先（LIFO）触发顺序。CLIPS手册记录了新近度策略，如下所示：</strong></strong></p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>每个事实和实例在内部都标记有“时间标记”，以指示其相对于系统中其他每个事实和实例的相对新近度。与每个规则激活关联的模式实体按降序排序，以确定放置位置。具有较新模式实体的激活被置于具有较新模式实体的激活之前。要确定两个激活的放置顺序，请从最大的时间标记开始一一比较两个激活的排序时间标记。比较应继续进行，直到一个激活的时间标签大于另一个激活的相应时间标签为止。具有较大时间标签的激活被放在议程上的其他激活之前。如果一个激活比另一个激活具有更多的模式实体，并且比较的时间标签都相同，则将具有更多时间标签的激活放在议程上的另一个激活之前。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top"><span class="attribution">-CLIPS参考手册</span></td></tr></tbody></table></div><p><strong><strong>但是，Jess和CLIPS都使用深度策略，该策略更简单，更轻便，Drools也采用了这种策略。CLIPS手册将深度策略记录为：</strong></strong></p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>新激活的规则置于具有相同显着性的所有规则之上。例如，假设事实a激活规则1和规则2，事实b激活规则3和规则4，则如果在事实b之前声明事实a，则规则3和规则4将成为事实。在议程上的规则1和规则2之上。但是，rule-1相对于rule-2的位置和rule-3相对于rule-4的位置将是任意的。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top"><span class="attribution">-CLIPS参考手册</span></td></tr></tbody></table></div><p><strong><strong>不使用“ make_path”规则的显着性，深度策略的初始Drools实现将不适用于礼节。CLIPS支持团队这样说：</strong></strong></p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tbody><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>CLIPS的默认冲突解决策略Depth与OPS5使用的默认冲突解决策略不同。因此，如果您将OPS5程序直接转换为CLIPS，但使用默认的深度冲突解决策略，则仅可能通过巧合获得正确的行为。CLIPS中提供了LEX和MEA冲突解决策略，使您可以在CLIPS中快速转换并正确运行OPS5程序。</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">- <span class="attribution">剪辑支持论坛</span></td></tr></tbody></table></div><p><strong><strong>对CLIPS代码的调查表明，深度策略中有未记录的功能。此策略中使用了累积的时间标签；它不是像新近策略那样通过事实进行广泛的事实比较，它只是将每次激活的所有时间标签的总和相加并进行比较。</strong></strong></p></div><div class="section" title="23.16.2.3。规则" assignfirstsea="" =""><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e28995"></a> 23.16.2.3。规则“ assignFirstSeat”</strong></strong></h4></div></div></div><p><strong><strong>一旦上下文更改为<code class="code">START_UP</code> ，将为所有断言的来宾创建激活。由于所有激活都是通过单个“工作记忆”操作创建的，因此它们都具有相同的激活时间标签。最后断言<code class="code">Guest</code>对象将具有较高的事实时间标记，并且会激活它，因为它具有最高的累积事实时间标记。此规则中的执行顺序重要性不高，但对“分配席位”规则有很大影响。激活触发并断言第一个<code class="code">Seating</code>安排和<code class="code">Path</code> ，然后设置<code class="code">Context</code>属性<code class="code">state</code>创建规则激活<code class="code">findSeating</code> 。</strong></strong></p><pre><code class="no-highlight">rule assignFirstSeat
    when
        context : Context( state == Context.START_UP )
        guest : Guest()
        count : Count()
    then
        String guestName = guest.getName();
        
        Seating seating =
          new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName);
        insert( seating );
        
        Path path = new Path( count.getValue(), 1, guestName );
        insert( path );
        
        modify( count ) { setValue ( count.getValue() + 1 )  }

    System.out.println( "assign first seat :  " + seating + " : " + path );

        modify( context ) {
            setState( Context.ASSIGN_SEATS )
        } 
end</code></pre></div><div class="section" title="23.16.2.4。规则" findseatin="" =""><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e29023"></a> 23.16.2.4。规则“ findSeating”</strong></strong></h4></div></div></div><p><strong><strong>此规则确定每个<code class="code">Seating</code>安排。该规则为<span class="emphasis"><em>所有</em></span>断言创建跨产品解决方案<code class="code">Seating</code>针对<span class="emphasis"><em>所有</em></span>声称的客人的安排，除了针对自己或任何已分配的选定解决方案的客人。</strong></strong></p><pre><code class="no-highlight">rule findSeating
   when 
       context : Context( state == Context.ASSIGN_SEATS )
       $s      : Seating( pathDone == true )
       $g1     : Guest( name == $s.rightGuestName )
       $g2     : Guest( sex != $g1.sex, hobby == $g1.hobby )

       count   : Count()

       not ( Path( id == $s.id, guestName == $g2.name) )
       not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) )
   then
       int rightSeat = $s.getRightSeat();
       int seatId = $s.getId();
       int countValue = count.getValue();
       
       Seating seating =
         new Seating( countValue, seatId, false, rightSeat,
                      $s.getRightGuestName(), rightSeat + 1, $g2.getName() );
       insert( seating );
                            
       Path path = new Path( countValue, rightSeat + 1, $g2.getName()  );
       insert( path );
       
       Chosen chosen = new Chosen( seatId, $g2.getName(), $g1.getHobby() );
       insert( chosen  );

       System.err.println( "find seating : " + seating + " : " + path +
                           " : " + chosen);

       modify( count ) {setValue(  countValue + 1 )}
       modify( context ) {setState( Context.MAKE_PATH )}
end</code></pre><p><strong><strong>但是，从前面显示的打印结果可以看出，只有<code class="code">Seating</code>最高的<code class="code">pid</code>选择交叉产品。如果我们几乎所有现有的标签都具有相同时间标签的激活，那怎么可能<code class="code">Seating</code>和<code class="code">Guest</code>对象？例如，在<code class="code">findSeating</code>产生的激活将如下所示。请记住，这是从很小的数据集中获得的，而对于更大的数据集，将会有更多的可能被激活<code class="code">Seating</code>解决方案，每个解决方案有多个<code class="code">pid</code> ：</strong></strong></p><div class="literallayout"><p><strong><strong>=> [ActivationCreated（35）：rule = findSeating<br>[fid：19：33]：[座位ID = 3，pid = 2，done = true，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3]<br>[fid：3：3]：[来宾姓名= n2，性别= f，兴趣爱好= h3]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]</strong></strong></p></div><p><strong><strong>所有这些冗余激活的创建似乎都是毫无意义的，但必须记住，礼节并不是关于良好的规则设计的；它是关于规则设计的。故意将其设计为不好的规则集，以对跨产品匹配过程和议程进行充分的压力测试，这显然是这样做的。请注意，每次激活都具有相同的时间标记35，因为它们都是通过更改<code class="code">Context</code>反对<code class="code">ASSIGN_SEATS</code> 。使用OPS5和LEX，可以使用<code class="code">Seating</code>最后声明。使用深度，累积的事实时间标签可确保使用最后声明的激活<code class="code">Seating</code>火灾。</strong></strong></p></div><div class="section" title="23.16.2.5。规则" makepat="=" pathdon="" =""><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e29081"></a> 23.16.2.5。规则“ makePath”和“ pathDone”</strong></strong></h4></div></div></div><p><strong><strong>规则<code class="code">makePath</code>必须始终开火<code class="code">pathDone</code> 。一种<code class="code">Path</code>每个对象都被断言<code class="code">Seating</code>安排，直到最后声明<code class="code">Seating</code> 。请注意，条件在<code class="code">pathDone</code>是这些中的一部分<code class="code">makePath</code> -那么我们如何确保<code class="code">makePath</code>先开火？</strong></strong></p><pre><code class="no-highlight">rule makePath
    when 
        Context( state == Context.MAKE_PATH )
        Seating( seatingId:id, seatingPid:pid, pathDone == false )
        Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat )
        not Path( id == seatingId, guestName == pathGuestName )
    then
        insert( new Path( seatingId, pathSeat, pathGuestName ) );
end</code></pre><pre><code class="no-highlight">rule pathDone
    when
        context : Context( state == Context.MAKE_PATH ) 
        seating : Seating( pathDone == false ) 
    then
        modify( seating ) {setPathDone( true )} 
        
    modify( context ) {setState( Context.CHECK_DONE)}
end</code></pre><div class="figure"><strong><strong><a id="d0e29114"></a><p class="title"><strong>图23.42。网状图</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/Examples/MannersExample/make_path.png" align="middle" alt="网状图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><p>两条规则都在议程中冲突，并且具有相同的激活时间标签。但是，“ Make Path”的累积事实时间标签更大，因此它具有优先级。</p></strong></strong></div><div class="section" title="23.16.2.6。规则" continu="=" arewedon="" =""><div class="titlepage"><div><div><h4 class="title"><strong><strong><a id="d0e29122"></a> 23.16.2.6。规则“继续”和“ areWeDone”</strong></strong></h4></div></div></div><p><strong><strong>规则<code class="code">areWeDone</code>仅在分配了最后一个席位时激活，这时将同时激活两个规则。出于同样的原因<code class="code">makePath</code>总是赢<code class="code">path Done</code> ， <code class="code">areWeDone</code>将优先于规则<code class="code">continue</code> 。</strong></strong></p><pre><code class="no-highlight">rule areWeDone
    when
        context : Context( state == Context.CHECK_DONE ) 
        LastSeat( lastSeat: seat )
        Seating( rightSeat == lastSeat ) 
    then
        modify( context ) {setState(Context.PRINT_RESULTS )}
end
</code></pre><pre><code class="no-highlight">rule continue
    when
        context : Context( state == Context.CHECK_DONE ) 
    then
        modify( context ) {setState( Context.ASSIGN_SEATS )}
end
</code></pre></div></div><div class="section" title="23.16.3。输出汇总"><div class="titlepage"><div><div><h3 class="title"><strong><strong><a id="d0e29146"></a> 23.16.3。输出汇总</strong></strong></h3></div></div></div><div class="literallayout"><p><strong><strong><span class="bold"><strong>分配第一个席位</strong></span><br>=> [fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>=> [fid：14：14]：[路径ID = 1，座位= 1，访客= n5]<br>
<br>==> [ActivationCreated（16）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>==> [ActivationCreated（16）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1] *<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：15：17]：[座位ID = 2，pid = 1，完成=假，ls = 1，lg = n5，rs = 2，rn = n4]<br>=> [fid：16：18]：[路径ID = 2，座位= 2，访客= n4]<br>=> [fid：17：19]：[选择的ID = 1，名称= n4，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（21）：rule = makePath<br>[fid：15：17]：[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：14：14]：[路径ID = 1，座位= 1，访客= n5] *<br>
<br>==> [ActivationCreated（21）：rule = pathDone<br>[座位ID = 2，pid = 1，完成=假，ls = 1，ln = n5，rs = 2，rn = n4] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：18：22：[路径ID = 2，座位= 1，访客= n5]]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续进行</strong></span><br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：7：7]：[来宾姓名= n4，性别= f，兴趣爱好= h3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3] *<br>
<br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]，[fid：12：20]：[计数值= 3]<br>
<br>=> [ActivationCreated（25）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：19：26]：[座位ID = 3，pid = 2，完成= false，ls = 2，lnn4，rs = 3，rn = n3]]<br>=> [fid：20：27]：[路径ID = 3，座位= 3，访客= n3]]<br>=> [fid：21：28]：[选择的ID = 2，名称= n3，兴趣爱好= h3}]<br>
<br>=> [ActivationCreated（30）：rule = makePath<br>[fid：19：26]：[座位ID = 3，pid = 2，done = false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：18：22]：[路径ID = 2，座位= 1，访客= n5] *<br>
<br>=> [ActivationCreated（30）：rule = makePath<br>[fid：19：26]：[座位ID = 3，pid = 2，done = false，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：16：18]：[路径ID = 2，座位= 2，访客= n4] *<br>
<br>=> [ActivationCreated（30）：规则=完成<br>[fid：19：26]：[座位ID = 3，pid = 2，完成= false，ls = 2，ln = n4，rs = 3，rn = n3] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：22：31]：[路径ID = 3，座位= 1，访客= n5]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> [fid：23：32] [路径ID = 3，座位= 2，访客= n4]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续处理</strong></span><br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：19：33]：[座位ID = 3，pid = 2，done = true，ls = 2，ln = n4，rs = 3，rn = n3]<br>[fid：4：4]：[来宾姓名= n3，性别= m，兴趣爱好= h3]<br>[fid：3：3]：[来宾姓名= n2，性别= f，兴趣爱好= h3]，[fid：12：29] *<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（35）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，爱好= h1]，[fid：1：1]：[来宾姓名= n1，性别= m，爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：24：36]：[座位ID = 4，pid = 3，完成= false，ls = 3，ln = n3，rs = 4，rn = n2]]<br>=> [fid：25：37]：[路径ID = 4，座位= 4，访客= n2]]<br>=> [fid：26：38]：[选择的ID = 3，名称= n2，兴趣爱好= h3]<br>
<br>==> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：23：32]：[路径ID = 3，座位= 2，访客= n4] *<br>
<br>==> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：20：27]：[路径ID = 3，座位= 3，访客= n3] *<br>
<br>=> [ActivationCreated（40）：rule = makePath<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：22：31]：[路径ID = 3，座位= 1，访客= n5] *<br>
<br>=> [ActivationCreated（40）：规则=完成<br>[fid：24：36]：[座位ID = 4，pid = 3，完成=假，ls = 3，ln = n3，rs = 4，rn = n2] *<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：27：41：[路径ID = 4，座位= 2，访客= n4]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：28：42]：[路径ID = 4，座位= 1，访客= n5]]<br>
<br>
<span class="bold"><strong>建立路径</strong></span><br>=> fid：29：43]：[路径ID = 4，座位= 3，访客= n3]]<br>
<br>
<span class="bold"><strong>完成的路径</strong></span><br>
<br>
<span class="bold"><strong>继续处理</strong></span><br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：15：23]：[座位ID = 2，pid = 1，完成= true，ls = 1，ln = n5，rs = 2，rn = n4]<br>[fid：5：5]：[来宾姓名= n4，性别= m，兴趣爱好= h1]，[fid：2：2]<br>[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>
<br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：24：44]：[座位ID = 4，pid = 3，done = true，ls = 3，ln = n3，rs = 4，rn = n2]<br>[fid：2：2]：[来宾姓名= n2，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1] *<br>
<br>=> [ActivationCreated（46）：rule = findSeating<br>[fid：13：13]：[座位ID = 1，pid = 0，done = true，ls = 1，ln = n5，rs = 1，rn = n5]<br>[fid：9：9]：[来宾姓名= n5，性别= f，兴趣爱好= h1]<br>[fid：1：1]：[来宾姓名= n1，性别= m，兴趣爱好= h1]<br>
<br>
<span class="bold"><strong>分配座位</strong></span><br>=> [fid：30：47]：[座位ID = 5，pid = 4，完成=假，ls = 4，ln = n2，rs = 5，rn = n1]<br>=> [fid：31：48]：[路径ID = 5，座位= 5，访客= n1]<br>=> [fid：32：49]：[选择的ID = 4，名称= n1，兴趣爱好= h1]<br>
</strong></strong></p></div></div></div><div class="section" title="23.17。后向链"><div class="titlepage"><div><div><h2 class="title"><strong><strong><a id="d0e29201"></a> 23.17。后向链</strong></strong></h2></div></div></div><p><strong><strong>后向链接规则系统是目标驱动的。这意味着系统以发动机试图满足的结论开始。如果不能这样做，它将搜索子目标，即将完成部分当前目标的结论。它会继续此过程，直到满足初始结论或不再有不满意的子目标为止。
    <span class="bold"><strong>Prolog</strong></span>是向后链接引擎的示例。</strong></strong></p><div class="figure"><strong><strong><a id="d0e29209"></a><p class="title"><strong>图23.43。向后链接图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/BackwardChaining/BackwardChainingChart.png" alt="向后链接图"></div></div></strong></strong></div><strong><strong><br class="figure-break"><div class="section" title="23.17.1。后向链系统"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29215"></a> 23.17.1。后向链系统</h3></div></div></div><p>向后链接是最近添加到JBoss规则引擎的功能。此过程通常称为派生查询，与反应式系统相比并不常见，因为JBoss Rules主要是反应式正向链。也就是说，它响应您的数据更改。添加到引擎的反向链接用于类产品的派生。</p></div><div class="section" title="23.17.2。克隆传递性闭包"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29220"></a> 23.17.2。克隆传递性闭包</h3></div></div></div><div class="figure"><a id="d0e29223"></a><p class="title"><strong>图23.44。推理图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/BackwardChaining/ReasoningGraph.png" alt="推理图"></div></div></div><br class="figure-break"><p>上一张图表演示了House的传递项目示例。可以通过执行以下规则来创建类似的推理图：</p><p>1。首先，创建一些Java规则来开发可传递项的推理。它插入每个位置。</p><p>2。接下来，创建<span class="bold"><strong>Location</strong></span>类；它具有项目及其位置。</p><p>3。如下所示为“房屋”示例键入规则：</p><pre><code class="language-java">ksession.insert( new Location("office", "house") );
ksession.insert( new Location("kitchen", "house") );
ksession.insert( new Location("knife", "kitchen") );
ksession.insert( new Location("cheese", "kitchen") );
ksession.insert( new Location("desk", "office") );
ksession.insert( new Location("chair", "office") );
ksession.insert( new Location("computer", "desk") );
ksession.insert( new Location("drawer", "desk") );</code></pre><p>4。创建一个传递设计，其中项目位于其指定位置，例如位于“办公室”中的“办公桌”。</p><div class="figure"><a id="d0e29244"></a><p class="title"><strong>图23.45。房屋的及物推理图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/BackwardChaining/TransitiveReasoningGraph.png" alt="房屋的及物推理图"></div></div></div><br class="figure-break"></div><div class="section" title="23.17.3。定义查询"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29250"></a> 23.17.3。定义查询</h3></div></div></div><p>1。创建查询以查看插入到规则引擎中的数据：</p><pre><code class="no-highlight">query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</code></pre><p>注意查询是如何递归的，并调用“ isContainedIn”。</p><p>2。创建一条规则以打印出插入到系统中的每个字符串，以查看事物的实现方式。该规则应类似于以下格式：</p><pre><code class="no-highlight">rule "go" salience 10
when
  $s : String( )
then
  System.out.println( $s );
end</code></pre><p>3。使用步骤2作为模型，创建一个规则，该规则调用步骤1查询“ isContainedIn”。</p><pre><code class="no-highlight">rule "go1"
when
  String( this == "go1" )
  isContainedIn("office", "house"; )
then
  System.out.println( "office is in the house" );
end</code></pre><p>当第一个字符串插入引擎时，“ go1”规则将触发。即，询问项目“办公室”是否在位置“房屋”中。因此，当插入“ go1”字符串时，上一条规则将引发步骤1查询。</p><p>4。创建“ go1”，将其插入引擎，然后调用fireAllRules。</p><pre><code class="no-highlight">         ksession.insert( "go1" );
ksession.fireAllRules();
---
go1
office is in the house</code></pre><p>---线表示发动机输出与“ go”规则和“ go1”规则触发的分离。</p></div><div class="section" title="23.17.4。传递闭包示例"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29275"></a> 23.17.4。传递闭包示例</h3></div></div></div><p>1。通过执行以下规则来创建传递闭包：</p><pre><code class="no-highlight">rule "go2"
when
  String( this == "go2" )
  isContainedIn("drawer", "house"; )
then
  System.out.println( "Drawer in the House" );
end</code></pre><p>2。回想“克隆传递闭包”的主题，“房屋”中没有“抽屉”的实例。 “抽屉”位于“办公桌”中。</p><div class="figure"><a id="d0e29284"></a><p class="title"><strong>图23.46。抽屉的及物推理图</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Examples/BackwardChaining/TransitiveReasoningGraph2.png" alt="抽屉的及物推理图"></div></div></div><br class="figure-break"><p>3。使用上一个查询获取此递归信息。</p><pre><code class="no-highlight">query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</code></pre><p>4。创建“ go2”，将其插入引擎，然后调用fireAllRules。</p><pre><code class="no-highlight">ksession.insert( "go2" );
ksession.fireAllRules();
---
go2
Drawer in the House</code></pre><p>触发规则后，它会正确告诉您已插入“ go2”，并且“抽屉”位于“房屋”中。</p><p>5，检查引擎如何确定此结果</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>该查询必须向下递归几个级别才能确定。</p></li><li class="listitem"><p>该查询不使用<span class="bold"><strong>Location（x，y;）</strong></span> ，而是使用<span class="bold"><strong>（z，y;）</strong></span>的值，因为“抽屉”不在“房屋”中。</p></li><li class="listitem"><p><span class="bold"><strong>z</strong></span>当前未绑定，这意味着<span class="bold"><strong>z</strong></span>没有任何值，并将返回参数中的所有内容。</p></li><li class="listitem"><p><span class="bold"><strong>y</strong></span>当前绑定到“房子”，因此<span class="bold"><strong>z</strong></span>将返回“办公室”和“厨房”。</p></li><li class="listitem"><p>从“办公室”收集信息，并递归检查“抽屉”是否在“办公室”中。正在为这些参数调用以下查询行： <span class="bold"><strong>isContainedIn（x，z;）</strong></span></p></li></ul></div><p>在“办公室”中没有“抽屉”的实例；因此，它不匹配。取消绑定z时，它将返回“办公室”内的数据，并将收集<span class="bold"><strong>z == desk</strong></span> 。</p><pre><code class="no-highlight">isContainedIn(x==drawer, z==desk)</code></pre><p>isContainedIn重复三次。在最后的递归中，实例在“办公桌”中触发“抽屉”。</p><pre><code class="no-highlight"> Location(x==drawer, y==desk)</code></pre><p>这在第一个位置上匹配并重复备份，因此我们知道“抽屉”在“办公桌”中，“办公桌”在“办公室”中，“办公室”在“房屋”中；因此，“抽屉”在“房子”中并返回true。</p></div><div class="section" title="23.17.5。反应式传递查询"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29347"></a> 23.17.5。反应式传递查询</h3></div></div></div><p>1。通过执行以下规则来创建反应式传递查询：</p><pre><code class="no-highlight">rule "go3"
when
  String( this == "go3" )
  isContainedIn("key", "office"; )
then
  System.out.println( "Key in the Office" );
end</code></pre><p>即使无法满足答案，反应式传递查询也可以提出问题。稍后，如果满意，它将返回答案。</p><p>2。对此反应性信息使用相同的查询。</p><pre><code class="no-highlight">query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</code></pre><p>3。创建“ go3”，将其插入引擎，然后调用fireAllRules。</p><pre><code class="no-highlight">ksession.insert( "go3" );
ksession.fireAllRules();
---
go3</code></pre><p>与任何String匹配的第一个规则返回“ go3”，但由于没有答案，因此不返回任何其他内容；但是，在系统中插入“ go3”时，它将持续等待直到满意为止。</p><p>4。在“抽屉”中插入“钥匙”的新位置：</p><pre><code class="no-highlight">ksession.insert( new Location("key", "drawer") );
ksession.fireAllRules();
---
Key in the Office</code></pre><p>这个新位置满足传递闭包的要求，因为它正在监视整个图形。此外，此过程现在具有四个递归级别，可在其中进行匹配和触发规则。</p></div><div class="section" title="23.17.6。具有未绑定参数的查询"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29372"></a> 23.17.6。具有未绑定参数的查询</h3></div></div></div><p>1。通过执行以下规则来创建带有无界参数的查询：</p><pre><code class="no-highlight">rule "go4"
when
  String( this == "go4" )
  isContainedIn(thing, "office"; )
then
  System.out.println( "thing" + thing + "is in the Office" );
end</code></pre><p>此规则要求“办公室”中的所有内容，并将告诉下面所有行中的所有内容。在这个例子中，unbound参数（变量变量thing）将返回所有可能的值。因此，它与“反应式传递查询”示例中使用的z值非常相似。</p><p>2。将查询用于未绑定的参数。</p><pre><code class="no-highlight">query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</code></pre><p>3。创建“ go4”，将其插入引擎，然后调用fireAllRules。</p><pre><code class="no-highlight">ksession.insert( "go4" );
ksession.fireAllRules();
---
go4
thing Key is in the Office
thing Computer is in the Office
thing Drawer is in the Office
thing Desk is in the Office
thing Chair is in the Office</code></pre><p>插入“ go4”时，它将返回“ Office”下方的所有先前信息。</p></div><div class="section" title="23.17.7。多个未绑定参数"><div class="titlepage"><div><div><h3 class="title"><a id="d0e29391"></a> 23.17.7。多个未绑定参数</h3></div></div></div><p>1。通过实施以下规则，创建具有“多个未绑定参数”的查询：</p><pre><code class="no-highlight">rule "go5"
when
  String( this == "go5" )
  isContainedIn(thing, location; )
then
  System.out.println( "thing" + thing + "is in" + location );
end</code></pre><p>此规则要求“办公室”中的所有内容，并将告诉下面所有行中的所有内容。在这个例子中，unbound参数（变量变量thing）将返回所有可能的值。因此，它与“反应式传递查询”示例中使用的z值非常相似。</p><p><span class="bold"><strong>事物</strong></span>和<span class="bold"><strong>位置</strong></span>都是不受约束的变量，没有绑定参数，则一切都被调用。</p><p>2。将查询用于多个未绑定的参数。</p><pre><code class="no-highlight">query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</code></pre><p>3。创建“ go5”，将其插入引擎，然后调用fireAllRules。</p><pre><code class="no-highlight">ksession.insert( "go5" );
ksession.fireAllRules();
---
go5
thing Knife is in House
thing Cheese is in House
thing Key is in House
thing Computer is in House
thing Drawer is in House
thing Desk is in House
thing Chair is in House
thing Key is in Office
thing Computer is in Office
thing Drawer is in Office
thing Key is in Desk
thing Office is in House
thing Computer is in Desk
thing Knife is in Kitchen
thing Cheese is in Kitchen
thing Kitchen is in House
thing Key is in Drawer
thing Drawer is in Desk
thing Desk is in Office
thing Chair is in Office</code></pre><p>调用“ go5”时，它将返回所有内容。</p><p></p></div></strong></strong></div></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></body></html>